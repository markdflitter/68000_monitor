00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 17/04/2021 19:04:07

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          ;PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 00000000                 270  STACK   DC.L 0                                      ; STACK
00000004= 00000008                 271  RESET   DC.L START                                  ; RESET
00000008                           272  
00000008                           273  ; start of program  
00000008                           274  START
00000008  13FC 0000 00E00001       275      MOVE.B #0,DISPLAY
00000010                           276  
00000010                           277  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       278      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       279      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           280      
00000020                           281      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                282s     MOVE.W  #$50,D1
00000024  6000 000E                283s     BRA _20000001
00000028                           284s _20000000
00000028  13C1 00C00005            285          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     286          NOP
00000030                           287      ENDF
00000030  0441 0010                288s     SUB.W   #$10,D1
00000034                           289s _20000001
00000034  B27C 0010                290s     CMP.W   #$10,D1
00000038  6CEE                     291s     BGE _20000000
0000003A                           292  
0000003A                           293      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                294s     MOVE.W  #$50,D1
0000003E  6000 000E                295s     BRA _20000003
00000042                           296s _20000002
00000042  13C1 00C00015            297          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     298          NOP
0000004A                           299      ENDF
0000004A  0441 0010                300s     SUB.W   #$10,D1
0000004E                           301s _20000003
0000004E  B27C 0010                302s     CMP.W   #$10,D1
00000052  6CEE                     303s     BGE _20000002
00000054                           304      
00000054                           305  ;initialise UART
00000054  13FC 0000 00C00009       306      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       307      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       308      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           309  
0000006C                           310  ; channel A
0000006C  13FC 0013 00C00001       311      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       312      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       313      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       314      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           315  
0000008C                           316  ; channel B
0000008C  13FC 0013 00C00011       317      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       318      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       319      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       320      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           321  
000000AC                           322m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           323m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      324m     IFEQ DEBUG
000000AC  1239 00C00003            325m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                326m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     327m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       328m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           329m     ENDC
000000C0                           330m 
000000C0                 FALSE     331m     IFNE DEBUG
000000C0                           332m     ENDC
000000C0                           333m 
000000C0                           334m     ENDM
000000C0                           335m     PRINT_CHAR #0,D1
000000C0                           336m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      337m     IFEQ DEBUG
000000C0  1239 00C00003            338m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                339m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     340m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       341m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           342m     ENDC
000000D4                           343m 
000000D4                 FALSE     344m     IFNE DEBUG
000000D4                           345m     ENDC
000000D4                           346m 
000000D4                           347m     ENDM
000000D4                           348m     PRINT_CHAR #0,D1
000000D4                           349m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      350m     IFEQ DEBUG
000000D4  1239 00C00003            351m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                352m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     353m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       354m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           355m     ENDC
000000E8                           356m 
000000E8                 FALSE     357m     IFNE DEBUG
000000E8                           358m     ENDC
000000E8                           359m 
000000E8                           360m     ENDM
000000E8                           361  
000000E8  13FC 0001 00E00001       362      MOVE.B #1,DISPLAY
000000F0                           363  
000000F0                           364m     PRINT_CRLF D1,A0
000000F0  41FA 10C4                365m     LEA CRLF(PC),A0
000000F4                           366mm     PRINT_STR A0,D1
000000F4                           367mm LOOP_5
000000F4  0C10 0000                368mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                369mm     BEQ EXIT_5
000000FC                           370mmm     PRINT_CHAR (A0)+,D1
000000FC                           371mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      372mmm     IFEQ DEBUG
000000FC  1239 00C00003            373mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                374mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     375mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            376mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           377mmm     ENDC
0000010E                           378mmm 
0000010E                 FALSE     379mmm     IFNE DEBUG
0000010E                           380mmm     ENDC
0000010E                           381mmm 
0000010E                           382mmm     ENDM
0000010E  60E4                     383mm     BRA LOOP_5
00000110                           384mm EXIT_5
00000110                           385mm     ENDM
00000110                           386m     ENDM
00000110  41FA 10C8                387      LEA VERSION(PC),A0
00000114                           388m     PRINT_STR A0,D3
00000114                           389m LOOP_7
00000114  0C10 0000                390m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                391m     BEQ EXIT_7
0000011C                           392mm     PRINT_CHAR (A0)+,D3
0000011C                           393mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      394mm     IFEQ DEBUG
0000011C  1639 00C00003            395mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                396mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     397mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            398mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           399mm     ENDC
0000012E                           400mm 
0000012E                 FALSE     401mm     IFNE DEBUG
0000012E                           402mm     ENDC
0000012E                           403mm 
0000012E                           404mm     ENDM
0000012E  60E4                     405m     BRA LOOP_7
00000130                           406m EXIT_7
00000130                           407m     ENDM
00000130                           408  
00000130  41FA 0EBA                409      LEA HELPPROMPT(PC),A0
00000134                           410m     PRINT_STR A0,D3
00000134                           411m LOOP_9
00000134  0C10 0000                412m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                413m     BEQ EXIT_9
0000013C                           414mm     PRINT_CHAR (A0)+,D3
0000013C                           415mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      416mm     IFEQ DEBUG
0000013C  1639 00C00003            417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     419mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            420mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           421mm     ENDC
0000014E                           422mm 
0000014E                 FALSE     423mm     IFNE DEBUG
0000014E                           424mm     ENDC
0000014E                           425mm 
0000014E                           426mm     ENDM
0000014E  60E4                     427m     BRA LOOP_9
00000150                           428m EXIT_9
00000150                           429m     ENDM
00000150                           430  
00000150                           431m     PRINT_CRLF D3,A0
00000150  41FA 1064                432m     LEA CRLF(PC),A0
00000154                           433mm     PRINT_STR A0,D3
00000154                           434mm LOOP_12
00000154  0C10 0000                435mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                436mm     BEQ EXIT_12
0000015C                           437mmm     PRINT_CHAR (A0)+,D3
0000015C                           438mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      439mmm     IFEQ DEBUG
0000015C  1639 00C00003            440mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                441mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     442mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            443mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           444mmm     ENDC
0000016E                           445mmm 
0000016E                 FALSE     446mmm     IFNE DEBUG
0000016E                           447mmm     ENDC
0000016E                           448mmm 
0000016E                           449mmm     ENDM
0000016E  60E4                     450mm     BRA LOOP_12
00000170                           451mm EXIT_12
00000170                           452mm     ENDM
00000170                           453m     ENDM
00000170                           454  
00000170  7E00                     455      MOVE.L #0,D7                                    ; address accumulator
00000172                           456  
00000172  13FC 0002 00E00001       457      MOVE.B #2,DISPLAY
0000017A                           458  MAIN_LOOP
0000017A  41FA 103D                459      LEA PROMPT(PC),A0
0000017E                           460m     PRINT_STR A0,D3
0000017E                           461m LOOP_14
0000017E  0C10 0000                462m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                463m     BEQ EXIT_14
00000186                           464mm     PRINT_CHAR (A0)+,D3
00000186                           465mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      466mm     IFEQ DEBUG
00000186  1639 00C00003            467mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                468mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     469mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            470mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           471mm     ENDC
00000198                           472mm 
00000198                 FALSE     473mm     IFNE DEBUG
00000198                           474mm     ENDC
00000198                           475mm 
00000198                           476mm     ENDM
00000198  60E4                     477m     BRA LOOP_14
0000019A                           478m EXIT_14
0000019A                           479m     ENDM
0000019A                           480  
0000019A                           481  GET_INPUT
0000019A                           482m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           483m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      484m     IFEQ DEBUG
0000019A  1639 00C00003            485m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                486m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     487m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           488m     ENDC
000001A6                           489m 
000001A6                           490mm     READ_CHAR D2
000001A6                 TRUE      491mm     IFEQ DEBUG
000001A6  1439 00C00007            492mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           493mm     ENDC
000001AC                 FALSE     494mm     IFNE DEBUG
000001AC                           495mm     ENDC
000001AC                           496mm 
000001AC  B43C 001B                497mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                498mm     BEQ START
000001B4                           499mm     ENDM
000001B4                           500m 
000001B4                 TRUE      501m     IFEQ DEBUG
000001B4                           502mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           503mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      504mm     IFEQ DEBUG
000001B4  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                506mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     507mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            508mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           509mm     ENDC
000001C6                           510mm 
000001C6                 FALSE     511mm     IFNE DEBUG
000001C6                           512mm     ENDC
000001C6                           513mm 
000001C6                           514mm     ENDM
000001C6                           515m     ENDC
000001C6                           516m     ENDM
000001C6                           517  
000001C6                           518      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                519s     CMP.B   #'0',D2
000001CA  6D00 000E                520s     BLT _00000000
000001CE  B43C 0039                521s     CMP.B   #'9',D2
000001D2  6E00 0006                522s     BGT _00000000
000001D6  6000 0DF6                523          BRA HEX_DIGIT
000001DA                           524      ENDI
000001DA                           525s _00000000
000001DA                           526      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                527s     CMP.B   #'A',D2
000001DE  6D00 000E                528s     BLT _00000001
000001E2  B43C 0046                529s     CMP.B   #'F',D2
000001E6  6E00 0006                530s     BGT _00000001
000001EA  6000 0DE2                531          BRA HEX_DIGIT
000001EE                           532      ENDI
000001EE                           533s _00000001
000001EE                           534  
000001EE  B43C 0077                535      CMP.B #'w',D2
000001F2  6700 019A                536      BEQ W
000001F6                           537  
000001F6  B43C 006C                538      CMP.B #'l',D2
000001FA  6700 0902                539      BEQ L 
000001FE                           540  
000001FE  B43C 0070                541      CMP.B #'p',D2
00000202  6700 0B2A                542      BEQ P
00000206                           543  
00000206  B43C 006D                544      CMP.B #'m',D2
0000020A  6700 0CF4                545      BEQ M
0000020E                           546  
0000020E                           547m     PRINT_CRLF D3,A0
0000020E  41FA 0FA6                548m     LEA CRLF(PC),A0
00000212                           549mm     PRINT_STR A0,D3
00000212                           550mm LOOP_20
00000212  0C10 0000                551mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                552mm     BEQ EXIT_20
0000021A                           553mmm     PRINT_CHAR (A0)+,D3
0000021A                           554mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      555mmm     IFEQ DEBUG
0000021A  1639 00C00003            556mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                557mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     558mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            559mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           560mmm     ENDC
0000022C                           561mmm 
0000022C                 FALSE     562mmm     IFNE DEBUG
0000022C                           563mmm     ENDC
0000022C                           564mmm 
0000022C                           565mmm     ENDM
0000022C  60E4                     566mm     BRA LOOP_20
0000022E                           567mm EXIT_20
0000022E                           568mm     ENDM
0000022E                           569m     ENDM
0000022E                           570   
0000022E  B43C 003F                571      CMP.B #'?',D2
00000232  6700 0056                572      BEQ H
00000236                           573   
00000236  B43C 0076                574      CMP.B #'v',D2
0000023A  6700 0056                575      BEQ V
0000023E                           576      
0000023E  B43C 0072                577      CMP.B #'r',D2
00000242  6700 0072                578      BEQ R
00000246                           579  
00000246  B43C 0073                580      CMP.B #'s',D2
0000024A  6700 01B6                581      BEQ S
0000024E                           582  
0000024E  B43C 0067                583      CMP.B #'g',D2
00000252  6700 07B2                584      BEQ G   
00000256                           585  
00000256  B43C 007A                586      CMP.B #'z',D2
0000025A  6700 07B2                587      BEQ Z   
0000025E                           588  
0000025E  B43C 006A                589      CMP.B #'j',D2
00000262  6700 0D34                590      BEQ j
00000266                           591  
00000266  41FA 0EAF                592      LEA HUH(PC),A0
0000026A                           593m     PRINT_STR A0,D3
0000026A                           594m LOOP_22
0000026A  0C10 0000                595m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000026E  6700 0016                596m     BEQ EXIT_22
00000272                           597mm     PRINT_CHAR (A0)+,D3
00000272                           598mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000272                 TRUE      599mm     IFEQ DEBUG
00000272  1639 00C00003            600mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000278  0803 0002                601mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000027C  67F4                     602mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000027E  13D8 00C00007            603mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000284                           604mm     ENDC
00000284                           605mm 
00000284                 FALSE     606mm     IFNE DEBUG
00000284                           607mm     ENDC
00000284                           608mm 
00000284                           609mm     ENDM
00000284  60E4                     610m     BRA LOOP_22
00000286                           611m EXIT_22
00000286                           612m     ENDM
00000286                           613  
00000286  6000 FEF2                614      BRA MAIN_LOOP
0000028A                           615  
0000028A                           616  ; commands
0000028A                           617  H
0000028A  41FA 0D73                618      LEA HELP(PC),A0
0000028E  6000 0006                619      BRA PRINTSTR
00000292                           620  
00000292                           621  V
00000292  41FA 0F46                622      LEA VERSION(PC),A0
00000296                           623  PRINTSTR
00000296                           624m     PRINT_STR A0,D3    
00000296                           625m LOOP_24
00000296  0C10 0000                626m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000029A  6700 0016                627m     BEQ EXIT_24
0000029E                           628mm     PRINT_CHAR (A0)+,D3
0000029E                           629mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029E                 TRUE      630mm     IFEQ DEBUG
0000029E  1639 00C00003            631mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002A4  0803 0002                632mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A8  67F4                     633mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002AA  13D8 00C00007            634mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002B0                           635mm     ENDC
000002B0                           636mm 
000002B0                 FALSE     637mm     IFNE DEBUG
000002B0                           638mm     ENDC
000002B0                           639mm 
000002B0                           640mm     ENDM
000002B0  60E4                     641m     BRA LOOP_24
000002B2                           642m EXIT_24
000002B2                           643m     ENDM
000002B2  6000 FEC6                644      BRA MAIN_LOOP
000002B6                           645  
000002B6                           646  R
000002B6  2047                     647      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B8  7E00                     648      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002BA  2410                     649      MOVE.L (A0),D2                                  ; read the memory and print it
000002BC                           650m     PRINT_REG D2,D3,D4,D5,A0
000002BC  41FA 0EFE                651m     LEA OX(PC),A0
000002C0                           652mm     PRINT_STR A0,D3
000002C0                           653mm LOOP_27
000002C0  0C10 0000                654mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002C4  6700 0016                655mm     BEQ EXIT_27
000002C8                           656mmm     PRINT_CHAR (A0)+,D3
000002C8                           657mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C8                 TRUE      658mmm     IFEQ DEBUG
000002C8  1639 00C00003            659mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002CE  0803 0002                660mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002D2  67F4                     661mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002D4  13D8 00C00007            662mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002DA                           663mmm     ENDC
000002DA                           664mmm 
000002DA                 FALSE     665mmm     IFNE DEBUG
000002DA                           666mmm     ENDC
000002DA                           667mmm 
000002DA                           668mmm     ENDM
000002DA  60E4                     669mm     BRA LOOP_27
000002DC                           670mm EXIT_27
000002DC                           671mm     ENDM
000002DC  7A07                     672m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002DE                           673m LOOP_26
000002DE                           674mm     BIN2HEX D2,D4,A0
000002DE  41FA 0E9B                675mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002E2  E99A                     676mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002E4  1802                     677mm     MOVE.B D2,D4
000002E6  0284 0000000F            678mm     ANDI.L #$F,D4
000002EC  1830 4000                679mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002F0                           680mm     ENDM
000002F0                           681mm     PRINT_CHAR D4,D3
000002F0                           682mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F0                 TRUE      683mm     IFEQ DEBUG
000002F0  1639 00C00003            684mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002F6  0803 0002                685mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002FA  67F4                     686mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002FC  13C4 00C00007            687mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000302                           688mm     ENDC
00000302                           689mm 
00000302                 FALSE     690mm     IFNE DEBUG
00000302                           691mm     ENDC
00000302                           692mm 
00000302                           693mm     ENDM
00000302  57CD FFDA                694m     DBEQ D5,LOOP_26
00000306                           695m     ENDM
00000306                           696      
00000306                           697m     PRINT_CHAR #32,D3
00000306                           698m WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000306                 TRUE      699m     IFEQ DEBUG
00000306  1639 00C00003            700m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000030C  0803 0002                701m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000310  67F4                     702m         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000312  13FC 0020 00C00007       703m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000031A                           704m     ENDC
0000031A                           705m 
0000031A                 FALSE     706m     IFNE DEBUG
0000031A                           707m     ENDC
0000031A                           708m 
0000031A                           709m     ENDM
0000031A                           710  
0000031A  E19A                     711      ROL.L #8,D2
0000031C                           712m     PRINT_CHAR D2,D3
0000031C                           713m WAIT_FOR_READY_32                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031C                 TRUE      714m     IFEQ DEBUG
0000031C  1639 00C00003            715m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000322  0803 0002                716m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000326  67F4                     717m         BEQ WAIT_FOR_READY_32                       ; NO SPACE, CHECK AGAIN
00000328  13C2 00C00007            718m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000032E                           719m     ENDC
0000032E                           720m 
0000032E                 FALSE     721m     IFNE DEBUG
0000032E                           722m     ENDC
0000032E                           723m 
0000032E                           724m     ENDM
0000032E  E19A                     725      ROL.L #8,D2
00000330                           726m     PRINT_CHAR D2,D3
00000330                           727m WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000330                 TRUE      728m     IFEQ DEBUG
00000330  1639 00C00003            729m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000336  0803 0002                730m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000033A  67F4                     731m         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000033C  13C2 00C00007            732m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000342                           733m     ENDC
00000342                           734m 
00000342                 FALSE     735m     IFNE DEBUG
00000342                           736m     ENDC
00000342                           737m 
00000342                           738m     ENDM
00000342  E19A                     739      ROL.L #8,D2
00000344                           740m     PRINT_CHAR D2,D3
00000344                           741m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000344                 TRUE      742m     IFEQ DEBUG
00000344  1639 00C00003            743m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000034A  0803 0002                744m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000034E  67F4                     745m         BEQ WAIT_FOR_READY_34                       ; NO SPACE, CHECK AGAIN
00000350  13C2 00C00007            746m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000356                           747m     ENDC
00000356                           748m 
00000356                 FALSE     749m     IFNE DEBUG
00000356                           750m     ENDC
00000356                           751m 
00000356                           752m     ENDM
00000356  E19A                     753      ROL.L #8,D2
00000358                           754m     PRINT_CHAR D2,D3
00000358                           755m WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000358                 TRUE      756m     IFEQ DEBUG
00000358  1639 00C00003            757m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000035E  0803 0002                758m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000362  67F4                     759m         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
00000364  13C2 00C00007            760m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000036A                           761m     ENDC
0000036A                           762m 
0000036A                 FALSE     763m     IFNE DEBUG
0000036A                           764m     ENDC
0000036A                           765m 
0000036A                           766m     ENDM
0000036A                           767  
0000036A                           768m     PRINT_CRLF D3,A0
0000036A  41FA 0E4A                769m     LEA CRLF(PC),A0
0000036E                           770mm     PRINT_STR A0,D3
0000036E                           771mm LOOP_37
0000036E  0C10 0000                772mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000372  6700 0016                773mm     BEQ EXIT_37
00000376                           774mmm     PRINT_CHAR (A0)+,D3
00000376                           775mmm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000376                 TRUE      776mmm     IFEQ DEBUG
00000376  1639 00C00003            777mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000037C  0803 0002                778mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000380  67F4                     779mmm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
00000382  13D8 00C00007            780mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000388                           781mmm     ENDC
00000388                           782mmm 
00000388                 FALSE     783mmm     IFNE DEBUG
00000388                           784mmm     ENDC
00000388                           785mmm 
00000388                           786mmm     ENDM
00000388  60E4                     787mm     BRA LOOP_37
0000038A                           788mm EXIT_37
0000038A                           789mm     ENDM
0000038A                           790m     ENDM
0000038A                           791      
0000038A  6000 FDEE                792      BRA MAIN_LOOP
0000038E                           793  
0000038E                           794  W
0000038E  3C3C 0007                795      MOVE #7,D6                                      ; 7 bytes left to read
00000392                           796      
00000392                           797  READ_DATA_TO_POKE
00000392  E98D                     798      LSL.L #4,D5                                     ; make what we have so far more significant
00000394                           799m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000394                           800m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000394                 TRUE      801m     IFEQ DEBUG
00000394  1639 00C00003            802m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000039A  0803 0000                803m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000039E  67F4                     804m         BEQ WAIT_FOR_READY_39                       ; NOTHING, CHECK AGAIN
000003A0                           805m     ENDC
000003A0                           806m 
000003A0                           807mm     READ_CHAR D2
000003A0                 TRUE      808mm     IFEQ DEBUG
000003A0  1439 00C00007            809mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000003A6                           810mm     ENDC
000003A6                 FALSE     811mm     IFNE DEBUG
000003A6                           812mm     ENDC
000003A6                           813mm 
000003A6  B43C 001B                814mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000003AA  6700 FC5C                815mm     BEQ START
000003AE                           816mm     ENDM
000003AE                           817m 
000003AE                 TRUE      818m     IFEQ DEBUG
000003AE                           819mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000003AE                           820mm WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003AE                 TRUE      821mm     IFEQ DEBUG
000003AE  1639 00C00003            822mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003B4  0803 0002                823mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003B8  67F4                     824mm         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003BA  13C2 00C00007            825mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003C0                           826mm     ENDC
000003C0                           827mm 
000003C0                 FALSE     828mm     IFNE DEBUG
000003C0                           829mm     ENDC
000003C0                           830mm 
000003C0                           831mm     ENDM
000003C0                           832m     ENDC
000003C0                           833m     ENDM
000003C0                           834m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000003C0  41FA 0DC9                835m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003C4  0402 0030                836m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C8  C4BC 000000FF            837m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000003CE  1430 2000                838m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000003D2                           839m     ENDM
000003D2  8A02                     840      OR.B D2,D5
000003D4  57CE FFBC                841      DBEQ D6,READ_DATA_TO_POKE
000003D8                           842      
000003D8  2047                     843      MOVE.L D7,A0                                    ; address accumulator -> address register
000003DA  7E00                     844      MOVE.L #0,D7                                    ; clear the now used address accumulator
000003DC                           845      
000003DC  2085                     846      MOVE.L D5,(A0)                                  ; write the data
000003DE                           847  
000003DE                           848m     PRINT_CRLF D3,A0
000003DE  41FA 0DD6                849m     LEA CRLF(PC),A0
000003E2                           850mm     PRINT_STR A0,D3
000003E2                           851mm LOOP_44
000003E2  0C10 0000                852mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003E6  6700 0016                853mm     BEQ EXIT_44
000003EA                           854mmm     PRINT_CHAR (A0)+,D3
000003EA                           855mmm WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003EA                 TRUE      856mmm     IFEQ DEBUG
000003EA  1639 00C00003            857mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003F0  0803 0002                858mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003F4  67F4                     859mmm         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
000003F6  13D8 00C00007            860mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003FC                           861mmm     ENDC
000003FC                           862mmm 
000003FC                 FALSE     863mmm     IFNE DEBUG
000003FC                           864mmm     ENDC
000003FC                           865mmm 
000003FC                           866mmm     ENDM
000003FC  60E4                     867mm     BRA LOOP_44
000003FE                           868mm EXIT_44
000003FE                           869mm     ENDM
000003FE                           870m     ENDM
000003FE  6000 FD7A                871      BRA MAIN_LOOP
00000402                           872  
00000402                           873  ; register map for S
00000402                           874  ; A0 - start address
00000402                           875  ; A1 - offset
00000402                           876  ; A2 - next address to write
00000402                           877  ; A3 - next location (jmp)
00000402                           878  ; A4 - Working Address Register
00000402                           879  ; D0 - record count
00000402                           880  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000402                           881  ; D2 - checksum
00000402                           882  ; D3 - data byte count
00000402                           883  ; D4 - read address, moved into A2
00000402                           884  ; D5 - temp
00000402                           885  ; D6 - temp
00000402                           886  ; D7 - temp
00000402                           887  S
00000402  2078 0000                888      MOVE.L 0,A0                                     ; start address -> A0
00000406  2247                     889      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000408                           890      
00000408  7000                     891      MOVE.L #0,D0                                    ; count of records read -> D0
0000040A                           892          
0000040A                           893  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000040A                           894m     DOWNLOAD D1
0000040A                           895m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000040A                           896m 
0000040A  1239 00C00003            897m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000410  0801 0000                898m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000414  6700 0010                899m     BEQ CONTINUE_46                                 ; NOTHING, CONTINUE
00000418                           900m 
00000418                           901mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000418                 TRUE      902mm     IFEQ DEBUG
00000418  1239 00C00007            903mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000041E                           904mm     ENDC
0000041E                 FALSE     905mm     IFNE DEBUG
0000041E                           906mm     ENDC
0000041E                           907mm 
0000041E  B23C 001B                908mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000422  6700 FBE4                909mm     BEQ START
00000426                           910mm     ENDM
00000426                           911m CONTINUE_46
00000426  1239 00C00013            912m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000042C  0801 0000                913m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000430  67D8                     914m     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
00000432                           915m     
00000432  1239 00C00017            916m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000438  13C1 00E00001            917m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000043E                           918m 
0000043E                           919m     ENDM
0000043E  B23C 0053                920      CMP.B #'S',D1                                   ; found S?
00000442  66C6                     921      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000444                           922      
00000444                           923      ;PRINT_CHAR #'S',D5                             ; print the S
00000444  5280                     924      ADD.L #1,D0                                     ; read another S record, increment count
00000446                           925      
00000446                           926m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000446                           927m WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000446                           928m 
00000446  1239 00C00003            929m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000044C  0801 0000                930m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000450  6700 0010                931m     BEQ CONTINUE_48                                 ; NOTHING, CONTINUE
00000454                           932m 
00000454                           933mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000454                 TRUE      934mm     IFEQ DEBUG
00000454  1239 00C00007            935mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000045A                           936mm     ENDC
0000045A                 FALSE     937mm     IFNE DEBUG
0000045A                           938mm     ENDC
0000045A                           939mm 
0000045A  B23C 001B                940mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000045E  6700 FBA8                941mm     BEQ START
00000462                           942mm     ENDM
00000462                           943m CONTINUE_48
00000462  1239 00C00013            944m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000468  0801 0000                945m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000046C  67D8                     946m     BEQ WAIT_FOR_READY_48                           ; NOTHING, CHECK AGAIN
0000046E                           947m     
0000046E  1239 00C00017            948m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000474  13C1 00E00001            949m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000047A                           950m 
0000047A                           951m     ENDM
0000047A                           952      ;PRINT_CHAR D1,D5
0000047A                           953  
0000047A  7400                     954      MOVE.L #0,D2                                    ; clear the checksum
0000047C                           955  
0000047C                           956m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000047C  1E3C 0002                957m     MOVE.B #2,D7
00000480                           958m     WHILE.B D7 <GT> 0 DO
00000480                           959ms _10000000
00000480  BE38 0000                960ms     CMP.B   0,D7
00000484  6F00 0050                961ms     BLE _10000001
00000488  E98B                     962m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000048A                           963mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000048A                           964mm WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048A                           965mm 
0000048A  1A39 00C00003            966mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000490  0805 0000                967mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000494  6700 0010                968mm     BEQ CONTINUE_51                                 ; NOTHING, CONTINUE
00000498                           969mm 
00000498                           970mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000498                 TRUE      971mmm     IFEQ DEBUG
00000498  1A39 00C00007            972mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000049E                           973mmm     ENDC
0000049E                 FALSE     974mmm     IFNE DEBUG
0000049E                           975mmm     ENDC
0000049E                           976mmm 
0000049E  BA3C 001B                977mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000004A2  6700 FB64                978mmm     BEQ START
000004A6                           979mmm     ENDM
000004A6                           980mm CONTINUE_51
000004A6  1A39 00C00013            981mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004AC  0805 0000                982mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004B0  67D8                     983mm     BEQ WAIT_FOR_READY_51                           ; NOTHING, CHECK AGAIN
000004B2                           984mm     
000004B2  1A39 00C00017            985mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004B8  13C5 00E00001            986mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004BE                           987mm 
000004BE                           988mm     ENDM
000004BE                           989m         ;PRINT_CHAR D5,D6
000004BE                           990mm         HEX2BIN D5,D5,A4
000004BE  49FA 0CCB                991mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004C2  0405 0030                992mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004C6  CABC 000000FF            993mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000004CC  1A34 5000                994mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000004D0                           995mm     ENDM
000004D0  8605                     996m         OR.B D5,D3
000004D2  5307                     997m         SUB.B #1,D7
000004D4                           998m     ENDW
000004D4  60AA                     999ms     BRA _10000000
000004D6                          1000ms _10000001
000004D6                          1001m 
000004D6  7A00                    1002m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000004D8  1A03                    1003m     MOVE.B D3,D5
000004DA  D483                    1004m     ADD.L D3,D2
000004DC                          1005m 
000004DC                          1006m     ENDM
000004DC                          1007  
000004DC                          1008      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000004DC  B23C 0030               1009s     CMP.B   #'0',D1
000004E0  6600 000A               1010s     BNE.L   _00000002
000004E4                          1011          ;PRINT_CRLF D5,A4
000004E4  6000 FF24               1012          BRA WAIT_FOR_SRECORD
000004E8                          1013      ELSE
000004E8  6000 0340               1014s     BRA _00000003
000004EC                          1015s _00000002
000004EC                          1016          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000004EC  B23C 0031               1017s     CMP.B   #'1',D1
000004F0  6708                    1018s     BEQ.S   _00000004
000004F2  B23C 0032               1019s     CMP.B   #'2',D1
000004F6  6600 01A8               1020s     BNE.L   _00000005
000004FA                          1021s _00000004
000004FA  5783                    1022              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004FC                          1023  
000004FC  7800                    1024              MOVE.L #0,D4                            ; read two bytes of address
000004FE                          1025m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000004FE  1E3C 0002               1026m     MOVE.B #2,D7
00000502                          1027m     WHILE.B D7 <GT> 0 DO
00000502                          1028ms _10000002
00000502  BE38 0000               1029ms     CMP.B   0,D7
00000506  6F00 0050               1030ms     BLE _10000003
0000050A  E98C                    1031m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000050C                          1032mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000050C                          1033mm WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050C                          1034mm 
0000050C  1A39 00C00003           1035mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000512  0805 0000               1036mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000516  6700 0010               1037mm     BEQ CONTINUE_55                                 ; NOTHING, CONTINUE
0000051A                          1038mm 
0000051A                          1039mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000051A                 TRUE     1040mmm     IFEQ DEBUG
0000051A  1A39 00C00007           1041mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000520                          1042mmm     ENDC
00000520                 FALSE    1043mmm     IFNE DEBUG
00000520                          1044mmm     ENDC
00000520                          1045mmm 
00000520  BA3C 001B               1046mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000524  6700 FAE2               1047mmm     BEQ START
00000528                          1048mmm     ENDM
00000528                          1049mm CONTINUE_55
00000528  1A39 00C00013           1050mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000052E  0805 0000               1051mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000532  67D8                    1052mm     BEQ WAIT_FOR_READY_55                           ; NOTHING, CHECK AGAIN
00000534                          1053mm     
00000534  1A39 00C00017           1054mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000053A  13C5 00E00001           1055mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000540                          1056mm 
00000540                          1057mm     ENDM
00000540                          1058m         ;PRINT_CHAR D5,D6
00000540                          1059mm         HEX2BIN D5,D5,A4
00000540  49FA 0C49               1060mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000544  0405 0030               1061mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000548  CABC 000000FF           1062mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000054E  1A34 5000               1063mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000552                          1064mm     ENDM
00000552  8805                    1065m         OR.B D5,D4
00000554  5307                    1066m         SUB.B #1,D7
00000556                          1067m     ENDW
00000556  60AA                    1068ms     BRA _10000002
00000558                          1069ms _10000003
00000558                          1070m 
00000558  7A00                    1071m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000055A  1A04                    1072m     MOVE.B D4,D5
0000055C  D484                    1073m     ADD.L D4,D2
0000055E                          1074m 
0000055E                          1075m     ENDM
0000055E                          1076m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
0000055E  1E3C 0002               1077m     MOVE.B #2,D7
00000562                          1078m     WHILE.B D7 <GT> 0 DO
00000562                          1079ms _10000004
00000562  BE38 0000               1080ms     CMP.B   0,D7
00000566  6F00 0050               1081ms     BLE _10000005
0000056A  E98C                    1082m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000056C                          1083mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000056C                          1084mm WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                          1085mm 
0000056C  1A39 00C00003           1086mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000572  0805 0000               1087mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000576  6700 0010               1088mm     BEQ CONTINUE_59                                 ; NOTHING, CONTINUE
0000057A                          1089mm 
0000057A                          1090mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000057A                 TRUE     1091mmm     IFEQ DEBUG
0000057A  1A39 00C00007           1092mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000580                          1093mmm     ENDC
00000580                 FALSE    1094mmm     IFNE DEBUG
00000580                          1095mmm     ENDC
00000580                          1096mmm 
00000580  BA3C 001B               1097mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000584  6700 FA82               1098mmm     BEQ START
00000588                          1099mmm     ENDM
00000588                          1100mm CONTINUE_59
00000588  1A39 00C00013           1101mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000058E  0805 0000               1102mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000592  67D8                    1103mm     BEQ WAIT_FOR_READY_59                           ; NOTHING, CHECK AGAIN
00000594                          1104mm     
00000594  1A39 00C00017           1105mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000059A  13C5 00E00001           1106mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000005A0                          1107mm 
000005A0                          1108mm     ENDM
000005A0                          1109m         ;PRINT_CHAR D5,D6
000005A0                          1110mm         HEX2BIN D5,D5,A4
000005A0  49FA 0BE9               1111mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000005A4  0405 0030               1112mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005A8  CABC 000000FF           1113mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005AE  1A34 5000               1114mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B2                          1115mm     ENDM
000005B2  8805                    1116m         OR.B D5,D4
000005B4  5307                    1117m         SUB.B #1,D7
000005B6                          1118m     ENDW
000005B6  60AA                    1119ms     BRA _10000004
000005B8                          1120ms _10000005
000005B8                          1121m 
000005B8  7A00                    1122m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005BA  1A04                    1123m     MOVE.B D4,D5
000005BC  D484                    1124m     ADD.L D4,D2
000005BE                          1125m 
000005BE                          1126m     ENDM
000005BE                          1127  
000005BE                          1128              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000005BE  B23C 0032               1129s     CMP.B   #'2',D1
000005C2  6600 0064               1130s     BNE.L   _00000006
000005C6  5383                    1131                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005C8                          1132m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000005C8  1E3C 0002               1133m     MOVE.B #2,D7
000005CC                          1134m     WHILE.B D7 <GT> 0 DO
000005CC                          1135ms _10000006
000005CC  BE38 0000               1136ms     CMP.B   0,D7
000005D0  6F00 0050               1137ms     BLE _10000007
000005D4  E98C                    1138m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005D6                          1139mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005D6                          1140mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005D6                          1141mm 
000005D6  1A39 00C00003           1142mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005DC  0805 0000               1143mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005E0  6700 0010               1144mm     BEQ CONTINUE_63                                 ; NOTHING, CONTINUE
000005E4                          1145mm 
000005E4                          1146mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005E4                 TRUE     1147mmm     IFEQ DEBUG
000005E4  1A39 00C00007           1148mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005EA                          1149mmm     ENDC
000005EA                 FALSE    1150mmm     IFNE DEBUG
000005EA                          1151mmm     ENDC
000005EA                          1152mmm 
000005EA  BA3C 001B               1153mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005EE  6700 FA18               1154mmm     BEQ START
000005F2                          1155mmm     ENDM
000005F2                          1156mm CONTINUE_63
000005F2  1A39 00C00013           1157mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005F8  0805 0000               1158mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005FC  67D8                    1159mm     BEQ WAIT_FOR_READY_63                           ; NOTHING, CHECK AGAIN
000005FE                          1160mm     
000005FE  1A39 00C00017           1161mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000604  13C5 00E00001           1162mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000060A                          1163mm 
0000060A                          1164mm     ENDM
0000060A                          1165m         ;PRINT_CHAR D5,D6
0000060A                          1166mm         HEX2BIN D5,D5,A4
0000060A  49FA 0B7F               1167mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000060E  0405 0030               1168mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000612  CABC 000000FF           1169mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000618  1A34 5000               1170mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000061C                          1171mm     ENDM
0000061C  8805                    1172m         OR.B D5,D4
0000061E  5307                    1173m         SUB.B #1,D7
00000620                          1174m     ENDW
00000620  60AA                    1175ms     BRA _10000006
00000622                          1176ms _10000007
00000622                          1177m 
00000622  7A00                    1178m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000624  1A04                    1179m     MOVE.B D4,D5
00000626  D484                    1180m     ADD.L D4,D2
00000628                          1181m 
00000628                          1182m     ENDM
00000628                          1183              ENDI
00000628                          1184s _00000006
00000628                          1185  
00000628  2444                    1186              MOVE.L D4,A2                            ; put the address in an address register
0000062A  D5C9                    1187              ADD.L A1,A2                             ; add in the offset
0000062C                          1188  
0000062C                          1189              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000062C                          1190s _10000008
0000062C  B63C 0000               1191s     CMP.B   #0,D3
00000630  6F00 0068               1192s     BLE _10000009
00000634                          1193m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000634  1E3C 0002               1194m     MOVE.B #2,D7
00000638                          1195m     WHILE.B D7 <GT> 0 DO
00000638                          1196ms _1000000A
00000638  BE38 0000               1197ms     CMP.B   0,D7
0000063C  6F00 0050               1198ms     BLE _1000000B
00000640  E989                    1199m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000642                          1200mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000642                          1201mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000642                          1202mm 
00000642  1A39 00C00003           1203mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000648  0805 0000               1204mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000064C  6700 0010               1205mm     BEQ CONTINUE_67                                 ; NOTHING, CONTINUE
00000650                          1206mm 
00000650                          1207mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000650                 TRUE     1208mmm     IFEQ DEBUG
00000650  1A39 00C00007           1209mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000656                          1210mmm     ENDC
00000656                 FALSE    1211mmm     IFNE DEBUG
00000656                          1212mmm     ENDC
00000656                          1213mmm 
00000656  BA3C 001B               1214mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000065A  6700 F9AC               1215mmm     BEQ START
0000065E                          1216mmm     ENDM
0000065E                          1217mm CONTINUE_67
0000065E  1A39 00C00013           1218mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000664  0805 0000               1219mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000668  67D8                    1220mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
0000066A                          1221mm     
0000066A  1A39 00C00017           1222mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000670  13C5 00E00001           1223mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000676                          1224mm 
00000676                          1225mm     ENDM
00000676                          1226m         ;PRINT_CHAR D5,D6
00000676                          1227mm         HEX2BIN D5,D5,A4
00000676  49FA 0B13               1228mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000067A  0405 0030               1229mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000067E  CABC 000000FF           1230mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000684  1A34 5000               1231mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000688                          1232mm     ENDM
00000688  8205                    1233m         OR.B D5,D1
0000068A  5307                    1234m         SUB.B #1,D7
0000068C                          1235m     ENDW
0000068C  60AA                    1236ms     BRA _1000000A
0000068E                          1237ms _1000000B
0000068E                          1238m 
0000068E  7A00                    1239m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000690  1A01                    1240m     MOVE.B D1,D5
00000692  D481                    1241m     ADD.L D1,D2
00000694                          1242m 
00000694                          1243m     ENDM
00000694                          1244   
00000694  14C1                    1245                  MOVE.B D1,(A2)+                     ; store it!
00000696                          1246  
00000696  5303                    1247                  SUB.B #1,D3                         ; 1 less byte to go
00000698                          1248              ENDW
00000698  6092                    1249s     BRA _10000008
0000069A                          1250s _10000009
0000069A                          1251  
0000069A  7200                    1252              MOVE.L #0,D1                            ; not done yet
0000069C                          1253          ELSE
0000069C  6000 018C               1254s     BRA _00000007
000006A0                          1255s _00000005
000006A0                          1256              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000006A0  B23C 0038               1257s     CMP.B   #'8',D1
000006A4  6600 012E               1258s     BNE.L   _00000008
000006A8  7800                    1259                  MOVE.L #0,D4                        ; read the 24 bit start address
000006AA                          1260m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000006AA  1E3C 0002               1261m     MOVE.B #2,D7
000006AE                          1262m     WHILE.B D7 <GT> 0 DO
000006AE                          1263ms _1000000C
000006AE  BE38 0000               1264ms     CMP.B   0,D7
000006B2  6F00 0050               1265ms     BLE _1000000D
000006B6  E98C                    1266m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006B8                          1267mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006B8                          1268mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006B8                          1269mm 
000006B8  1A39 00C00003           1270mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006BE  0805 0000               1271mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C2  6700 0010               1272mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
000006C6                          1273mm 
000006C6                          1274mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006C6                 TRUE     1275mmm     IFEQ DEBUG
000006C6  1A39 00C00007           1276mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006CC                          1277mmm     ENDC
000006CC                 FALSE    1278mmm     IFNE DEBUG
000006CC                          1279mmm     ENDC
000006CC                          1280mmm 
000006CC  BA3C 001B               1281mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006D0  6700 F936               1282mmm     BEQ START
000006D4                          1283mmm     ENDM
000006D4                          1284mm CONTINUE_71
000006D4  1A39 00C00013           1285mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006DA  0805 0000               1286mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006DE  67D8                    1287mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
000006E0                          1288mm     
000006E0  1A39 00C00017           1289mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006E6  13C5 00E00001           1290mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006EC                          1291mm 
000006EC                          1292mm     ENDM
000006EC                          1293m         ;PRINT_CHAR D5,D6
000006EC                          1294mm         HEX2BIN D5,D5,A4
000006EC  49FA 0A9D               1295mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006F0  0405 0030               1296mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006F4  CABC 000000FF           1297mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006FA  1A34 5000               1298mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006FE                          1299mm     ENDM
000006FE  8805                    1300m         OR.B D5,D4
00000700  5307                    1301m         SUB.B #1,D7
00000702                          1302m     ENDW
00000702  60AA                    1303ms     BRA _1000000C
00000704                          1304ms _1000000D
00000704                          1305m 
00000704  7A00                    1306m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000706  1A04                    1307m     MOVE.B D4,D5
00000708  D484                    1308m     ADD.L D4,D2
0000070A                          1309m 
0000070A                          1310m     ENDM
0000070A                          1311m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000070A  1E3C 0002               1312m     MOVE.B #2,D7
0000070E                          1313m     WHILE.B D7 <GT> 0 DO
0000070E                          1314ms _1000000E
0000070E  BE38 0000               1315ms     CMP.B   0,D7
00000712  6F00 0050               1316ms     BLE _1000000F
00000716  E98C                    1317m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000718                          1318mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000718                          1319mm WAIT_FOR_READY_75                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000718                          1320mm 
00000718  1A39 00C00003           1321mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000071E  0805 0000               1322mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000722  6700 0010               1323mm     BEQ CONTINUE_75                                 ; NOTHING, CONTINUE
00000726                          1324mm 
00000726                          1325mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000726                 TRUE     1326mmm     IFEQ DEBUG
00000726  1A39 00C00007           1327mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000072C                          1328mmm     ENDC
0000072C                 FALSE    1329mmm     IFNE DEBUG
0000072C                          1330mmm     ENDC
0000072C                          1331mmm 
0000072C  BA3C 001B               1332mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000730  6700 F8D6               1333mmm     BEQ START
00000734                          1334mmm     ENDM
00000734                          1335mm CONTINUE_75
00000734  1A39 00C00013           1336mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000073A  0805 0000               1337mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000073E  67D8                    1338mm     BEQ WAIT_FOR_READY_75                           ; NOTHING, CHECK AGAIN
00000740                          1339mm     
00000740  1A39 00C00017           1340mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000746  13C5 00E00001           1341mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000074C                          1342mm 
0000074C                          1343mm     ENDM
0000074C                          1344m         ;PRINT_CHAR D5,D6
0000074C                          1345mm         HEX2BIN D5,D5,A4
0000074C  49FA 0A3D               1346mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000750  0405 0030               1347mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000754  CABC 000000FF           1348mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000075A  1A34 5000               1349mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000075E                          1350mm     ENDM
0000075E  8805                    1351m         OR.B D5,D4
00000760  5307                    1352m         SUB.B #1,D7
00000762                          1353m     ENDW
00000762  60AA                    1354ms     BRA _1000000E
00000764                          1355ms _1000000F
00000764                          1356m 
00000764  7A00                    1357m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000766  1A04                    1358m     MOVE.B D4,D5
00000768  D484                    1359m     ADD.L D4,D2
0000076A                          1360m 
0000076A                          1361m     ENDM
0000076A                          1362m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
0000076A  1E3C 0002               1363m     MOVE.B #2,D7
0000076E                          1364m     WHILE.B D7 <GT> 0 DO
0000076E                          1365ms _10000010
0000076E  BE38 0000               1366ms     CMP.B   0,D7
00000772  6F00 0050               1367ms     BLE _10000011
00000776  E98C                    1368m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000778                          1369mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000778                          1370mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000778                          1371mm 
00000778  1A39 00C00003           1372mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000077E  0805 0000               1373mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000782  6700 0010               1374mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
00000786                          1375mm 
00000786                          1376mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000786                 TRUE     1377mmm     IFEQ DEBUG
00000786  1A39 00C00007           1378mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000078C                          1379mmm     ENDC
0000078C                 FALSE    1380mmm     IFNE DEBUG
0000078C                          1381mmm     ENDC
0000078C                          1382mmm 
0000078C  BA3C 001B               1383mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000790  6700 F876               1384mmm     BEQ START
00000794                          1385mmm     ENDM
00000794                          1386mm CONTINUE_79
00000794  1A39 00C00013           1387mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000079A  0805 0000               1388mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000079E  67D8                    1389mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
000007A0                          1390mm     
000007A0  1A39 00C00017           1391mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007A6  13C5 00E00001           1392mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007AC                          1393mm 
000007AC                          1394mm     ENDM
000007AC                          1395m         ;PRINT_CHAR D5,D6
000007AC                          1396mm         HEX2BIN D5,D5,A4
000007AC  49FA 09DD               1397mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007B0  0405 0030               1398mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B4  CABC 000000FF           1399mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007BA  1A34 5000               1400mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007BE                          1401mm     ENDM
000007BE  8805                    1402m         OR.B D5,D4
000007C0  5307                    1403m         SUB.B #1,D7
000007C2                          1404m     ENDW
000007C2  60AA                    1405ms     BRA _10000010
000007C4                          1406ms _10000011
000007C4                          1407m 
000007C4  7A00                    1408m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C6  1A04                    1409m     MOVE.B D4,D5
000007C8  D484                    1410m     ADD.L D4,D2
000007CA                          1411m 
000007CA                          1412m     ENDM
000007CA                          1413  
000007CA  2044                    1414                  MOVE.L D4,A0                        ; start address -> A0
000007CC  D1C9                    1415                  ADD.L A1,A0                         ; add in the offset
000007CE                          1416  
000007CE  72FF                    1417                  MOVE.L #$FFFFFFFF,D1                ; done
000007D0                          1418              ELSE
000007D0  6000 0058               1419s     BRA _00000009
000007D4                          1420s _00000008
000007D4                          1421                  ;PRINT_CRLF D5,A4
000007D4                          1422  
000007D4  49FA 096A               1423                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000007D8                          1424m                 PRINT_STR A4,D5
000007D8                          1425m LOOP_82
000007D8  0C14 0000               1426m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000007DC  6700 0016               1427m     BEQ EXIT_82
000007E0                          1428mm     PRINT_CHAR (A4)+,D5
000007E0                          1429mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007E0                 TRUE     1430mm     IFEQ DEBUG
000007E0  1A39 00C00003           1431mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000007E6  0805 0002               1432mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000007EA  67F4                    1433mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
000007EC  13DC 00C00007           1434mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007F2                          1435mm     ENDC
000007F2                          1436mm 
000007F2                 FALSE    1437mm     IFNE DEBUG
000007F2                          1438mm     ENDC
000007F2                          1439mm 
000007F2                          1440mm     ENDM
000007F2  60E4                    1441m     BRA LOOP_82
000007F4                          1442m EXIT_82
000007F4                          1443m     ENDM
000007F4                          1444m                 PRINT_CHAR D1,D5
000007F4                          1445m WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F4                 TRUE     1446m     IFEQ DEBUG
000007F4  1A39 00C00003           1447m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000007FA  0805 0002               1448m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000007FE  67F4                    1449m         BEQ WAIT_FOR_READY_84                       ; NO SPACE, CHECK AGAIN
00000800  13C1 00C00007           1450m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000806                          1451m     ENDC
00000806                          1452m 
00000806                 FALSE    1453m     IFNE DEBUG
00000806                          1454m     ENDC
00000806                          1455m 
00000806                          1456m     ENDM
00000806                          1457m                 PRINT_CRLF D5,A4
00000806  49FA 09AE               1458m     LEA CRLF(PC),A4
0000080A                          1459mm     PRINT_STR A4,D5
0000080A                          1460mm LOOP_86
0000080A  0C14 0000               1461mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000080E  6700 0016               1462mm     BEQ EXIT_86
00000812                          1463mmm     PRINT_CHAR (A4)+,D5
00000812                          1464mmm WAIT_FOR_READY_87                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000812                 TRUE     1465mmm     IFEQ DEBUG
00000812  1A39 00C00003           1466mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000818  0805 0002               1467mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000081C  67F4                    1468mmm         BEQ WAIT_FOR_READY_87                       ; NO SPACE, CHECK AGAIN
0000081E  13DC 00C00007           1469mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000824                          1470mmm     ENDC
00000824                          1471mmm 
00000824                 FALSE    1472mmm     IFNE DEBUG
00000824                          1473mmm     ENDC
00000824                          1474mmm 
00000824                          1475mmm     ENDM
00000824  60E4                    1476mm     BRA LOOP_86
00000826                          1477mm EXIT_86
00000826                          1478mm     ENDM
00000826                          1479m     ENDM
00000826                          1480  
00000826  6000 FBE2               1481                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
0000082A                          1482              ENDI
0000082A                          1483s _00000009
0000082A                          1484          ENDI
0000082A                          1485s _00000007
0000082A                          1486      ENDI
0000082A                          1487s _00000003
0000082A                          1488  
0000082A                          1489m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
0000082A  1E3C 0002               1490m     MOVE.B #2,D7
0000082E                          1491m     WHILE.B D7 <GT> 0 DO
0000082E                          1492ms _10000012
0000082E  BE38 0000               1493ms     CMP.B   0,D7
00000832  6F00 0050               1494ms     BLE _10000013
00000836  E98C                    1495m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000838                          1496mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000838                          1497mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000838                          1498mm 
00000838  1A39 00C00003           1499mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000083E  0805 0000               1500mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000842  6700 0010               1501mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000846                          1502mm 
00000846                          1503mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000846                 TRUE     1504mmm     IFEQ DEBUG
00000846  1A39 00C00007           1505mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000084C                          1506mmm     ENDC
0000084C                 FALSE    1507mmm     IFNE DEBUG
0000084C                          1508mmm     ENDC
0000084C                          1509mmm 
0000084C  BA3C 001B               1510mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000850  6700 F7B6               1511mmm     BEQ START
00000854                          1512mmm     ENDM
00000854                          1513mm CONTINUE_89
00000854  1A39 00C00013           1514mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000085A  0805 0000               1515mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000085E  67D8                    1516mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
00000860                          1517mm     
00000860  1A39 00C00017           1518mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000866  13C5 00E00001           1519mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000086C                          1520mm 
0000086C                          1521mm     ENDM
0000086C                          1522m         ;PRINT_CHAR D5,D6
0000086C                          1523mm         HEX2BIN D5,D5,A4
0000086C  49FA 091D               1524mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000870  0405 0030               1525mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000874  CABC 000000FF           1526mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000087A  1A34 5000               1527mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000087E                          1528mm     ENDM
0000087E  8805                    1529m         OR.B D5,D4
00000880  5307                    1530m         SUB.B #1,D7
00000882                          1531m     ENDW
00000882  60AA                    1532ms     BRA _10000012
00000884                          1533ms _10000013
00000884                          1534m 
00000884  7A00                    1535m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000886  1A04                    1536m     MOVE.B D4,D5
00000888  D484                    1537m     ADD.L D4,D2
0000088A                          1538m 
0000088A                          1539m     ENDM
0000088A                          1540      ;PRINT_CRLF D5,A4
0000088A                          1541  
0000088A                          1542      IF.B D2 <NE> #$FF THEN.L
0000088A  B43C 00FF               1543s     CMP.B   #$FF,D2
0000088E  6700 0090               1544s     BEQ.L   _0000000A
00000892  49FA 08C3               1545          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000896                          1546m         PRINT_STR A4,D5
00000896                          1547m LOOP_92
00000896  0C14 0000               1548m     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000089A  6700 0016               1549m     BEQ EXIT_92
0000089E                          1550mm     PRINT_CHAR (A4)+,D5
0000089E                          1551mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000089E                 TRUE     1552mm     IFEQ DEBUG
0000089E  1A39 00C00003           1553mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008A4  0805 0002               1554mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008A8  67F4                    1555mm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
000008AA  13DC 00C00007           1556mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008B0                          1557mm     ENDC
000008B0                          1558mm 
000008B0                 FALSE    1559mm     IFNE DEBUG
000008B0                          1560mm     ENDC
000008B0                          1561mm 
000008B0                          1562mm     ENDM
000008B0  60E4                    1563m     BRA LOOP_92
000008B2                          1564m EXIT_92
000008B2                          1565m     ENDM
000008B2                          1566m         PRINT_REG D0,D5,D2,D6,A4
000008B2  49FA 0908               1567m     LEA OX(PC),A4
000008B6                          1568mm     PRINT_STR A4,D5
000008B6                          1569mm LOOP_95
000008B6  0C14 0000               1570mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008BA  6700 0016               1571mm     BEQ EXIT_95
000008BE                          1572mmm     PRINT_CHAR (A4)+,D5
000008BE                          1573mmm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BE                 TRUE     1574mmm     IFEQ DEBUG
000008BE  1A39 00C00003           1575mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008C4  0805 0002               1576mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008C8  67F4                    1577mmm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000008CA  13DC 00C00007           1578mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008D0                          1579mmm     ENDC
000008D0                          1580mmm 
000008D0                 FALSE    1581mmm     IFNE DEBUG
000008D0                          1582mmm     ENDC
000008D0                          1583mmm 
000008D0                          1584mmm     ENDM
000008D0  60E4                    1585mm     BRA LOOP_95
000008D2                          1586mm EXIT_95
000008D2                          1587mm     ENDM
000008D2  7C07                    1588m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000008D4                          1589m LOOP_94
000008D4                          1590mm     BIN2HEX D0,D2,A4
000008D4  49FA 08A5               1591mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008D8  E998                    1592mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000008DA  1400                    1593mm     MOVE.B D0,D2
000008DC  0282 0000000F           1594mm     ANDI.L #$F,D2
000008E2  1434 2000               1595mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000008E6                          1596mm     ENDM
000008E6                          1597mm     PRINT_CHAR D2,D5
000008E6                          1598mm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                 TRUE     1599mm     IFEQ DEBUG
000008E6  1A39 00C00003           1600mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008EC  0805 0002               1601mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008F0  67F4                    1602mm         BEQ WAIT_FOR_READY_98                       ; NO SPACE, CHECK AGAIN
000008F2  13C2 00C00007           1603mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008F8                          1604mm     ENDC
000008F8                          1605mm 
000008F8                 FALSE    1606mm     IFNE DEBUG
000008F8                          1607mm     ENDC
000008F8                          1608mm 
000008F8                          1609mm     ENDM
000008F8  57CE FFDA               1610m     DBEQ D6,LOOP_94
000008FC                          1611m     ENDM
000008FC                          1612m         PRINT_CRLF D5,A4
000008FC  49FA 08B8               1613m     LEA CRLF(PC),A4
00000900                          1614mm     PRINT_STR A4,D5
00000900                          1615mm LOOP_100
00000900  0C14 0000               1616mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000904  6700 0016               1617mm     BEQ EXIT_100
00000908                          1618mmm     PRINT_CHAR (A4)+,D5
00000908                          1619mmm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000908                 TRUE     1620mmm     IFEQ DEBUG
00000908  1A39 00C00003           1621mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000090E  0805 0002               1622mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000912  67F4                    1623mmm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000914  13DC 00C00007           1624mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000091A                          1625mmm     ENDC
0000091A                          1626mmm 
0000091A                 FALSE    1627mmm     IFNE DEBUG
0000091A                          1628mmm     ENDC
0000091A                          1629mmm 
0000091A                          1630mmm     ENDM
0000091A  60E4                    1631mm     BRA LOOP_100
0000091C                          1632mm EXIT_100
0000091C                          1633mm     ENDM
0000091C                          1634m     ENDM
0000091C  6000 F85C               1635          BRA MAIN_LOOP
00000920                          1636      ENDI
00000920                          1637s _0000000A
00000920                          1638  
00000920                          1639      IF D1 <EQ> #0 THEN
00000920  B27C 0000               1640s     CMP.W   #0,D1
00000924  6600 0006               1641s     BNE _0000000B
00000928  6000 FAE0               1642        BRA WAIT_FOR_SRECORD
0000092C                          1643      ENDI
0000092C                          1644s _0000000B
0000092C                          1645  DOWNLOAD_DONE
0000092C                          1646m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
0000092C  43FA 088E               1647m     LEA OX(PC),A1
00000930                          1648mm     PRINT_STR A1,D5
00000930                          1649mm LOOP_103
00000930  0C11 0000               1650mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000934  6700 0016               1651mm     BEQ EXIT_103
00000938                          1652mmm     PRINT_CHAR (A1)+,D5
00000938                          1653mmm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000938                 TRUE     1654mmm     IFEQ DEBUG
00000938  1A39 00C00003           1655mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000093E  0805 0002               1656mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000942  67F4                    1657mmm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
00000944  13D9 00C00007           1658mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000094A                          1659mmm     ENDC
0000094A                          1660mmm 
0000094A                 FALSE    1661mmm     IFNE DEBUG
0000094A                          1662mmm     ENDC
0000094A                          1663mmm 
0000094A                          1664mmm     ENDM
0000094A  60E4                    1665mm     BRA LOOP_103
0000094C                          1666mm EXIT_103
0000094C                          1667mm     ENDM
0000094C  7407                    1668m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000094E                          1669m LOOP_102
0000094E                          1670mm     BIN2HEX D0,D6,A1
0000094E  43FA 082B               1671mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000952  E998                    1672mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000954  1C00                    1673mm     MOVE.B D0,D6
00000956  0286 0000000F           1674mm     ANDI.L #$F,D6
0000095C  1C31 6000               1675mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000960                          1676mm     ENDM
00000960                          1677mm     PRINT_CHAR D6,D5
00000960                          1678mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000960                 TRUE     1679mm     IFEQ DEBUG
00000960  1A39 00C00003           1680mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000966  0805 0002               1681mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000096A  67F4                    1682mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
0000096C  13C6 00C00007           1683mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000972                          1684mm     ENDC
00000972                          1685mm 
00000972                 FALSE    1686mm     IFNE DEBUG
00000972                          1687mm     ENDC
00000972                          1688mm 
00000972                          1689mm     ENDM
00000972  57CA FFDA               1690m     DBEQ D2,LOOP_102
00000976                          1691m     ENDM
00000976  43FA 07A6               1692      LEA READ(PC),A1
0000097A                          1693m     PRINT_STR A1,D5
0000097A                          1694m LOOP_107
0000097A  0C11 0000               1695m     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000097E  6700 0016               1696m     BEQ EXIT_107
00000982                          1697mm     PRINT_CHAR (A1)+,D5
00000982                          1698mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000982                 TRUE     1699mm     IFEQ DEBUG
00000982  1A39 00C00003           1700mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000988  0805 0002               1701mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000098C  67F4                    1702mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
0000098E  13D9 00C00007           1703mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000994                          1704mm     ENDC
00000994                          1705mm 
00000994                 FALSE    1706mm     IFNE DEBUG
00000994                          1707mm     ENDC
00000994                          1708mm 
00000994                          1709mm     ENDM
00000994  60E4                    1710m     BRA LOOP_107
00000996                          1711m EXIT_107
00000996                          1712m     ENDM
00000996  2E08                    1713      MOVE.L A0,D7                                    ; set address accumulator to start address
00000998                          1714m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000998  43FA 0822               1715m     LEA OX(PC),A1
0000099C                          1716mm     PRINT_STR A1,D5
0000099C                          1717mm LOOP_110
0000099C  0C11 0000               1718mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000009A0  6700 0016               1719mm     BEQ EXIT_110
000009A4                          1720mmm     PRINT_CHAR (A1)+,D5
000009A4                          1721mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A4                 TRUE     1722mmm     IFEQ DEBUG
000009A4  1A39 00C00003           1723mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009AA  0805 0002               1724mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009AE  67F4                    1725mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009B0  13D9 00C00007           1726mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009B6                          1727mmm     ENDC
000009B6                          1728mmm 
000009B6                 FALSE    1729mmm     IFNE DEBUG
000009B6                          1730mmm     ENDC
000009B6                          1731mmm 
000009B6                          1732mmm     ENDM
000009B6  60E4                    1733mm     BRA LOOP_110
000009B8                          1734mm EXIT_110
000009B8                          1735mm     ENDM
000009B8  7407                    1736m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009BA                          1737m LOOP_109
000009BA                          1738mm     BIN2HEX D7,D6,A1
000009BA  43FA 07BF               1739mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
000009BE  E99F                    1740mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009C0  1C07                    1741mm     MOVE.B D7,D6
000009C2  0286 0000000F           1742mm     ANDI.L #$F,D6
000009C8  1C31 6000               1743mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
000009CC                          1744mm     ENDM
000009CC                          1745mm     PRINT_CHAR D6,D5
000009CC                          1746mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009CC                 TRUE     1747mm     IFEQ DEBUG
000009CC  1A39 00C00003           1748mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009D2  0805 0002               1749mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009D6  67F4                    1750mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009D8  13C6 00C00007           1751mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009DE                          1752mm     ENDC
000009DE                          1753mm 
000009DE                 FALSE    1754mm     IFNE DEBUG
000009DE                          1755mm     ENDC
000009DE                          1756mm 
000009DE                          1757mm     ENDM
000009DE  57CA FFDA               1758m     DBEQ D2,LOOP_109
000009E2                          1759m     ENDM
000009E2                          1760m     PRINT_CRLF D5,A4
000009E2  49FA 07D2               1761m     LEA CRLF(PC),A4
000009E6                          1762mm     PRINT_STR A4,D5
000009E6                          1763mm LOOP_115
000009E6  0C14 0000               1764mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009EA  6700 0016               1765mm     BEQ EXIT_115
000009EE                          1766mmm     PRINT_CHAR (A4)+,D5
000009EE                          1767mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EE                 TRUE     1768mmm     IFEQ DEBUG
000009EE  1A39 00C00003           1769mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009F4  0805 0002               1770mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009F8  67F4                    1771mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009FA  13DC 00C00007           1772mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A00                          1773mmm     ENDC
00000A00                          1774mmm 
00000A00                 FALSE    1775mmm     IFNE DEBUG
00000A00                          1776mmm     ENDC
00000A00                          1777mmm 
00000A00                          1778mmm     ENDM
00000A00  60E4                    1779mm     BRA LOOP_115
00000A02                          1780mm EXIT_115
00000A02                          1781mm     ENDM
00000A02                          1782m     ENDM
00000A02                          1783  
00000A02  6000 F776               1784      BRA MAIN_LOOP
00000A06                          1785  
00000A06                          1786  G
00000A06  2047                    1787      MOVE.L D7,A0                                    ; address accumulator -> address register
00000A08  3E3C 0000               1788      MOVE #0,D7                                      ; clear the now used address accumulator
00000A0C  4ED0                    1789      JMP (A0)                                        ; jump to it!
00000A0E                          1790  
00000A0E                          1791  Z
00000A0E  207C 00200000           1792      MOVE.L #RAM,A0                                  ; address of RAM
00000A14  D1FC 00100000           1793      ADD.L #$100000,A0
00000A1A                          1794  
00000A1A                          1795      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000A1A  7000                    1796s     MOVE.L  #0,D0
00000A1C  6000 0012               1797s     BRA _20000005
00000A20                          1798s _20000004
00000A20  2200                    1799          MOVE.L D0,D1                                ; progress update
00000A22  E089                    1800          LSR.L #8,D1 
00000A24  E089                    1801          LSR.L #8,D1
00000A26  13C1 00E00001           1802          MOVE.B D1,DISPLAY
00000A2C                          1803          
00000A2C  2108                    1804          MOVE.L A0,-(A0)
00000A2E                          1805      ENDF
00000A2E  5880                    1806s     ADD.L   #4,D0
00000A30                          1807s _20000005
00000A30  B0BC 000FFFFC           1808s     CMP.L   #$FFFFC,D0
00000A36  6FE8                    1809s     BLE _20000004
00000A38                          1810  
00000A38  207C 00200000           1811      MOVE.L #RAM,A0                                  ; address of RAM
00000A3E  D1FC 00100000           1812      ADD.L #$100000,A0
00000A44                          1813  
00000A44                          1814      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000A44  7000                    1815s     MOVE.L  #0,D0
00000A46  6000 00A8               1816s     BRA _20000007
00000A4A                          1817s _20000006
00000A4A  2200                    1818          MOVE.L D0,D1                                ; progress update
00000A4C  E089                    1819          LSR.L #8,D1
00000A4E  E089                    1820          LSR.L #8,D1
00000A50  13C1 00E00001           1821          MOVE.B D1,DISPLAY
00000A56                          1822  
00000A56  2408                    1823          MOVE.L A0,D2
00000A58  2220                    1824          MOVE.L -(A0),D1
00000A5A                          1825  
00000A5A                          1826          IF.L D2 <NE> D1 THEN
00000A5A  B481                    1827s     CMP.L   D1,D2
00000A5C  6700 0090               1828s     BEQ _0000000C
00000A60  43FA 0707               1829              LEA RAM_ERROR(PC),A1
00000A64                          1830m             PRINT_STR A1,D1
00000A64                          1831m LOOP_117
00000A64  0C11 0000               1832m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A68  6700 0016               1833m     BEQ EXIT_117
00000A6C                          1834mm     PRINT_CHAR (A1)+,D1
00000A6C                          1835mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A6C                 TRUE     1836mm     IFEQ DEBUG
00000A6C  1239 00C00003           1837mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000A72  0801 0002               1838mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000A76  67F4                    1839mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A78  13D9 00C00007           1840mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A7E                          1841mm     ENDC
00000A7E                          1842mm 
00000A7E                 FALSE    1843mm     IFNE DEBUG
00000A7E                          1844mm     ENDC
00000A7E                          1845mm 
00000A7E                          1846mm     ENDM
00000A7E  60E4                    1847m     BRA LOOP_117
00000A80                          1848m EXIT_117
00000A80                          1849m     ENDM
00000A80  2208                    1850              MOVE.L A0,D1
00000A82  5981                    1851              SUB.L #4,D1
00000A84                          1852m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000A84  43FA 0736               1853m     LEA OX(PC),A1
00000A88                          1854mm     PRINT_STR A1,D3
00000A88                          1855mm LOOP_120
00000A88  0C11 0000               1856mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A8C  6700 0016               1857mm     BEQ EXIT_120
00000A90                          1858mmm     PRINT_CHAR (A1)+,D3
00000A90                          1859mmm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A90                 TRUE     1860mmm     IFEQ DEBUG
00000A90  1639 00C00003           1861mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000A96  0803 0002               1862mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000A9A  67F4                    1863mmm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A9C  13D9 00C00007           1864mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AA2                          1865mmm     ENDC
00000AA2                          1866mmm 
00000AA2                 FALSE    1867mmm     IFNE DEBUG
00000AA2                          1868mmm     ENDC
00000AA2                          1869mmm 
00000AA2                          1870mmm     ENDM
00000AA2  60E4                    1871mm     BRA LOOP_120
00000AA4                          1872mm EXIT_120
00000AA4                          1873mm     ENDM
00000AA4  7C07                    1874m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AA6                          1875m LOOP_119
00000AA6                          1876mm     BIN2HEX D1,D2,A1
00000AA6  43FA 06D3               1877mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AAA  E999                    1878mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AAC  1401                    1879mm     MOVE.B D1,D2
00000AAE  0282 0000000F           1880mm     ANDI.L #$F,D2
00000AB4  1431 2000               1881mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000AB8                          1882mm     ENDM
00000AB8                          1883mm     PRINT_CHAR D2,D3
00000AB8                          1884mm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB8                 TRUE     1885mm     IFEQ DEBUG
00000AB8  1639 00C00003           1886mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ABE  0803 0002               1887mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000AC2  67F4                    1888mm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000AC4  13C2 00C00007           1889mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000ACA                          1890mm     ENDC
00000ACA                          1891mm 
00000ACA                 FALSE    1892mm     IFNE DEBUG
00000ACA                          1893mm     ENDC
00000ACA                          1894mm 
00000ACA                          1895mm     ENDM
00000ACA  57CE FFDA               1896m     DBEQ D6,LOOP_119
00000ACE                          1897m     ENDM
00000ACE                          1898m             PRINT_CRLF D3,A1
00000ACE  43FA 06E6               1899m     LEA CRLF(PC),A1
00000AD2                          1900mm     PRINT_STR A1,D3
00000AD2                          1901mm LOOP_125
00000AD2  0C11 0000               1902mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AD6  6700 0016               1903mm     BEQ EXIT_125
00000ADA                          1904mmm     PRINT_CHAR (A1)+,D3
00000ADA                          1905mmm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ADA                 TRUE     1906mmm     IFEQ DEBUG
00000ADA  1639 00C00003           1907mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000AE0  0803 0002               1908mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000AE4  67F4                    1909mmm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000AE6  13D9 00C00007           1910mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AEC                          1911mmm     ENDC
00000AEC                          1912mmm 
00000AEC                 FALSE    1913mmm     IFNE DEBUG
00000AEC                          1914mmm     ENDC
00000AEC                          1915mmm 
00000AEC                          1916mmm     ENDM
00000AEC  60E4                    1917mm     BRA LOOP_125
00000AEE                          1918mm EXIT_125
00000AEE                          1919mm     ENDM
00000AEE                          1920m     ENDM
00000AEE                          1921          ENDI 
00000AEE                          1922s _0000000C
00000AEE                          1923      ENDF
00000AEE  5880                    1924s     ADD.L   #4,D0
00000AF0                          1925s _20000007
00000AF0  B0BC 000FFFFC           1926s     CMP.L   #$FFFFC,D0
00000AF6  6F00 FF52               1927s     BLE _20000006
00000AFA                          1928  
00000AFA  6000 F67E               1929      BRA MAIN_LOOP
00000AFE                          1930  
00000AFE                          1931  L
00000AFE  7000                    1932      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000B00  7200                    1933      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B02                          1934  
00000B02                          1935      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B02  343C 0000               1936s     MOVE.W  #0,D2
00000B06  6000 0046               1937s     BRA _20000009
00000B0A                          1938s _20000008
00000B0A  E989                    1939          LSL.L #4,D1                                 ; make what we have so far more significant
00000B0C                          1940m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B0C                          1941m WAIT_FOR_READY_127                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0C                 TRUE     1942m     IFEQ DEBUG
00000B0C  1839 00C00003           1943m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B12  0804 0000               1944m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000B16  67F4                    1945m         BEQ WAIT_FOR_READY_127                      ; NOTHING, CHECK AGAIN
00000B18                          1946m     ENDC
00000B18                          1947m 
00000B18                          1948mm     READ_CHAR D3
00000B18                 TRUE     1949mm     IFEQ DEBUG
00000B18  1639 00C00007           1950mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B1E                          1951mm     ENDC
00000B1E                 FALSE    1952mm     IFNE DEBUG
00000B1E                          1953mm     ENDC
00000B1E                          1954mm 
00000B1E  B63C 001B               1955mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000B22  6700 F4E4               1956mm     BEQ START
00000B26                          1957mm     ENDM
00000B26                          1958m 
00000B26                 TRUE     1959m     IFEQ DEBUG
00000B26                          1960mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B26                          1961mm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B26                 TRUE     1962mm     IFEQ DEBUG
00000B26  1839 00C00003           1963mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B2C  0804 0002               1964mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000B30  67F4                    1965mm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000B32  13C3 00C00007           1966mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B38                          1967mm     ENDC
00000B38                          1968mm 
00000B38                 FALSE    1969mm     IFNE DEBUG
00000B38                          1970mm     ENDC
00000B38                          1971mm 
00000B38                          1972mm     ENDM
00000B38                          1973m     ENDC
00000B38                          1974m     ENDM
00000B38                          1975m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000B38  41FA 0651               1976m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000B3C  0403 0030               1977m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B40  C6BC 000000FF           1978m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000B46  1630 3000               1979m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B4A                          1980m     ENDM
00000B4A  8203                    1981          OR.B D3,D1
00000B4C                          1982      ENDF
00000B4C  5242                    1983s     ADD.W   #1,D2
00000B4E                          1984s _20000009
00000B4E  B47C 0007               1985s     CMP.W   #7,D2
00000B52  6FB6                    1986s     BLE _20000008
00000B54                          1987  
00000B54  3001                    1988      MOVE.W D1,D0                                    ; extract the LSword for the length
00000B56  E089                    1989      LSR.L #8,D1                                     ; extract the MSword for the address
00000B58  E089                    1990      LSR.L #8,D1
00000B5A                          1991  
00000B5A                          1992m     PRINT_CRLF D2,A1
00000B5A  43FA 065A               1993m     LEA CRLF(PC),A1
00000B5E                          1994mm     PRINT_STR A1,D2
00000B5E                          1995mm LOOP_132
00000B5E  0C11 0000               1996mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B62  6700 0016               1997mm     BEQ EXIT_132
00000B66                          1998mmm     PRINT_CHAR (A1)+,D2
00000B66                          1999mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B66                 TRUE     2000mmm     IFEQ DEBUG
00000B66  1439 00C00003           2001mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000B6C  0802 0002               2002mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000B70  67F4                    2003mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B72  13D9 00C00007           2004mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B78                          2005mmm     ENDC
00000B78                          2006mmm 
00000B78                 FALSE    2007mmm     IFNE DEBUG
00000B78                          2008mmm     ENDC
00000B78                          2009mmm 
00000B78                          2010mmm     ENDM
00000B78  60E4                    2011mm     BRA LOOP_132
00000B7A                          2012mm EXIT_132
00000B7A                          2013mm     ENDM
00000B7A                          2014m     ENDM
00000B7A                          2015  
00000B7A  2041                    2016      MOVE.L D1,A0                                    ; target address
00000B7C                          2017  
00000B7C  2247                    2018      MOVE.L D7,A1                                    ; address accumulator -> address register
00000B7E  7E00                    2019      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000B80                          2020  
00000B80  5089                    2021      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000B82  5180                    2022      SUB.L #8,D0
00000B84                          2023  
00000B84                          2024m     UNPROTECT
00000B84  31FC AAAA 2AAA          2025m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000B8A  4E71                    2026m     NOP
00000B8C  31FC 5555 1554          2027m     MOVE.W #$5555,$1554
00000B92  4E71                    2028m     NOP
00000B94  31FC 8080 2AAA          2029m     MOVE.W #$8080,$2AAA
00000B9A  4E71                    2030m     NOP
00000B9C  31FC AAAA 2AAA          2031m     MOVE.W #$AAAA,$2AAA
00000BA2  4E71                    2032m     NOP
00000BA4  31FC 5555 1554          2033m     MOVE.W #$5555,$1554
00000BAA  4E71                    2034m     NOP
00000BAC  31FC 2020 2AAA          2035m     MOVE.W #$2020,$2AAA
00000BB2                          2036m     ENDM
00000BB2                          2037  
00000BB2  45FA 05EE               2038      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000BB6                          2039m     PRINT_STR A2,D2
00000BB6                          2040m LOOP_135
00000BB6  0C12 0000               2041m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000BBA  6700 0016               2042m     BEQ EXIT_135
00000BBE                          2043mm     PRINT_CHAR (A2)+,D2
00000BBE                          2044mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BBE                 TRUE     2045mm     IFEQ DEBUG
00000BBE  1439 00C00003           2046mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000BC4  0802 0002               2047mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000BC8  67F4                    2048mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000BCA  13DA 00C00007           2049mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BD0                          2050mm     ENDC
00000BD0                          2051mm 
00000BD0                 FALSE    2052mm     IFNE DEBUG
00000BD0                          2053mm     ENDC
00000BD0                          2054mm 
00000BD0                          2055mm     ENDM
00000BD0  60E4                    2056m     BRA LOOP_135
00000BD2                          2057m EXIT_135
00000BD2                          2058m     ENDM
00000BD2                          2059  
00000BD2  2409                    2060      MOVE.L A1,D2
00000BD4                          2061m     PRINT_REG D2,D3,D4,D5,A2
00000BD4  45FA 05E6               2062m     LEA OX(PC),A2
00000BD8                          2063mm     PRINT_STR A2,D3
00000BD8                          2064mm LOOP_138
00000BD8  0C12 0000               2065mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000BDC  6700 0016               2066mm     BEQ EXIT_138
00000BE0                          2067mmm     PRINT_CHAR (A2)+,D3
00000BE0                          2068mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE0                 TRUE     2069mmm     IFEQ DEBUG
00000BE0  1639 00C00003           2070mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BE6  0803 0002               2071mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BEA  67F4                    2072mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000BEC  13DA 00C00007           2073mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BF2                          2074mmm     ENDC
00000BF2                          2075mmm 
00000BF2                 FALSE    2076mmm     IFNE DEBUG
00000BF2                          2077mmm     ENDC
00000BF2                          2078mmm 
00000BF2                          2079mmm     ENDM
00000BF2  60E4                    2080mm     BRA LOOP_138
00000BF4                          2081mm EXIT_138
00000BF4                          2082mm     ENDM
00000BF4  7A07                    2083m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BF6                          2084m LOOP_137
00000BF6                          2085mm     BIN2HEX D2,D4,A2
00000BF6  45FA 0583               2086mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000BFA  E99A                    2087mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BFC  1802                    2088mm     MOVE.B D2,D4
00000BFE  0284 0000000F           2089mm     ANDI.L #$F,D4
00000C04  1832 4000               2090mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000C08                          2091mm     ENDM
00000C08                          2092mm     PRINT_CHAR D4,D3
00000C08                          2093mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C08                 TRUE     2094mm     IFEQ DEBUG
00000C08  1639 00C00003           2095mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C0E  0803 0002               2096mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C12  67F4                    2097mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000C14  13C4 00C00007           2098mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C1A                          2099mm     ENDC
00000C1A                          2100mm 
00000C1A                 FALSE    2101mm     IFNE DEBUG
00000C1A                          2102mm     ENDC
00000C1A                          2103mm 
00000C1A                          2104mm     ENDM
00000C1A  57CD FFDA               2105m     DBEQ D5,LOOP_137
00000C1E                          2106m     ENDM
00000C1E                          2107  
00000C1E  45FA 059F               2108      LEA TO(PC),A2
00000C22                          2109m     PRINT_STR A2,D3
00000C22                          2110m LOOP_142
00000C22  0C12 0000               2111m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C26  6700 0016               2112m     BEQ EXIT_142
00000C2A                          2113mm     PRINT_CHAR (A2)+,D3
00000C2A                          2114mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C2A                 TRUE     2115mm     IFEQ DEBUG
00000C2A  1639 00C00003           2116mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C30  0803 0002               2117mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C34  67F4                    2118mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000C36  13DA 00C00007           2119mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C3C                          2120mm     ENDC
00000C3C                          2121mm 
00000C3C                 FALSE    2122mm     IFNE DEBUG
00000C3C                          2123mm     ENDC
00000C3C                          2124mm 
00000C3C                          2125mm     ENDM
00000C3C  60E4                    2126m     BRA LOOP_142
00000C3E                          2127m EXIT_142
00000C3E                          2128m     ENDM
00000C3E                          2129  
00000C3E  2408                    2130      MOVE.L A0,D2
00000C40                          2131m     PRINT_REG D2,D3,D4,D5,A2
00000C40  45FA 057A               2132m     LEA OX(PC),A2
00000C44                          2133mm     PRINT_STR A2,D3
00000C44                          2134mm LOOP_145
00000C44  0C12 0000               2135mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C48  6700 0016               2136mm     BEQ EXIT_145
00000C4C                          2137mmm     PRINT_CHAR (A2)+,D3
00000C4C                          2138mmm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4C                 TRUE     2139mmm     IFEQ DEBUG
00000C4C  1639 00C00003           2140mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C52  0803 0002               2141mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C56  67F4                    2142mmm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C58  13DA 00C00007           2143mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C5E                          2144mmm     ENDC
00000C5E                          2145mmm 
00000C5E                 FALSE    2146mmm     IFNE DEBUG
00000C5E                          2147mmm     ENDC
00000C5E                          2148mmm 
00000C5E                          2149mmm     ENDM
00000C5E  60E4                    2150mm     BRA LOOP_145
00000C60                          2151mm EXIT_145
00000C60                          2152mm     ENDM
00000C60  7A07                    2153m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C62                          2154m LOOP_144
00000C62                          2155mm     BIN2HEX D2,D4,A2
00000C62  45FA 0517               2156mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000C66  E99A                    2157mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C68  1802                    2158mm     MOVE.B D2,D4
00000C6A  0284 0000000F           2159mm     ANDI.L #$F,D4
00000C70  1832 4000               2160mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000C74                          2161mm     ENDM
00000C74                          2162mm     PRINT_CHAR D4,D3
00000C74                          2163mm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C74                 TRUE     2164mm     IFEQ DEBUG
00000C74  1639 00C00003           2165mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C7A  0803 0002               2166mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C7E  67F4                    2167mm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000C80  13C4 00C00007           2168mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C86                          2169mm     ENDC
00000C86                          2170mm 
00000C86                 FALSE    2171mm     IFNE DEBUG
00000C86                          2172mm     ENDC
00000C86                          2173mm 
00000C86                          2174mm     ENDM
00000C86  57CD FFDA               2175m     DBEQ D5,LOOP_144
00000C8A                          2176m     ENDM
00000C8A                          2177  
00000C8A                          2178m     PRINT_CRLF D3,A2
00000C8A  45FA 052A               2179m     LEA CRLF(PC),A2
00000C8E                          2180mm     PRINT_STR A2,D3
00000C8E                          2181mm LOOP_150
00000C8E  0C12 0000               2182mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C92  6700 0016               2183mm     BEQ EXIT_150
00000C96                          2184mmm     PRINT_CHAR (A2)+,D3
00000C96                          2185mmm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C96                 TRUE     2186mmm     IFEQ DEBUG
00000C96  1639 00C00003           2187mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C9C  0803 0002               2188mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CA0  67F4                    2189mmm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000CA2  13DA 00C00007           2190mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA8                          2191mmm     ENDC
00000CA8                          2192mmm 
00000CA8                 FALSE    2193mmm     IFNE DEBUG
00000CA8                          2194mmm     ENDC
00000CA8                          2195mmm 
00000CA8                          2196mmm     ENDM
00000CA8  60E4                    2197mm     BRA LOOP_150
00000CAA                          2198mm EXIT_150
00000CAA                          2199mm     ENDM
00000CAA                          2200m     ENDM
00000CAA                          2201  
00000CAA                          2202      WHILE D0 <GT> #0 DO
00000CAA                          2203s _10000014
00000CAA  B07C 0000               2204s     CMP.W   #0,D0
00000CAE  6F00 001C               2205s     BLE _10000015
00000CB2  5580                    2206          SUB.L #2,D0
00000CB4                          2207  
00000CB4  13D1 00E00001           2208          MOVE.B (A1),DISPLAY
00000CBA                          2209m         PROGRAM (A1),(A0),D2
00000CBA  3091                    2210m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000CBC                          2211m 
00000CBC                          2212m WAIT_FOR_COMPLETE_152
00000CBC  3410                    2213m         MOVE.W (A0),D2
00000CBE                          2214m 
00000CBE                          2215m         IF.W D2 <NE> (A1) THEN
00000CBE  B451                    2216ms     CMP.W   (A1),D2
00000CC0  6700 0004               2217ms     BEQ _0000000D
00000CC4  60F6                    2218m             BRA WAIT_FOR_COMPLETE_152
00000CC6                          2219m         ENDI
00000CC6                          2220ms _0000000D
00000CC6                          2221m         ENDM
00000CC6                          2222  
00000CC6  5488                    2223          ADD.L #2,A0
00000CC8  5489                    2224          ADD.L #2,A1
00000CCA                          2225      ENDW
00000CCA  60DE                    2226s     BRA _10000014
00000CCC                          2227s _10000015
00000CCC                          2228  
00000CCC                          2229m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000CCC  31FC 0000 0000          2230m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000CD2                          2231m 
00000CD2                          2232m WAIT_FOR_COMPLETE_153
00000CD2  3438 0000               2233m         MOVE.W $0,D2
00000CD6                          2234m 
00000CD6                          2235m         IF.W D2 <NE> #0 THEN
00000CD6  B47C 0000               2236ms     CMP.W   #0,D2
00000CDA  6700 0004               2237ms     BEQ _0000000E
00000CDE  60F2                    2238m             BRA WAIT_FOR_COMPLETE_153
00000CE0                          2239m         ENDI
00000CE0                          2240ms _0000000E
00000CE0                          2241m         ENDM
00000CE0                          2242m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000CE0  31FC 0000 0002          2243m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000CE6                          2244m 
00000CE6                          2245m WAIT_FOR_COMPLETE_154
00000CE6  3438 0002               2246m         MOVE.W $2,D2
00000CEA                          2247m 
00000CEA                          2248m         IF.W D2 <NE> #0 THEN
00000CEA  B47C 0000               2249ms     CMP.W   #0,D2
00000CEE  6700 0004               2250ms     BEQ _0000000F
00000CF2  60F2                    2251m             BRA WAIT_FOR_COMPLETE_154
00000CF4                          2252m         ENDI
00000CF4                          2253ms _0000000F
00000CF4                          2254m         ENDM
00000CF4                          2255  
00000CF4                          2256m     PROGRAM D1, $6, D2
00000CF4  31C1 0006               2257m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000CF8                          2258m 
00000CF8                          2259m WAIT_FOR_COMPLETE_155
00000CF8  3438 0006               2260m         MOVE.W $6,D2
00000CFC                          2261m 
00000CFC                          2262m         IF.W D2 <NE> D1 THEN
00000CFC  B441                    2263ms     CMP.W   D1,D2
00000CFE  6700 0004               2264ms     BEQ _00000010
00000D02  60F4                    2265m             BRA WAIT_FOR_COMPLETE_155
00000D04                          2266m         ENDI
00000D04                          2267ms _00000010
00000D04                          2268m         ENDM
00000D04  E089                    2269      LSR.L #8,D1
00000D06  E089                    2270      LSR.L #8,D1
00000D08                          2271m     PROGRAM D1, $4, D2
00000D08  31C1 0004               2272m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000D0C                          2273m 
00000D0C                          2274m WAIT_FOR_COMPLETE_156
00000D0C  3438 0004               2275m         MOVE.W $4,D2
00000D10                          2276m 
00000D10                          2277m         IF.W D2 <NE> D1 THEN
00000D10  B441                    2278ms     CMP.W   D1,D2
00000D12  6700 0004               2279ms     BEQ _00000011
00000D16  60F4                    2280m             BRA WAIT_FOR_COMPLETE_156
00000D18                          2281m         ENDI
00000D18                          2282ms _00000011
00000D18                          2283m         ENDM
00000D18                          2284  
00000D18                          2285m     PROTECT
00000D18  31FC AAAA 2AAA          2286m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000D1E  31FC 5555 1554          2287m     MOVE.W #$5555,$1554
00000D24  31FC A0A0 2AAA          2288m     MOVE.W #$A0A0,$2AAA
00000D2A                          2289m     ENDM
00000D2A                          2290  
00000D2A  6000 F44E               2291      BRA MAIN_LOOP
00000D2E                          2292  
00000D2E                          2293  P
00000D2E  7000                    2294      MOVE.L #0,D0                                    ; D0 will be the data to write
00000D30                          2295  
00000D30                          2296      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000D30  323C 0000               2297s     MOVE.W  #0,D1
00000D34  6000 0046               2298s     BRA _2000000B
00000D38                          2299s _2000000A
00000D38  E988                    2300          LSL.L #4,D0                                 ; make what we have so far more significant
00000D3A                          2301m         WAIT_CHAR D2,D3                             ; next character -> D2
00000D3A                          2302m WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3A                 TRUE     2303m     IFEQ DEBUG
00000D3A  1639 00C00003           2304m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D40  0803 0000               2305m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000D44  67F4                    2306m         BEQ WAIT_FOR_READY_158                      ; NOTHING, CHECK AGAIN
00000D46                          2307m     ENDC
00000D46                          2308m 
00000D46                          2309mm     READ_CHAR D2
00000D46                 TRUE     2310mm     IFEQ DEBUG
00000D46  1439 00C00007           2311mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000D4C                          2312mm     ENDC
00000D4C                 FALSE    2313mm     IFNE DEBUG
00000D4C                          2314mm     ENDC
00000D4C                          2315mm 
00000D4C  B43C 001B               2316mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000D50  6700 F2B6               2317mm     BEQ START
00000D54                          2318mm     ENDM
00000D54                          2319m 
00000D54                 TRUE     2320m     IFEQ DEBUG
00000D54                          2321mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000D54                          2322mm WAIT_FOR_READY_160                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D54                 TRUE     2323mm     IFEQ DEBUG
00000D54  1639 00C00003           2324mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D5A  0803 0002               2325mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D5E  67F4                    2326mm         BEQ WAIT_FOR_READY_160                      ; NO SPACE, CHECK AGAIN
00000D60  13C2 00C00007           2327mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D66                          2328mm     ENDC
00000D66                          2329mm 
00000D66                 FALSE    2330mm     IFNE DEBUG
00000D66                          2331mm     ENDC
00000D66                          2332mm 
00000D66                          2333mm     ENDM
00000D66                          2334m     ENDC
00000D66                          2335m     ENDM
00000D66                          2336m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D66  41FA 0423               2337m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000D6A  0402 0030               2338m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D6E  C4BC 000000FF           2339m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000D74  1430 2000               2340m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D78                          2341m     ENDM
00000D78  8002                    2342          OR.B D2,D0
00000D7A                          2343      ENDF
00000D7A  5241                    2344s     ADD.W   #1,D1
00000D7C                          2345s _2000000B
00000D7C  B27C 0003               2346s     CMP.W   #3,D1
00000D80  6FB6                    2347s     BLE _2000000A
00000D82                          2348  
00000D82                          2349m     PRINT_CRLF D2,A1
00000D82  43FA 0432               2350m     LEA CRLF(PC),A1
00000D86                          2351mm     PRINT_STR A1,D2
00000D86                          2352mm LOOP_163
00000D86  0C11 0000               2353mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D8A  6700 0016               2354mm     BEQ EXIT_163
00000D8E                          2355mmm     PRINT_CHAR (A1)+,D2
00000D8E                          2356mmm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D8E                 TRUE     2357mmm     IFEQ DEBUG
00000D8E  1439 00C00003           2358mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D94  0802 0002               2359mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D98  67F4                    2360mmm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000D9A  13D9 00C00007           2361mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DA0                          2362mmm     ENDC
00000DA0                          2363mmm 
00000DA0                 FALSE    2364mmm     IFNE DEBUG
00000DA0                          2365mmm     ENDC
00000DA0                          2366mmm 
00000DA0                          2367mmm     ENDM
00000DA0  60E4                    2368mm     BRA LOOP_163
00000DA2                          2369mm EXIT_163
00000DA2                          2370mm     ENDM
00000DA2                          2371m     ENDM
00000DA2                          2372  
00000DA2  2047                    2373      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000DA4  7E00                    2374      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000DA6                          2375  
00000DA6                          2376m     UNPROTECT
00000DA6  31FC AAAA 2AAA          2377m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000DAC  4E71                    2378m     NOP
00000DAE  31FC 5555 1554          2379m     MOVE.W #$5555,$1554
00000DB4  4E71                    2380m     NOP
00000DB6  31FC 8080 2AAA          2381m     MOVE.W #$8080,$2AAA
00000DBC  4E71                    2382m     NOP
00000DBE  31FC AAAA 2AAA          2383m     MOVE.W #$AAAA,$2AAA
00000DC4  4E71                    2384m     NOP
00000DC6  31FC 5555 1554          2385m     MOVE.W #$5555,$1554
00000DCC  4E71                    2386m     NOP
00000DCE  31FC 2020 2AAA          2387m     MOVE.W #$2020,$2AAA
00000DD4                          2388m     ENDM
00000DD4                          2389               
00000DD4  45FA 03CC               2390      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000DD8                          2391m     PRINT_STR A2,D2
00000DD8                          2392m LOOP_166
00000DD8  0C12 0000               2393m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DDC  6700 0016               2394m     BEQ EXIT_166
00000DE0                          2395mm     PRINT_CHAR (A2)+,D2
00000DE0                          2396mm WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE0                 TRUE     2397mm     IFEQ DEBUG
00000DE0  1439 00C00003           2398mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DE6  0802 0002               2399mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DEA  67F4                    2400mm         BEQ WAIT_FOR_READY_167                      ; NO SPACE, CHECK AGAIN
00000DEC  13DA 00C00007           2401mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DF2                          2402mm     ENDC
00000DF2                          2403mm 
00000DF2                 FALSE    2404mm     IFNE DEBUG
00000DF2                          2405mm     ENDC
00000DF2                          2406mm 
00000DF2                          2407mm     ENDM
00000DF2  60E4                    2408m     BRA LOOP_166
00000DF4                          2409m EXIT_166
00000DF4                          2410m     ENDM
00000DF4                          2411  
00000DF4                          2412m     PRINT_CHAR '#',D3
00000DF4                          2413m WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF4                 TRUE     2414m     IFEQ DEBUG
00000DF4  1639 00C00003           2415m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DFA  0803 0002               2416m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DFE  67F4                    2417m         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000E00  13F8 0023 00C00007      2418m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000E08                          2419m     ENDC
00000E08                          2420m 
00000E08                 FALSE    2421m     IFNE DEBUG
00000E08                          2422m     ENDC
00000E08                          2423m 
00000E08                          2424m     ENDM
00000E08                          2425m     PRINT_REG D0,D3,D4,D5,A2
00000E08  45FA 03B2               2426m     LEA OX(PC),A2
00000E0C                          2427mm     PRINT_STR A2,D3
00000E0C                          2428mm LOOP_170
00000E0C  0C12 0000               2429mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E10  6700 0016               2430mm     BEQ EXIT_170
00000E14                          2431mmm     PRINT_CHAR (A2)+,D3
00000E14                          2432mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E14                 TRUE     2433mmm     IFEQ DEBUG
00000E14  1639 00C00003           2434mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E1A  0803 0002               2435mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E1E  67F4                    2436mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000E20  13DA 00C00007           2437mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E26                          2438mmm     ENDC
00000E26                          2439mmm 
00000E26                 FALSE    2440mmm     IFNE DEBUG
00000E26                          2441mmm     ENDC
00000E26                          2442mmm 
00000E26                          2443mmm     ENDM
00000E26  60E4                    2444mm     BRA LOOP_170
00000E28                          2445mm EXIT_170
00000E28                          2446mm     ENDM
00000E28  7A07                    2447m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E2A                          2448m LOOP_169
00000E2A                          2449mm     BIN2HEX D0,D4,A2
00000E2A  45FA 034F               2450mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E2E  E998                    2451mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E30  1800                    2452mm     MOVE.B D0,D4
00000E32  0284 0000000F           2453mm     ANDI.L #$F,D4
00000E38  1832 4000               2454mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E3C                          2455mm     ENDM
00000E3C                          2456mm     PRINT_CHAR D4,D3
00000E3C                          2457mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3C                 TRUE     2458mm     IFEQ DEBUG
00000E3C  1639 00C00003           2459mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E42  0803 0002               2460mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E46  67F4                    2461mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000E48  13C4 00C00007           2462mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E4E                          2463mm     ENDC
00000E4E                          2464mm 
00000E4E                 FALSE    2465mm     IFNE DEBUG
00000E4E                          2466mm     ENDC
00000E4E                          2467mm 
00000E4E                          2468mm     ENDM
00000E4E  57CD FFDA               2469m     DBEQ D5,LOOP_169
00000E52                          2470m     ENDM
00000E52                          2471  
00000E52  45FA 036B               2472      LEA TO(PC),A2
00000E56                          2473m     PRINT_STR A2,D3
00000E56                          2474m LOOP_174
00000E56  0C12 0000               2475m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E5A  6700 0016               2476m     BEQ EXIT_174
00000E5E                          2477mm     PRINT_CHAR (A2)+,D3
00000E5E                          2478mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E5E                 TRUE     2479mm     IFEQ DEBUG
00000E5E  1639 00C00003           2480mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E64  0803 0002               2481mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E68  67F4                    2482mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00000E6A  13DA 00C00007           2483mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E70                          2484mm     ENDC
00000E70                          2485mm 
00000E70                 FALSE    2486mm     IFNE DEBUG
00000E70                          2487mm     ENDC
00000E70                          2488mm 
00000E70                          2489mm     ENDM
00000E70  60E4                    2490m     BRA LOOP_174
00000E72                          2491m EXIT_174
00000E72                          2492m     ENDM
00000E72                          2493  
00000E72  2408                    2494      MOVE.L A0,D2
00000E74                          2495m     PRINT_REG D2,D3,D4,D5,A2
00000E74  45FA 0346               2496m     LEA OX(PC),A2
00000E78                          2497mm     PRINT_STR A2,D3
00000E78                          2498mm LOOP_177
00000E78  0C12 0000               2499mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E7C  6700 0016               2500mm     BEQ EXIT_177
00000E80                          2501mmm     PRINT_CHAR (A2)+,D3
00000E80                          2502mmm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E80                 TRUE     2503mmm     IFEQ DEBUG
00000E80  1639 00C00003           2504mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E86  0803 0002               2505mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E8A  67F4                    2506mmm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000E8C  13DA 00C00007           2507mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E92                          2508mmm     ENDC
00000E92                          2509mmm 
00000E92                 FALSE    2510mmm     IFNE DEBUG
00000E92                          2511mmm     ENDC
00000E92                          2512mmm 
00000E92                          2513mmm     ENDM
00000E92  60E4                    2514mm     BRA LOOP_177
00000E94                          2515mm EXIT_177
00000E94                          2516mm     ENDM
00000E94  7A07                    2517m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E96                          2518m LOOP_176
00000E96                          2519mm     BIN2HEX D2,D4,A2
00000E96  45FA 02E3               2520mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E9A  E99A                    2521mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E9C  1802                    2522mm     MOVE.B D2,D4
00000E9E  0284 0000000F           2523mm     ANDI.L #$F,D4
00000EA4  1832 4000               2524mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EA8                          2525mm     ENDM
00000EA8                          2526mm     PRINT_CHAR D4,D3
00000EA8                          2527mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA8                 TRUE     2528mm     IFEQ DEBUG
00000EA8  1639 00C00003           2529mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EAE  0803 0002               2530mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EB2  67F4                    2531mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000EB4  13C4 00C00007           2532mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EBA                          2533mm     ENDC
00000EBA                          2534mm 
00000EBA                 FALSE    2535mm     IFNE DEBUG
00000EBA                          2536mm     ENDC
00000EBA                          2537mm 
00000EBA                          2538mm     ENDM
00000EBA  57CD FFDA               2539m     DBEQ D5,LOOP_176
00000EBE                          2540m     ENDM
00000EBE                          2541  
00000EBE                          2542m     PRINT_CRLF D3,A2
00000EBE  45FA 02F6               2543m     LEA CRLF(PC),A2
00000EC2                          2544mm     PRINT_STR A2,D3
00000EC2                          2545mm LOOP_182
00000EC2  0C12 0000               2546mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EC6  6700 0016               2547mm     BEQ EXIT_182
00000ECA                          2548mmm     PRINT_CHAR (A2)+,D3
00000ECA                          2549mmm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ECA                 TRUE     2550mmm     IFEQ DEBUG
00000ECA  1639 00C00003           2551mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ED0  0803 0002               2552mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ED4  67F4                    2553mmm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000ED6  13DA 00C00007           2554mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EDC                          2555mmm     ENDC
00000EDC                          2556mmm 
00000EDC                 FALSE    2557mmm     IFNE DEBUG
00000EDC                          2558mmm     ENDC
00000EDC                          2559mmm 
00000EDC                          2560mmm     ENDM
00000EDC  60E4                    2561mm     BRA LOOP_182
00000EDE                          2562mm EXIT_182
00000EDE                          2563mm     ENDM
00000EDE                          2564m     ENDM
00000EDE                          2565  
00000EDE                          2566m     PROGRAM D0,(A0),D2
00000EDE  3080                    2567m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000EE0                          2568m 
00000EE0                          2569m WAIT_FOR_COMPLETE_184
00000EE0  3410                    2570m         MOVE.W (A0),D2
00000EE2                          2571m 
00000EE2                          2572m         IF.W D2 <NE> D0 THEN
00000EE2  B440                    2573ms     CMP.W   D0,D2
00000EE4  6700 0004               2574ms     BEQ _00000012
00000EE8  60F6                    2575m             BRA WAIT_FOR_COMPLETE_184
00000EEA                          2576m         ENDI
00000EEA                          2577ms _00000012
00000EEA                          2578m         ENDM
00000EEA                          2579  
00000EEA                          2580m     PROTECT
00000EEA  31FC AAAA 2AAA          2581m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000EF0  31FC 5555 1554          2582m     MOVE.W #$5555,$1554
00000EF6  31FC A0A0 2AAA          2583m     MOVE.W #$A0A0,$2AAA
00000EFC                          2584m     ENDM
00000EFC                          2585  
00000EFC  6000 F27C               2586      BRA MAIN_LOOP
00000F00                          2587      
00000F00                          2588  M
00000F00  7000                    2589      MOVE.L #0,D0                                        ; D0 will be the length to read            
00000F02  7200                    2590      MOVE.L #0,D1                                        ; D1 will be the address to read 
00000F04                          2591  
00000F04                          2592      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000F04  343C 0000               2593s     MOVE.W  #0,D2
00000F08  6000 0046               2594s     BRA _2000000D
00000F0C                          2595s _2000000C
00000F0C  E989                    2596          LSL.L #4,D1                                     ; make what we have so far more significant
00000F0E                          2597m         WAIT_CHAR D3,D4                                 ; next character -> D2
00000F0E                          2598m WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F0E                 TRUE     2599m     IFEQ DEBUG
00000F0E  1839 00C00003           2600m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000F14  0804 0000               2601m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000F18  67F4                    2602m         BEQ WAIT_FOR_READY_186                      ; NOTHING, CHECK AGAIN
00000F1A                          2603m     ENDC
00000F1A                          2604m 
00000F1A                          2605mm     READ_CHAR D3
00000F1A                 TRUE     2606mm     IFEQ DEBUG
00000F1A  1639 00C00007           2607mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000F20                          2608mm     ENDC
00000F20                 FALSE    2609mm     IFNE DEBUG
00000F20                          2610mm     ENDC
00000F20                          2611mm 
00000F20  B63C 001B               2612mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000F24  6700 F0E2               2613mm     BEQ START
00000F28                          2614mm     ENDM
00000F28                          2615m 
00000F28                 TRUE     2616m     IFEQ DEBUG
00000F28                          2617mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000F28                          2618mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F28                 TRUE     2619mm     IFEQ DEBUG
00000F28  1839 00C00003           2620mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000F2E  0804 0002               2621mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000F32  67F4                    2622mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00000F34  13C3 00C00007           2623mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F3A                          2624mm     ENDC
00000F3A                          2625mm 
00000F3A                 FALSE    2626mm     IFNE DEBUG
00000F3A                          2627mm     ENDC
00000F3A                          2628mm 
00000F3A                          2629mm     ENDM
00000F3A                          2630m     ENDC
00000F3A                          2631m     ENDM
00000F3A                          2632m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
00000F3A  41FA 024F               2633m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000F3E  0403 0030               2634m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F42  C6BC 000000FF           2635m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000F48  1630 3000               2636m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000F4C                          2637m     ENDM
00000F4C  8203                    2638          OR.B D3,D1
00000F4E                          2639      ENDF
00000F4E  5242                    2640s     ADD.W   #1,D2
00000F50                          2641s _2000000D
00000F50  B47C 0007               2642s     CMP.W   #7,D2
00000F54  6FB6                    2643s     BLE _2000000C
00000F56                          2644m     PRINT_CRLF D2,A1
00000F56  43FA 025E               2645m     LEA CRLF(PC),A1
00000F5A                          2646mm     PRINT_STR A1,D2
00000F5A                          2647mm LOOP_191
00000F5A  0C11 0000               2648mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F5E  6700 0016               2649mm     BEQ EXIT_191
00000F62                          2650mmm     PRINT_CHAR (A1)+,D2
00000F62                          2651mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F62                 TRUE     2652mmm     IFEQ DEBUG
00000F62  1439 00C00003           2653mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F68  0802 0002               2654mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F6C  67F4                    2655mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00000F6E  13D9 00C00007           2656mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F74                          2657mmm     ENDC
00000F74                          2658mmm 
00000F74                 FALSE    2659mmm     IFNE DEBUG
00000F74                          2660mmm     ENDC
00000F74                          2661mmm 
00000F74                          2662mmm     ENDM
00000F74  60E4                    2663mm     BRA LOOP_191
00000F76                          2664mm EXIT_191
00000F76                          2665mm     ENDM
00000F76                          2666m     ENDM
00000F76                          2667  
00000F76  3001                    2668      MOVE.W D1,D0                                        ; extract the LSword for the length
00000F78  E089                    2669      LSR.L #8,D1                                         ; extract the MSword for the address
00000F7A  E089                    2670      LSR.L #8,D1
00000F7C                          2671  
00000F7C  2241                    2672      MOVE.L D1,A1
00000F7E                          2673      
00000F7E  2047                    2674      MOVE.L D7,A0                                        ; address accumulator -> target address register
00000F80                          2675      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00000F80                          2676  
00000F80                          2677      WHILE D0 <GT> #0 DO
00000F80                          2678s _10000016
00000F80  B07C 0000               2679s     CMP.W   #0,D0
00000F84  6F00 000E               2680s     BLE _10000017
00000F88  5580                    2681          SUB.L #2,D0
00000F8A                          2682  
00000F8A  13D1 00E00001           2683          MOVE.B (A1),DISPLAY
00000F90  30D9                    2684          MOVE.W (A1)+,(A0)+
00000F92                          2685      ENDW
00000F92  60EC                    2686s     BRA _10000016
00000F94                          2687s _10000017
00000F94                          2688      
00000F94  6000 F1E4               2689      BRA MAIN_LOOP
00000F98                          2690      
00000F98                          2691  J
00000F98  2047                    2692      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000F9A  7E00                    2693      MOVE.L #0,D7
00000F9C  2E7C 002FFFFC           2694      MOVE.L #$2FFFFC,A7                                  ; set up the stack pointer 
00000FA2  2C7C 002FFFFC           2695      MOVE.L #$2FFFFC,A6                                  ; set up the frame pointer
00000FA8                          2696  
00000FA8  4E90                    2697      JSR (A0)
00000FAA                          2698      
00000FAA  41FA 0218               2699      LEA BACK(PC),A0
00000FAE                          2700m     PRINT_STR A0,D0
00000FAE                          2701m LOOP_193
00000FAE  0C10 0000               2702m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000FB2  6700 0016               2703m     BEQ EXIT_193
00000FB6                          2704mm     PRINT_CHAR (A0)+,D0
00000FB6                          2705mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FB6                 TRUE     2706mm     IFEQ DEBUG
00000FB6  1039 00C00003           2707mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00000FBC  0800 0002               2708mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00000FC0  67F4                    2709mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00000FC2  13D8 00C00007           2710mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FC8                          2711mm     ENDC
00000FC8                          2712mm 
00000FC8                 FALSE    2713mm     IFNE DEBUG
00000FC8                          2714mm     ENDC
00000FC8                          2715mm 
00000FC8                          2716mm     ENDM
00000FC8  60E4                    2717m     BRA LOOP_193
00000FCA                          2718m EXIT_193
00000FCA                          2719m     ENDM
00000FCA                          2720      
00000FCA  6000 F1AE               2721      BRA MAIN_LOOP
00000FCE                          2722  
00000FCE                          2723  HEX_DIGIT
00000FCE  E98F                    2724      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
00000FD0                          2725m     HEX2BIN D2,D2,A0
00000FD0  41FA 01B9               2726m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000FD4  0402 0030               2727m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FD8  C4BC 000000FF           2728m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000FDE  1430 2000               2729m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000FE2                          2730m     ENDM
00000FE2  8E02                    2731      OR.B D2,D7  
00000FE4  6000 F1B4               2732      BRA GET_INPUT
00000FE8                          2733  
00000FE8  FFFF FFFF               2734      SIMHALT                                             ; halt simulator
00000FEC                          2735  
00000FEC                          2736  ; strings
00000FEC= 50 72 65 73 73 20 ...   2737  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000FFF= 5B 3F 5D 09 09 09 ...   2738  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
0000100B= 5B 76 5D 09 09 09 ...   2739          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
0000101A= 78 78 78 78 78 78 ...   2740          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001032= 78 78 78 78 78 78 ...   2741          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001052= 78 78 78 78 78 78 ...   2742          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001073= 78 78 78 78 78 78 ...   2743          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001084= 5B 7A 5D 09 09 09 ...   2744          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001096= 78 78 78 78 78 78 ...   2745          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000010B7= 78 78 78 78 78 78 ...   2746          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000010D6= 78 78 78 78 78 78 ...   2747          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
000010FA= 78 78 78 78 78 78 ...   2748          DC.B 'xxxxxxxx[j]',TAB,TAB,'JST to C code',CR,LF,NULL
00001117= 48 75 68 3F 0D 0A 00    2749  HUH  DC.B 'Huh?',CR,LF,NULL
0000111E= 20 53 20 72 65 63 ...   2750  READ    DC.B ' S records read, start address = ',NULL
00001140= 57 3A 20 55 6E 6B ...   2751  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001157= 57 3A 20 43 53 20 ...   2752  CS_FAILURE  DC.B 'W: CS failure at ',NULL
00001169= 57 3A 20 52 41 4D ...   2753  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
0000117B= 30 31 32 33 34 35 ...   2754  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000118B= 00 01 02 03 04 05 ...   2755  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000011A2= 4C 6F 61 64 69 6E ...   2756  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000011B6= 0D 0A 00                2757  CRLF    DC.B CR,LF,NULL
000011B9= 3E 20 00                2758  PROMPT  DC.B '> ',NULL
000011BC= 30 78 00                2759  ox      DC.B '0x',NULL
000011BF= 20 2D 3E 20 00          2760  to      DC.B ' -> ',NULL
000011C4= 62 61 63 6B 20 66 ...   2761  BACK    DC.B 'back from the dead!',CR,LF,NULL
000011DA= 4D 44 46 2D 6D 6F ...   2762  VERSION DC.B 'MDF-mon V1.83 (17/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
000011F7                          2763  
000011F7                          2764      END START                                       ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BACK                11C4
BIN2HEX             0
BIN2HEX_LUT         117B
CONTINUE_46         426
CONTINUE_48         462
CONTINUE_51         4A6
CONTINUE_55         528
CONTINUE_59         588
CONTINUE_63         5F2
CONTINUE_67         65E
CONTINUE_71         6D4
CONTINUE_75         734
CONTINUE_79         794
CONTINUE_89         854
CR                  D
CRLF                11B6
CS_FAILURE          1157
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       92C
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_100            91C
EXIT_103            94C
EXIT_107            996
EXIT_110            9B8
EXIT_115            A02
EXIT_117            A80
EXIT_12             170
EXIT_120            AA4
EXIT_125            AEE
EXIT_132            B7A
EXIT_135            BD2
EXIT_138            BF4
EXIT_14             19A
EXIT_142            C3E
EXIT_145            C60
EXIT_150            CAA
EXIT_163            DA2
EXIT_166            DF4
EXIT_170            E28
EXIT_174            E72
EXIT_177            E94
EXIT_182            EDE
EXIT_191            F76
EXIT_193            FCA
EXIT_20             22E
EXIT_22             286
EXIT_24             2B2
EXIT_27             2DC
EXIT_37             38A
EXIT_44             3FE
EXIT_5              110
EXIT_7              130
EXIT_82             7F4
EXIT_86             826
EXIT_9              150
EXIT_92             8B2
EXIT_95             8D2
G                   A06
GET_INPUT           19A
H                   28A
HELP                FFF
HELPPROMPT          FEC
HEX2BIN             10B
HEX2BIN_LUT         118B
HEX_DIGIT           FCE
HUH                 1117
J                   F98
L                   AFE
LF                  A
LOADING             11A2
LOOP_100            900
LOOP_102            94E
LOOP_103            930
LOOP_107            97A
LOOP_109            9BA
LOOP_110            99C
LOOP_115            9E6
LOOP_117            A64
LOOP_119            AA6
LOOP_12             154
LOOP_120            A88
LOOP_125            AD2
LOOP_132            B5E
LOOP_135            BB6
LOOP_137            BF6
LOOP_138            BD8
LOOP_14             17E
LOOP_142            C22
LOOP_144            C62
LOOP_145            C44
LOOP_150            C8E
LOOP_163            D86
LOOP_166            DD8
LOOP_169            E2A
LOOP_170            E0C
LOOP_174            E56
LOOP_176            E96
LOOP_177            E78
LOOP_182            EC2
LOOP_191            F5A
LOOP_193            FAE
LOOP_20             212
LOOP_22             26A
LOOP_24             296
LOOP_26             2DE
LOOP_27             2C0
LOOP_37             36E
LOOP_44             3E2
LOOP_5              F4
LOOP_7              114
LOOP_82             7D8
LOOP_86             80A
LOOP_9              134
LOOP_92             896
LOOP_94             8D4
LOOP_95             8B6
M                   F00
MAIN_LOOP           17A
NULL                0
OX                  11BC
P                   D2E
PRINTSTR            296
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4E
PROMPT              11B9
PROTECT             A40
R                   2B6
RAM                 200000
RAM_ERROR           1169
READ                111E
READ_CHAR           62D
READ_DATA_TO_POKE   392
RESET               4
ROM                 0
S                   402
STACK               0
START               8
TAB                 9
TO                  11BF
UNPROTECT           979
UNREC               1140
V                   292
VERSION             11DA
W                   38E
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_152  CBC
WAIT_FOR_COMPLETE_153  CD2
WAIT_FOR_COMPLETE_154  CE6
WAIT_FOR_COMPLETE_155  CF8
WAIT_FOR_COMPLETE_156  D0C
WAIT_FOR_COMPLETE_184  EE0
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_101  908
WAIT_FOR_READY_104  938
WAIT_FOR_READY_106  960
WAIT_FOR_READY_108  982
WAIT_FOR_READY_111  9A4
WAIT_FOR_READY_113  9CC
WAIT_FOR_READY_116  9EE
WAIT_FOR_READY_118  A6C
WAIT_FOR_READY_121  A90
WAIT_FOR_READY_123  AB8
WAIT_FOR_READY_126  ADA
WAIT_FOR_READY_127  B0C
WAIT_FOR_READY_129  B26
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_133  B66
WAIT_FOR_READY_136  BBE
WAIT_FOR_READY_139  BE0
WAIT_FOR_READY_141  C08
WAIT_FOR_READY_143  C2A
WAIT_FOR_READY_146  C4C
WAIT_FOR_READY_148  C74
WAIT_FOR_READY_15   186
WAIT_FOR_READY_151  C96
WAIT_FOR_READY_158  D3A
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_160  D54
WAIT_FOR_READY_164  D8E
WAIT_FOR_READY_167  DE0
WAIT_FOR_READY_168  DF4
WAIT_FOR_READY_171  E14
WAIT_FOR_READY_173  E3C
WAIT_FOR_READY_175  E5E
WAIT_FOR_READY_178  E80
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_180  EA8
WAIT_FOR_READY_183  ECA
WAIT_FOR_READY_186  F0E
WAIT_FOR_READY_188  F28
WAIT_FOR_READY_192  F62
WAIT_FOR_READY_194  FB6
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_23   272
WAIT_FOR_READY_25   29E
WAIT_FOR_READY_28   2C8
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2F0
WAIT_FOR_READY_31   306
WAIT_FOR_READY_32   31C
WAIT_FOR_READY_33   330
WAIT_FOR_READY_34   344
WAIT_FOR_READY_35   358
WAIT_FOR_READY_38   376
WAIT_FOR_READY_39   394
WAIT_FOR_READY_41   3AE
WAIT_FOR_READY_45   3EA
WAIT_FOR_READY_46   40A
WAIT_FOR_READY_48   446
WAIT_FOR_READY_51   48A
WAIT_FOR_READY_55   50C
WAIT_FOR_READY_59   56C
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_63   5D6
WAIT_FOR_READY_67   642
WAIT_FOR_READY_71   6B8
WAIT_FOR_READY_75   718
WAIT_FOR_READY_79   778
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_83   7E0
WAIT_FOR_READY_84   7F4
WAIT_FOR_READY_87   812
WAIT_FOR_READY_89   838
WAIT_FOR_READY_93   89E
WAIT_FOR_READY_96   8BE
WAIT_FOR_READY_98   8E6
WAIT_FOR_SRECORD    40A
Z                   A0E
_00000000           1DA
_00000001           1EE
_00000002           4EC
_00000003           82A
_00000004           4FA
_00000005           6A0
_00000006           628
_00000007           82A
_00000008           7D4
_00000009           82A
_0000000A           920
_0000000B           92C
_0000000C           AEE
_0000000D           CC6
_0000000E           CE0
_0000000F           CF4
_00000010           D04
_00000011           D18
_00000012           EEA
_10000000           480
_10000001           4D6
_10000002           502
_10000003           558
_10000004           562
_10000005           5B8
_10000006           5CC
_10000007           622
_10000008           62C
_10000009           69A
_1000000A           638
_1000000B           68E
_1000000C           6AE
_1000000D           704
_1000000E           70E
_1000000F           764
_10000010           76E
_10000011           7C4
_10000012           82E
_10000013           884
_10000014           CAA
_10000015           CCC
_10000016           F80
_10000017           F94
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A20
_20000005           A30
_20000006           A4A
_20000007           AF0
_20000008           B0A
_20000009           B4E
_2000000A           D38
_2000000B           D7C
_2000000C           F0C
_2000000D           F50
