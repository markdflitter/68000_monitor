00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 19/10/2021 12:55:38

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor 
00000000                             6  
00000000                             7  *-----------------------------------------------------------
00000000                             8  
00000000                             9      ORG  $0
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00000000                 14  NULL                EQU 0
00000000  =00000009                 15  TAB                 EQU 9
00000000  =0000000D                 16  CR                  EQU 13
00000000  =0000000A                 17  LF                  EQU 10
00000000                            18  
00000000  =00000000                 19  ROM                 EQU $0
00000000  =00200000                 20  RAM                 EQU $200000
00000000  =002E0000                 21  STACK_ADDRESS       EQU $2E0000
00000000                            22  
00000000  =00A00000                 23  MC68230_BASE        EQU $A00000
00000000  =00000000                 24  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 25  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 26  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 27  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 28  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 29  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 30  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 31  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 32  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 33  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 34  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 35  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 36  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 37  MC68230_STATUS_             EQU $D
00000000                            38  
00000000  =00A00001                 39  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 40  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 41  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 42  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 43  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 44  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 45  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            46  
00000000  =00A0000B                 47  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 48  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 49  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 50  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 51  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 52  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 53  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 54  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 55  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 56  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 57  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 58  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            59  
00000000  =00000020                 60  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 61  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 62  MC68230_PORT_C_CS           EQU $08
00000000                            63  
00000000  =00000000                 64  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 65  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 66  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 67  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 68  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 69  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 70  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            71  
00000000  =00000007                 72  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 73  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            74  
00000000  =00000007                 75  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 76  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 77  IDE_STATUS_READY            EQU 6
00000000  =00000003                 78  IDE_STATUS_DRQ              EQU 3
00000000                            79  
00000000  =00C00000                 80  DUART_BASE          EQU $C00000
00000000  =00000000                 81  DUART_MRA_          EQU $0
00000000  =00000001                 82  DUART_CSRA_         EQU $1
00000000  =00000001                 83  DUART_SRA_          EQU $1
00000000  =00000002                 84  DUART_CRA_          EQU $2
00000000  =00000003                 85  DUART_TXA_          EQU $3
00000000  =00000003                 86  DUART_RXA_          EQU $3
00000000  =00000004                 87  DUART_ACR_          EQU $4
00000000  =00000005                 88  DUART_IMR_          EQU $5
00000000  =00000006                 89  DUART_CTUR_         EQU $6
00000000  =00000007                 90  DUART_CTLR_         EQU $7
00000000  =00000008                 91  DUART_MRB_          EQU $8
00000000  =00000009                 92  DUART_CSRB_         EQU $9
00000000  =00000009                 93  DUART_SRB_          EQU $9
00000000  =0000000A                 94  DUART_CRB_          EQU $A
00000000  =0000000B                 95  DUART_TXB_          EQU $B
00000000  =0000000B                 96  DUART_RXB_          EQU $B
00000000  =0000000C                 97  DUART_IVR_          EQU $C
00000000  =0000000D                 98  DUART_OPCR_         EQU $D
00000000  =0000000E                 99  DUART_SET_OPR_      EQU $E
00000000  =0000000F                100  DUART_RESET_OPR_    EQU $F
00000000                           101  
00000000  =00C00001                102  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                103  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                104  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                105  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                106  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                107  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           108  
00000000  =00C00011                109  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                110  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                111  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                112  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                113  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                114  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           115  
00000000  =00C00009                116  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                117  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                118  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                119  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                120  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                121  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                122  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                123  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           124  
00000000  =00E00000                125  DISPLAY_BASE        EQU $E00000
00000000  =00000000                126  DISPLAY_            EQU $0
00000000  =00E00001                127  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           128  
00000000                           129  ; macros
00000000                           130  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           131  ; the input register is changed during the process
00000000                           132  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           133  BIN2HEX MACRO
00000000                           134      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           135      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           136      MOVE.B \1,\2
00000000                           137      ANDI.L #$F,\2
00000000                           138      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           139      ENDM
00000000                           140  
00000000                           141  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           142  ; the input register is changed during the process
00000000                           143  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           144  HEX2BIN MACRO
00000000                           145      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           146      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           147      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           148      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           149      ENDM
00000000                           150  
00000000                           151  ; send a single char to the serial port
00000000                           152  ; \1 = char to send, \2 = data register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  PRINT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #2,\2                                  ; check for space to send
00000000                           159          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           160          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           161      ENDC
00000000                           162  
00000000                           163      IFNE DEBUG
00000000                           164          MOVE.B \1,D1
00000000                           165          MOVE.L #6,D0   
00000000                           166          TRAP #15                                    ; write to terminal in simulator
00000000                           167      ENDC
00000000                           168  
00000000                           169      ENDM
00000000                           170  
00000000                           171  ; send CR,LF to the serial port
00000000                           172  ; \1 = data register to use for status poll, /2 = working address register
00000000                           173  PRINT_CRLF MACRO
00000000                           174      LEA CRLF(PC),\2
00000000                           175      PRINT_STR \2,\1
00000000                           176      ENDM
00000000                           177  
00000000                           178  ; send C-style, zero terminated string to the serial port
00000000                           179  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           180  PRINT_STR MACRO
00000000                           181  LOOP\@
00000000                           182      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           183      BEQ EXIT\@
00000000                           184      PRINT_CHAR (\1)+,\2
00000000                           185      BRA LOOP\@
00000000                           186  EXIT\@
00000000                           187      ENDM
00000000                           188    
00000000                           189  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           190  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           191  PRINT_REG_4BIT MACRO
00000000                           192      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           193      MOVE.B \1,\3
00000000                           194      ANDI.L #$F,\3
00000000                           195      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           196      PRINT_CHAR \3,\2
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           200  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           201  PRINT_REG MACRO
00000000                           202      LEA ox(PC),\5
00000000                           203      PRINT_STR \5,\2
00000000                           204      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           205  LOOP\@
00000000                           206      BIN2HEX \1,\3,\5
00000000                           207      PRINT_CHAR \3,\2
00000000                           208      DBEQ \4,LOOP\@
00000000                           209      ENDM
00000000                           210  
00000000                           211  ; wait for a char from the serial port
00000000                           212  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           213  ; will stamp on D0 and D1 in debug mode
00000000                           214  WAIT_CHAR MACRO
00000000                           215  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           216      IFEQ DEBUG
00000000                           217          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           218          BTST #0,\2                                  ; check for character
00000000                           219          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           220      ENDC
00000000                           221  
00000000                           222      READ_CHAR \1
00000000                           223  
00000000                           224      IFEQ DEBUG
00000000                           225          PRINT_CHAR \1,\2                            ; echo it back
00000000                           226      ENDC
00000000                           227      ENDM
00000000                           228  
00000000                           229  ; read a char from the serial port - assumes that there is one!
00000000                           230  ; \ 1= data register for read char
00000000                           231  ; will stamp on D0 and D1 in debug mode
00000000                           232  READ_CHAR MACRO
00000000                           233      IFEQ DEBUG
00000000                           234          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           235      ENDC
00000000                           236      IFNE DEBUG
00000000                           237          MOVE.L #5,D0    
00000000                           238          TRAP #15                                    ; read from keyboard in simulator
00000000                           239          MOVE.L D1,\1
00000000                           240      ENDC
00000000                           241  
00000000                           242      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           243      BEQ START
00000000                           244      ENDM
00000000                           245  
00000000                           246  
00000000                           247  ; read data from the download serial port
00000000                           248  ; \ 1= data register for read char
00000000                           249  DOWNLOAD MACRO
00000000                           250  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           251  
00000000                           252      MOVE.B DUART_SRA,\1                             ; read download status register
00000000                           253      BTST #0,\1                                      ; check for character
00000000                           254      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           255      
00000000                           256      MOVE.B DUART_RXA,\1                             ; got a character, read it
00000000                           257      
00000000                           258      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           259      BEQ START
00000000                           260  
00000000                           261      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           262  
00000000                           263      ENDM
00000000                           264  
00000000                           265  ; read two hex digits from the download serial port and convert to a byte
00000000                           266  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           267  DOWNLOAD_BYTE MACRO
00000000                           268      MOVE.B #2,\4
00000000                           269      WHILE.B \4 <GT> 0 DO
00000000                           270          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           271          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           272          ;PRINT_CHAR \2,\3
00000000                           273          HEX2BIN \2,\2,\6
00000000                           274          OR.B \2,\1
00000000                           275          SUB.B #1,\4
00000000                           276      ENDW
00000000                           277  
00000000                           278      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           279      MOVE.B \1,\2
00000000                           280      ADD.L \1,\5
00000000                           281  
00000000                           282      ENDM
00000000                           283  
00000000                           284  ; unprotect the EEPROM
00000000                           285  UNPROTECT MACRO
00000000                           286      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           287      NOP
00000000                           288      MOVE.W #$5555,$1554
00000000                           289      NOP
00000000                           290      MOVE.W #$8080,$2AAA
00000000                           291      NOP
00000000                           292      MOVE.W #$AAAA,$2AAA
00000000                           293      NOP
00000000                           294      MOVE.W #$5555,$1554
00000000                           295      NOP
00000000                           296      MOVE.W #$2020,$2AAA
00000000                           297      ENDM
00000000                           298      
00000000                           299  ; protect the EEPROM
00000000                           300  PROTECT MACRO
00000000                           301      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           302      MOVE.W #$5555,$1554
00000000                           303      MOVE.W #$A0A0,$2AAA
00000000                           304      ENDM
00000000                           305  ; write word to EEPROM
00000000                           306  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           307  PROGRAM MACRO
00000000                           308    MOVE.W \1,\2                                      ; write the data
00000000                           309  
00000000                           310  WAIT_FOR_COMPLETE\@
00000000                           311          MOVE.W \2,\3
00000000                           312  
00000000                           313          IF.W \3 <NE> \1 THEN
00000000                           314              BRA WAIT_FOR_COMPLETE\@
00000000                           315          ENDI
00000000                           316          ENDM
00000000                           317          
00000000                           318  ; program vector to EEPROM
00000000                           319  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           320  PROGRAM_VECTOR MACRO
00000000                           321      ADD.L #2,\2
00000000                           322      PROGRAM \1, (\2), \3                            ; write it
00000000                           323      LSR.L #8,\1
00000000                           324      LSR.L #8,\1
00000000                           325      SUB.L #2,\2
00000000                           326      PROGRAM \1, (\2), \3
00000000                           327      ENDM
00000000                           328  
00000000                           329  ; read an ide register
00000000                           330  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           331  READ_8 MACRO
00000000                           332      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           333      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           334      ORI.B \1, \3
00000000                           335      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           336      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           337      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           338      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           339      ORI.B #MC68230_PORT_C_READ, \3
00000000                           340      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           341      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           342      ENDM
00000000                           343      
00000000                           344  ; write an ide register
00000000                           345  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           346  WRITE_8 MACRO
00000000                           347      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           348      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           349      ORI.B \2, \3
00000000                           350      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           351      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           352      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           353      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           354      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           355      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           356      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           357      ENDM
00000000                           358  
00000000                           359  ; read ide data
00000000                           360  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           361  READ_16 MACRO
00000000                           362      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           363      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           364      
00000000                           365      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           366      ORI.B \1, \3
00000000                           367      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           368      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           369      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           370      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           371      LSL.W #8, \2
00000000                           372      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           373      ORI.B #MC68230_PORT_C_READ, \3
00000000                           374      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           375      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           376      ENDM
00000000                           377      
00000000                           378  ; read ide data
00000000                           379  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           380  READ_32 MACRO
00000000                           381      READ_16 \1, \2, \3
00000000                           382      LSL.L #8, \2
00000000                           383      LSL.L #8, \2
00000000                           384      READ_16 \1, \2, \3
00000000                           385      ENDM
00000000                           386          
00000000                           387  ; read ide status
00000000                           388  ;\1 = data register for result, \2 = working data register 
00000000                           389  READ_IDE_STATUS MACRO   
00000000                           390      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           391      ENDM
00000000                           392      
00000000                           393  ; wait for ide drive to be ready
00000000                           394  ;\1 = working data register 1, \2 = working data register 2
00000000                           395  WAIT_DRIVE_READY MACRO
00000000                           396  LOOP\@
00000000                           397      READ_IDE_STATUS \1, \2
00000000                           398      BTST #IDE_STATUS_READY, \1
00000000                           399      BEQ LOOP\@
00000000                           400      ENDM
00000000                           401      
00000000                           402  ; wait for ide drive to be not busy
00000000                           403  ;\1 = working data register 1, \2 = working data register 2
00000000                           404  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           405  LOOP\@
00000000                           406      READ_IDE_STATUS \1, \2
00000000                           407      BTST #IDE_STATUS_BUSY, \1
00000000                           408      BNE LOOP\@
00000000                           409      ENDM
00000000                           410      
00000000                           411  ; wait for ide drive to have data for us
00000000                           412  ;\1 = working data register 1, \2 = working data register 2
00000000                           413  WAIT_DRIVE_DRQ MACRO
00000000                           414  LOOP\@
00000000                           415      READ_IDE_STATUS \1, \2
00000000                           416      BTST #IDE_STATUS_DRQ, \1
00000000                           417      BEQ LOOP\@
00000000                           418      ENDM
00000000                           419      
00000000                           420  ; prepare to send a read command
00000000                           421  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           422  SET_READ_ADDRESS MACRO
00000000                           423      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           424      MOVE.L \1,\3
00000000                           425      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           426      LSR.L #8, \3
00000000                           427      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           428      LSR.L #8, \3                                
00000000                           429      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           430      LSR.L #8, \3
00000000                           431      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           432      ANDI.B #$0F,\3
00000000                           433      OR.B \3,\4
00000000                           434      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           435      ENDM
00000000                           436  
00000000                           437  ; send command
00000000                           438  ; \1 = command, \2 = working data register 1,
00000000                           439  SEND_COMMAND MACRO
00000000                           440      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           441      ENDM
00000000                           442      
00000000                           443  ; send read command and wait
00000000                           444  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           445  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           446      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           447      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           448      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           449      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           450      WAIT_DRIVE_DRQ \2, \3
00000000                           451      ENDM
00000000                           452  
00000000                           453  ; register catalogue
00000000                           454  ; D0 - used for simulator I/O
00000000                           455  ; D1 - used for simulator I/O
00000000                           456  ; D2 - read character
00000000                           457  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           458  ; D6 - working register used in R/W
00000000                           459  ; D7 - address accumulator, reset by download
00000000                           460  ; A0 - address of string to print 
00000000                           461  
00000000                           462  ; start vector
00000000= 002E0000                 463  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 464  RESET   DC.L START                              ; RESET
00000008= 00001C5E                 465  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001C5E                 466          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001DB2                 467          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001DC2                 468          DC.L UNHANDLED_HANDLER
00000018= 00001DC2                 469          DC.L UNHANDLED_HANDLER
0000001C= 00001DC2                 470          DC.L UNHANDLED_HANDLER
00000020= 00001DC2                 471          DC.L UNHANDLED_HANDLER
00000024= 00001DC2                 472          DC.L UNHANDLED_HANDLER
00000028= 00001DC2                 473          DC.L UNHANDLED_HANDLER
0000002C= 00001DC2                 474          DC.L UNHANDLED_HANDLER
00000030= 00001DC2                 475          DC.L UNHANDLED_HANDLER
00000034= 00001DC2                 476          DC.L UNHANDLED_HANDLER
00000038= 00001DC2                 477          DC.L UNHANDLED_HANDLER
0000003C= 00001DC2                 478          DC.L UNHANDLED_HANDLER
00000040= 00001DC2                 479          DC.L UNHANDLED_HANDLER
00000044= 00001DC2                 480          DC.L UNHANDLED_HANDLER
00000048= 00001DC2                 481          DC.L UNHANDLED_HANDLER
0000004C= 00001DC2                 482          DC.L UNHANDLED_HANDLER
00000050= 00001DC2                 483          DC.L UNHANDLED_HANDLER
00000054= 00001DC2                 484          DC.L UNHANDLED_HANDLER
00000058= 00001DC2                 485          DC.L UNHANDLED_HANDLER
0000005C= 00001DC2                 486          DC.L UNHANDLED_HANDLER
00000060= 00001DE6                 487          DC.L SPURIOUS_HANDLER
00000064= 00001DC2                 488          DC.L UNHANDLED_HANDLER
00000068= 00001DC2                 489          DC.L UNHANDLED_HANDLER
0000006C= 00001DC2                 490          DC.L UNHANDLED_HANDLER
00000070= 00001DC2                 491          DC.L UNHANDLED_HANDLER
00000074= 00001DC2                 492          DC.L UNHANDLED_HANDLER
00000078= 00001DC2                 493          DC.L UNHANDLED_HANDLER
0000007C= 00001DC2                 494          DC.L UNHANDLED_HANDLER
00000080= 00001DC2                 495          DC.L UNHANDLED_HANDLER
00000084= 00001DC2                 496          DC.L UNHANDLED_HANDLER
00000088= 00001DC2                 497          DC.L UNHANDLED_HANDLER
0000008C= 00001DC2                 498          DC.L UNHANDLED_HANDLER
00000090= 00001DC2                 499          DC.L UNHANDLED_HANDLER
00000094= 00001DC2                 500          DC.L UNHANDLED_HANDLER
00000098= 00001DC2                 501          DC.L UNHANDLED_HANDLER
0000009C= 00001DC2                 502          DC.L UNHANDLED_HANDLER
000000A0= 00001DC2                 503          DC.L UNHANDLED_HANDLER
000000A4= 00001DC2                 504          DC.L UNHANDLED_HANDLER
000000A8= 00001DC2                 505          DC.L UNHANDLED_HANDLER
000000AC= 00001DC2                 506          DC.L UNHANDLED_HANDLER
000000B0= 00001DC2                 507          DC.L UNHANDLED_HANDLER
000000B4= 00001DC2                 508          DC.L UNHANDLED_HANDLER
000000B8= 00001DC2                 509          DC.L UNHANDLED_HANDLER
000000BC= 00001DC2                 510          DC.L UNHANDLED_HANDLER
000000C0= 00001DC2                 511          DC.L UNHANDLED_HANDLER
000000C4= 00001DC2                 512          DC.L UNHANDLED_HANDLER
000000C8= 00001DC2                 513          DC.L UNHANDLED_HANDLER
000000CC= 00001DC2                 514          DC.L UNHANDLED_HANDLER
000000D0= 00001DC2                 515          DC.L UNHANDLED_HANDLER
000000D4= 00001DC2                 516          DC.L UNHANDLED_HANDLER
000000D8= 00001DC2                 517          DC.L UNHANDLED_HANDLER 
000000DC= 00001DC2                 518          DC.L UNHANDLED_HANDLER
000000E0= 00001DC2                 519          DC.L UNHANDLED_HANDLER
000000E4= 00001DC2                 520          DC.L UNHANDLED_HANDLER 
000000E8= 00001DC2                 521          DC.L UNHANDLED_HANDLER 
000000EC= 00001DC2                 522          DC.L UNHANDLED_HANDLER
000000F0= 00001DC2                 523          DC.L UNHANDLED_HANDLER 
000000F4= 00001DC2                 524          DC.L UNHANDLED_HANDLER 
000000F8= 00001DC2                 525          DC.L UNHANDLED_HANDLER 
000000FC= 00001DC2                 526          DC.L UNHANDLED_HANDLER
00000100= 00001DD6                 527  USER    DC.L TICK_HANDLER
00000104                           528      ; start of program  
00000104                           529  START
00000104  2E7C 002E0000            530      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       531      MOVE.B #0,DISPLAY
00000112                           532  
00000112  7000                     533      MOVE.L #0,D0
00000114  1039 00C00019            534      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           535  
0000011A                           536  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       537      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       538      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           539      
0000012A                           540      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                541s     MOVE.W  #$50,D1
0000012E  6000 000E                542s     BRA _20000001
00000132                           543s _20000000
00000132  13C1 00C00005            544          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     545          NOP
0000013A                           546      ENDF
0000013A  0441 0010                547s     SUB.W   #$10,D1
0000013E                           548s _20000001
0000013E  B27C 0010                549s     CMP.W   #$10,D1
00000142  6CEE                     550s     BGE _20000000
00000144                           551  
00000144                           552      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                553s     MOVE.W  #$50,D1
00000148  6000 000E                554s     BRA _20000003
0000014C                           555s _20000002
0000014C  13C1 00C00015            556          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     557          NOP
00000154                           558      ENDF
00000154  0441 0010                559s     SUB.W   #$10,D1
00000158                           560s _20000003
00000158  B27C 0010                561s     CMP.W   #$10,D1
0000015C  6CEE                     562s     BGE _20000002
0000015E                           563      
0000015E                           564  ;initialise UART
0000015E  13FC 0000 00C0000B       565      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       566      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       567      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       568      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       569      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           570  
00000186                           571  ; channel A
00000186  13FC 0013 00C00001       572      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       573      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       574      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       575      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           576  
000001A6                           577  ; channel B
000001A6  13FC 0013 00C00011       578      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       579      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       580      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       581      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       582      MOVE.B #64,DUART_IVR
000001CE                           583  
000001CE                           584m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           585m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      586m     IFEQ DEBUG
000001CE  1239 00C00003            587m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                588m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     589m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       590m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           591m     ENDC
000001E2                           592m 
000001E2                 FALSE     593m     IFNE DEBUG
000001E2                           594m     ENDC
000001E2                           595m 
000001E2                           596m     ENDM
000001E2                           597m     PRINT_CHAR #0,D1
000001E2                           598m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      599m     IFEQ DEBUG
000001E2  1239 00C00003            600m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                601m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     602m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       603m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           604m     ENDC
000001F6                           605m 
000001F6                 FALSE     606m     IFNE DEBUG
000001F6                           607m     ENDC
000001F6                           608m 
000001F6                           609m     ENDM
000001F6                           610m     PRINT_CHAR #0,D1
000001F6                           611m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      612m     IFEQ DEBUG
000001F6  1239 00C00003            613m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                614m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     615m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       616m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           617m     ENDC
0000020A                           618m 
0000020A                 FALSE     619m     IFNE DEBUG
0000020A                           620m     ENDC
0000020A                           621m 
0000020A                           622m     ENDM
0000020A                           623      
0000020A                           624      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                625s     CMP.W   #$0F,D0
0000020E  6600 0008                626s     BNE _00000000
00000212  1039 00C00005            627          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           628      ENDI
00000218                           629s _00000000
00000218                           630  
00000218  13FC 0001 00E00001       631      MOVE.B #1,DISPLAY
00000220                           632      
00000220                           633m     PRINT_CRLF D1,A0
00000220  41FA 1E0F                634m     LEA CRLF(PC),A0
00000224                           635mm     PRINT_STR A0,D1
00000224                           636mm LOOP_5
00000224  0C10 0000                637mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                638mm     BEQ EXIT_5
0000022C                           639mmm     PRINT_CHAR (A0)+,D1
0000022C                           640mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      641mmm     IFEQ DEBUG
0000022C  1239 00C00003            642mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                643mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     644mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            645mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           646mmm     ENDC
0000023E                           647mmm 
0000023E                 FALSE     648mmm     IFNE DEBUG
0000023E                           649mmm     ENDC
0000023E                           650mmm 
0000023E                           651mmm     ENDM
0000023E  60E4                     652mm     BRA LOOP_5
00000240                           653mm EXIT_5
00000240                           654mm     ENDM
00000240                           655m     ENDM
00000240  41FA 1EA4                656      LEA VERSION(PC),A0
00000244                           657m     PRINT_STR A0,D3
00000244                           658m LOOP_7
00000244  0C10 0000                659m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                660m     BEQ EXIT_7
0000024C                           661mm     PRINT_CHAR (A0)+,D3
0000024C                           662mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      663mm     IFEQ DEBUG
0000024C  1639 00C00003            664mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                665mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     666mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            667mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           668mm     ENDC
0000025E                           669mm 
0000025E                 FALSE     670mm     IFNE DEBUG
0000025E                           671mm     ENDC
0000025E                           672mm 
0000025E                           673mm     ENDM
0000025E  60E4                     674m     BRA LOOP_7
00000260                           675m EXIT_7
00000260                           676m     ENDM
00000260                           677  
00000260  41F9 00002104            678      LEA END,A0
00000266  2008                     679      MOVE.L A0,D0
00000268                           680m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1DCD                681m     LEA OX(PC),A0
0000026C                           682mm     PRINT_STR A0,D1
0000026C                           683mm LOOP_10
0000026C  0C10 0000                684mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                685mm     BEQ EXIT_10
00000274                           686mmm     PRINT_CHAR (A0)+,D1
00000274                           687mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      688mmm     IFEQ DEBUG
00000274  1239 00C00003            689mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                690mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     691mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            692mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           693mmm     ENDC
00000286                           694mmm 
00000286                 FALSE     695mmm     IFNE DEBUG
00000286                           696mmm     ENDC
00000286                           697mmm 
00000286                           698mmm     ENDM
00000286  60E4                     699mm     BRA LOOP_10
00000288                           700mm EXIT_10
00000288                           701mm     ENDM
00000288  7607                     702m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           703m LOOP_9
0000028A                           704mm     BIN2HEX D0,D2,A0
0000028A  41FA 1D6A                705mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     706mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     707mm     MOVE.B D0,D2
00000292  0282 0000000F            708mm     ANDI.L #$F,D2
00000298  1430 2000                709mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           710mm     ENDM
0000029C                           711mm     PRINT_CHAR D2,D1
0000029C                           712mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      713mm     IFEQ DEBUG
0000029C  1239 00C00003            714mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                715mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     716mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            717mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           718mm     ENDC
000002AE                           719mm 
000002AE                 FALSE     720mm     IFNE DEBUG
000002AE                           721mm     ENDC
000002AE                           722mm 
000002AE                           723mm     ENDM
000002AE  57CB FFDA                724m     DBEQ D3,LOOP_9
000002B2                           725m     ENDM
000002B2                           726m     PRINT_CRLF D1,A0
000002B2  41FA 1D7D                727m     LEA CRLF(PC),A0
000002B6                           728mm     PRINT_STR A0,D1
000002B6                           729mm LOOP_15
000002B6  0C10 0000                730mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                731mm     BEQ EXIT_15
000002BE                           732mmm     PRINT_CHAR (A0)+,D1
000002BE                           733mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      734mmm     IFEQ DEBUG
000002BE  1239 00C00003            735mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                736mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     737mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            738mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           739mmm     ENDC
000002D0                           740mmm 
000002D0                 FALSE     741mmm     IFNE DEBUG
000002D0                           742mmm     ENDC
000002D0                           743mmm 
000002D0                           744mmm     ENDM
000002D0  60E4                     745mm     BRA LOOP_15
000002D2                           746mm EXIT_15
000002D2                           747mm     ENDM
000002D2                           748m     ENDM
000002D2                           749  
000002D2  41FA 1B38                750      LEA HELPPROMPT(PC),A0
000002D6                           751m     PRINT_STR A0,D3
000002D6                           752m LOOP_17
000002D6  0C10 0000                753m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                754m     BEQ EXIT_17
000002DE                           755mm     PRINT_CHAR (A0)+,D3
000002DE                           756mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      757mm     IFEQ DEBUG
000002DE  1639 00C00003            758mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                759mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     760mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            761mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           762mm     ENDC
000002F0                           763mm 
000002F0                 FALSE     764mm     IFNE DEBUG
000002F0                           765mm     ENDC
000002F0                           766mm 
000002F0                           767mm     ENDM
000002F0  60E4                     768m     BRA LOOP_17
000002F2                           769m EXIT_17
000002F2                           770m     ENDM
000002F2                           771  
000002F2                           772m     PRINT_CRLF D3,A0
000002F2  41FA 1D3D                773m     LEA CRLF(PC),A0
000002F6                           774mm     PRINT_STR A0,D3
000002F6                           775mm LOOP_20
000002F6  0C10 0000                776mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                777mm     BEQ EXIT_20
000002FE                           778mmm     PRINT_CHAR (A0)+,D3
000002FE                           779mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      780mmm     IFEQ DEBUG
000002FE  1639 00C00003            781mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                782mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     783mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            784mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           785mmm     ENDC
00000310                           786mmm 
00000310                 FALSE     787mmm     IFNE DEBUG
00000310                           788mmm     ENDC
00000310                           789mmm 
00000310                           790mmm     ENDM
00000310  60E4                     791mm     BRA LOOP_20
00000312                           792mm EXIT_20
00000312                           793mm     ENDM
00000312                           794m     ENDM
00000312                           795  
00000312  7E00                     796      MOVE.L #0,D7                                    ; address accumulator
00000314                           797  
00000314  13FC 0002 00E00001       798      MOVE.B #2,DISPLAY
0000031C                           799      
0000031C  13FC 0000 00A00001       800      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       801      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       802      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       803      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           804      
0000033C  13FC 0003 00E00001       805      MOVE.B #3,DISPLAY
00000344                           806      
00000344                           807      
00000344                           808  MAIN_LOOP
00000344  41FA 1CEE                809      LEA PROMPT(PC),A0
00000348                           810m     PRINT_STR A0,D3
00000348                           811m LOOP_22
00000348  0C10 0000                812m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                813m     BEQ EXIT_22
00000350                           814mm     PRINT_CHAR (A0)+,D3
00000350                           815mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      816mm     IFEQ DEBUG
00000350  1639 00C00003            817mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                818mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     819mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            820mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           821mm     ENDC
00000362                           822mm 
00000362                 FALSE     823mm     IFNE DEBUG
00000362                           824mm     ENDC
00000362                           825mm 
00000362                           826mm     ENDM
00000362  60E4                     827m     BRA LOOP_22
00000364                           828m EXIT_22
00000364                           829m     ENDM
00000364                           830  
00000364                           831  GET_INPUT
00000364                           832m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           833m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      834m     IFEQ DEBUG
00000364  1639 00C00003            835m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                836m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     837m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           838m     ENDC
00000370                           839m 
00000370                           840mm     READ_CHAR D2
00000370                 TRUE      841mm     IFEQ DEBUG
00000370  1439 00C00007            842mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           843mm     ENDC
00000376                 FALSE     844mm     IFNE DEBUG
00000376                           845mm     ENDC
00000376                           846mm 
00000376  B43C 001B                847mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                848mm     BEQ START
0000037E                           849mm     ENDM
0000037E                           850m 
0000037E                 TRUE      851m     IFEQ DEBUG
0000037E                           852mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           853mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      854mm     IFEQ DEBUG
0000037E  1639 00C00003            855mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                856mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     857mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            858mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           859mm     ENDC
00000390                           860mm 
00000390                 FALSE     861mm     IFNE DEBUG
00000390                           862mm     ENDC
00000390                           863mm 
00000390                           864mm     ENDM
00000390                           865m     ENDC
00000390                           866m     ENDM
00000390                           867  
00000390                           868      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                869s     CMP.B   #'0',D2
00000394  6D00 000E                870s     BLT _00000001
00000398  B43C 0039                871s     CMP.B   #'9',D2
0000039C  6E00 0006                872s     BGT _00000001
000003A0  6000 18A2                873          BRA HEX_DIGIT
000003A4                           874      ENDI
000003A4                           875s _00000001
000003A4                           876      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                877s     CMP.B   #'A',D2
000003A8  6D00 000E                878s     BLT _00000002
000003AC  B43C 0046                879s     CMP.B   #'F',D2
000003B0  6E00 0006                880s     BGT _00000002
000003B4  6000 188E                881          BRA HEX_DIGIT
000003B8                           882      ENDI
000003B8                           883s _00000002
000003B8                           884  
000003B8  B43C 0077                885      CMP.B #'w',D2
000003BC  6700 01C6                886      BEQ W
000003C0                           887  
000003C0  B43C 006C                888      CMP.B #'l',D2
000003C4  6700 08CE                889      BEQ L 
000003C8                           890  
000003C8  B43C 0070                891      CMP.B #'p',D2
000003CC  6700 0C10                892      BEQ P
000003D0                           893  
000003D0                           894m     PRINT_CRLF D3,A0
000003D0  41FA 1C5F                895m     LEA CRLF(PC),A0
000003D4                           896mm     PRINT_STR A0,D3
000003D4                           897mm LOOP_28
000003D4  0C10 0000                898mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                899mm     BEQ EXIT_28
000003DC                           900mmm     PRINT_CHAR (A0)+,D3
000003DC                           901mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      902mmm     IFEQ DEBUG
000003DC  1639 00C00003            903mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                904mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     905mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            906mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           907mmm     ENDC
000003EE                           908mmm 
000003EE                 FALSE     909mmm     IFNE DEBUG
000003EE                           910mmm     ENDC
000003EE                           911mmm 
000003EE                           912mmm     ENDM
000003EE  60E4                     913mm     BRA LOOP_28
000003F0                           914mm EXIT_28
000003F0                           915mm     ENDM
000003F0                           916m     ENDM
000003F0                           917   
000003F0  B43C 003F                918      CMP.B #'?',D2
000003F4  6700 008A                919      BEQ H
000003F8                           920   
000003F8  B43C 0076                921      CMP.B #'v',D2
000003FC  6700 008A                922      BEQ V
00000400                           923      
00000400  B43C 0072                924      CMP.B #'r',D2
00000404  6700 00A6                925      BEQ R
00000408                           926  
00000408  B43C 0073                927      CMP.B #'s',D2
0000040C  6700 01F0                928      BEQ S
00000410                           929  
00000410  B43C 0067                930      CMP.B #'g',D2
00000414  6700 0788                931      BEQ G   
00000418                           932  
00000418  B43C 007A                933      CMP.B #'z',D2
0000041C  6700 0786                934      BEQ Z   
00000420                           935  
00000420  B43C 0078                936      CMP.B #'x',D2
00000424  6700 0D88                937      BEQ X
00000428                           938  
00000428  B43C 0049                939      CMP.B #'I',D2
0000042C  6700 0E9C                940      BEQ EI
00000430                           941  
00000430  B43C 006F                942      CMP.B #'o',D2
00000434  6700 0EA4                943      BEQ DI
00000438                           944  
00000438  B43C 0023                945      CMP.B #'#',D2
0000043C  6700 0EAC                946      BEQ HASH
00000440                           947  
00000440  B43C 0069                948      CMP.B #'i',D2
00000444  2A7C 00000000            949      MOVE.L #0, A5               ; not boot
0000044A  6700 0EB4                950      BEQ IB
0000044E                           951  
0000044E  B43C 0062                952      CMP.B #'b',D2
00000452  2A7C 00000001            953      MOVE.L #1, A5               ; boot
00000458  6700 0EA6                954      BEQ IB
0000045C                           955  
0000045C  41FA 1B36                956      LEA HUH(PC),A0
00000460                           957m     PRINT_STR A0,D3
00000460                           958m LOOP_30
00000460  0C10 0000                959m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000464  6700 0016                960m     BEQ EXIT_30
00000468                           961mm     PRINT_CHAR (A0)+,D3
00000468                           962mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      963mm     IFEQ DEBUG
00000468  1639 00C00003            964mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000046E  0803 0002                965mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000472  67F4                     966mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000474  13D8 00C00007            967mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047A                           968mm     ENDC
0000047A                           969mm 
0000047A                 FALSE     970mm     IFNE DEBUG
0000047A                           971mm     ENDC
0000047A                           972mm 
0000047A                           973mm     ENDM
0000047A  60E4                     974m     BRA LOOP_30
0000047C                           975m EXIT_30
0000047C                           976m     ENDM
0000047C                           977  
0000047C  6000 FEC6                978      BRA MAIN_LOOP
00000480                           979  
00000480                           980  ; commands
00000480                           981  H
00000480  41FA 199D                982      LEA HELP(PC),A0
00000484  6000 0006                983      BRA PRINTIT
00000488                           984  
00000488                           985  V
00000488  41FA 1C5C                986      LEA VERSION(PC),A0
0000048C                           987  PRINTIT
0000048C                           988m     PRINT_STR A0,D3    
0000048C                           989m LOOP_32
0000048C  0C10 0000                990m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000490  6700 0016                991m     BEQ EXIT_32
00000494                           992mm     PRINT_CHAR (A0)+,D3
00000494                           993mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000494                 TRUE      994mm     IFEQ DEBUG
00000494  1639 00C00003            995mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000049A  0803 0002                996mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000049E  67F4                     997mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
000004A0  13D8 00C00007            998mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004A6                           999mm     ENDC
000004A6                          1000mm 
000004A6                 FALSE    1001mm     IFNE DEBUG
000004A6                          1002mm     ENDC
000004A6                          1003mm 
000004A6                          1004mm     ENDM
000004A6  60E4                    1005m     BRA LOOP_32
000004A8                          1006m EXIT_32
000004A8                          1007m     ENDM
000004A8  6000 FE9A               1008      BRA MAIN_LOOP
000004AC                          1009  
000004AC                          1010  R
000004AC  2047                    1011      MOVE.L D7,A0                                    ; address accumulator -> address register
000004AE  7E00                    1012      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B0  2410                    1013      MOVE.L (A0),D2                                  ; read the memory and print it
000004B2                          1014m     PRINT_REG D2,D3,D4,D5,A0
000004B2  41FA 1B83               1015m     LEA OX(PC),A0
000004B6                          1016mm     PRINT_STR A0,D3
000004B6                          1017mm LOOP_35
000004B6  0C10 0000               1018mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004BA  6700 0016               1019mm     BEQ EXIT_35
000004BE                          1020mmm     PRINT_CHAR (A0)+,D3
000004BE                          1021mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                 TRUE     1022mmm     IFEQ DEBUG
000004BE  1639 00C00003           1023mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004C4  0803 0002               1024mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C8  67F4                    1025mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004CA  13D8 00C00007           1026mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004D0                          1027mmm     ENDC
000004D0                          1028mmm 
000004D0                 FALSE    1029mmm     IFNE DEBUG
000004D0                          1030mmm     ENDC
000004D0                          1031mmm 
000004D0                          1032mmm     ENDM
000004D0  60E4                    1033mm     BRA LOOP_35
000004D2                          1034mm EXIT_35
000004D2                          1035mm     ENDM
000004D2  7A07                    1036m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004D4                          1037m LOOP_34
000004D4                          1038mm     BIN2HEX D2,D4,A0
000004D4  41FA 1B20               1039mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004D8  E99A                    1040mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004DA  1802                    1041mm     MOVE.B D2,D4
000004DC  0284 0000000F           1042mm     ANDI.L #$F,D4
000004E2  1830 4000               1043mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004E6                          1044mm     ENDM
000004E6                          1045mm     PRINT_CHAR D4,D3
000004E6                          1046mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E6                 TRUE     1047mm     IFEQ DEBUG
000004E6  1639 00C00003           1048mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EC  0803 0002               1049mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F0  67F4                    1050mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004F2  13C4 00C00007           1051mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F8                          1052mm     ENDC
000004F8                          1053mm 
000004F8                 FALSE    1054mm     IFNE DEBUG
000004F8                          1055mm     ENDC
000004F8                          1056mm 
000004F8                          1057mm     ENDM
000004F8  57CD FFDA               1058m     DBEQ D5,LOOP_34
000004FC                          1059m     ENDM
000004FC                          1060      
000004FC                          1061m     PRINT_CHAR #32,D3
000004FC                          1062m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FC                 TRUE     1063m     IFEQ DEBUG
000004FC  1639 00C00003           1064m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000502  0803 0002               1065m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000506  67F4                    1066m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000508  13FC 0020 00C00007      1067m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000510                          1068m     ENDC
00000510                          1069m 
00000510                 FALSE    1070m     IFNE DEBUG
00000510                          1071m     ENDC
00000510                          1072m 
00000510                          1073m     ENDM
00000510                          1074  
00000510  E19A                    1075      ROL.L #8,D2
00000512                          1076m     PRINT_CHAR D2,D3
00000512                          1077m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1078m     IFEQ DEBUG
00000512  1639 00C00003           1079m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1080m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1081m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1082m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1083m     ENDC
00000524                          1084m 
00000524                 FALSE    1085m     IFNE DEBUG
00000524                          1086m     ENDC
00000524                          1087m 
00000524                          1088m     ENDM
00000524  E19A                    1089      ROL.L #8,D2
00000526                          1090m     PRINT_CHAR D2,D3
00000526                          1091m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1092m     IFEQ DEBUG
00000526  1639 00C00003           1093m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1094m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1095m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1096m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1097m     ENDC
00000538                          1098m 
00000538                 FALSE    1099m     IFNE DEBUG
00000538                          1100m     ENDC
00000538                          1101m 
00000538                          1102m     ENDM
00000538  E19A                    1103      ROL.L #8,D2
0000053A                          1104m     PRINT_CHAR D2,D3
0000053A                          1105m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1106m     IFEQ DEBUG
0000053A  1639 00C00003           1107m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1108m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1109m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1110m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1111m     ENDC
0000054C                          1112m 
0000054C                 FALSE    1113m     IFNE DEBUG
0000054C                          1114m     ENDC
0000054C                          1115m 
0000054C                          1116m     ENDM
0000054C  E19A                    1117      ROL.L #8,D2
0000054E                          1118m     PRINT_CHAR D2,D3
0000054E                          1119m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054E                 TRUE     1120m     IFEQ DEBUG
0000054E  1639 00C00003           1121m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000554  0803 0002               1122m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000558  67F4                    1123m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000055A  13C2 00C00007           1124m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000560                          1125m     ENDC
00000560                          1126m 
00000560                 FALSE    1127m     IFNE DEBUG
00000560                          1128m     ENDC
00000560                          1129m 
00000560                          1130m     ENDM
00000560                          1131  
00000560                          1132m     PRINT_CRLF D3,A0
00000560  41FA 1ACF               1133m     LEA CRLF(PC),A0
00000564                          1134mm     PRINT_STR A0,D3
00000564                          1135mm LOOP_45
00000564  0C10 0000               1136mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016               1137mm     BEQ EXIT_45
0000056C                          1138mmm     PRINT_CHAR (A0)+,D3
0000056C                          1139mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE     1140mmm     IFEQ DEBUG
0000056C  1639 00C00003           1141mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000572  0803 0002               1142mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                    1143mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007           1144mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                          1145mmm     ENDC
0000057E                          1146mmm 
0000057E                 FALSE    1147mmm     IFNE DEBUG
0000057E                          1148mmm     ENDC
0000057E                          1149mmm 
0000057E                          1150mmm     ENDM
0000057E  60E4                    1151mm     BRA LOOP_45
00000580                          1152mm EXIT_45
00000580                          1153mm     ENDM
00000580                          1154m     ENDM
00000580                          1155      
00000580  6000 FDC2               1156      BRA MAIN_LOOP
00000584                          1157  
00000584                          1158  W
00000584                          1159      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000584  3C3C 0000               1160s     MOVE.W  #0,D6
00000588  6000 0046               1161s     BRA _20000005
0000058C                          1162s _20000004
0000058C  E98D                    1163          LSL.L #4,D5                                     ; make what we have so far more significant
0000058E                          1164m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000058E                          1165m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058E                 TRUE     1166m     IFEQ DEBUG
0000058E  1639 00C00003           1167m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000594  0803 0000               1168m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000598  67F4                    1169m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
0000059A                          1170m     ENDC
0000059A                          1171m 
0000059A                          1172mm     READ_CHAR D2
0000059A                 TRUE     1173mm     IFEQ DEBUG
0000059A  1439 00C00007           1174mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000005A0                          1175mm     ENDC
000005A0                 FALSE    1176mm     IFNE DEBUG
000005A0                          1177mm     ENDC
000005A0                          1178mm 
000005A0  B43C 001B               1179mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000005A4  6700 FB5E               1180mm     BEQ START
000005A8                          1181mm     ENDM
000005A8                          1182m 
000005A8                 TRUE     1183m     IFEQ DEBUG
000005A8                          1184mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000005A8                          1185mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A8                 TRUE     1186mm     IFEQ DEBUG
000005A8  1639 00C00003           1187mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005AE  0803 0002               1188mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B2  67F4                    1189mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005B4  13C2 00C00007           1190mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005BA                          1191mm     ENDC
000005BA                          1192mm 
000005BA                 FALSE    1193mm     IFNE DEBUG
000005BA                          1194mm     ENDC
000005BA                          1195mm 
000005BA                          1196mm     ENDM
000005BA                          1197m     ENDC
000005BA                          1198m     ENDM
000005BA                          1199m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005BA  41FA 1A4A               1200m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005BE  0402 0030               1201m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005C2  C4BC 000000FF           1202m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005C8  1430 2000               1203m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005CC                          1204m     ENDM
000005CC  8A02                    1205          OR.B D2,D5
000005CE                          1206      ENDF
000005CE  5246                    1207s     ADD.W   #1,D6
000005D0                          1208s _20000005
000005D0  BC7C 0007               1209s     CMP.W   #7,D6
000005D4  6FB6                    1210s     BLE _20000004
000005D6                          1211  
000005D6                          1212m     PRINT_CRLF D3,A0
000005D6  41FA 1A59               1213m     LEA CRLF(PC),A0
000005DA                          1214mm     PRINT_STR A0,D3
000005DA                          1215mm LOOP_52
000005DA  0C10 0000               1216mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005DE  6700 0016               1217mm     BEQ EXIT_52
000005E2                          1218mmm     PRINT_CHAR (A0)+,D3
000005E2                          1219mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                 TRUE     1220mmm     IFEQ DEBUG
000005E2  1639 00C00003           1221mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005E8  0803 0002               1222mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005EC  67F4                    1223mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005EE  13D8 00C00007           1224mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005F4                          1225mmm     ENDC
000005F4                          1226mmm 
000005F4                 FALSE    1227mmm     IFNE DEBUG
000005F4                          1228mmm     ENDC
000005F4                          1229mmm 
000005F4                          1230mmm     ENDM
000005F4  60E4                    1231mm     BRA LOOP_52
000005F6                          1232mm EXIT_52
000005F6                          1233mm     ENDM
000005F6                          1234m     ENDM
000005F6                          1235  
000005F6  2047                    1236      MOVE.L D7,A0                                    ; address accumulator -> address register
000005F8                          1237  
000005F8  2085                    1238      MOVE.L D5,(A0)                                  ; write the data
000005FA                          1239  
000005FA  6000 FD48               1240      BRA MAIN_LOOP
000005FE                          1241  
000005FE                          1242  ; register map for S
000005FE                          1243  ; A0 - start address
000005FE                          1244  ; A1 - offset
000005FE                          1245  ; A2 - next address to write
000005FE                          1246  ; A3 - next location (jmp)
000005FE                          1247  ; A4 - Working Address Register
000005FE                          1248  ; D0 - record count
000005FE                          1249  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005FE                          1250  ; D2 - checksum
000005FE                          1251  ; D3 - data byte count
000005FE                          1252  ; D4 - read address, moved into A2
000005FE                          1253  ; D5 - temp
000005FE                          1254  ; D6 - temp
000005FE                          1255  ; D7 - temp
000005FE                          1256  S
000005FE  2078 0000               1257      MOVE.L 0,A0                                     ; start address -> A0
00000602  2247                    1258      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000604  7E00                    1259      MOVE.L #0,D7
00000606  7000                    1260      MOVE.L #0,D0                                    ; count of records read -> D0
00000608                          1261          
00000608                          1262  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000608                          1263m     DOWNLOAD D1
00000608                          1264m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1265m 
00000608  1239 00C00003           1266m     MOVE.B DUART_SRA,D1                             ; READ DOWNLOAD STATUS REGISTER
0000060E  0801 0000               1267m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000612  67F4                    1268m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
00000614                          1269m     
00000614  1239 00C00007           1270m     MOVE.B DUART_RXA,D1                             ; GOT A CHARACTER, READ IT
0000061A                          1271m     
0000061A  B23C 001B               1272m     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000061E  6700 FAE4               1273m     BEQ START
00000622                          1274m 
00000622  13C1 00E00001           1275m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000628                          1276m 
00000628                          1277m     ENDM
00000628  B23C 0053               1278      CMP.B #'S',D1                                   ; found S?
0000062C  66DA                    1279      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000062E                          1280      
0000062E                          1281m     PRINT_CHAR #'.',D5                              ; print a progress indicator
0000062E                          1282m WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                 TRUE     1283m     IFEQ DEBUG
0000062E  1A39 00C00003           1284m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000634  0805 0002               1285m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000638  67F4                    1286m         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
0000063A  13FC 002E 00C00007      1287m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000642                          1288m     ENDC
00000642                          1289m 
00000642                 FALSE    1290m     IFNE DEBUG
00000642                          1291m     ENDC
00000642                          1292m 
00000642                          1293m     ENDM
00000642                          1294      ;PRINT_CHAR #'S',D5                             ; print the S
00000642  5280                    1295      ADD.L #1,D0                                     ; read another S record, increment count
00000644                          1296      
00000644                          1297m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000644                          1298m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000644                          1299m 
00000644  1239 00C00003           1300m     MOVE.B DUART_SRA,D1                             ; READ DOWNLOAD STATUS REGISTER
0000064A  0801 0000               1301m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000064E  67F4                    1302m     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
00000650                          1303m     
00000650  1239 00C00007           1304m     MOVE.B DUART_RXA,D1                             ; GOT A CHARACTER, READ IT
00000656                          1305m     
00000656  B23C 001B               1306m     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000065A  6700 FAA8               1307m     BEQ START
0000065E                          1308m 
0000065E  13C1 00E00001           1309m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000664                          1310m 
00000664                          1311m     ENDM
00000664                          1312      ;PRINT_CHAR D1,D5
00000664                          1313  
00000664  7400                    1314      MOVE.L #0,D2                                    ; clear the checksum
00000666  7600                    1315      MOVE.L #0,D3
00000668                          1316  
00000668                          1317m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000668  1E3C 0002               1318m     MOVE.B #2,D7
0000066C                          1319m     WHILE.B D7 <GT> 0 DO
0000066C                          1320ms _10000000
0000066C  BE38 0000               1321ms     CMP.B   0,D7
00000670  6F00 003C               1322ms     BLE _10000001
00000674  E98B                    1323m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000676                          1324mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000676                          1325mm WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000676                          1326mm 
00000676  1A39 00C00003           1327mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
0000067C  0805 0000               1328mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000680  67F4                    1329mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000682                          1330mm     
00000682  1A39 00C00007           1331mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000688                          1332mm     
00000688  BA3C 001B               1333mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000068C  6700 FA76               1334mm     BEQ START
00000690                          1335mm 
00000690  13C5 00E00001           1336mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000696                          1337mm 
00000696                          1338mm     ENDM
00000696                          1339m         ;PRINT_CHAR D5,D6
00000696                          1340mm         HEX2BIN D5,D5,A4
00000696  49FA 196E               1341mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000069A  0405 0030               1342mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000069E  CABC 000000FF           1343mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006A4  1A34 5000               1344mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006A8                          1345mm     ENDM
000006A8  8605                    1346m         OR.B D5,D3
000006AA  5307                    1347m         SUB.B #1,D7
000006AC                          1348m     ENDW
000006AC  60BE                    1349ms     BRA _10000000
000006AE                          1350ms _10000001
000006AE                          1351m 
000006AE  7A00                    1352m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006B0  1A03                    1353m     MOVE.B D3,D5
000006B2  D483                    1354m     ADD.L D3,D2
000006B4                          1355m 
000006B4                          1356m     ENDM
000006B4                          1357      
000006B4                          1358      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006B4  B23C 0030               1359s     CMP.B   #'0',D1
000006B8  6600 000A               1360s     BNE.L   _00000003
000006BC                          1361          ;PRINT_CRLF D5,A4
000006BC  6000 FF4A               1362          BRA WAIT_FOR_SRECORD
000006C0                          1363      ELSE
000006C0  6000 02D4               1364s     BRA _00000004
000006C4                          1365s _00000003
000006C4                          1366          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006C4  B23C 0031               1367s     CMP.B   #'1',D1
000006C8  6708                    1368s     BEQ.S   _00000005
000006CA  B23C 0032               1369s     CMP.B   #'2',D1
000006CE  6600 0158               1370s     BNE.L   _00000006
000006D2                          1371s _00000005
000006D2  5783                    1372              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000006D4                          1373  
000006D4  7800                    1374              MOVE.L #0,D4                            ; read two bytes of address
000006D6                          1375m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000006D6  1E3C 0002               1376m     MOVE.B #2,D7
000006DA                          1377m     WHILE.B D7 <GT> 0 DO
000006DA                          1378ms _10000002
000006DA  BE38 0000               1379ms     CMP.B   0,D7
000006DE  6F00 003C               1380ms     BLE _10000003
000006E2  E98C                    1381m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006E4                          1382mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006E4                          1383mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E4                          1384mm 
000006E4  1A39 00C00003           1385mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000006EA  0805 0000               1386mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006EE  67F4                    1387mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000006F0                          1388mm     
000006F0  1A39 00C00007           1389mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000006F6                          1390mm     
000006F6  BA3C 001B               1391mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006FA  6700 FA08               1392mm     BEQ START
000006FE                          1393mm 
000006FE  13C5 00E00001           1394mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000704                          1395mm 
00000704                          1396mm     ENDM
00000704                          1397m         ;PRINT_CHAR D5,D6
00000704                          1398mm         HEX2BIN D5,D5,A4
00000704  49FA 1900               1399mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000708  0405 0030               1400mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000070C  CABC 000000FF           1401mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000712  1A34 5000               1402mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000716                          1403mm     ENDM
00000716  8805                    1404m         OR.B D5,D4
00000718  5307                    1405m         SUB.B #1,D7
0000071A                          1406m     ENDW
0000071A  60BE                    1407ms     BRA _10000002
0000071C                          1408ms _10000003
0000071C                          1409m 
0000071C  7A00                    1410m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000071E  1A04                    1411m     MOVE.B D4,D5
00000720  D484                    1412m     ADD.L D4,D2
00000722                          1413m 
00000722                          1414m     ENDM
00000722                          1415m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000722  1E3C 0002               1416m     MOVE.B #2,D7
00000726                          1417m     WHILE.B D7 <GT> 0 DO
00000726                          1418ms _10000004
00000726  BE38 0000               1419ms     CMP.B   0,D7
0000072A  6F00 003C               1420ms     BLE _10000005
0000072E  E98C                    1421m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000730                          1422mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000730                          1423mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000730                          1424mm 
00000730  1A39 00C00003           1425mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000736  0805 0000               1426mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000073A  67F4                    1427mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
0000073C                          1428mm     
0000073C  1A39 00C00007           1429mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000742                          1430mm     
00000742  BA3C 001B               1431mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000746  6700 F9BC               1432mm     BEQ START
0000074A                          1433mm 
0000074A  13C5 00E00001           1434mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000750                          1435mm 
00000750                          1436mm     ENDM
00000750                          1437m         ;PRINT_CHAR D5,D6
00000750                          1438mm         HEX2BIN D5,D5,A4
00000750  49FA 18B4               1439mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000754  0405 0030               1440mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000758  CABC 000000FF           1441mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000075E  1A34 5000               1442mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000762                          1443mm     ENDM
00000762  8805                    1444m         OR.B D5,D4
00000764  5307                    1445m         SUB.B #1,D7
00000766                          1446m     ENDW
00000766  60BE                    1447ms     BRA _10000004
00000768                          1448ms _10000005
00000768                          1449m 
00000768  7A00                    1450m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000076A  1A04                    1451m     MOVE.B D4,D5
0000076C  D484                    1452m     ADD.L D4,D2
0000076E                          1453m 
0000076E                          1454m     ENDM
0000076E                          1455  
0000076E                          1456              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
0000076E  B23C 0032               1457s     CMP.B   #'2',D1
00000772  6600 0050               1458s     BNE.L   _00000007
00000776  5383                    1459                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000778                          1460m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000778  1E3C 0002               1461m     MOVE.B #2,D7
0000077C                          1462m     WHILE.B D7 <GT> 0 DO
0000077C                          1463ms _10000006
0000077C  BE38 0000               1464ms     CMP.B   0,D7
00000780  6F00 003C               1465ms     BLE _10000007
00000784  E98C                    1466m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000786                          1467mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000786                          1468mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000786                          1469mm 
00000786  1A39 00C00003           1470mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
0000078C  0805 0000               1471mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000790  67F4                    1472mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000792                          1473mm     
00000792  1A39 00C00007           1474mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000798                          1475mm     
00000798  BA3C 001B               1476mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000079C  6700 F966               1477mm     BEQ START
000007A0                          1478mm 
000007A0  13C5 00E00001           1479mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007A6                          1480mm 
000007A6                          1481mm     ENDM
000007A6                          1482m         ;PRINT_CHAR D5,D6
000007A6                          1483mm         HEX2BIN D5,D5,A4
000007A6  49FA 185E               1484mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007AA  0405 0030               1485mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007AE  CABC 000000FF           1486mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007B4  1A34 5000               1487mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B8                          1488mm     ENDM
000007B8  8805                    1489m         OR.B D5,D4
000007BA  5307                    1490m         SUB.B #1,D7
000007BC                          1491m     ENDW
000007BC  60BE                    1492ms     BRA _10000006
000007BE                          1493ms _10000007
000007BE                          1494m 
000007BE  7A00                    1495m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C0  1A04                    1496m     MOVE.B D4,D5
000007C2  D484                    1497m     ADD.L D4,D2
000007C4                          1498m 
000007C4                          1499m     ENDM
000007C4                          1500              ENDI
000007C4                          1501s _00000007
000007C4                          1502  
000007C4  2444                    1503              MOVE.L D4,A2                            ; put the address in an address register
000007C6  D5C9                    1504              ADD.L A1,A2                             ; add in the offset
000007C8                          1505  
000007C8                          1506              WHILE.B D3 <HI> #0 DO                   ; read the data bytes
000007C8                          1507s _10000008
000007C8  B63C 0000               1508s     CMP.B   #0,D3
000007CC  6300 0054               1509s     BLS _10000009
000007D0                          1510m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000007D0  1E3C 0002               1511m     MOVE.B #2,D7
000007D4                          1512m     WHILE.B D7 <GT> 0 DO
000007D4                          1513ms _1000000A
000007D4  BE38 0000               1514ms     CMP.B   0,D7
000007D8  6F00 003C               1515ms     BLE _1000000B
000007DC  E989                    1516m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000007DE                          1517mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007DE                          1518mm WAIT_FOR_READY_70                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DE                          1519mm 
000007DE  1A39 00C00003           1520mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E4  0805 0000               1521mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E8  67F4                    1522mm     BEQ WAIT_FOR_READY_70                           ; NOTHING, CHECK AGAIN
000007EA                          1523mm     
000007EA  1A39 00C00007           1524mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000007F0                          1525mm     
000007F0  BA3C 001B               1526mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007F4  6700 F90E               1527mm     BEQ START
000007F8                          1528mm 
000007F8  13C5 00E00001           1529mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007FE                          1530mm 
000007FE                          1531mm     ENDM
000007FE                          1532m         ;PRINT_CHAR D5,D6
000007FE                          1533mm         HEX2BIN D5,D5,A4
000007FE  49FA 1806               1534mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000802  0405 0030               1535mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000806  CABC 000000FF           1536mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000080C  1A34 5000               1537mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000810                          1538mm     ENDM
00000810  8205                    1539m         OR.B D5,D1
00000812  5307                    1540m         SUB.B #1,D7
00000814                          1541m     ENDW
00000814  60BE                    1542ms     BRA _1000000A
00000816                          1543ms _1000000B
00000816                          1544m 
00000816  7A00                    1545m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000818  1A01                    1546m     MOVE.B D1,D5
0000081A  D481                    1547m     ADD.L D1,D2
0000081C                          1548m 
0000081C                          1549m     ENDM
0000081C                          1550   
0000081C  14C1                    1551                  MOVE.B D1,(A2)+                     ; store it!
0000081E                          1552  
0000081E  5303                    1553                  SUB.B #1,D3                         ; 1 less byte to go
00000820                          1554              ENDW
00000820  60A6                    1555s     BRA _10000008
00000822                          1556s _10000009
00000822                          1557  
00000822  7200                    1558              MOVE.L #0,D1                            ; not done yet
00000824                          1559          ELSE
00000824  6000 0170               1560s     BRA _00000008
00000828                          1561s _00000006
00000828                          1562              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000828  B23C 0038               1563s     CMP.B   #'8',D1
0000082C  6600 00F2               1564s     BNE.L   _00000009
00000830  7800                    1565                  MOVE.L #0,D4                        ; read the 24 bit start address
00000832                          1566m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000832  1E3C 0002               1567m     MOVE.B #2,D7
00000836                          1568m     WHILE.B D7 <GT> 0 DO
00000836                          1569ms _1000000C
00000836  BE38 0000               1570ms     CMP.B   0,D7
0000083A  6F00 003C               1571ms     BLE _1000000D
0000083E  E98C                    1572m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000840                          1573mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000840                          1574mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                          1575mm 
00000840  1A39 00C00003           1576mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000846  0805 0000               1577mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000084A  67F4                    1578mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
0000084C                          1579mm     
0000084C  1A39 00C00007           1580mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000852                          1581mm     
00000852  BA3C 001B               1582mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000856  6700 F8AC               1583mm     BEQ START
0000085A                          1584mm 
0000085A  13C5 00E00001           1585mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000860                          1586mm 
00000860                          1587mm     ENDM
00000860                          1588m         ;PRINT_CHAR D5,D6
00000860                          1589mm         HEX2BIN D5,D5,A4
00000860  49FA 17A4               1590mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000864  0405 0030               1591mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000868  CABC 000000FF           1592mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000086E  1A34 5000               1593mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000872                          1594mm     ENDM
00000872  8805                    1595m         OR.B D5,D4
00000874  5307                    1596m         SUB.B #1,D7
00000876                          1597m     ENDW
00000876  60BE                    1598ms     BRA _1000000C
00000878                          1599ms _1000000D
00000878                          1600m 
00000878  7A00                    1601m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000087A  1A04                    1602m     MOVE.B D4,D5
0000087C  D484                    1603m     ADD.L D4,D2
0000087E                          1604m 
0000087E                          1605m     ENDM
0000087E                          1606m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000087E  1E3C 0002               1607m     MOVE.B #2,D7
00000882                          1608m     WHILE.B D7 <GT> 0 DO
00000882                          1609ms _1000000E
00000882  BE38 0000               1610ms     CMP.B   0,D7
00000886  6F00 003C               1611ms     BLE _1000000F
0000088A  E98C                    1612m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000088C                          1613mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000088C                          1614mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088C                          1615mm 
0000088C  1A39 00C00003           1616mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000892  0805 0000               1617mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000896  67F4                    1618mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00000898                          1619mm     
00000898  1A39 00C00007           1620mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
0000089E                          1621mm     
0000089E  BA3C 001B               1622mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008A2  6700 F860               1623mm     BEQ START
000008A6                          1624mm 
000008A6  13C5 00E00001           1625mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008AC                          1626mm 
000008AC                          1627mm     ENDM
000008AC                          1628m         ;PRINT_CHAR D5,D6
000008AC                          1629mm         HEX2BIN D5,D5,A4
000008AC  49FA 1758               1630mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008B0  0405 0030               1631mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B4  CABC 000000FF           1632mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008BA  1A34 5000               1633mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008BE                          1634mm     ENDM
000008BE  8805                    1635m         OR.B D5,D4
000008C0  5307                    1636m         SUB.B #1,D7
000008C2                          1637m     ENDW
000008C2  60BE                    1638ms     BRA _1000000E
000008C4                          1639ms _1000000F
000008C4                          1640m 
000008C4  7A00                    1641m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008C6  1A04                    1642m     MOVE.B D4,D5
000008C8  D484                    1643m     ADD.L D4,D2
000008CA                          1644m 
000008CA                          1645m     ENDM
000008CA                          1646m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000008CA  1E3C 0002               1647m     MOVE.B #2,D7
000008CE                          1648m     WHILE.B D7 <GT> 0 DO
000008CE                          1649ms _10000010
000008CE  BE38 0000               1650ms     CMP.B   0,D7
000008D2  6F00 003C               1651ms     BLE _10000011
000008D6  E98C                    1652m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008D8                          1653mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008D8                          1654mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D8                          1655mm 
000008D8  1A39 00C00003           1656mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DE  0805 0000               1657mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E2  67F4                    1658mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
000008E4                          1659mm     
000008E4  1A39 00C00007           1660mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000008EA                          1661mm     
000008EA  BA3C 001B               1662mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008EE  6700 F814               1663mm     BEQ START
000008F2                          1664mm 
000008F2  13C5 00E00001           1665mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008F8                          1666mm 
000008F8                          1667mm     ENDM
000008F8                          1668m         ;PRINT_CHAR D5,D6
000008F8                          1669mm         HEX2BIN D5,D5,A4
000008F8  49FA 170C               1670mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008FC  0405 0030               1671mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000900  CABC 000000FF           1672mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000906  1A34 5000               1673mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000090A                          1674mm     ENDM
0000090A  8805                    1675m         OR.B D5,D4
0000090C  5307                    1676m         SUB.B #1,D7
0000090E                          1677m     ENDW
0000090E  60BE                    1678ms     BRA _10000010
00000910                          1679ms _10000011
00000910                          1680m 
00000910  7A00                    1681m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000912  1A04                    1682m     MOVE.B D4,D5
00000914  D484                    1683m     ADD.L D4,D2
00000916                          1684m 
00000916                          1685m     ENDM
00000916                          1686  
00000916  2044                    1687                  MOVE.L D4,A0                        ; start address -> A0
00000918  D1C9                    1688                  ADD.L A1,A0                         ; add in the offset
0000091A                          1689  
0000091A  72FF                    1690                  MOVE.L #$FFFFFFFF,D1                ; done
0000091C                          1691              ELSE
0000091C  6000 0078               1692s     BRA _0000000A
00000920                          1693s _00000009
00000920                          1694m                 PRINT_CRLF D5,A4
00000920  49FA 170F               1695m     LEA CRLF(PC),A4
00000924                          1696mm     PRINT_STR A4,D5
00000924                          1697mm LOOP_82
00000924  0C14 0000               1698mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000928  6700 0016               1699mm     BEQ EXIT_82
0000092C                          1700mmm     PRINT_CHAR (A4)+,D5
0000092C                          1701mmm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092C                 TRUE     1702mmm     IFEQ DEBUG
0000092C  1A39 00C00003           1703mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000932  0805 0002               1704mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000936  67F4                    1705mmm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000938  13DC 00C00007           1706mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000093E                          1707mmm     ENDC
0000093E                          1708mmm 
0000093E                 FALSE    1709mmm     IFNE DEBUG
0000093E                          1710mmm     ENDC
0000093E                          1711mmm 
0000093E                          1712mmm     ENDM
0000093E  60E4                    1713mm     BRA LOOP_82
00000940                          1714mm EXIT_82
00000940                          1715mm     ENDM
00000940                          1716m     ENDM
00000940                          1717  
00000940  49FA 167B               1718                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000944                          1719m                 PRINT_STR A4,D5
00000944                          1720m LOOP_84
00000944  0C14 0000               1721m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000948  6700 0016               1722m     BEQ EXIT_84
0000094C                          1723mm     PRINT_CHAR (A4)+,D5
0000094C                          1724mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094C                 TRUE     1725mm     IFEQ DEBUG
0000094C  1A39 00C00003           1726mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000952  0805 0002               1727mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000956  67F4                    1728mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000958  13DC 00C00007           1729mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000095E                          1730mm     ENDC
0000095E                          1731mm 
0000095E                 FALSE    1732mm     IFNE DEBUG
0000095E                          1733mm     ENDC
0000095E                          1734mm 
0000095E                          1735mm     ENDM
0000095E  60E4                    1736m     BRA LOOP_84
00000960                          1737m EXIT_84
00000960                          1738m     ENDM
00000960                          1739m                 PRINT_CHAR D1,D5
00000960                          1740m WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000960                 TRUE     1741m     IFEQ DEBUG
00000960  1A39 00C00003           1742m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000966  0805 0002               1743m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000096A  67F4                    1744m         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
0000096C  13C1 00C00007           1745m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000972                          1746m     ENDC
00000972                          1747m 
00000972                 FALSE    1748m     IFNE DEBUG
00000972                          1749m     ENDC
00000972                          1750m 
00000972                          1751m     ENDM
00000972                          1752m                 PRINT_CRLF D5,A4
00000972  49FA 16BD               1753m     LEA CRLF(PC),A4
00000976                          1754mm     PRINT_STR A4,D5
00000976                          1755mm LOOP_88
00000976  0C14 0000               1756mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000097A  6700 0016               1757mm     BEQ EXIT_88
0000097E                          1758mmm     PRINT_CHAR (A4)+,D5
0000097E                          1759mmm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000097E                 TRUE     1760mmm     IFEQ DEBUG
0000097E  1A39 00C00003           1761mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000984  0805 0002               1762mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000988  67F4                    1763mmm         BEQ WAIT_FOR_READY_89                       ; NO SPACE, CHECK AGAIN
0000098A  13DC 00C00007           1764mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000990                          1765mmm     ENDC
00000990                          1766mmm 
00000990                 FALSE    1767mmm     IFNE DEBUG
00000990                          1768mmm     ENDC
00000990                          1769mmm 
00000990                          1770mmm     ENDM
00000990  60E4                    1771mm     BRA LOOP_88
00000992                          1772mm EXIT_88
00000992                          1773mm     ENDM
00000992                          1774m     ENDM
00000992                          1775  
00000992  6000 FC74               1776                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000996                          1777              ENDI
00000996                          1778s _0000000A
00000996                          1779          ENDI
00000996                          1780s _00000008
00000996                          1781      ENDI
00000996                          1782s _00000004
00000996                          1783  
00000996                          1784m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000996  1E3C 0002               1785m     MOVE.B #2,D7
0000099A                          1786m     WHILE.B D7 <GT> 0 DO
0000099A                          1787ms _10000012
0000099A  BE38 0000               1788ms     CMP.B   0,D7
0000099E  6F00 003C               1789ms     BLE _10000013
000009A2  E98C                    1790m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009A4                          1791mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009A4                          1792mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A4                          1793mm 
000009A4  1A39 00C00003           1794mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000009AA  0805 0000               1795mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009AE  67F4                    1796mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
000009B0                          1797mm     
000009B0  1A39 00C00007           1798mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000009B6                          1799mm     
000009B6  BA3C 001B               1800mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009BA  6700 F748               1801mm     BEQ START
000009BE                          1802mm 
000009BE  13C5 00E00001           1803mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009C4                          1804mm 
000009C4                          1805mm     ENDM
000009C4                          1806m         ;PRINT_CHAR D5,D6
000009C4                          1807mm         HEX2BIN D5,D5,A4
000009C4  49FA 1640               1808mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009C8  0405 0030               1809mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009CC  CABC 000000FF           1810mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009D2  1A34 5000               1811mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009D6                          1812mm     ENDM
000009D6  8805                    1813m         OR.B D5,D4
000009D8  5307                    1814m         SUB.B #1,D7
000009DA                          1815m     ENDW
000009DA  60BE                    1816ms     BRA _10000012
000009DC                          1817ms _10000013
000009DC                          1818m 
000009DC  7A00                    1819m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009DE  1A04                    1820m     MOVE.B D4,D5
000009E0  D484                    1821m     ADD.L D4,D2
000009E2                          1822m 
000009E2                          1823m     ENDM
000009E2                          1824  
000009E2                          1825      IF.B D2 <NE> #$FF THEN.L
000009E2  B43C 00FF               1826s     CMP.B   #$FF,D2
000009E6  6700 00B0               1827s     BEQ.L   _0000000B
000009EA                          1828m         PRINT_CRLF D5,A4
000009EA  49FA 1645               1829m     LEA CRLF(PC),A4
000009EE                          1830mm     PRINT_STR A4,D5
000009EE                          1831mm LOOP_94
000009EE  0C14 0000               1832mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009F2  6700 0016               1833mm     BEQ EXIT_94
000009F6                          1834mmm     PRINT_CHAR (A4)+,D5
000009F6                          1835mmm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F6                 TRUE     1836mmm     IFEQ DEBUG
000009F6  1A39 00C00003           1837mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009FC  0805 0002               1838mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A00  67F4                    1839mmm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000A02  13DC 00C00007           1840mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A08                          1841mmm     ENDC
00000A08                          1842mmm 
00000A08                 FALSE    1843mmm     IFNE DEBUG
00000A08                          1844mmm     ENDC
00000A08                          1845mmm 
00000A08                          1846mmm     ENDM
00000A08  60E4                    1847mm     BRA LOOP_94
00000A0A                          1848mm EXIT_94
00000A0A                          1849mm     ENDM
00000A0A                          1850m     ENDM
00000A0A  49FA 15C8               1851          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000A0E                          1852m         PRINT_STR A4,D5
00000A0E                          1853m LOOP_96
00000A0E  0C14 0000               1854m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A12  6700 0016               1855m     BEQ EXIT_96
00000A16                          1856mm     PRINT_CHAR (A4)+,D5
00000A16                          1857mm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1858mm     IFEQ DEBUG
00000A16  1A39 00C00003           1859mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A1C  0805 0002               1860mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1861mm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
00000A22  13DC 00C00007           1862mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A28                          1863mm     ENDC
00000A28                          1864mm 
00000A28                 FALSE    1865mm     IFNE DEBUG
00000A28                          1866mm     ENDC
00000A28                          1867mm 
00000A28                          1868mm     ENDM
00000A28  60E4                    1869m     BRA LOOP_96
00000A2A                          1870m EXIT_96
00000A2A                          1871m     ENDM
00000A2A                          1872m         PRINT_REG D0,D5,D3,D6,A4
00000A2A  49FA 160B               1873m     LEA OX(PC),A4
00000A2E                          1874mm     PRINT_STR A4,D5
00000A2E                          1875mm LOOP_99
00000A2E  0C14 0000               1876mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A32  6700 0016               1877mm     BEQ EXIT_99
00000A36                          1878mmm     PRINT_CHAR (A4)+,D5
00000A36                          1879mmm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A36                 TRUE     1880mmm     IFEQ DEBUG
00000A36  1A39 00C00003           1881mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A3C  0805 0002               1882mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A40  67F4                    1883mmm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000A42  13DC 00C00007           1884mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A48                          1885mmm     ENDC
00000A48                          1886mmm 
00000A48                 FALSE    1887mmm     IFNE DEBUG
00000A48                          1888mmm     ENDC
00000A48                          1889mmm 
00000A48                          1890mmm     ENDM
00000A48  60E4                    1891mm     BRA LOOP_99
00000A4A                          1892mm EXIT_99
00000A4A                          1893mm     ENDM
00000A4A  7C07                    1894m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A4C                          1895m LOOP_98
00000A4C                          1896mm     BIN2HEX D0,D3,A4
00000A4C  49FA 15A8               1897mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A50  E998                    1898mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A52  1600                    1899mm     MOVE.B D0,D3
00000A54  0283 0000000F           1900mm     ANDI.L #$F,D3
00000A5A  1634 3000               1901mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000A5E                          1902mm     ENDM
00000A5E                          1903mm     PRINT_CHAR D3,D5
00000A5E                          1904mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5E                 TRUE     1905mm     IFEQ DEBUG
00000A5E  1A39 00C00003           1906mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A64  0805 0002               1907mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A68  67F4                    1908mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000A6A  13C3 00C00007           1909mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A70                          1910mm     ENDC
00000A70                          1911mm 
00000A70                 FALSE    1912mm     IFNE DEBUG
00000A70                          1913mm     ENDC
00000A70                          1914mm 
00000A70                          1915mm     ENDM
00000A70  57CE FFDA               1916m     DBEQ D6,LOOP_98
00000A74                          1917m     ENDM
00000A74                          1918m         PRINT_CRLF D5,A4
00000A74  49FA 15BB               1919m     LEA CRLF(PC),A4
00000A78                          1920mm     PRINT_STR A4,D5
00000A78                          1921mm LOOP_104
00000A78  0C14 0000               1922mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A7C  6700 0016               1923mm     BEQ EXIT_104
00000A80                          1924mmm     PRINT_CHAR (A4)+,D5
00000A80                          1925mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A80                 TRUE     1926mmm     IFEQ DEBUG
00000A80  1A39 00C00003           1927mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A86  0805 0002               1928mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A8A  67F4                    1929mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A8C  13DC 00C00007           1930mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A92                          1931mmm     ENDC
00000A92                          1932mmm 
00000A92                 FALSE    1933mmm     IFNE DEBUG
00000A92                          1934mmm     ENDC
00000A92                          1935mmm 
00000A92                          1936mmm     ENDM
00000A92  60E4                    1937mm     BRA LOOP_104
00000A94                          1938mm EXIT_104
00000A94                          1939mm     ENDM
00000A94                          1940m     ENDM
00000A94                          1941          
00000A94  6000 F8AE               1942          BRA MAIN_LOOP
00000A98                          1943      ENDI
00000A98                          1944s _0000000B
00000A98                          1945  
00000A98                          1946      IF D1 <EQ> #0 THEN
00000A98  B27C 0000               1947s     CMP.W   #0,D1
00000A9C  6600 0006               1948s     BNE _0000000C
00000AA0  6000 FB66               1949        BRA WAIT_FOR_SRECORD
00000AA4                          1950      ENDI
00000AA4                          1951s _0000000C
00000AA4                          1952  DOWNLOAD_DONE
00000AA4                          1953m     PRINT_CRLF D5,A4
00000AA4  49FA 158B               1954m     LEA CRLF(PC),A4
00000AA8                          1955mm     PRINT_STR A4,D5
00000AA8                          1956mm LOOP_107
00000AA8  0C14 0000               1957mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AAC  6700 0016               1958mm     BEQ EXIT_107
00000AB0                          1959mmm     PRINT_CHAR (A4)+,D5
00000AB0                          1960mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB0                 TRUE     1961mmm     IFEQ DEBUG
00000AB0  1A39 00C00003           1962mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB6  0805 0002               1963mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ABA  67F4                    1964mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000ABC  13DC 00C00007           1965mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AC2                          1966mmm     ENDC
00000AC2                          1967mmm 
00000AC2                 FALSE    1968mmm     IFNE DEBUG
00000AC2                          1969mmm     ENDC
00000AC2                          1970mmm 
00000AC2                          1971mmm     ENDM
00000AC2  60E4                    1972mm     BRA LOOP_107
00000AC4                          1973mm EXIT_107
00000AC4                          1974mm     ENDM
00000AC4                          1975m     ENDM
00000AC4                          1976m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000AC4  43FA 1571               1977m     LEA OX(PC),A1
00000AC8                          1978mm     PRINT_STR A1,D5
00000AC8                          1979mm LOOP_110
00000AC8  0C11 0000               1980mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000ACC  6700 0016               1981mm     BEQ EXIT_110
00000AD0                          1982mmm     PRINT_CHAR (A1)+,D5
00000AD0                          1983mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD0                 TRUE     1984mmm     IFEQ DEBUG
00000AD0  1A39 00C00003           1985mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD6  0805 0002               1986mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ADA  67F4                    1987mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000ADC  13D9 00C00007           1988mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AE2                          1989mmm     ENDC
00000AE2                          1990mmm 
00000AE2                 FALSE    1991mmm     IFNE DEBUG
00000AE2                          1992mmm     ENDC
00000AE2                          1993mmm 
00000AE2                          1994mmm     ENDM
00000AE2  60E4                    1995mm     BRA LOOP_110
00000AE4                          1996mm EXIT_110
00000AE4                          1997mm     ENDM
00000AE4  7407                    1998m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AE6                          1999m LOOP_109
00000AE6                          2000mm     BIN2HEX D0,D6,A1
00000AE6  43FA 150E               2001mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AEA  E998                    2002mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AEC  1C00                    2003mm     MOVE.B D0,D6
00000AEE  0286 0000000F           2004mm     ANDI.L #$F,D6
00000AF4  1C31 6000               2005mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000AF8                          2006mm     ENDM
00000AF8                          2007mm     PRINT_CHAR D6,D5
00000AF8                          2008mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF8                 TRUE     2009mm     IFEQ DEBUG
00000AF8  1A39 00C00003           2010mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AFE  0805 0002               2011mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B02  67F4                    2012mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000B04  13C6 00C00007           2013mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B0A                          2014mm     ENDC
00000B0A                          2015mm 
00000B0A                 FALSE    2016mm     IFNE DEBUG
00000B0A                          2017mm     ENDC
00000B0A                          2018mm 
00000B0A                          2019mm     ENDM
00000B0A  57CA FFDA               2020m     DBEQ D2,LOOP_109
00000B0E                          2021m     ENDM
00000B0E  43FA 148B               2022      LEA READ(PC),A1
00000B12                          2023m     PRINT_STR A1,D5
00000B12                          2024m LOOP_114
00000B12  0C11 0000               2025m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B16  6700 0016               2026m     BEQ EXIT_114
00000B1A                          2027mm     PRINT_CHAR (A1)+,D5
00000B1A                          2028mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1A                 TRUE     2029mm     IFEQ DEBUG
00000B1A  1A39 00C00003           2030mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B20  0805 0002               2031mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B24  67F4                    2032mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B26  13D9 00C00007           2033mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B2C                          2034mm     ENDC
00000B2C                          2035mm 
00000B2C                 FALSE    2036mm     IFNE DEBUG
00000B2C                          2037mm     ENDC
00000B2C                          2038mm 
00000B2C                          2039mm     ENDM
00000B2C  60E4                    2040m     BRA LOOP_114
00000B2E                          2041m EXIT_114
00000B2E                          2042m     ENDM
00000B2E  2E08                    2043      MOVE.L A0,D7                                    ; set address accumulator to start address
00000B30                          2044m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000B30  43FA 1505               2045m     LEA OX(PC),A1
00000B34                          2046mm     PRINT_STR A1,D5
00000B34                          2047mm LOOP_117
00000B34  0C11 0000               2048mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B38  6700 0016               2049mm     BEQ EXIT_117
00000B3C                          2050mmm     PRINT_CHAR (A1)+,D5
00000B3C                          2051mmm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3C                 TRUE     2052mmm     IFEQ DEBUG
00000B3C  1A39 00C00003           2053mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B42  0805 0002               2054mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B46  67F4                    2055mmm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000B48  13D9 00C00007           2056mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B4E                          2057mmm     ENDC
00000B4E                          2058mmm 
00000B4E                 FALSE    2059mmm     IFNE DEBUG
00000B4E                          2060mmm     ENDC
00000B4E                          2061mmm 
00000B4E                          2062mmm     ENDM
00000B4E  60E4                    2063mm     BRA LOOP_117
00000B50                          2064mm EXIT_117
00000B50                          2065mm     ENDM
00000B50  7407                    2066m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B52                          2067m LOOP_116
00000B52                          2068mm     BIN2HEX D7,D6,A1
00000B52  43FA 14A2               2069mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B56  E99F                    2070mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B58  1C07                    2071mm     MOVE.B D7,D6
00000B5A  0286 0000000F           2072mm     ANDI.L #$F,D6
00000B60  1C31 6000               2073mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B64                          2074mm     ENDM
00000B64                          2075mm     PRINT_CHAR D6,D5
00000B64                          2076mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B64                 TRUE     2077mm     IFEQ DEBUG
00000B64  1A39 00C00003           2078mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B6A  0805 0002               2079mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B6E  67F4                    2080mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000B70  13C6 00C00007           2081mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B76                          2082mm     ENDC
00000B76                          2083mm 
00000B76                 FALSE    2084mm     IFNE DEBUG
00000B76                          2085mm     ENDC
00000B76                          2086mm 
00000B76                          2087mm     ENDM
00000B76  57CA FFDA               2088m     DBEQ D2,LOOP_116
00000B7A                          2089m     ENDM
00000B7A                          2090m     PRINT_CRLF D5,A4
00000B7A  49FA 14B5               2091m     LEA CRLF(PC),A4
00000B7E                          2092mm     PRINT_STR A4,D5
00000B7E                          2093mm LOOP_122
00000B7E  0C14 0000               2094mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B82  6700 0016               2095mm     BEQ EXIT_122
00000B86                          2096mmm     PRINT_CHAR (A4)+,D5
00000B86                          2097mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B86                 TRUE     2098mmm     IFEQ DEBUG
00000B86  1A39 00C00003           2099mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B8C  0805 0002               2100mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B90  67F4                    2101mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000B92  13DC 00C00007           2102mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B98                          2103mmm     ENDC
00000B98                          2104mmm 
00000B98                 FALSE    2105mmm     IFNE DEBUG
00000B98                          2106mmm     ENDC
00000B98                          2107mmm 
00000B98                          2108mmm     ENDM
00000B98  60E4                    2109mm     BRA LOOP_122
00000B9A                          2110mm EXIT_122
00000B9A                          2111mm     ENDM
00000B9A                          2112m     ENDM
00000B9A                          2113  
00000B9A  6000 F7A8               2114      BRA MAIN_LOOP
00000B9E                          2115  
00000B9E                          2116  G
00000B9E  2047                    2117      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000BA0  7E00                    2118      MOVE.L #0,D7
00000BA2                          2119  
00000BA2  4ED0                    2120      JMP (A0)
00000BA4                          2121          
00000BA4                          2122  Z
00000BA4  207C 00200000           2123      MOVE.L #RAM,A0                                  ; address of RAM
00000BAA  D1FC 00100000           2124      ADD.L #$100000,A0
00000BB0                          2125  
00000BB0                          2126      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000BB0  7000                    2127s     MOVE.L  #0,D0
00000BB2  6000 0012               2128s     BRA _20000007
00000BB6                          2129s _20000006
00000BB6  2200                    2130          MOVE.L D0,D1                                ; progress update
00000BB8  E089                    2131          LSR.L #8,D1 
00000BBA  E089                    2132          LSR.L #8,D1
00000BBC  13C1 00E00001           2133          MOVE.B D1,DISPLAY
00000BC2                          2134          
00000BC2  2108                    2135          MOVE.L A0,-(A0)
00000BC4                          2136      ENDF
00000BC4  5880                    2137s     ADD.L   #4,D0
00000BC6                          2138s _20000007
00000BC6  B0BC 000FFFFC           2139s     CMP.L   #$FFFFC,D0
00000BCC  6FE8                    2140s     BLE _20000006
00000BCE                          2141  
00000BCE  207C 00200000           2142      MOVE.L #RAM,A0                                  ; address of RAM
00000BD4  D1FC 00100000           2143      ADD.L #$100000,A0
00000BDA                          2144  
00000BDA                          2145      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000BDA  7000                    2146s     MOVE.L  #0,D0
00000BDC  6000 00A8               2147s     BRA _20000009
00000BE0                          2148s _20000008
00000BE0  2200                    2149          MOVE.L D0,D1                                ; progress update
00000BE2  E089                    2150          LSR.L #8,D1
00000BE4  E089                    2151          LSR.L #8,D1
00000BE6  13C1 00E00001           2152          MOVE.B D1,DISPLAY
00000BEC                          2153  
00000BEC  2408                    2154          MOVE.L A0,D2
00000BEE  2220                    2155          MOVE.L -(A0),D1
00000BF0                          2156  
00000BF0                          2157          IF.L D2 <NE> D1 THEN
00000BF0  B481                    2158s     CMP.L   D1,D2
00000BF2  6700 0090               2159s     BEQ _0000000D
00000BF6  43FA 13ED               2160              LEA RAM_ERROR(PC),A1
00000BFA                          2161m             PRINT_STR A1,D1
00000BFA                          2162m LOOP_124
00000BFA  0C11 0000               2163m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BFE  6700 0016               2164m     BEQ EXIT_124
00000C02                          2165mm     PRINT_CHAR (A1)+,D1
00000C02                          2166mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C02                 TRUE     2167mm     IFEQ DEBUG
00000C02  1239 00C00003           2168mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000C08  0801 0002               2169mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000C0C  67F4                    2170mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000C0E  13D9 00C00007           2171mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C14                          2172mm     ENDC
00000C14                          2173mm 
00000C14                 FALSE    2174mm     IFNE DEBUG
00000C14                          2175mm     ENDC
00000C14                          2176mm 
00000C14                          2177mm     ENDM
00000C14  60E4                    2178m     BRA LOOP_124
00000C16                          2179m EXIT_124
00000C16                          2180m     ENDM
00000C16  2208                    2181              MOVE.L A0,D1
00000C18  5981                    2182              SUB.L #4,D1
00000C1A                          2183m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C1A  43FA 141B               2184m     LEA OX(PC),A1
00000C1E                          2185mm     PRINT_STR A1,D3
00000C1E                          2186mm LOOP_127
00000C1E  0C11 0000               2187mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C22  6700 0016               2188mm     BEQ EXIT_127
00000C26                          2189mmm     PRINT_CHAR (A1)+,D3
00000C26                          2190mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C26                 TRUE     2191mmm     IFEQ DEBUG
00000C26  1639 00C00003           2192mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C2C  0803 0002               2193mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C30  67F4                    2194mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000C32  13D9 00C00007           2195mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C38                          2196mmm     ENDC
00000C38                          2197mmm 
00000C38                 FALSE    2198mmm     IFNE DEBUG
00000C38                          2199mmm     ENDC
00000C38                          2200mmm 
00000C38                          2201mmm     ENDM
00000C38  60E4                    2202mm     BRA LOOP_127
00000C3A                          2203mm EXIT_127
00000C3A                          2204mm     ENDM
00000C3A  7C07                    2205m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C3C                          2206m LOOP_126
00000C3C                          2207mm     BIN2HEX D1,D2,A1
00000C3C  43FA 13B8               2208mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C40  E999                    2209mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C42  1401                    2210mm     MOVE.B D1,D2
00000C44  0282 0000000F           2211mm     ANDI.L #$F,D2
00000C4A  1431 2000               2212mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000C4E                          2213mm     ENDM
00000C4E                          2214mm     PRINT_CHAR D2,D3
00000C4E                          2215mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4E                 TRUE     2216mm     IFEQ DEBUG
00000C4E  1639 00C00003           2217mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C54  0803 0002               2218mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C58  67F4                    2219mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000C5A  13C2 00C00007           2220mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C60                          2221mm     ENDC
00000C60                          2222mm 
00000C60                 FALSE    2223mm     IFNE DEBUG
00000C60                          2224mm     ENDC
00000C60                          2225mm 
00000C60                          2226mm     ENDM
00000C60  57CE FFDA               2227m     DBEQ D6,LOOP_126
00000C64                          2228m     ENDM
00000C64                          2229m             PRINT_CRLF D3,A1
00000C64  43FA 13CB               2230m     LEA CRLF(PC),A1
00000C68                          2231mm     PRINT_STR A1,D3
00000C68                          2232mm LOOP_132
00000C68  0C11 0000               2233mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C6C  6700 0016               2234mm     BEQ EXIT_132
00000C70                          2235mmm     PRINT_CHAR (A1)+,D3
00000C70                          2236mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C70                 TRUE     2237mmm     IFEQ DEBUG
00000C70  1639 00C00003           2238mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C76  0803 0002               2239mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C7A  67F4                    2240mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000C7C  13D9 00C00007           2241mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C82                          2242mmm     ENDC
00000C82                          2243mmm 
00000C82                 FALSE    2244mmm     IFNE DEBUG
00000C82                          2245mmm     ENDC
00000C82                          2246mmm 
00000C82                          2247mmm     ENDM
00000C82  60E4                    2248mm     BRA LOOP_132
00000C84                          2249mm EXIT_132
00000C84                          2250mm     ENDM
00000C84                          2251m     ENDM
00000C84                          2252          ENDI 
00000C84                          2253s _0000000D
00000C84                          2254      ENDF
00000C84  5880                    2255s     ADD.L   #4,D0
00000C86                          2256s _20000009
00000C86  B0BC 000FFFFC           2257s     CMP.L   #$FFFFC,D0
00000C8C  6F00 FF52               2258s     BLE _20000008
00000C90                          2259  
00000C90  6000 F6B2               2260      BRA MAIN_LOOP
00000C94                          2261  
00000C94                          2262  L
00000C94  7000                    2263      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C96  7200                    2264      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C98                          2265  
00000C98                          2266      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C98  343C 0000               2267s     MOVE.W  #0,D2
00000C9C  6000 0046               2268s     BRA _2000000B
00000CA0                          2269s _2000000A
00000CA0  E989                    2270          LSL.L #4,D1                                 ; make what we have so far more significant
00000CA2                          2271m         WAIT_CHAR D3,D4                             ; next character -> D2
00000CA2                          2272m WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA2                 TRUE     2273m     IFEQ DEBUG
00000CA2  1839 00C00003           2274m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CA8  0804 0000               2275m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000CAC  67F4                    2276m         BEQ WAIT_FOR_READY_134                      ; NOTHING, CHECK AGAIN
00000CAE                          2277m     ENDC
00000CAE                          2278m 
00000CAE                          2279mm     READ_CHAR D3
00000CAE                 TRUE     2280mm     IFEQ DEBUG
00000CAE  1639 00C00007           2281mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000CB4                          2282mm     ENDC
00000CB4                 FALSE    2283mm     IFNE DEBUG
00000CB4                          2284mm     ENDC
00000CB4                          2285mm 
00000CB4  B63C 001B               2286mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000CB8  6700 F44A               2287mm     BEQ START
00000CBC                          2288mm     ENDM
00000CBC                          2289m 
00000CBC                 TRUE     2290m     IFEQ DEBUG
00000CBC                          2291mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000CBC                          2292mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CBC                 TRUE     2293mm     IFEQ DEBUG
00000CBC  1839 00C00003           2294mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CC2  0804 0002               2295mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000CC6  67F4                    2296mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CC8  13C3 00C00007           2297mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CCE                          2298mm     ENDC
00000CCE                          2299mm 
00000CCE                 FALSE    2300mm     IFNE DEBUG
00000CCE                          2301mm     ENDC
00000CCE                          2302mm 
00000CCE                          2303mm     ENDM
00000CCE                          2304m     ENDC
00000CCE                          2305m     ENDM
00000CCE                          2306m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000CCE  41FA 1336               2307m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000CD2  0403 0030               2308m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CD6  C6BC 000000FF           2309m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000CDC  1630 3000               2310m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CE0                          2311m     ENDM
00000CE0  8203                    2312          OR.B D3,D1
00000CE2                          2313      ENDF
00000CE2  5242                    2314s     ADD.W   #1,D2
00000CE4                          2315s _2000000B
00000CE4  B47C 0007               2316s     CMP.W   #7,D2
00000CE8  6FB6                    2317s     BLE _2000000A
00000CEA                          2318  
00000CEA  3001                    2319      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000CEC  0480 00000104           2320      SUB.L #START,D0                                 ; remove the vector table from the length
00000CF2  E089                    2321      LSR.L #8,D1                                     ; extract the MSword for the address
00000CF4  E089                    2322      LSR.L #8,D1
00000CF6                          2323  
00000CF6                          2324m     PRINT_CRLF D2,A1
00000CF6  43FA 1339               2325m     LEA CRLF(PC),A1
00000CFA                          2326mm     PRINT_STR A1,D2
00000CFA                          2327mm LOOP_139
00000CFA  0C11 0000               2328mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CFE  6700 0016               2329mm     BEQ EXIT_139
00000D02                          2330mmm     PRINT_CHAR (A1)+,D2
00000D02                          2331mmm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D02                 TRUE     2332mmm     IFEQ DEBUG
00000D02  1439 00C00003           2333mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D08  0802 0002               2334mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D0C  67F4                    2335mmm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000D0E  13D9 00C00007           2336mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D14                          2337mmm     ENDC
00000D14                          2338mmm 
00000D14                 FALSE    2339mmm     IFNE DEBUG
00000D14                          2340mmm     ENDC
00000D14                          2341mmm 
00000D14                          2342mmm     ENDM
00000D14  60E4                    2343mm     BRA LOOP_139
00000D16                          2344mm EXIT_139
00000D16                          2345mm     ENDM
00000D16                          2346m     ENDM
00000D16                          2347  
00000D16  2041                    2348      MOVE.L D1,A0                                    ; target address
00000D18  2641                    2349      MOVE.L D1,A3                                    ; keep a copy for later
00000D1A                          2350  
00000D1A  2247                    2351      MOVE.L D7,A1                                    ; address accumulator -> address register
00000D1C  D3FC 00000104           2352      ADD.L #START,A1                                 ; skip the vectors
00000D22  2847                    2353      MOVE.L D7,A4                                    ; keep a clean copy for later
00000D24  7E00                    2354      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000D26                          2355  
00000D26                          2356m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000D26  31FC AAAA 2AAA          2357m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000D2C  4E71                    2358m     NOP
00000D2E  31FC 5555 1554          2359m     MOVE.W #$5555,$1554
00000D34  4E71                    2360m     NOP
00000D36  31FC 8080 2AAA          2361m     MOVE.W #$8080,$2AAA
00000D3C  4E71                    2362m     NOP
00000D3E  31FC AAAA 2AAA          2363m     MOVE.W #$AAAA,$2AAA
00000D44  4E71                    2364m     NOP
00000D46  31FC 5555 1554          2365m     MOVE.W #$5555,$1554
00000D4C  4E71                    2366m     NOP
00000D4E  31FC 2020 2AAA          2367m     MOVE.W #$2020,$2AAA
00000D54                          2368m     ENDM
00000D54                          2369                      
00000D54                          2370      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000D54  3E3C 0000               2371s     MOVE.W  #$0,D7
00000D58  6000 0006               2372s     BRA _2000000D
00000D5C                          2373s _2000000C
00000D5C  4E71                    2374          NOP
00000D5E                          2375      ENDF
00000D5E  5247                    2376s     ADD.W   #1,D7
00000D60                          2377s _2000000D
00000D60  BE7C FFFF               2378s     CMP.W   #$FFFFFFFF,D7
00000D64  6FF6                    2379s     BLE _2000000C
00000D66                          2380                  
00000D66  45FA 12B5               2381      LEA LOADING(PC),A2
00000D6A                          2382m     PRINT_STR A2,D2
00000D6A                          2383m LOOP_142
00000D6A  0C12 0000               2384m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D6E  6700 0016               2385m     BEQ EXIT_142
00000D72                          2386mm     PRINT_CHAR (A2)+,D2
00000D72                          2387mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     2388mm     IFEQ DEBUG
00000D72  1439 00C00003           2389mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D78  0802 0002               2390mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    2391mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000D7E  13DA 00C00007           2392mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D84                          2393mm     ENDC
00000D84                          2394mm 
00000D84                 FALSE    2395mm     IFNE DEBUG
00000D84                          2396mm     ENDC
00000D84                          2397mm 
00000D84                          2398mm     ENDM
00000D84  60E4                    2399m     BRA LOOP_142
00000D86                          2400m EXIT_142
00000D86                          2401m     ENDM
00000D86  45FA 1295               2402      LEA LOADING(PC),A2
00000D8A                          2403m     PRINT_STR A2,D2
00000D8A                          2404m LOOP_144
00000D8A  0C12 0000               2405m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D8E  6700 0016               2406m     BEQ EXIT_144
00000D92                          2407mm     PRINT_CHAR (A2)+,D2
00000D92                          2408mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D92                 TRUE     2409mm     IFEQ DEBUG
00000D92  1439 00C00003           2410mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D98  0802 0002               2411mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D9C  67F4                    2412mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000D9E  13DA 00C00007           2413mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DA4                          2414mm     ENDC
00000DA4                          2415mm 
00000DA4                 FALSE    2416mm     IFNE DEBUG
00000DA4                          2417mm     ENDC
00000DA4                          2418mm 
00000DA4                          2419mm     ENDM
00000DA4  60E4                    2420m     BRA LOOP_144
00000DA6                          2421m EXIT_144
00000DA6                          2422m     ENDM
00000DA6  45FA 1275               2423      LEA LOADING(PC),A2
00000DAA                          2424m     PRINT_STR A2,D2
00000DAA                          2425m LOOP_146
00000DAA  0C12 0000               2426m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DAE  6700 0016               2427m     BEQ EXIT_146
00000DB2                          2428mm     PRINT_CHAR (A2)+,D2
00000DB2                          2429mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB2                 TRUE     2430mm     IFEQ DEBUG
00000DB2  1439 00C00003           2431mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DB8  0802 0002               2432mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DBC  67F4                    2433mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000DBE  13DA 00C00007           2434mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DC4                          2435mm     ENDC
00000DC4                          2436mm 
00000DC4                 FALSE    2437mm     IFNE DEBUG
00000DC4                          2438mm     ENDC
00000DC4                          2439mm 
00000DC4                          2440mm     ENDM
00000DC4  60E4                    2441m     BRA LOOP_146
00000DC6                          2442m EXIT_146
00000DC6                          2443m     ENDM
00000DC6  45FA 1255               2444      LEA LOADING(PC),A2
00000DCA                          2445m     PRINT_STR A2,D2
00000DCA                          2446m LOOP_148
00000DCA  0C12 0000               2447m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DCE  6700 0016               2448m     BEQ EXIT_148
00000DD2                          2449mm     PRINT_CHAR (A2)+,D2
00000DD2                          2450mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD2                 TRUE     2451mm     IFEQ DEBUG
00000DD2  1439 00C00003           2452mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DD8  0802 0002               2453mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DDC  67F4                    2454mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000DDE  13DA 00C00007           2455mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DE4                          2456mm     ENDC
00000DE4                          2457mm 
00000DE4                 FALSE    2458mm     IFNE DEBUG
00000DE4                          2459mm     ENDC
00000DE4                          2460mm 
00000DE4                          2461mm     ENDM
00000DE4  60E4                    2462m     BRA LOOP_148
00000DE6                          2463m EXIT_148
00000DE6                          2464m     ENDM
00000DE6                          2465          
00000DE6  2409                    2466      MOVE.L A1,D2
00000DE8                          2467m     PRINT_REG D2,D3,D4,D5,A2
00000DE8  45FA 124D               2468m     LEA OX(PC),A2
00000DEC                          2469mm     PRINT_STR A2,D3
00000DEC                          2470mm LOOP_151
00000DEC  0C12 0000               2471mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DF0  6700 0016               2472mm     BEQ EXIT_151
00000DF4                          2473mmm     PRINT_CHAR (A2)+,D3
00000DF4                          2474mmm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF4                 TRUE     2475mmm     IFEQ DEBUG
00000DF4  1639 00C00003           2476mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DFA  0803 0002               2477mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DFE  67F4                    2478mmm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000E00  13DA 00C00007           2479mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E06                          2480mmm     ENDC
00000E06                          2481mmm 
00000E06                 FALSE    2482mmm     IFNE DEBUG
00000E06                          2483mmm     ENDC
00000E06                          2484mmm 
00000E06                          2485mmm     ENDM
00000E06  60E4                    2486mm     BRA LOOP_151
00000E08                          2487mm EXIT_151
00000E08                          2488mm     ENDM
00000E08  7A07                    2489m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E0A                          2490m LOOP_150
00000E0A                          2491mm     BIN2HEX D2,D4,A2
00000E0A  45FA 11EA               2492mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E0E  E99A                    2493mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E10  1802                    2494mm     MOVE.B D2,D4
00000E12  0284 0000000F           2495mm     ANDI.L #$F,D4
00000E18  1832 4000               2496mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E1C                          2497mm     ENDM
00000E1C                          2498mm     PRINT_CHAR D4,D3
00000E1C                          2499mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E1C                 TRUE     2500mm     IFEQ DEBUG
00000E1C  1639 00C00003           2501mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E22  0803 0002               2502mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E26  67F4                    2503mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000E28  13C4 00C00007           2504mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E2E                          2505mm     ENDC
00000E2E                          2506mm 
00000E2E                 FALSE    2507mm     IFNE DEBUG
00000E2E                          2508mm     ENDC
00000E2E                          2509mm 
00000E2E                          2510mm     ENDM
00000E2E  57CD FFDA               2511m     DBEQ D5,LOOP_150
00000E32                          2512m     ENDM
00000E32                          2513  
00000E32  45FA 1206               2514      LEA TO(PC),A2
00000E36                          2515m     PRINT_STR A2,D3
00000E36                          2516m LOOP_155
00000E36  0C12 0000               2517m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E3A  6700 0016               2518m     BEQ EXIT_155
00000E3E                          2519mm     PRINT_CHAR (A2)+,D3
00000E3E                          2520mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3E                 TRUE     2521mm     IFEQ DEBUG
00000E3E  1639 00C00003           2522mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E44  0803 0002               2523mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E48  67F4                    2524mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000E4A  13DA 00C00007           2525mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E50                          2526mm     ENDC
00000E50                          2527mm 
00000E50                 FALSE    2528mm     IFNE DEBUG
00000E50                          2529mm     ENDC
00000E50                          2530mm 
00000E50                          2531mm     ENDM
00000E50  60E4                    2532m     BRA LOOP_155
00000E52                          2533m EXIT_155
00000E52                          2534m     ENDM
00000E52                          2535  
00000E52  2408                    2536      MOVE.L A0,D2
00000E54                          2537m     PRINT_REG D2,D3,D4,D5,A2
00000E54  45FA 11E1               2538m     LEA OX(PC),A2
00000E58                          2539mm     PRINT_STR A2,D3
00000E58                          2540mm LOOP_158
00000E58  0C12 0000               2541mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E5C  6700 0016               2542mm     BEQ EXIT_158
00000E60                          2543mmm     PRINT_CHAR (A2)+,D3
00000E60                          2544mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E60                 TRUE     2545mmm     IFEQ DEBUG
00000E60  1639 00C00003           2546mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E66  0803 0002               2547mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E6A  67F4                    2548mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000E6C  13DA 00C00007           2549mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E72                          2550mmm     ENDC
00000E72                          2551mmm 
00000E72                 FALSE    2552mmm     IFNE DEBUG
00000E72                          2553mmm     ENDC
00000E72                          2554mmm 
00000E72                          2555mmm     ENDM
00000E72  60E4                    2556mm     BRA LOOP_158
00000E74                          2557mm EXIT_158
00000E74                          2558mm     ENDM
00000E74  7A07                    2559m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E76                          2560m LOOP_157
00000E76                          2561mm     BIN2HEX D2,D4,A2
00000E76  45FA 117E               2562mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E7A  E99A                    2563mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E7C  1802                    2564mm     MOVE.B D2,D4
00000E7E  0284 0000000F           2565mm     ANDI.L #$F,D4
00000E84  1832 4000               2566mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E88                          2567mm     ENDM
00000E88                          2568mm     PRINT_CHAR D4,D3
00000E88                          2569mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E88                 TRUE     2570mm     IFEQ DEBUG
00000E88  1639 00C00003           2571mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E8E  0803 0002               2572mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E92  67F4                    2573mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E94  13C4 00C00007           2574mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E9A                          2575mm     ENDC
00000E9A                          2576mm 
00000E9A                 FALSE    2577mm     IFNE DEBUG
00000E9A                          2578mm     ENDC
00000E9A                          2579mm 
00000E9A                          2580mm     ENDM
00000E9A  57CD FFDA               2581m     DBEQ D5,LOOP_157
00000E9E                          2582m     ENDM
00000E9E                          2583  
00000E9E  45FA 119F               2584      LEA FOR(PC),A2
00000EA2                          2585m     PRINT_STR A2,D3
00000EA2                          2586m LOOP_162
00000EA2  0C12 0000               2587m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EA6  6700 0016               2588m     BEQ EXIT_162
00000EAA                          2589mm     PRINT_CHAR (A2)+,D3
00000EAA                          2590mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EAA                 TRUE     2591mm     IFEQ DEBUG
00000EAA  1639 00C00003           2592mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EB0  0803 0002               2593mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EB4  67F4                    2594mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000EB6  13DA 00C00007           2595mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EBC                          2596mm     ENDC
00000EBC                          2597mm 
00000EBC                 FALSE    2598mm     IFNE DEBUG
00000EBC                          2599mm     ENDC
00000EBC                          2600mm 
00000EBC                          2601mm     ENDM
00000EBC  60E4                    2602m     BRA LOOP_162
00000EBE                          2603m EXIT_162
00000EBE                          2604m     ENDM
00000EBE                          2605m     PRINT_REG D0,D3,D4,D5,A2
00000EBE  45FA 1177               2606m     LEA OX(PC),A2
00000EC2                          2607mm     PRINT_STR A2,D3
00000EC2                          2608mm LOOP_165
00000EC2  0C12 0000               2609mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EC6  6700 0016               2610mm     BEQ EXIT_165
00000ECA                          2611mmm     PRINT_CHAR (A2)+,D3
00000ECA                          2612mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ECA                 TRUE     2613mmm     IFEQ DEBUG
00000ECA  1639 00C00003           2614mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ED0  0803 0002               2615mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ED4  67F4                    2616mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000ED6  13DA 00C00007           2617mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EDC                          2618mmm     ENDC
00000EDC                          2619mmm 
00000EDC                 FALSE    2620mmm     IFNE DEBUG
00000EDC                          2621mmm     ENDC
00000EDC                          2622mmm 
00000EDC                          2623mmm     ENDM
00000EDC  60E4                    2624mm     BRA LOOP_165
00000EDE                          2625mm EXIT_165
00000EDE                          2626mm     ENDM
00000EDE  7A07                    2627m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EE0                          2628m LOOP_164
00000EE0                          2629mm     BIN2HEX D0,D4,A2
00000EE0  45FA 1114               2630mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EE4  E998                    2631mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EE6  1800                    2632mm     MOVE.B D0,D4
00000EE8  0284 0000000F           2633mm     ANDI.L #$F,D4
00000EEE  1832 4000               2634mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EF2                          2635mm     ENDM
00000EF2                          2636mm     PRINT_CHAR D4,D3
00000EF2                          2637mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EF2                 TRUE     2638mm     IFEQ DEBUG
00000EF2  1639 00C00003           2639mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EF8  0803 0002               2640mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EFC  67F4                    2641mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000EFE  13C4 00C00007           2642mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F04                          2643mm     ENDC
00000F04                          2644mm 
00000F04                 FALSE    2645mm     IFNE DEBUG
00000F04                          2646mm     ENDC
00000F04                          2647mm 
00000F04                          2648mm     ENDM
00000F04  57CD FFDA               2649m     DBEQ D5,LOOP_164
00000F08                          2650m     ENDM
00000F08                          2651  
00000F08                          2652m     PRINT_CRLF D3,A2
00000F08  45FA 1127               2653m     LEA CRLF(PC),A2
00000F0C                          2654mm     PRINT_STR A2,D3
00000F0C                          2655mm LOOP_170
00000F0C  0C12 0000               2656mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F10  6700 0016               2657mm     BEQ EXIT_170
00000F14                          2658mmm     PRINT_CHAR (A2)+,D3
00000F14                          2659mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F14                 TRUE     2660mmm     IFEQ DEBUG
00000F14  1639 00C00003           2661mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F1A  0803 0002               2662mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F1E  67F4                    2663mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F20  13DA 00C00007           2664mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F26                          2665mmm     ENDC
00000F26                          2666mmm 
00000F26                 FALSE    2667mmm     IFNE DEBUG
00000F26                          2668mmm     ENDC
00000F26                          2669mmm 
00000F26                          2670mmm     ENDM
00000F26  60E4                    2671mm     BRA LOOP_170
00000F28                          2672mm EXIT_170
00000F28                          2673mm     ENDM
00000F28                          2674m     ENDM
00000F28                          2675  
00000F28                          2676      WHILE D0 <GT> #0 DO
00000F28                          2677s _10000014
00000F28  B07C 0000               2678s     CMP.W   #0,D0
00000F2C  6F00 0022               2679s     BLE _10000015
00000F30  5580                    2680          SUB.L #2,D0
00000F32                          2681  
00000F32  2408                    2682          MOVE.L A0,D2
00000F34  0202 0007               2683          ANDI.B #$7,D2
00000F38  13C2 00E00001           2684          MOVE.B D2,DISPLAY
00000F3E                          2685m         PROGRAM (A1),(A0),D2
00000F3E  3091                    2686m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000F40                          2687m 
00000F40                          2688m WAIT_FOR_COMPLETE_172
00000F40  3410                    2689m         MOVE.W (A0),D2
00000F42                          2690m 
00000F42                          2691m         IF.W D2 <NE> (A1) THEN
00000F42  B451                    2692ms     CMP.W   (A1),D2
00000F44  6700 0004               2693ms     BEQ _0000000E
00000F48  60F6                    2694m             BRA WAIT_FOR_COMPLETE_172
00000F4A                          2695m         ENDI
00000F4A                          2696ms _0000000E
00000F4A                          2697m         ENDM
00000F4A                          2698                  
00000F4A  5488                    2699          ADD.L #2,A0
00000F4C  5489                    2700          ADD.L #2,A1
00000F4E                          2701      ENDW
00000F4E  60D8                    2702s     BRA _10000014
00000F50                          2703s _10000015
00000F50                          2704      
00000F50  41F8 0000               2705      LEA STACK,A0
00000F54  D1CC                    2706      ADD.L A4,A0
00000F56  2010                    2707      MOVE.L (A0),D0
00000F58                          2708      
00000F58  207C 00000000           2709      MOVE.L #0,A0
00000F5E                          2710m     PROGRAM_VECTOR D0,A0,D2
00000F5E  5488                    2711m     ADD.L #2,A0
00000F60                          2712mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000F60  3080                    2713mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F62                          2714mm 
00000F62                          2715mm WAIT_FOR_COMPLETE_174
00000F62  3410                    2716mm         MOVE.W (A0),D2
00000F64                          2717mm 
00000F64                          2718mm         IF.W D2 <NE> D0 THEN
00000F64  B440                    2719mms     CMP.W   D0,D2
00000F66  6700 0004               2720mms     BEQ _0000000F
00000F6A  60F6                    2721mm             BRA WAIT_FOR_COMPLETE_174
00000F6C                          2722mm         ENDI
00000F6C                          2723mms _0000000F
00000F6C                          2724mm         ENDM
00000F6C  E088                    2725m     LSR.L #8,D0
00000F6E  E088                    2726m     LSR.L #8,D0
00000F70  5588                    2727m     SUB.L #2,A0
00000F72                          2728mm     PROGRAM D0, (A0), D2
00000F72  3080                    2729mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F74                          2730mm 
00000F74                          2731mm WAIT_FOR_COMPLETE_175
00000F74  3410                    2732mm         MOVE.W (A0),D2
00000F76                          2733mm 
00000F76                          2734mm         IF.W D2 <NE> D0 THEN
00000F76  B440                    2735mms     CMP.W   D0,D2
00000F78  6700 0004               2736mms     BEQ _00000010
00000F7C  60F6                    2737mm             BRA WAIT_FOR_COMPLETE_175
00000F7E                          2738mm         ENDI
00000F7E                          2739mms _00000010
00000F7E                          2740mm         ENDM
00000F7E                          2741m     ENDM
00000F7E                          2742      
00000F7E                          2743      FOR A0 = #RESET TO #START-4 BY #4 DO
00000F7E  307C 0004               2744s     MOVE.W  #RESET,A0
00000F82  6000 003E               2745s     BRA _2000000F
00000F86                          2746s _2000000E
00000F86                          2747  
00000F86  2248                    2748          MOVE.L A0,A1
00000F88  D3CC                    2749          ADD.L A4,A1
00000F8A                          2750              
00000F8A  2011                    2751          MOVE.L (A1),D0  
00000F8C  D081                    2752          ADD.L D1,D0
00000F8E  0480 00000104           2753          SUB.L #START,D0
00000F94                          2754      
00000F94  2408                    2755          MOVE.L A0,D2
00000F96  0202 0007               2756          ANDI.B #$7,D2
00000F9A  13C2 00E00001           2757          MOVE.B D2,DISPLAY
00000FA0                          2758m         PROGRAM_VECTOR D0,A0,D2
00000FA0  5488                    2759m     ADD.L #2,A0
00000FA2                          2760mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000FA2  3080                    2761mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FA4                          2762mm 
00000FA4                          2763mm WAIT_FOR_COMPLETE_177
00000FA4  3410                    2764mm         MOVE.W (A0),D2
00000FA6                          2765mm 
00000FA6                          2766mm         IF.W D2 <NE> D0 THEN
00000FA6  B440                    2767mms     CMP.W   D0,D2
00000FA8  6700 0004               2768mms     BEQ _00000011
00000FAC  60F6                    2769mm             BRA WAIT_FOR_COMPLETE_177
00000FAE                          2770mm         ENDI
00000FAE                          2771mms _00000011
00000FAE                          2772mm         ENDM
00000FAE  E088                    2773m     LSR.L #8,D0
00000FB0  E088                    2774m     LSR.L #8,D0
00000FB2  5588                    2775m     SUB.L #2,A0
00000FB4                          2776mm     PROGRAM D0, (A0), D2
00000FB4  3080                    2777mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FB6                          2778mm 
00000FB6                          2779mm WAIT_FOR_COMPLETE_178
00000FB6  3410                    2780mm         MOVE.W (A0),D2
00000FB8                          2781mm 
00000FB8                          2782mm         IF.W D2 <NE> D0 THEN
00000FB8  B440                    2783mms     CMP.W   D0,D2
00000FBA  6700 0004               2784mms     BEQ _00000012
00000FBE  60F6                    2785mm             BRA WAIT_FOR_COMPLETE_178
00000FC0                          2786mm         ENDI
00000FC0                          2787mms _00000012
00000FC0                          2788mm         ENDM
00000FC0                          2789m     ENDM
00000FC0                          2790      ENDF
00000FC0  5848                    2791s     ADD.W   #4,A0
00000FC2                          2792s _2000000F
00000FC2  B0FC 0100               2793s     CMP.W   #START-4,A0
00000FC6  6FBE                    2794s     BLE _2000000E
00000FC8                          2795                                          
00000FC8                          2796m     PROTECT
00000FC8  31FC AAAA 2AAA          2797m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000FCE  31FC 5555 1554          2798m     MOVE.W #$5555,$1554
00000FD4  31FC A0A0 2AAA          2799m     MOVE.W #$A0A0,$2AAA
00000FDA                          2800m     ENDM
00000FDA                          2801  
00000FDA  6000 F368               2802      BRA MAIN_LOOP
00000FDE                          2803      
00000FDE                          2804  P
00000FDE  7000                    2805      MOVE.L #0,D0                                    ; D0 will be the data to write
00000FE0                          2806  
00000FE0                          2807      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000FE0  323C 0000               2808s     MOVE.W  #0,D1
00000FE4  6000 0046               2809s     BRA _20000011
00000FE8                          2810s _20000010
00000FE8  E988                    2811          LSL.L #4,D0                                 ; make what we have so far more significant
00000FEA                          2812m         WAIT_CHAR D2,D3                             ; next character -> D2
00000FEA                          2813m WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FEA                 TRUE     2814m     IFEQ DEBUG
00000FEA  1639 00C00003           2815m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FF0  0803 0000               2816m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000FF4  67F4                    2817m         BEQ WAIT_FOR_READY_180                      ; NOTHING, CHECK AGAIN
00000FF6                          2818m     ENDC
00000FF6                          2819m 
00000FF6                          2820mm     READ_CHAR D2
00000FF6                 TRUE     2821mm     IFEQ DEBUG
00000FF6  1439 00C00007           2822mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000FFC                          2823mm     ENDC
00000FFC                 FALSE    2824mm     IFNE DEBUG
00000FFC                          2825mm     ENDC
00000FFC                          2826mm 
00000FFC  B43C 001B               2827mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001000  6700 F102               2828mm     BEQ START
00001004                          2829mm     ENDM
00001004                          2830m 
00001004                 TRUE     2831m     IFEQ DEBUG
00001004                          2832mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001004                          2833mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001004                 TRUE     2834mm     IFEQ DEBUG
00001004  1639 00C00003           2835mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000100A  0803 0002               2836mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000100E  67F4                    2837mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00001010  13C2 00C00007           2838mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001016                          2839mm     ENDC
00001016                          2840mm 
00001016                 FALSE    2841mm     IFNE DEBUG
00001016                          2842mm     ENDC
00001016                          2843mm 
00001016                          2844mm     ENDM
00001016                          2845m     ENDC
00001016                          2846m     ENDM
00001016                          2847m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001016  41FA 0FEE               2848m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000101A  0402 0030               2849m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000101E  C4BC 000000FF           2850m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001024  1430 2000               2851m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001028                          2852m     ENDM
00001028  8002                    2853          OR.B D2,D0
0000102A                          2854      ENDF
0000102A  5241                    2855s     ADD.W   #1,D1
0000102C                          2856s _20000011
0000102C  B27C 0003               2857s     CMP.W   #3,D1
00001030  6FB6                    2858s     BLE _20000010
00001032                          2859  
00001032                          2860m     PRINT_CRLF D2,A1
00001032  43FA 0FFD               2861m     LEA CRLF(PC),A1
00001036                          2862mm     PRINT_STR A1,D2
00001036                          2863mm LOOP_185
00001036  0C11 0000               2864mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000103A  6700 0016               2865mm     BEQ EXIT_185
0000103E                          2866mmm     PRINT_CHAR (A1)+,D2
0000103E                          2867mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000103E                 TRUE     2868mmm     IFEQ DEBUG
0000103E  1439 00C00003           2869mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001044  0802 0002               2870mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001048  67F4                    2871mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
0000104A  13D9 00C00007           2872mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001050                          2873mmm     ENDC
00001050                          2874mmm 
00001050                 FALSE    2875mmm     IFNE DEBUG
00001050                          2876mmm     ENDC
00001050                          2877mmm 
00001050                          2878mmm     ENDM
00001050  60E4                    2879mm     BRA LOOP_185
00001052                          2880mm EXIT_185
00001052                          2881mm     ENDM
00001052                          2882m     ENDM
00001052                          2883  
00001052  2047                    2884      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001054  7E00                    2885      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001056                          2886  
00001056                          2887m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001056  31FC AAAA 2AAA          2888m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000105C  4E71                    2889m     NOP
0000105E  31FC 5555 1554          2890m     MOVE.W #$5555,$1554
00001064  4E71                    2891m     NOP
00001066  31FC 8080 2AAA          2892m     MOVE.W #$8080,$2AAA
0000106C  4E71                    2893m     NOP
0000106E  31FC AAAA 2AAA          2894m     MOVE.W #$AAAA,$2AAA
00001074  4E71                    2895m     NOP
00001076  31FC 5555 1554          2896m     MOVE.W #$5555,$1554
0000107C  4E71                    2897m     NOP
0000107E  31FC 2020 2AAA          2898m     MOVE.W #$2020,$2AAA
00001084                          2899m     ENDM
00001084                          2900                              
00001084                          2901      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001084  3E3C 0000               2902s     MOVE.W  #$0,D7
00001088  6000 0006               2903s     BRA _20000013
0000108C                          2904s _20000012
0000108C  4E71                    2905          NOP
0000108E                          2906      ENDF
0000108E  5247                    2907s     ADD.W   #1,D7
00001090                          2908s _20000013
00001090  BE7C FFFF               2909s     CMP.W   #$FFFFFFFF,D7
00001094  6FF6                    2910s     BLE _20000012
00001096                          2911               
00001096  45FA 0F85               2912      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000109A                          2913m     PRINT_STR A2,D2
0000109A                          2914m LOOP_188
0000109A  0C12 0000               2915m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000109E  6700 0016               2916m     BEQ EXIT_188
000010A2                          2917mm     PRINT_CHAR (A2)+,D2
000010A2                          2918mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010A2                 TRUE     2919mm     IFEQ DEBUG
000010A2  1439 00C00003           2920mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010A8  0802 0002               2921mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010AC  67F4                    2922mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
000010AE  13DA 00C00007           2923mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010B4                          2924mm     ENDC
000010B4                          2925mm 
000010B4                 FALSE    2926mm     IFNE DEBUG
000010B4                          2927mm     ENDC
000010B4                          2928mm 
000010B4                          2929mm     ENDM
000010B4  60E4                    2930m     BRA LOOP_188
000010B6                          2931m EXIT_188
000010B6                          2932m     ENDM
000010B6                          2933  
000010B6                          2934m     PRINT_REG D0,D3,D4,D5,A2
000010B6  45FA 0F7F               2935m     LEA OX(PC),A2
000010BA                          2936mm     PRINT_STR A2,D3
000010BA                          2937mm LOOP_191
000010BA  0C12 0000               2938mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010BE  6700 0016               2939mm     BEQ EXIT_191
000010C2                          2940mmm     PRINT_CHAR (A2)+,D3
000010C2                          2941mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010C2                 TRUE     2942mmm     IFEQ DEBUG
000010C2  1639 00C00003           2943mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010C8  0803 0002               2944mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010CC  67F4                    2945mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
000010CE  13DA 00C00007           2946mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010D4                          2947mmm     ENDC
000010D4                          2948mmm 
000010D4                 FALSE    2949mmm     IFNE DEBUG
000010D4                          2950mmm     ENDC
000010D4                          2951mmm 
000010D4                          2952mmm     ENDM
000010D4  60E4                    2953mm     BRA LOOP_191
000010D6                          2954mm EXIT_191
000010D6                          2955mm     ENDM
000010D6  7A07                    2956m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010D8                          2957m LOOP_190
000010D8                          2958mm     BIN2HEX D0,D4,A2
000010D8  45FA 0F1C               2959mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000010DC  E998                    2960mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010DE  1800                    2961mm     MOVE.B D0,D4
000010E0  0284 0000000F           2962mm     ANDI.L #$F,D4
000010E6  1832 4000               2963mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000010EA                          2964mm     ENDM
000010EA                          2965mm     PRINT_CHAR D4,D3
000010EA                          2966mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010EA                 TRUE     2967mm     IFEQ DEBUG
000010EA  1639 00C00003           2968mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010F0  0803 0002               2969mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010F4  67F4                    2970mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
000010F6  13C4 00C00007           2971mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010FC                          2972mm     ENDC
000010FC                          2973mm 
000010FC                 FALSE    2974mm     IFNE DEBUG
000010FC                          2975mm     ENDC
000010FC                          2976mm 
000010FC                          2977mm     ENDM
000010FC  57CD FFDA               2978m     DBEQ D5,LOOP_190
00001100                          2979m     ENDM
00001100                          2980  
00001100  45FA 0F38               2981      LEA TO(PC),A2
00001104                          2982m     PRINT_STR A2,D3
00001104                          2983m LOOP_195
00001104  0C12 0000               2984m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001108  6700 0016               2985m     BEQ EXIT_195
0000110C                          2986mm     PRINT_CHAR (A2)+,D3
0000110C                          2987mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000110C                 TRUE     2988mm     IFEQ DEBUG
0000110C  1639 00C00003           2989mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001112  0803 0002               2990mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001116  67F4                    2991mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00001118  13DA 00C00007           2992mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000111E                          2993mm     ENDC
0000111E                          2994mm 
0000111E                 FALSE    2995mm     IFNE DEBUG
0000111E                          2996mm     ENDC
0000111E                          2997mm 
0000111E                          2998mm     ENDM
0000111E  60E4                    2999m     BRA LOOP_195
00001120                          3000m EXIT_195
00001120                          3001m     ENDM
00001120                          3002  
00001120  2408                    3003      MOVE.L A0,D2
00001122                          3004m     PRINT_REG D2,D3,D4,D5,A2
00001122  45FA 0F13               3005m     LEA OX(PC),A2
00001126                          3006mm     PRINT_STR A2,D3
00001126                          3007mm LOOP_198
00001126  0C12 0000               3008mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000112A  6700 0016               3009mm     BEQ EXIT_198
0000112E                          3010mmm     PRINT_CHAR (A2)+,D3
0000112E                          3011mmm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000112E                 TRUE     3012mmm     IFEQ DEBUG
0000112E  1639 00C00003           3013mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001134  0803 0002               3014mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001138  67F4                    3015mmm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
0000113A  13DA 00C00007           3016mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001140                          3017mmm     ENDC
00001140                          3018mmm 
00001140                 FALSE    3019mmm     IFNE DEBUG
00001140                          3020mmm     ENDC
00001140                          3021mmm 
00001140                          3022mmm     ENDM
00001140  60E4                    3023mm     BRA LOOP_198
00001142                          3024mm EXIT_198
00001142                          3025mm     ENDM
00001142  7A07                    3026m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001144                          3027m LOOP_197
00001144                          3028mm     BIN2HEX D2,D4,A2
00001144  45FA 0EB0               3029mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001148  E99A                    3030mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000114A  1802                    3031mm     MOVE.B D2,D4
0000114C  0284 0000000F           3032mm     ANDI.L #$F,D4
00001152  1832 4000               3033mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001156                          3034mm     ENDM
00001156                          3035mm     PRINT_CHAR D4,D3
00001156                          3036mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001156                 TRUE     3037mm     IFEQ DEBUG
00001156  1639 00C00003           3038mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000115C  0803 0002               3039mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001160  67F4                    3040mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
00001162  13C4 00C00007           3041mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001168                          3042mm     ENDC
00001168                          3043mm 
00001168                 FALSE    3044mm     IFNE DEBUG
00001168                          3045mm     ENDC
00001168                          3046mm 
00001168                          3047mm     ENDM
00001168  57CD FFDA               3048m     DBEQ D5,LOOP_197
0000116C                          3049m     ENDM
0000116C                          3050  
0000116C                          3051m     PRINT_CRLF D3,A2
0000116C  45FA 0EC3               3052m     LEA CRLF(PC),A2
00001170                          3053mm     PRINT_STR A2,D3
00001170                          3054mm LOOP_203
00001170  0C12 0000               3055mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001174  6700 0016               3056mm     BEQ EXIT_203
00001178                          3057mmm     PRINT_CHAR (A2)+,D3
00001178                          3058mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001178                 TRUE     3059mmm     IFEQ DEBUG
00001178  1639 00C00003           3060mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000117E  0803 0002               3061mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001182  67F4                    3062mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001184  13DA 00C00007           3063mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000118A                          3064mmm     ENDC
0000118A                          3065mmm 
0000118A                 FALSE    3066mmm     IFNE DEBUG
0000118A                          3067mmm     ENDC
0000118A                          3068mmm 
0000118A                          3069mmm     ENDM
0000118A  60E4                    3070mm     BRA LOOP_203
0000118C                          3071mm EXIT_203
0000118C                          3072mm     ENDM
0000118C                          3073m     ENDM
0000118C                          3074  
0000118C                          3075m     PROGRAM D0,(A0),D2
0000118C  3080                    3076m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000118E                          3077m 
0000118E                          3078m WAIT_FOR_COMPLETE_205
0000118E  3410                    3079m         MOVE.W (A0),D2
00001190                          3080m 
00001190                          3081m         IF.W D2 <NE> D0 THEN
00001190  B440                    3082ms     CMP.W   D0,D2
00001192  6700 0004               3083ms     BEQ _00000013
00001196  60F6                    3084m             BRA WAIT_FOR_COMPLETE_205
00001198                          3085m         ENDI
00001198                          3086ms _00000013
00001198                          3087m         ENDM
00001198                          3088  
00001198                          3089m     PROTECT
00001198  31FC AAAA 2AAA          3090m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000119E  31FC 5555 1554          3091m     MOVE.W #$5555,$1554
000011A4  31FC A0A0 2AAA          3092m     MOVE.W #$A0A0,$2AAA
000011AA                          3093m     ENDM
000011AA                          3094      
000011AA  6000 F198               3095      BRA MAIN_LOOP
000011AE                          3096      
000011AE                          3097  X
000011AE  45FA 0E9A               3098      LEA STATUS_REGISTER(PC),A2
000011B2                          3099m     PRINT_STR A2,D3
000011B2                          3100m LOOP_207
000011B2  0C12 0000               3101m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011B6  6700 0016               3102m     BEQ EXIT_207
000011BA                          3103mm     PRINT_CHAR (A2)+,D3
000011BA                          3104mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011BA                 TRUE     3105mm     IFEQ DEBUG
000011BA  1639 00C00003           3106mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011C0  0803 0002               3107mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011C4  67F4                    3108mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
000011C6  13DA 00C00007           3109mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011CC                          3110mm     ENDC
000011CC                          3111mm 
000011CC                 FALSE    3112mm     IFNE DEBUG
000011CC                          3113mm     ENDC
000011CC                          3114mm 
000011CC                          3115mm     ENDM
000011CC  60E4                    3116m     BRA LOOP_207
000011CE                          3117m EXIT_207
000011CE                          3118m     ENDM
000011CE                          3119  
000011CE  40C0                    3120      MOVE SR,D0
000011D0                          3121m     PRINT_REG D0,D3,D4,D5,A2
000011D0  45FA 0E65               3122m     LEA OX(PC),A2
000011D4                          3123mm     PRINT_STR A2,D3
000011D4                          3124mm LOOP_210
000011D4  0C12 0000               3125mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D8  6700 0016               3126mm     BEQ EXIT_210
000011DC                          3127mmm     PRINT_CHAR (A2)+,D3
000011DC                          3128mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011DC                 TRUE     3129mmm     IFEQ DEBUG
000011DC  1639 00C00003           3130mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011E2  0803 0002               3131mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011E6  67F4                    3132mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000011E8  13DA 00C00007           3133mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011EE                          3134mmm     ENDC
000011EE                          3135mmm 
000011EE                 FALSE    3136mmm     IFNE DEBUG
000011EE                          3137mmm     ENDC
000011EE                          3138mmm 
000011EE                          3139mmm     ENDM
000011EE  60E4                    3140mm     BRA LOOP_210
000011F0                          3141mm EXIT_210
000011F0                          3142mm     ENDM
000011F0  7A07                    3143m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011F2                          3144m LOOP_209
000011F2                          3145mm     BIN2HEX D0,D4,A2
000011F2  45FA 0E02               3146mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011F6  E998                    3147mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011F8  1800                    3148mm     MOVE.B D0,D4
000011FA  0284 0000000F           3149mm     ANDI.L #$F,D4
00001200  1832 4000               3150mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001204                          3151mm     ENDM
00001204                          3152mm     PRINT_CHAR D4,D3
00001204                          3153mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001204                 TRUE     3154mm     IFEQ DEBUG
00001204  1639 00C00003           3155mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000120A  0803 0002               3156mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000120E  67F4                    3157mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
00001210  13C4 00C00007           3158mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001216                          3159mm     ENDC
00001216                          3160mm 
00001216                 FALSE    3161mm     IFNE DEBUG
00001216                          3162mm     ENDC
00001216                          3163mm 
00001216                          3164mm     ENDM
00001216  57CD FFDA               3165m     DBEQ D5,LOOP_209
0000121A                          3166m     ENDM
0000121A                          3167m     PRINT_CRLF D3,A2
0000121A  45FA 0E15               3168m     LEA CRLF(PC),A2
0000121E                          3169mm     PRINT_STR A2,D3
0000121E                          3170mm LOOP_215
0000121E  0C12 0000               3171mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001222  6700 0016               3172mm     BEQ EXIT_215
00001226                          3173mmm     PRINT_CHAR (A2)+,D3
00001226                          3174mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001226                 TRUE     3175mmm     IFEQ DEBUG
00001226  1639 00C00003           3176mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000122C  0803 0002               3177mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001230  67F4                    3178mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001232  13DA 00C00007           3179mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001238                          3180mmm     ENDC
00001238                          3181mmm 
00001238                 FALSE    3182mmm     IFNE DEBUG
00001238                          3183mmm     ENDC
00001238                          3184mmm 
00001238                          3185mmm     ENDM
00001238  60E4                    3186mm     BRA LOOP_215
0000123A                          3187mm EXIT_215
0000123A                          3188mm     ENDM
0000123A                          3189m     ENDM
0000123A                          3190  
0000123A  45FA 0E09               3191      LEA STACK_POINTER(PC),A2
0000123E                          3192m     PRINT_STR A2,D3
0000123E                          3193m LOOP_217
0000123E  0C12 0000               3194m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001242  6700 0016               3195m     BEQ EXIT_217
00001246                          3196mm     PRINT_CHAR (A2)+,D3
00001246                          3197mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001246                 TRUE     3198mm     IFEQ DEBUG
00001246  1639 00C00003           3199mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000124C  0803 0002               3200mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001250  67F4                    3201mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001252  13DA 00C00007           3202mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001258                          3203mm     ENDC
00001258                          3204mm 
00001258                 FALSE    3205mm     IFNE DEBUG
00001258                          3206mm     ENDC
00001258                          3207mm 
00001258                          3208mm     ENDM
00001258  60E4                    3209m     BRA LOOP_217
0000125A                          3210m EXIT_217
0000125A                          3211m     ENDM
0000125A                          3212  
0000125A  200F                    3213      MOVE.L SP,D0
0000125C                          3214m     PRINT_REG D0,D3,D4,D5,A2
0000125C  45FA 0DD9               3215m     LEA OX(PC),A2
00001260                          3216mm     PRINT_STR A2,D3
00001260                          3217mm LOOP_220
00001260  0C12 0000               3218mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001264  6700 0016               3219mm     BEQ EXIT_220
00001268                          3220mmm     PRINT_CHAR (A2)+,D3
00001268                          3221mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001268                 TRUE     3222mmm     IFEQ DEBUG
00001268  1639 00C00003           3223mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126E  0803 0002               3224mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001272  67F4                    3225mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001274  13DA 00C00007           3226mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000127A                          3227mmm     ENDC
0000127A                          3228mmm 
0000127A                 FALSE    3229mmm     IFNE DEBUG
0000127A                          3230mmm     ENDC
0000127A                          3231mmm 
0000127A                          3232mmm     ENDM
0000127A  60E4                    3233mm     BRA LOOP_220
0000127C                          3234mm EXIT_220
0000127C                          3235mm     ENDM
0000127C  7A07                    3236m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000127E                          3237m LOOP_219
0000127E                          3238mm     BIN2HEX D0,D4,A2
0000127E  45FA 0D76               3239mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001282  E998                    3240mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001284  1800                    3241mm     MOVE.B D0,D4
00001286  0284 0000000F           3242mm     ANDI.L #$F,D4
0000128C  1832 4000               3243mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001290                          3244mm     ENDM
00001290                          3245mm     PRINT_CHAR D4,D3
00001290                          3246mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001290                 TRUE     3247mm     IFEQ DEBUG
00001290  1639 00C00003           3248mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001296  0803 0002               3249mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000129A  67F4                    3250mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
0000129C  13C4 00C00007           3251mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012A2                          3252mm     ENDC
000012A2                          3253mm 
000012A2                 FALSE    3254mm     IFNE DEBUG
000012A2                          3255mm     ENDC
000012A2                          3256mm 
000012A2                          3257mm     ENDM
000012A2  57CD FFDA               3258m     DBEQ D5,LOOP_219
000012A6                          3259m     ENDM
000012A6                          3260m     PRINT_CRLF D3,A2
000012A6  45FA 0D89               3261m     LEA CRLF(PC),A2
000012AA                          3262mm     PRINT_STR A2,D3
000012AA                          3263mm LOOP_225
000012AA  0C12 0000               3264mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012AE  6700 0016               3265mm     BEQ EXIT_225
000012B2                          3266mmm     PRINT_CHAR (A2)+,D3
000012B2                          3267mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B2                 TRUE     3268mmm     IFEQ DEBUG
000012B2  1639 00C00003           3269mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B8  0803 0002               3270mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012BC  67F4                    3271mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012BE  13DA 00C00007           3272mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012C4                          3273mmm     ENDC
000012C4                          3274mmm 
000012C4                 FALSE    3275mmm     IFNE DEBUG
000012C4                          3276mmm     ENDC
000012C4                          3277mmm 
000012C4                          3278mmm     ENDM
000012C4  60E4                    3279mm     BRA LOOP_225
000012C6                          3280mm EXIT_225
000012C6                          3281mm     ENDM
000012C6                          3282m     ENDM
000012C6                          3283  
000012C6  6000 F07C               3284      BRA MAIN_LOOP
000012CA                          3285          
000012CA                          3286  EI
000012CA  13FC 0008 00C0000B      3287      MOVE.B #8,DUART_IMR
000012D2  027C F8FF               3288      AND.W #$F8FF,SR
000012D6  6000 F06C               3289      BRA MAIN_LOOP
000012DA                          3290      
000012DA                          3291  DI
000012DA  13FC 0000 00C0000B      3292      MOVE.B #0,DUART_IMR
000012E2  007C 0700               3293      OR.W #$0700,SR
000012E6  6000 F05C               3294      BRA MAIN_LOOP
000012EA                          3295          
000012EA                          3296  HASH
000012EA                          3297m     PROTECT
000012EA  31FC AAAA 2AAA          3298m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000012F0  31FC 5555 1554          3299m     MOVE.W #$5555,$1554
000012F6  31FC A0A0 2AAA          3300m     MOVE.W #$A0A0,$2AAA
000012FC                          3301m     ENDM
000012FC  6000 F046               3302      BRA MAIN_LOOP
00001300                          3303  IB
00001300  13FC 0038 00A00019      3304      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001308                          3305      
00001308                          3306m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
00001308  13FC 00FF 00A00007      3307m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001310  103C 0030               3308m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001314  0000 0006               3309m     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001318  13C0 00A00019           3310m     MOVE.B D0, MC68230_PORT_C_DATA
0000131E  0200 00EF               3311m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001322  13FC 00E0 00A00013      3312m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
0000132A  13C0 00A00019           3313m     MOVE.B D0, MC68230_PORT_C_DATA
00001330  0000 0010               3314m     ORI.B #MC68230_PORT_C_WRITE, D0
00001334  13C0 00A00019           3315m     MOVE.B D0, MC68230_PORT_C_DATA
0000133A  13FC 0038 00A00019      3316m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001342                          3317m     ENDM
00001342                          3318m     WAIT_DRIVE_READY D0, D1
00001342                          3319m LOOP_229
00001342                          3320mm     READ_IDE_STATUS D0, D1
00001342                          3321mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001342  13FC 0000 00A00007      3322mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000134A  123C 0030               3323mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000134E  0001 0007               3324mmm     ORI.B #IDE_STATUS_REGISTER, D1
00001352  13C1 00A00019           3325mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001358  0201 00DF               3326mmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000135C  13C1 00A00019           3327mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001362  1039 00A00013           3328mmm     MOVE.B MC68230_PORT_B_DATA, D0
00001368  0001 0020               3329mmm     ORI.B #MC68230_PORT_C_READ, D1
0000136C  13C1 00A00019           3330mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001372  13FC 0038 00A00019      3331mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000137A                          3332mmm     ENDM
0000137A                          3333mm     ENDM
0000137A  0800 0006               3334m     BTST #IDE_STATUS_READY, D0
0000137E  67C2                    3335m     BEQ LOOP_229
00001380                          3336m     ENDM
00001380                          3337          
00001380                          3338m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
00001380                          3339mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001380                          3340mm LOOP_233
00001380                          3341mmm     READ_IDE_STATUS D0, D1
00001380                          3342mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001380  13FC 0000 00A00007      3343mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001388  123C 0030               3344mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000138C  0001 0007               3345mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001390  13C1 00A00019           3346mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001396  0201 00DF               3347mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000139A  13C1 00A00019           3348mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000013A0  1039 00A00013           3349mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000013A6  0001 0020               3350mmmm     ORI.B #MC68230_PORT_C_READ, D1
000013AA  13C1 00A00019           3351mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000013B0  13FC 0038 00A00019      3352mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013B8                          3353mmmm     ENDM
000013B8                          3354mmm     ENDM
000013B8  0800 0007               3355mm     BTST #IDE_STATUS_BUSY, D0
000013BC  66C2                    3356mm     BNE LOOP_233
000013BE                          3357mm     ENDM
000013BE                          3358mm     SET_READ_ADDRESS #0, D0, D1, D2
000013BE                          3359mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
000013BE  13FC 00FF 00A00007      3360mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000013C6  103C 0030               3361mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000013CA  0000 0002               3362mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
000013CE  13C0 00A00019           3363mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013D4  0200 00EF               3364mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000013D8  13FC 0001 00A00013      3365mmm     MOVE.B #1, MC68230_PORT_B_DATA
000013E0  13C0 00A00019           3366mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013E6  0000 0010               3367mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000013EA  13C0 00A00019           3368mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013F0  13FC 0038 00A00019      3369mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013F8                          3370mmm     ENDM
000013F8  7200                    3371mm     MOVE.L #0,D1
000013FA                          3372mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
000013FA  13FC 00FF 00A00007      3373mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001402  103C 0030               3374mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001406  0000 0003               3375mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
0000140A  13C0 00A00019           3376mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001410  0200 00EF               3377mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001414  13C1 00A00013           3378mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000141A  13C0 00A00019           3379mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001420  0000 0010               3380mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001424  13C0 00A00019           3381mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000142A  13FC 0038 00A00019      3382mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001432                          3383mmm     ENDM
00001432  E089                    3384mm     LSR.L #8, D1
00001434                          3385mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001434  13FC 00FF 00A00007      3386mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000143C  103C 0030               3387mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001440  0000 0004               3388mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
00001444  13C0 00A00019           3389mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000144A  0200 00EF               3390mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000144E  13C1 00A00013           3391mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001454  13C0 00A00019           3392mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000145A  0000 0010               3393mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000145E  13C0 00A00019           3394mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001464  13FC 0038 00A00019      3395mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000146C                          3396mmm     ENDM
0000146C  E089                    3397mm     LSR.L #8, D1                                
0000146E                          3398mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
0000146E  13FC 00FF 00A00007      3399mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001476  103C 0030               3400mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000147A  0000 0005               3401mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
0000147E  13C0 00A00019           3402mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001484  0200 00EF               3403mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001488  13C1 00A00013           3404mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000148E  13C0 00A00019           3405mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001494  0000 0010               3406mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001498  13C0 00A00019           3407mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000149E  13FC 0038 00A00019      3408mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014A6                          3409mmm     ENDM
000014A6  E089                    3410mm     LSR.L #8, D1
000014A8                          3411mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
000014A8  13FC 0000 00A00007      3412mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014B0  103C 0030               3413mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014B4  0000 0006               3414mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000014B8  13C0 00A00019           3415mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014BE  0200 00DF               3416mmm     ANDI.B #~MC68230_PORT_C_READ, D0
000014C2  13C0 00A00019           3417mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014C8  1439 00A00013           3418mmm     MOVE.B MC68230_PORT_B_DATA, D2
000014CE  0000 0020               3419mmm     ORI.B #MC68230_PORT_C_READ, D0
000014D2  13C0 00A00019           3420mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014D8  13FC 0038 00A00019      3421mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014E0                          3422mmm     ENDM
000014E0  0201 000F               3423mm     ANDI.B #$0F,D1
000014E4  8401                    3424mm     OR.B D1,D2
000014E6                          3425mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
000014E6  13FC 00FF 00A00007      3426mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014EE  103C 0030               3427mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014F2  0000 0006               3428mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000014F6  13C0 00A00019           3429mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014FC  0200 00EF               3430mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001500  13C2 00A00013           3431mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001506  13C0 00A00019           3432mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000150C  0000 0010               3433mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001510  13C0 00A00019           3434mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001516  13FC 0038 00A00019      3435mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000151E                          3436mmm     ENDM
0000151E                          3437mm     ENDM
0000151E                          3438mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
0000151E                          3439mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
0000151E  13FC 00FF 00A00007      3440mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001526  103C 0030               3441mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000152A  0000 0007               3442mmm     ORI.B #IDE_COMMAND_REGISTER, D0
0000152E  13C0 00A00019           3443mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001534  0200 00EF               3444mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001538  13FC 0020 00A00013      3445mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001540  13C0 00A00019           3446mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001546  0000 0010               3447mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000154A  13C0 00A00019           3448mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001550  13FC 0038 00A00019      3449mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001558                          3450mmm     ENDM
00001558                          3451mm     ENDM
00001558                          3452mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001558                          3453mm LOOP_245
00001558                          3454mmm     READ_IDE_STATUS D0, D1
00001558                          3455mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001558  13FC 0000 00A00007      3456mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001560  123C 0030               3457mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001564  0001 0007               3458mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001568  13C1 00A00019           3459mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000156E  0201 00DF               3460mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001572  13C1 00A00019           3461mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001578  1039 00A00013           3462mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000157E  0001 0020               3463mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001582  13C1 00A00019           3464mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001588  13FC 0038 00A00019      3465mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001590                          3466mmmm     ENDM
00001590                          3467mmm     ENDM
00001590  0800 0007               3468mm     BTST #IDE_STATUS_BUSY, D0
00001594  66C2                    3469mm     BNE LOOP_245
00001596                          3470mm     ENDM
00001596                          3471mm     WAIT_DRIVE_DRQ D0, D1
00001596                          3472mm LOOP_248
00001596                          3473mmm     READ_IDE_STATUS D0, D1
00001596                          3474mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001596  13FC 0000 00A00007      3475mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000159E  123C 0030               3476mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000015A2  0001 0007               3477mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000015A6  13C1 00A00019           3478mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015AC  0201 00DF               3479mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000015B0  13C1 00A00019           3480mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015B6  1039 00A00013           3481mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000015BC  0001 0020               3482mmmm     ORI.B #MC68230_PORT_C_READ, D1
000015C0  13C1 00A00019           3483mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015C6  13FC 0038 00A00019      3484mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015CE                          3485mmmm     ENDM
000015CE                          3486mmm     ENDM
000015CE  0800 0003               3487mm     BTST #IDE_STATUS_DRQ, D0
000015D2  67C2                    3488mm     BEQ LOOP_248
000015D4                          3489mm     ENDM
000015D4                          3490m     ENDM
000015D4                          3491      
000015D4                          3492      FOR D1 = #0 to #7 DO
000015D4  323C 0000               3493s     MOVE.W  #0,D1
000015D8  6000 0098               3494s     BRA _20000015
000015DC                          3495s _20000014
000015DC                          3496m         READ_32 #IDE_DATA_REGISTER, D0, D6      ; num entries in boot table -> D0 (it's written 8 times to fill the block up)
000015DC                          3497mm     READ_16 #IDE_DATA_REGISTER, D0, D6
000015DC  13FC 0000 00A00007      3498mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015E4  13FC 0000 00A00005      3499mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000015EC                          3500mm     
000015EC  1C3C 0030               3501mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
000015F0  0006 0000               3502mm     ORI.B #IDE_DATA_REGISTER, D6
000015F4  13C6 00A00019           3503mm     MOVE.B D6, MC68230_PORT_C_DATA
000015FA  0206 00DF               3504mm     ANDI.B #~MC68230_PORT_C_READ, D6
000015FE  13C6 00A00019           3505mm     MOVE.B D6, MC68230_PORT_C_DATA
00001604  1039 00A00011           3506mm     MOVE.B MC68230_PORT_A_DATA, D0
0000160A  E148                    3507mm     LSL.W #8, D0
0000160C  1039 00A00013           3508mm     MOVE.B MC68230_PORT_B_DATA, D0
00001612  0006 0020               3509mm     ORI.B #MC68230_PORT_C_READ, D6
00001616  13C6 00A00019           3510mm     MOVE.B D6, MC68230_PORT_C_DATA
0000161C  13FC 0038 00A00019      3511mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001624                          3512mm     ENDM
00001624  E188                    3513m     LSL.L #8, D0
00001626  E188                    3514m     LSL.L #8, D0
00001628                          3515mm     READ_16 #IDE_DATA_REGISTER, D0, D6
00001628  13FC 0000 00A00007      3516mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001630  13FC 0000 00A00005      3517mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001638                          3518mm     
00001638  1C3C 0030               3519mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
0000163C  0006 0000               3520mm     ORI.B #IDE_DATA_REGISTER, D6
00001640  13C6 00A00019           3521mm     MOVE.B D6, MC68230_PORT_C_DATA
00001646  0206 00DF               3522mm     ANDI.B #~MC68230_PORT_C_READ, D6
0000164A  13C6 00A00019           3523mm     MOVE.B D6, MC68230_PORT_C_DATA
00001650  1039 00A00011           3524mm     MOVE.B MC68230_PORT_A_DATA, D0
00001656  E148                    3525mm     LSL.W #8, D0
00001658  1039 00A00013           3526mm     MOVE.B MC68230_PORT_B_DATA, D0
0000165E  0006 0020               3527mm     ORI.B #MC68230_PORT_C_READ, D6
00001662  13C6 00A00019           3528mm     MOVE.B D6, MC68230_PORT_C_DATA
00001668  13FC 0038 00A00019      3529mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001670                          3530mm     ENDM
00001670                          3531m     ENDM
00001670                          3532      ENDF
00001670  5241                    3533s     ADD.W   #1,D1
00001672                          3534s _20000015
00001672  B27C 0007               3535s     CMP.W   #7,D1
00001676  6F00 FF64               3536s     BLE _20000014
0000167A  7200                    3537      MOVE.L #0, D1                               ; current boot table index -> D1
0000167C                          3538                          
0000167C                          3539      IF A5 <EQ> #1 THEN                          ; if we are booting...
0000167C  BAFC 0001               3540s     CMP.W   #1,A5
00001680  6600 0018               3541s     BNE _00000014
00001684  CEBC 0000000F           3542          AND.L #$F,D7                            ; consider bottom 4 bits of address accumulator only
0000168A                          3543          IF D7 <GE> D0 THEN                      ; don't boot if off the end of the boot table
0000168A  BE40                    3544s     CMP.W   D0,D7
0000168C  6D00 0008               3545s     BLT _00000015
00001690  2A7C 00000002           3546              MOVE.L #2, A5
00001696                          3547          ENDI
00001696                          3548s _00000015
00001696                          3549  
00001696  2007                    3550          MOVE.L D7, D0                           ; then shorten the boot table to the selected entry 
00001698  5280                    3551          ADD.L #1, D0
0000169A                          3552      ENDI
0000169A                          3553s _00000014
0000169A                          3554      
0000169A  227C 00000000           3555      MOVE.L #0, A1
000016A0                          3556      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
000016A0  143C 0000               3557s     MOVE.B  #0,D2
000016A4  6000 0236               3558s     BRA _20000017
000016A8                          3559s _20000016
000016A8  1A3C 0001               3560          MOVE.B #1, D5                           ; assume empty
000016AC                          3561          FOR.B D3 = #0 TO #11 DO                 ; words read from this boot table entry -> D2
000016AC  163C 0000               3562s     MOVE.B  #0,D3
000016B0  6000 01EE               3563s     BRA _20000019
000016B4                          3564s _20000018
000016B4                          3565m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
000016B4                          3566mm     READ_16 #IDE_DATA_REGISTER, D4, D7
000016B4  13FC 0000 00A00007      3567mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016BC  13FC 0000 00A00005      3568mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000016C4                          3569mm     
000016C4  1E3C 0030               3570mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000016C8  0007 0000               3571mm     ORI.B #IDE_DATA_REGISTER, D7
000016CC  13C7 00A00019           3572mm     MOVE.B D7, MC68230_PORT_C_DATA
000016D2  0207 00DF               3573mm     ANDI.B #~MC68230_PORT_C_READ, D7
000016D6  13C7 00A00019           3574mm     MOVE.B D7, MC68230_PORT_C_DATA
000016DC  1839 00A00011           3575mm     MOVE.B MC68230_PORT_A_DATA, D4
000016E2  E14C                    3576mm     LSL.W #8, D4
000016E4  1839 00A00013           3577mm     MOVE.B MC68230_PORT_B_DATA, D4
000016EA  0007 0020               3578mm     ORI.B #MC68230_PORT_C_READ, D7
000016EE  13C7 00A00019           3579mm     MOVE.B D7, MC68230_PORT_C_DATA
000016F4  13FC 0038 00A00019      3580mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016FC                          3581mm     ENDM
000016FC  E18C                    3582m     LSL.L #8, D4
000016FE  E18C                    3583m     LSL.L #8, D4
00001700                          3584mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001700  13FC 0000 00A00007      3585mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001708  13FC 0000 00A00005      3586mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001710                          3587mm     
00001710  1E3C 0030               3588mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001714  0007 0000               3589mm     ORI.B #IDE_DATA_REGISTER, D7
00001718  13C7 00A00019           3590mm     MOVE.B D7, MC68230_PORT_C_DATA
0000171E  0207 00DF               3591mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001722  13C7 00A00019           3592mm     MOVE.B D7, MC68230_PORT_C_DATA
00001728  1839 00A00011           3593mm     MOVE.B MC68230_PORT_A_DATA, D4
0000172E  E14C                    3594mm     LSL.W #8, D4
00001730  1839 00A00013           3595mm     MOVE.B MC68230_PORT_B_DATA, D4
00001736  0007 0020               3596mm     ORI.B #MC68230_PORT_C_READ, D7
0000173A  13C7 00A00019           3597mm     MOVE.B D7, MC68230_PORT_C_DATA
00001740  13FC 0038 00A00019      3598mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001748                          3599mm     ENDM
00001748                          3600m     ENDM
00001748                          3601              IF.B D1 <LT> D0 THEN                ; still in the boot table?
00001748  B200                    3602s     CMP.B   D0,D1
0000174A  6C00 0152               3603s     BGE _00000016
0000174E                          3604                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
0000174E  B63C 0000               3605s     CMP.B   #0,D3
00001752  6600 0004               3606s     BNE _00000017
00001756  1A04                    3607                      MOVE.B D4, D5               ; empty flag -> D5
00001758                          3608                  ENDI
00001758                          3609s _00000017
00001758                          3610                  
00001758                          3611                  IF.B D5 <NE> #1 THEN            ; not empty         
00001758  BA3C 0001               3612s     CMP.B   #1,D5
0000175C  6700 013A               3613s     BEQ _00000018
00001760                          3614                      IF A5 <EQ> #0 THEN          ; not booting, so print
00001760  BAFC 0000               3615s     CMP.W   #0,A5
00001764  6600 00FE               3616s     BNE _00000019
00001768                          3617                          IF.B D3 <EQ> #0 THEN    ; first word in boot table, print the index
00001768  B63C 0000               3618s     CMP.B   #0,D3
0000176C  6600 0044               3619s     BNE _0000001A
00001770                          3620m                             PRINT_REG_4BIT D1, D6, D7, A0   
00001770  41FA 0884               3621m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001774  1E01                    3622m     MOVE.B D1,D7
00001776  0287 0000000F           3623m     ANDI.L #$F,D7
0000177C  1E30 7000               3624m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
00001780                          3625mm     PRINT_CHAR D7,D6
00001780                          3626mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001780                 TRUE     3627mm     IFEQ DEBUG
00001780  1C39 00C00003           3628mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00001786  0806 0002               3629mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000178A  67F4                    3630mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
0000178C  13C7 00C00007           3631mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001792                          3632mm     ENDC
00001792                          3633mm 
00001792                 FALSE    3634mm     IFNE DEBUG
00001792                          3635mm     ENDC
00001792                          3636mm 
00001792                          3637mm     ENDM
00001792                          3638m     ENDM
00001792  41FA 08BB               3639                              LEA INDEX_SEP(PC), A0
00001796                          3640m                             PRINT_STR A0, D7
00001796                          3641m LOOP_259
00001796  0C10 0000               3642m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000179A  6700 0016               3643m     BEQ EXIT_259
0000179E                          3644mm     PRINT_CHAR (A0)+,D7
0000179E                          3645mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000179E                 TRUE     3646mm     IFEQ DEBUG
0000179E  1E39 00C00003           3647mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017A4  0807 0002               3648mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017A8  67F4                    3649mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
000017AA  13D8 00C00007           3650mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017B0                          3651mm     ENDC
000017B0                          3652mm 
000017B0                 FALSE    3653mm     IFNE DEBUG
000017B0                          3654mm     ENDC
000017B0                          3655mm 
000017B0                          3656mm     ENDM
000017B0  60E4                    3657m     BRA LOOP_259
000017B2                          3658m EXIT_259
000017B2                          3659m     ENDM
000017B2                          3660                          ENDI
000017B2                          3661s _0000001A
000017B2                          3662  
000017B2                          3663                          IF.B D3 <GT> #1 AND.B D3 <LT> #7 THEN   ; str, print it
000017B2  B63C 0001               3664s     CMP.B   #1,D3
000017B6  6F00 002E               3665s     BLE _0000001B
000017BA  B63C 0007               3666s     CMP.B   #7,D3
000017BE  6C00 0026               3667s     BGE _0000001B
000017C2                          3668                              FOR.B D6 = #0 TO #3 DO
000017C2  1C3C 0000               3669s     MOVE.B  #0,D6
000017C6  6000 0018               3670s     BRA _2000001B
000017CA                          3671s _2000001A
000017CA  E19C                    3672                                  ROL.L #8, D4                    
000017CC                          3673m                                 PRINT_CHAR D4, D7
000017CC                          3674m WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017CC                 TRUE     3675m     IFEQ DEBUG
000017CC  1E39 00C00003           3676m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017D2  0807 0002               3677m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017D6  67F4                    3678m         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000017D8  13C4 00C00007           3679m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017DE                          3680m     ENDC
000017DE                          3681m 
000017DE                 FALSE    3682m     IFNE DEBUG
000017DE                          3683m     ENDC
000017DE                          3684m 
000017DE                          3685m     ENDM
000017DE                          3686                              ENDF
000017DE  5206                    3687s     ADD.B   #1,D6
000017E0                          3688s _2000001B
000017E0  BC3C 0003               3689s     CMP.B   #3,D6
000017E4  6FE4                    3690s     BLE _2000001A
000017E6                          3691                          ENDI
000017E6                          3692s _0000001B
000017E6                          3693                      
000017E6                          3694                          IF.B D3 <GT> #7 AND.B D3 <LT> #12 THEN
000017E6  B63C 0007               3695s     CMP.B   #7,D3
000017EA  6F00 0078               3696s     BLE _0000001C
000017EE  B63C 000C               3697s     CMP.B   #12,D3
000017F2  6C00 0070               3698s     BGE _0000001C
000017F6  2C45                    3699                              MOVE.L D5, A6       ; preserve the empty flag, we're gonna use D5
000017F8  41FA 0855               3700                              LEA INDEX_SEP(PC), A0
000017FC                          3701m                             PRINT_STR A0, D7
000017FC                          3702m LOOP_262
000017FC  0C10 0000               3703m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001800  6700 0016               3704m     BEQ EXIT_262
00001804                          3705mm     PRINT_CHAR (A0)+,D7
00001804                          3706mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001804                 TRUE     3707mm     IFEQ DEBUG
00001804  1E39 00C00003           3708mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000180A  0807 0002               3709mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000180E  67F4                    3710mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
00001810  13D8 00C00007           3711mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001816                          3712mm     ENDC
00001816                          3713mm 
00001816                 FALSE    3714mm     IFNE DEBUG
00001816                          3715mm     ENDC
00001816                          3716mm 
00001816                          3717mm     ENDM
00001816  60E4                    3718m     BRA LOOP_262
00001818                          3719m EXIT_262
00001818                          3720m     ENDM
00001818                          3721m                             PRINT_REG D4, D5, D6, D7, A0
00001818  41FA 081D               3722m     LEA OX(PC),A0
0000181C                          3723mm     PRINT_STR A0,D5
0000181C                          3724mm LOOP_265
0000181C  0C10 0000               3725mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001820  6700 0016               3726mm     BEQ EXIT_265
00001824                          3727mmm     PRINT_CHAR (A0)+,D5
00001824                          3728mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001824                 TRUE     3729mmm     IFEQ DEBUG
00001824  1A39 00C00003           3730mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000182A  0805 0002               3731mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000182E  67F4                    3732mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
00001830  13D8 00C00007           3733mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001836                          3734mmm     ENDC
00001836                          3735mmm 
00001836                 FALSE    3736mmm     IFNE DEBUG
00001836                          3737mmm     ENDC
00001836                          3738mmm 
00001836                          3739mmm     ENDM
00001836  60E4                    3740mm     BRA LOOP_265
00001838                          3741mm EXIT_265
00001838                          3742mm     ENDM
00001838  7E07                    3743m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000183A                          3744m LOOP_264
0000183A                          3745mm     BIN2HEX D4,D6,A0
0000183A  41FA 07BA               3746mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000183E  E99C                    3747mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001840  1C04                    3748mm     MOVE.B D4,D6
00001842  0286 0000000F           3749mm     ANDI.L #$F,D6
00001848  1C30 6000               3750mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
0000184C                          3751mm     ENDM
0000184C                          3752mm     PRINT_CHAR D6,D5
0000184C                          3753mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000184C                 TRUE     3754mm     IFEQ DEBUG
0000184C  1A39 00C00003           3755mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00001852  0805 0002               3756mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001856  67F4                    3757mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
00001858  13C6 00C00007           3758mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000185E                          3759mm     ENDC
0000185E                          3760mm 
0000185E                 FALSE    3761mm     IFNE DEBUG
0000185E                          3762mm     ENDC
0000185E                          3763mm 
0000185E                          3764mm     ENDM
0000185E  57CF FFDA               3765m     DBEQ D7,LOOP_264
00001862                          3766m     ENDM
00001862  2A0E                    3767                              MOVE.L A6, D5       ; restore the empty flag into D5
00001864                          3768                          ENDI
00001864                          3769s _0000001C
00001864                          3770                      ENDI
00001864                          3771s _00000019
00001864                          3772                      
00001864                          3773                      IF A5 <EQ> #1 THEN          ; save the params if we are booting
00001864  BAFC 0001               3774s     CMP.W   #1,A5
00001868  6600 002A               3775s     BNE _0000001D
0000186C                          3776                          IF.B D3 <EQ> #8 THEN                        
0000186C  B63C 0008               3777s     CMP.B   #8,D3
00001870  6600 0004               3778s     BNE _0000001E
00001874  2244                    3779                              MOVE.L D4, A1       ; length -> A1
00001876                          3780                          ENDI
00001876                          3781s _0000001E
00001876                          3782              
00001876                          3783                          IF.B D3 <EQ> #9 THEN
00001876  B63C 0009               3784s     CMP.B   #9,D3
0000187A  6600 0004               3785s     BNE _0000001F
0000187E  2444                    3786                              MOVE.L D4, A2       ; start address -> A2
00001880                          3787                          ENDI
00001880                          3788s _0000001F
00001880                          3789  
00001880                          3790                          IF.B D3 <EQ> #10 THEN
00001880  B63C 000A               3791s     CMP.B   #10,D3
00001884  6600 0004               3792s     BNE _00000020
00001888  2644                    3793                              MOVE.L D4, A3       ; go address -> A3
0000188A                          3794                          ENDI
0000188A                          3795s _00000020
0000188A                          3796  
0000188A                          3797                          IF.B D3 <EQ> #11 THEN
0000188A  B63C 000B               3798s     CMP.B   #11,D3
0000188E  6600 0004               3799s     BNE _00000021
00001892  2844                    3800                              MOVE.L D4, A4       ; start block -> A4
00001894                          3801                          ENDI                    
00001894                          3802s _00000021
00001894                          3803                      ENDI
00001894                          3804s _0000001D
00001894                          3805                  ELSE
00001894  6000 0008               3806s     BRA _00000022
00001898                          3807s _00000018
00001898  227C 00000000           3808                      MOVE.L #0, A1
0000189E                          3809                  ENDI
0000189E                          3810s _00000022
0000189E                          3811              ENDI            
0000189E                          3812s _00000016
0000189E                          3813          ENDF
0000189E  5203                    3814s     ADD.B   #1,D3
000018A0                          3815s _20000019
000018A0  B63C 000B               3816s     CMP.B   #11,D3
000018A4  6F00 FE0E               3817s     BLE _20000018
000018A8                          3818  
000018A8                          3819          IF A5 <EQ> #0 THEN                  ; not booting?          
000018A8  BAFC 0000               3820s     CMP.W   #0,A5
000018AC  6600 002A               3821s     BNE _00000023
000018B0                          3822              IF.B D5 <NE> #1 THEN            ; not booting and not empty, so print crlf
000018B0  BA3C 0001               3823s     CMP.B   #1,D5
000018B4  6700 0022               3824s     BEQ _00000024
000018B8                          3825m                 PRINT_CRLF D7, A0
000018B8  41FA 0777               3826m     LEA CRLF(PC),A0
000018BC                          3827mm     PRINT_STR A0,D7
000018BC                          3828mm LOOP_270
000018BC  0C10 0000               3829mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000018C0  6700 0016               3830mm     BEQ EXIT_270
000018C4                          3831mmm     PRINT_CHAR (A0)+,D7
000018C4                          3832mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018C4                 TRUE     3833mmm     IFEQ DEBUG
000018C4  1E39 00C00003           3834mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000018CA  0807 0002               3835mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000018CE  67F4                    3836mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
000018D0  13D8 00C00007           3837mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018D6                          3838mmm     ENDC
000018D6                          3839mmm 
000018D6                 FALSE    3840mmm     IFNE DEBUG
000018D6                          3841mmm     ENDC
000018D6                          3842mmm 
000018D6                          3843mmm     ENDM
000018D6  60E4                    3844mm     BRA LOOP_270
000018D8                          3845mm EXIT_270
000018D8                          3846mm     ENDM
000018D8                          3847m     ENDM
000018D8                          3848              ENDI
000018D8                          3849s _00000024
000018D8                          3850          ENDI
000018D8                          3851s _00000023
000018D8                          3852          
000018D8  5281                    3853          ADD.L #1,D1                         ; next boot table index
000018DA                          3854      ENDF
000018DA  5202                    3855s     ADD.B   #1,D2
000018DC                          3856s _20000017
000018DC  B43C 0009               3857s     CMP.B   #9,D2
000018E0  6F00 FDC6               3858s     BLE _20000016
000018E4                          3859                          
000018E4                          3860      IF A5 <NE> #0 THEN                      ; check for boot from empty slot
000018E4  BAFC 0000               3861s     CMP.W   #0,A5
000018E8  6700 0034               3862s     BEQ _00000025
000018EC                          3863          IF A5 <EQ> #2 OR A1 <EQ> #0  THEN 
000018EC  BAFC 0002               3864s     CMP.W   #2,A5
000018F0  6708                    3865s     BEQ.S   _00000026
000018F2  B2FC 0000               3866s     CMP.W   #0,A1
000018F6  6600 0026               3867s     BNE _00000027
000018FA                          3868s _00000026
000018FA  41FA 075F               3869              LEA NOT_FOUND(PC), A0
000018FE                          3870m             PRINT_STR A0, D7
000018FE                          3871m LOOP_272
000018FE  0C10 0000               3872m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001902  6700 0016               3873m     BEQ EXIT_272
00001906                          3874mm     PRINT_CHAR (A0)+,D7
00001906                          3875mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001906                 TRUE     3876mm     IFEQ DEBUG
00001906  1E39 00C00003           3877mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000190C  0807 0002               3878mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001910  67F4                    3879mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
00001912  13D8 00C00007           3880mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001918                          3881mm     ENDC
00001918                          3882mm 
00001918                 FALSE    3883mm     IFNE DEBUG
00001918                          3884mm     ENDC
00001918                          3885mm 
00001918                          3886mm     ENDM
00001918  60E4                    3887m     BRA LOOP_272
0000191A                          3888m EXIT_272
0000191A                          3889m     ENDM
0000191A  6000 EA28               3890              BRA MAIN_LOOP
0000191E                          3891          ENDI
0000191E                          3892s _00000027
0000191E                          3893      ENDI
0000191E                          3894s _00000025
0000191E                          3895      
0000191E                          3896      IF A5 <EQ> #1 THEN                      ; booting?
0000191E  BAFC 0001               3897s     CMP.W   #1,A5
00001922  6600 031C               3898s     BNE _00000028
00001926  41FA 072B               3899          LEA BOOT(PC), A0
0000192A                          3900m         PRINT_STR A0, D7
0000192A                          3901m LOOP_274
0000192A  0C10 0000               3902m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000192E  6700 0016               3903m     BEQ EXIT_274
00001932                          3904mm     PRINT_CHAR (A0)+,D7
00001932                          3905mm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001932                 TRUE     3906mm     IFEQ DEBUG
00001932  1E39 00C00003           3907mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001938  0807 0002               3908mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000193C  67F4                    3909mm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
0000193E  13D8 00C00007           3910mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001944                          3911mm     ENDC
00001944                          3912mm 
00001944                 FALSE    3913mm     IFNE DEBUG
00001944                          3914mm     ENDC
00001944                          3915mm 
00001944                          3916mm     ENDM
00001944  60E4                    3917m     BRA LOOP_274
00001946                          3918m EXIT_274
00001946                          3919m     ENDM
00001946                          3920      
00001946  2009                    3921          MOVE.L A1, D0                       ; length -> D0              
00001948  220C                    3922          MOVE.L A4, D1                       ; start block -> D1
0000194A                          3923          
0000194A                          3924          WHILE.L D0 <GT> #0 DO
0000194A                          3925s _10000016
0000194A  B0BC 00000000           3926s     CMP.L   #0,D0
00001950  6F00 02CC               3927s     BLE _10000017
00001954                          3928m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
00001954                          3929mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001954                          3930mm LOOP_277
00001954                          3931mmm     READ_IDE_STATUS D5, D6
00001954                          3932mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001954  13FC 0000 00A00007      3933mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000195C  1C3C 0030               3934mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001960  0006 0007               3935mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001964  13C6 00A00019           3936mmmm     MOVE.B D6, MC68230_PORT_C_DATA
0000196A  0206 00DF               3937mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
0000196E  13C6 00A00019           3938mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001974  1A39 00A00013           3939mmmm     MOVE.B MC68230_PORT_B_DATA, D5
0000197A  0006 0020               3940mmmm     ORI.B #MC68230_PORT_C_READ, D6
0000197E  13C6 00A00019           3941mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001984  13FC 0038 00A00019      3942mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000198C                          3943mmmm     ENDM
0000198C                          3944mmm     ENDM
0000198C  0805 0007               3945mm     BTST #IDE_STATUS_BUSY, D5
00001990  66C2                    3946mm     BNE LOOP_277
00001992                          3947mm     ENDM
00001992                          3948mm     SET_READ_ADDRESS D1, D5, D6, D7
00001992                          3949mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D5
00001992  13FC 00FF 00A00007      3950mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000199A  1A3C 0030               3951mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
0000199E  0005 0002               3952mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D5
000019A2  13C5 00A00019           3953mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019A8  0205 00EF               3954mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019AC  13FC 0001 00A00013      3955mmm     MOVE.B #1, MC68230_PORT_B_DATA
000019B4  13C5 00A00019           3956mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019BA  0005 0010               3957mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019BE  13C5 00A00019           3958mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019C4  13FC 0038 00A00019      3959mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019CC                          3960mmm     ENDM
000019CC  2C01                    3961mm     MOVE.L D1,D6
000019CE                          3962mmm     WRITE_8 D6, #IDE_LBA_0_7_REGISTER, D5
000019CE  13FC 00FF 00A00007      3963mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019D6  1A3C 0030               3964mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019DA  0005 0003               3965mmm     ORI.B #IDE_LBA_0_7_REGISTER, D5
000019DE  13C5 00A00019           3966mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019E4  0205 00EF               3967mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019E8  13C6 00A00013           3968mmm     MOVE.B D6, MC68230_PORT_B_DATA
000019EE  13C5 00A00019           3969mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019F4  0005 0010               3970mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019F8  13C5 00A00019           3971mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019FE  13FC 0038 00A00019      3972mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A06                          3973mmm     ENDM
00001A06  E08E                    3974mm     LSR.L #8, D6
00001A08                          3975mmm     WRITE_8 D6, #IDE_LBA_8_15_REGISTER, D5
00001A08  13FC 00FF 00A00007      3976mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A10  1A3C 0030               3977mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A14  0005 0004               3978mmm     ORI.B #IDE_LBA_8_15_REGISTER, D5
00001A18  13C5 00A00019           3979mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A1E  0205 00EF               3980mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A22  13C6 00A00013           3981mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A28  13C5 00A00019           3982mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A2E  0005 0010               3983mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A32  13C5 00A00019           3984mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A38  13FC 0038 00A00019      3985mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A40                          3986mmm     ENDM
00001A40  E08E                    3987mm     LSR.L #8, D6                                
00001A42                          3988mmm     WRITE_8 D6, #IDE_LBA_16_23_REGISTER, D5
00001A42  13FC 00FF 00A00007      3989mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A4A  1A3C 0030               3990mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A4E  0005 0005               3991mmm     ORI.B #IDE_LBA_16_23_REGISTER, D5
00001A52  13C5 00A00019           3992mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A58  0205 00EF               3993mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A5C  13C6 00A00013           3994mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A62  13C5 00A00019           3995mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A68  0005 0010               3996mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A6C  13C5 00A00019           3997mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A72  13FC 0038 00A00019      3998mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A7A                          3999mmm     ENDM
00001A7A  E08E                    4000mm     LSR.L #8, D6
00001A7C                          4001mmm     READ_8 #IDE_DRIVESEL_REGISTER, D7, D5
00001A7C  13FC 0000 00A00007      4002mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001A84  1A3C 0030               4003mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A88  0005 0006               4004mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001A8C  13C5 00A00019           4005mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A92  0205 00DF               4006mmm     ANDI.B #~MC68230_PORT_C_READ, D5
00001A96  13C5 00A00019           4007mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A9C  1E39 00A00013           4008mmm     MOVE.B MC68230_PORT_B_DATA, D7
00001AA2  0005 0020               4009mmm     ORI.B #MC68230_PORT_C_READ, D5
00001AA6  13C5 00A00019           4010mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AAC  13FC 0038 00A00019      4011mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AB4                          4012mmm     ENDM
00001AB4  0206 000F               4013mm     ANDI.B #$0F,D6
00001AB8  8E06                    4014mm     OR.B D6,D7
00001ABA                          4015mmm     WRITE_8 D7, #IDE_DRIVESEL_REGISTER, D5
00001ABA  13FC 00FF 00A00007      4016mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001AC2  1A3C 0030               4017mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AC6  0005 0006               4018mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001ACA  13C5 00A00019           4019mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AD0  0205 00EF               4020mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001AD4  13C7 00A00013           4021mmm     MOVE.B D7, MC68230_PORT_B_DATA
00001ADA  13C5 00A00019           4022mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AE0  0005 0010               4023mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001AE4  13C5 00A00019           4024mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AEA  13FC 0038 00A00019      4025mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AF2                          4026mmm     ENDM
00001AF2                          4027mm     ENDM
00001AF2                          4028mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D5
00001AF2                          4029mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D5
00001AF2  13FC 00FF 00A00007      4030mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001AFA  1A3C 0030               4031mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AFE  0005 0007               4032mmm     ORI.B #IDE_COMMAND_REGISTER, D5
00001B02  13C5 00A00019           4033mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B08  0205 00EF               4034mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001B0C  13FC 0020 00A00013      4035mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001B14  13C5 00A00019           4036mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B1A  0005 0010               4037mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001B1E  13C5 00A00019           4038mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B24  13FC 0038 00A00019      4039mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B2C                          4040mmm     ENDM
00001B2C                          4041mm     ENDM
00001B2C                          4042mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001B2C                          4043mm LOOP_289
00001B2C                          4044mmm     READ_IDE_STATUS D5, D6
00001B2C                          4045mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001B2C  13FC 0000 00A00007      4046mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B34  1C3C 0030               4047mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001B38  0006 0007               4048mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001B3C  13C6 00A00019           4049mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B42  0206 00DF               4050mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001B46  13C6 00A00019           4051mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B4C  1A39 00A00013           4052mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001B52  0006 0020               4053mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001B56  13C6 00A00019           4054mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B5C  13FC 0038 00A00019      4055mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B64                          4056mmmm     ENDM
00001B64                          4057mmm     ENDM
00001B64  0805 0007               4058mm     BTST #IDE_STATUS_BUSY, D5
00001B68  66C2                    4059mm     BNE LOOP_289
00001B6A                          4060mm     ENDM
00001B6A                          4061mm     WAIT_DRIVE_DRQ D5, D6
00001B6A                          4062mm LOOP_292
00001B6A                          4063mmm     READ_IDE_STATUS D5, D6
00001B6A                          4064mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001B6A  13FC 0000 00A00007      4065mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B72  1C3C 0030               4066mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001B76  0006 0007               4067mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001B7A  13C6 00A00019           4068mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B80  0206 00DF               4069mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001B84  13C6 00A00019           4070mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B8A  1A39 00A00013           4071mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001B90  0006 0020               4072mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001B94  13C6 00A00019           4073mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B9A  13FC 0038 00A00019      4074mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001BA2                          4075mmmm     ENDM
00001BA2                          4076mmm     ENDM
00001BA2  0805 0003               4077mm     BTST #IDE_STATUS_DRQ, D5
00001BA6  67C2                    4078mm     BEQ LOOP_292
00001BA8                          4079mm     ENDM
00001BA8                          4080m     ENDM
00001BA8                          4081m             PRINT_CHAR #'.', D7
00001BA8                          4082m WAIT_FOR_READY_295                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001BA8                 TRUE     4083m     IFEQ DEBUG
00001BA8  1E39 00C00003           4084m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001BAE  0807 0002               4085m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001BB2  67F4                    4086m         BEQ WAIT_FOR_READY_295                      ; NO SPACE, CHECK AGAIN
00001BB4  13FC 002E 00C00007      4087m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001BBC                          4088m     ENDC
00001BBC                          4089m 
00001BBC                 FALSE    4090m     IFNE DEBUG
00001BBC                          4091m     ENDC
00001BBC                          4092m 
00001BBC                          4093m     ENDM
00001BBC                          4094              
00001BBC                          4095              FOR.L D3 = #0 TO #255 DO
00001BBC  7600                    4096s     MOVE.L  #0,D3
00001BBE  6000 0050               4097s     BRA _2000001D
00001BC2                          4098s _2000001C
00001BC2                          4099m                 READ_16 #IDE_DATA_REGISTER, D4, D7
00001BC2  13FC 0000 00A00007      4100m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BCA  13FC 0000 00A00005      4101m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001BD2                          4102m     
00001BD2  1E3C 0030               4103m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001BD6  0007 0000               4104m     ORI.B #IDE_DATA_REGISTER, D7
00001BDA  13C7 00A00019           4105m     MOVE.B D7, MC68230_PORT_C_DATA
00001BE0  0207 00DF               4106m     ANDI.B #~MC68230_PORT_C_READ, D7
00001BE4  13C7 00A00019           4107m     MOVE.B D7, MC68230_PORT_C_DATA
00001BEA  1839 00A00011           4108m     MOVE.B MC68230_PORT_A_DATA, D4
00001BF0  E14C                    4109m     LSL.W #8, D4
00001BF2  1839 00A00013           4110m     MOVE.B MC68230_PORT_B_DATA, D4
00001BF8  0007 0020               4111m     ORI.B #MC68230_PORT_C_READ, D7
00001BFC  13C7 00A00019           4112m     MOVE.B D7, MC68230_PORT_C_DATA
00001C02  13FC 0038 00A00019      4113m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001C0A                          4114m     ENDM
00001C0A  34C4                    4115                  MOVE.W D4,(A2)+
00001C0C  5580                    4116                  SUB.L #2, D0
00001C0E                          4117              ENDF
00001C0E  5283                    4118s     ADD.L   #1,D3
00001C10                          4119s _2000001D
00001C10  B6BC 000000FF           4120s     CMP.L   #255,D3
00001C16  6FAA                    4121s     BLE _2000001C
00001C18                          4122          
00001C18  5281                    4123              ADD.L #1, D1                    ; next block
00001C1A                          4124          ENDW
00001C1A  6000 FD2E               4125s     BRA _10000016
00001C1E                          4126s _10000017
00001C1E                          4127  
00001C1E                          4128m         PRINT_CRLF D3, A6   
00001C1E  4DFA 0411               4129m     LEA CRLF(PC),A6
00001C22                          4130mm     PRINT_STR A6,D3
00001C22                          4131mm LOOP_298
00001C22  0C16 0000               4132mm     CMP.B #NULL,(A6)                                ; 0 -> DONE
00001C26  6700 0016               4133mm     BEQ EXIT_298
00001C2A                          4134mmm     PRINT_CHAR (A6)+,D3
00001C2A                          4135mmm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C2A                 TRUE     4136mmm     IFEQ DEBUG
00001C2A  1639 00C00003           4137mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001C30  0803 0002               4138mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001C34  67F4                    4139mmm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001C36  13DE 00C00007           4140mmm         MOVE.B (A6)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C3C                          4141mmm     ENDC
00001C3C                          4142mmm 
00001C3C                 FALSE    4143mmm     IFNE DEBUG
00001C3C                          4144mmm     ENDC
00001C3C                          4145mmm 
00001C3C                          4146mmm     ENDM
00001C3C  60E4                    4147mm     BRA LOOP_298
00001C3E                          4148mm EXIT_298
00001C3E                          4149mm     ENDM
00001C3E                          4150m     ENDM
00001C3E                          4151      
00001C3E  2E0B                    4152          MOVE.L A3, D7                           ; set go address
00001C40                          4153      ENDI
00001C40                          4154s _00000028
00001C40                          4155  
00001C40  6000 E702               4156      BRA MAIN_LOOP
00001C44                          4157  
00001C44                          4158  HEX_DIGIT
00001C44  E98F                    4159      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001C46                          4160m     HEX2BIN D2,D2,A0
00001C46  41FA 03BE               4161m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001C4A  0402 0030               4162m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001C4E  C4BC 000000FF           4163m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001C54  1430 2000               4164m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001C58                          4165m     ENDM
00001C58  8E02                    4166      OR.B D2,D7  
00001C5A  6000 E708               4167      BRA GET_INPUT
00001C5E                          4168  
00001C5E                          4169  ; exceptions    
00001C5E                          4170  BUS_ERROR_HANDLER
00001C5E                          4171  
00001C5E  41FA 040E               4172      LEA BUS_ERROR(PC),A0
00001C62                          4173m     PRINT_STR A0,D1
00001C62                          4174m LOOP_301
00001C62  0C10 0000               4175m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C66  6700 0016               4176m     BEQ EXIT_301
00001C6A                          4177mm     PRINT_CHAR (A0)+,D1
00001C6A                          4178mm WAIT_FOR_READY_302                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C6A                 TRUE     4179mm     IFEQ DEBUG
00001C6A  1239 00C00003           4180mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C70  0801 0002               4181mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001C74  67F4                    4182mm         BEQ WAIT_FOR_READY_302                      ; NO SPACE, CHECK AGAIN
00001C76  13D8 00C00007           4183mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C7C                          4184mm     ENDC
00001C7C                          4185mm 
00001C7C                 FALSE    4186mm     IFNE DEBUG
00001C7C                          4187mm     ENDC
00001C7C                          4188mm 
00001C7C                          4189mm     ENDM
00001C7C  60E4                    4190m     BRA LOOP_301
00001C7E                          4191m EXIT_301
00001C7E                          4192m     ENDM
00001C7E                          4193  
00001C7E  7000                    4194      MOVE.L #0,D0
00001C80  3017                    4195      MOVE.W (SP),D0
00001C82                          4196  
00001C82  0800 0004               4197      BTST #4,D0
00001C86  6700 0026               4198      BEQ WRITE
00001C8A                          4199      
00001C8A  41FA 03F7               4200      LEA READING(PC),A0
00001C8E                          4201m     PRINT_STR A0,D1
00001C8E                          4202m LOOP_303
00001C8E  0C10 0000               4203m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C92  6700 0016               4204m     BEQ EXIT_303
00001C96                          4205mm     PRINT_CHAR (A0)+,D1
00001C96                          4206mm WAIT_FOR_READY_304                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C96                 TRUE     4207mm     IFEQ DEBUG
00001C96  1239 00C00003           4208mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C9C  0801 0002               4209mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CA0  67F4                    4210mm         BEQ WAIT_FOR_READY_304                      ; NO SPACE, CHECK AGAIN
00001CA2  13D8 00C00007           4211mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CA8                          4212mm     ENDC
00001CA8                          4213mm 
00001CA8                 FALSE    4214mm     IFNE DEBUG
00001CA8                          4215mm     ENDC
00001CA8                          4216mm 
00001CA8                          4217mm     ENDM
00001CA8  60E4                    4218m     BRA LOOP_303
00001CAA                          4219m EXIT_303
00001CAA                          4220m     ENDM
00001CAA                          4221  
00001CAA  6000 0022               4222      BRA CONTINUE    
00001CAE                          4223  WRITE
00001CAE  41FA 03DC               4224      LEA WRITING(PC),A0
00001CB2                          4225m     PRINT_STR A0,D1
00001CB2                          4226m LOOP_305
00001CB2  0C10 0000               4227m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CB6  6700 0016               4228m     BEQ EXIT_305
00001CBA                          4229mm     PRINT_CHAR (A0)+,D1
00001CBA                          4230mm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CBA                 TRUE     4231mm     IFEQ DEBUG
00001CBA  1239 00C00003           4232mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CC0  0801 0002               4233mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CC4  67F4                    4234mm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
00001CC6  13D8 00C00007           4235mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CCC                          4236mm     ENDC
00001CCC                          4237mm 
00001CCC                 FALSE    4238mm     IFNE DEBUG
00001CCC                          4239mm     ENDC
00001CCC                          4240mm 
00001CCC                          4241mm     ENDM
00001CCC  60E4                    4242m     BRA LOOP_305
00001CCE                          4243m EXIT_305
00001CCE                          4244m     ENDM
00001CCE                          4245  
00001CCE                          4246  CONTINUE
00001CCE  222F 0002               4247      MOVE.L 2(SP),D1
00001CD2                          4248m     PRINT_REG D1,D2,D3,D4,A0
00001CD2  41FA 0363               4249m     LEA OX(PC),A0
00001CD6                          4250mm     PRINT_STR A0,D2
00001CD6                          4251mm LOOP_308
00001CD6  0C10 0000               4252mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CDA  6700 0016               4253mm     BEQ EXIT_308
00001CDE                          4254mmm     PRINT_CHAR (A0)+,D2
00001CDE                          4255mmm WAIT_FOR_READY_309                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CDE                 TRUE     4256mmm     IFEQ DEBUG
00001CDE  1439 00C00003           4257mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001CE4  0802 0002               4258mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001CE8  67F4                    4259mmm         BEQ WAIT_FOR_READY_309                      ; NO SPACE, CHECK AGAIN
00001CEA  13D8 00C00007           4260mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CF0                          4261mmm     ENDC
00001CF0                          4262mmm 
00001CF0                 FALSE    4263mmm     IFNE DEBUG
00001CF0                          4264mmm     ENDC
00001CF0                          4265mmm 
00001CF0                          4266mmm     ENDM
00001CF0  60E4                    4267mm     BRA LOOP_308
00001CF2                          4268mm EXIT_308
00001CF2                          4269mm     ENDM
00001CF2  7807                    4270m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001CF4                          4271m LOOP_307
00001CF4                          4272mm     BIN2HEX D1,D3,A0
00001CF4  41FA 0300               4273mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001CF8  E999                    4274mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001CFA  1601                    4275mm     MOVE.B D1,D3
00001CFC  0283 0000000F           4276mm     ANDI.L #$F,D3
00001D02  1630 3000               4277mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D06                          4278mm     ENDM
00001D06                          4279mm     PRINT_CHAR D3,D2
00001D06                          4280mm WAIT_FOR_READY_311                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D06                 TRUE     4281mm     IFEQ DEBUG
00001D06  1439 00C00003           4282mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D0C  0802 0002               4283mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D10  67F4                    4284mm         BEQ WAIT_FOR_READY_311                      ; NO SPACE, CHECK AGAIN
00001D12  13C3 00C00007           4285mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D18                          4286mm     ENDC
00001D18                          4287mm 
00001D18                 FALSE    4288mm     IFNE DEBUG
00001D18                          4289mm     ENDC
00001D18                          4290mm 
00001D18                          4291mm     ENDM
00001D18  57CC FFDA               4292m     DBEQ D4,LOOP_307
00001D1C                          4293m     ENDM
00001D1C                          4294  
00001D1C  41FA 0377               4295      LEA FROM(PC),A0
00001D20                          4296m     PRINT_STR A0,D0
00001D20                          4297m LOOP_312
00001D20  0C10 0000               4298m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D24  6700 0016               4299m     BEQ EXIT_312
00001D28                          4300mm     PRINT_CHAR (A0)+,D0
00001D28                          4301mm WAIT_FOR_READY_313                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D28                 TRUE     4302mm     IFEQ DEBUG
00001D28  1039 00C00003           4303mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D2E  0800 0002               4304mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001D32  67F4                    4305mm         BEQ WAIT_FOR_READY_313                      ; NO SPACE, CHECK AGAIN
00001D34  13D8 00C00007           4306mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D3A                          4307mm     ENDC
00001D3A                          4308mm 
00001D3A                 FALSE    4309mm     IFNE DEBUG
00001D3A                          4310mm     ENDC
00001D3A                          4311mm 
00001D3A                          4312mm     ENDM
00001D3A  60E4                    4313m     BRA LOOP_312
00001D3C                          4314m EXIT_312
00001D3C                          4315m     ENDM
00001D3C                          4316  
00001D3C  222F 000A               4317      MOVE.L 10(SP),D1
00001D40                          4318m     PRINT_REG D1,D2,D3,D4,A0
00001D40  41FA 02F5               4319m     LEA OX(PC),A0
00001D44                          4320mm     PRINT_STR A0,D2
00001D44                          4321mm LOOP_315
00001D44  0C10 0000               4322mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D48  6700 0016               4323mm     BEQ EXIT_315
00001D4C                          4324mmm     PRINT_CHAR (A0)+,D2
00001D4C                          4325mmm WAIT_FOR_READY_316                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D4C                 TRUE     4326mmm     IFEQ DEBUG
00001D4C  1439 00C00003           4327mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D52  0802 0002               4328mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D56  67F4                    4329mmm         BEQ WAIT_FOR_READY_316                      ; NO SPACE, CHECK AGAIN
00001D58  13D8 00C00007           4330mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D5E                          4331mmm     ENDC
00001D5E                          4332mmm 
00001D5E                 FALSE    4333mmm     IFNE DEBUG
00001D5E                          4334mmm     ENDC
00001D5E                          4335mmm 
00001D5E                          4336mmm     ENDM
00001D5E  60E4                    4337mm     BRA LOOP_315
00001D60                          4338mm EXIT_315
00001D60                          4339mm     ENDM
00001D60  7807                    4340m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001D62                          4341m LOOP_314
00001D62                          4342mm     BIN2HEX D1,D3,A0
00001D62  41FA 0292               4343mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001D66  E999                    4344mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001D68  1601                    4345mm     MOVE.B D1,D3
00001D6A  0283 0000000F           4346mm     ANDI.L #$F,D3
00001D70  1630 3000               4347mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D74                          4348mm     ENDM
00001D74                          4349mm     PRINT_CHAR D3,D2
00001D74                          4350mm WAIT_FOR_READY_318                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D74                 TRUE     4351mm     IFEQ DEBUG
00001D74  1439 00C00003           4352mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D7A  0802 0002               4353mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D7E  67F4                    4354mm         BEQ WAIT_FOR_READY_318                      ; NO SPACE, CHECK AGAIN
00001D80  13C3 00C00007           4355mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D86                          4356mm     ENDC
00001D86                          4357mm 
00001D86                 FALSE    4358mm     IFNE DEBUG
00001D86                          4359mm     ENDC
00001D86                          4360mm 
00001D86                          4361mm     ENDM
00001D86  57CC FFDA               4362m     DBEQ D4,LOOP_314
00001D8A                          4363m     ENDM
00001D8A                          4364m     PRINT_CRLF D0,A0
00001D8A  41FA 02A5               4365m     LEA CRLF(PC),A0
00001D8E                          4366mm     PRINT_STR A0,D0
00001D8E                          4367mm LOOP_320
00001D8E  0C10 0000               4368mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D92  6700 0016               4369mm     BEQ EXIT_320
00001D96                          4370mmm     PRINT_CHAR (A0)+,D0
00001D96                          4371mmm WAIT_FOR_READY_321                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D96                 TRUE     4372mmm     IFEQ DEBUG
00001D96  1039 00C00003           4373mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D9C  0800 0002               4374mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001DA0  67F4                    4375mmm         BEQ WAIT_FOR_READY_321                      ; NO SPACE, CHECK AGAIN
00001DA2  13D8 00C00007           4376mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DA8                          4377mmm     ENDC
00001DA8                          4378mmm 
00001DA8                 FALSE    4379mmm     IFNE DEBUG
00001DA8                          4380mmm     ENDC
00001DA8                          4381mmm 
00001DA8                          4382mmm     ENDM
00001DA8  60E4                    4383mm     BRA LOOP_320
00001DAA                          4384mm EXIT_320
00001DAA                          4385mm     ENDM
00001DAA                          4386m     ENDM
00001DAA                          4387      
00001DAA  207C 00000004           4388      MOVE.L #4,A0
00001DB0  4ED0                    4389      JMP (A0)
00001DB2                          4390          
00001DB2                          4391  ILLEGAL_HANDLER
00001DB2  13FC 0007 00E00001      4392      MOVE.B #7,DISPLAY   
00001DBA  207C 00000004           4393      MOVE.L #4,A0
00001DC0  4ED0                    4394      JMP (A0)
00001DC2                          4395          
00001DC2                          4396  UNHANDLED_HANDLER
00001DC2  41FA 02D8               4397      LEA UNHANDLED(PC),A0
00001DC6  4EF9 00001DEA           4398      JMP PRINTIT_RTE
00001DCC                          4399      
00001DCC                          4400  UNINITIALISED_HANDLER
00001DCC  41FA 02E4               4401      LEA UNINITIALISED(PC),A0
00001DD0  4EF9 00001DEA           4402      JMP PRINTIT_RTE
00001DD6                          4403  
00001DD6                          4404  TICK_HANDLER
00001DD6  1039 00C0001F           4405      MOVE.B DUART_RESET_OPR,D0
00001DDC  41FA 0289               4406      LEA TICK(PC),A0
00001DE0  4EF9 00001DEA           4407      JMP PRINTIT_RTE
00001DE6                          4408  
00001DE6                          4409  SPURIOUS_HANDLER
00001DE6  41FA 02E9               4410      LEA SPURIOUS(PC),A0
00001DEA                          4411  PRINTIT_RTE
00001DEA                          4412m     PRINT_STR A0,D1
00001DEA                          4413m LOOP_322
00001DEA  0C10 0000               4414m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001DEE  6700 0016               4415m     BEQ EXIT_322
00001DF2                          4416mm     PRINT_CHAR (A0)+,D1
00001DF2                          4417mm WAIT_FOR_READY_323                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DF2                 TRUE     4418mm     IFEQ DEBUG
00001DF2  1239 00C00003           4419mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001DF8  0801 0002               4420mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001DFC  67F4                    4421mm         BEQ WAIT_FOR_READY_323                      ; NO SPACE, CHECK AGAIN
00001DFE  13D8 00C00007           4422mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001E04                          4423mm     ENDC
00001E04                          4424mm 
00001E04                 FALSE    4425mm     IFNE DEBUG
00001E04                          4426mm     ENDC
00001E04                          4427mm 
00001E04                          4428mm     ENDM
00001E04  60E4                    4429m     BRA LOOP_322
00001E06                          4430m EXIT_322
00001E06                          4431m     ENDM
00001E06  4E73                    4432      RTE 
00001E08                          4433      
00001E08  FFFF FFFF               4434      SIMHALT                                             ; halt simulator
00001E0C                          4435  
00001E0C                          4436  ; strings
00001E0C= 50 72 65 73 73 20 ...   4437  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001E1F= 5B 3F 5D 09 09 09 ...   4438  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001E2B= 5B 76 5D 09 09 09 ...   4439          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001E3A= 78 78 78 78 78 78 ...   4440          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001E52= 78 78 78 78 78 78 ...   4441          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001E72= 78 78 78 78 78 78 ...   4442          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001E93= 78 78 78 78 78 78 ...   4443          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001EA4= 5B 7A 5D 09 09 09 ...   4444          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001EB6= 78 78 78 78 78 78 ...   4445          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001EDA= 78 78 78 78 78 78 ...   4446          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001EFC= 23 09 09 09 77 72 ...   4447          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001F16= 5B 78 5D 09 09 09 ...   4448          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001F2D= 5B 49 5D 09 09 09 ...   4449          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001F46= 5B 6F 5D 09 09 09 ...   4450          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001F60= 5B 69 5D 09 09 09 ...   4451          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001F76= 78 78 78 78 78 78 ...   4452          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001F94= 48 75 68 3F 0D 0A 00    4453  HUH  DC.B 'Huh?',CR,LF,NULL
00001F9B= 20 53 20 72 65 63 ...   4454  READ    DC.B ' S records read, start address = ',NULL
00001FBD= 57 3A 20 55 6E 6B ...   4455  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001FD4= 21 20 43 53 20 66 ...   4456  CS_FAILURE  DC.B '! CS failure at ',NULL
00001FE5= 21 20 52 41 4D 20 ...   4457  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001FF6= 30 31 32 33 34 35 ...   4458  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00002006= 00 01 02 03 04 05 ...   4459  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000201D= 4C 6F 61 64 69 6E ...   4460  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00002031= 0D 0A 00                4461  CRLF    DC.B CR,LF,NULL
00002034= 3E 20 00                4462  PROMPT  DC.B '> ',NULL
00002037= 30 78 00                4463  ox      DC.B '0x',NULL
0000203A= 20 2D 3E 20 00          4464  to      DC.B ' -> ',NULL
0000203F= 20 66 6F 72 20 00       4465  for     DC.B ' for ',NULL
00002045= 53 50 3A 20 00          4466  STACK_POINTER DC.B 'SP: ',NULL
0000204A= 53 52 3A 20 00          4467  STATUS_REGISTER DC.B 'SR: ',NULL
0000204F= 20 3A 20 00             4468  INDEX_SEP DC.B ' : ',NULL
00002053= 42 6F 6F 74 69 6E ...   4469  BOOT DC.B 'Booting',NULL
0000205B= 4E 6F 74 20 66 6F ...   4470  NOT_FOUND DC.B 'Not found',CR,LF,NULL
00002067= 74 69 63 6B 0D 0A 00    4471  TICK DC.B 'tick',CR,LF,NULL
0000206E= 2A 20 42 75 73 2F ...   4472  BUS_ERROR DC.B '* Bus/address error ',NULL
00002083= 72 65 61 64 69 6E ...   4473  READING DC.B 'reading ',NULL
0000208C= 77 72 69 74 69 6E ...   4474  WRITING DC.B 'writing ',NULL
00002095= 20 66 72 6F 6D 20 00    4475  FROM DC.B ' from ',NULL
0000209C= 2A 20 55 6E 68 61 ...   4476  UNHANDLED DC.B '* Unhandled interrupt',NULL
000020B2= 2A 20 55 6E 69 74 ...   4477  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
000020D1= 2A 20 53 70 75 72 ...   4478  SPURIOUS DC.B '* Spurious interrupt',NULL
000020E6= 4D 44 46 2D 6D 6F ...   4479  VERSION DC.B 'MDF-mon V1.156 (20/10/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00002104= 00                      4480  END     DC.B 0
00002105                          4481      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1FF6
BOOT                2053
BUS_ERROR           206E
BUS_ERROR_HANDLER   1C5E
CONTINUE            1CCE
CR                  D
CRLF                2031
CS_FAILURE          1FD4
DEBUG               0
DI                  12DA
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       986
DOWNLOAD_DONE       AA4
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  12CA
END                 2104
EXIT_10             288
EXIT_104            A94
EXIT_107            AC4
EXIT_110            AE4
EXIT_114            B2E
EXIT_117            B50
EXIT_122            B9A
EXIT_124            C16
EXIT_127            C3A
EXIT_132            C84
EXIT_139            D16
EXIT_142            D86
EXIT_144            DA6
EXIT_146            DC6
EXIT_148            DE6
EXIT_15             2D2
EXIT_151            E08
EXIT_155            E52
EXIT_158            E74
EXIT_162            EBE
EXIT_165            EDE
EXIT_17             2F2
EXIT_170            F28
EXIT_185            1052
EXIT_188            10B6
EXIT_191            10D6
EXIT_195            1120
EXIT_198            1142
EXIT_20             312
EXIT_203            118C
EXIT_207            11CE
EXIT_210            11F0
EXIT_215            123A
EXIT_217            125A
EXIT_22             364
EXIT_220            127C
EXIT_225            12C6
EXIT_259            17B2
EXIT_262            1818
EXIT_265            1838
EXIT_270            18D8
EXIT_272            191A
EXIT_274            1946
EXIT_28             3F0
EXIT_298            1C3E
EXIT_30             47C
EXIT_301            1C7E
EXIT_303            1CAA
EXIT_305            1CCE
EXIT_308            1CF2
EXIT_312            1D3C
EXIT_315            1D60
EXIT_32             4A8
EXIT_320            1DAA
EXIT_322            1E06
EXIT_35             4D2
EXIT_45             580
EXIT_5              240
EXIT_52             5F6
EXIT_7              260
EXIT_82             940
EXIT_84             960
EXIT_88             992
EXIT_94             A0A
EXIT_96             A2A
EXIT_99             A4A
FOR                 203F
FROM                2095
G                   B9E
GET_INPUT           364
H                   480
HASH                12EA
HELP                1E1F
HELPPROMPT          1E0C
HEX2BIN             10B
HEX2BIN_LUT         2006
HEX_DIGIT           1C44
HUH                 1F94
IB                  1300
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1DB2
INDEX_SEP           204F
L                   C94
LF                  A
LOADING             201D
LOOP_10             26C
LOOP_104            A78
LOOP_107            AA8
LOOP_109            AE6
LOOP_110            AC8
LOOP_114            B12
LOOP_116            B52
LOOP_117            B34
LOOP_122            B7E
LOOP_124            BFA
LOOP_126            C3C
LOOP_127            C1E
LOOP_132            C68
LOOP_139            CFA
LOOP_142            D6A
LOOP_144            D8A
LOOP_146            DAA
LOOP_148            DCA
LOOP_15             2B6
LOOP_150            E0A
LOOP_151            DEC
LOOP_155            E36
LOOP_157            E76
LOOP_158            E58
LOOP_162            EA2
LOOP_164            EE0
LOOP_165            EC2
LOOP_17             2D6
LOOP_170            F0C
LOOP_185            1036
LOOP_188            109A
LOOP_190            10D8
LOOP_191            10BA
LOOP_195            1104
LOOP_197            1144
LOOP_198            1126
LOOP_20             2F6
LOOP_203            1170
LOOP_207            11B2
LOOP_209            11F2
LOOP_210            11D4
LOOP_215            121E
LOOP_217            123E
LOOP_219            127E
LOOP_22             348
LOOP_220            1260
LOOP_225            12AA
LOOP_229            1342
LOOP_233            1380
LOOP_245            1558
LOOP_248            1596
LOOP_259            1796
LOOP_262            17FC
LOOP_264            183A
LOOP_265            181C
LOOP_270            18BC
LOOP_272            18FE
LOOP_274            192A
LOOP_277            1954
LOOP_28             3D4
LOOP_289            1B2C
LOOP_292            1B6A
LOOP_298            1C22
LOOP_30             460
LOOP_301            1C62
LOOP_303            1C8E
LOOP_305            1CB2
LOOP_307            1CF4
LOOP_308            1CD6
LOOP_312            1D20
LOOP_314            1D62
LOOP_315            1D44
LOOP_32             48C
LOOP_320            1D8E
LOOP_322            1DEA
LOOP_34             4D4
LOOP_35             4B6
LOOP_45             564
LOOP_5              224
LOOP_52             5DA
LOOP_7              244
LOOP_82             924
LOOP_84             944
LOOP_88             976
LOOP_9              28A
LOOP_94             9EE
LOOP_96             A0E
LOOP_98             A4C
LOOP_99             A2E
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           205B
NULL                0
OX                  2037
P                   FDE
PRINTIT             48C
PRINTIT_RTE         1DEA
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             C5B
PROGRAM_VECTOR      CF2
PROMPT              2034
PROTECT             BF7
R                   4AC
RAM                 200000
RAM_ERROR           1FE5
READ                1F9B
READING             2083
READ_16             10E5
READ_32             1312
READ_8              D70
READ_CHAR           6DD
READ_IDE_STATUS     1361
RESET               4
ROM                 0
S                   5FE
SEND_COMMAND        15E3
SEND_READ_COMMAND_AND_WAIT  1612
SET_READ_ADDRESS    1481
SPURIOUS            20D1
SPURIOUS_HANDLER    1DE6
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       2045
START               104
STATUS_REGISTER     204A
TAB                 9
TICK                2067
TICK_HANDLER        1DD6
TO                  203A
UNHANDLED           209C
UNHANDLED_HANDLER   1DC2
UNINITIALISED       20B2
UNINITIALISED_HANDLER  1DCC
UNPROTECT           B30
UNREC               1FBD
USER                100
V                   488
VECS                8
VERSION             20E6
W                   584
WAIT_CHAR           599
WAIT_DRIVE_DRQ      1431
WAIT_DRIVE_NOT_BUSY  13E0
WAIT_DRIVE_READY    138E
WAIT_FOR_COMPLETE_172  F40
WAIT_FOR_COMPLETE_174  F62
WAIT_FOR_COMPLETE_175  F74
WAIT_FOR_COMPLETE_177  FA4
WAIT_FOR_COMPLETE_178  FB6
WAIT_FOR_COMPLETE_205  118E
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_100  A36
WAIT_FOR_READY_102  A5E
WAIT_FOR_READY_105  A80
WAIT_FOR_READY_108  AB0
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AD0
WAIT_FOR_READY_113  AF8
WAIT_FOR_READY_115  B1A
WAIT_FOR_READY_118  B3C
WAIT_FOR_READY_120  B64
WAIT_FOR_READY_123  B86
WAIT_FOR_READY_125  C02
WAIT_FOR_READY_128  C26
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_130  C4E
WAIT_FOR_READY_133  C70
WAIT_FOR_READY_134  CA2
WAIT_FOR_READY_136  CBC
WAIT_FOR_READY_140  D02
WAIT_FOR_READY_143  D72
WAIT_FOR_READY_145  D92
WAIT_FOR_READY_147  DB2
WAIT_FOR_READY_149  DD2
WAIT_FOR_READY_152  DF4
WAIT_FOR_READY_154  E1C
WAIT_FOR_READY_156  E3E
WAIT_FOR_READY_159  E60
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E88
WAIT_FOR_READY_163  EAA
WAIT_FOR_READY_166  ECA
WAIT_FOR_READY_168  EF2
WAIT_FOR_READY_171  F14
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  FEA
WAIT_FOR_READY_182  1004
WAIT_FOR_READY_186  103E
WAIT_FOR_READY_189  10A2
WAIT_FOR_READY_192  10C2
WAIT_FOR_READY_194  10EA
WAIT_FOR_READY_196  110C
WAIT_FOR_READY_199  112E
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  1156
WAIT_FOR_READY_204  1178
WAIT_FOR_READY_208  11BA
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  11DC
WAIT_FOR_READY_213  1204
WAIT_FOR_READY_216  1226
WAIT_FOR_READY_218  1246
WAIT_FOR_READY_221  1268
WAIT_FOR_READY_223  1290
WAIT_FOR_READY_226  12B2
WAIT_FOR_READY_23   350
WAIT_FOR_READY_24   364
WAIT_FOR_READY_258  1780
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_260  179E
WAIT_FOR_READY_261  17CC
WAIT_FOR_READY_263  1804
WAIT_FOR_READY_266  1824
WAIT_FOR_READY_268  184C
WAIT_FOR_READY_271  18C4
WAIT_FOR_READY_273  1906
WAIT_FOR_READY_275  1932
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_295  1BA8
WAIT_FOR_READY_299  1C2A
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_302  1C6A
WAIT_FOR_READY_304  1C96
WAIT_FOR_READY_306  1CBA
WAIT_FOR_READY_309  1CDE
WAIT_FOR_READY_31   468
WAIT_FOR_READY_311  1D06
WAIT_FOR_READY_313  1D28
WAIT_FOR_READY_316  1D4C
WAIT_FOR_READY_318  1D74
WAIT_FOR_READY_321  1D96
WAIT_FOR_READY_323  1DF2
WAIT_FOR_READY_33   494
WAIT_FOR_READY_36   4BE
WAIT_FOR_READY_38   4E6
WAIT_FOR_READY_39   4FC
WAIT_FOR_READY_40   512
WAIT_FOR_READY_41   526
WAIT_FOR_READY_42   53A
WAIT_FOR_READY_43   54E
WAIT_FOR_READY_46   56C
WAIT_FOR_READY_47   58E
WAIT_FOR_READY_49   5A8
WAIT_FOR_READY_53   5E2
WAIT_FOR_READY_54   608
WAIT_FOR_READY_55   62E
WAIT_FOR_READY_56   644
WAIT_FOR_READY_58   676
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   6E4
WAIT_FOR_READY_64   730
WAIT_FOR_READY_67   786
WAIT_FOR_READY_70   7DE
WAIT_FOR_READY_73   840
WAIT_FOR_READY_76   88C
WAIT_FOR_READY_79   8D8
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_83   92C
WAIT_FOR_READY_85   94C
WAIT_FOR_READY_86   960
WAIT_FOR_READY_89   97E
WAIT_FOR_READY_91   9A4
WAIT_FOR_READY_95   9F6
WAIT_FOR_READY_97   A16
WAIT_FOR_SRECORD    608
WRITE               1CAE
WRITE_8             F29
WRITING             208C
X                   11AE
Z                   BA4
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6C4
_00000004           996
_00000005           6D2
_00000006           828
_00000007           7C4
_00000008           996
_00000009           920
_0000000A           996
_0000000B           A98
_0000000C           AA4
_0000000D           C84
_0000000E           F4A
_0000000F           F6C
_00000010           F7E
_00000011           FAE
_00000012           FC0
_00000013           1198
_00000014           169A
_00000015           1696
_00000016           189E
_00000017           1758
_00000018           1898
_00000019           1864
_0000001A           17B2
_0000001B           17E6
_0000001C           1864
_0000001D           1894
_0000001E           1876
_0000001F           1880
_00000020           188A
_00000021           1894
_00000022           189E
_00000023           18D8
_00000024           18D8
_00000025           191E
_00000026           18FA
_00000027           191E
_00000028           1C40
_10000000           66C
_10000001           6AE
_10000002           6DA
_10000003           71C
_10000004           726
_10000005           768
_10000006           77C
_10000007           7BE
_10000008           7C8
_10000009           822
_1000000A           7D4
_1000000B           816
_1000000C           836
_1000000D           878
_1000000E           882
_1000000F           8C4
_10000010           8CE
_10000011           910
_10000012           99A
_10000013           9DC
_10000014           F28
_10000015           F50
_10000016           194A
_10000017           1C1E
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           58C
_20000005           5D0
_20000006           BB6
_20000007           BC6
_20000008           BE0
_20000009           C86
_2000000A           CA0
_2000000B           CE4
_2000000C           D5C
_2000000D           D60
_2000000E           F86
_2000000F           FC2
_20000010           FE8
_20000011           102C
_20000012           108C
_20000013           1090
_20000014           15DC
_20000015           1672
_20000016           16A8
_20000017           18DC
_20000018           16B4
_20000019           18A0
_2000001A           17CA
_2000001B           17E0
_2000001C           1BC2
_2000001D           1C10
