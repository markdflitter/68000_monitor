00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 25/05/2021 07:47:05

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           190  PRINT_REG MACRO
00000000                           191      LEA ox(PC),\5
00000000                           192      PRINT_STR \5,\2
00000000                           193      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           194  LOOP\@
00000000                           195      BIN2HEX \1,\3,\5
00000000                           196      PRINT_CHAR \3,\2
00000000                           197      DBEQ \4,LOOP\@
00000000                           198      ENDM
00000000                           199  
00000000                           200  ; wait for a char from the serial port
00000000                           201  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           202  ; will stamp on D0 and D1 in debug mode
00000000                           203  WAIT_CHAR MACRO
00000000                           204  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           205      IFEQ DEBUG
00000000                           206          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           207          BTST #0,\2                                  ; check for character
00000000                           208          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           209      ENDC
00000000                           210  
00000000                           211      READ_CHAR \1
00000000                           212  
00000000                           213      IFEQ DEBUG
00000000                           214          PRINT_CHAR \1,\2                            ; echo it back
00000000                           215      ENDC
00000000                           216      ENDM
00000000                           217  
00000000                           218  ; read a char from the serial port - assumes that there is one!
00000000                           219  ; \ 1= data register for read char
00000000                           220  ; will stamp on D0 and D1 in debug mode
00000000                           221  READ_CHAR MACRO
00000000                           222      IFEQ DEBUG
00000000                           223          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           224      ENDC
00000000                           225      IFNE DEBUG
00000000                           226          MOVE.L #5,D0    
00000000                           227          TRAP #15                                    ; read from keyboard in simulator
00000000                           228          MOVE.L D1,\1
00000000                           229      ENDC
00000000                           230  
00000000                           231      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           232      BEQ START
00000000                           233      ENDM
00000000                           234  
00000000                           235  
00000000                           236  ; read data from the download serial port
00000000                           237  ; \ 1= data register for read char
00000000                           238  DOWNLOAD MACRO
00000000                           239  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           240  
00000000                           241      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           242      BTST #0,\1                                      ; check for character
00000000                           243      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           244  
00000000                           245      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           246  CONTINUE\@
00000000                           247      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           248      BTST #0,\1                                      ; check for character
00000000                           249      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           250      
00000000                           251      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           252      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           253  
00000000                           254      ENDM
00000000                           255  
00000000                           256  ; unprotect the EEPROM
00000000                           257  UNPROTECT MACRO
00000000                           258      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           259      NOP
00000000                           260      MOVE.W #$5555,$1554
00000000                           261      NOP
00000000                           262      MOVE.W #$8080,$2AAA
00000000                           263      NOP
00000000                           264      MOVE.W #$AAAA,$2AAA
00000000                           265      NOP
00000000                           266      MOVE.W #$5555,$1554
00000000                           267      NOP
00000000                           268      MOVE.W #$2020,$2AAA
00000000                           269      ENDM
00000000                           270      
00000000                           271  ; protect the EEPROM
00000000                           272  PROTECT MACRO
00000000                           273      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           274      MOVE.W #$5555,$1554
00000000                           275      MOVE.W #$A0A0,$2AAA
00000000                           276      ENDM
00000000                           277  
00000000                           278  
00000000                           279  ; read two hex digits from the download serial port and convert to a byte
00000000                           280  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           281  DOWNLOAD_BYTE MACRO
00000000                           282      MOVE.B #2,\4
00000000                           283      WHILE.B \4 <GT> 0 DO
00000000                           284          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           285          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           286          PRINT_CHAR \2,\3
00000000                           287          HEX2BIN \2,\2,\6
00000000                           288          OR.B \2,\1
00000000                           289          SUB.B #1,\4
00000000                           290      ENDW
00000000                           291  
00000000                           292      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           293      MOVE.B \1,\2
00000000                           294      ADD.L \1,\5
00000000                           295  
00000000                           296      ENDM
00000000                           297  
00000000                           298  ; write word to EEPROM
00000000                           299  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           300  PROGRAM MACRO
00000000                           301    MOVE.W \1,\2                                      ; write the data
00000000                           302  
00000000                           303  WAIT_FOR_COMPLETE\@
00000000                           304          MOVE.W \2,\3
00000000                           305  
00000000                           306          IF.W \3 <NE> \1 THEN
00000000                           307              BRA WAIT_FOR_COMPLETE\@
00000000                           308          ENDI
00000000                           309          ENDM
00000000                           310          
00000000                           311  ; program vector to EEPROM
00000000                           312  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           313  PROGRAM_VECTOR MACRO
00000000                           314      ADD.L #2,\2
00000000                           315      PROGRAM \1, (\2), \3                            ; write it
00000000                           316      LSR.L #8,\1
00000000                           317      LSR.L #8,\1
00000000                           318      SUB.L #2,\2
00000000                           319      PROGRAM \1, (\2), \3
00000000                           320      ENDM
00000000                           321  
00000000                           322  ; read an ide register
00000000                           323  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           324  READ_8 MACRO
00000000                           325      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           326      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           327      ORI.B \1, \3
00000000                           328      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           329      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           330      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           331      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           332      ORI.B #MC68230_PORT_C_READ, \3
00000000                           333      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           334      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           335      ENDM
00000000                           336      
00000000                           337  ; write an ide register
00000000                           338  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           339  WRITE_8 MACRO
00000000                           340      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           341      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           342      ORI.B \2, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           345      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           346      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           347      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           348      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           349      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           350      ENDM
00000000                           351  
00000000                           352  ; read ide data
00000000                           353  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           354  READ_16 MACRO
00000000                           355      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           356      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           357      
00000000                           358      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           359      ORI.B \1, \3
00000000                           360      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           361      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           362      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           363      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           364      LSL.W #8, \2
00000000                           365      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           366      ORI.B #MC68230_PORT_C_READ, \3
00000000                           367      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           369      ENDM
00000000                           370      
00000000                           371  ; read ide data
00000000                           372  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           373  READ_32 MACRO
00000000                           374      READ_16 \1, \2, \3
00000000                           375      LSL.L #8, \2
00000000                           376      LSL.L #8, \2
00000000                           377      READ_16 \1, \2, \3
00000000                           378      ENDM
00000000                           379          
00000000                           380  ; read ide status
00000000                           381  ;\1 = data register for result, \2 = working data register 
00000000                           382  READ_IDE_STATUS MACRO   
00000000                           383      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           384      ENDM
00000000                           385      
00000000                           386  ; wait for ide drive to be ready
00000000                           387  ;\1 = working data register 1, \2 = working data register 2
00000000                           388  WAIT_DRIVE_READY MACRO
00000000                           389  LOOP\@
00000000                           390      READ_IDE_STATUS \1, \2
00000000                           391      BTST #IDE_STATUS_READY, \1
00000000                           392      BEQ LOOP\@
00000000                           393      ENDM
00000000                           394      
00000000                           395  ; wait for ide drive to be not busy
00000000                           396  ;\1 = working data register 1, \2 = working data register 2
00000000                           397  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           398  LOOP\@
00000000                           399      READ_IDE_STATUS \1, \2
00000000                           400      BTST #IDE_STATUS_BUSY, \1
00000000                           401      BNE LOOP\@
00000000                           402      ENDM
00000000                           403      
00000000                           404  ; wait for ide drive to have data for us
00000000                           405  ;\1 = working data register 1, \2 = working data register 2
00000000                           406  WAIT_DRIVE_DRQ MACRO
00000000                           407  LOOP\@
00000000                           408      READ_IDE_STATUS \1, \2
00000000                           409      BTST #IDE_STATUS_DRQ, \1
00000000                           410      BEQ LOOP\@
00000000                           411      ENDM
00000000                           412      
00000000                           413  ; prepare to send a read command
00000000                           414  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           415  SET_READ_ADDRESS MACRO
00000000                           416      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           417      MOVE.L \1,\3
00000000                           418      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           419      LSR.L #8, \3
00000000                           420      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           421      LSR.L #8, \3                                
00000000                           422      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           423      LSR.L #8, \3
00000000                           424      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           425      ANDI.B #$0F,\3
00000000                           426      OR.B \3,\4
00000000                           427      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           428      ENDM
00000000                           429  
00000000                           430  ; send command
00000000                           431  ; \1 = command, \2 = working data register 1,
00000000                           432  SEND_COMMAND MACRO
00000000                           433      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           434      ENDM
00000000                           435      
00000000                           436  ; send read command and wait
00000000                           437  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           438  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           439      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           440      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           441      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           442      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           443      WAIT_DRIVE_DRQ \2, \3
00000000                           444      ENDM
00000000                           445  
00000000                           446  ; register catalogue
00000000                           447  ; D0 - used for simulator I/O
00000000                           448  ; D1 - used for simulator I/O
00000000                           449  ; D2 - read character
00000000                           450  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           451  ; D6 - working register used in R/W
00000000                           452  ; D7 - address accumulator, reset by download
00000000                           453  ; A0 - address of string to print 
00000000                           454  
00000000                           455  ; start vector
00000000= 002E0000                 456  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 457  RESET   DC.L START                              ; RESET
00000008= 0000197A                 458  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 0000197A                 459          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001ACE                 460          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001ADE                 461          DC.L UNHANDLED_HANDLER
00000018= 00001ADE                 462          DC.L UNHANDLED_HANDLER
0000001C= 00001ADE                 463          DC.L UNHANDLED_HANDLER
00000020= 00001ADE                 464          DC.L UNHANDLED_HANDLER
00000024= 00001ADE                 465          DC.L UNHANDLED_HANDLER
00000028= 00001ADE                 466          DC.L UNHANDLED_HANDLER
0000002C= 00001ADE                 467          DC.L UNHANDLED_HANDLER
00000030= 00001ADE                 468          DC.L UNHANDLED_HANDLER
00000034= 00001ADE                 469          DC.L UNHANDLED_HANDLER
00000038= 00001ADE                 470          DC.L UNHANDLED_HANDLER
0000003C= 00001ADE                 471          DC.L UNHANDLED_HANDLER
00000040= 00001ADE                 472          DC.L UNHANDLED_HANDLER
00000044= 00001ADE                 473          DC.L UNHANDLED_HANDLER
00000048= 00001ADE                 474          DC.L UNHANDLED_HANDLER
0000004C= 00001ADE                 475          DC.L UNHANDLED_HANDLER
00000050= 00001ADE                 476          DC.L UNHANDLED_HANDLER
00000054= 00001ADE                 477          DC.L UNHANDLED_HANDLER
00000058= 00001ADE                 478          DC.L UNHANDLED_HANDLER
0000005C= 00001ADE                 479          DC.L UNHANDLED_HANDLER
00000060= 00001B02                 480          DC.L SPURIOUS_HANDLER
00000064= 00001ADE                 481          DC.L UNHANDLED_HANDLER
00000068= 00001ADE                 482          DC.L UNHANDLED_HANDLER
0000006C= 00001ADE                 483          DC.L UNHANDLED_HANDLER
00000070= 00001ADE                 484          DC.L UNHANDLED_HANDLER
00000074= 00001ADE                 485          DC.L UNHANDLED_HANDLER
00000078= 00001ADE                 486          DC.L UNHANDLED_HANDLER
0000007C= 00001ADE                 487          DC.L UNHANDLED_HANDLER
00000080= 00001ADE                 488          DC.L UNHANDLED_HANDLER
00000084= 00001ADE                 489          DC.L UNHANDLED_HANDLER
00000088= 00001ADE                 490          DC.L UNHANDLED_HANDLER
0000008C= 00001ADE                 491          DC.L UNHANDLED_HANDLER
00000090= 00001ADE                 492          DC.L UNHANDLED_HANDLER
00000094= 00001ADE                 493          DC.L UNHANDLED_HANDLER
00000098= 00001ADE                 494          DC.L UNHANDLED_HANDLER
0000009C= 00001ADE                 495          DC.L UNHANDLED_HANDLER
000000A0= 00001ADE                 496          DC.L UNHANDLED_HANDLER
000000A4= 00001ADE                 497          DC.L UNHANDLED_HANDLER
000000A8= 00001ADE                 498          DC.L UNHANDLED_HANDLER
000000AC= 00001ADE                 499          DC.L UNHANDLED_HANDLER
000000B0= 00001ADE                 500          DC.L UNHANDLED_HANDLER
000000B4= 00001ADE                 501          DC.L UNHANDLED_HANDLER
000000B8= 00001ADE                 502          DC.L UNHANDLED_HANDLER
000000BC= 00001ADE                 503          DC.L UNHANDLED_HANDLER
000000C0= 00001ADE                 504          DC.L UNHANDLED_HANDLER
000000C4= 00001ADE                 505          DC.L UNHANDLED_HANDLER
000000C8= 00001ADE                 506          DC.L UNHANDLED_HANDLER
000000CC= 00001ADE                 507          DC.L UNHANDLED_HANDLER
000000D0= 00001ADE                 508          DC.L UNHANDLED_HANDLER
000000D4= 00001ADE                 509          DC.L UNHANDLED_HANDLER
000000D8= 00001ADE                 510          DC.L UNHANDLED_HANDLER 
000000DC= 00001ADE                 511          DC.L UNHANDLED_HANDLER
000000E0= 00001ADE                 512          DC.L UNHANDLED_HANDLER
000000E4= 00001ADE                 513          DC.L UNHANDLED_HANDLER 
000000E8= 00001ADE                 514          DC.L UNHANDLED_HANDLER 
000000EC= 00001ADE                 515          DC.L UNHANDLED_HANDLER
000000F0= 00001ADE                 516          DC.L UNHANDLED_HANDLER 
000000F4= 00001ADE                 517          DC.L UNHANDLED_HANDLER 
000000F8= 00001ADE                 518          DC.L UNHANDLED_HANDLER 
000000FC= 00001ADE                 519          DC.L UNHANDLED_HANDLER
00000100= 00001AF2                 520  USER    DC.L TICK_HANDLER
00000104                           521      ; start of program  
00000104                           522  START
00000104  2E7C 002E0000            523      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       524      MOVE.B #0,DISPLAY
00000112                           525  
00000112  7000                     526      MOVE.L #0,D0
00000114  1039 00C00019            527      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           528  
0000011A                           529  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       530      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       531      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           532      
0000012A                           533      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                534s     MOVE.W  #$50,D1
0000012E  6000 000E                535s     BRA _20000001
00000132                           536s _20000000
00000132  13C1 00C00005            537          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     538          NOP
0000013A                           539      ENDF
0000013A  0441 0010                540s     SUB.W   #$10,D1
0000013E                           541s _20000001
0000013E  B27C 0010                542s     CMP.W   #$10,D1
00000142  6CEE                     543s     BGE _20000000
00000144                           544  
00000144                           545      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                546s     MOVE.W  #$50,D1
00000148  6000 000E                547s     BRA _20000003
0000014C                           548s _20000002
0000014C  13C1 00C00015            549          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     550          NOP
00000154                           551      ENDF
00000154  0441 0010                552s     SUB.W   #$10,D1
00000158                           553s _20000003
00000158  B27C 0010                554s     CMP.W   #$10,D1
0000015C  6CEE                     555s     BGE _20000002
0000015E                           556      
0000015E                           557  ;initialise UART
0000015E  13FC 0000 00C0000B       558      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       559      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       560      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       561      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       562      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           563  
00000186                           564  ; channel A
00000186  13FC 0013 00C00001       565      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       566      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       567      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       568      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           569  
000001A6                           570  ; channel B
000001A6  13FC 0013 00C00011       571      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       572      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       573      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       574      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       575      MOVE.B #64,DUART_IVR
000001CE                           576  
000001CE                           577m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           578m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      579m     IFEQ DEBUG
000001CE  1239 00C00003            580m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                581m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     582m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       583m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           584m     ENDC
000001E2                           585m 
000001E2                 FALSE     586m     IFNE DEBUG
000001E2                           587m     ENDC
000001E2                           588m 
000001E2                           589m     ENDM
000001E2                           590m     PRINT_CHAR #0,D1
000001E2                           591m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      592m     IFEQ DEBUG
000001E2  1239 00C00003            593m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                594m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     595m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       596m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           597m     ENDC
000001F6                           598m 
000001F6                 FALSE     599m     IFNE DEBUG
000001F6                           600m     ENDC
000001F6                           601m 
000001F6                           602m     ENDM
000001F6                           603m     PRINT_CHAR #0,D1
000001F6                           604m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      605m     IFEQ DEBUG
000001F6  1239 00C00003            606m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                607m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     608m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       609m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           610m     ENDC
0000020A                           611m 
0000020A                 FALSE     612m     IFNE DEBUG
0000020A                           613m     ENDC
0000020A                           614m 
0000020A                           615m     ENDM
0000020A                           616      
0000020A                           617      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                618s     CMP.W   #$0F,D0
0000020E  6600 0008                619s     BNE _00000000
00000212  1039 00C00005            620          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           621      ENDI
00000218                           622s _00000000
00000218                           623  
00000218  13FC 0001 00E00001       624      MOVE.B #1,DISPLAY
00000220                           625      
00000220                           626m     PRINT_CRLF D1,A0
00000220  41FA 1B15                627m     LEA CRLF(PC),A0
00000224                           628mm     PRINT_STR A0,D1
00000224                           629mm LOOP_5
00000224  0C10 0000                630mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                631mm     BEQ EXIT_5
0000022C                           632mmm     PRINT_CHAR (A0)+,D1
0000022C                           633mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      634mmm     IFEQ DEBUG
0000022C  1239 00C00003            635mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                636mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     637mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            638mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           639mmm     ENDC
0000023E                           640mmm 
0000023E                 FALSE     641mmm     IFNE DEBUG
0000023E                           642mmm     ENDC
0000023E                           643mmm 
0000023E                           644mmm     ENDM
0000023E  60E4                     645mm     BRA LOOP_5
00000240                           646mm EXIT_5
00000240                           647mm     ENDM
00000240                           648m     ENDM
00000240  41FA 1B92                649      LEA VERSION(PC),A0
00000244                           650m     PRINT_STR A0,D3
00000244                           651m LOOP_7
00000244  0C10 0000                652m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                653m     BEQ EXIT_7
0000024C                           654mm     PRINT_CHAR (A0)+,D3
0000024C                           655mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      656mm     IFEQ DEBUG
0000024C  1639 00C00003            657mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                658mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     659mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            660mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           661mm     ENDC
0000025E                           662mm 
0000025E                 FALSE     663mm     IFNE DEBUG
0000025E                           664mm     ENDC
0000025E                           665mm 
0000025E                           666mm     ENDM
0000025E  60E4                     667m     BRA LOOP_7
00000260                           668m EXIT_7
00000260                           669m     ENDM
00000260                           670  
00000260  41F9 00001DF2            671      LEA END,A0
00000266  2008                     672      MOVE.L A0,D0
00000268                           673m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1AD3                674m     LEA OX(PC),A0
0000026C                           675mm     PRINT_STR A0,D1
0000026C                           676mm LOOP_10
0000026C  0C10 0000                677mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                678mm     BEQ EXIT_10
00000274                           679mmm     PRINT_CHAR (A0)+,D1
00000274                           680mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      681mmm     IFEQ DEBUG
00000274  1239 00C00003            682mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                683mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     684mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            685mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           686mmm     ENDC
00000286                           687mmm 
00000286                 FALSE     688mmm     IFNE DEBUG
00000286                           689mmm     ENDC
00000286                           690mmm 
00000286                           691mmm     ENDM
00000286  60E4                     692mm     BRA LOOP_10
00000288                           693mm EXIT_10
00000288                           694mm     ENDM
00000288  7607                     695m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           696m LOOP_9
0000028A                           697mm     BIN2HEX D0,D2,A0
0000028A  41FA 1A70                698mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     699mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     700mm     MOVE.B D0,D2
00000292  0282 0000000F            701mm     ANDI.L #$F,D2
00000298  1430 2000                702mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           703mm     ENDM
0000029C                           704mm     PRINT_CHAR D2,D1
0000029C                           705mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      706mm     IFEQ DEBUG
0000029C  1239 00C00003            707mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                708mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     709mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            710mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           711mm     ENDC
000002AE                           712mm 
000002AE                 FALSE     713mm     IFNE DEBUG
000002AE                           714mm     ENDC
000002AE                           715mm 
000002AE                           716mm     ENDM
000002AE  57CB FFDA                717m     DBEQ D3,LOOP_9
000002B2                           718m     ENDM
000002B2                           719m     PRINT_CRLF D1,A0
000002B2  41FA 1A83                720m     LEA CRLF(PC),A0
000002B6                           721mm     PRINT_STR A0,D1
000002B6                           722mm LOOP_15
000002B6  0C10 0000                723mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                724mm     BEQ EXIT_15
000002BE                           725mmm     PRINT_CHAR (A0)+,D1
000002BE                           726mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      727mmm     IFEQ DEBUG
000002BE  1239 00C00003            728mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                729mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     730mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            731mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           732mmm     ENDC
000002D0                           733mmm 
000002D0                 FALSE     734mmm     IFNE DEBUG
000002D0                           735mmm     ENDC
000002D0                           736mmm 
000002D0                           737mmm     ENDM
000002D0  60E4                     738mm     BRA LOOP_15
000002D2                           739mm EXIT_15
000002D2                           740mm     ENDM
000002D2                           741m     ENDM
000002D2                           742  
000002D2  41FA 1854                743      LEA HELPPROMPT(PC),A0
000002D6                           744m     PRINT_STR A0,D3
000002D6                           745m LOOP_17
000002D6  0C10 0000                746m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                747m     BEQ EXIT_17
000002DE                           748mm     PRINT_CHAR (A0)+,D3
000002DE                           749mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      750mm     IFEQ DEBUG
000002DE  1639 00C00003            751mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                752mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     753mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            754mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           755mm     ENDC
000002F0                           756mm 
000002F0                 FALSE     757mm     IFNE DEBUG
000002F0                           758mm     ENDC
000002F0                           759mm 
000002F0                           760mm     ENDM
000002F0  60E4                     761m     BRA LOOP_17
000002F2                           762m EXIT_17
000002F2                           763m     ENDM
000002F2                           764  
000002F2                           765m     PRINT_CRLF D3,A0
000002F2  41FA 1A43                766m     LEA CRLF(PC),A0
000002F6                           767mm     PRINT_STR A0,D3
000002F6                           768mm LOOP_20
000002F6  0C10 0000                769mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                770mm     BEQ EXIT_20
000002FE                           771mmm     PRINT_CHAR (A0)+,D3
000002FE                           772mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      773mmm     IFEQ DEBUG
000002FE  1639 00C00003            774mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                775mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     776mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            777mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           778mmm     ENDC
00000310                           779mmm 
00000310                 FALSE     780mmm     IFNE DEBUG
00000310                           781mmm     ENDC
00000310                           782mmm 
00000310                           783mmm     ENDM
00000310  60E4                     784mm     BRA LOOP_20
00000312                           785mm EXIT_20
00000312                           786mm     ENDM
00000312                           787m     ENDM
00000312                           788  
00000312  7E00                     789      MOVE.L #0,D7                                    ; address accumulator
00000314                           790  
00000314  13FC 0002 00E00001       791      MOVE.B #2,DISPLAY
0000031C                           792      
0000031C  13FC 0000 00A00001       793      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       794      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       795      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       796      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           797      
0000033C  13FC 0003 00E00001       798      MOVE.B #3,DISPLAY
00000344                           799      
00000344                           800      
00000344                           801  MAIN_LOOP
00000344  41FA 19F4                802      LEA PROMPT(PC),A0
00000348                           803m     PRINT_STR A0,D3
00000348                           804m LOOP_22
00000348  0C10 0000                805m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                806m     BEQ EXIT_22
00000350                           807mm     PRINT_CHAR (A0)+,D3
00000350                           808mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      809mm     IFEQ DEBUG
00000350  1639 00C00003            810mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                811mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     812mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            813mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           814mm     ENDC
00000362                           815mm 
00000362                 FALSE     816mm     IFNE DEBUG
00000362                           817mm     ENDC
00000362                           818mm 
00000362                           819mm     ENDM
00000362  60E4                     820m     BRA LOOP_22
00000364                           821m EXIT_22
00000364                           822m     ENDM
00000364                           823  
00000364                           824  GET_INPUT
00000364                           825m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           826m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      827m     IFEQ DEBUG
00000364  1639 00C00003            828m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                829m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     830m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           831m     ENDC
00000370                           832m 
00000370                           833mm     READ_CHAR D2
00000370                 TRUE      834mm     IFEQ DEBUG
00000370  1439 00C00007            835mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           836mm     ENDC
00000376                 FALSE     837mm     IFNE DEBUG
00000376                           838mm     ENDC
00000376                           839mm 
00000376  B43C 001B                840mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                841mm     BEQ START
0000037E                           842mm     ENDM
0000037E                           843m 
0000037E                 TRUE      844m     IFEQ DEBUG
0000037E                           845mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           846mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      847mm     IFEQ DEBUG
0000037E  1639 00C00003            848mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                849mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     850mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            851mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           852mm     ENDC
00000390                           853mm 
00000390                 FALSE     854mm     IFNE DEBUG
00000390                           855mm     ENDC
00000390                           856mm 
00000390                           857mm     ENDM
00000390                           858m     ENDC
00000390                           859m     ENDM
00000390                           860  
00000390                           861      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                862s     CMP.B   #'0',D2
00000394  6D00 000E                863s     BLT _00000001
00000398  B43C 0039                864s     CMP.B   #'9',D2
0000039C  6E00 0006                865s     BGT _00000001
000003A0  6000 15BE                866          BRA HEX_DIGIT
000003A4                           867      ENDI
000003A4                           868s _00000001
000003A4                           869      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                870s     CMP.B   #'A',D2
000003A8  6D00 000E                871s     BLT _00000002
000003AC  B43C 0046                872s     CMP.B   #'F',D2
000003B0  6E00 0006                873s     BGT _00000002
000003B4  6000 15AA                874          BRA HEX_DIGIT
000003B8                           875      ENDI
000003B8                           876s _00000002
000003B8                           877  
000003B8  B43C 0077                878      CMP.B #'w',D2
000003BC  6700 01B2                879      BEQ W
000003C0                           880  
000003C0  B43C 006C                881      CMP.B #'l',D2
000003C4  6700 0A48                882      BEQ L 
000003C8                           883  
000003C8  B43C 0070                884      CMP.B #'p',D2
000003CC  6700 0D22                885      BEQ P
000003D0                           886  
000003D0                           887m     PRINT_CRLF D3,A0
000003D0  41FA 1965                888m     LEA CRLF(PC),A0
000003D4                           889mm     PRINT_STR A0,D3
000003D4                           890mm LOOP_28
000003D4  0C10 0000                891mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                892mm     BEQ EXIT_28
000003DC                           893mmm     PRINT_CHAR (A0)+,D3
000003DC                           894mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      895mmm     IFEQ DEBUG
000003DC  1639 00C00003            896mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                897mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     898mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            899mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           900mmm     ENDC
000003EE                           901mmm 
000003EE                 FALSE     902mmm     IFNE DEBUG
000003EE                           903mmm     ENDC
000003EE                           904mmm 
000003EE                           905mmm     ENDM
000003EE  60E4                     906mm     BRA LOOP_28
000003F0                           907mm EXIT_28
000003F0                           908mm     ENDM
000003F0                           909m     ENDM
000003F0                           910   
000003F0  B43C 003F                911      CMP.B #'?',D2
000003F4  6700 0076                912      BEQ H
000003F8                           913   
000003F8  B43C 0076                914      CMP.B #'v',D2
000003FC  6700 0076                915      BEQ V
00000400                           916      
00000400  B43C 0072                917      CMP.B #'r',D2
00000404  6700 0092                918      BEQ R
00000408                           919  
00000408  B43C 0073                920      CMP.B #'s',D2
0000040C  6700 01DC                921      BEQ S
00000410                           922  
00000410  B43C 0067                923      CMP.B #'g',D2
00000414  6700 0902                924      BEQ G   
00000418                           925  
00000418  B43C 007A                926      CMP.B #'z',D2
0000041C  6700 0900                927      BEQ Z   
00000420                           928  
00000420  B43C 0078                929      CMP.B #'x',D2
00000424  6700 0E9A                930      BEQ X
00000428                           931  
00000428  B43C 0069                932      CMP.B #'i',D2
0000042C  6700 0FAE                933      BEQ I
00000430                           934  
00000430  B43C 006F                935      CMP.B #'o',D2
00000434  6700 0FB6                936      BEQ O
00000438                           937  
00000438  B43C 0023                938      CMP.B #'#',D2
0000043C  6700 0FBE                939      BEQ HASH
00000440                           940  
00000440  B43C 0062                941      CMP.B #'b',D2
00000444  6700 0FCC                942      BEQ B
00000448                           943  
00000448  41FA 1850                944      LEA HUH(PC),A0
0000044C                           945m     PRINT_STR A0,D3
0000044C                           946m LOOP_30
0000044C  0C10 0000                947m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000450  6700 0016                948m     BEQ EXIT_30
00000454                           949mm     PRINT_CHAR (A0)+,D3
00000454                           950mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000454                 TRUE      951mm     IFEQ DEBUG
00000454  1639 00C00003            952mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000045A  0803 0002                953mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000045E  67F4                     954mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000460  13D8 00C00007            955mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000466                           956mm     ENDC
00000466                           957mm 
00000466                 FALSE     958mm     IFNE DEBUG
00000466                           959mm     ENDC
00000466                           960mm 
00000466                           961mm     ENDM
00000466  60E4                     962m     BRA LOOP_30
00000468                           963m EXIT_30
00000468                           964m     ENDM
00000468                           965  
00000468  6000 FEDA                966      BRA MAIN_LOOP
0000046C                           967  
0000046C                           968  ; commands
0000046C                           969  H
0000046C  41FA 16CD                970      LEA HELP(PC),A0
00000470  6000 0006                971      BRA PRINTIT
00000474                           972  
00000474                           973  V
00000474  41FA 195E                974      LEA VERSION(PC),A0
00000478                           975  PRINTIT
00000478                           976m     PRINT_STR A0,D3    
00000478                           977m LOOP_32
00000478  0C10 0000                978m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000047C  6700 0016                979m     BEQ EXIT_32
00000480                           980mm     PRINT_CHAR (A0)+,D3
00000480                           981mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000480                 TRUE      982mm     IFEQ DEBUG
00000480  1639 00C00003            983mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000486  0803 0002                984mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000048A  67F4                     985mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000048C  13D8 00C00007            986mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000492                           987mm     ENDC
00000492                           988mm 
00000492                 FALSE     989mm     IFNE DEBUG
00000492                           990mm     ENDC
00000492                           991mm 
00000492                           992mm     ENDM
00000492  60E4                     993m     BRA LOOP_32
00000494                           994m EXIT_32
00000494                           995m     ENDM
00000494  6000 FEAE                996      BRA MAIN_LOOP
00000498                           997  
00000498                           998  R
00000498  2047                     999      MOVE.L D7,A0                                    ; address accumulator -> address register
0000049A  7E00                    1000      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000049C  2410                    1001      MOVE.L (A0),D2                                  ; read the memory and print it
0000049E                          1002m     PRINT_REG D2,D3,D4,D5,A0
0000049E  41FA 189D               1003m     LEA OX(PC),A0
000004A2                          1004mm     PRINT_STR A0,D3
000004A2                          1005mm LOOP_35
000004A2  0C10 0000               1006mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004A6  6700 0016               1007mm     BEQ EXIT_35
000004AA                          1008mmm     PRINT_CHAR (A0)+,D3
000004AA                          1009mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AA                 TRUE     1010mmm     IFEQ DEBUG
000004AA  1639 00C00003           1011mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004B0  0803 0002               1012mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004B4  67F4                    1013mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004B6  13D8 00C00007           1014mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004BC                          1015mmm     ENDC
000004BC                          1016mmm 
000004BC                 FALSE    1017mmm     IFNE DEBUG
000004BC                          1018mmm     ENDC
000004BC                          1019mmm 
000004BC                          1020mmm     ENDM
000004BC  60E4                    1021mm     BRA LOOP_35
000004BE                          1022mm EXIT_35
000004BE                          1023mm     ENDM
000004BE  7A07                    1024m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004C0                          1025m LOOP_34
000004C0                          1026mm     BIN2HEX D2,D4,A0
000004C0  41FA 183A               1027mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004C4  E99A                    1028mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004C6  1802                    1029mm     MOVE.B D2,D4
000004C8  0284 0000000F           1030mm     ANDI.L #$F,D4
000004CE  1830 4000               1031mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004D2                          1032mm     ENDM
000004D2                          1033mm     PRINT_CHAR D4,D3
000004D2                          1034mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D2                 TRUE     1035mm     IFEQ DEBUG
000004D2  1639 00C00003           1036mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004D8  0803 0002               1037mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004DC  67F4                    1038mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004DE  13C4 00C00007           1039mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E4                          1040mm     ENDC
000004E4                          1041mm 
000004E4                 FALSE    1042mm     IFNE DEBUG
000004E4                          1043mm     ENDC
000004E4                          1044mm 
000004E4                          1045mm     ENDM
000004E4  57CD FFDA               1046m     DBEQ D5,LOOP_34
000004E8                          1047m     ENDM
000004E8                          1048      
000004E8                          1049m     PRINT_CHAR #32,D3
000004E8                          1050m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E8                 TRUE     1051m     IFEQ DEBUG
000004E8  1639 00C00003           1052m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EE  0803 0002               1053m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F2  67F4                    1054m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004F4  13FC 0020 00C00007      1055m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004FC                          1056m     ENDC
000004FC                          1057m 
000004FC                 FALSE    1058m     IFNE DEBUG
000004FC                          1059m     ENDC
000004FC                          1060m 
000004FC                          1061m     ENDM
000004FC                          1062  
000004FC  E19A                    1063      ROL.L #8,D2
000004FE                          1064m     PRINT_CHAR D2,D3
000004FE                          1065m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FE                 TRUE     1066m     IFEQ DEBUG
000004FE  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000504  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000508  67F4                    1069m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000050A  13C2 00C00007           1070m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000510                          1071m     ENDC
00000510                          1072m 
00000510                 FALSE    1073m     IFNE DEBUG
00000510                          1074m     ENDC
00000510                          1075m 
00000510                          1076m     ENDM
00000510  E19A                    1077      ROL.L #8,D2
00000512                          1078m     PRINT_CHAR D2,D3
00000512                          1079m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1080m     IFEQ DEBUG
00000512  1639 00C00003           1081m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1082m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1083m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1084m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1085m     ENDC
00000524                          1086m 
00000524                 FALSE    1087m     IFNE DEBUG
00000524                          1088m     ENDC
00000524                          1089m 
00000524                          1090m     ENDM
00000524  E19A                    1091      ROL.L #8,D2
00000526                          1092m     PRINT_CHAR D2,D3
00000526                          1093m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1094m     IFEQ DEBUG
00000526  1639 00C00003           1095m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1096m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1097m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1098m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1099m     ENDC
00000538                          1100m 
00000538                 FALSE    1101m     IFNE DEBUG
00000538                          1102m     ENDC
00000538                          1103m 
00000538                          1104m     ENDM
00000538  E19A                    1105      ROL.L #8,D2
0000053A                          1106m     PRINT_CHAR D2,D3
0000053A                          1107m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1108m     IFEQ DEBUG
0000053A  1639 00C00003           1109m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1110m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1111m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1112m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1113m     ENDC
0000054C                          1114m 
0000054C                 FALSE    1115m     IFNE DEBUG
0000054C                          1116m     ENDC
0000054C                          1117m 
0000054C                          1118m     ENDM
0000054C                          1119  
0000054C                          1120m     PRINT_CRLF D3,A0
0000054C  41FA 17E9               1121m     LEA CRLF(PC),A0
00000550                          1122mm     PRINT_STR A0,D3
00000550                          1123mm LOOP_45
00000550  0C10 0000               1124mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000554  6700 0016               1125mm     BEQ EXIT_45
00000558                          1126mmm     PRINT_CHAR (A0)+,D3
00000558                          1127mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000558                 TRUE     1128mmm     IFEQ DEBUG
00000558  1639 00C00003           1129mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000055E  0803 0002               1130mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000562  67F4                    1131mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000564  13D8 00C00007           1132mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000056A                          1133mmm     ENDC
0000056A                          1134mmm 
0000056A                 FALSE    1135mmm     IFNE DEBUG
0000056A                          1136mmm     ENDC
0000056A                          1137mmm 
0000056A                          1138mmm     ENDM
0000056A  60E4                    1139mm     BRA LOOP_45
0000056C                          1140mm EXIT_45
0000056C                          1141mm     ENDM
0000056C                          1142m     ENDM
0000056C                          1143      
0000056C  6000 FDD6               1144      BRA MAIN_LOOP
00000570                          1145  
00000570                          1146  W
00000570                          1147      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000570  3C3C 0000               1148s     MOVE.W  #0,D6
00000574  6000 0046               1149s     BRA _20000005
00000578                          1150s _20000004
00000578  E98D                    1151          LSL.L #4,D5                                     ; make what we have so far more significant
0000057A                          1152m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000057A                          1153m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000057A                 TRUE     1154m     IFEQ DEBUG
0000057A  1639 00C00003           1155m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000580  0803 0000               1156m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000584  67F4                    1157m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000586                          1158m     ENDC
00000586                          1159m 
00000586                          1160mm     READ_CHAR D2
00000586                 TRUE     1161mm     IFEQ DEBUG
00000586  1439 00C00007           1162mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000058C                          1163mm     ENDC
0000058C                 FALSE    1164mm     IFNE DEBUG
0000058C                          1165mm     ENDC
0000058C                          1166mm 
0000058C  B43C 001B               1167mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000590  6700 FB72               1168mm     BEQ START
00000594                          1169mm     ENDM
00000594                          1170m 
00000594                 TRUE     1171m     IFEQ DEBUG
00000594                          1172mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000594                          1173mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                 TRUE     1174mm     IFEQ DEBUG
00000594  1639 00C00003           1175mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000059A  0803 0002               1176mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000059E  67F4                    1177mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005A0  13C2 00C00007           1178mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A6                          1179mm     ENDC
000005A6                          1180mm 
000005A6                 FALSE    1181mm     IFNE DEBUG
000005A6                          1182mm     ENDC
000005A6                          1183mm 
000005A6                          1184mm     ENDM
000005A6                          1185m     ENDC
000005A6                          1186m     ENDM
000005A6                          1187m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005A6  41FA 1764               1188m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005AA  0402 0030               1189m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005AE  C4BC 000000FF           1190m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005B4  1430 2000               1191m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B8                          1192m     ENDM
000005B8  8A02                    1193          OR.B D2,D5
000005BA                          1194      ENDF
000005BA  5246                    1195s     ADD.W   #1,D6
000005BC                          1196s _20000005
000005BC  BC7C 0007               1197s     CMP.W   #7,D6
000005C0  6FB6                    1198s     BLE _20000004
000005C2                          1199  
000005C2                          1200m     PRINT_CRLF D3,A0
000005C2  41FA 1773               1201m     LEA CRLF(PC),A0
000005C6                          1202mm     PRINT_STR A0,D3
000005C6                          1203mm LOOP_52
000005C6  0C10 0000               1204mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005CA  6700 0016               1205mm     BEQ EXIT_52
000005CE                          1206mmm     PRINT_CHAR (A0)+,D3
000005CE                          1207mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                 TRUE     1208mmm     IFEQ DEBUG
000005CE  1639 00C00003           1209mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005D4  0803 0002               1210mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005D8  67F4                    1211mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005DA  13D8 00C00007           1212mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005E0                          1213mmm     ENDC
000005E0                          1214mmm 
000005E0                 FALSE    1215mmm     IFNE DEBUG
000005E0                          1216mmm     ENDC
000005E0                          1217mmm 
000005E0                          1218mmm     ENDM
000005E0  60E4                    1219mm     BRA LOOP_52
000005E2                          1220mm EXIT_52
000005E2                          1221mm     ENDM
000005E2                          1222m     ENDM
000005E2                          1223  
000005E2  2047                    1224      MOVE.L D7,A0                                    ; address accumulator -> address register
000005E4                          1225  
000005E4  2085                    1226      MOVE.L D5,(A0)                                  ; write the data
000005E6                          1227  
000005E6  6000 FD5C               1228      BRA MAIN_LOOP
000005EA                          1229  
000005EA                          1230  ; register map for S
000005EA                          1231  ; A0 - start address
000005EA                          1232  ; A1 - offset
000005EA                          1233  ; A2 - next address to write
000005EA                          1234  ; A3 - next location (jmp)
000005EA                          1235  ; A4 - Working Address Register
000005EA                          1236  ; D0 - record count
000005EA                          1237  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005EA                          1238  ; D2 - checksum
000005EA                          1239  ; D3 - data byte count
000005EA                          1240  ; D4 - read address, moved into A2
000005EA                          1241  ; D5 - temp
000005EA                          1242  ; D6 - temp
000005EA                          1243  ; D7 - temp
000005EA                          1244  S
000005EA  2078 0000               1245      MOVE.L 0,A0                                     ; start address -> A0
000005EE  2247                    1246      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005F0  7E00                    1247      MOVE.L #0,D7
000005F2  7000                    1248      MOVE.L #0,D0                                    ; count of records read -> D0
000005F4                          1249          
000005F4                          1250  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005F4                          1251m     DOWNLOAD D1
000005F4                          1252m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F4                          1253m 
000005F4  1239 00C00003           1254m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005FA  0801 0000               1255m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005FE  6700 0010               1256m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000602                          1257m 
00000602                          1258mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000602                 TRUE     1259mm     IFEQ DEBUG
00000602  1239 00C00007           1260mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000608                          1261mm     ENDC
00000608                 FALSE    1262mm     IFNE DEBUG
00000608                          1263mm     ENDC
00000608                          1264mm 
00000608  B23C 001B               1265mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000060C  6700 FAF6               1266mm     BEQ START
00000610                          1267mm     ENDM
00000610                          1268m CONTINUE_54
00000610  1239 00C00013           1269m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000616  0801 0000               1270m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061A  67D8                    1271m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
0000061C                          1272m     
0000061C  1239 00C00017           1273m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000622  13C1 00E00001           1274m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000628                          1275m 
00000628                          1276m     ENDM
00000628  B23C 0053               1277      CMP.B #'S',D1                                   ; found S?
0000062C  66C6                    1278      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000062E                          1279      
0000062E                          1280m     PRINT_CHAR #'S',D5                              ; print the S
0000062E                          1281m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                 TRUE     1282m     IFEQ DEBUG
0000062E  1A39 00C00003           1283m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000634  0805 0002               1284m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000638  67F4                    1285m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000063A  13FC 0053 00C00007      1286m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000642                          1287m     ENDC
00000642                          1288m 
00000642                 FALSE    1289m     IFNE DEBUG
00000642                          1290m     ENDC
00000642                          1291m 
00000642                          1292m     ENDM
00000642  5280                    1293      ADD.L #1,D0                                     ; read another S record, increment count
00000644                          1294      
00000644                          1295m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000644                          1296m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000644                          1297m 
00000644  1239 00C00003           1298m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000064A  0801 0000               1299m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000064E  6700 0010               1300m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000652                          1301m 
00000652                          1302mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000652                 TRUE     1303mm     IFEQ DEBUG
00000652  1239 00C00007           1304mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000658                          1305mm     ENDC
00000658                 FALSE    1306mm     IFNE DEBUG
00000658                          1307mm     ENDC
00000658                          1308mm 
00000658  B23C 001B               1309mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000065C  6700 FAA6               1310mm     BEQ START
00000660                          1311mm     ENDM
00000660                          1312m CONTINUE_57
00000660  1239 00C00013           1313m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000666  0801 0000               1314m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000066A  67D8                    1315m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000066C                          1316m     
0000066C  1239 00C00017           1317m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000672  13C1 00E00001           1318m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000678                          1319m 
00000678                          1320m     ENDM
00000678                          1321m     PRINT_CHAR D1,D5
00000678                          1322m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000678                 TRUE     1323m     IFEQ DEBUG
00000678  1A39 00C00003           1324m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000067E  0805 0002               1325m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000682  67F4                    1326m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000684  13C1 00C00007           1327m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000068A                          1328m     ENDC
0000068A                          1329m 
0000068A                 FALSE    1330m     IFNE DEBUG
0000068A                          1331m     ENDC
0000068A                          1332m 
0000068A                          1333m     ENDM
0000068A                          1334  
0000068A  7400                    1335      MOVE.L #0,D2                                    ; clear the checksum
0000068C                          1336  
0000068C                          1337m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000068C  1E3C 0002               1338m     MOVE.B #2,D7
00000690                          1339m     WHILE.B D7 <GT> 0 DO
00000690                          1340ms _10000000
00000690  BE38 0000               1341ms     CMP.B   0,D7
00000694  6F00 0062               1342ms     BLE _10000001
00000698  E98B                    1343m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000069A                          1344mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000069A                          1345mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069A                          1346mm 
0000069A  1A39 00C00003           1347mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006A0  0805 0000               1348mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006A4  6700 0010               1349mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
000006A8                          1350mm 
000006A8                          1351mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006A8                 TRUE     1352mmm     IFEQ DEBUG
000006A8  1A39 00C00007           1353mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006AE                          1354mmm     ENDC
000006AE                 FALSE    1355mmm     IFNE DEBUG
000006AE                          1356mmm     ENDC
000006AE                          1357mmm 
000006AE  BA3C 001B               1358mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006B2  6700 FA50               1359mmm     BEQ START
000006B6                          1360mmm     ENDM
000006B6                          1361mm CONTINUE_61
000006B6  1A39 00C00013           1362mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006BC  0805 0000               1363mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C0  67D8                    1364mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000006C2                          1365mm     
000006C2  1A39 00C00017           1366mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006C8  13C5 00E00001           1367mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006CE                          1368mm 
000006CE                          1369mm     ENDM
000006CE                          1370mm         PRINT_CHAR D5,D6
000006CE                          1371mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006CE                 TRUE     1372mm     IFEQ DEBUG
000006CE  1C39 00C00003           1373mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006D4  0806 0002               1374mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006D8  67F4                    1375mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006DA  13C5 00C00007           1376mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006E0                          1377mm     ENDC
000006E0                          1378mm 
000006E0                 FALSE    1379mm     IFNE DEBUG
000006E0                          1380mm     ENDC
000006E0                          1381mm 
000006E0                          1382mm     ENDM
000006E0                          1383mm         HEX2BIN D5,D5,A4
000006E0  49FA 162A               1384mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006E4  0405 0030               1385mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006E8  CABC 000000FF           1386mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006EE  1A34 5000               1387mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006F2                          1388mm     ENDM
000006F2  8605                    1389m         OR.B D5,D3
000006F4  5307                    1390m         SUB.B #1,D7
000006F6                          1391m     ENDW
000006F6  6098                    1392ms     BRA _10000000
000006F8                          1393ms _10000001
000006F8                          1394m 
000006F8  7A00                    1395m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006FA  1A03                    1396m     MOVE.B D3,D5
000006FC  D483                    1397m     ADD.L D3,D2
000006FE                          1398m 
000006FE                          1399m     ENDM
000006FE                          1400  
000006FE                          1401      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006FE  B23C 0030               1402s     CMP.B   #'0',D1
00000702  6600 002A               1403s     BNE.L   _00000003
00000706                          1404m         PRINT_CRLF D5,A4
00000706  49FA 162F               1405m     LEA CRLF(PC),A4
0000070A                          1406mm     PRINT_STR A4,D5
0000070A                          1407mm LOOP_66
0000070A  0C14 0000               1408mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000070E  6700 0016               1409mm     BEQ EXIT_66
00000712                          1410mmm     PRINT_CHAR (A4)+,D5
00000712                          1411mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                 TRUE     1412mmm     IFEQ DEBUG
00000712  1A39 00C00003           1413mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000718  0805 0002               1414mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000071C  67F4                    1415mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
0000071E  13DC 00C00007           1416mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000724                          1417mmm     ENDC
00000724                          1418mmm 
00000724                 FALSE    1419mmm     IFNE DEBUG
00000724                          1420mmm     ENDC
00000724                          1421mmm 
00000724                          1422mmm     ENDM
00000724  60E4                    1423mm     BRA LOOP_66
00000726                          1424mm EXIT_66
00000726                          1425mm     ENDM
00000726                          1426m     ENDM
00000726  6000 FECC               1427          BRA WAIT_FOR_SRECORD
0000072A                          1428      ELSE
0000072A  6000 03DE               1429s     BRA _00000004
0000072E                          1430s _00000003
0000072E                          1431          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
0000072E  B23C 0031               1432s     CMP.B   #'1',D1
00000732  6708                    1433s     BEQ.S   _00000005
00000734  B23C 0032               1434s     CMP.B   #'2',D1
00000738  6600 01F0               1435s     BNE.L   _00000006
0000073C                          1436s _00000005
0000073C  5783                    1437              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000073E                          1438  
0000073E  7800                    1439              MOVE.L #0,D4                            ; read two bytes of address
00000740                          1440m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000740  1E3C 0002               1441m     MOVE.B #2,D7
00000744                          1442m     WHILE.B D7 <GT> 0 DO
00000744                          1443ms _10000002
00000744  BE38 0000               1444ms     CMP.B   0,D7
00000748  6F00 0062               1445ms     BLE _10000003
0000074C  E98C                    1446m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000074E                          1447mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000074E                          1448mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000074E                          1449mm 
0000074E  1A39 00C00003           1450mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000754  0805 0000               1451mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000758  6700 0010               1452mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
0000075C                          1453mm 
0000075C                          1454mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075C                 TRUE     1455mmm     IFEQ DEBUG
0000075C  1A39 00C00007           1456mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000762                          1457mmm     ENDC
00000762                 FALSE    1458mmm     IFNE DEBUG
00000762                          1459mmm     ENDC
00000762                          1460mmm 
00000762  BA3C 001B               1461mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000766  6700 F99C               1462mmm     BEQ START
0000076A                          1463mmm     ENDM
0000076A                          1464mm CONTINUE_69
0000076A  1A39 00C00013           1465mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000770  0805 0000               1466mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000774  67D8                    1467mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000776                          1468mm     
00000776  1A39 00C00017           1469mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000077C  13C5 00E00001           1470mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000782                          1471mm 
00000782                          1472mm     ENDM
00000782                          1473mm         PRINT_CHAR D5,D6
00000782                          1474mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000782                 TRUE     1475mm     IFEQ DEBUG
00000782  1C39 00C00003           1476mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000788  0806 0002               1477mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000078C  67F4                    1478mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000078E  13C5 00C00007           1479mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000794                          1480mm     ENDC
00000794                          1481mm 
00000794                 FALSE    1482mm     IFNE DEBUG
00000794                          1483mm     ENDC
00000794                          1484mm 
00000794                          1485mm     ENDM
00000794                          1486mm         HEX2BIN D5,D5,A4
00000794  49FA 1576               1487mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000798  0405 0030               1488mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000079C  CABC 000000FF           1489mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007A2  1A34 5000               1490mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007A6                          1491mm     ENDM
000007A6  8805                    1492m         OR.B D5,D4
000007A8  5307                    1493m         SUB.B #1,D7
000007AA                          1494m     ENDW
000007AA  6098                    1495ms     BRA _10000002
000007AC                          1496ms _10000003
000007AC                          1497m 
000007AC  7A00                    1498m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007AE  1A04                    1499m     MOVE.B D4,D5
000007B0  D484                    1500m     ADD.L D4,D2
000007B2                          1501m 
000007B2                          1502m     ENDM
000007B2                          1503m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000007B2  1E3C 0002               1504m     MOVE.B #2,D7
000007B6                          1505m     WHILE.B D7 <GT> 0 DO
000007B6                          1506ms _10000004
000007B6  BE38 0000               1507ms     CMP.B   0,D7
000007BA  6F00 0062               1508ms     BLE _10000005
000007BE  E98C                    1509m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007C0                          1510mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007C0                          1511mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C0                          1512mm 
000007C0  1A39 00C00003           1513mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007C6  0805 0000               1514mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CA  6700 0010               1515mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
000007CE                          1516mm 
000007CE                          1517mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007CE                 TRUE     1518mmm     IFEQ DEBUG
000007CE  1A39 00C00007           1519mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007D4                          1520mmm     ENDC
000007D4                 FALSE    1521mmm     IFNE DEBUG
000007D4                          1522mmm     ENDC
000007D4                          1523mmm 
000007D4  BA3C 001B               1524mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007D8  6700 F92A               1525mmm     BEQ START
000007DC                          1526mmm     ENDM
000007DC                          1527mm CONTINUE_74
000007DC  1A39 00C00013           1528mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E2  0805 0000               1529mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E6  67D8                    1530mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000007E8                          1531mm     
000007E8  1A39 00C00017           1532mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007EE  13C5 00E00001           1533mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007F4                          1534mm 
000007F4                          1535mm     ENDM
000007F4                          1536mm         PRINT_CHAR D5,D6
000007F4                          1537mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F4                 TRUE     1538mm     IFEQ DEBUG
000007F4  1C39 00C00003           1539mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007FA  0806 0002               1540mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007FE  67F4                    1541mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
00000800  13C5 00C00007           1542mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000806                          1543mm     ENDC
00000806                          1544mm 
00000806                 FALSE    1545mm     IFNE DEBUG
00000806                          1546mm     ENDC
00000806                          1547mm 
00000806                          1548mm     ENDM
00000806                          1549mm         HEX2BIN D5,D5,A4
00000806  49FA 1504               1550mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000080A  0405 0030               1551mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000080E  CABC 000000FF           1552mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000814  1A34 5000               1553mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000818                          1554mm     ENDM
00000818  8805                    1555m         OR.B D5,D4
0000081A  5307                    1556m         SUB.B #1,D7
0000081C                          1557m     ENDW
0000081C  6098                    1558ms     BRA _10000004
0000081E                          1559ms _10000005
0000081E                          1560m 
0000081E  7A00                    1561m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000820  1A04                    1562m     MOVE.B D4,D5
00000822  D484                    1563m     ADD.L D4,D2
00000824                          1564m 
00000824                          1565m     ENDM
00000824                          1566  
00000824                          1567              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000824  B23C 0032               1568s     CMP.B   #'2',D1
00000828  6600 0076               1569s     BNE.L   _00000007
0000082C  5383                    1570                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000082E                          1571m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000082E  1E3C 0002               1572m     MOVE.B #2,D7
00000832                          1573m     WHILE.B D7 <GT> 0 DO
00000832                          1574ms _10000006
00000832  BE38 0000               1575ms     CMP.B   0,D7
00000836  6F00 0062               1576ms     BLE _10000007
0000083A  E98C                    1577m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000083C                          1578mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000083C                          1579mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083C                          1580mm 
0000083C  1A39 00C00003           1581mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000842  0805 0000               1582mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000846  6700 0010               1583mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000084A                          1584mm 
0000084A                          1585mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                 TRUE     1586mmm     IFEQ DEBUG
0000084A  1A39 00C00007           1587mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000850                          1588mmm     ENDC
00000850                 FALSE    1589mmm     IFNE DEBUG
00000850                          1590mmm     ENDC
00000850                          1591mmm 
00000850  BA3C 001B               1592mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000854  6700 F8AE               1593mmm     BEQ START
00000858                          1594mmm     ENDM
00000858                          1595mm CONTINUE_79
00000858  1A39 00C00013           1596mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000085E  0805 0000               1597mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000862  67D8                    1598mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000864                          1599mm     
00000864  1A39 00C00017           1600mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000086A  13C5 00E00001           1601mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000870                          1602mm 
00000870                          1603mm     ENDM
00000870                          1604mm         PRINT_CHAR D5,D6
00000870                          1605mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1606mm     IFEQ DEBUG
00000870  1C39 00C00003           1607mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000876  0806 0002               1608mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1609mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
0000087C  13C5 00C00007           1610mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000882                          1611mm     ENDC
00000882                          1612mm 
00000882                 FALSE    1613mm     IFNE DEBUG
00000882                          1614mm     ENDC
00000882                          1615mm 
00000882                          1616mm     ENDM
00000882                          1617mm         HEX2BIN D5,D5,A4
00000882  49FA 1488               1618mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000886  0405 0030               1619mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000088A  CABC 000000FF           1620mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000890  1A34 5000               1621mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000894                          1622mm     ENDM
00000894  8805                    1623m         OR.B D5,D4
00000896  5307                    1624m         SUB.B #1,D7
00000898                          1625m     ENDW
00000898  6098                    1626ms     BRA _10000006
0000089A                          1627ms _10000007
0000089A                          1628m 
0000089A  7A00                    1629m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000089C  1A04                    1630m     MOVE.B D4,D5
0000089E  D484                    1631m     ADD.L D4,D2
000008A0                          1632m 
000008A0                          1633m     ENDM
000008A0                          1634              ENDI
000008A0                          1635s _00000007
000008A0                          1636  
000008A0  2444                    1637              MOVE.L D4,A2                            ; put the address in an address register
000008A2  D5C9                    1638              ADD.L A1,A2                             ; add in the offset
000008A4                          1639  
000008A4                          1640              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000008A4                          1641s _10000008
000008A4  B63C 0000               1642s     CMP.B   #0,D3
000008A8  6F00 007A               1643s     BLE _10000009
000008AC                          1644m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000008AC  1E3C 0002               1645m     MOVE.B #2,D7
000008B0                          1646m     WHILE.B D7 <GT> 0 DO
000008B0                          1647ms _1000000A
000008B0  BE38 0000               1648ms     CMP.B   0,D7
000008B4  6F00 0062               1649ms     BLE _1000000B
000008B8  E989                    1650m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000008BA                          1651mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008BA                          1652mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BA                          1653mm 
000008BA  1A39 00C00003           1654mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008C0  0805 0000               1655mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C4  6700 0010               1656mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
000008C8                          1657mm 
000008C8                          1658mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008C8                 TRUE     1659mmm     IFEQ DEBUG
000008C8  1A39 00C00007           1660mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008CE                          1661mmm     ENDC
000008CE                 FALSE    1662mmm     IFNE DEBUG
000008CE                          1663mmm     ENDC
000008CE                          1664mmm 
000008CE  BA3C 001B               1665mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008D2  6700 F830               1666mmm     BEQ START
000008D6                          1667mmm     ENDM
000008D6                          1668mm CONTINUE_84
000008D6  1A39 00C00013           1669mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DC  0805 0000               1670mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E0  67D8                    1671mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000008E2                          1672mm     
000008E2  1A39 00C00017           1673mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008E8  13C5 00E00001           1674mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008EE                          1675mm 
000008EE                          1676mm     ENDM
000008EE                          1677mm         PRINT_CHAR D5,D6
000008EE                          1678mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EE                 TRUE     1679mm     IFEQ DEBUG
000008EE  1C39 00C00003           1680mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008F4  0806 0002               1681mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008F8  67F4                    1682mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
000008FA  13C5 00C00007           1683mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000900                          1684mm     ENDC
00000900                          1685mm 
00000900                 FALSE    1686mm     IFNE DEBUG
00000900                          1687mm     ENDC
00000900                          1688mm 
00000900                          1689mm     ENDM
00000900                          1690mm         HEX2BIN D5,D5,A4
00000900  49FA 140A               1691mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000904  0405 0030               1692mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000908  CABC 000000FF           1693mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000090E  1A34 5000               1694mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000912                          1695mm     ENDM
00000912  8205                    1696m         OR.B D5,D1
00000914  5307                    1697m         SUB.B #1,D7
00000916                          1698m     ENDW
00000916  6098                    1699ms     BRA _1000000A
00000918                          1700ms _1000000B
00000918                          1701m 
00000918  7A00                    1702m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000091A  1A01                    1703m     MOVE.B D1,D5
0000091C  D481                    1704m     ADD.L D1,D2
0000091E                          1705m 
0000091E                          1706m     ENDM
0000091E                          1707   
0000091E  14C1                    1708                  MOVE.B D1,(A2)+                     ; store it!
00000920                          1709  
00000920  5303                    1710                  SUB.B #1,D3                         ; 1 less byte to go
00000922                          1711              ENDW
00000922  6080                    1712s     BRA _10000008
00000924                          1713s _10000009
00000924                          1714  
00000924  7200                    1715              MOVE.L #0,D1                            ; not done yet
00000926                          1716          ELSE
00000926  6000 01E2               1717s     BRA _00000008
0000092A                          1718s _00000006
0000092A                          1719              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
0000092A  B23C 0038               1720s     CMP.B   #'8',D1
0000092E  6600 0164               1721s     BNE.L   _00000009
00000932  7800                    1722                  MOVE.L #0,D4                        ; read the 24 bit start address
00000934                          1723m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000934  1E3C 0002               1724m     MOVE.B #2,D7
00000938                          1725m     WHILE.B D7 <GT> 0 DO
00000938                          1726ms _1000000C
00000938  BE38 0000               1727ms     CMP.B   0,D7
0000093C  6F00 0062               1728ms     BLE _1000000D
00000940  E98C                    1729m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000942                          1730mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000942                          1731mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000942                          1732mm 
00000942  1A39 00C00003           1733mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000948  0805 0000               1734mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000094C  6700 0010               1735mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000950                          1736mm 
00000950                          1737mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000950                 TRUE     1738mmm     IFEQ DEBUG
00000950  1A39 00C00007           1739mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000956                          1740mmm     ENDC
00000956                 FALSE    1741mmm     IFNE DEBUG
00000956                          1742mmm     ENDC
00000956                          1743mmm 
00000956  BA3C 001B               1744mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000095A  6700 F7A8               1745mmm     BEQ START
0000095E                          1746mmm     ENDM
0000095E                          1747mm CONTINUE_89
0000095E  1A39 00C00013           1748mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000964  0805 0000               1749mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000968  67D8                    1750mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
0000096A                          1751mm     
0000096A  1A39 00C00017           1752mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000970  13C5 00E00001           1753mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000976                          1754mm 
00000976                          1755mm     ENDM
00000976                          1756mm         PRINT_CHAR D5,D6
00000976                          1757mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000976                 TRUE     1758mm     IFEQ DEBUG
00000976  1C39 00C00003           1759mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000097C  0806 0002               1760mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000980  67F4                    1761mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000982  13C5 00C00007           1762mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000988                          1763mm     ENDC
00000988                          1764mm 
00000988                 FALSE    1765mm     IFNE DEBUG
00000988                          1766mm     ENDC
00000988                          1767mm 
00000988                          1768mm     ENDM
00000988                          1769mm         HEX2BIN D5,D5,A4
00000988  49FA 1382               1770mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000098C  0405 0030               1771mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000990  CABC 000000FF           1772mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000996  1A34 5000               1773mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000099A                          1774mm     ENDM
0000099A  8805                    1775m         OR.B D5,D4
0000099C  5307                    1776m         SUB.B #1,D7
0000099E                          1777m     ENDW
0000099E  6098                    1778ms     BRA _1000000C
000009A0                          1779ms _1000000D
000009A0                          1780m 
000009A0  7A00                    1781m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009A2  1A04                    1782m     MOVE.B D4,D5
000009A4  D484                    1783m     ADD.L D4,D2
000009A6                          1784m 
000009A6                          1785m     ENDM
000009A6                          1786m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000009A6  1E3C 0002               1787m     MOVE.B #2,D7
000009AA                          1788m     WHILE.B D7 <GT> 0 DO
000009AA                          1789ms _1000000E
000009AA  BE38 0000               1790ms     CMP.B   0,D7
000009AE  6F00 0062               1791ms     BLE _1000000F
000009B2  E98C                    1792m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B4                          1793mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B4                          1794mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B4                          1795mm 
000009B4  1A39 00C00003           1796mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009BA  0805 0000               1797mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009BE  6700 0010               1798mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
000009C2                          1799mm 
000009C2                          1800mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C2                 TRUE     1801mmm     IFEQ DEBUG
000009C2  1A39 00C00007           1802mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C8                          1803mmm     ENDC
000009C8                 FALSE    1804mmm     IFNE DEBUG
000009C8                          1805mmm     ENDC
000009C8                          1806mmm 
000009C8  BA3C 001B               1807mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CC  6700 F736               1808mmm     BEQ START
000009D0                          1809mmm     ENDM
000009D0                          1810mm CONTINUE_94
000009D0  1A39 00C00013           1811mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D6  0805 0000               1812mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009DA  67D8                    1813mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
000009DC                          1814mm     
000009DC  1A39 00C00017           1815mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E2  13C5 00E00001           1816mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E8                          1817mm 
000009E8                          1818mm     ENDM
000009E8                          1819mm         PRINT_CHAR D5,D6
000009E8                          1820mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E8                 TRUE     1821mm     IFEQ DEBUG
000009E8  1C39 00C00003           1822mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009EE  0806 0002               1823mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F2  67F4                    1824mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000009F4  13C5 00C00007           1825mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009FA                          1826mm     ENDC
000009FA                          1827mm 
000009FA                 FALSE    1828mm     IFNE DEBUG
000009FA                          1829mm     ENDC
000009FA                          1830mm 
000009FA                          1831mm     ENDM
000009FA                          1832mm         HEX2BIN D5,D5,A4
000009FA  49FA 1310               1833mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009FE  0405 0030               1834mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A02  CABC 000000FF           1835mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A08  1A34 5000               1836mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0C                          1837mm     ENDM
00000A0C  8805                    1838m         OR.B D5,D4
00000A0E  5307                    1839m         SUB.B #1,D7
00000A10                          1840m     ENDW
00000A10  6098                    1841ms     BRA _1000000E
00000A12                          1842ms _1000000F
00000A12                          1843m 
00000A12  7A00                    1844m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A14  1A04                    1845m     MOVE.B D4,D5
00000A16  D484                    1846m     ADD.L D4,D2
00000A18                          1847m 
00000A18                          1848m     ENDM
00000A18                          1849m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000A18  1E3C 0002               1850m     MOVE.B #2,D7
00000A1C                          1851m     WHILE.B D7 <GT> 0 DO
00000A1C                          1852ms _10000010
00000A1C  BE38 0000               1853ms     CMP.B   0,D7
00000A20  6F00 0062               1854ms     BLE _10000011
00000A24  E98C                    1855m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A26                          1856mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A26                          1857mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                          1858mm 
00000A26  1A39 00C00003           1859mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A2C  0805 0000               1860mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A30  6700 0010               1861mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000A34                          1862mm 
00000A34                          1863mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A34                 TRUE     1864mmm     IFEQ DEBUG
00000A34  1A39 00C00007           1865mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A3A                          1866mmm     ENDC
00000A3A                 FALSE    1867mmm     IFNE DEBUG
00000A3A                          1868mmm     ENDC
00000A3A                          1869mmm 
00000A3A  BA3C 001B               1870mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A3E  6700 F6C4               1871mmm     BEQ START
00000A42                          1872mmm     ENDM
00000A42                          1873mm CONTINUE_99
00000A42  1A39 00C00013           1874mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A48  0805 0000               1875mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A4C  67D8                    1876mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000A4E                          1877mm     
00000A4E  1A39 00C00017           1878mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A54  13C5 00E00001           1879mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A5A                          1880mm 
00000A5A                          1881mm     ENDM
00000A5A                          1882mm         PRINT_CHAR D5,D6
00000A5A                          1883mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5A                 TRUE     1884mm     IFEQ DEBUG
00000A5A  1C39 00C00003           1885mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A60  0806 0002               1886mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A64  67F4                    1887mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000A66  13C5 00C00007           1888mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A6C                          1889mm     ENDC
00000A6C                          1890mm 
00000A6C                 FALSE    1891mm     IFNE DEBUG
00000A6C                          1892mm     ENDC
00000A6C                          1893mm 
00000A6C                          1894mm     ENDM
00000A6C                          1895mm         HEX2BIN D5,D5,A4
00000A6C  49FA 129E               1896mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A70  0405 0030               1897mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A74  CABC 000000FF           1898mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A7A  1A34 5000               1899mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A7E                          1900mm     ENDM
00000A7E  8805                    1901m         OR.B D5,D4
00000A80  5307                    1902m         SUB.B #1,D7
00000A82                          1903m     ENDW
00000A82  6098                    1904ms     BRA _10000010
00000A84                          1905ms _10000011
00000A84                          1906m 
00000A84  7A00                    1907m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A86  1A04                    1908m     MOVE.B D4,D5
00000A88  D484                    1909m     ADD.L D4,D2
00000A8A                          1910m 
00000A8A                          1911m     ENDM
00000A8A                          1912  
00000A8A  2044                    1913                  MOVE.L D4,A0                        ; start address -> A0
00000A8C  D1C9                    1914                  ADD.L A1,A0                         ; add in the offset
00000A8E                          1915  
00000A8E  72FF                    1916                  MOVE.L #$FFFFFFFF,D1                ; done
00000A90                          1917              ELSE
00000A90  6000 0078               1918s     BRA _0000000A
00000A94                          1919s _00000009
00000A94                          1920m                 PRINT_CRLF D5,A4
00000A94  49FA 12A1               1921m     LEA CRLF(PC),A4
00000A98                          1922mm     PRINT_STR A4,D5
00000A98                          1923mm LOOP_104
00000A98  0C14 0000               1924mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A9C  6700 0016               1925mm     BEQ EXIT_104
00000AA0                          1926mmm     PRINT_CHAR (A4)+,D5
00000AA0                          1927mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA0                 TRUE     1928mmm     IFEQ DEBUG
00000AA0  1A39 00C00003           1929mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA6  0805 0002               1930mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAA  67F4                    1931mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000AAC  13DC 00C00007           1932mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AB2                          1933mmm     ENDC
00000AB2                          1934mmm 
00000AB2                 FALSE    1935mmm     IFNE DEBUG
00000AB2                          1936mmm     ENDC
00000AB2                          1937mmm 
00000AB2                          1938mmm     ENDM
00000AB2  60E4                    1939mm     BRA LOOP_104
00000AB4                          1940mm EXIT_104
00000AB4                          1941mm     ENDM
00000AB4                          1942m     ENDM
00000AB4                          1943  
00000AB4  49FA 120D               1944                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000AB8                          1945m                 PRINT_STR A4,D5
00000AB8                          1946m LOOP_106
00000AB8  0C14 0000               1947m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ABC  6700 0016               1948m     BEQ EXIT_106
00000AC0                          1949mm     PRINT_CHAR (A4)+,D5
00000AC0                          1950mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC0                 TRUE     1951mm     IFEQ DEBUG
00000AC0  1A39 00C00003           1952mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC6  0805 0002               1953mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACA  67F4                    1954mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000ACC  13DC 00C00007           1955mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD2                          1956mm     ENDC
00000AD2                          1957mm 
00000AD2                 FALSE    1958mm     IFNE DEBUG
00000AD2                          1959mm     ENDC
00000AD2                          1960mm 
00000AD2                          1961mm     ENDM
00000AD2  60E4                    1962m     BRA LOOP_106
00000AD4                          1963m EXIT_106
00000AD4                          1964m     ENDM
00000AD4                          1965m                 PRINT_CHAR D1,D5
00000AD4                          1966m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD4                 TRUE     1967m     IFEQ DEBUG
00000AD4  1A39 00C00003           1968m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ADA  0805 0002               1969m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ADE  67F4                    1970m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AE0  13C1 00C00007           1971m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AE6                          1972m     ENDC
00000AE6                          1973m 
00000AE6                 FALSE    1974m     IFNE DEBUG
00000AE6                          1975m     ENDC
00000AE6                          1976m 
00000AE6                          1977m     ENDM
00000AE6                          1978m                 PRINT_CRLF D5,A4
00000AE6  49FA 124F               1979m     LEA CRLF(PC),A4
00000AEA                          1980mm     PRINT_STR A4,D5
00000AEA                          1981mm LOOP_110
00000AEA  0C14 0000               1982mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AEE  6700 0016               1983mm     BEQ EXIT_110
00000AF2                          1984mmm     PRINT_CHAR (A4)+,D5
00000AF2                          1985mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF2                 TRUE     1986mmm     IFEQ DEBUG
00000AF2  1A39 00C00003           1987mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF8  0805 0002               1988mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFC  67F4                    1989mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000AFE  13DC 00C00007           1990mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B04                          1991mmm     ENDC
00000B04                          1992mmm 
00000B04                 FALSE    1993mmm     IFNE DEBUG
00000B04                          1994mmm     ENDC
00000B04                          1995mmm 
00000B04                          1996mmm     ENDM
00000B04  60E4                    1997mm     BRA LOOP_110
00000B06                          1998mm EXIT_110
00000B06                          1999mm     ENDM
00000B06                          2000m     ENDM
00000B06                          2001  
00000B06  6000 FAEC               2002                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000B0A                          2003              ENDI
00000B0A                          2004s _0000000A
00000B0A                          2005          ENDI
00000B0A                          2006s _00000008
00000B0A                          2007      ENDI
00000B0A                          2008s _00000004
00000B0A                          2009  
00000B0A                          2010m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000B0A  1E3C 0002               2011m     MOVE.B #2,D7
00000B0E                          2012m     WHILE.B D7 <GT> 0 DO
00000B0E                          2013ms _10000012
00000B0E  BE38 0000               2014ms     CMP.B   0,D7
00000B12  6F00 0062               2015ms     BLE _10000013
00000B16  E98C                    2016m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B18                          2017mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B18                          2018mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B18                          2019mm 
00000B18  1A39 00C00003           2020mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B1E  0805 0000               2021mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B22  6700 0010               2022mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000B26                          2023mm 
00000B26                          2024mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B26                 TRUE     2025mmm     IFEQ DEBUG
00000B26  1A39 00C00007           2026mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B2C                          2027mmm     ENDC
00000B2C                 FALSE    2028mmm     IFNE DEBUG
00000B2C                          2029mmm     ENDC
00000B2C                          2030mmm 
00000B2C  BA3C 001B               2031mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B30  6700 F5D2               2032mmm     BEQ START
00000B34                          2033mmm     ENDM
00000B34                          2034mm CONTINUE_113
00000B34  1A39 00C00013           2035mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B3A  0805 0000               2036mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B3E  67D8                    2037mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000B40                          2038mm     
00000B40  1A39 00C00017           2039mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B46  13C5 00E00001           2040mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B4C                          2041mm 
00000B4C                          2042mm     ENDM
00000B4C                          2043mm         PRINT_CHAR D5,D6
00000B4C                          2044mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4C                 TRUE     2045mm     IFEQ DEBUG
00000B4C  1C39 00C00003           2046mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B52  0806 0002               2047mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B56  67F4                    2048mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B58  13C5 00C00007           2049mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B5E                          2050mm     ENDC
00000B5E                          2051mm 
00000B5E                 FALSE    2052mm     IFNE DEBUG
00000B5E                          2053mm     ENDC
00000B5E                          2054mm 
00000B5E                          2055mm     ENDM
00000B5E                          2056mm         HEX2BIN D5,D5,A4
00000B5E  49FA 11AC               2057mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B62  0405 0030               2058mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B66  CABC 000000FF           2059mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B6C  1A34 5000               2060mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B70                          2061mm     ENDM
00000B70  8805                    2062m         OR.B D5,D4
00000B72  5307                    2063m         SUB.B #1,D7
00000B74                          2064m     ENDW
00000B74  6098                    2065ms     BRA _10000012
00000B76                          2066ms _10000013
00000B76                          2067m 
00000B76  7A00                    2068m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B78  1A04                    2069m     MOVE.B D4,D5
00000B7A  D484                    2070m     ADD.L D4,D2
00000B7C                          2071m 
00000B7C                          2072m     ENDM
00000B7C                          2073m     PRINT_CRLF D5,A4
00000B7C  49FA 11B9               2074m     LEA CRLF(PC),A4
00000B80                          2075mm     PRINT_STR A4,D5
00000B80                          2076mm LOOP_118
00000B80  0C14 0000               2077mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B84  6700 0016               2078mm     BEQ EXIT_118
00000B88                          2079mmm     PRINT_CHAR (A4)+,D5
00000B88                          2080mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2081mmm     IFEQ DEBUG
00000B88  1A39 00C00003           2082mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B8E  0805 0002               2083mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2084mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B94  13DC 00C00007           2085mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9A                          2086mmm     ENDC
00000B9A                          2087mmm 
00000B9A                 FALSE    2088mmm     IFNE DEBUG
00000B9A                          2089mmm     ENDC
00000B9A                          2090mmm 
00000B9A                          2091mmm     ENDM
00000B9A  60E4                    2092mm     BRA LOOP_118
00000B9C                          2093mm EXIT_118
00000B9C                          2094mm     ENDM
00000B9C                          2095m     ENDM
00000B9C                          2096  
00000B9C                          2097      IF.B D2 <NE> #$FF THEN.L
00000B9C  B43C 00FF               2098s     CMP.B   #$FF,D2
00000BA0  6700 0090               2099s     BEQ.L   _0000000B
00000BA4  49FA 1134               2100          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000BA8                          2101m         PRINT_STR A4,D5
00000BA8                          2102m LOOP_120
00000BA8  0C14 0000               2103m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BAC  6700 0016               2104m     BEQ EXIT_120
00000BB0                          2105mm     PRINT_CHAR (A4)+,D5
00000BB0                          2106mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB0                 TRUE     2107mm     IFEQ DEBUG
00000BB0  1A39 00C00003           2108mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BB6  0805 0002               2109mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BBA  67F4                    2110mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000BBC  13DC 00C00007           2111mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BC2                          2112mm     ENDC
00000BC2                          2113mm 
00000BC2                 FALSE    2114mm     IFNE DEBUG
00000BC2                          2115mm     ENDC
00000BC2                          2116mm 
00000BC2                          2117mm     ENDM
00000BC2  60E4                    2118m     BRA LOOP_120
00000BC4                          2119m EXIT_120
00000BC4                          2120m     ENDM
00000BC4                          2121m         PRINT_REG D0,D5,D3,D6,A4
00000BC4  49FA 1177               2122m     LEA OX(PC),A4
00000BC8                          2123mm     PRINT_STR A4,D5
00000BC8                          2124mm LOOP_123
00000BC8  0C14 0000               2125mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BCC  6700 0016               2126mm     BEQ EXIT_123
00000BD0                          2127mmm     PRINT_CHAR (A4)+,D5
00000BD0                          2128mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                 TRUE     2129mmm     IFEQ DEBUG
00000BD0  1A39 00C00003           2130mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD6  0805 0002               2131mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BDA  67F4                    2132mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BDC  13DC 00C00007           2133mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BE2                          2134mmm     ENDC
00000BE2                          2135mmm 
00000BE2                 FALSE    2136mmm     IFNE DEBUG
00000BE2                          2137mmm     ENDC
00000BE2                          2138mmm 
00000BE2                          2139mmm     ENDM
00000BE2  60E4                    2140mm     BRA LOOP_123
00000BE4                          2141mm EXIT_123
00000BE4                          2142mm     ENDM
00000BE4  7C07                    2143m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BE6                          2144m LOOP_122
00000BE6                          2145mm     BIN2HEX D0,D3,A4
00000BE6  49FA 1114               2146mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000BEA  E998                    2147mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BEC  1600                    2148mm     MOVE.B D0,D3
00000BEE  0283 0000000F           2149mm     ANDI.L #$F,D3
00000BF4  1634 3000               2150mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000BF8                          2151mm     ENDM
00000BF8                          2152mm     PRINT_CHAR D3,D5
00000BF8                          2153mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF8                 TRUE     2154mm     IFEQ DEBUG
00000BF8  1A39 00C00003           2155mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BFE  0805 0002               2156mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C02  67F4                    2157mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000C04  13C3 00C00007           2158mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C0A                          2159mm     ENDC
00000C0A                          2160mm 
00000C0A                 FALSE    2161mm     IFNE DEBUG
00000C0A                          2162mm     ENDC
00000C0A                          2163mm 
00000C0A                          2164mm     ENDM
00000C0A  57CE FFDA               2165m     DBEQ D6,LOOP_122
00000C0E                          2166m     ENDM
00000C0E                          2167m         PRINT_CRLF D5,A4
00000C0E  49FA 1127               2168m     LEA CRLF(PC),A4
00000C12                          2169mm     PRINT_STR A4,D5
00000C12                          2170mm LOOP_128
00000C12  0C14 0000               2171mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C16  6700 0016               2172mm     BEQ EXIT_128
00000C1A                          2173mmm     PRINT_CHAR (A4)+,D5
00000C1A                          2174mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1A                 TRUE     2175mmm     IFEQ DEBUG
00000C1A  1A39 00C00003           2176mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C20  0805 0002               2177mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C24  67F4                    2178mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000C26  13DC 00C00007           2179mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C2C                          2180mmm     ENDC
00000C2C                          2181mmm 
00000C2C                 FALSE    2182mmm     IFNE DEBUG
00000C2C                          2183mmm     ENDC
00000C2C                          2184mmm 
00000C2C                          2185mmm     ENDM
00000C2C  60E4                    2186mm     BRA LOOP_128
00000C2E                          2187mm EXIT_128
00000C2E                          2188mm     ENDM
00000C2E                          2189m     ENDM
00000C2E                          2190          
00000C2E  6000 F714               2191          BRA MAIN_LOOP
00000C32                          2192      ENDI
00000C32                          2193s _0000000B
00000C32                          2194  
00000C32                          2195      IF D1 <EQ> #0 THEN
00000C32  B27C 0000               2196s     CMP.W   #0,D1
00000C36  6600 0006               2197s     BNE _0000000C
00000C3A  6000 F9B8               2198        BRA WAIT_FOR_SRECORD
00000C3E                          2199      ENDI
00000C3E                          2200s _0000000C
00000C3E                          2201  DOWNLOAD_DONE
00000C3E                          2202m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C3E  43FA 10FD               2203m     LEA OX(PC),A1
00000C42                          2204mm     PRINT_STR A1,D5
00000C42                          2205mm LOOP_131
00000C42  0C11 0000               2206mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C46  6700 0016               2207mm     BEQ EXIT_131
00000C4A                          2208mmm     PRINT_CHAR (A1)+,D5
00000C4A                          2209mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2210mmm     IFEQ DEBUG
00000C4A  1A39 00C00003           2211mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C50  0805 0002               2212mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2213mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000C56  13D9 00C00007           2214mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C5C                          2215mmm     ENDC
00000C5C                          2216mmm 
00000C5C                 FALSE    2217mmm     IFNE DEBUG
00000C5C                          2218mmm     ENDC
00000C5C                          2219mmm 
00000C5C                          2220mmm     ENDM
00000C5C  60E4                    2221mm     BRA LOOP_131
00000C5E                          2222mm EXIT_131
00000C5E                          2223mm     ENDM
00000C5E  7407                    2224m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C60                          2225m LOOP_130
00000C60                          2226mm     BIN2HEX D0,D6,A1
00000C60  43FA 109A               2227mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C64  E998                    2228mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C66  1C00                    2229mm     MOVE.B D0,D6
00000C68  0286 0000000F           2230mm     ANDI.L #$F,D6
00000C6E  1C31 6000               2231mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C72                          2232mm     ENDM
00000C72                          2233mm     PRINT_CHAR D6,D5
00000C72                          2234mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C72                 TRUE     2235mm     IFEQ DEBUG
00000C72  1A39 00C00003           2236mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C78  0805 0002               2237mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C7C  67F4                    2238mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C7E  13C6 00C00007           2239mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C84                          2240mm     ENDC
00000C84                          2241mm 
00000C84                 FALSE    2242mm     IFNE DEBUG
00000C84                          2243mm     ENDC
00000C84                          2244mm 
00000C84                          2245mm     ENDM
00000C84  57CA FFDA               2246m     DBEQ D2,LOOP_130
00000C88                          2247m     ENDM
00000C88  43FA 1017               2248      LEA READ(PC),A1
00000C8C                          2249m     PRINT_STR A1,D5
00000C8C                          2250m LOOP_135
00000C8C  0C11 0000               2251m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C90  6700 0016               2252m     BEQ EXIT_135
00000C94                          2253mm     PRINT_CHAR (A1)+,D5
00000C94                          2254mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C94                 TRUE     2255mm     IFEQ DEBUG
00000C94  1A39 00C00003           2256mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C9A  0805 0002               2257mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C9E  67F4                    2258mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CA0  13D9 00C00007           2259mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA6                          2260mm     ENDC
00000CA6                          2261mm 
00000CA6                 FALSE    2262mm     IFNE DEBUG
00000CA6                          2263mm     ENDC
00000CA6                          2264mm 
00000CA6                          2265mm     ENDM
00000CA6  60E4                    2266m     BRA LOOP_135
00000CA8                          2267m EXIT_135
00000CA8                          2268m     ENDM
00000CA8  2E08                    2269      MOVE.L A0,D7                                    ; set address accumulator to start address
00000CAA                          2270m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000CAA  43FA 1091               2271m     LEA OX(PC),A1
00000CAE                          2272mm     PRINT_STR A1,D5
00000CAE                          2273mm LOOP_138
00000CAE  0C11 0000               2274mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CB2  6700 0016               2275mm     BEQ EXIT_138
00000CB6                          2276mmm     PRINT_CHAR (A1)+,D5
00000CB6                          2277mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2278mmm     IFEQ DEBUG
00000CB6  1A39 00C00003           2279mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CBC  0805 0002               2280mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2281mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CC2  13D9 00C00007           2282mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CC8                          2283mmm     ENDC
00000CC8                          2284mmm 
00000CC8                 FALSE    2285mmm     IFNE DEBUG
00000CC8                          2286mmm     ENDC
00000CC8                          2287mmm 
00000CC8                          2288mmm     ENDM
00000CC8  60E4                    2289mm     BRA LOOP_138
00000CCA                          2290mm EXIT_138
00000CCA                          2291mm     ENDM
00000CCA  7407                    2292m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CCC                          2293m LOOP_137
00000CCC                          2294mm     BIN2HEX D7,D6,A1
00000CCC  43FA 102E               2295mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CD0  E99F                    2296mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CD2  1C07                    2297mm     MOVE.B D7,D6
00000CD4  0286 0000000F           2298mm     ANDI.L #$F,D6
00000CDA  1C31 6000               2299mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CDE                          2300mm     ENDM
00000CDE                          2301mm     PRINT_CHAR D6,D5
00000CDE                          2302mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDE                 TRUE     2303mm     IFEQ DEBUG
00000CDE  1A39 00C00003           2304mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CE4  0805 0002               2305mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CE8  67F4                    2306mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CEA  13C6 00C00007           2307mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CF0                          2308mm     ENDC
00000CF0                          2309mm 
00000CF0                 FALSE    2310mm     IFNE DEBUG
00000CF0                          2311mm     ENDC
00000CF0                          2312mm 
00000CF0                          2313mm     ENDM
00000CF0  57CA FFDA               2314m     DBEQ D2,LOOP_137
00000CF4                          2315m     ENDM
00000CF4                          2316m     PRINT_CRLF D5,A4
00000CF4  49FA 1041               2317m     LEA CRLF(PC),A4
00000CF8                          2318mm     PRINT_STR A4,D5
00000CF8                          2319mm LOOP_143
00000CF8  0C14 0000               2320mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000CFC  6700 0016               2321mm     BEQ EXIT_143
00000D00                          2322mmm     PRINT_CHAR (A4)+,D5
00000D00                          2323mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2324mmm     IFEQ DEBUG
00000D00  1A39 00C00003           2325mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D06  0805 0002               2326mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2327mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D0C  13DC 00C00007           2328mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D12                          2329mmm     ENDC
00000D12                          2330mmm 
00000D12                 FALSE    2331mmm     IFNE DEBUG
00000D12                          2332mmm     ENDC
00000D12                          2333mmm 
00000D12                          2334mmm     ENDM
00000D12  60E4                    2335mm     BRA LOOP_143
00000D14                          2336mm EXIT_143
00000D14                          2337mm     ENDM
00000D14                          2338m     ENDM
00000D14                          2339  
00000D14  6000 F62E               2340      BRA MAIN_LOOP
00000D18                          2341  
00000D18                          2342  G
00000D18  2047                    2343      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000D1A  7E00                    2344      MOVE.L #0,D7
00000D1C                          2345  
00000D1C  4ED0                    2346      JMP (A0)
00000D1E                          2347          
00000D1E                          2348  Z
00000D1E  207C 00200000           2349      MOVE.L #RAM,A0                                  ; address of RAM
00000D24  D1FC 00100000           2350      ADD.L #$100000,A0
00000D2A                          2351  
00000D2A                          2352      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000D2A  7000                    2353s     MOVE.L  #0,D0
00000D2C  6000 0012               2354s     BRA _20000007
00000D30                          2355s _20000006
00000D30  2200                    2356          MOVE.L D0,D1                                ; progress update
00000D32  E089                    2357          LSR.L #8,D1 
00000D34  E089                    2358          LSR.L #8,D1
00000D36  13C1 00E00001           2359          MOVE.B D1,DISPLAY
00000D3C                          2360          
00000D3C  2108                    2361          MOVE.L A0,-(A0)
00000D3E                          2362      ENDF
00000D3E  5880                    2363s     ADD.L   #4,D0
00000D40                          2364s _20000007
00000D40  B0BC 000FFFFC           2365s     CMP.L   #$FFFFC,D0
00000D46  6FE8                    2366s     BLE _20000006
00000D48                          2367  
00000D48  207C 00200000           2368      MOVE.L #RAM,A0                                  ; address of RAM
00000D4E  D1FC 00100000           2369      ADD.L #$100000,A0
00000D54                          2370  
00000D54                          2371      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D54  7000                    2372s     MOVE.L  #0,D0
00000D56  6000 00A8               2373s     BRA _20000009
00000D5A                          2374s _20000008
00000D5A  2200                    2375          MOVE.L D0,D1                                ; progress update
00000D5C  E089                    2376          LSR.L #8,D1
00000D5E  E089                    2377          LSR.L #8,D1
00000D60  13C1 00E00001           2378          MOVE.B D1,DISPLAY
00000D66                          2379  
00000D66  2408                    2380          MOVE.L A0,D2
00000D68  2220                    2381          MOVE.L -(A0),D1
00000D6A                          2382  
00000D6A                          2383          IF.L D2 <NE> D1 THEN
00000D6A  B481                    2384s     CMP.L   D1,D2
00000D6C  6700 0090               2385s     BEQ _0000000D
00000D70  43FA 0F79               2386              LEA RAM_ERROR(PC),A1
00000D74                          2387m             PRINT_STR A1,D1
00000D74                          2388m LOOP_145
00000D74  0C11 0000               2389m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D78  6700 0016               2390m     BEQ EXIT_145
00000D7C                          2391mm     PRINT_CHAR (A1)+,D1
00000D7C                          2392mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7C                 TRUE     2393mm     IFEQ DEBUG
00000D7C  1239 00C00003           2394mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D82  0801 0002               2395mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000D86  67F4                    2396mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000D88  13D9 00C00007           2397mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D8E                          2398mm     ENDC
00000D8E                          2399mm 
00000D8E                 FALSE    2400mm     IFNE DEBUG
00000D8E                          2401mm     ENDC
00000D8E                          2402mm 
00000D8E                          2403mm     ENDM
00000D8E  60E4                    2404m     BRA LOOP_145
00000D90                          2405m EXIT_145
00000D90                          2406m     ENDM
00000D90  2208                    2407              MOVE.L A0,D1
00000D92  5981                    2408              SUB.L #4,D1
00000D94                          2409m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000D94  43FA 0FA7               2410m     LEA OX(PC),A1
00000D98                          2411mm     PRINT_STR A1,D3
00000D98                          2412mm LOOP_148
00000D98  0C11 0000               2413mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D9C  6700 0016               2414mm     BEQ EXIT_148
00000DA0                          2415mmm     PRINT_CHAR (A1)+,D3
00000DA0                          2416mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA0                 TRUE     2417mmm     IFEQ DEBUG
00000DA0  1639 00C00003           2418mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DA6  0803 0002               2419mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DAA  67F4                    2420mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000DAC  13D9 00C00007           2421mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DB2                          2422mmm     ENDC
00000DB2                          2423mmm 
00000DB2                 FALSE    2424mmm     IFNE DEBUG
00000DB2                          2425mmm     ENDC
00000DB2                          2426mmm 
00000DB2                          2427mmm     ENDM
00000DB2  60E4                    2428mm     BRA LOOP_148
00000DB4                          2429mm EXIT_148
00000DB4                          2430mm     ENDM
00000DB4  7C07                    2431m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DB6                          2432m LOOP_147
00000DB6                          2433mm     BIN2HEX D1,D2,A1
00000DB6  43FA 0F44               2434mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000DBA  E999                    2435mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DBC  1401                    2436mm     MOVE.B D1,D2
00000DBE  0282 0000000F           2437mm     ANDI.L #$F,D2
00000DC4  1431 2000               2438mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000DC8                          2439mm     ENDM
00000DC8                          2440mm     PRINT_CHAR D2,D3
00000DC8                          2441mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC8                 TRUE     2442mm     IFEQ DEBUG
00000DC8  1639 00C00003           2443mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DCE  0803 0002               2444mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DD2  67F4                    2445mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DD4  13C2 00C00007           2446mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DDA                          2447mm     ENDC
00000DDA                          2448mm 
00000DDA                 FALSE    2449mm     IFNE DEBUG
00000DDA                          2450mm     ENDC
00000DDA                          2451mm 
00000DDA                          2452mm     ENDM
00000DDA  57CE FFDA               2453m     DBEQ D6,LOOP_147
00000DDE                          2454m     ENDM
00000DDE                          2455m             PRINT_CRLF D3,A1
00000DDE  43FA 0F57               2456m     LEA CRLF(PC),A1
00000DE2                          2457mm     PRINT_STR A1,D3
00000DE2                          2458mm LOOP_153
00000DE2  0C11 0000               2459mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DE6  6700 0016               2460mm     BEQ EXIT_153
00000DEA                          2461mmm     PRINT_CHAR (A1)+,D3
00000DEA                          2462mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEA                 TRUE     2463mmm     IFEQ DEBUG
00000DEA  1639 00C00003           2464mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DF0  0803 0002               2465mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DF4  67F4                    2466mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DF6  13D9 00C00007           2467mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DFC                          2468mmm     ENDC
00000DFC                          2469mmm 
00000DFC                 FALSE    2470mmm     IFNE DEBUG
00000DFC                          2471mmm     ENDC
00000DFC                          2472mmm 
00000DFC                          2473mmm     ENDM
00000DFC  60E4                    2474mm     BRA LOOP_153
00000DFE                          2475mm EXIT_153
00000DFE                          2476mm     ENDM
00000DFE                          2477m     ENDM
00000DFE                          2478          ENDI 
00000DFE                          2479s _0000000D
00000DFE                          2480      ENDF
00000DFE  5880                    2481s     ADD.L   #4,D0
00000E00                          2482s _20000009
00000E00  B0BC 000FFFFC           2483s     CMP.L   #$FFFFC,D0
00000E06  6F00 FF52               2484s     BLE _20000008
00000E0A                          2485  
00000E0A  6000 F538               2486      BRA MAIN_LOOP
00000E0E                          2487  
00000E0E                          2488  L
00000E0E  7000                    2489      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000E10  7200                    2490      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000E12                          2491  
00000E12                          2492      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000E12  343C 0000               2493s     MOVE.W  #0,D2
00000E16  6000 0046               2494s     BRA _2000000B
00000E1A                          2495s _2000000A
00000E1A  E989                    2496          LSL.L #4,D1                                 ; make what we have so far more significant
00000E1C                          2497m         WAIT_CHAR D3,D4                             ; next character -> D2
00000E1C                          2498m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E1C                 TRUE     2499m     IFEQ DEBUG
00000E1C  1839 00C00003           2500m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E22  0804 0000               2501m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000E26  67F4                    2502m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000E28                          2503m     ENDC
00000E28                          2504m 
00000E28                          2505mm     READ_CHAR D3
00000E28                 TRUE     2506mm     IFEQ DEBUG
00000E28  1639 00C00007           2507mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000E2E                          2508mm     ENDC
00000E2E                 FALSE    2509mm     IFNE DEBUG
00000E2E                          2510mm     ENDC
00000E2E                          2511mm 
00000E2E  B63C 001B               2512mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E32  6700 F2D0               2513mm     BEQ START
00000E36                          2514mm     ENDM
00000E36                          2515m 
00000E36                 TRUE     2516m     IFEQ DEBUG
00000E36                          2517mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E36                          2518mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E36                 TRUE     2519mm     IFEQ DEBUG
00000E36  1839 00C00003           2520mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E3C  0804 0002               2521mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E40  67F4                    2522mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E42  13C3 00C00007           2523mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E48                          2524mm     ENDC
00000E48                          2525mm 
00000E48                 FALSE    2526mm     IFNE DEBUG
00000E48                          2527mm     ENDC
00000E48                          2528mm 
00000E48                          2529mm     ENDM
00000E48                          2530m     ENDC
00000E48                          2531m     ENDM
00000E48                          2532m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E48  41FA 0EC2               2533m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E4C  0403 0030               2534m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E50  C6BC 000000FF           2535m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E56  1630 3000               2536m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E5A                          2537m     ENDM
00000E5A  8203                    2538          OR.B D3,D1
00000E5C                          2539      ENDF
00000E5C  5242                    2540s     ADD.W   #1,D2
00000E5E                          2541s _2000000B
00000E5E  B47C 0007               2542s     CMP.W   #7,D2
00000E62  6FB6                    2543s     BLE _2000000A
00000E64                          2544  
00000E64  3001                    2545      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E66  0480 00000104           2546      SUB.L #START,D0                                 ; remove the vector table from the length
00000E6C  E089                    2547      LSR.L #8,D1                                     ; extract the MSword for the address
00000E6E  E089                    2548      LSR.L #8,D1
00000E70                          2549  
00000E70                          2550m     PRINT_CRLF D2,A1
00000E70  43FA 0EC5               2551m     LEA CRLF(PC),A1
00000E74                          2552mm     PRINT_STR A1,D2
00000E74                          2553mm LOOP_160
00000E74  0C11 0000               2554mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E78  6700 0016               2555mm     BEQ EXIT_160
00000E7C                          2556mmm     PRINT_CHAR (A1)+,D2
00000E7C                          2557mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E7C                 TRUE     2558mmm     IFEQ DEBUG
00000E7C  1439 00C00003           2559mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E82  0802 0002               2560mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E86  67F4                    2561mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E88  13D9 00C00007           2562mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E8E                          2563mmm     ENDC
00000E8E                          2564mmm 
00000E8E                 FALSE    2565mmm     IFNE DEBUG
00000E8E                          2566mmm     ENDC
00000E8E                          2567mmm 
00000E8E                          2568mmm     ENDM
00000E8E  60E4                    2569mm     BRA LOOP_160
00000E90                          2570mm EXIT_160
00000E90                          2571mm     ENDM
00000E90                          2572m     ENDM
00000E90                          2573  
00000E90  2041                    2574      MOVE.L D1,A0                                    ; target address
00000E92  2641                    2575      MOVE.L D1,A3                                    ; keep a copy for later
00000E94                          2576  
00000E94  2247                    2577      MOVE.L D7,A1                                    ; address accumulator -> address register
00000E96  D3FC 00000104           2578      ADD.L #START,A1                                 ; skip the vectors
00000E9C  2847                    2579      MOVE.L D7,A4                                    ; keep a clean copy for later
00000E9E  7E00                    2580      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EA0                          2581  
00000EA0                          2582m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000EA0  31FC AAAA 2AAA          2583m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EA6  4E71                    2584m     NOP
00000EA8  31FC 5555 1554          2585m     MOVE.W #$5555,$1554
00000EAE  4E71                    2586m     NOP
00000EB0  31FC 8080 2AAA          2587m     MOVE.W #$8080,$2AAA
00000EB6  4E71                    2588m     NOP
00000EB8  31FC AAAA 2AAA          2589m     MOVE.W #$AAAA,$2AAA
00000EBE  4E71                    2590m     NOP
00000EC0  31FC 5555 1554          2591m     MOVE.W #$5555,$1554
00000EC6  4E71                    2592m     NOP
00000EC8  31FC 2020 2AAA          2593m     MOVE.W #$2020,$2AAA
00000ECE                          2594m     ENDM
00000ECE                          2595                      
00000ECE                          2596      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000ECE  3E3C 0000               2597s     MOVE.W  #$0,D7
00000ED2  6000 0006               2598s     BRA _2000000D
00000ED6                          2599s _2000000C
00000ED6  4E71                    2600          NOP
00000ED8                          2601      ENDF
00000ED8  5247                    2602s     ADD.W   #1,D7
00000EDA                          2603s _2000000D
00000EDA  BE7C FFFF               2604s     CMP.W   #$FFFFFFFF,D7
00000EDE  6FF6                    2605s     BLE _2000000C
00000EE0                          2606                  
00000EE0  45FA 0E41               2607      LEA LOADING(PC),A2
00000EE4                          2608m     PRINT_STR A2,D2
00000EE4                          2609m LOOP_163
00000EE4  0C12 0000               2610m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EE8  6700 0016               2611m     BEQ EXIT_163
00000EEC                          2612mm     PRINT_CHAR (A2)+,D2
00000EEC                          2613mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEC                 TRUE     2614mm     IFEQ DEBUG
00000EEC  1439 00C00003           2615mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EF2  0802 0002               2616mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EF6  67F4                    2617mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EF8  13DA 00C00007           2618mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFE                          2619mm     ENDC
00000EFE                          2620mm 
00000EFE                 FALSE    2621mm     IFNE DEBUG
00000EFE                          2622mm     ENDC
00000EFE                          2623mm 
00000EFE                          2624mm     ENDM
00000EFE  60E4                    2625m     BRA LOOP_163
00000F00                          2626m EXIT_163
00000F00                          2627m     ENDM
00000F00                          2628          
00000F00  2409                    2629      MOVE.L A1,D2
00000F02                          2630m     PRINT_REG D2,D3,D4,D5,A2
00000F02  45FA 0E39               2631m     LEA OX(PC),A2
00000F06                          2632mm     PRINT_STR A2,D3
00000F06                          2633mm LOOP_166
00000F06  0C12 0000               2634mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F0A  6700 0016               2635mm     BEQ EXIT_166
00000F0E                          2636mmm     PRINT_CHAR (A2)+,D3
00000F0E                          2637mmm WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F0E                 TRUE     2638mmm     IFEQ DEBUG
00000F0E  1639 00C00003           2639mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F14  0803 0002               2640mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F18  67F4                    2641mmm         BEQ WAIT_FOR_READY_167                      ; NO SPACE, CHECK AGAIN
00000F1A  13DA 00C00007           2642mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F20                          2643mmm     ENDC
00000F20                          2644mmm 
00000F20                 FALSE    2645mmm     IFNE DEBUG
00000F20                          2646mmm     ENDC
00000F20                          2647mmm 
00000F20                          2648mmm     ENDM
00000F20  60E4                    2649mm     BRA LOOP_166
00000F22                          2650mm EXIT_166
00000F22                          2651mm     ENDM
00000F22  7A07                    2652m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F24                          2653m LOOP_165
00000F24                          2654mm     BIN2HEX D2,D4,A2
00000F24  45FA 0DD6               2655mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F28  E99A                    2656mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F2A  1802                    2657mm     MOVE.B D2,D4
00000F2C  0284 0000000F           2658mm     ANDI.L #$F,D4
00000F32  1832 4000               2659mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F36                          2660mm     ENDM
00000F36                          2661mm     PRINT_CHAR D4,D3
00000F36                          2662mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F36                 TRUE     2663mm     IFEQ DEBUG
00000F36  1639 00C00003           2664mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F3C  0803 0002               2665mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F40  67F4                    2666mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F42  13C4 00C00007           2667mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F48                          2668mm     ENDC
00000F48                          2669mm 
00000F48                 FALSE    2670mm     IFNE DEBUG
00000F48                          2671mm     ENDC
00000F48                          2672mm 
00000F48                          2673mm     ENDM
00000F48  57CD FFDA               2674m     DBEQ D5,LOOP_165
00000F4C                          2675m     ENDM
00000F4C                          2676  
00000F4C  45FA 0DF2               2677      LEA TO(PC),A2
00000F50                          2678m     PRINT_STR A2,D3
00000F50                          2679m LOOP_170
00000F50  0C12 0000               2680m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F54  6700 0016               2681m     BEQ EXIT_170
00000F58                          2682mm     PRINT_CHAR (A2)+,D3
00000F58                          2683mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F58                 TRUE     2684mm     IFEQ DEBUG
00000F58  1639 00C00003           2685mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F5E  0803 0002               2686mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F62  67F4                    2687mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F64  13DA 00C00007           2688mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F6A                          2689mm     ENDC
00000F6A                          2690mm 
00000F6A                 FALSE    2691mm     IFNE DEBUG
00000F6A                          2692mm     ENDC
00000F6A                          2693mm 
00000F6A                          2694mm     ENDM
00000F6A  60E4                    2695m     BRA LOOP_170
00000F6C                          2696m EXIT_170
00000F6C                          2697m     ENDM
00000F6C                          2698  
00000F6C  2408                    2699      MOVE.L A0,D2
00000F6E                          2700m     PRINT_REG D2,D3,D4,D5,A2
00000F6E  45FA 0DCD               2701m     LEA OX(PC),A2
00000F72                          2702mm     PRINT_STR A2,D3
00000F72                          2703mm LOOP_173
00000F72  0C12 0000               2704mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F76  6700 0016               2705mm     BEQ EXIT_173
00000F7A                          2706mmm     PRINT_CHAR (A2)+,D3
00000F7A                          2707mmm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F7A                 TRUE     2708mmm     IFEQ DEBUG
00000F7A  1639 00C00003           2709mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F80  0803 0002               2710mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F84  67F4                    2711mmm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00000F86  13DA 00C00007           2712mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F8C                          2713mmm     ENDC
00000F8C                          2714mmm 
00000F8C                 FALSE    2715mmm     IFNE DEBUG
00000F8C                          2716mmm     ENDC
00000F8C                          2717mmm 
00000F8C                          2718mmm     ENDM
00000F8C  60E4                    2719mm     BRA LOOP_173
00000F8E                          2720mm EXIT_173
00000F8E                          2721mm     ENDM
00000F8E  7A07                    2722m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F90                          2723m LOOP_172
00000F90                          2724mm     BIN2HEX D2,D4,A2
00000F90  45FA 0D6A               2725mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F94  E99A                    2726mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F96  1802                    2727mm     MOVE.B D2,D4
00000F98  0284 0000000F           2728mm     ANDI.L #$F,D4
00000F9E  1832 4000               2729mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FA2                          2730mm     ENDM
00000FA2                          2731mm     PRINT_CHAR D4,D3
00000FA2                          2732mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FA2                 TRUE     2733mm     IFEQ DEBUG
00000FA2  1639 00C00003           2734mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FA8  0803 0002               2735mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FAC  67F4                    2736mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000FAE  13C4 00C00007           2737mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FB4                          2738mm     ENDC
00000FB4                          2739mm 
00000FB4                 FALSE    2740mm     IFNE DEBUG
00000FB4                          2741mm     ENDC
00000FB4                          2742mm 
00000FB4                          2743mm     ENDM
00000FB4  57CD FFDA               2744m     DBEQ D5,LOOP_172
00000FB8                          2745m     ENDM
00000FB8                          2746  
00000FB8  45FA 0D8B               2747      LEA FOR(PC),A2
00000FBC                          2748m     PRINT_STR A2,D3
00000FBC                          2749m LOOP_177
00000FBC  0C12 0000               2750m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FC0  6700 0016               2751m     BEQ EXIT_177
00000FC4                          2752mm     PRINT_CHAR (A2)+,D3
00000FC4                          2753mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC4                 TRUE     2754mm     IFEQ DEBUG
00000FC4  1639 00C00003           2755mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FCA  0803 0002               2756mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FCE  67F4                    2757mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000FD0  13DA 00C00007           2758mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FD6                          2759mm     ENDC
00000FD6                          2760mm 
00000FD6                 FALSE    2761mm     IFNE DEBUG
00000FD6                          2762mm     ENDC
00000FD6                          2763mm 
00000FD6                          2764mm     ENDM
00000FD6  60E4                    2765m     BRA LOOP_177
00000FD8                          2766m EXIT_177
00000FD8                          2767m     ENDM
00000FD8                          2768m     PRINT_REG D0,D3,D4,D5,A2
00000FD8  45FA 0D63               2769m     LEA OX(PC),A2
00000FDC                          2770mm     PRINT_STR A2,D3
00000FDC                          2771mm LOOP_180
00000FDC  0C12 0000               2772mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FE0  6700 0016               2773mm     BEQ EXIT_180
00000FE4                          2774mmm     PRINT_CHAR (A2)+,D3
00000FE4                          2775mmm WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FE4                 TRUE     2776mmm     IFEQ DEBUG
00000FE4  1639 00C00003           2777mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FEA  0803 0002               2778mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FEE  67F4                    2779mmm         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
00000FF0  13DA 00C00007           2780mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FF6                          2781mmm     ENDC
00000FF6                          2782mmm 
00000FF6                 FALSE    2783mmm     IFNE DEBUG
00000FF6                          2784mmm     ENDC
00000FF6                          2785mmm 
00000FF6                          2786mmm     ENDM
00000FF6  60E4                    2787mm     BRA LOOP_180
00000FF8                          2788mm EXIT_180
00000FF8                          2789mm     ENDM
00000FF8  7A07                    2790m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FFA                          2791m LOOP_179
00000FFA                          2792mm     BIN2HEX D0,D4,A2
00000FFA  45FA 0D00               2793mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FFE  E998                    2794mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001000  1800                    2795mm     MOVE.B D0,D4
00001002  0284 0000000F           2796mm     ANDI.L #$F,D4
00001008  1832 4000               2797mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000100C                          2798mm     ENDM
0000100C                          2799mm     PRINT_CHAR D4,D3
0000100C                          2800mm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000100C                 TRUE     2801mm     IFEQ DEBUG
0000100C  1639 00C00003           2802mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001012  0803 0002               2803mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001016  67F4                    2804mm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00001018  13C4 00C00007           2805mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000101E                          2806mm     ENDC
0000101E                          2807mm 
0000101E                 FALSE    2808mm     IFNE DEBUG
0000101E                          2809mm     ENDC
0000101E                          2810mm 
0000101E                          2811mm     ENDM
0000101E  57CD FFDA               2812m     DBEQ D5,LOOP_179
00001022                          2813m     ENDM
00001022                          2814  
00001022                          2815m     PRINT_CRLF D3,A2
00001022  45FA 0D13               2816m     LEA CRLF(PC),A2
00001026                          2817mm     PRINT_STR A2,D3
00001026                          2818mm LOOP_185
00001026  0C12 0000               2819mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000102A  6700 0016               2820mm     BEQ EXIT_185
0000102E                          2821mmm     PRINT_CHAR (A2)+,D3
0000102E                          2822mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000102E                 TRUE     2823mmm     IFEQ DEBUG
0000102E  1639 00C00003           2824mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001034  0803 0002               2825mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001038  67F4                    2826mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
0000103A  13DA 00C00007           2827mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001040                          2828mmm     ENDC
00001040                          2829mmm 
00001040                 FALSE    2830mmm     IFNE DEBUG
00001040                          2831mmm     ENDC
00001040                          2832mmm 
00001040                          2833mmm     ENDM
00001040  60E4                    2834mm     BRA LOOP_185
00001042                          2835mm EXIT_185
00001042                          2836mm     ENDM
00001042                          2837m     ENDM
00001042                          2838  
00001042                          2839      WHILE D0 <GT> #0 DO
00001042                          2840s _10000014
00001042  B07C 0000               2841s     CMP.W   #0,D0
00001046  6F00 001C               2842s     BLE _10000015
0000104A  5580                    2843          SUB.L #2,D0
0000104C                          2844  
0000104C  13D1 00E00001           2845          MOVE.B (A1),DISPLAY
00001052                          2846m         PROGRAM (A1),(A0),D2
00001052  3091                    2847m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001054                          2848m 
00001054                          2849m WAIT_FOR_COMPLETE_187
00001054  3410                    2850m         MOVE.W (A0),D2
00001056                          2851m 
00001056                          2852m         IF.W D2 <NE> (A1) THEN
00001056  B451                    2853ms     CMP.W   (A1),D2
00001058  6700 0004               2854ms     BEQ _0000000E
0000105C  60F6                    2855m             BRA WAIT_FOR_COMPLETE_187
0000105E                          2856m         ENDI
0000105E                          2857ms _0000000E
0000105E                          2858m         ENDM
0000105E                          2859                  
0000105E  5488                    2860          ADD.L #2,A0
00001060  5489                    2861          ADD.L #2,A1
00001062                          2862      ENDW
00001062  60DE                    2863s     BRA _10000014
00001064                          2864s _10000015
00001064                          2865      
00001064  41F8 0000               2866      LEA STACK,A0
00001068  D1CC                    2867      ADD.L A4,A0
0000106A  2010                    2868      MOVE.L (A0),D0
0000106C                          2869      
0000106C  207C 00000000           2870      MOVE.L #0,A0
00001072                          2871m     PROGRAM_VECTOR D0,A0,D2
00001072  5488                    2872m     ADD.L #2,A0
00001074                          2873mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00001074  3080                    2874mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001076                          2875mm 
00001076                          2876mm WAIT_FOR_COMPLETE_189
00001076  3410                    2877mm         MOVE.W (A0),D2
00001078                          2878mm 
00001078                          2879mm         IF.W D2 <NE> D0 THEN
00001078  B440                    2880mms     CMP.W   D0,D2
0000107A  6700 0004               2881mms     BEQ _0000000F
0000107E  60F6                    2882mm             BRA WAIT_FOR_COMPLETE_189
00001080                          2883mm         ENDI
00001080                          2884mms _0000000F
00001080                          2885mm         ENDM
00001080  E088                    2886m     LSR.L #8,D0
00001082  E088                    2887m     LSR.L #8,D0
00001084  5588                    2888m     SUB.L #2,A0
00001086                          2889mm     PROGRAM D0, (A0), D2
00001086  3080                    2890mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001088                          2891mm 
00001088                          2892mm WAIT_FOR_COMPLETE_190
00001088  3410                    2893mm         MOVE.W (A0),D2
0000108A                          2894mm 
0000108A                          2895mm         IF.W D2 <NE> D0 THEN
0000108A  B440                    2896mms     CMP.W   D0,D2
0000108C  6700 0004               2897mms     BEQ _00000010
00001090  60F6                    2898mm             BRA WAIT_FOR_COMPLETE_190
00001092                          2899mm         ENDI
00001092                          2900mms _00000010
00001092                          2901mm         ENDM
00001092                          2902m     ENDM
00001092                          2903      
00001092                          2904      FOR A0 = #RESET TO #START-4 BY #4 DO
00001092  307C 0004               2905s     MOVE.W  #RESET,A0
00001096  6000 003C               2906s     BRA _2000000F
0000109A                          2907s _2000000E
0000109A                          2908  
0000109A  2248                    2909          MOVE.L A0,A1
0000109C  D3CC                    2910          ADD.L A4,A1
0000109E                          2911              
0000109E  2011                    2912          MOVE.L (A1),D0  
000010A0  D081                    2913          ADD.L D1,D0
000010A2  0480 00000104           2914          SUB.L #START,D0
000010A8                          2915  
000010A8  2408                    2916          MOVE.L A0,D2
000010AA                          2917          
000010AA  2408                    2918          MOVE.L A0,D2
000010AC  13C2 00E00001           2919          MOVE.B D2,DISPLAY
000010B2                          2920m         PROGRAM_VECTOR D0,A0,D2
000010B2  5488                    2921m     ADD.L #2,A0
000010B4                          2922mm     PROGRAM D0, (A0), D2                            ; WRITE IT
000010B4  3080                    2923mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010B6                          2924mm 
000010B6                          2925mm WAIT_FOR_COMPLETE_192
000010B6  3410                    2926mm         MOVE.W (A0),D2
000010B8                          2927mm 
000010B8                          2928mm         IF.W D2 <NE> D0 THEN
000010B8  B440                    2929mms     CMP.W   D0,D2
000010BA  6700 0004               2930mms     BEQ _00000011
000010BE  60F6                    2931mm             BRA WAIT_FOR_COMPLETE_192
000010C0                          2932mm         ENDI
000010C0                          2933mms _00000011
000010C0                          2934mm         ENDM
000010C0  E088                    2935m     LSR.L #8,D0
000010C2  E088                    2936m     LSR.L #8,D0
000010C4  5588                    2937m     SUB.L #2,A0
000010C6                          2938mm     PROGRAM D0, (A0), D2
000010C6  3080                    2939mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010C8                          2940mm 
000010C8                          2941mm WAIT_FOR_COMPLETE_193
000010C8  3410                    2942mm         MOVE.W (A0),D2
000010CA                          2943mm 
000010CA                          2944mm         IF.W D2 <NE> D0 THEN
000010CA  B440                    2945mms     CMP.W   D0,D2
000010CC  6700 0004               2946mms     BEQ _00000012
000010D0  60F6                    2947mm             BRA WAIT_FOR_COMPLETE_193
000010D2                          2948mm         ENDI
000010D2                          2949mms _00000012
000010D2                          2950mm         ENDM
000010D2                          2951m     ENDM
000010D2                          2952      ENDF
000010D2  5848                    2953s     ADD.W   #4,A0
000010D4                          2954s _2000000F
000010D4  B0FC 0100               2955s     CMP.W   #START-4,A0
000010D8  6FC0                    2956s     BLE _2000000E
000010DA                          2957                                          
000010DA                          2958m     PROTECT
000010DA  31FC AAAA 2AAA          2959m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010E0  31FC 5555 1554          2960m     MOVE.W #$5555,$1554
000010E6  31FC A0A0 2AAA          2961m     MOVE.W #$A0A0,$2AAA
000010EC                          2962m     ENDM
000010EC                          2963  
000010EC  6000 F256               2964      BRA MAIN_LOOP
000010F0                          2965      
000010F0                          2966  P
000010F0  7000                    2967      MOVE.L #0,D0                                    ; D0 will be the data to write
000010F2                          2968  
000010F2                          2969      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000010F2  323C 0000               2970s     MOVE.W  #0,D1
000010F6  6000 0046               2971s     BRA _20000011
000010FA                          2972s _20000010
000010FA  E988                    2973          LSL.L #4,D0                                 ; make what we have so far more significant
000010FC                          2974m         WAIT_CHAR D2,D3                             ; next character -> D2
000010FC                          2975m WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010FC                 TRUE     2976m     IFEQ DEBUG
000010FC  1639 00C00003           2977m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001102  0803 0000               2978m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001106  67F4                    2979m         BEQ WAIT_FOR_READY_195                      ; NOTHING, CHECK AGAIN
00001108                          2980m     ENDC
00001108                          2981m 
00001108                          2982mm     READ_CHAR D2
00001108                 TRUE     2983mm     IFEQ DEBUG
00001108  1439 00C00007           2984mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000110E                          2985mm     ENDC
0000110E                 FALSE    2986mm     IFNE DEBUG
0000110E                          2987mm     ENDC
0000110E                          2988mm 
0000110E  B43C 001B               2989mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001112  6700 EFF0               2990mm     BEQ START
00001116                          2991mm     ENDM
00001116                          2992m 
00001116                 TRUE     2993m     IFEQ DEBUG
00001116                          2994mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001116                          2995mm WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001116                 TRUE     2996mm     IFEQ DEBUG
00001116  1639 00C00003           2997mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000111C  0803 0002               2998mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001120  67F4                    2999mm         BEQ WAIT_FOR_READY_197                      ; NO SPACE, CHECK AGAIN
00001122  13C2 00C00007           3000mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001128                          3001mm     ENDC
00001128                          3002mm 
00001128                 FALSE    3003mm     IFNE DEBUG
00001128                          3004mm     ENDC
00001128                          3005mm 
00001128                          3006mm     ENDM
00001128                          3007m     ENDC
00001128                          3008m     ENDM
00001128                          3009m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001128  41FA 0BE2               3010m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000112C  0402 0030               3011m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001130  C4BC 000000FF           3012m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001136  1430 2000               3013m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000113A                          3014m     ENDM
0000113A  8002                    3015          OR.B D2,D0
0000113C                          3016      ENDF
0000113C  5241                    3017s     ADD.W   #1,D1
0000113E                          3018s _20000011
0000113E  B27C 0003               3019s     CMP.W   #3,D1
00001142  6FB6                    3020s     BLE _20000010
00001144                          3021  
00001144                          3022m     PRINT_CRLF D2,A1
00001144  43FA 0BF1               3023m     LEA CRLF(PC),A1
00001148                          3024mm     PRINT_STR A1,D2
00001148                          3025mm LOOP_200
00001148  0C11 0000               3026mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000114C  6700 0016               3027mm     BEQ EXIT_200
00001150                          3028mmm     PRINT_CHAR (A1)+,D2
00001150                          3029mmm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001150                 TRUE     3030mmm     IFEQ DEBUG
00001150  1439 00C00003           3031mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001156  0802 0002               3032mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000115A  67F4                    3033mmm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
0000115C  13D9 00C00007           3034mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001162                          3035mmm     ENDC
00001162                          3036mmm 
00001162                 FALSE    3037mmm     IFNE DEBUG
00001162                          3038mmm     ENDC
00001162                          3039mmm 
00001162                          3040mmm     ENDM
00001162  60E4                    3041mm     BRA LOOP_200
00001164                          3042mm EXIT_200
00001164                          3043mm     ENDM
00001164                          3044m     ENDM
00001164                          3045  
00001164  2047                    3046      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001166  7E00                    3047      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001168                          3048  
00001168                          3049m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001168  31FC AAAA 2AAA          3050m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000116E  4E71                    3051m     NOP
00001170  31FC 5555 1554          3052m     MOVE.W #$5555,$1554
00001176  4E71                    3053m     NOP
00001178  31FC 8080 2AAA          3054m     MOVE.W #$8080,$2AAA
0000117E  4E71                    3055m     NOP
00001180  31FC AAAA 2AAA          3056m     MOVE.W #$AAAA,$2AAA
00001186  4E71                    3057m     NOP
00001188  31FC 5555 1554          3058m     MOVE.W #$5555,$1554
0000118E  4E71                    3059m     NOP
00001190  31FC 2020 2AAA          3060m     MOVE.W #$2020,$2AAA
00001196                          3061m     ENDM
00001196                          3062                              
00001196                          3063      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001196  3E3C 0000               3064s     MOVE.W  #$0,D7
0000119A  6000 0006               3065s     BRA _20000013
0000119E                          3066s _20000012
0000119E  4E71                    3067          NOP
000011A0                          3068      ENDF
000011A0  5247                    3069s     ADD.W   #1,D7
000011A2                          3070s _20000013
000011A2  BE7C FFFF               3071s     CMP.W   #$FFFFFFFF,D7
000011A6  6FF6                    3072s     BLE _20000012
000011A8                          3073               
000011A8  45FA 0B79               3074      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
000011AC                          3075m     PRINT_STR A2,D2
000011AC                          3076m LOOP_203
000011AC  0C12 0000               3077m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011B0  6700 0016               3078m     BEQ EXIT_203
000011B4                          3079mm     PRINT_CHAR (A2)+,D2
000011B4                          3080mm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011B4                 TRUE     3081mm     IFEQ DEBUG
000011B4  1439 00C00003           3082mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011BA  0802 0002               3083mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011BE  67F4                    3084mm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
000011C0  13DA 00C00007           3085mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011C6                          3086mm     ENDC
000011C6                          3087mm 
000011C6                 FALSE    3088mm     IFNE DEBUG
000011C6                          3089mm     ENDC
000011C6                          3090mm 
000011C6                          3091mm     ENDM
000011C6  60E4                    3092m     BRA LOOP_203
000011C8                          3093m EXIT_203
000011C8                          3094m     ENDM
000011C8                          3095  
000011C8                          3096m     PRINT_REG D0,D3,D4,D5,A2
000011C8  45FA 0B73               3097m     LEA OX(PC),A2
000011CC                          3098mm     PRINT_STR A2,D3
000011CC                          3099mm LOOP_206
000011CC  0C12 0000               3100mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D0  6700 0016               3101mm     BEQ EXIT_206
000011D4                          3102mmm     PRINT_CHAR (A2)+,D3
000011D4                          3103mmm WAIT_FOR_READY_207                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011D4                 TRUE     3104mmm     IFEQ DEBUG
000011D4  1639 00C00003           3105mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011DA  0803 0002               3106mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011DE  67F4                    3107mmm         BEQ WAIT_FOR_READY_207                      ; NO SPACE, CHECK AGAIN
000011E0  13DA 00C00007           3108mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011E6                          3109mmm     ENDC
000011E6                          3110mmm 
000011E6                 FALSE    3111mmm     IFNE DEBUG
000011E6                          3112mmm     ENDC
000011E6                          3113mmm 
000011E6                          3114mmm     ENDM
000011E6  60E4                    3115mm     BRA LOOP_206
000011E8                          3116mm EXIT_206
000011E8                          3117mm     ENDM
000011E8  7A07                    3118m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011EA                          3119m LOOP_205
000011EA                          3120mm     BIN2HEX D0,D4,A2
000011EA  45FA 0B10               3121mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011EE  E998                    3122mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011F0  1800                    3123mm     MOVE.B D0,D4
000011F2  0284 0000000F           3124mm     ANDI.L #$F,D4
000011F8  1832 4000               3125mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011FC                          3126mm     ENDM
000011FC                          3127mm     PRINT_CHAR D4,D3
000011FC                          3128mm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011FC                 TRUE     3129mm     IFEQ DEBUG
000011FC  1639 00C00003           3130mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001202  0803 0002               3131mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001206  67F4                    3132mm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
00001208  13C4 00C00007           3133mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000120E                          3134mm     ENDC
0000120E                          3135mm 
0000120E                 FALSE    3136mm     IFNE DEBUG
0000120E                          3137mm     ENDC
0000120E                          3138mm 
0000120E                          3139mm     ENDM
0000120E  57CD FFDA               3140m     DBEQ D5,LOOP_205
00001212                          3141m     ENDM
00001212                          3142  
00001212  45FA 0B2C               3143      LEA TO(PC),A2
00001216                          3144m     PRINT_STR A2,D3
00001216                          3145m LOOP_210
00001216  0C12 0000               3146m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000121A  6700 0016               3147m     BEQ EXIT_210
0000121E                          3148mm     PRINT_CHAR (A2)+,D3
0000121E                          3149mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121E                 TRUE     3150mm     IFEQ DEBUG
0000121E  1639 00C00003           3151mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001224  0803 0002               3152mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001228  67F4                    3153mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0000122A  13DA 00C00007           3154mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001230                          3155mm     ENDC
00001230                          3156mm 
00001230                 FALSE    3157mm     IFNE DEBUG
00001230                          3158mm     ENDC
00001230                          3159mm 
00001230                          3160mm     ENDM
00001230  60E4                    3161m     BRA LOOP_210
00001232                          3162m EXIT_210
00001232                          3163m     ENDM
00001232                          3164  
00001232  2408                    3165      MOVE.L A0,D2
00001234                          3166m     PRINT_REG D2,D3,D4,D5,A2
00001234  45FA 0B07               3167m     LEA OX(PC),A2
00001238                          3168mm     PRINT_STR A2,D3
00001238                          3169mm LOOP_213
00001238  0C12 0000               3170mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000123C  6700 0016               3171mm     BEQ EXIT_213
00001240                          3172mmm     PRINT_CHAR (A2)+,D3
00001240                          3173mmm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001240                 TRUE     3174mmm     IFEQ DEBUG
00001240  1639 00C00003           3175mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001246  0803 0002               3176mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000124A  67F4                    3177mmm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
0000124C  13DA 00C00007           3178mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001252                          3179mmm     ENDC
00001252                          3180mmm 
00001252                 FALSE    3181mmm     IFNE DEBUG
00001252                          3182mmm     ENDC
00001252                          3183mmm 
00001252                          3184mmm     ENDM
00001252  60E4                    3185mm     BRA LOOP_213
00001254                          3186mm EXIT_213
00001254                          3187mm     ENDM
00001254  7A07                    3188m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001256                          3189m LOOP_212
00001256                          3190mm     BIN2HEX D2,D4,A2
00001256  45FA 0AA4               3191mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000125A  E99A                    3192mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000125C  1802                    3193mm     MOVE.B D2,D4
0000125E  0284 0000000F           3194mm     ANDI.L #$F,D4
00001264  1832 4000               3195mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001268                          3196mm     ENDM
00001268                          3197mm     PRINT_CHAR D4,D3
00001268                          3198mm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001268                 TRUE     3199mm     IFEQ DEBUG
00001268  1639 00C00003           3200mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126E  0803 0002               3201mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001272  67F4                    3202mm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001274  13C4 00C00007           3203mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000127A                          3204mm     ENDC
0000127A                          3205mm 
0000127A                 FALSE    3206mm     IFNE DEBUG
0000127A                          3207mm     ENDC
0000127A                          3208mm 
0000127A                          3209mm     ENDM
0000127A  57CD FFDA               3210m     DBEQ D5,LOOP_212
0000127E                          3211m     ENDM
0000127E                          3212  
0000127E                          3213m     PRINT_CRLF D3,A2
0000127E  45FA 0AB7               3214m     LEA CRLF(PC),A2
00001282                          3215mm     PRINT_STR A2,D3
00001282                          3216mm LOOP_218
00001282  0C12 0000               3217mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001286  6700 0016               3218mm     BEQ EXIT_218
0000128A                          3219mmm     PRINT_CHAR (A2)+,D3
0000128A                          3220mmm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000128A                 TRUE     3221mmm     IFEQ DEBUG
0000128A  1639 00C00003           3222mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001290  0803 0002               3223mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001294  67F4                    3224mmm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
00001296  13DA 00C00007           3225mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000129C                          3226mmm     ENDC
0000129C                          3227mmm 
0000129C                 FALSE    3228mmm     IFNE DEBUG
0000129C                          3229mmm     ENDC
0000129C                          3230mmm 
0000129C                          3231mmm     ENDM
0000129C  60E4                    3232mm     BRA LOOP_218
0000129E                          3233mm EXIT_218
0000129E                          3234mm     ENDM
0000129E                          3235m     ENDM
0000129E                          3236  
0000129E                          3237m     PROGRAM D0,(A0),D2
0000129E  3080                    3238m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000012A0                          3239m 
000012A0                          3240m WAIT_FOR_COMPLETE_220
000012A0  3410                    3241m         MOVE.W (A0),D2
000012A2                          3242m 
000012A2                          3243m         IF.W D2 <NE> D0 THEN
000012A2  B440                    3244ms     CMP.W   D0,D2
000012A4  6700 0004               3245ms     BEQ _00000013
000012A8  60F6                    3246m             BRA WAIT_FOR_COMPLETE_220
000012AA                          3247m         ENDI
000012AA                          3248ms _00000013
000012AA                          3249m         ENDM
000012AA                          3250  
000012AA                          3251m     PROTECT
000012AA  31FC AAAA 2AAA          3252m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000012B0  31FC 5555 1554          3253m     MOVE.W #$5555,$1554
000012B6  31FC A0A0 2AAA          3254m     MOVE.W #$A0A0,$2AAA
000012BC                          3255m     ENDM
000012BC                          3256      
000012BC  6000 F086               3257      BRA MAIN_LOOP
000012C0                          3258      
000012C0                          3259  X
000012C0  45FA 0A8E               3260      LEA STATUS_REGISTER(PC),A2
000012C4                          3261m     PRINT_STR A2,D3
000012C4                          3262m LOOP_222
000012C4  0C12 0000               3263m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012C8  6700 0016               3264m     BEQ EXIT_222
000012CC                          3265mm     PRINT_CHAR (A2)+,D3
000012CC                          3266mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012CC                 TRUE     3267mm     IFEQ DEBUG
000012CC  1639 00C00003           3268mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012D2  0803 0002               3269mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012D6  67F4                    3270mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
000012D8  13DA 00C00007           3271mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012DE                          3272mm     ENDC
000012DE                          3273mm 
000012DE                 FALSE    3274mm     IFNE DEBUG
000012DE                          3275mm     ENDC
000012DE                          3276mm 
000012DE                          3277mm     ENDM
000012DE  60E4                    3278m     BRA LOOP_222
000012E0                          3279m EXIT_222
000012E0                          3280m     ENDM
000012E0                          3281  
000012E0  40C0                    3282      MOVE SR,D0
000012E2                          3283m     PRINT_REG D0,D3,D4,D5,A2
000012E2  45FA 0A59               3284m     LEA OX(PC),A2
000012E6                          3285mm     PRINT_STR A2,D3
000012E6                          3286mm LOOP_225
000012E6  0C12 0000               3287mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012EA  6700 0016               3288mm     BEQ EXIT_225
000012EE                          3289mmm     PRINT_CHAR (A2)+,D3
000012EE                          3290mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012EE                 TRUE     3291mmm     IFEQ DEBUG
000012EE  1639 00C00003           3292mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012F4  0803 0002               3293mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012F8  67F4                    3294mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012FA  13DA 00C00007           3295mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001300                          3296mmm     ENDC
00001300                          3297mmm 
00001300                 FALSE    3298mmm     IFNE DEBUG
00001300                          3299mmm     ENDC
00001300                          3300mmm 
00001300                          3301mmm     ENDM
00001300  60E4                    3302mm     BRA LOOP_225
00001302                          3303mm EXIT_225
00001302                          3304mm     ENDM
00001302  7A07                    3305m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001304                          3306m LOOP_224
00001304                          3307mm     BIN2HEX D0,D4,A2
00001304  45FA 09F6               3308mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001308  E998                    3309mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000130A  1800                    3310mm     MOVE.B D0,D4
0000130C  0284 0000000F           3311mm     ANDI.L #$F,D4
00001312  1832 4000               3312mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001316                          3313mm     ENDM
00001316                          3314mm     PRINT_CHAR D4,D3
00001316                          3315mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001316                 TRUE     3316mm     IFEQ DEBUG
00001316  1639 00C00003           3317mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000131C  0803 0002               3318mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001320  67F4                    3319mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
00001322  13C4 00C00007           3320mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001328                          3321mm     ENDC
00001328                          3322mm 
00001328                 FALSE    3323mm     IFNE DEBUG
00001328                          3324mm     ENDC
00001328                          3325mm 
00001328                          3326mm     ENDM
00001328  57CD FFDA               3327m     DBEQ D5,LOOP_224
0000132C                          3328m     ENDM
0000132C                          3329m     PRINT_CRLF D3,A2
0000132C  45FA 0A09               3330m     LEA CRLF(PC),A2
00001330                          3331mm     PRINT_STR A2,D3
00001330                          3332mm LOOP_230
00001330  0C12 0000               3333mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001334  6700 0016               3334mm     BEQ EXIT_230
00001338                          3335mmm     PRINT_CHAR (A2)+,D3
00001338                          3336mmm WAIT_FOR_READY_231                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001338                 TRUE     3337mmm     IFEQ DEBUG
00001338  1639 00C00003           3338mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000133E  0803 0002               3339mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001342  67F4                    3340mmm         BEQ WAIT_FOR_READY_231                      ; NO SPACE, CHECK AGAIN
00001344  13DA 00C00007           3341mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000134A                          3342mmm     ENDC
0000134A                          3343mmm 
0000134A                 FALSE    3344mmm     IFNE DEBUG
0000134A                          3345mmm     ENDC
0000134A                          3346mmm 
0000134A                          3347mmm     ENDM
0000134A  60E4                    3348mm     BRA LOOP_230
0000134C                          3349mm EXIT_230
0000134C                          3350mm     ENDM
0000134C                          3351m     ENDM
0000134C                          3352  
0000134C  45FA 09FD               3353      LEA STACK_POINTER(PC),A2
00001350                          3354m     PRINT_STR A2,D3
00001350                          3355m LOOP_232
00001350  0C12 0000               3356m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001354  6700 0016               3357m     BEQ EXIT_232
00001358                          3358mm     PRINT_CHAR (A2)+,D3
00001358                          3359mm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001358                 TRUE     3360mm     IFEQ DEBUG
00001358  1639 00C00003           3361mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000135E  0803 0002               3362mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001362  67F4                    3363mm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001364  13DA 00C00007           3364mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000136A                          3365mm     ENDC
0000136A                          3366mm 
0000136A                 FALSE    3367mm     IFNE DEBUG
0000136A                          3368mm     ENDC
0000136A                          3369mm 
0000136A                          3370mm     ENDM
0000136A  60E4                    3371m     BRA LOOP_232
0000136C                          3372m EXIT_232
0000136C                          3373m     ENDM
0000136C                          3374  
0000136C  200F                    3375      MOVE.L SP,D0
0000136E                          3376m     PRINT_REG D0,D3,D4,D5,A2
0000136E  45FA 09CD               3377m     LEA OX(PC),A2
00001372                          3378mm     PRINT_STR A2,D3
00001372                          3379mm LOOP_235
00001372  0C12 0000               3380mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001376  6700 0016               3381mm     BEQ EXIT_235
0000137A                          3382mmm     PRINT_CHAR (A2)+,D3
0000137A                          3383mmm WAIT_FOR_READY_236                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000137A                 TRUE     3384mmm     IFEQ DEBUG
0000137A  1639 00C00003           3385mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001380  0803 0002               3386mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001384  67F4                    3387mmm         BEQ WAIT_FOR_READY_236                      ; NO SPACE, CHECK AGAIN
00001386  13DA 00C00007           3388mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000138C                          3389mmm     ENDC
0000138C                          3390mmm 
0000138C                 FALSE    3391mmm     IFNE DEBUG
0000138C                          3392mmm     ENDC
0000138C                          3393mmm 
0000138C                          3394mmm     ENDM
0000138C  60E4                    3395mm     BRA LOOP_235
0000138E                          3396mm EXIT_235
0000138E                          3397mm     ENDM
0000138E  7A07                    3398m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001390                          3399m LOOP_234
00001390                          3400mm     BIN2HEX D0,D4,A2
00001390  45FA 096A               3401mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001394  E998                    3402mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001396  1800                    3403mm     MOVE.B D0,D4
00001398  0284 0000000F           3404mm     ANDI.L #$F,D4
0000139E  1832 4000               3405mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000013A2                          3406mm     ENDM
000013A2                          3407mm     PRINT_CHAR D4,D3
000013A2                          3408mm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013A2                 TRUE     3409mm     IFEQ DEBUG
000013A2  1639 00C00003           3410mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013A8  0803 0002               3411mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013AC  67F4                    3412mm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
000013AE  13C4 00C00007           3413mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013B4                          3414mm     ENDC
000013B4                          3415mm 
000013B4                 FALSE    3416mm     IFNE DEBUG
000013B4                          3417mm     ENDC
000013B4                          3418mm 
000013B4                          3419mm     ENDM
000013B4  57CD FFDA               3420m     DBEQ D5,LOOP_234
000013B8                          3421m     ENDM
000013B8                          3422m     PRINT_CRLF D3,A2
000013B8  45FA 097D               3423m     LEA CRLF(PC),A2
000013BC                          3424mm     PRINT_STR A2,D3
000013BC                          3425mm LOOP_240
000013BC  0C12 0000               3426mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013C0  6700 0016               3427mm     BEQ EXIT_240
000013C4                          3428mmm     PRINT_CHAR (A2)+,D3
000013C4                          3429mmm WAIT_FOR_READY_241                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013C4                 TRUE     3430mmm     IFEQ DEBUG
000013C4  1639 00C00003           3431mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013CA  0803 0002               3432mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013CE  67F4                    3433mmm         BEQ WAIT_FOR_READY_241                      ; NO SPACE, CHECK AGAIN
000013D0  13DA 00C00007           3434mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013D6                          3435mmm     ENDC
000013D6                          3436mmm 
000013D6                 FALSE    3437mmm     IFNE DEBUG
000013D6                          3438mmm     ENDC
000013D6                          3439mmm 
000013D6                          3440mmm     ENDM
000013D6  60E4                    3441mm     BRA LOOP_240
000013D8                          3442mm EXIT_240
000013D8                          3443mm     ENDM
000013D8                          3444m     ENDM
000013D8                          3445  
000013D8  6000 EF6A               3446      BRA MAIN_LOOP
000013DC                          3447          
000013DC                          3448  I
000013DC  13FC 0008 00C0000B      3449      MOVE.B #8,DUART_IMR
000013E4  027C F8FF               3450      AND.W #$F8FF,SR
000013E8  6000 EF5A               3451      BRA MAIN_LOOP
000013EC                          3452      
000013EC                          3453  O
000013EC  13FC 0000 00C0000B      3454      MOVE.B #0,DUART_IMR
000013F4  007C 0700               3455      OR.W #$0700,SR
000013F8  6000 EF4A               3456      BRA MAIN_LOOP
000013FC                          3457          
000013FC                          3458  HASH
000013FC                          3459m     PROTECT
000013FC  31FC AAAA 2AAA          3460m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001402  31FC 5555 1554          3461m     MOVE.W #$5555,$1554
00001408  31FC A0A0 2AAA          3462m     MOVE.W #$A0A0,$2AAA
0000140E                          3463m     ENDM
0000140E  6000 EF34               3464      BRA MAIN_LOOP
00001412                          3465      
00001412                          3466  B
00001412  13FC 0038 00A00019      3467      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000141A                          3468      
0000141A                          3469m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
0000141A  13FC 00FF 00A00007      3470m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001422  103C 0030               3471m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001426  0000 0006               3472m     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000142A  13C0 00A00019           3473m     MOVE.B D0, MC68230_PORT_C_DATA
00001430  0200 00EF               3474m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001434  13FC 00E0 00A00013      3475m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
0000143C  13C0 00A00019           3476m     MOVE.B D0, MC68230_PORT_C_DATA
00001442  0000 0010               3477m     ORI.B #MC68230_PORT_C_WRITE, D0
00001446  13C0 00A00019           3478m     MOVE.B D0, MC68230_PORT_C_DATA
0000144C  13FC 0038 00A00019      3479m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001454                          3480m     ENDM
00001454                          3481m     WAIT_DRIVE_READY D0, D1
00001454                          3482m LOOP_244
00001454                          3483mm     READ_IDE_STATUS D0, D1
00001454                          3484mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001454  13FC 0000 00A00007      3485mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000145C  123C 0030               3486mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001460  0001 0007               3487mmm     ORI.B #IDE_STATUS_REGISTER, D1
00001464  13C1 00A00019           3488mmm     MOVE.B D1, MC68230_PORT_C_DATA
0000146A  0201 00DF               3489mmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000146E  13C1 00A00019           3490mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001474  1039 00A00013           3491mmm     MOVE.B MC68230_PORT_B_DATA, D0
0000147A  0001 0020               3492mmm     ORI.B #MC68230_PORT_C_READ, D1
0000147E  13C1 00A00019           3493mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001484  13FC 0038 00A00019      3494mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000148C                          3495mmm     ENDM
0000148C                          3496mm     ENDM
0000148C  0800 0006               3497m     BTST #IDE_STATUS_READY, D0
00001490  67C2                    3498m     BEQ LOOP_244
00001492                          3499m     ENDM
00001492                          3500          
00001492  2607                    3501      MOVE.L D7,D3                                ; grab the address accumulator into D3 as block startb
00001494                          3502              
00001494  7801                    3503      MOVE.L #1, D4                               ; flag for first iteration
00001496  7A01                    3504      MOVE.L #1, D5                               ; sentinel to prime the loop
00001498                          3505      WHILE D5 <GT> #0 DO
00001498                          3506s _10000016
00001498  BA7C 0000               3507s     CMP.W   #0,D5
0000149C  6F00 049E               3508s     BLE _10000017
000014A0                          3509m         SEND_READ_COMMAND_AND_WAIT D3, D0, D1, D2
000014A0                          3510mm     WAIT_DRIVE_NOT_BUSY D0, D1
000014A0                          3511mm LOOP_248
000014A0                          3512mmm     READ_IDE_STATUS D0, D1
000014A0                          3513mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000014A0  13FC 0000 00A00007      3514mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014A8  123C 0030               3515mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000014AC  0001 0007               3516mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000014B0  13C1 00A00019           3517mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014B6  0201 00DF               3518mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000014BA  13C1 00A00019           3519mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014C0  1039 00A00013           3520mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000014C6  0001 0020               3521mmmm     ORI.B #MC68230_PORT_C_READ, D1
000014CA  13C1 00A00019           3522mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014D0  13FC 0038 00A00019      3523mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014D8                          3524mmmm     ENDM
000014D8                          3525mmm     ENDM
000014D8  0800 0007               3526mm     BTST #IDE_STATUS_BUSY, D0
000014DC  66C2                    3527mm     BNE LOOP_248
000014DE                          3528mm     ENDM
000014DE                          3529mm     SET_READ_ADDRESS D3, D0, D1, D2
000014DE                          3530mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
000014DE  13FC 00FF 00A00007      3531mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014E6  103C 0030               3532mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014EA  0000 0002               3533mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
000014EE  13C0 00A00019           3534mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014F4  0200 00EF               3535mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014F8  13FC 0001 00A00013      3536mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001500  13C0 00A00019           3537mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001506  0000 0010               3538mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000150A  13C0 00A00019           3539mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001510  13FC 0038 00A00019      3540mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001518                          3541mmm     ENDM
00001518  2203                    3542mm     MOVE.L D3,D1
0000151A                          3543mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
0000151A  13FC 00FF 00A00007      3544mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001522  103C 0030               3545mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001526  0000 0003               3546mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
0000152A  13C0 00A00019           3547mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001530  0200 00EF               3548mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001534  13C1 00A00013           3549mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000153A  13C0 00A00019           3550mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001540  0000 0010               3551mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001544  13C0 00A00019           3552mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000154A  13FC 0038 00A00019      3553mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001552                          3554mmm     ENDM
00001552  E089                    3555mm     LSR.L #8, D1
00001554                          3556mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001554  13FC 00FF 00A00007      3557mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000155C  103C 0030               3558mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001560  0000 0004               3559mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
00001564  13C0 00A00019           3560mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000156A  0200 00EF               3561mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000156E  13C1 00A00013           3562mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001574  13C0 00A00019           3563mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000157A  0000 0010               3564mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000157E  13C0 00A00019           3565mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001584  13FC 0038 00A00019      3566mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000158C                          3567mmm     ENDM
0000158C  E089                    3568mm     LSR.L #8, D1                                
0000158E                          3569mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
0000158E  13FC 00FF 00A00007      3570mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001596  103C 0030               3571mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000159A  0000 0005               3572mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
0000159E  13C0 00A00019           3573mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015A4  0200 00EF               3574mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000015A8  13C1 00A00013           3575mmm     MOVE.B D1, MC68230_PORT_B_DATA
000015AE  13C0 00A00019           3576mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015B4  0000 0010               3577mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000015B8  13C0 00A00019           3578mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015BE  13FC 0038 00A00019      3579mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015C6                          3580mmm     ENDM
000015C6  E089                    3581mm     LSR.L #8, D1
000015C8                          3582mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
000015C8  13FC 0000 00A00007      3583mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015D0  103C 0030               3584mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000015D4  0000 0006               3585mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000015D8  13C0 00A00019           3586mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015DE  0200 00DF               3587mmm     ANDI.B #~MC68230_PORT_C_READ, D0
000015E2  13C0 00A00019           3588mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015E8  1439 00A00013           3589mmm     MOVE.B MC68230_PORT_B_DATA, D2
000015EE  0000 0020               3590mmm     ORI.B #MC68230_PORT_C_READ, D0
000015F2  13C0 00A00019           3591mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015F8  13FC 0038 00A00019      3592mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001600                          3593mmm     ENDM
00001600  0201 000F               3594mm     ANDI.B #$0F,D1
00001604  8401                    3595mm     OR.B D1,D2
00001606                          3596mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
00001606  13FC 00FF 00A00007      3597mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000160E  103C 0030               3598mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001612  0000 0006               3599mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001616  13C0 00A00019           3600mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000161C  0200 00EF               3601mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001620  13C2 00A00013           3602mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001626  13C0 00A00019           3603mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000162C  0000 0010               3604mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001630  13C0 00A00019           3605mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001636  13FC 0038 00A00019      3606mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000163E                          3607mmm     ENDM
0000163E                          3608mm     ENDM
0000163E                          3609mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
0000163E                          3610mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
0000163E  13FC 00FF 00A00007      3611mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001646  103C 0030               3612mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000164A  0000 0007               3613mmm     ORI.B #IDE_COMMAND_REGISTER, D0
0000164E  13C0 00A00019           3614mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001654  0200 00EF               3615mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001658  13FC 0020 00A00013      3616mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001660  13C0 00A00019           3617mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001666  0000 0010               3618mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000166A  13C0 00A00019           3619mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001670  13FC 0038 00A00019      3620mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001678                          3621mmm     ENDM
00001678                          3622mm     ENDM
00001678                          3623mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001678                          3624mm LOOP_260
00001678                          3625mmm     READ_IDE_STATUS D0, D1
00001678                          3626mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001678  13FC 0000 00A00007      3627mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001680  123C 0030               3628mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001684  0001 0007               3629mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001688  13C1 00A00019           3630mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000168E  0201 00DF               3631mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001692  13C1 00A00019           3632mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001698  1039 00A00013           3633mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000169E  0001 0020               3634mmmm     ORI.B #MC68230_PORT_C_READ, D1
000016A2  13C1 00A00019           3635mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016A8  13FC 0038 00A00019      3636mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016B0                          3637mmmm     ENDM
000016B0                          3638mmm     ENDM
000016B0  0800 0007               3639mm     BTST #IDE_STATUS_BUSY, D0
000016B4  66C2                    3640mm     BNE LOOP_260
000016B6                          3641mm     ENDM
000016B6                          3642mm     WAIT_DRIVE_DRQ D0, D1
000016B6                          3643mm LOOP_263
000016B6                          3644mmm     READ_IDE_STATUS D0, D1
000016B6                          3645mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000016B6  13FC 0000 00A00007      3646mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016BE  123C 0030               3647mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000016C2  0001 0007               3648mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000016C6  13C1 00A00019           3649mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016CC  0201 00DF               3650mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000016D0  13C1 00A00019           3651mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016D6  1039 00A00013           3652mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000016DC  0001 0020               3653mmmm     ORI.B #MC68230_PORT_C_READ, D1
000016E0  13C1 00A00019           3654mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016E6  13FC 0038 00A00019      3655mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016EE                          3656mmmm     ENDM
000016EE                          3657mmm     ENDM
000016EE  0800 0003               3658mm     BTST #IDE_STATUS_DRQ, D0
000016F2  67C2                    3659mm     BEQ LOOP_263
000016F4                          3660mm     ENDM
000016F4                          3661m     ENDM
000016F4                          3662m         PRINT_CHAR #'.', D1
000016F4                          3663m WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016F4                 TRUE     3664m     IFEQ DEBUG
000016F4  1239 00C00003           3665m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000016FA  0801 0002               3666m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000016FE  67F4                    3667m         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
00001700  13FC 002E 00C00007      3668m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001708                          3669m     ENDC
00001708                          3670m 
00001708                 FALSE    3671m     IFNE DEBUG
00001708                          3672m     ENDC
00001708                          3673m 
00001708                          3674m     ENDM
00001708                          3675          
00001708                          3676          IF D4 <EQ> #1 THEN
00001708  B87C 0001               3677s     CMP.W   #1,D4
0000170C  6600 01C8               3678s     BNE _00000014
00001710                          3679m             READ_32 #IDE_DATA_REGISTER, D2, D1      ; start -> D2
00001710                          3680mm     READ_16 #IDE_DATA_REGISTER, D2, D1
00001710  13FC 0000 00A00007      3681mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001718  13FC 0000 00A00005      3682mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001720                          3683mm     
00001720  123C 0030               3684mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001724  0001 0000               3685mm     ORI.B #IDE_DATA_REGISTER, D1
00001728  13C1 00A00019           3686mm     MOVE.B D1, MC68230_PORT_C_DATA
0000172E  0201 00DF               3687mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001732  13C1 00A00019           3688mm     MOVE.B D1, MC68230_PORT_C_DATA
00001738  1439 00A00011           3689mm     MOVE.B MC68230_PORT_A_DATA, D2
0000173E  E14A                    3690mm     LSL.W #8, D2
00001740  1439 00A00013           3691mm     MOVE.B MC68230_PORT_B_DATA, D2
00001746  0001 0020               3692mm     ORI.B #MC68230_PORT_C_READ, D1
0000174A  13C1 00A00019           3693mm     MOVE.B D1, MC68230_PORT_C_DATA
00001750  13FC 0038 00A00019      3694mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001758                          3695mm     ENDM
00001758  E18A                    3696m     LSL.L #8, D2
0000175A  E18A                    3697m     LSL.L #8, D2
0000175C                          3698mm     READ_16 #IDE_DATA_REGISTER, D2, D1
0000175C  13FC 0000 00A00007      3699mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001764  13FC 0000 00A00005      3700mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000176C                          3701mm     
0000176C  123C 0030               3702mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001770  0001 0000               3703mm     ORI.B #IDE_DATA_REGISTER, D1
00001774  13C1 00A00019           3704mm     MOVE.B D1, MC68230_PORT_C_DATA
0000177A  0201 00DF               3705mm     ANDI.B #~MC68230_PORT_C_READ, D1
0000177E  13C1 00A00019           3706mm     MOVE.B D1, MC68230_PORT_C_DATA
00001784  1439 00A00011           3707mm     MOVE.B MC68230_PORT_A_DATA, D2
0000178A  E14A                    3708mm     LSL.W #8, D2
0000178C  1439 00A00013           3709mm     MOVE.B MC68230_PORT_B_DATA, D2
00001792  0001 0020               3710mm     ORI.B #MC68230_PORT_C_READ, D1
00001796  13C1 00A00019           3711mm     MOVE.B D1, MC68230_PORT_C_DATA
0000179C  13FC 0038 00A00019      3712mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017A4                          3713mm     ENDM
000017A4                          3714m     ENDM
000017A4  2042                    3715              MOVE.L D2, A0                           ; set up target         
000017A6                          3716m             READ_32 #IDE_DATA_REGISTER, D5, D1      ; end -> D5
000017A6                          3717mm     READ_16 #IDE_DATA_REGISTER, D5, D1
000017A6  13FC 0000 00A00007      3718mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000017AE  13FC 0000 00A00005      3719mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000017B6                          3720mm     
000017B6  123C 0030               3721mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000017BA  0001 0000               3722mm     ORI.B #IDE_DATA_REGISTER, D1
000017BE  13C1 00A00019           3723mm     MOVE.B D1, MC68230_PORT_C_DATA
000017C4  0201 00DF               3724mm     ANDI.B #~MC68230_PORT_C_READ, D1
000017C8  13C1 00A00019           3725mm     MOVE.B D1, MC68230_PORT_C_DATA
000017CE  1A39 00A00011           3726mm     MOVE.B MC68230_PORT_A_DATA, D5
000017D4  E14D                    3727mm     LSL.W #8, D5
000017D6  1A39 00A00013           3728mm     MOVE.B MC68230_PORT_B_DATA, D5
000017DC  0001 0020               3729mm     ORI.B #MC68230_PORT_C_READ, D1
000017E0  13C1 00A00019           3730mm     MOVE.B D1, MC68230_PORT_C_DATA
000017E6  13FC 0038 00A00019      3731mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017EE                          3732mm     ENDM
000017EE  E18D                    3733m     LSL.L #8, D5
000017F0  E18D                    3734m     LSL.L #8, D5
000017F2                          3735mm     READ_16 #IDE_DATA_REGISTER, D5, D1
000017F2  13FC 0000 00A00007      3736mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000017FA  13FC 0000 00A00005      3737mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001802                          3738mm     
00001802  123C 0030               3739mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001806  0001 0000               3740mm     ORI.B #IDE_DATA_REGISTER, D1
0000180A  13C1 00A00019           3741mm     MOVE.B D1, MC68230_PORT_C_DATA
00001810  0201 00DF               3742mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001814  13C1 00A00019           3743mm     MOVE.B D1, MC68230_PORT_C_DATA
0000181A  1A39 00A00011           3744mm     MOVE.B MC68230_PORT_A_DATA, D5
00001820  E14D                    3745mm     LSL.W #8, D5
00001822  1A39 00A00013           3746mm     MOVE.B MC68230_PORT_B_DATA, D5
00001828  0001 0020               3747mm     ORI.B #MC68230_PORT_C_READ, D1
0000182C  13C1 00A00019           3748mm     MOVE.B D1, MC68230_PORT_C_DATA
00001832  13FC 0038 00A00019      3749mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000183A                          3750mm     ENDM
0000183A                          3751m     ENDM
0000183A  9A82                    3752              SUB.L D2, D5                            ; work out num bytes
0000183C                          3753m             READ_32 #IDE_DATA_REGISTER, D7, D1      ; read entry point into address accumulator
0000183C                          3754mm     READ_16 #IDE_DATA_REGISTER, D7, D1
0000183C  13FC 0000 00A00007      3755mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001844  13FC 0000 00A00005      3756mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000184C                          3757mm     
0000184C  123C 0030               3758mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001850  0001 0000               3759mm     ORI.B #IDE_DATA_REGISTER, D1
00001854  13C1 00A00019           3760mm     MOVE.B D1, MC68230_PORT_C_DATA
0000185A  0201 00DF               3761mm     ANDI.B #~MC68230_PORT_C_READ, D1
0000185E  13C1 00A00019           3762mm     MOVE.B D1, MC68230_PORT_C_DATA
00001864  1E39 00A00011           3763mm     MOVE.B MC68230_PORT_A_DATA, D7
0000186A  E14F                    3764mm     LSL.W #8, D7
0000186C  1E39 00A00013           3765mm     MOVE.B MC68230_PORT_B_DATA, D7
00001872  0001 0020               3766mm     ORI.B #MC68230_PORT_C_READ, D1
00001876  13C1 00A00019           3767mm     MOVE.B D1, MC68230_PORT_C_DATA
0000187C  13FC 0038 00A00019      3768mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001884                          3769mm     ENDM
00001884  E18F                    3770m     LSL.L #8, D7
00001886  E18F                    3771m     LSL.L #8, D7
00001888                          3772mm     READ_16 #IDE_DATA_REGISTER, D7, D1
00001888  13FC 0000 00A00007      3773mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001890  13FC 0000 00A00005      3774mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001898                          3775mm     
00001898  123C 0030               3776mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
0000189C  0001 0000               3777mm     ORI.B #IDE_DATA_REGISTER, D1
000018A0  13C1 00A00019           3778mm     MOVE.B D1, MC68230_PORT_C_DATA
000018A6  0201 00DF               3779mm     ANDI.B #~MC68230_PORT_C_READ, D1
000018AA  13C1 00A00019           3780mm     MOVE.B D1, MC68230_PORT_C_DATA
000018B0  1E39 00A00011           3781mm     MOVE.B MC68230_PORT_A_DATA, D7
000018B6  E14F                    3782mm     LSL.W #8, D7
000018B8  1E39 00A00013           3783mm     MOVE.B MC68230_PORT_B_DATA, D7
000018BE  0001 0020               3784mm     ORI.B #MC68230_PORT_C_READ, D1
000018C2  13C1 00A00019           3785mm     MOVE.B D1, MC68230_PORT_C_DATA
000018C8  13FC 0038 00A00019      3786mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000018D0                          3787mm     ENDM
000018D0                          3788m     ENDM
000018D0  7406                    3789              MOVE.L #6, D2                           ; words read so far
000018D2                          3790          ELSE
000018D2  6000 0004               3791s     BRA _00000015
000018D6                          3792s _00000014
000018D6  7400                    3793              MOVE.L #0, D2                           ; words read so far
000018D8                          3794          ENDI
000018D8                          3795s _00000015
000018D8                          3796              
000018D8                          3797          FOR.L D6 = D2 TO #255 DO
000018D8  2C02                    3798s     MOVE.L  D2,D6
000018DA  6000 0050               3799s     BRA _20000015
000018DE                          3800s _20000014
000018DE                          3801m             READ_16 #IDE_DATA_REGISTER, D0, D1
000018DE  13FC 0000 00A00007      3802m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000018E6  13FC 0000 00A00005      3803m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000018EE                          3804m     
000018EE  123C 0030               3805m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000018F2  0001 0000               3806m     ORI.B #IDE_DATA_REGISTER, D1
000018F6  13C1 00A00019           3807m     MOVE.B D1, MC68230_PORT_C_DATA
000018FC  0201 00DF               3808m     ANDI.B #~MC68230_PORT_C_READ, D1
00001900  13C1 00A00019           3809m     MOVE.B D1, MC68230_PORT_C_DATA
00001906  1039 00A00011           3810m     MOVE.B MC68230_PORT_A_DATA, D0
0000190C  E148                    3811m     LSL.W #8, D0
0000190E  1039 00A00013           3812m     MOVE.B MC68230_PORT_B_DATA, D0
00001914  0001 0020               3813m     ORI.B #MC68230_PORT_C_READ, D1
00001918  13C1 00A00019           3814m     MOVE.B D1, MC68230_PORT_C_DATA
0000191E  13FC 0038 00A00019      3815m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001926                          3816m     ENDM
00001926  30C0                    3817              MOVE.W D0,(A0)+
00001928  5585                    3818              SUB.L #2, D5
0000192A                          3819          ENDF
0000192A  5286                    3820s     ADD.L   #1,D6
0000192C                          3821s _20000015
0000192C  BCBC 000000FF           3822s     CMP.L   #255,D6
00001932  6FAA                    3823s     BLE _20000014
00001934                          3824          
00001934  5283                    3825          ADD.L #1, D3                                ; next block
00001936  7800                    3826          MOVE.L #0, D4                               ; not the first anymore
00001938                          3827      ENDW
00001938  6000 FB5E               3828s     BRA _10000016
0000193C                          3829s _10000017
0000193C                          3830  
0000193C                          3831m     PRINT_CRLF D3,A3
0000193C  47FA 03F9               3832m     LEA CRLF(PC),A3
00001940                          3833mm     PRINT_STR A3,D3
00001940                          3834mm LOOP_278
00001940  0C13 0000               3835mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001944  6700 0016               3836mm     BEQ EXIT_278
00001948                          3837mmm     PRINT_CHAR (A3)+,D3
00001948                          3838mmm WAIT_FOR_READY_279                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001948                 TRUE     3839mmm     IFEQ DEBUG
00001948  1639 00C00003           3840mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000194E  0803 0002               3841mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001952  67F4                    3842mmm         BEQ WAIT_FOR_READY_279                      ; NO SPACE, CHECK AGAIN
00001954  13DB 00C00007           3843mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000195A                          3844mmm     ENDC
0000195A                          3845mmm 
0000195A                 FALSE    3846mmm     IFNE DEBUG
0000195A                          3847mmm     ENDC
0000195A                          3848mmm 
0000195A                          3849mmm     ENDM
0000195A  60E4                    3850mm     BRA LOOP_278
0000195C                          3851mm EXIT_278
0000195C                          3852mm     ENDM
0000195C                          3853m     ENDM
0000195C                          3854      
0000195C  6000 E9E6               3855      BRA MAIN_LOOP
00001960                          3856  
00001960                          3857  HEX_DIGIT
00001960  E98F                    3858      LSL.L #4,D7                                     ; add the next digit in the next 4 bits
00001962                          3859m     HEX2BIN D2,D2,A0
00001962  41FA 03A8               3860m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001966  0402 0030               3861m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000196A  C4BC 000000FF           3862m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001970  1430 2000               3863m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001974                          3864m     ENDM
00001974  8E02                    3865      OR.B D2,D7  
00001976  6000 E9EC               3866      BRA GET_INPUT
0000197A                          3867  
0000197A                          3868  ; exceptions    
0000197A                          3869  BUS_ERROR_HANDLER
0000197A                          3870  
0000197A  41FA 03E0               3871      LEA BUS_ERROR(PC),A0
0000197E                          3872m     PRINT_STR A0,D1
0000197E                          3873m LOOP_281
0000197E  0C10 0000               3874m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001982  6700 0016               3875m     BEQ EXIT_281
00001986                          3876mm     PRINT_CHAR (A0)+,D1
00001986                          3877mm WAIT_FOR_READY_282                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001986                 TRUE     3878mm     IFEQ DEBUG
00001986  1239 00C00003           3879mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000198C  0801 0002               3880mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001990  67F4                    3881mm         BEQ WAIT_FOR_READY_282                      ; NO SPACE, CHECK AGAIN
00001992  13D8 00C00007           3882mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001998                          3883mm     ENDC
00001998                          3884mm 
00001998                 FALSE    3885mm     IFNE DEBUG
00001998                          3886mm     ENDC
00001998                          3887mm 
00001998                          3888mm     ENDM
00001998  60E4                    3889m     BRA LOOP_281
0000199A                          3890m EXIT_281
0000199A                          3891m     ENDM
0000199A                          3892  
0000199A  7000                    3893      MOVE.L #0,D0
0000199C  3017                    3894      MOVE.W (SP),D0
0000199E                          3895  
0000199E  0800 0004               3896      BTST #4,D0
000019A2  6700 0026               3897      BEQ WRITE
000019A6                          3898      
000019A6  41FA 03C9               3899      LEA READING(PC),A0
000019AA                          3900m     PRINT_STR A0,D1
000019AA                          3901m LOOP_283
000019AA  0C10 0000               3902m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019AE  6700 0016               3903m     BEQ EXIT_283
000019B2                          3904mm     PRINT_CHAR (A0)+,D1
000019B2                          3905mm WAIT_FOR_READY_284                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019B2                 TRUE     3906mm     IFEQ DEBUG
000019B2  1239 00C00003           3907mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000019B8  0801 0002               3908mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000019BC  67F4                    3909mm         BEQ WAIT_FOR_READY_284                      ; NO SPACE, CHECK AGAIN
000019BE  13D8 00C00007           3910mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019C4                          3911mm     ENDC
000019C4                          3912mm 
000019C4                 FALSE    3913mm     IFNE DEBUG
000019C4                          3914mm     ENDC
000019C4                          3915mm 
000019C4                          3916mm     ENDM
000019C4  60E4                    3917m     BRA LOOP_283
000019C6                          3918m EXIT_283
000019C6                          3919m     ENDM
000019C6                          3920  
000019C6  6000 0022               3921      BRA CONTINUE    
000019CA                          3922  WRITE
000019CA  41FA 03AE               3923      LEA WRITING(PC),A0
000019CE                          3924m     PRINT_STR A0,D1
000019CE                          3925m LOOP_285
000019CE  0C10 0000               3926m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019D2  6700 0016               3927m     BEQ EXIT_285
000019D6                          3928mm     PRINT_CHAR (A0)+,D1
000019D6                          3929mm WAIT_FOR_READY_286                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019D6                 TRUE     3930mm     IFEQ DEBUG
000019D6  1239 00C00003           3931mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000019DC  0801 0002               3932mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000019E0  67F4                    3933mm         BEQ WAIT_FOR_READY_286                      ; NO SPACE, CHECK AGAIN
000019E2  13D8 00C00007           3934mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019E8                          3935mm     ENDC
000019E8                          3936mm 
000019E8                 FALSE    3937mm     IFNE DEBUG
000019E8                          3938mm     ENDC
000019E8                          3939mm 
000019E8                          3940mm     ENDM
000019E8  60E4                    3941m     BRA LOOP_285
000019EA                          3942m EXIT_285
000019EA                          3943m     ENDM
000019EA                          3944  
000019EA                          3945  CONTINUE
000019EA  222F 0002               3946      MOVE.L 2(SP),D1
000019EE                          3947m     PRINT_REG D1,D2,D3,D4,A0
000019EE  41FA 034D               3948m     LEA OX(PC),A0
000019F2                          3949mm     PRINT_STR A0,D2
000019F2                          3950mm LOOP_288
000019F2  0C10 0000               3951mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019F6  6700 0016               3952mm     BEQ EXIT_288
000019FA                          3953mmm     PRINT_CHAR (A0)+,D2
000019FA                          3954mmm WAIT_FOR_READY_289                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019FA                 TRUE     3955mmm     IFEQ DEBUG
000019FA  1439 00C00003           3956mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A00  0802 0002               3957mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A04  67F4                    3958mmm         BEQ WAIT_FOR_READY_289                      ; NO SPACE, CHECK AGAIN
00001A06  13D8 00C00007           3959mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A0C                          3960mmm     ENDC
00001A0C                          3961mmm 
00001A0C                 FALSE    3962mmm     IFNE DEBUG
00001A0C                          3963mmm     ENDC
00001A0C                          3964mmm 
00001A0C                          3965mmm     ENDM
00001A0C  60E4                    3966mm     BRA LOOP_288
00001A0E                          3967mm EXIT_288
00001A0E                          3968mm     ENDM
00001A0E  7807                    3969m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A10                          3970m LOOP_287
00001A10                          3971mm     BIN2HEX D1,D3,A0
00001A10  41FA 02EA               3972mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A14  E999                    3973mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A16  1601                    3974mm     MOVE.B D1,D3
00001A18  0283 0000000F           3975mm     ANDI.L #$F,D3
00001A1E  1630 3000               3976mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A22                          3977mm     ENDM
00001A22                          3978mm     PRINT_CHAR D3,D2
00001A22                          3979mm WAIT_FOR_READY_291                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A22                 TRUE     3980mm     IFEQ DEBUG
00001A22  1439 00C00003           3981mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A28  0802 0002               3982mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A2C  67F4                    3983mm         BEQ WAIT_FOR_READY_291                      ; NO SPACE, CHECK AGAIN
00001A2E  13C3 00C00007           3984mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001A34                          3985mm     ENDC
00001A34                          3986mm 
00001A34                 FALSE    3987mm     IFNE DEBUG
00001A34                          3988mm     ENDC
00001A34                          3989mm 
00001A34                          3990mm     ENDM
00001A34  57CC FFDA               3991m     DBEQ D4,LOOP_287
00001A38                          3992m     ENDM
00001A38                          3993  
00001A38  41FA 0349               3994      LEA FROM(PC),A0
00001A3C                          3995m     PRINT_STR A0,D0
00001A3C                          3996m LOOP_292
00001A3C  0C10 0000               3997m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A40  6700 0016               3998m     BEQ EXIT_292
00001A44                          3999mm     PRINT_CHAR (A0)+,D0
00001A44                          4000mm WAIT_FOR_READY_293                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A44                 TRUE     4001mm     IFEQ DEBUG
00001A44  1039 00C00003           4002mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001A4A  0800 0002               4003mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001A4E  67F4                    4004mm         BEQ WAIT_FOR_READY_293                      ; NO SPACE, CHECK AGAIN
00001A50  13D8 00C00007           4005mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A56                          4006mm     ENDC
00001A56                          4007mm 
00001A56                 FALSE    4008mm     IFNE DEBUG
00001A56                          4009mm     ENDC
00001A56                          4010mm 
00001A56                          4011mm     ENDM
00001A56  60E4                    4012m     BRA LOOP_292
00001A58                          4013m EXIT_292
00001A58                          4014m     ENDM
00001A58                          4015  
00001A58  222F 000A               4016      MOVE.L 10(SP),D1
00001A5C                          4017m     PRINT_REG D1,D2,D3,D4,A0
00001A5C  41FA 02DF               4018m     LEA OX(PC),A0
00001A60                          4019mm     PRINT_STR A0,D2
00001A60                          4020mm LOOP_295
00001A60  0C10 0000               4021mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A64  6700 0016               4022mm     BEQ EXIT_295
00001A68                          4023mmm     PRINT_CHAR (A0)+,D2
00001A68                          4024mmm WAIT_FOR_READY_296                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A68                 TRUE     4025mmm     IFEQ DEBUG
00001A68  1439 00C00003           4026mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A6E  0802 0002               4027mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A72  67F4                    4028mmm         BEQ WAIT_FOR_READY_296                      ; NO SPACE, CHECK AGAIN
00001A74  13D8 00C00007           4029mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A7A                          4030mmm     ENDC
00001A7A                          4031mmm 
00001A7A                 FALSE    4032mmm     IFNE DEBUG
00001A7A                          4033mmm     ENDC
00001A7A                          4034mmm 
00001A7A                          4035mmm     ENDM
00001A7A  60E4                    4036mm     BRA LOOP_295
00001A7C                          4037mm EXIT_295
00001A7C                          4038mm     ENDM
00001A7C  7807                    4039m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A7E                          4040m LOOP_294
00001A7E                          4041mm     BIN2HEX D1,D3,A0
00001A7E  41FA 027C               4042mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A82  E999                    4043mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A84  1601                    4044mm     MOVE.B D1,D3
00001A86  0283 0000000F           4045mm     ANDI.L #$F,D3
00001A8C  1630 3000               4046mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A90                          4047mm     ENDM
00001A90                          4048mm     PRINT_CHAR D3,D2
00001A90                          4049mm WAIT_FOR_READY_298                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A90                 TRUE     4050mm     IFEQ DEBUG
00001A90  1439 00C00003           4051mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A96  0802 0002               4052mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A9A  67F4                    4053mm         BEQ WAIT_FOR_READY_298                      ; NO SPACE, CHECK AGAIN
00001A9C  13C3 00C00007           4054mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001AA2                          4055mm     ENDC
00001AA2                          4056mm 
00001AA2                 FALSE    4057mm     IFNE DEBUG
00001AA2                          4058mm     ENDC
00001AA2                          4059mm 
00001AA2                          4060mm     ENDM
00001AA2  57CC FFDA               4061m     DBEQ D4,LOOP_294
00001AA6                          4062m     ENDM
00001AA6                          4063m     PRINT_CRLF D0,A0
00001AA6  41FA 028F               4064m     LEA CRLF(PC),A0
00001AAA                          4065mm     PRINT_STR A0,D0
00001AAA                          4066mm LOOP_300
00001AAA  0C10 0000               4067mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001AAE  6700 0016               4068mm     BEQ EXIT_300
00001AB2                          4069mmm     PRINT_CHAR (A0)+,D0
00001AB2                          4070mmm WAIT_FOR_READY_301                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001AB2                 TRUE     4071mmm     IFEQ DEBUG
00001AB2  1039 00C00003           4072mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001AB8  0800 0002               4073mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001ABC  67F4                    4074mmm         BEQ WAIT_FOR_READY_301                      ; NO SPACE, CHECK AGAIN
00001ABE  13D8 00C00007           4075mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AC4                          4076mmm     ENDC
00001AC4                          4077mmm 
00001AC4                 FALSE    4078mmm     IFNE DEBUG
00001AC4                          4079mmm     ENDC
00001AC4                          4080mmm 
00001AC4                          4081mmm     ENDM
00001AC4  60E4                    4082mm     BRA LOOP_300
00001AC6                          4083mm EXIT_300
00001AC6                          4084mm     ENDM
00001AC6                          4085m     ENDM
00001AC6                          4086      
00001AC6  207C 00000004           4087      MOVE.L #4,A0
00001ACC  4ED0                    4088      JMP (A0)
00001ACE                          4089          
00001ACE                          4090  ILLEGAL_HANDLER
00001ACE  13FC 0007 00E00001      4091      MOVE.B #7,DISPLAY   
00001AD6  207C 00000004           4092      MOVE.L #4,A0
00001ADC  4ED0                    4093      JMP (A0)
00001ADE                          4094          
00001ADE                          4095  UNHANDLED_HANDLER
00001ADE  41FA 02AA               4096      LEA UNHANDLED(PC),A0
00001AE2  4EF9 00001B06           4097      JMP PRINTIT_RTE
00001AE8                          4098      
00001AE8                          4099  UNINITIALISED_HANDLER
00001AE8  41FA 02B6               4100      LEA UNINITIALISED(PC),A0
00001AEC  4EF9 00001B06           4101      JMP PRINTIT_RTE
00001AF2                          4102  
00001AF2                          4103  TICK_HANDLER
00001AF2  1039 00C0001F           4104      MOVE.B DUART_RESET_OPR,D0
00001AF8  41FA 025B               4105      LEA TICK(PC),A0
00001AFC  4EF9 00001B06           4106      JMP PRINTIT_RTE
00001B02                          4107  
00001B02                          4108  SPURIOUS_HANDLER
00001B02  41FA 02BB               4109      LEA SPURIOUS(PC),A0
00001B06                          4110  PRINTIT_RTE
00001B06                          4111m     PRINT_STR A0,D1
00001B06                          4112m LOOP_302
00001B06  0C10 0000               4113m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001B0A  6700 0016               4114m     BEQ EXIT_302
00001B0E                          4115mm     PRINT_CHAR (A0)+,D1
00001B0E                          4116mm WAIT_FOR_READY_303                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B0E                 TRUE     4117mm     IFEQ DEBUG
00001B0E  1239 00C00003           4118mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001B14  0801 0002               4119mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001B18  67F4                    4120mm         BEQ WAIT_FOR_READY_303                      ; NO SPACE, CHECK AGAIN
00001B1A  13D8 00C00007           4121mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001B20                          4122mm     ENDC
00001B20                          4123mm 
00001B20                 FALSE    4124mm     IFNE DEBUG
00001B20                          4125mm     ENDC
00001B20                          4126mm 
00001B20                          4127mm     ENDM
00001B20  60E4                    4128m     BRA LOOP_302
00001B22                          4129m EXIT_302
00001B22                          4130m     ENDM
00001B22  4E73                    4131      RTE 
00001B24                          4132      
00001B24  FFFF FFFF               4133      SIMHALT                                             ; halt simulator
00001B28                          4134  
00001B28                          4135  ; strings
00001B28= 50 72 65 73 73 20 ...   4136  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001B3B= 5B 3F 5D 09 09 09 ...   4137  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001B47= 5B 76 5D 09 09 09 ...   4138          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001B56= 78 78 78 78 78 78 ...   4139          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001B6E= 78 78 78 78 78 78 ...   4140          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001B8E= 78 78 78 78 78 78 ...   4141          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001BAF= 78 78 78 78 78 78 ...   4142          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001BC0= 5B 7A 5D 09 09 09 ...   4143          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001BD2= 78 78 78 78 78 78 ...   4144          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001BF6= 78 78 78 78 78 78 ...   4145          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001C18= 23 09 09 09 77 72 ...   4146          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001C32= 5B 78 5D 09 09 09 ...   4147          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001C49= 5B 69 5D 09 09 09 ...   4148          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001C62= 5B 6F 5D 09 09 09 ...   4149          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001C7C= 78 78 78 78 78 78 ...   4150          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001C9A= 48 75 68 3F 0D 0A 00    4151  HUH  DC.B 'Huh?',CR,LF,NULL
00001CA1= 20 53 20 72 65 63 ...   4152  READ    DC.B ' S records read, start address = ',NULL
00001CC3= 57 3A 20 55 6E 6B ...   4153  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001CDA= 21 20 43 53 20 66 ...   4154  CS_FAILURE  DC.B '! CS failure at ',NULL
00001CEB= 21 20 52 41 4D 20 ...   4155  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001CFC= 30 31 32 33 34 35 ...   4156  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001D0C= 00 01 02 03 04 05 ...   4157  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001D23= 4C 6F 61 64 69 6E ...   4158  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001D37= 0D 0A 00                4159  CRLF    DC.B CR,LF,NULL
00001D3A= 3E 20 00                4160  PROMPT  DC.B '> ',NULL
00001D3D= 30 78 00                4161  ox      DC.B '0x',NULL
00001D40= 20 2D 3E 20 00          4162  to      DC.B ' -> ',NULL
00001D45= 20 66 6F 72 20 00       4163  for     DC.B ' for ',NULL
00001D4B= 53 50 3A 20 00          4164  STACK_POINTER DC.B 'SP: ',NULL
00001D50= 53 52 3A 20 00          4165  STATUS_REGISTER DC.B 'SR: ',NULL
00001D55= 74 69 63 6B 0D 0A 00    4166  TICK DC.B 'tick',CR,LF,NULL
00001D5C= 2A 20 42 75 73 2F ...   4167  BUS_ERROR DC.B '* Bus/address error ',NULL
00001D71= 72 65 61 64 69 6E ...   4168  READING DC.B 'reading ',NULL
00001D7A= 77 72 69 74 69 6E ...   4169  WRITING DC.B 'writing ',NULL
00001D83= 20 66 72 6F 6D 20 00    4170  FROM DC.B ' from ',NULL
00001D8A= 2A 20 55 6E 68 61 ...   4171  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001DA0= 2A 20 55 6E 69 74 ...   4172  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00001DBF= 2A 20 53 70 75 72 ...   4173  SPURIOUS DC.B '* Spurious interrupt',NULL
00001DD4= 4D 44 46 2D 6D 6F ...   4174  VERSION DC.B 'MDF-mon V1.140 (25/05/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001DF2= 00                      4175  END     DC.B 0
00001DF3                          4176      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B                   1412
BIN2HEX             0
BIN2HEX_LUT         1CFC
BUS_ERROR           1D5C
BUS_ERROR_HANDLER   197A
CONTINUE            19EA
CONTINUE_113        B34
CONTINUE_54         610
CONTINUE_57         660
CONTINUE_61         6B6
CONTINUE_69         76A
CONTINUE_74         7DC
CONTINUE_79         858
CONTINUE_84         8D6
CONTINUE_89         95E
CONTINUE_94         9D0
CONTINUE_99         A42
CR                  D
CRLF                1D37
CS_FAILURE          1CDA
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C3E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1DF2
EXIT_10             288
EXIT_104            AB4
EXIT_106            AD4
EXIT_110            B06
EXIT_118            B9C
EXIT_120            BC4
EXIT_123            BE4
EXIT_128            C2E
EXIT_131            C5E
EXIT_135            CA8
EXIT_138            CCA
EXIT_143            D14
EXIT_145            D90
EXIT_148            DB4
EXIT_15             2D2
EXIT_153            DFE
EXIT_160            E90
EXIT_163            F00
EXIT_166            F22
EXIT_17             2F2
EXIT_170            F6C
EXIT_173            F8E
EXIT_177            FD8
EXIT_180            FF8
EXIT_185            1042
EXIT_20             312
EXIT_200            1164
EXIT_203            11C8
EXIT_206            11E8
EXIT_210            1232
EXIT_213            1254
EXIT_218            129E
EXIT_22             364
EXIT_222            12E0
EXIT_225            1302
EXIT_230            134C
EXIT_232            136C
EXIT_235            138E
EXIT_240            13D8
EXIT_278            195C
EXIT_28             3F0
EXIT_281            199A
EXIT_283            19C6
EXIT_285            19EA
EXIT_288            1A0E
EXIT_292            1A58
EXIT_295            1A7C
EXIT_30             468
EXIT_300            1AC6
EXIT_302            1B22
EXIT_32             494
EXIT_35             4BE
EXIT_45             56C
EXIT_5              240
EXIT_52             5E2
EXIT_66             726
EXIT_7              260
FOR                 1D45
FROM                1D83
G                   D18
GET_INPUT           364
H                   46C
HASH                13FC
HELP                1B3B
HELPPROMPT          1B28
HEX2BIN             10B
HEX2BIN_LUT         1D0C
HEX_DIGIT           1960
HUH                 1C9A
I                   13DC
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1ACE
L                   E0E
LF                  A
LOADING             1D23
LOOP_10             26C
LOOP_104            A98
LOOP_106            AB8
LOOP_110            AEA
LOOP_118            B80
LOOP_120            BA8
LOOP_122            BE6
LOOP_123            BC8
LOOP_128            C12
LOOP_130            C60
LOOP_131            C42
LOOP_135            C8C
LOOP_137            CCC
LOOP_138            CAE
LOOP_143            CF8
LOOP_145            D74
LOOP_147            DB6
LOOP_148            D98
LOOP_15             2B6
LOOP_153            DE2
LOOP_160            E74
LOOP_163            EE4
LOOP_165            F24
LOOP_166            F06
LOOP_17             2D6
LOOP_170            F50
LOOP_172            F90
LOOP_173            F72
LOOP_177            FBC
LOOP_179            FFA
LOOP_180            FDC
LOOP_185            1026
LOOP_20             2F6
LOOP_200            1148
LOOP_203            11AC
LOOP_205            11EA
LOOP_206            11CC
LOOP_210            1216
LOOP_212            1256
LOOP_213            1238
LOOP_218            1282
LOOP_22             348
LOOP_222            12C4
LOOP_224            1304
LOOP_225            12E6
LOOP_230            1330
LOOP_232            1350
LOOP_234            1390
LOOP_235            1372
LOOP_240            13BC
LOOP_244            1454
LOOP_248            14A0
LOOP_260            1678
LOOP_263            16B6
LOOP_278            1940
LOOP_28             3D4
LOOP_281            197E
LOOP_283            19AA
LOOP_285            19CE
LOOP_287            1A10
LOOP_288            19F2
LOOP_292            1A3C
LOOP_294            1A7E
LOOP_295            1A60
LOOP_30             44C
LOOP_300            1AAA
LOOP_302            1B06
LOOP_32             478
LOOP_34             4C0
LOOP_35             4A2
LOOP_45             550
LOOP_5              224
LOOP_52             5C6
LOOP_66             70A
LOOP_7              244
LOOP_9              28A
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NULL                0
O                   13EC
OX                  1D3D
P                   10F0
PRINTIT             478
PRINTIT_RTE         1B06
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1D3A
PROTECT             A40
R                   498
RAM                 200000
RAM_ERROR           1CEB
READ                1CA1
READING             1D71
READ_16             10D7
READ_32             1304
READ_8              D62
READ_CHAR           62D
READ_IDE_STATUS     1353
RESET               4
ROM                 0
S                   5EA
SEND_COMMAND        15D5
SEND_READ_COMMAND_AND_WAIT  1604
SET_READ_ADDRESS    1473
SPURIOUS            1DBF
SPURIOUS_HANDLER    1B02
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1D4B
START               104
STATUS_REGISTER     1D50
TAB                 9
TICK                1D55
TICK_HANDLER        1AF2
TO                  1D40
UNHANDLED           1D8A
UNHANDLED_HANDLER   1ADE
UNINITIALISED       1DA0
UNINITIALISED_HANDLER  1AE8
UNPROTECT           979
UNREC               1CC3
USER                100
V                   474
VECS                8
VERSION             1DD4
W                   570
WAIT_CHAR           4E9
WAIT_DRIVE_DRQ      1423
WAIT_DRIVE_NOT_BUSY  13D2
WAIT_DRIVE_READY    1380
WAIT_FOR_COMPLETE_187  1054
WAIT_FOR_COMPLETE_189  1076
WAIT_FOR_COMPLETE_190  1088
WAIT_FOR_COMPLETE_192  10B6
WAIT_FOR_COMPLETE_193  10C8
WAIT_FOR_COMPLETE_220  12A0
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A5A
WAIT_FOR_READY_105  AA0
WAIT_FOR_READY_107  AC0
WAIT_FOR_READY_108  AD4
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AF2
WAIT_FOR_READY_113  B18
WAIT_FOR_READY_115  B4C
WAIT_FOR_READY_119  B88
WAIT_FOR_READY_121  BB0
WAIT_FOR_READY_124  BD0
WAIT_FOR_READY_126  BF8
WAIT_FOR_READY_129  C1A
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_132  C4A
WAIT_FOR_READY_134  C72
WAIT_FOR_READY_136  C94
WAIT_FOR_READY_139  CB6
WAIT_FOR_READY_141  CDE
WAIT_FOR_READY_144  D00
WAIT_FOR_READY_146  D7C
WAIT_FOR_READY_149  DA0
WAIT_FOR_READY_151  DC8
WAIT_FOR_READY_154  DEA
WAIT_FOR_READY_155  E1C
WAIT_FOR_READY_157  E36
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E7C
WAIT_FOR_READY_164  EEC
WAIT_FOR_READY_167  F0E
WAIT_FOR_READY_169  F36
WAIT_FOR_READY_171  F58
WAIT_FOR_READY_174  F7A
WAIT_FOR_READY_176  FA2
WAIT_FOR_READY_178  FC4
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_181  FE4
WAIT_FOR_READY_183  100C
WAIT_FOR_READY_186  102E
WAIT_FOR_READY_195  10FC
WAIT_FOR_READY_197  1116
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  1150
WAIT_FOR_READY_204  11B4
WAIT_FOR_READY_207  11D4
WAIT_FOR_READY_209  11FC
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  121E
WAIT_FOR_READY_214  1240
WAIT_FOR_READY_216  1268
WAIT_FOR_READY_219  128A
WAIT_FOR_READY_223  12CC
WAIT_FOR_READY_226  12EE
WAIT_FOR_READY_228  1316
WAIT_FOR_READY_23   350
WAIT_FOR_READY_231  1338
WAIT_FOR_READY_233  1358
WAIT_FOR_READY_236  137A
WAIT_FOR_READY_238  13A2
WAIT_FOR_READY_24   364
WAIT_FOR_READY_241  13C4
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_266  16F4
WAIT_FOR_READY_279  1948
WAIT_FOR_READY_282  1986
WAIT_FOR_READY_284  19B2
WAIT_FOR_READY_286  19D6
WAIT_FOR_READY_289  19FA
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_291  1A22
WAIT_FOR_READY_293  1A44
WAIT_FOR_READY_296  1A68
WAIT_FOR_READY_298  1A90
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_301  1AB2
WAIT_FOR_READY_303  1B0E
WAIT_FOR_READY_31   454
WAIT_FOR_READY_33   480
WAIT_FOR_READY_36   4AA
WAIT_FOR_READY_38   4D2
WAIT_FOR_READY_39   4E8
WAIT_FOR_READY_40   4FE
WAIT_FOR_READY_41   512
WAIT_FOR_READY_42   526
WAIT_FOR_READY_43   53A
WAIT_FOR_READY_46   558
WAIT_FOR_READY_47   57A
WAIT_FOR_READY_49   594
WAIT_FOR_READY_53   5CE
WAIT_FOR_READY_54   5F4
WAIT_FOR_READY_56   62E
WAIT_FOR_READY_57   644
WAIT_FOR_READY_59   678
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   69A
WAIT_FOR_READY_63   6CE
WAIT_FOR_READY_67   712
WAIT_FOR_READY_69   74E
WAIT_FOR_READY_71   782
WAIT_FOR_READY_74   7C0
WAIT_FOR_READY_76   7F4
WAIT_FOR_READY_79   83C
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_81   870
WAIT_FOR_READY_84   8BA
WAIT_FOR_READY_86   8EE
WAIT_FOR_READY_89   942
WAIT_FOR_READY_91   976
WAIT_FOR_READY_94   9B4
WAIT_FOR_READY_96   9E8
WAIT_FOR_READY_99   A26
WAIT_FOR_SRECORD    5F4
WRITE               19CA
WRITE_8             F1B
WRITING             1D7A
X                   12C0
Z                   D1E
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           72E
_00000004           B0A
_00000005           73C
_00000006           92A
_00000007           8A0
_00000008           B0A
_00000009           A94
_0000000A           B0A
_0000000B           C32
_0000000C           C3E
_0000000D           DFE
_0000000E           105E
_0000000F           1080
_00000010           1092
_00000011           10C0
_00000012           10D2
_00000013           12AA
_00000014           18D6
_00000015           18D8
_10000000           690
_10000001           6F8
_10000002           744
_10000003           7AC
_10000004           7B6
_10000005           81E
_10000006           832
_10000007           89A
_10000008           8A4
_10000009           924
_1000000A           8B0
_1000000B           918
_1000000C           938
_1000000D           9A0
_1000000E           9AA
_1000000F           A12
_10000010           A1C
_10000011           A84
_10000012           B0E
_10000013           B76
_10000014           1042
_10000015           1064
_10000016           1498
_10000017           193C
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           578
_20000005           5BC
_20000006           D30
_20000007           D40
_20000008           D5A
_20000009           E00
_2000000A           E1A
_2000000B           E5E
_2000000C           ED6
_2000000D           EDA
_2000000E           109A
_2000000F           10D4
_20000010           10FA
_20000011           113E
_20000012           119E
_20000013           11A2
_20000014           18DE
_20000015           192C
