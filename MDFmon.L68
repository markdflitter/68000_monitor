00000010 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 25/04/2021 09:25:04

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 002FFFFC                 270  STACK   DC.L $2FFFFC                                ; STACK
00000004= 00000010                 271  RESET   DC.L START                                  ; RESET
00000008= 000012D2                 272  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 000012D2                 273          DC.L BUS_ERROR_HANDLER                      ; ADDRESS ERROR
00000010                           274  
00000010                           275  ; start of program  
00000010                           276  START
00000010  13FC 0000 00E00001       277      MOVE.B #0,DISPLAY
00000018                           278  
00000018  2E7C 002FFFFC            279      MOVE.L #$2FFFFC,A7                              ; reset the stack pointer, in case we got here through a bus error
0000001E                           280  
0000001E                           281  ; reset the UART in case of warm start
0000001E  13FC 000A 00C00005       282      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000026  13FC 000A 00C00015       283      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000002E                           284      
0000002E                           285      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000002E  323C 0050                286s     MOVE.W  #$50,D1
00000032  6000 000E                287s     BRA _20000001
00000036                           288s _20000000
00000036  13C1 00C00005            289          MOVE.B D1,DUART_CRA                         ; reset everyting
0000003C  4E71                     290          NOP
0000003E                           291      ENDF
0000003E  0441 0010                292s     SUB.W   #$10,D1
00000042                           293s _20000001
00000042  B27C 0010                294s     CMP.W   #$10,D1
00000046  6CEE                     295s     BGE _20000000
00000048                           296  
00000048                           297      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000048  323C 0050                298s     MOVE.W  #$50,D1
0000004C  6000 000E                299s     BRA _20000003
00000050                           300s _20000002
00000050  13C1 00C00015            301          MOVE.B D1,DUART_CRB                         ; reset everyting
00000056  4E71                     302          NOP
00000058                           303      ENDF
00000058  0441 0010                304s     SUB.W   #$10,D1
0000005C                           305s _20000003
0000005C  B27C 0010                306s     CMP.W   #$10,D1
00000060  6CEE                     307s     BGE _20000002
00000062                           308      
00000062                           309  ;initialise UART
00000062  13FC 0000 00C00009       310      MOVE.B #$0,DUART_ACR
0000006A  13FC 0000 00C0000B       311      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000072  13FC 0000 00C0001B       312      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000007A                           313  
0000007A                           314  ; channel A
0000007A  13FC 0013 00C00001       315      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000082  13FC 0007 00C00001       316      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000008A  13FC 00CC 00C00003       317      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000092  13FC 0005 00C00005       318      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000009A                           319  
0000009A                           320  ; channel B
0000009A  13FC 0013 00C00011       321      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000000A2  13FC 0007 00C00011       322      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000000AA  13FC 00CC 00C00013       323      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000B2  13FC 0005 00C00015       324      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000BA                           325  
000000BA                           326m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000BA                           327m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000BA                 TRUE      328m     IFEQ DEBUG
000000BA  1239 00C00003            329m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C0  0801 0002                330m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000C4  67F4                     331m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000C6  13FC 0000 00C00007       332m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000CE                           333m     ENDC
000000CE                           334m 
000000CE                 FALSE     335m     IFNE DEBUG
000000CE                           336m     ENDC
000000CE                           337m 
000000CE                           338m     ENDM
000000CE                           339m     PRINT_CHAR #0,D1
000000CE                           340m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000CE                 TRUE      341m     IFEQ DEBUG
000000CE  1239 00C00003            342m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000D4  0801 0002                343m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000D8  67F4                     344m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000DA  13FC 0000 00C00007       345m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E2                           346m     ENDC
000000E2                           347m 
000000E2                 FALSE     348m     IFNE DEBUG
000000E2                           349m     ENDC
000000E2                           350m 
000000E2                           351m     ENDM
000000E2                           352m     PRINT_CHAR #0,D1
000000E2                           353m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E2                 TRUE      354m     IFEQ DEBUG
000000E2  1239 00C00003            355m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000E8  0801 0002                356m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000EC  67F4                     357m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000EE  13FC 0000 00C00007       358m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000F6                           359m     ENDC
000000F6                           360m 
000000F6                 FALSE     361m     IFNE DEBUG
000000F6                           362m     ENDC
000000F6                           363m 
000000F6                           364m     ENDM
000000F6                           365  
000000F6  13FC 0001 00E00001       366      MOVE.B #1,DISPLAY
000000FE                           367      
000000FE                           368m     PRINT_CRLF D1,A0
000000FE  41FA 14E9                369m     LEA CRLF(PC),A0
00000102                           370mm     PRINT_STR A0,D1
00000102                           371mm LOOP_5
00000102  0C10 0000                372mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000106  6700 0016                373mm     BEQ EXIT_5
0000010A                           374mmm     PRINT_CHAR (A0)+,D1
0000010A                           375mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000010A                 TRUE      376mmm     IFEQ DEBUG
0000010A  1239 00C00003            377mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000110  0801 0002                378mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000114  67F4                     379mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000116  13D8 00C00007            380mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000011C                           381mmm     ENDC
0000011C                           382mmm 
0000011C                 FALSE     383mmm     IFNE DEBUG
0000011C                           384mmm     ENDC
0000011C                           385mmm 
0000011C                           386mmm     ENDM
0000011C  60E4                     387mm     BRA LOOP_5
0000011E                           388mm EXIT_5
0000011E                           389mm     ENDM
0000011E                           390m     ENDM
0000011E  41FA 150F                391      LEA VERSION(PC),A0
00000122                           392m     PRINT_STR A0,D3
00000122                           393m LOOP_7
00000122  0C10 0000                394m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000126  6700 0016                395m     BEQ EXIT_7
0000012A                           396mm     PRINT_CHAR (A0)+,D3
0000012A                           397mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      398mm     IFEQ DEBUG
0000012A  1639 00C00003            399mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000130  0803 0002                400mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000134  67F4                     401mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            402mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000013C                           403mm     ENDC
0000013C                           404mm 
0000013C                 FALSE     405mm     IFNE DEBUG
0000013C                           406mm     ENDC
0000013C                           407mm 
0000013C                           408mm     ENDM
0000013C  60E4                     409m     BRA LOOP_7
0000013E                           410m EXIT_7
0000013E                           411m     ENDM
0000013E                           412  
0000013E  41F9 0000164D            413      LEA END,A0
00000144  2008                     414      MOVE.L A0,D0
00000146                           415m     PRINT_REG D0,D1,D2,D3,A0
00000146  41FA 14A7                416m     LEA OX(PC),A0
0000014A                           417mm     PRINT_STR A0,D1
0000014A                           418mm LOOP_10
0000014A  0C10 0000                419mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000014E  6700 0016                420mm     BEQ EXIT_10
00000152                           421mmm     PRINT_CHAR (A0)+,D1
00000152                           422mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      423mmm     IFEQ DEBUG
00000152  1239 00C00003            424mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000158  0801 0002                425mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000015C  67F4                     426mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
0000015E  13D8 00C00007            427mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000164                           428mmm     ENDC
00000164                           429mmm 
00000164                 FALSE     430mmm     IFNE DEBUG
00000164                           431mmm     ENDC
00000164                           432mmm 
00000164                           433mmm     ENDM
00000164  60E4                     434mm     BRA LOOP_10
00000166                           435mm EXIT_10
00000166                           436mm     ENDM
00000166  7607                     437m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000168                           438m LOOP_9
00000168                           439mm     BIN2HEX D0,D2,A0
00000168  41FA 1442                440mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000016C  E998                     441mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000016E  1400                     442mm     MOVE.B D0,D2
00000170  0282 0000000F            443mm     ANDI.L #$F,D2
00000176  1430 2000                444mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000017A                           445mm     ENDM
0000017A                           446mm     PRINT_CHAR D2,D1
0000017A                           447mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000017A                 TRUE      448mm     IFEQ DEBUG
0000017A  1239 00C00003            449mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000180  0801 0002                450mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000184  67F4                     451mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000186  13C2 00C00007            452mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000018C                           453mm     ENDC
0000018C                           454mm 
0000018C                 FALSE     455mm     IFNE DEBUG
0000018C                           456mm     ENDC
0000018C                           457mm 
0000018C                           458mm     ENDM
0000018C  57CB FFDA                459m     DBEQ D3,LOOP_9
00000190                           460m     ENDM
00000190                           461m     PRINT_CRLF D1,A0
00000190  41FA 1457                462m     LEA CRLF(PC),A0
00000194                           463mm     PRINT_STR A0,D1
00000194                           464mm LOOP_15
00000194  0C10 0000                465mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000198  6700 0016                466mm     BEQ EXIT_15
0000019C                           467mmm     PRINT_CHAR (A0)+,D1
0000019C                           468mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019C                 TRUE      469mmm     IFEQ DEBUG
0000019C  1239 00C00003            470mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001A2  0801 0002                471mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001A6  67F4                     472mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000001A8  13D8 00C00007            473mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001AE                           474mmm     ENDC
000001AE                           475mmm 
000001AE                 FALSE     476mmm     IFNE DEBUG
000001AE                           477mmm     ENDC
000001AE                           478mmm 
000001AE                           479mmm     ENDM
000001AE  60E4                     480mm     BRA LOOP_15
000001B0                           481mm EXIT_15
000001B0                           482mm     ENDM
000001B0                           483m     ENDM
000001B0                           484  
000001B0  41FA 1272                485      LEA HELPPROMPT(PC),A0
000001B4                           486m     PRINT_STR A0,D3
000001B4                           487m LOOP_17
000001B4  0C10 0000                488m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001B8  6700 0016                489m     BEQ EXIT_17
000001BC                           490mm     PRINT_CHAR (A0)+,D3
000001BC                           491mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001BC                 TRUE      492mm     IFEQ DEBUG
000001BC  1639 00C00003            493mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001C2  0803 0002                494mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001C6  67F4                     495mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C8  13D8 00C00007            496mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001CE                           497mm     ENDC
000001CE                           498mm 
000001CE                 FALSE     499mm     IFNE DEBUG
000001CE                           500mm     ENDC
000001CE                           501mm 
000001CE                           502mm     ENDM
000001CE  60E4                     503m     BRA LOOP_17
000001D0                           504m EXIT_17
000001D0                           505m     ENDM
000001D0                           506  
000001D0                           507m     PRINT_CRLF D3,A0
000001D0  41FA 1417                508m     LEA CRLF(PC),A0
000001D4                           509mm     PRINT_STR A0,D3
000001D4                           510mm LOOP_20
000001D4  0C10 0000                511mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001D8  6700 0016                512mm     BEQ EXIT_20
000001DC                           513mmm     PRINT_CHAR (A0)+,D3
000001DC                           514mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001DC                 TRUE      515mmm     IFEQ DEBUG
000001DC  1639 00C00003            516mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001E2  0803 0002                517mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001E6  67F4                     518mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
000001E8  13D8 00C00007            519mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001EE                           520mmm     ENDC
000001EE                           521mmm 
000001EE                 FALSE     522mmm     IFNE DEBUG
000001EE                           523mmm     ENDC
000001EE                           524mmm 
000001EE                           525mmm     ENDM
000001EE  60E4                     526mm     BRA LOOP_20
000001F0                           527mm EXIT_20
000001F0                           528mm     ENDM
000001F0                           529m     ENDM
000001F0                           530  
000001F0  7E00                     531      MOVE.L #0,D7                                    ; address accumulator
000001F2                           532  
000001F2  13FC 0002 00E00001       533      MOVE.B #2,DISPLAY
000001FA                           534  MAIN_LOOP
000001FA  41FA 13F0                535      LEA PROMPT(PC),A0
000001FE                           536m     PRINT_STR A0,D3
000001FE                           537m LOOP_22
000001FE  0C10 0000                538m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000202  6700 0016                539m     BEQ EXIT_22
00000206                           540mm     PRINT_CHAR (A0)+,D3
00000206                           541mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000206                 TRUE      542mm     IFEQ DEBUG
00000206  1639 00C00003            543mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000020C  0803 0002                544mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000210  67F4                     545mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000212  13D8 00C00007            546mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000218                           547mm     ENDC
00000218                           548mm 
00000218                 FALSE     549mm     IFNE DEBUG
00000218                           550mm     ENDC
00000218                           551mm 
00000218                           552mm     ENDM
00000218  60E4                     553m     BRA LOOP_22
0000021A                           554m EXIT_22
0000021A                           555m     ENDM
0000021A                           556  
0000021A                           557  GET_INPUT
0000021A                           558m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000021A                           559m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      560m     IFEQ DEBUG
0000021A  1639 00C00003            561m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0000                562m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000224  67F4                     563m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000226                           564m     ENDC
00000226                           565m 
00000226                           566mm     READ_CHAR D2
00000226                 TRUE      567mm     IFEQ DEBUG
00000226  1439 00C00007            568mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000022C                           569mm     ENDC
0000022C                 FALSE     570mm     IFNE DEBUG
0000022C                           571mm     ENDC
0000022C                           572mm 
0000022C  B43C 001B                573mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000230  6700 FDDE                574mm     BEQ START
00000234                           575mm     ENDM
00000234                           576m 
00000234                 TRUE      577m     IFEQ DEBUG
00000234                           578mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000234                           579mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000234                 TRUE      580mm     IFEQ DEBUG
00000234  1639 00C00003            581mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000023A  0803 0002                582mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000023E  67F4                     583mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000240  13C2 00C00007            584mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000246                           585mm     ENDC
00000246                           586mm 
00000246                 FALSE     587mm     IFNE DEBUG
00000246                           588mm     ENDC
00000246                           589mm 
00000246                           590mm     ENDM
00000246                           591m     ENDC
00000246                           592m     ENDM
00000246                           593  
00000246                           594      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000246  B43C 0030                595s     CMP.B   #'0',D2
0000024A  6D00 000E                596s     BLT _00000000
0000024E  B43C 0039                597s     CMP.B   #'9',D2
00000252  6E00 0006                598s     BGT _00000000
00000256  6000 105C                599          BRA HEX_DIGIT
0000025A                           600      ENDI
0000025A                           601s _00000000
0000025A                           602      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000025A  B43C 0041                603s     CMP.B   #'A',D2
0000025E  6D00 000E                604s     BLT _00000001
00000262  B43C 0046                605s     CMP.B   #'F',D2
00000266  6E00 0006                606s     BGT _00000001
0000026A  6000 1048                607          BRA HEX_DIGIT
0000026E                           608      ENDI
0000026E                           609s _00000001
0000026E                           610  
0000026E  B43C 0077                611      CMP.B #'w',D2
00000272  6700 019A                612      BEQ W
00000276                           613  
00000276  B43C 006C                614      CMP.B #'l',D2
0000027A  6700 0A30                615      BEQ L 
0000027E                           616  
0000027E  B43C 0070                617      CMP.B #'p',D2
00000282  6700 0CBE                618      BEQ P
00000286                           619  
00000286  B43C 006D                620      CMP.B #'m',D2
0000028A  6700 0E74                621      BEQ M
0000028E                           622  
0000028E                           623m     PRINT_CRLF D3,A0
0000028E  41FA 1359                624m     LEA CRLF(PC),A0
00000292                           625mm     PRINT_STR A0,D3
00000292                           626mm LOOP_28
00000292  0C10 0000                627mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000296  6700 0016                628mm     BEQ EXIT_28
0000029A                           629mmm     PRINT_CHAR (A0)+,D3
0000029A                           630mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029A                 TRUE      631mmm     IFEQ DEBUG
0000029A  1639 00C00003            632mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002A0  0803 0002                633mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A4  67F4                     634mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000002A6  13D8 00C00007            635mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002AC                           636mmm     ENDC
000002AC                           637mmm 
000002AC                 FALSE     638mmm     IFNE DEBUG
000002AC                           639mmm     ENDC
000002AC                           640mmm 
000002AC                           641mmm     ENDM
000002AC  60E4                     642mm     BRA LOOP_28
000002AE                           643mm EXIT_28
000002AE                           644mm     ENDM
000002AE                           645m     ENDM
000002AE                           646   
000002AE  B43C 003F                647      CMP.B #'?',D2
000002B2  6700 0056                648      BEQ H
000002B6                           649   
000002B6  B43C 0076                650      CMP.B #'v',D2
000002BA  6700 0056                651      BEQ V
000002BE                           652      
000002BE  B43C 0072                653      CMP.B #'r',D2
000002C2  6700 0072                654      BEQ R
000002C6                           655  
000002C6  B43C 0073                656      CMP.B #'s',D2
000002CA  6700 01BE                657      BEQ S
000002CE                           658  
000002CE  B43C 0067                659      CMP.B #'g',D2
000002D2  6700 08E2                660      BEQ G   
000002D6                           661  
000002D6  B43C 007A                662      CMP.B #'z',D2
000002DA  6700 08E0                663      BEQ Z   
000002DE                           664  
000002DE  B43C 0078                665      CMP.B #'x',D2
000002E2  6700 0EB4                666      BEQ X
000002E6                           667  
000002E6  41FA 1262                668      LEA HUH(PC),A0
000002EA                           669m     PRINT_STR A0,D3
000002EA                           670m LOOP_30
000002EA  0C10 0000                671m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002EE  6700 0016                672m     BEQ EXIT_30
000002F2                           673mm     PRINT_CHAR (A0)+,D3
000002F2                           674mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F2                 TRUE      675mm     IFEQ DEBUG
000002F2  1639 00C00003            676mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002F8  0803 0002                677mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002FC  67F4                     678mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
000002FE  13D8 00C00007            679mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000304                           680mm     ENDC
00000304                           681mm 
00000304                 FALSE     682mm     IFNE DEBUG
00000304                           683mm     ENDC
00000304                           684mm 
00000304                           685mm     ENDM
00000304  60E4                     686m     BRA LOOP_30
00000306                           687m EXIT_30
00000306                           688m     ENDM
00000306                           689  
00000306  6000 FEF2                690      BRA MAIN_LOOP
0000030A                           691  
0000030A                           692  ; commands
0000030A                           693  H
0000030A  41FA 112B                694      LEA HELP(PC),A0
0000030E  6000 0006                695      BRA PRINTSTR
00000312                           696  
00000312                           697  V
00000312  41FA 131B                698      LEA VERSION(PC),A0
00000316                           699  PRINTSTR
00000316                           700m     PRINT_STR A0,D3    
00000316                           701m LOOP_32
00000316  0C10 0000                702m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000031A  6700 0016                703m     BEQ EXIT_32
0000031E                           704mm     PRINT_CHAR (A0)+,D3
0000031E                           705mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031E                 TRUE      706mm     IFEQ DEBUG
0000031E  1639 00C00003            707mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000324  0803 0002                708mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000328  67F4                     709mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000032A  13D8 00C00007            710mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000330                           711mm     ENDC
00000330                           712mm 
00000330                 FALSE     713mm     IFNE DEBUG
00000330                           714mm     ENDC
00000330                           715mm 
00000330                           716mm     ENDM
00000330  60E4                     717m     BRA LOOP_32
00000332                           718m EXIT_32
00000332                           719m     ENDM
00000332  6000 FEC6                720      BRA MAIN_LOOP
00000336                           721  
00000336                           722  R
00000336  2047                     723      MOVE.L D7,A0                                    ; address accumulator -> address register
00000338  7E00                     724      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000033A  2410                     725      MOVE.L (A0),D2                                  ; read the memory and print it
0000033C                           726m     PRINT_REG D2,D3,D4,D5,A0
0000033C  41FA 12B1                727m     LEA OX(PC),A0
00000340                           728mm     PRINT_STR A0,D3
00000340                           729mm LOOP_35
00000340  0C10 0000                730mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000344  6700 0016                731mm     BEQ EXIT_35
00000348                           732mmm     PRINT_CHAR (A0)+,D3
00000348                           733mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000348                 TRUE      734mmm     IFEQ DEBUG
00000348  1639 00C00003            735mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000034E  0803 0002                736mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000352  67F4                     737mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
00000354  13D8 00C00007            738mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000035A                           739mmm     ENDC
0000035A                           740mmm 
0000035A                 FALSE     741mmm     IFNE DEBUG
0000035A                           742mmm     ENDC
0000035A                           743mmm 
0000035A                           744mmm     ENDM
0000035A  60E4                     745mm     BRA LOOP_35
0000035C                           746mm EXIT_35
0000035C                           747mm     ENDM
0000035C  7A07                     748m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000035E                           749m LOOP_34
0000035E                           750mm     BIN2HEX D2,D4,A0
0000035E  41FA 124C                751mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000362  E99A                     752mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000364  1802                     753mm     MOVE.B D2,D4
00000366  0284 0000000F            754mm     ANDI.L #$F,D4
0000036C  1830 4000                755mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000370                           756mm     ENDM
00000370                           757mm     PRINT_CHAR D4,D3
00000370                           758mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000370                 TRUE      759mm     IFEQ DEBUG
00000370  1639 00C00003            760mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000376  0803 0002                761mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000037A  67F4                     762mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
0000037C  13C4 00C00007            763mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000382                           764mm     ENDC
00000382                           765mm 
00000382                 FALSE     766mm     IFNE DEBUG
00000382                           767mm     ENDC
00000382                           768mm 
00000382                           769mm     ENDM
00000382  57CD FFDA                770m     DBEQ D5,LOOP_34
00000386                           771m     ENDM
00000386                           772      
00000386                           773m     PRINT_CHAR #32,D3
00000386                           774m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000386                 TRUE      775m     IFEQ DEBUG
00000386  1639 00C00003            776m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000038C  0803 0002                777m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000390  67F4                     778m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000392  13FC 0020 00C00007       779m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000039A                           780m     ENDC
0000039A                           781m 
0000039A                 FALSE     782m     IFNE DEBUG
0000039A                           783m     ENDC
0000039A                           784m 
0000039A                           785m     ENDM
0000039A                           786  
0000039A  E19A                     787      ROL.L #8,D2
0000039C                           788m     PRINT_CHAR D2,D3
0000039C                           789m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039C                 TRUE      790m     IFEQ DEBUG
0000039C  1639 00C00003            791m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003A2  0803 0002                792m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003A6  67F4                     793m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000003A8  13C2 00C00007            794m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003AE                           795m     ENDC
000003AE                           796m 
000003AE                 FALSE     797m     IFNE DEBUG
000003AE                           798m     ENDC
000003AE                           799m 
000003AE                           800m     ENDM
000003AE  E19A                     801      ROL.L #8,D2
000003B0                           802m     PRINT_CHAR D2,D3
000003B0                           803m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B0                 TRUE      804m     IFEQ DEBUG
000003B0  1639 00C00003            805m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003B6  0803 0002                806m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003BA  67F4                     807m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003BC  13C2 00C00007            808m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003C2                           809m     ENDC
000003C2                           810m 
000003C2                 FALSE     811m     IFNE DEBUG
000003C2                           812m     ENDC
000003C2                           813m 
000003C2                           814m     ENDM
000003C2  E19A                     815      ROL.L #8,D2
000003C4                           816m     PRINT_CHAR D2,D3
000003C4                           817m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003C4                 TRUE      818m     IFEQ DEBUG
000003C4  1639 00C00003            819m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003CA  0803 0002                820m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003CE  67F4                     821m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000003D0  13C2 00C00007            822m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003D6                           823m     ENDC
000003D6                           824m 
000003D6                 FALSE     825m     IFNE DEBUG
000003D6                           826m     ENDC
000003D6                           827m 
000003D6                           828m     ENDM
000003D6  E19A                     829      ROL.L #8,D2
000003D8                           830m     PRINT_CHAR D2,D3
000003D8                           831m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D8                 TRUE      832m     IFEQ DEBUG
000003D8  1639 00C00003            833m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003DE  0803 0002                834m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E2  67F4                     835m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
000003E4  13C2 00C00007            836m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003EA                           837m     ENDC
000003EA                           838m 
000003EA                 FALSE     839m     IFNE DEBUG
000003EA                           840m     ENDC
000003EA                           841m 
000003EA                           842m     ENDM
000003EA                           843  
000003EA                           844m     PRINT_CRLF D3,A0
000003EA  41FA 11FD                845m     LEA CRLF(PC),A0
000003EE                           846mm     PRINT_STR A0,D3
000003EE                           847mm LOOP_45
000003EE  0C10 0000                848mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003F2  6700 0016                849mm     BEQ EXIT_45
000003F6                           850mmm     PRINT_CHAR (A0)+,D3
000003F6                           851mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003F6                 TRUE      852mmm     IFEQ DEBUG
000003F6  1639 00C00003            853mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003FC  0803 0002                854mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000400  67F4                     855mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000402  13D8 00C00007            856mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000408                           857mmm     ENDC
00000408                           858mmm 
00000408                 FALSE     859mmm     IFNE DEBUG
00000408                           860mmm     ENDC
00000408                           861mmm 
00000408                           862mmm     ENDM
00000408  60E4                     863mm     BRA LOOP_45
0000040A                           864mm EXIT_45
0000040A                           865mm     ENDM
0000040A                           866m     ENDM
0000040A                           867      
0000040A  6000 FDEE                868      BRA MAIN_LOOP
0000040E                           869  
0000040E                           870  W
0000040E                           871      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
0000040E  3C3C 0000                872s     MOVE.W  #0,D6
00000412  6000 0046                873s     BRA _20000005
00000416                           874s _20000004
00000416  E98D                     875          LSL.L #4,D5                                     ; make what we have so far more significant
00000418                           876m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000418                           877m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000418                 TRUE      878m     IFEQ DEBUG
00000418  1639 00C00003            879m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000041E  0803 0000                880m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000422  67F4                     881m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000424                           882m     ENDC
00000424                           883m 
00000424                           884mm     READ_CHAR D2
00000424                 TRUE      885mm     IFEQ DEBUG
00000424  1439 00C00007            886mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000042A                           887mm     ENDC
0000042A                 FALSE     888mm     IFNE DEBUG
0000042A                           889mm     ENDC
0000042A                           890mm 
0000042A  B43C 001B                891mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000042E  6700 FBE0                892mm     BEQ START
00000432                           893mm     ENDM
00000432                           894m 
00000432                 TRUE      895m     IFEQ DEBUG
00000432                           896mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000432                           897mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000432                 TRUE      898mm     IFEQ DEBUG
00000432  1639 00C00003            899mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000438  0803 0002                900mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000043C  67F4                     901mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
0000043E  13C2 00C00007            902mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000444                           903mm     ENDC
00000444                           904mm 
00000444                 FALSE     905mm     IFNE DEBUG
00000444                           906mm     ENDC
00000444                           907mm 
00000444                           908mm     ENDM
00000444                           909m     ENDC
00000444                           910m     ENDM
00000444                           911m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000444  41FA 1176                912m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000448  0402 0030                913m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000044C  C4BC 000000FF            914m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000452  1430 2000                915m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000456                           916m     ENDM
00000456  8A02                     917          OR.B D2,D5
00000458                           918      ENDF
00000458  5246                     919s     ADD.W   #1,D6
0000045A                           920s _20000005
0000045A  BC7C 0007                921s     CMP.W   #7,D6
0000045E  6FB6                     922s     BLE _20000004
00000460                           923  
00000460                           924m     PRINT_CRLF D3,A0
00000460  41FA 1187                925m     LEA CRLF(PC),A0
00000464                           926mm     PRINT_STR A0,D3
00000464                           927mm LOOP_52
00000464  0C10 0000                928mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000468  6700 0016                929mm     BEQ EXIT_52
0000046C                           930mmm     PRINT_CHAR (A0)+,D3
0000046C                           931mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000046C                 TRUE      932mmm     IFEQ DEBUG
0000046C  1639 00C00003            933mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000472  0803 0002                934mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000476  67F4                     935mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
00000478  13D8 00C00007            936mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047E                           937mmm     ENDC
0000047E                           938mmm 
0000047E                 FALSE     939mmm     IFNE DEBUG
0000047E                           940mmm     ENDC
0000047E                           941mmm 
0000047E                           942mmm     ENDM
0000047E  60E4                     943mm     BRA LOOP_52
00000480                           944mm EXIT_52
00000480                           945mm     ENDM
00000480                           946m     ENDM
00000480                           947  
00000480  2047                     948      MOVE.L D7,A0                                    ; address accumulator -> address register
00000482  7E00                     949      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000484                           950  
00000484  2085                     951      MOVE.L D5,(A0)                                  ; write the data
00000486                           952  
00000486  6000 FD72                953      BRA MAIN_LOOP
0000048A                           954  
0000048A                           955  ; register map for S
0000048A                           956  ; A0 - start address
0000048A                           957  ; A1 - offset
0000048A                           958  ; A2 - next address to write
0000048A                           959  ; A3 - next location (jmp)
0000048A                           960  ; A4 - Working Address Register
0000048A                           961  ; D0 - record count
0000048A                           962  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000048A                           963  ; D2 - checksum
0000048A                           964  ; D3 - data byte count
0000048A                           965  ; D4 - read address, moved into A2
0000048A                           966  ; D5 - temp
0000048A                           967  ; D6 - temp
0000048A                           968  ; D7 - temp
0000048A                           969  S
0000048A  2078 0000                970      MOVE.L 0,A0                                     ; start address -> A0
0000048E  2247                     971      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000490                           972      
00000490  7000                     973      MOVE.L #0,D0                                    ; count of records read -> D0
00000492                           974          
00000492                           975  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000492                           976m     DOWNLOAD D1
00000492                           977m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000492                           978m 
00000492  1239 00C00003            979m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000498  0801 0000                980m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000049C  6700 0010                981m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
000004A0                           982m 
000004A0                           983mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000004A0                 TRUE      984mm     IFEQ DEBUG
000004A0  1239 00C00007            985mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000004A6                           986mm     ENDC
000004A6                 FALSE     987mm     IFNE DEBUG
000004A6                           988mm     ENDC
000004A6                           989mm 
000004A6  B23C 001B                990mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000004AA  6700 FB64                991mm     BEQ START
000004AE                           992mm     ENDM
000004AE                           993m CONTINUE_54
000004AE  1239 00C00013            994m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000004B4  0801 0000                995m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000004B8  67D8                     996m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000004BA                           997m     
000004BA  1239 00C00017            998m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000004C0  13C1 00E00001            999m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000004C6                          1000m 
000004C6                          1001m     ENDM
000004C6  B23C 0053               1002      CMP.B #'S',D1                                   ; found S?
000004CA  66C6                    1003      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000004CC                          1004      
000004CC                          1005m     PRINT_CHAR #'S',D5                              ; print the S
000004CC                          1006m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CC                 TRUE     1007m     IFEQ DEBUG
000004CC  1A39 00C00003           1008m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000004D2  0805 0002               1009m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000004D6  67F4                    1010m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
000004D8  13FC 0053 00C00007      1011m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
000004E0                          1012m     ENDC
000004E0                          1013m 
000004E0                 FALSE    1014m     IFNE DEBUG
000004E0                          1015m     ENDC
000004E0                          1016m 
000004E0                          1017m     ENDM
000004E0  5280                    1018      ADD.L #1,D0                                     ; read another S record, increment count
000004E2                          1019      
000004E2                          1020m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000004E2                          1021m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E2                          1022m 
000004E2  1239 00C00003           1023m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000004E8  0801 0000               1024m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000004EC  6700 0010               1025m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
000004F0                          1026m 
000004F0                          1027mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000004F0                 TRUE     1028mm     IFEQ DEBUG
000004F0  1239 00C00007           1029mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000004F6                          1030mm     ENDC
000004F6                 FALSE    1031mm     IFNE DEBUG
000004F6                          1032mm     ENDC
000004F6                          1033mm 
000004F6  B23C 001B               1034mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000004FA  6700 FB14               1035mm     BEQ START
000004FE                          1036mm     ENDM
000004FE                          1037m CONTINUE_57
000004FE  1239 00C00013           1038m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000504  0801 0000               1039m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000508  67D8                    1040m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000050A                          1041m     
0000050A  1239 00C00017           1042m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000510  13C1 00E00001           1043m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000516                          1044m 
00000516                          1045m     ENDM
00000516                          1046m     PRINT_CHAR D1,D5
00000516                          1047m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000516                 TRUE     1048m     IFEQ DEBUG
00000516  1A39 00C00003           1049m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000051C  0805 0002               1050m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000520  67F4                    1051m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000522  13C1 00C00007           1052m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000528                          1053m     ENDC
00000528                          1054m 
00000528                 FALSE    1055m     IFNE DEBUG
00000528                          1056m     ENDC
00000528                          1057m 
00000528                          1058m     ENDM
00000528                          1059  
00000528  7400                    1060      MOVE.L #0,D2                                    ; clear the checksum
0000052A                          1061  
0000052A                          1062m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000052A  1E3C 0002               1063m     MOVE.B #2,D7
0000052E                          1064m     WHILE.B D7 <GT> 0 DO
0000052E                          1065ms _10000000
0000052E  BE38 0000               1066ms     CMP.B   0,D7
00000532  6F00 0062               1067ms     BLE _10000001
00000536  E98B                    1068m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000538                          1069mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000538                          1070mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000538                          1071mm 
00000538  1A39 00C00003           1072mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000053E  0805 0000               1073mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000542  6700 0010               1074mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000546                          1075mm 
00000546                          1076mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000546                 TRUE     1077mmm     IFEQ DEBUG
00000546  1A39 00C00007           1078mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000054C                          1079mmm     ENDC
0000054C                 FALSE    1080mmm     IFNE DEBUG
0000054C                          1081mmm     ENDC
0000054C                          1082mmm 
0000054C  BA3C 001B               1083mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000550  6700 FABE               1084mmm     BEQ START
00000554                          1085mmm     ENDM
00000554                          1086mm CONTINUE_61
00000554  1A39 00C00013           1087mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000055A  0805 0000               1088mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000055E  67D8                    1089mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000560                          1090mm     
00000560  1A39 00C00017           1091mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000566  13C5 00E00001           1092mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000056C                          1093mm 
0000056C                          1094mm     ENDM
0000056C                          1095mm         PRINT_CHAR D5,D6
0000056C                          1096mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE     1097mm     IFEQ DEBUG
0000056C  1C39 00C00003           1098mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000572  0806 0002               1099mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                    1100mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
00000578  13C5 00C00007           1101mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000057E                          1102mm     ENDC
0000057E                          1103mm 
0000057E                 FALSE    1104mm     IFNE DEBUG
0000057E                          1105mm     ENDC
0000057E                          1106mm 
0000057E                          1107mm     ENDM
0000057E                          1108mm         HEX2BIN D5,D5,A4
0000057E  49FA 103C               1109mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000582  0405 0030               1110mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000586  CABC 000000FF           1111mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000058C  1A34 5000               1112mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000590                          1113mm     ENDM
00000590  8605                    1114m         OR.B D5,D3
00000592  5307                    1115m         SUB.B #1,D7
00000594                          1116m     ENDW
00000594  6098                    1117ms     BRA _10000000
00000596                          1118ms _10000001
00000596                          1119m 
00000596  7A00                    1120m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000598  1A03                    1121m     MOVE.B D3,D5
0000059A  D483                    1122m     ADD.L D3,D2
0000059C                          1123m 
0000059C                          1124m     ENDM
0000059C                          1125  
0000059C                          1126      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000059C  B23C 0030               1127s     CMP.B   #'0',D1
000005A0  6600 002A               1128s     BNE.L   _00000002
000005A4                          1129m         PRINT_CRLF D5,A4
000005A4  49FA 1043               1130m     LEA CRLF(PC),A4
000005A8                          1131mm     PRINT_STR A4,D5
000005A8                          1132mm LOOP_66
000005A8  0C14 0000               1133mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000005AC  6700 0016               1134mm     BEQ EXIT_66
000005B0                          1135mmm     PRINT_CHAR (A4)+,D5
000005B0                          1136mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                 TRUE     1137mmm     IFEQ DEBUG
000005B0  1A39 00C00003           1138mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000005B6  0805 0002               1139mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000005BA  67F4                    1140mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000005BC  13DC 00C00007           1141mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005C2                          1142mmm     ENDC
000005C2                          1143mmm 
000005C2                 FALSE    1144mmm     IFNE DEBUG
000005C2                          1145mmm     ENDC
000005C2                          1146mmm 
000005C2                          1147mmm     ENDM
000005C2  60E4                    1148mm     BRA LOOP_66
000005C4                          1149mm EXIT_66
000005C4                          1150mm     ENDM
000005C4                          1151m     ENDM
000005C4  6000 FECC               1152          BRA WAIT_FOR_SRECORD
000005C8                          1153      ELSE
000005C8  6000 03DE               1154s     BRA _00000003
000005CC                          1155s _00000002
000005CC                          1156          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000005CC  B23C 0031               1157s     CMP.B   #'1',D1
000005D0  6708                    1158s     BEQ.S   _00000004
000005D2  B23C 0032               1159s     CMP.B   #'2',D1
000005D6  6600 01F0               1160s     BNE.L   _00000005
000005DA                          1161s _00000004
000005DA  5783                    1162              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000005DC                          1163  
000005DC  7800                    1164              MOVE.L #0,D4                            ; read two bytes of address
000005DE                          1165m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000005DE  1E3C 0002               1166m     MOVE.B #2,D7
000005E2                          1167m     WHILE.B D7 <GT> 0 DO
000005E2                          1168ms _10000002
000005E2  BE38 0000               1169ms     CMP.B   0,D7
000005E6  6F00 0062               1170ms     BLE _10000003
000005EA  E98C                    1171m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005EC                          1172mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005EC                          1173mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005EC                          1174mm 
000005EC  1A39 00C00003           1175mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005F2  0805 0000               1176mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005F6  6700 0010               1177mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
000005FA                          1178mm 
000005FA                          1179mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005FA                 TRUE     1180mmm     IFEQ DEBUG
000005FA  1A39 00C00007           1181mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000600                          1182mmm     ENDC
00000600                 FALSE    1183mmm     IFNE DEBUG
00000600                          1184mmm     ENDC
00000600                          1185mmm 
00000600  BA3C 001B               1186mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000604  6700 FA0A               1187mmm     BEQ START
00000608                          1188mmm     ENDM
00000608                          1189mm CONTINUE_69
00000608  1A39 00C00013           1190mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000060E  0805 0000               1191mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000612  67D8                    1192mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000614                          1193mm     
00000614  1A39 00C00017           1194mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000061A  13C5 00E00001           1195mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000620                          1196mm 
00000620                          1197mm     ENDM
00000620                          1198mm         PRINT_CHAR D5,D6
00000620                          1199mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000620                 TRUE     1200mm     IFEQ DEBUG
00000620  1C39 00C00003           1201mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000626  0806 0002               1202mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000062A  67F4                    1203mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000062C  13C5 00C00007           1204mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000632                          1205mm     ENDC
00000632                          1206mm 
00000632                 FALSE    1207mm     IFNE DEBUG
00000632                          1208mm     ENDC
00000632                          1209mm 
00000632                          1210mm     ENDM
00000632                          1211mm         HEX2BIN D5,D5,A4
00000632  49FA 0F88               1212mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000636  0405 0030               1213mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000063A  CABC 000000FF           1214mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000640  1A34 5000               1215mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000644                          1216mm     ENDM
00000644  8805                    1217m         OR.B D5,D4
00000646  5307                    1218m         SUB.B #1,D7
00000648                          1219m     ENDW
00000648  6098                    1220ms     BRA _10000002
0000064A                          1221ms _10000003
0000064A                          1222m 
0000064A  7A00                    1223m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000064C  1A04                    1224m     MOVE.B D4,D5
0000064E  D484                    1225m     ADD.L D4,D2
00000650                          1226m 
00000650                          1227m     ENDM
00000650                          1228m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000650  1E3C 0002               1229m     MOVE.B #2,D7
00000654                          1230m     WHILE.B D7 <GT> 0 DO
00000654                          1231ms _10000004
00000654  BE38 0000               1232ms     CMP.B   0,D7
00000658  6F00 0062               1233ms     BLE _10000005
0000065C  E98C                    1234m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000065E                          1235mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000065E                          1236mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000065E                          1237mm 
0000065E  1A39 00C00003           1238mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000664  0805 0000               1239mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000668  6700 0010               1240mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
0000066C                          1241mm 
0000066C                          1242mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000066C                 TRUE     1243mmm     IFEQ DEBUG
0000066C  1A39 00C00007           1244mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000672                          1245mmm     ENDC
00000672                 FALSE    1246mmm     IFNE DEBUG
00000672                          1247mmm     ENDC
00000672                          1248mmm 
00000672  BA3C 001B               1249mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000676  6700 F998               1250mmm     BEQ START
0000067A                          1251mmm     ENDM
0000067A                          1252mm CONTINUE_74
0000067A  1A39 00C00013           1253mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000680  0805 0000               1254mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000684  67D8                    1255mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
00000686                          1256mm     
00000686  1A39 00C00017           1257mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000068C  13C5 00E00001           1258mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000692                          1259mm 
00000692                          1260mm     ENDM
00000692                          1261mm         PRINT_CHAR D5,D6
00000692                          1262mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000692                 TRUE     1263mm     IFEQ DEBUG
00000692  1C39 00C00003           1264mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000698  0806 0002               1265mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000069C  67F4                    1266mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
0000069E  13C5 00C00007           1267mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006A4                          1268mm     ENDC
000006A4                          1269mm 
000006A4                 FALSE    1270mm     IFNE DEBUG
000006A4                          1271mm     ENDC
000006A4                          1272mm 
000006A4                          1273mm     ENDM
000006A4                          1274mm         HEX2BIN D5,D5,A4
000006A4  49FA 0F16               1275mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006A8  0405 0030               1276mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006AC  CABC 000000FF           1277mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006B2  1A34 5000               1278mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006B6                          1279mm     ENDM
000006B6  8805                    1280m         OR.B D5,D4
000006B8  5307                    1281m         SUB.B #1,D7
000006BA                          1282m     ENDW
000006BA  6098                    1283ms     BRA _10000004
000006BC                          1284ms _10000005
000006BC                          1285m 
000006BC  7A00                    1286m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006BE  1A04                    1287m     MOVE.B D4,D5
000006C0  D484                    1288m     ADD.L D4,D2
000006C2                          1289m 
000006C2                          1290m     ENDM
000006C2                          1291  
000006C2                          1292              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000006C2  B23C 0032               1293s     CMP.B   #'2',D1
000006C6  6600 0076               1294s     BNE.L   _00000006
000006CA  5383                    1295                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000006CC                          1296m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000006CC  1E3C 0002               1297m     MOVE.B #2,D7
000006D0                          1298m     WHILE.B D7 <GT> 0 DO
000006D0                          1299ms _10000006
000006D0  BE38 0000               1300ms     CMP.B   0,D7
000006D4  6F00 0062               1301ms     BLE _10000007
000006D8  E98C                    1302m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006DA                          1303mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006DA                          1304mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DA                          1305mm 
000006DA  1A39 00C00003           1306mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006E0  0805 0000               1307mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006E4  6700 0010               1308mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
000006E8                          1309mm 
000006E8                          1310mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006E8                 TRUE     1311mmm     IFEQ DEBUG
000006E8  1A39 00C00007           1312mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006EE                          1313mmm     ENDC
000006EE                 FALSE    1314mmm     IFNE DEBUG
000006EE                          1315mmm     ENDC
000006EE                          1316mmm 
000006EE  BA3C 001B               1317mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006F2  6700 F91C               1318mmm     BEQ START
000006F6                          1319mmm     ENDM
000006F6                          1320mm CONTINUE_79
000006F6  1A39 00C00013           1321mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006FC  0805 0000               1322mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000700  67D8                    1323mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000702                          1324mm     
00000702  1A39 00C00017           1325mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000708  13C5 00E00001           1326mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000070E                          1327mm 
0000070E                          1328mm     ENDM
0000070E                          1329mm         PRINT_CHAR D5,D6
0000070E                          1330mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000070E                 TRUE     1331mm     IFEQ DEBUG
0000070E  1C39 00C00003           1332mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000714  0806 0002               1333mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000718  67F4                    1334mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
0000071A  13C5 00C00007           1335mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000720                          1336mm     ENDC
00000720                          1337mm 
00000720                 FALSE    1338mm     IFNE DEBUG
00000720                          1339mm     ENDC
00000720                          1340mm 
00000720                          1341mm     ENDM
00000720                          1342mm         HEX2BIN D5,D5,A4
00000720  49FA 0E9A               1343mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000724  0405 0030               1344mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000728  CABC 000000FF           1345mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000072E  1A34 5000               1346mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000732                          1347mm     ENDM
00000732  8805                    1348m         OR.B D5,D4
00000734  5307                    1349m         SUB.B #1,D7
00000736                          1350m     ENDW
00000736  6098                    1351ms     BRA _10000006
00000738                          1352ms _10000007
00000738                          1353m 
00000738  7A00                    1354m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000073A  1A04                    1355m     MOVE.B D4,D5
0000073C  D484                    1356m     ADD.L D4,D2
0000073E                          1357m 
0000073E                          1358m     ENDM
0000073E                          1359              ENDI
0000073E                          1360s _00000006
0000073E                          1361  
0000073E  2444                    1362              MOVE.L D4,A2                            ; put the address in an address register
00000740  D5C9                    1363              ADD.L A1,A2                             ; add in the offset
00000742                          1364  
00000742                          1365              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000742                          1366s _10000008
00000742  B63C 0000               1367s     CMP.B   #0,D3
00000746  6F00 007A               1368s     BLE _10000009
0000074A                          1369m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
0000074A  1E3C 0002               1370m     MOVE.B #2,D7
0000074E                          1371m     WHILE.B D7 <GT> 0 DO
0000074E                          1372ms _1000000A
0000074E  BE38 0000               1373ms     CMP.B   0,D7
00000752  6F00 0062               1374ms     BLE _1000000B
00000756  E989                    1375m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000758                          1376mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000758                          1377mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000758                          1378mm 
00000758  1A39 00C00003           1379mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000075E  0805 0000               1380mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000762  6700 0010               1381mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000766                          1382mm 
00000766                          1383mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000766                 TRUE     1384mmm     IFEQ DEBUG
00000766  1A39 00C00007           1385mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000076C                          1386mmm     ENDC
0000076C                 FALSE    1387mmm     IFNE DEBUG
0000076C                          1388mmm     ENDC
0000076C                          1389mmm 
0000076C  BA3C 001B               1390mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000770  6700 F89E               1391mmm     BEQ START
00000774                          1392mmm     ENDM
00000774                          1393mm CONTINUE_84
00000774  1A39 00C00013           1394mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000077A  0805 0000               1395mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000077E  67D8                    1396mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
00000780                          1397mm     
00000780  1A39 00C00017           1398mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000786  13C5 00E00001           1399mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000078C                          1400mm 
0000078C                          1401mm     ENDM
0000078C                          1402mm         PRINT_CHAR D5,D6
0000078C                          1403mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078C                 TRUE     1404mm     IFEQ DEBUG
0000078C  1C39 00C00003           1405mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000792  0806 0002               1406mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000796  67F4                    1407mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
00000798  13C5 00C00007           1408mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000079E                          1409mm     ENDC
0000079E                          1410mm 
0000079E                 FALSE    1411mm     IFNE DEBUG
0000079E                          1412mm     ENDC
0000079E                          1413mm 
0000079E                          1414mm     ENDM
0000079E                          1415mm         HEX2BIN D5,D5,A4
0000079E  49FA 0E1C               1416mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A2  0405 0030               1417mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007A6  CABC 000000FF           1418mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007AC  1A34 5000               1419mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B0                          1420mm     ENDM
000007B0  8205                    1421m         OR.B D5,D1
000007B2  5307                    1422m         SUB.B #1,D7
000007B4                          1423m     ENDW
000007B4  6098                    1424ms     BRA _1000000A
000007B6                          1425ms _1000000B
000007B6                          1426m 
000007B6  7A00                    1427m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B8  1A01                    1428m     MOVE.B D1,D5
000007BA  D481                    1429m     ADD.L D1,D2
000007BC                          1430m 
000007BC                          1431m     ENDM
000007BC                          1432   
000007BC  14C1                    1433                  MOVE.B D1,(A2)+                     ; store it!
000007BE                          1434  
000007BE  5303                    1435                  SUB.B #1,D3                         ; 1 less byte to go
000007C0                          1436              ENDW
000007C0  6080                    1437s     BRA _10000008
000007C2                          1438s _10000009
000007C2                          1439  
000007C2  7200                    1440              MOVE.L #0,D1                            ; not done yet
000007C4                          1441          ELSE
000007C4  6000 01E2               1442s     BRA _00000007
000007C8                          1443s _00000005
000007C8                          1444              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000007C8  B23C 0038               1445s     CMP.B   #'8',D1
000007CC  6600 0164               1446s     BNE.L   _00000008
000007D0  7800                    1447                  MOVE.L #0,D4                        ; read the 24 bit start address
000007D2                          1448m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000007D2  1E3C 0002               1449m     MOVE.B #2,D7
000007D6                          1450m     WHILE.B D7 <GT> 0 DO
000007D6                          1451ms _1000000C
000007D6  BE38 0000               1452ms     CMP.B   0,D7
000007DA  6F00 0062               1453ms     BLE _1000000D
000007DE  E98C                    1454m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007E0                          1455mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007E0                          1456mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007E0                          1457mm 
000007E0  1A39 00C00003           1458mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007E6  0805 0000               1459mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007EA  6700 0010               1460mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
000007EE                          1461mm 
000007EE                          1462mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007EE                 TRUE     1463mmm     IFEQ DEBUG
000007EE  1A39 00C00007           1464mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007F4                          1465mmm     ENDC
000007F4                 FALSE    1466mmm     IFNE DEBUG
000007F4                          1467mmm     ENDC
000007F4                          1468mmm 
000007F4  BA3C 001B               1469mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007F8  6700 F816               1470mmm     BEQ START
000007FC                          1471mmm     ENDM
000007FC                          1472mm CONTINUE_89
000007FC  1A39 00C00013           1473mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000802  0805 0000               1474mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000806  67D8                    1475mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
00000808                          1476mm     
00000808  1A39 00C00017           1477mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000080E  13C5 00E00001           1478mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000814                          1479mm 
00000814                          1480mm     ENDM
00000814                          1481mm         PRINT_CHAR D5,D6
00000814                          1482mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000814                 TRUE     1483mm     IFEQ DEBUG
00000814  1C39 00C00003           1484mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000081A  0806 0002               1485mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000081E  67F4                    1486mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000820  13C5 00C00007           1487mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000826                          1488mm     ENDC
00000826                          1489mm 
00000826                 FALSE    1490mm     IFNE DEBUG
00000826                          1491mm     ENDC
00000826                          1492mm 
00000826                          1493mm     ENDM
00000826                          1494mm         HEX2BIN D5,D5,A4
00000826  49FA 0D94               1495mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000082A  0405 0030               1496mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000082E  CABC 000000FF           1497mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000834  1A34 5000               1498mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000838                          1499mm     ENDM
00000838  8805                    1500m         OR.B D5,D4
0000083A  5307                    1501m         SUB.B #1,D7
0000083C                          1502m     ENDW
0000083C  6098                    1503ms     BRA _1000000C
0000083E                          1504ms _1000000D
0000083E                          1505m 
0000083E  7A00                    1506m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000840  1A04                    1507m     MOVE.B D4,D5
00000842  D484                    1508m     ADD.L D4,D2
00000844                          1509m 
00000844                          1510m     ENDM
00000844                          1511m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000844  1E3C 0002               1512m     MOVE.B #2,D7
00000848                          1513m     WHILE.B D7 <GT> 0 DO
00000848                          1514ms _1000000E
00000848  BE38 0000               1515ms     CMP.B   0,D7
0000084C  6F00 0062               1516ms     BLE _1000000F
00000850  E98C                    1517m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000852                          1518mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000852                          1519mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000852                          1520mm 
00000852  1A39 00C00003           1521mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000858  0805 0000               1522mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000085C  6700 0010               1523mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
00000860                          1524mm 
00000860                          1525mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000860                 TRUE     1526mmm     IFEQ DEBUG
00000860  1A39 00C00007           1527mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000866                          1528mmm     ENDC
00000866                 FALSE    1529mmm     IFNE DEBUG
00000866                          1530mmm     ENDC
00000866                          1531mmm 
00000866  BA3C 001B               1532mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000086A  6700 F7A4               1533mmm     BEQ START
0000086E                          1534mmm     ENDM
0000086E                          1535mm CONTINUE_94
0000086E  1A39 00C00013           1536mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000874  0805 0000               1537mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000878  67D8                    1538mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
0000087A                          1539mm     
0000087A  1A39 00C00017           1540mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000880  13C5 00E00001           1541mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000886                          1542mm 
00000886                          1543mm     ENDM
00000886                          1544mm         PRINT_CHAR D5,D6
00000886                          1545mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000886                 TRUE     1546mm     IFEQ DEBUG
00000886  1C39 00C00003           1547mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000088C  0806 0002               1548mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000890  67F4                    1549mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
00000892  13C5 00C00007           1550mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000898                          1551mm     ENDC
00000898                          1552mm 
00000898                 FALSE    1553mm     IFNE DEBUG
00000898                          1554mm     ENDC
00000898                          1555mm 
00000898                          1556mm     ENDM
00000898                          1557mm         HEX2BIN D5,D5,A4
00000898  49FA 0D22               1558mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000089C  0405 0030               1559mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008A0  CABC 000000FF           1560mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008A6  1A34 5000               1561mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008AA                          1562mm     ENDM
000008AA  8805                    1563m         OR.B D5,D4
000008AC  5307                    1564m         SUB.B #1,D7
000008AE                          1565m     ENDW
000008AE  6098                    1566ms     BRA _1000000E
000008B0                          1567ms _1000000F
000008B0                          1568m 
000008B0  7A00                    1569m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008B2  1A04                    1570m     MOVE.B D4,D5
000008B4  D484                    1571m     ADD.L D4,D2
000008B6                          1572m 
000008B6                          1573m     ENDM
000008B6                          1574m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000008B6  1E3C 0002               1575m     MOVE.B #2,D7
000008BA                          1576m     WHILE.B D7 <GT> 0 DO
000008BA                          1577ms _10000010
000008BA  BE38 0000               1578ms     CMP.B   0,D7
000008BE  6F00 0062               1579ms     BLE _10000011
000008C2  E98C                    1580m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008C4                          1581mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008C4                          1582mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008C4                          1583mm 
000008C4  1A39 00C00003           1584mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008CA  0805 0000               1585mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008CE  6700 0010               1586mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
000008D2                          1587mm 
000008D2                          1588mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008D2                 TRUE     1589mmm     IFEQ DEBUG
000008D2  1A39 00C00007           1590mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008D8                          1591mmm     ENDC
000008D8                 FALSE    1592mmm     IFNE DEBUG
000008D8                          1593mmm     ENDC
000008D8                          1594mmm 
000008D8  BA3C 001B               1595mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008DC  6700 F732               1596mmm     BEQ START
000008E0                          1597mmm     ENDM
000008E0                          1598mm CONTINUE_99
000008E0  1A39 00C00013           1599mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008E6  0805 0000               1600mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008EA  67D8                    1601mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
000008EC                          1602mm     
000008EC  1A39 00C00017           1603mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008F2  13C5 00E00001           1604mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008F8                          1605mm 
000008F8                          1606mm     ENDM
000008F8                          1607mm         PRINT_CHAR D5,D6
000008F8                          1608mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F8                 TRUE     1609mm     IFEQ DEBUG
000008F8  1C39 00C00003           1610mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008FE  0806 0002               1611mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000902  67F4                    1612mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000904  13C5 00C00007           1613mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000090A                          1614mm     ENDC
0000090A                          1615mm 
0000090A                 FALSE    1616mm     IFNE DEBUG
0000090A                          1617mm     ENDC
0000090A                          1618mm 
0000090A                          1619mm     ENDM
0000090A                          1620mm         HEX2BIN D5,D5,A4
0000090A  49FA 0CB0               1621mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000090E  0405 0030               1622mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000912  CABC 000000FF           1623mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000918  1A34 5000               1624mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000091C                          1625mm     ENDM
0000091C  8805                    1626m         OR.B D5,D4
0000091E  5307                    1627m         SUB.B #1,D7
00000920                          1628m     ENDW
00000920  6098                    1629ms     BRA _10000010
00000922                          1630ms _10000011
00000922                          1631m 
00000922  7A00                    1632m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000924  1A04                    1633m     MOVE.B D4,D5
00000926  D484                    1634m     ADD.L D4,D2
00000928                          1635m 
00000928                          1636m     ENDM
00000928                          1637  
00000928  2044                    1638                  MOVE.L D4,A0                        ; start address -> A0
0000092A  D1C9                    1639                  ADD.L A1,A0                         ; add in the offset
0000092C                          1640  
0000092C  72FF                    1641                  MOVE.L #$FFFFFFFF,D1                ; done
0000092E                          1642              ELSE
0000092E  6000 0078               1643s     BRA _00000009
00000932                          1644s _00000008
00000932                          1645m                 PRINT_CRLF D5,A4
00000932  49FA 0CB5               1646m     LEA CRLF(PC),A4
00000936                          1647mm     PRINT_STR A4,D5
00000936                          1648mm LOOP_104
00000936  0C14 0000               1649mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000093A  6700 0016               1650mm     BEQ EXIT_104
0000093E                          1651mmm     PRINT_CHAR (A4)+,D5
0000093E                          1652mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000093E                 TRUE     1653mmm     IFEQ DEBUG
0000093E  1A39 00C00003           1654mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000944  0805 0002               1655mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000948  67F4                    1656mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
0000094A  13DC 00C00007           1657mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000950                          1658mmm     ENDC
00000950                          1659mmm 
00000950                 FALSE    1660mmm     IFNE DEBUG
00000950                          1661mmm     ENDC
00000950                          1662mmm 
00000950                          1663mmm     ENDM
00000950  60E4                    1664mm     BRA LOOP_104
00000952                          1665mm EXIT_104
00000952                          1666mm     ENDM
00000952                          1667m     ENDM
00000952                          1668  
00000952  49FA 0C1F               1669                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000956                          1670m                 PRINT_STR A4,D5
00000956                          1671m LOOP_106
00000956  0C14 0000               1672m     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000095A  6700 0016               1673m     BEQ EXIT_106
0000095E                          1674mm     PRINT_CHAR (A4)+,D5
0000095E                          1675mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1676mm     IFEQ DEBUG
0000095E  1A39 00C00003           1677mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000964  0805 0002               1678mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000968  67F4                    1679mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
0000096A  13DC 00C00007           1680mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000970                          1681mm     ENDC
00000970                          1682mm 
00000970                 FALSE    1683mm     IFNE DEBUG
00000970                          1684mm     ENDC
00000970                          1685mm 
00000970                          1686mm     ENDM
00000970  60E4                    1687m     BRA LOOP_106
00000972                          1688m EXIT_106
00000972                          1689m     ENDM
00000972                          1690m                 PRINT_CHAR D1,D5
00000972                          1691m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000972                 TRUE     1692m     IFEQ DEBUG
00000972  1A39 00C00003           1693m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000978  0805 0002               1694m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000097C  67F4                    1695m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
0000097E  13C1 00C00007           1696m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000984                          1697m     ENDC
00000984                          1698m 
00000984                 FALSE    1699m     IFNE DEBUG
00000984                          1700m     ENDC
00000984                          1701m 
00000984                          1702m     ENDM
00000984                          1703m                 PRINT_CRLF D5,A4
00000984  49FA 0C63               1704m     LEA CRLF(PC),A4
00000988                          1705mm     PRINT_STR A4,D5
00000988                          1706mm LOOP_110
00000988  0C14 0000               1707mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000098C  6700 0016               1708mm     BEQ EXIT_110
00000990                          1709mmm     PRINT_CHAR (A4)+,D5
00000990                          1710mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000990                 TRUE     1711mmm     IFEQ DEBUG
00000990  1A39 00C00003           1712mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000996  0805 0002               1713mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000099A  67F4                    1714mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
0000099C  13DC 00C00007           1715mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009A2                          1716mmm     ENDC
000009A2                          1717mmm 
000009A2                 FALSE    1718mmm     IFNE DEBUG
000009A2                          1719mmm     ENDC
000009A2                          1720mmm 
000009A2                          1721mmm     ENDM
000009A2  60E4                    1722mm     BRA LOOP_110
000009A4                          1723mm EXIT_110
000009A4                          1724mm     ENDM
000009A4                          1725m     ENDM
000009A4                          1726  
000009A4  6000 FAEC               1727                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
000009A8                          1728              ENDI
000009A8                          1729s _00000009
000009A8                          1730          ENDI
000009A8                          1731s _00000007
000009A8                          1732      ENDI
000009A8                          1733s _00000003
000009A8                          1734  
000009A8                          1735m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
000009A8  1E3C 0002               1736m     MOVE.B #2,D7
000009AC                          1737m     WHILE.B D7 <GT> 0 DO
000009AC                          1738ms _10000012
000009AC  BE38 0000               1739ms     CMP.B   0,D7
000009B0  6F00 0062               1740ms     BLE _10000013
000009B4  E98C                    1741m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B6                          1742mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B6                          1743mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B6                          1744mm 
000009B6  1A39 00C00003           1745mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009BC  0805 0000               1746mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009C0  6700 0010               1747mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
000009C4                          1748mm 
000009C4                          1749mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C4                 TRUE     1750mmm     IFEQ DEBUG
000009C4  1A39 00C00007           1751mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009CA                          1752mmm     ENDC
000009CA                 FALSE    1753mmm     IFNE DEBUG
000009CA                          1754mmm     ENDC
000009CA                          1755mmm 
000009CA  BA3C 001B               1756mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CE  6700 F640               1757mmm     BEQ START
000009D2                          1758mmm     ENDM
000009D2                          1759mm CONTINUE_113
000009D2  1A39 00C00013           1760mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D8  0805 0000               1761mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009DC  67D8                    1762mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
000009DE                          1763mm     
000009DE  1A39 00C00017           1764mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E4  13C5 00E00001           1765mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009EA                          1766mm 
000009EA                          1767mm     ENDM
000009EA                          1768mm         PRINT_CHAR D5,D6
000009EA                          1769mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009EA                 TRUE     1770mm     IFEQ DEBUG
000009EA  1C39 00C00003           1771mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009F0  0806 0002               1772mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F4  67F4                    1773mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
000009F6  13C5 00C00007           1774mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009FC                          1775mm     ENDC
000009FC                          1776mm 
000009FC                 FALSE    1777mm     IFNE DEBUG
000009FC                          1778mm     ENDC
000009FC                          1779mm 
000009FC                          1780mm     ENDM
000009FC                          1781mm         HEX2BIN D5,D5,A4
000009FC  49FA 0BBE               1782mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A00  0405 0030               1783mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A04  CABC 000000FF           1784mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A0A  1A34 5000               1785mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0E                          1786mm     ENDM
00000A0E  8805                    1787m         OR.B D5,D4
00000A10  5307                    1788m         SUB.B #1,D7
00000A12                          1789m     ENDW
00000A12  6098                    1790ms     BRA _10000012
00000A14                          1791ms _10000013
00000A14                          1792m 
00000A14  7A00                    1793m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A16  1A04                    1794m     MOVE.B D4,D5
00000A18  D484                    1795m     ADD.L D4,D2
00000A1A                          1796m 
00000A1A                          1797m     ENDM
00000A1A                          1798m     PRINT_CRLF D5,A4
00000A1A  49FA 0BCD               1799m     LEA CRLF(PC),A4
00000A1E                          1800mm     PRINT_STR A4,D5
00000A1E                          1801mm LOOP_118
00000A1E  0C14 0000               1802mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A22  6700 0016               1803mm     BEQ EXIT_118
00000A26                          1804mmm     PRINT_CHAR (A4)+,D5
00000A26                          1805mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1806mmm     IFEQ DEBUG
00000A26  1A39 00C00003           1807mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A2C  0805 0002               1808mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1809mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A32  13DC 00C00007           1810mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A38                          1811mmm     ENDC
00000A38                          1812mmm 
00000A38                 FALSE    1813mmm     IFNE DEBUG
00000A38                          1814mmm     ENDC
00000A38                          1815mmm 
00000A38                          1816mmm     ENDM
00000A38  60E4                    1817mm     BRA LOOP_118
00000A3A                          1818mm EXIT_118
00000A3A                          1819mm     ENDM
00000A3A                          1820m     ENDM
00000A3A                          1821  
00000A3A                          1822      IF.B D2 <NE> #$FF THEN.L
00000A3A  B43C 00FF               1823s     CMP.B   #$FF,D2
00000A3E  6700 0090               1824s     BEQ.L   _0000000A
00000A42  49FA 0B46               1825          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000A46                          1826m         PRINT_STR A4,D5
00000A46                          1827m LOOP_120
00000A46  0C14 0000               1828m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A4A  6700 0016               1829m     BEQ EXIT_120
00000A4E                          1830mm     PRINT_CHAR (A4)+,D5
00000A4E                          1831mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A4E                 TRUE     1832mm     IFEQ DEBUG
00000A4E  1A39 00C00003           1833mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A54  0805 0002               1834mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A58  67F4                    1835mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A5A  13DC 00C00007           1836mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A60                          1837mm     ENDC
00000A60                          1838mm 
00000A60                 FALSE    1839mm     IFNE DEBUG
00000A60                          1840mm     ENDC
00000A60                          1841mm 
00000A60                          1842mm     ENDM
00000A60  60E4                    1843m     BRA LOOP_120
00000A62                          1844m EXIT_120
00000A62                          1845m     ENDM
00000A62                          1846m         PRINT_REG D0,D5,D3,D6,A4
00000A62  49FA 0B8B               1847m     LEA OX(PC),A4
00000A66                          1848mm     PRINT_STR A4,D5
00000A66                          1849mm LOOP_123
00000A66  0C14 0000               1850mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A6A  6700 0016               1851mm     BEQ EXIT_123
00000A6E                          1852mmm     PRINT_CHAR (A4)+,D5
00000A6E                          1853mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A6E                 TRUE     1854mmm     IFEQ DEBUG
00000A6E  1A39 00C00003           1855mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A74  0805 0002               1856mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A78  67F4                    1857mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A7A  13DC 00C00007           1858mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A80                          1859mmm     ENDC
00000A80                          1860mmm 
00000A80                 FALSE    1861mmm     IFNE DEBUG
00000A80                          1862mmm     ENDC
00000A80                          1863mmm 
00000A80                          1864mmm     ENDM
00000A80  60E4                    1865mm     BRA LOOP_123
00000A82                          1866mm EXIT_123
00000A82                          1867mm     ENDM
00000A82  7C07                    1868m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A84                          1869m LOOP_122
00000A84                          1870mm     BIN2HEX D0,D3,A4
00000A84  49FA 0B26               1871mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A88  E998                    1872mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A8A  1600                    1873mm     MOVE.B D0,D3
00000A8C  0283 0000000F           1874mm     ANDI.L #$F,D3
00000A92  1634 3000               1875mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000A96                          1876mm     ENDM
00000A96                          1877mm     PRINT_CHAR D3,D5
00000A96                          1878mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A96                 TRUE     1879mm     IFEQ DEBUG
00000A96  1A39 00C00003           1880mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A9C  0805 0002               1881mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AA0  67F4                    1882mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000AA2  13C3 00C00007           1883mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AA8                          1884mm     ENDC
00000AA8                          1885mm 
00000AA8                 FALSE    1886mm     IFNE DEBUG
00000AA8                          1887mm     ENDC
00000AA8                          1888mm 
00000AA8                          1889mm     ENDM
00000AA8  57CE FFDA               1890m     DBEQ D6,LOOP_122
00000AAC                          1891m     ENDM
00000AAC                          1892m         PRINT_CRLF D5,A4
00000AAC  49FA 0B3B               1893m     LEA CRLF(PC),A4
00000AB0                          1894mm     PRINT_STR A4,D5
00000AB0                          1895mm LOOP_128
00000AB0  0C14 0000               1896mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AB4  6700 0016               1897mm     BEQ EXIT_128
00000AB8                          1898mmm     PRINT_CHAR (A4)+,D5
00000AB8                          1899mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB8                 TRUE     1900mmm     IFEQ DEBUG
00000AB8  1A39 00C00003           1901mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ABE  0805 0002               1902mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AC2  67F4                    1903mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000AC4  13DC 00C00007           1904mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ACA                          1905mmm     ENDC
00000ACA                          1906mmm 
00000ACA                 FALSE    1907mmm     IFNE DEBUG
00000ACA                          1908mmm     ENDC
00000ACA                          1909mmm 
00000ACA                          1910mmm     ENDM
00000ACA  60E4                    1911mm     BRA LOOP_128
00000ACC                          1912mm EXIT_128
00000ACC                          1913mm     ENDM
00000ACC                          1914m     ENDM
00000ACC                          1915          
00000ACC  6000 F72C               1916          BRA MAIN_LOOP
00000AD0                          1917      ENDI
00000AD0                          1918s _0000000A
00000AD0                          1919  
00000AD0                          1920      IF D1 <EQ> #0 THEN
00000AD0  B27C 0000               1921s     CMP.W   #0,D1
00000AD4  6600 0006               1922s     BNE _0000000B
00000AD8  6000 F9B8               1923        BRA WAIT_FOR_SRECORD
00000ADC                          1924      ENDI
00000ADC                          1925s _0000000B
00000ADC                          1926  DOWNLOAD_DONE
00000ADC                          1927m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000ADC  43FA 0B11               1928m     LEA OX(PC),A1
00000AE0                          1929mm     PRINT_STR A1,D5
00000AE0                          1930mm LOOP_131
00000AE0  0C11 0000               1931mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AE4  6700 0016               1932mm     BEQ EXIT_131
00000AE8                          1933mmm     PRINT_CHAR (A1)+,D5
00000AE8                          1934mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE8                 TRUE     1935mmm     IFEQ DEBUG
00000AE8  1A39 00C00003           1936mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AEE  0805 0002               1937mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AF2  67F4                    1938mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000AF4  13D9 00C00007           1939mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AFA                          1940mmm     ENDC
00000AFA                          1941mmm 
00000AFA                 FALSE    1942mmm     IFNE DEBUG
00000AFA                          1943mmm     ENDC
00000AFA                          1944mmm 
00000AFA                          1945mmm     ENDM
00000AFA  60E4                    1946mm     BRA LOOP_131
00000AFC                          1947mm EXIT_131
00000AFC                          1948mm     ENDM
00000AFC  7407                    1949m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AFE                          1950m LOOP_130
00000AFE                          1951mm     BIN2HEX D0,D6,A1
00000AFE  43FA 0AAC               1952mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B02  E998                    1953mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B04  1C00                    1954mm     MOVE.B D0,D6
00000B06  0286 0000000F           1955mm     ANDI.L #$F,D6
00000B0C  1C31 6000               1956mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B10                          1957mm     ENDM
00000B10                          1958mm     PRINT_CHAR D6,D5
00000B10                          1959mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B10                 TRUE     1960mm     IFEQ DEBUG
00000B10  1A39 00C00003           1961mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B16  0805 0002               1962mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B1A  67F4                    1963mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B1C  13C6 00C00007           1964mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B22                          1965mm     ENDC
00000B22                          1966mm 
00000B22                 FALSE    1967mm     IFNE DEBUG
00000B22                          1968mm     ENDC
00000B22                          1969mm 
00000B22                          1970mm     ENDM
00000B22  57CA FFDA               1971m     DBEQ D2,LOOP_130
00000B26                          1972m     ENDM
00000B26  43FA 0A29               1973      LEA READ(PC),A1
00000B2A                          1974m     PRINT_STR A1,D5
00000B2A                          1975m LOOP_135
00000B2A  0C11 0000               1976m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B2E  6700 0016               1977m     BEQ EXIT_135
00000B32                          1978mm     PRINT_CHAR (A1)+,D5
00000B32                          1979mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B32                 TRUE     1980mm     IFEQ DEBUG
00000B32  1A39 00C00003           1981mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B38  0805 0002               1982mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B3C  67F4                    1983mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B3E  13D9 00C00007           1984mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B44                          1985mm     ENDC
00000B44                          1986mm 
00000B44                 FALSE    1987mm     IFNE DEBUG
00000B44                          1988mm     ENDC
00000B44                          1989mm 
00000B44                          1990mm     ENDM
00000B44  60E4                    1991m     BRA LOOP_135
00000B46                          1992m EXIT_135
00000B46                          1993m     ENDM
00000B46  2E08                    1994      MOVE.L A0,D7                                    ; set address accumulator to start address
00000B48                          1995m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000B48  43FA 0AA5               1996m     LEA OX(PC),A1
00000B4C                          1997mm     PRINT_STR A1,D5
00000B4C                          1998mm LOOP_138
00000B4C  0C11 0000               1999mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B50  6700 0016               2000mm     BEQ EXIT_138
00000B54                          2001mmm     PRINT_CHAR (A1)+,D5
00000B54                          2002mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B54                 TRUE     2003mmm     IFEQ DEBUG
00000B54  1A39 00C00003           2004mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B5A  0805 0002               2005mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B5E  67F4                    2006mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000B60  13D9 00C00007           2007mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B66                          2008mmm     ENDC
00000B66                          2009mmm 
00000B66                 FALSE    2010mmm     IFNE DEBUG
00000B66                          2011mmm     ENDC
00000B66                          2012mmm 
00000B66                          2013mmm     ENDM
00000B66  60E4                    2014mm     BRA LOOP_138
00000B68                          2015mm EXIT_138
00000B68                          2016mm     ENDM
00000B68  7407                    2017m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B6A                          2018m LOOP_137
00000B6A                          2019mm     BIN2HEX D7,D6,A1
00000B6A  43FA 0A40               2020mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B6E  E99F                    2021mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B70  1C07                    2022mm     MOVE.B D7,D6
00000B72  0286 0000000F           2023mm     ANDI.L #$F,D6
00000B78  1C31 6000               2024mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B7C                          2025mm     ENDM
00000B7C                          2026mm     PRINT_CHAR D6,D5
00000B7C                          2027mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7C                 TRUE     2028mm     IFEQ DEBUG
00000B7C  1A39 00C00003           2029mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B82  0805 0002               2030mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B86  67F4                    2031mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B88  13C6 00C00007           2032mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B8E                          2033mm     ENDC
00000B8E                          2034mm 
00000B8E                 FALSE    2035mm     IFNE DEBUG
00000B8E                          2036mm     ENDC
00000B8E                          2037mm 
00000B8E                          2038mm     ENDM
00000B8E  57CA FFDA               2039m     DBEQ D2,LOOP_137
00000B92                          2040m     ENDM
00000B92                          2041m     PRINT_CRLF D5,A4
00000B92  49FA 0A55               2042m     LEA CRLF(PC),A4
00000B96                          2043mm     PRINT_STR A4,D5
00000B96                          2044mm LOOP_143
00000B96  0C14 0000               2045mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B9A  6700 0016               2046mm     BEQ EXIT_143
00000B9E                          2047mmm     PRINT_CHAR (A4)+,D5
00000B9E                          2048mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B9E                 TRUE     2049mmm     IFEQ DEBUG
00000B9E  1A39 00C00003           2050mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BA4  0805 0002               2051mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BA8  67F4                    2052mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000BAA  13DC 00C00007           2053mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BB0                          2054mmm     ENDC
00000BB0                          2055mmm 
00000BB0                 FALSE    2056mmm     IFNE DEBUG
00000BB0                          2057mmm     ENDC
00000BB0                          2058mmm 
00000BB0                          2059mmm     ENDM
00000BB0  60E4                    2060mm     BRA LOOP_143
00000BB2                          2061mm EXIT_143
00000BB2                          2062mm     ENDM
00000BB2                          2063m     ENDM
00000BB2                          2064  
00000BB2  6000 F646               2065      BRA MAIN_LOOP
00000BB6                          2066  
00000BB6                          2067  G
00000BB6  2047                    2068      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000BB8  7E00                    2069      MOVE.L #0,D7
00000BBA                          2070  
00000BBA  4ED0                    2071      JMP (A0)
00000BBC                          2072          
00000BBC                          2073  Z
00000BBC  207C 00200000           2074      MOVE.L #RAM,A0                                  ; address of RAM
00000BC2  D1FC 00100000           2075      ADD.L #$100000,A0
00000BC8                          2076  
00000BC8                          2077      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000BC8  7000                    2078s     MOVE.L  #0,D0
00000BCA  6000 0012               2079s     BRA _20000007
00000BCE                          2080s _20000006
00000BCE  2200                    2081          MOVE.L D0,D1                                ; progress update
00000BD0  E089                    2082          LSR.L #8,D1 
00000BD2  E089                    2083          LSR.L #8,D1
00000BD4  13C1 00E00001           2084          MOVE.B D1,DISPLAY
00000BDA                          2085          
00000BDA  2108                    2086          MOVE.L A0,-(A0)
00000BDC                          2087      ENDF
00000BDC  5880                    2088s     ADD.L   #4,D0
00000BDE                          2089s _20000007
00000BDE  B0BC 000FFFFC           2090s     CMP.L   #$FFFFC,D0
00000BE4  6FE8                    2091s     BLE _20000006
00000BE6                          2092  
00000BE6  207C 00200000           2093      MOVE.L #RAM,A0                                  ; address of RAM
00000BEC  D1FC 00100000           2094      ADD.L #$100000,A0
00000BF2                          2095  
00000BF2                          2096      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000BF2  7000                    2097s     MOVE.L  #0,D0
00000BF4  6000 00A8               2098s     BRA _20000009
00000BF8                          2099s _20000008
00000BF8  2200                    2100          MOVE.L D0,D1                                ; progress update
00000BFA  E089                    2101          LSR.L #8,D1
00000BFC  E089                    2102          LSR.L #8,D1
00000BFE  13C1 00E00001           2103          MOVE.B D1,DISPLAY
00000C04                          2104  
00000C04  2408                    2105          MOVE.L A0,D2
00000C06  2220                    2106          MOVE.L -(A0),D1
00000C08                          2107  
00000C08                          2108          IF.L D2 <NE> D1 THEN
00000C08  B481                    2109s     CMP.L   D1,D2
00000C0A  6700 0090               2110s     BEQ _0000000C
00000C0E  43FA 098B               2111              LEA RAM_ERROR(PC),A1
00000C12                          2112m             PRINT_STR A1,D1
00000C12                          2113m LOOP_145
00000C12  0C11 0000               2114m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C16  6700 0016               2115m     BEQ EXIT_145
00000C1A                          2116mm     PRINT_CHAR (A1)+,D1
00000C1A                          2117mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1A                 TRUE     2118mm     IFEQ DEBUG
00000C1A  1239 00C00003           2119mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000C20  0801 0002               2120mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000C24  67F4                    2121mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C26  13D9 00C00007           2122mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C2C                          2123mm     ENDC
00000C2C                          2124mm 
00000C2C                 FALSE    2125mm     IFNE DEBUG
00000C2C                          2126mm     ENDC
00000C2C                          2127mm 
00000C2C                          2128mm     ENDM
00000C2C  60E4                    2129m     BRA LOOP_145
00000C2E                          2130m EXIT_145
00000C2E                          2131m     ENDM
00000C2E  2208                    2132              MOVE.L A0,D1
00000C30  5981                    2133              SUB.L #4,D1
00000C32                          2134m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C32  43FA 09BB               2135m     LEA OX(PC),A1
00000C36                          2136mm     PRINT_STR A1,D3
00000C36                          2137mm LOOP_148
00000C36  0C11 0000               2138mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C3A  6700 0016               2139mm     BEQ EXIT_148
00000C3E                          2140mmm     PRINT_CHAR (A1)+,D3
00000C3E                          2141mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C3E                 TRUE     2142mmm     IFEQ DEBUG
00000C3E  1639 00C00003           2143mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C44  0803 0002               2144mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C48  67F4                    2145mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000C4A  13D9 00C00007           2146mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C50                          2147mmm     ENDC
00000C50                          2148mmm 
00000C50                 FALSE    2149mmm     IFNE DEBUG
00000C50                          2150mmm     ENDC
00000C50                          2151mmm 
00000C50                          2152mmm     ENDM
00000C50  60E4                    2153mm     BRA LOOP_148
00000C52                          2154mm EXIT_148
00000C52                          2155mm     ENDM
00000C52  7C07                    2156m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C54                          2157m LOOP_147
00000C54                          2158mm     BIN2HEX D1,D2,A1
00000C54  43FA 0956               2159mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C58  E999                    2160mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C5A  1401                    2161mm     MOVE.B D1,D2
00000C5C  0282 0000000F           2162mm     ANDI.L #$F,D2
00000C62  1431 2000               2163mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000C66                          2164mm     ENDM
00000C66                          2165mm     PRINT_CHAR D2,D3
00000C66                          2166mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C66                 TRUE     2167mm     IFEQ DEBUG
00000C66  1639 00C00003           2168mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C6C  0803 0002               2169mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C70  67F4                    2170mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000C72  13C2 00C00007           2171mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C78                          2172mm     ENDC
00000C78                          2173mm 
00000C78                 FALSE    2174mm     IFNE DEBUG
00000C78                          2175mm     ENDC
00000C78                          2176mm 
00000C78                          2177mm     ENDM
00000C78  57CE FFDA               2178m     DBEQ D6,LOOP_147
00000C7C                          2179m     ENDM
00000C7C                          2180m             PRINT_CRLF D3,A1
00000C7C  43FA 096B               2181m     LEA CRLF(PC),A1
00000C80                          2182mm     PRINT_STR A1,D3
00000C80                          2183mm LOOP_153
00000C80  0C11 0000               2184mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C84  6700 0016               2185mm     BEQ EXIT_153
00000C88                          2186mmm     PRINT_CHAR (A1)+,D3
00000C88                          2187mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C88                 TRUE     2188mmm     IFEQ DEBUG
00000C88  1639 00C00003           2189mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C8E  0803 0002               2190mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C92  67F4                    2191mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000C94  13D9 00C00007           2192mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C9A                          2193mmm     ENDC
00000C9A                          2194mmm 
00000C9A                 FALSE    2195mmm     IFNE DEBUG
00000C9A                          2196mmm     ENDC
00000C9A                          2197mmm 
00000C9A                          2198mmm     ENDM
00000C9A  60E4                    2199mm     BRA LOOP_153
00000C9C                          2200mm EXIT_153
00000C9C                          2201mm     ENDM
00000C9C                          2202m     ENDM
00000C9C                          2203          ENDI 
00000C9C                          2204s _0000000C
00000C9C                          2205      ENDF
00000C9C  5880                    2206s     ADD.L   #4,D0
00000C9E                          2207s _20000009
00000C9E  B0BC 000FFFFC           2208s     CMP.L   #$FFFFC,D0
00000CA4  6F00 FF52               2209s     BLE _20000008
00000CA8                          2210  
00000CA8  6000 F550               2211      BRA MAIN_LOOP
00000CAC                          2212  
00000CAC                          2213  L
00000CAC  7000                    2214      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000CAE  7200                    2215      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000CB0                          2216  
00000CB0                          2217      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000CB0  343C 0000               2218s     MOVE.W  #0,D2
00000CB4  6000 0046               2219s     BRA _2000000B
00000CB8                          2220s _2000000A
00000CB8  E989                    2221          LSL.L #4,D1                                 ; make what we have so far more significant
00000CBA                          2222m         WAIT_CHAR D3,D4                             ; next character -> D2
00000CBA                          2223m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CBA                 TRUE     2224m     IFEQ DEBUG
00000CBA  1839 00C00003           2225m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CC0  0804 0000               2226m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000CC4  67F4                    2227m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000CC6                          2228m     ENDC
00000CC6                          2229m 
00000CC6                          2230mm     READ_CHAR D3
00000CC6                 TRUE     2231mm     IFEQ DEBUG
00000CC6  1639 00C00007           2232mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000CCC                          2233mm     ENDC
00000CCC                 FALSE    2234mm     IFNE DEBUG
00000CCC                          2235mm     ENDC
00000CCC                          2236mm 
00000CCC  B63C 001B               2237mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000CD0  6700 F33E               2238mm     BEQ START
00000CD4                          2239mm     ENDM
00000CD4                          2240m 
00000CD4                 TRUE     2241m     IFEQ DEBUG
00000CD4                          2242mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000CD4                          2243mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD4                 TRUE     2244mm     IFEQ DEBUG
00000CD4  1839 00C00003           2245mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CDA  0804 0002               2246mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000CDE  67F4                    2247mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000CE0  13C3 00C00007           2248mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CE6                          2249mm     ENDC
00000CE6                          2250mm 
00000CE6                 FALSE    2251mm     IFNE DEBUG
00000CE6                          2252mm     ENDC
00000CE6                          2253mm 
00000CE6                          2254mm     ENDM
00000CE6                          2255m     ENDC
00000CE6                          2256m     ENDM
00000CE6                          2257m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000CE6  41FA 08D4               2258m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000CEA  0403 0030               2259m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CEE  C6BC 000000FF           2260m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000CF4  1630 3000               2261m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CF8                          2262m     ENDM
00000CF8  8203                    2263          OR.B D3,D1
00000CFA                          2264      ENDF
00000CFA  5242                    2265s     ADD.W   #1,D2
00000CFC                          2266s _2000000B
00000CFC  B47C 0007               2267s     CMP.W   #7,D2
00000D00  6FB6                    2268s     BLE _2000000A
00000D02                          2269  
00000D02  3001                    2270      MOVE.W D1,D0                                    ; extract the LSword for the length
00000D04  E089                    2271      LSR.L #8,D1                                     ; extract the MSword for the address
00000D06  E089                    2272      LSR.L #8,D1
00000D08                          2273  
00000D08                          2274m     PRINT_CRLF D2,A1
00000D08  43FA 08DF               2275m     LEA CRLF(PC),A1
00000D0C                          2276mm     PRINT_STR A1,D2
00000D0C                          2277mm LOOP_160
00000D0C  0C11 0000               2278mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D10  6700 0016               2279mm     BEQ EXIT_160
00000D14                          2280mmm     PRINT_CHAR (A1)+,D2
00000D14                          2281mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D14                 TRUE     2282mmm     IFEQ DEBUG
00000D14  1439 00C00003           2283mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D1A  0802 0002               2284mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D1E  67F4                    2285mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D20  13D9 00C00007           2286mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D26                          2287mmm     ENDC
00000D26                          2288mmm 
00000D26                 FALSE    2289mmm     IFNE DEBUG
00000D26                          2290mmm     ENDC
00000D26                          2291mmm 
00000D26                          2292mmm     ENDM
00000D26  60E4                    2293mm     BRA LOOP_160
00000D28                          2294mm EXIT_160
00000D28                          2295mm     ENDM
00000D28                          2296m     ENDM
00000D28                          2297  
00000D28  2041                    2298      MOVE.L D1,A0                                    ; target address
00000D2A  2641                    2299      MOVE.L D1,A3                                    ; keep a copy for later
00000D2C                          2300  
00000D2C  2247                    2301      MOVE.L D7,A1                                    ; address accumulator -> address register
00000D2E  7E00                    2302      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000D30                          2303  
00000D30                          2304m     UNPROTECT
00000D30  31FC AAAA 2AAA          2305m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000D36  4E71                    2306m     NOP
00000D38  31FC 5555 1554          2307m     MOVE.W #$5555,$1554
00000D3E  4E71                    2308m     NOP
00000D40  31FC 8080 2AAA          2309m     MOVE.W #$8080,$2AAA
00000D46  4E71                    2310m     NOP
00000D48  31FC AAAA 2AAA          2311m     MOVE.W #$AAAA,$2AAA
00000D4E  4E71                    2312m     NOP
00000D50  31FC 5555 1554          2313m     MOVE.W #$5555,$1554
00000D56  4E71                    2314m     NOP
00000D58  31FC 2020 2AAA          2315m     MOVE.W #$2020,$2AAA
00000D5E                          2316m     ENDM
00000D5E                          2317  
00000D5E  45FA 0873               2318      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000D62                          2319m     PRINT_STR A2,D2
00000D62                          2320m LOOP_163
00000D62  0C12 0000               2321m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D66  6700 0016               2322m     BEQ EXIT_163
00000D6A                          2323mm     PRINT_CHAR (A2)+,D2
00000D6A                          2324mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6A                 TRUE     2325mm     IFEQ DEBUG
00000D6A  1439 00C00003           2326mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D70  0802 0002               2327mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D74  67F4                    2328mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000D76  13DA 00C00007           2329mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D7C                          2330mm     ENDC
00000D7C                          2331mm 
00000D7C                 FALSE    2332mm     IFNE DEBUG
00000D7C                          2333mm     ENDC
00000D7C                          2334mm 
00000D7C                          2335mm     ENDM
00000D7C  60E4                    2336m     BRA LOOP_163
00000D7E                          2337m EXIT_163
00000D7E                          2338m     ENDM
00000D7E                          2339  
00000D7E  2409                    2340      MOVE.L A1,D2
00000D80                          2341m     PRINT_REG D2,D3,D4,D5,A2
00000D80  45FA 086D               2342m     LEA OX(PC),A2
00000D84                          2343mm     PRINT_STR A2,D3
00000D84                          2344mm LOOP_166
00000D84  0C12 0000               2345mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D88  6700 0016               2346mm     BEQ EXIT_166
00000D8C                          2347mmm     PRINT_CHAR (A2)+,D3
00000D8C                          2348mmm WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D8C                 TRUE     2349mmm     IFEQ DEBUG
00000D8C  1639 00C00003           2350mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D92  0803 0002               2351mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D96  67F4                    2352mmm         BEQ WAIT_FOR_READY_167                      ; NO SPACE, CHECK AGAIN
00000D98  13DA 00C00007           2353mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D9E                          2354mmm     ENDC
00000D9E                          2355mmm 
00000D9E                 FALSE    2356mmm     IFNE DEBUG
00000D9E                          2357mmm     ENDC
00000D9E                          2358mmm 
00000D9E                          2359mmm     ENDM
00000D9E  60E4                    2360mm     BRA LOOP_166
00000DA0                          2361mm EXIT_166
00000DA0                          2362mm     ENDM
00000DA0  7A07                    2363m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DA2                          2364m LOOP_165
00000DA2                          2365mm     BIN2HEX D2,D4,A2
00000DA2  45FA 0808               2366mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000DA6  E99A                    2367mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DA8  1802                    2368mm     MOVE.B D2,D4
00000DAA  0284 0000000F           2369mm     ANDI.L #$F,D4
00000DB0  1832 4000               2370mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000DB4                          2371mm     ENDM
00000DB4                          2372mm     PRINT_CHAR D4,D3
00000DB4                          2373mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB4                 TRUE     2374mm     IFEQ DEBUG
00000DB4  1639 00C00003           2375mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DBA  0803 0002               2376mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DBE  67F4                    2377mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000DC0  13C4 00C00007           2378mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DC6                          2379mm     ENDC
00000DC6                          2380mm 
00000DC6                 FALSE    2381mm     IFNE DEBUG
00000DC6                          2382mm     ENDC
00000DC6                          2383mm 
00000DC6                          2384mm     ENDM
00000DC6  57CD FFDA               2385m     DBEQ D5,LOOP_165
00000DCA                          2386m     ENDM
00000DCA                          2387  
00000DCA  45FA 0826               2388      LEA TO(PC),A2
00000DCE                          2389m     PRINT_STR A2,D3
00000DCE                          2390m LOOP_170
00000DCE  0C12 0000               2391m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DD2  6700 0016               2392m     BEQ EXIT_170
00000DD6                          2393mm     PRINT_CHAR (A2)+,D3
00000DD6                          2394mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD6                 TRUE     2395mm     IFEQ DEBUG
00000DD6  1639 00C00003           2396mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DDC  0803 0002               2397mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DE0  67F4                    2398mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000DE2  13DA 00C00007           2399mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DE8                          2400mm     ENDC
00000DE8                          2401mm 
00000DE8                 FALSE    2402mm     IFNE DEBUG
00000DE8                          2403mm     ENDC
00000DE8                          2404mm 
00000DE8                          2405mm     ENDM
00000DE8  60E4                    2406m     BRA LOOP_170
00000DEA                          2407m EXIT_170
00000DEA                          2408m     ENDM
00000DEA                          2409  
00000DEA  2408                    2410      MOVE.L A0,D2
00000DEC                          2411m     PRINT_REG D2,D3,D4,D5,A2
00000DEC  45FA 0801               2412m     LEA OX(PC),A2
00000DF0                          2413mm     PRINT_STR A2,D3
00000DF0                          2414mm LOOP_173
00000DF0  0C12 0000               2415mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DF4  6700 0016               2416mm     BEQ EXIT_173
00000DF8                          2417mmm     PRINT_CHAR (A2)+,D3
00000DF8                          2418mmm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF8                 TRUE     2419mmm     IFEQ DEBUG
00000DF8  1639 00C00003           2420mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DFE  0803 0002               2421mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E02  67F4                    2422mmm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00000E04  13DA 00C00007           2423mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E0A                          2424mmm     ENDC
00000E0A                          2425mmm 
00000E0A                 FALSE    2426mmm     IFNE DEBUG
00000E0A                          2427mmm     ENDC
00000E0A                          2428mmm 
00000E0A                          2429mmm     ENDM
00000E0A  60E4                    2430mm     BRA LOOP_173
00000E0C                          2431mm EXIT_173
00000E0C                          2432mm     ENDM
00000E0C  7A07                    2433m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E0E                          2434m LOOP_172
00000E0E                          2435mm     BIN2HEX D2,D4,A2
00000E0E  45FA 079C               2436mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E12  E99A                    2437mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E14  1802                    2438mm     MOVE.B D2,D4
00000E16  0284 0000000F           2439mm     ANDI.L #$F,D4
00000E1C  1832 4000               2440mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E20                          2441mm     ENDM
00000E20                          2442mm     PRINT_CHAR D4,D3
00000E20                          2443mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E20                 TRUE     2444mm     IFEQ DEBUG
00000E20  1639 00C00003           2445mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E26  0803 0002               2446mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E2A  67F4                    2447mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000E2C  13C4 00C00007           2448mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E32                          2449mm     ENDC
00000E32                          2450mm 
00000E32                 FALSE    2451mm     IFNE DEBUG
00000E32                          2452mm     ENDC
00000E32                          2453mm 
00000E32                          2454mm     ENDM
00000E32  57CD FFDA               2455m     DBEQ D5,LOOP_172
00000E36                          2456m     ENDM
00000E36                          2457  
00000E36                          2458m     PRINT_CRLF D3,A2
00000E36  45FA 07B1               2459m     LEA CRLF(PC),A2
00000E3A                          2460mm     PRINT_STR A2,D3
00000E3A                          2461mm LOOP_178
00000E3A  0C12 0000               2462mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E3E  6700 0016               2463mm     BEQ EXIT_178
00000E42                          2464mmm     PRINT_CHAR (A2)+,D3
00000E42                          2465mmm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E42                 TRUE     2466mmm     IFEQ DEBUG
00000E42  1639 00C00003           2467mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E48  0803 0002               2468mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E4C  67F4                    2469mmm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00000E4E  13DA 00C00007           2470mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E54                          2471mmm     ENDC
00000E54                          2472mmm 
00000E54                 FALSE    2473mmm     IFNE DEBUG
00000E54                          2474mmm     ENDC
00000E54                          2475mmm 
00000E54                          2476mmm     ENDM
00000E54  60E4                    2477mm     BRA LOOP_178
00000E56                          2478mm EXIT_178
00000E56                          2479mm     ENDM
00000E56                          2480m     ENDM
00000E56                          2481  
00000E56                          2482      WHILE D0 <GT> #0 DO
00000E56                          2483s _10000014
00000E56  B07C 0000               2484s     CMP.W   #0,D0
00000E5A  6F00 001C               2485s     BLE _10000015
00000E5E  5580                    2486          SUB.L #2,D0
00000E60                          2487  
00000E60  13D1 00E00001           2488          MOVE.B (A1),DISPLAY
00000E66                          2489m         PROGRAM (A1),(A0),D2
00000E66  3091                    2490m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000E68                          2491m 
00000E68                          2492m WAIT_FOR_COMPLETE_180
00000E68  3410                    2493m         MOVE.W (A0),D2
00000E6A                          2494m 
00000E6A                          2495m         IF.W D2 <NE> (A1) THEN
00000E6A  B451                    2496ms     CMP.W   (A1),D2
00000E6C  6700 0004               2497ms     BEQ _0000000D
00000E70  60F6                    2498m             BRA WAIT_FOR_COMPLETE_180
00000E72                          2499m         ENDI
00000E72                          2500ms _0000000D
00000E72                          2501m         ENDM
00000E72                          2502  
00000E72  5488                    2503          ADD.L #2,A0
00000E74  5489                    2504          ADD.L #2,A1
00000E76                          2505      ENDW
00000E76  60DE                    2506s     BRA _10000014
00000E78                          2507s _10000015
00000E78                          2508                                                      ; we're done, can now update the SP and start vector
00000E78                          2509m     PROGRAM #$FFFC, $2, D2                          ; SP
00000E78  31FC FFFC 0002          2510m   MOVE.W #$FFFC,$2                                      ; WRITE THE DATA
00000E7E                          2511m 
00000E7E                          2512m WAIT_FOR_COMPLETE_181
00000E7E  3438 0002               2513m         MOVE.W $2,D2
00000E82                          2514m 
00000E82                          2515m         IF.W D2 <NE> #$FFFC THEN
00000E82  B47C FFFC               2516ms     CMP.W   #$FFFC,D2
00000E86  6700 0004               2517ms     BEQ _0000000E
00000E8A  60F2                    2518m             BRA WAIT_FOR_COMPLETE_181
00000E8C                          2519m         ENDI
00000E8C                          2520ms _0000000E
00000E8C                          2521m         ENDM
00000E8C                          2522m     PROGRAM #$002F, $0, D2          
00000E8C  31FC 002F 0000          2523m   MOVE.W #$002F,$0                                      ; WRITE THE DATA
00000E92                          2524m 
00000E92                          2525m WAIT_FOR_COMPLETE_182
00000E92  3438 0000               2526m         MOVE.W $0,D2
00000E96                          2527m 
00000E96                          2528m         IF.W D2 <NE> #$002F THEN
00000E96  B47C 002F               2529ms     CMP.W   #$002F,D2
00000E9A  6700 0004               2530ms     BEQ _0000000F
00000E9E  60F2                    2531m             BRA WAIT_FOR_COMPLETE_182
00000EA0                          2532m         ENDI
00000EA0                          2533ms _0000000F
00000EA0                          2534m         ENDM
00000EA0                          2535  
00000EA0                          2536m     PROGRAM D1, $6, D2                              ; PC
00000EA0  31C1 0006               2537m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000EA4                          2538m 
00000EA4                          2539m WAIT_FOR_COMPLETE_183
00000EA4  3438 0006               2540m         MOVE.W $6,D2
00000EA8                          2541m 
00000EA8                          2542m         IF.W D2 <NE> D1 THEN
00000EA8  B441                    2543ms     CMP.W   D1,D2
00000EAA  6700 0004               2544ms     BEQ _00000010
00000EAE  60F4                    2545m             BRA WAIT_FOR_COMPLETE_183
00000EB0                          2546m         ENDI
00000EB0                          2547ms _00000010
00000EB0                          2548m         ENDM
00000EB0  E089                    2549      LSR.L #8,D1
00000EB2  E089                    2550      LSR.L #8,D1
00000EB4                          2551m     PROGRAM D1, $4, D2
00000EB4  31C1 0004               2552m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000EB8                          2553m 
00000EB8                          2554m WAIT_FOR_COMPLETE_184
00000EB8  3438 0004               2555m         MOVE.W $4,D2
00000EBC                          2556m 
00000EBC                          2557m         IF.W D2 <NE> D1 THEN
00000EBC  B441                    2558ms     CMP.W   D1,D2
00000EBE  6700 0004               2559ms     BEQ _00000011
00000EC2  60F4                    2560m             BRA WAIT_FOR_COMPLETE_184
00000EC4                          2561m         ENDI
00000EC4                          2562ms _00000011
00000EC4                          2563m         ENDM
00000EC4                          2564      
00000EC4  41F9 000012D2           2565      LEA BUS_ERROR_HANDLER,A0                        ; set the bus error handler - this is deliberately not relative to get the offset from $ORG 
00000ECA  43F8 0010               2566      LEA START,A1
00000ECE  D1CB                    2567      ADD.L A3,A0
00000ED0  91C9                    2568      SUB.L A1,A0 
00000ED2  2008                    2569      MOVE.L A0,D0
00000ED4                          2570m     PROGRAM D0, $A, D2                              ; write it
00000ED4  31C0 000A               2571m   MOVE.W D0,$A                                      ; WRITE THE DATA
00000ED8                          2572m 
00000ED8                          2573m WAIT_FOR_COMPLETE_185
00000ED8  3438 000A               2574m         MOVE.W $A,D2
00000EDC                          2575m 
00000EDC                          2576m         IF.W D2 <NE> D0 THEN
00000EDC  B440                    2577ms     CMP.W   D0,D2
00000EDE  6700 0004               2578ms     BEQ _00000012
00000EE2  60F4                    2579m             BRA WAIT_FOR_COMPLETE_185
00000EE4                          2580m         ENDI
00000EE4                          2581ms _00000012
00000EE4                          2582m         ENDM
00000EE4  E088                    2583      LSR.L #8,D0
00000EE6  E088                    2584      LSR.L #8,D0
00000EE8                          2585m     PROGRAM D0, $8, D2
00000EE8  31C0 0008               2586m   MOVE.W D0,$8                                      ; WRITE THE DATA
00000EEC                          2587m 
00000EEC                          2588m WAIT_FOR_COMPLETE_186
00000EEC  3438 0008               2589m         MOVE.W $8,D2
00000EF0                          2590m 
00000EF0                          2591m         IF.W D2 <NE> D0 THEN
00000EF0  B440                    2592ms     CMP.W   D0,D2
00000EF2  6700 0004               2593ms     BEQ _00000013
00000EF6  60F4                    2594m             BRA WAIT_FOR_COMPLETE_186
00000EF8                          2595m         ENDI
00000EF8                          2596ms _00000013
00000EF8                          2597m         ENDM
00000EF8                          2598  
00000EF8  41F9 000012D2           2599      LEA BUS_ERROR_HANDLER,A0                        ; set the bus error handler - this is deliberately not relative to get the offset from $ORG 
00000EFE  43F8 0010               2600      LEA START,A1
00000F02  D1CB                    2601      ADD.L A3,A0
00000F04  91C9                    2602      SUB.L A1,A0 
00000F06  2008                    2603      MOVE.L A0,D0
00000F08                          2604m     PROGRAM D0, $E, D2                              ; write it
00000F08  31C0 000E               2605m   MOVE.W D0,$E                                      ; WRITE THE DATA
00000F0C                          2606m 
00000F0C                          2607m WAIT_FOR_COMPLETE_187
00000F0C  3438 000E               2608m         MOVE.W $E,D2
00000F10                          2609m 
00000F10                          2610m         IF.W D2 <NE> D0 THEN
00000F10  B440                    2611ms     CMP.W   D0,D2
00000F12  6700 0004               2612ms     BEQ _00000014
00000F16  60F4                    2613m             BRA WAIT_FOR_COMPLETE_187
00000F18                          2614m         ENDI
00000F18                          2615ms _00000014
00000F18                          2616m         ENDM
00000F18  E088                    2617      LSR.L #8,D0
00000F1A  E088                    2618      LSR.L #8,D0
00000F1C                          2619m     PROGRAM D0, $C, D2
00000F1C  31C0 000C               2620m   MOVE.W D0,$C                                      ; WRITE THE DATA
00000F20                          2621m 
00000F20                          2622m WAIT_FOR_COMPLETE_188
00000F20  3438 000C               2623m         MOVE.W $C,D2
00000F24                          2624m 
00000F24                          2625m         IF.W D2 <NE> D0 THEN
00000F24  B440                    2626ms     CMP.W   D0,D2
00000F26  6700 0004               2627ms     BEQ _00000015
00000F2A  60F4                    2628m             BRA WAIT_FOR_COMPLETE_188
00000F2C                          2629m         ENDI
00000F2C                          2630ms _00000015
00000F2C                          2631m         ENDM
00000F2C                          2632                                                          
00000F2C                          2633m     PROTECT
00000F2C  31FC AAAA 2AAA          2634m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F32  31FC 5555 1554          2635m     MOVE.W #$5555,$1554
00000F38  31FC A0A0 2AAA          2636m     MOVE.W #$A0A0,$2AAA
00000F3E                          2637m     ENDM
00000F3E                          2638  
00000F3E  6000 F2BA               2639      BRA MAIN_LOOP
00000F42                          2640  
00000F42                          2641  P
00000F42  7000                    2642      MOVE.L #0,D0                                    ; D0 will be the data to write
00000F44                          2643  
00000F44                          2644      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000F44  323C 0000               2645s     MOVE.W  #0,D1
00000F48  6000 0046               2646s     BRA _2000000D
00000F4C                          2647s _2000000C
00000F4C  E988                    2648          LSL.L #4,D0                                 ; make what we have so far more significant
00000F4E                          2649m         WAIT_CHAR D2,D3                             ; next character -> D2
00000F4E                          2650m WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F4E                 TRUE     2651m     IFEQ DEBUG
00000F4E  1639 00C00003           2652m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F54  0803 0000               2653m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000F58  67F4                    2654m         BEQ WAIT_FOR_READY_190                      ; NOTHING, CHECK AGAIN
00000F5A                          2655m     ENDC
00000F5A                          2656m 
00000F5A                          2657mm     READ_CHAR D2
00000F5A                 TRUE     2658mm     IFEQ DEBUG
00000F5A  1439 00C00007           2659mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000F60                          2660mm     ENDC
00000F60                 FALSE    2661mm     IFNE DEBUG
00000F60                          2662mm     ENDC
00000F60                          2663mm 
00000F60  B43C 001B               2664mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000F64  6700 F0AA               2665mm     BEQ START
00000F68                          2666mm     ENDM
00000F68                          2667m 
00000F68                 TRUE     2668m     IFEQ DEBUG
00000F68                          2669mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000F68                          2670mm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F68                 TRUE     2671mm     IFEQ DEBUG
00000F68  1639 00C00003           2672mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F6E  0803 0002               2673mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F72  67F4                    2674mm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00000F74  13C2 00C00007           2675mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F7A                          2676mm     ENDC
00000F7A                          2677mm 
00000F7A                 FALSE    2678mm     IFNE DEBUG
00000F7A                          2679mm     ENDC
00000F7A                          2680mm 
00000F7A                          2681mm     ENDM
00000F7A                          2682m     ENDC
00000F7A                          2683m     ENDM
00000F7A                          2684m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000F7A  41FA 0640               2685m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000F7E  0402 0030               2686m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F82  C4BC 000000FF           2687m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000F88  1430 2000               2688m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000F8C                          2689m     ENDM
00000F8C  8002                    2690          OR.B D2,D0
00000F8E                          2691      ENDF
00000F8E  5241                    2692s     ADD.W   #1,D1
00000F90                          2693s _2000000D
00000F90  B27C 0003               2694s     CMP.W   #3,D1
00000F94  6FB6                    2695s     BLE _2000000C
00000F96                          2696  
00000F96                          2697m     PRINT_CRLF D2,A1
00000F96  43FA 0651               2698m     LEA CRLF(PC),A1
00000F9A                          2699mm     PRINT_STR A1,D2
00000F9A                          2700mm LOOP_195
00000F9A  0C11 0000               2701mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F9E  6700 0016               2702mm     BEQ EXIT_195
00000FA2                          2703mmm     PRINT_CHAR (A1)+,D2
00000FA2                          2704mmm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FA2                 TRUE     2705mmm     IFEQ DEBUG
00000FA2  1439 00C00003           2706mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000FA8  0802 0002               2707mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000FAC  67F4                    2708mmm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00000FAE  13D9 00C00007           2709mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FB4                          2710mmm     ENDC
00000FB4                          2711mmm 
00000FB4                 FALSE    2712mmm     IFNE DEBUG
00000FB4                          2713mmm     ENDC
00000FB4                          2714mmm 
00000FB4                          2715mmm     ENDM
00000FB4  60E4                    2716mm     BRA LOOP_195
00000FB6                          2717mm EXIT_195
00000FB6                          2718mm     ENDM
00000FB6                          2719m     ENDM
00000FB6                          2720  
00000FB6  2047                    2721      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000FB8  7E00                    2722      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000FBA                          2723  
00000FBA                          2724m     UNPROTECT
00000FBA  31FC AAAA 2AAA          2725m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000FC0  4E71                    2726m     NOP
00000FC2  31FC 5555 1554          2727m     MOVE.W #$5555,$1554
00000FC8  4E71                    2728m     NOP
00000FCA  31FC 8080 2AAA          2729m     MOVE.W #$8080,$2AAA
00000FD0  4E71                    2730m     NOP
00000FD2  31FC AAAA 2AAA          2731m     MOVE.W #$AAAA,$2AAA
00000FD8  4E71                    2732m     NOP
00000FDA  31FC 5555 1554          2733m     MOVE.W #$5555,$1554
00000FE0  4E71                    2734m     NOP
00000FE2  31FC 2020 2AAA          2735m     MOVE.W #$2020,$2AAA
00000FE8                          2736m     ENDM
00000FE8                          2737               
00000FE8  45FA 05E9               2738      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000FEC                          2739m     PRINT_STR A2,D2
00000FEC                          2740m LOOP_198
00000FEC  0C12 0000               2741m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FF0  6700 0016               2742m     BEQ EXIT_198
00000FF4                          2743mm     PRINT_CHAR (A2)+,D2
00000FF4                          2744mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FF4                 TRUE     2745mm     IFEQ DEBUG
00000FF4  1439 00C00003           2746mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000FFA  0802 0002               2747mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000FFE  67F4                    2748mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001000  13DA 00C00007           2749mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001006                          2750mm     ENDC
00001006                          2751mm 
00001006                 FALSE    2752mm     IFNE DEBUG
00001006                          2753mm     ENDC
00001006                          2754mm 
00001006                          2755mm     ENDM
00001006  60E4                    2756m     BRA LOOP_198
00001008                          2757m EXIT_198
00001008                          2758m     ENDM
00001008                          2759  
00001008                          2760m     PRINT_REG D0,D3,D4,D5,A2
00001008  45FA 05E5               2761m     LEA OX(PC),A2
0000100C                          2762mm     PRINT_STR A2,D3
0000100C                          2763mm LOOP_201
0000100C  0C12 0000               2764mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001010  6700 0016               2765mm     BEQ EXIT_201
00001014                          2766mmm     PRINT_CHAR (A2)+,D3
00001014                          2767mmm WAIT_FOR_READY_202                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001014                 TRUE     2768mmm     IFEQ DEBUG
00001014  1639 00C00003           2769mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000101A  0803 0002               2770mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000101E  67F4                    2771mmm         BEQ WAIT_FOR_READY_202                      ; NO SPACE, CHECK AGAIN
00001020  13DA 00C00007           2772mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001026                          2773mmm     ENDC
00001026                          2774mmm 
00001026                 FALSE    2775mmm     IFNE DEBUG
00001026                          2776mmm     ENDC
00001026                          2777mmm 
00001026                          2778mmm     ENDM
00001026  60E4                    2779mm     BRA LOOP_201
00001028                          2780mm EXIT_201
00001028                          2781mm     ENDM
00001028  7A07                    2782m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000102A                          2783m LOOP_200
0000102A                          2784mm     BIN2HEX D0,D4,A2
0000102A  45FA 0580               2785mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000102E  E998                    2786mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001030  1800                    2787mm     MOVE.B D0,D4
00001032  0284 0000000F           2788mm     ANDI.L #$F,D4
00001038  1832 4000               2789mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000103C                          2790mm     ENDM
0000103C                          2791mm     PRINT_CHAR D4,D3
0000103C                          2792mm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000103C                 TRUE     2793mm     IFEQ DEBUG
0000103C  1639 00C00003           2794mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001042  0803 0002               2795mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001046  67F4                    2796mm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001048  13C4 00C00007           2797mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000104E                          2798mm     ENDC
0000104E                          2799mm 
0000104E                 FALSE    2800mm     IFNE DEBUG
0000104E                          2801mm     ENDC
0000104E                          2802mm 
0000104E                          2803mm     ENDM
0000104E  57CD FFDA               2804m     DBEQ D5,LOOP_200
00001052                          2805m     ENDM
00001052                          2806  
00001052  45FA 059E               2807      LEA TO(PC),A2
00001056                          2808m     PRINT_STR A2,D3
00001056                          2809m LOOP_205
00001056  0C12 0000               2810m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000105A  6700 0016               2811m     BEQ EXIT_205
0000105E                          2812mm     PRINT_CHAR (A2)+,D3
0000105E                          2813mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000105E                 TRUE     2814mm     IFEQ DEBUG
0000105E  1639 00C00003           2815mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001064  0803 0002               2816mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001068  67F4                    2817mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
0000106A  13DA 00C00007           2818mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001070                          2819mm     ENDC
00001070                          2820mm 
00001070                 FALSE    2821mm     IFNE DEBUG
00001070                          2822mm     ENDC
00001070                          2823mm 
00001070                          2824mm     ENDM
00001070  60E4                    2825m     BRA LOOP_205
00001072                          2826m EXIT_205
00001072                          2827m     ENDM
00001072                          2828  
00001072  2408                    2829      MOVE.L A0,D2
00001074                          2830m     PRINT_REG D2,D3,D4,D5,A2
00001074  45FA 0579               2831m     LEA OX(PC),A2
00001078                          2832mm     PRINT_STR A2,D3
00001078                          2833mm LOOP_208
00001078  0C12 0000               2834mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000107C  6700 0016               2835mm     BEQ EXIT_208
00001080                          2836mmm     PRINT_CHAR (A2)+,D3
00001080                          2837mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001080                 TRUE     2838mmm     IFEQ DEBUG
00001080  1639 00C00003           2839mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001086  0803 0002               2840mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000108A  67F4                    2841mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
0000108C  13DA 00C00007           2842mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001092                          2843mmm     ENDC
00001092                          2844mmm 
00001092                 FALSE    2845mmm     IFNE DEBUG
00001092                          2846mmm     ENDC
00001092                          2847mmm 
00001092                          2848mmm     ENDM
00001092  60E4                    2849mm     BRA LOOP_208
00001094                          2850mm EXIT_208
00001094                          2851mm     ENDM
00001094  7A07                    2852m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001096                          2853m LOOP_207
00001096                          2854mm     BIN2HEX D2,D4,A2
00001096  45FA 0514               2855mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000109A  E99A                    2856mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000109C  1802                    2857mm     MOVE.B D2,D4
0000109E  0284 0000000F           2858mm     ANDI.L #$F,D4
000010A4  1832 4000               2859mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000010A8                          2860mm     ENDM
000010A8                          2861mm     PRINT_CHAR D4,D3
000010A8                          2862mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010A8                 TRUE     2863mm     IFEQ DEBUG
000010A8  1639 00C00003           2864mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010AE  0803 0002               2865mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010B2  67F4                    2866mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000010B4  13C4 00C00007           2867mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010BA                          2868mm     ENDC
000010BA                          2869mm 
000010BA                 FALSE    2870mm     IFNE DEBUG
000010BA                          2871mm     ENDC
000010BA                          2872mm 
000010BA                          2873mm     ENDM
000010BA  57CD FFDA               2874m     DBEQ D5,LOOP_207
000010BE                          2875m     ENDM
000010BE                          2876  
000010BE                          2877m     PRINT_CRLF D3,A2
000010BE  45FA 0529               2878m     LEA CRLF(PC),A2
000010C2                          2879mm     PRINT_STR A2,D3
000010C2                          2880mm LOOP_213
000010C2  0C12 0000               2881mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010C6  6700 0016               2882mm     BEQ EXIT_213
000010CA                          2883mmm     PRINT_CHAR (A2)+,D3
000010CA                          2884mmm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010CA                 TRUE     2885mmm     IFEQ DEBUG
000010CA  1639 00C00003           2886mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010D0  0803 0002               2887mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010D4  67F4                    2888mmm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
000010D6  13DA 00C00007           2889mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010DC                          2890mmm     ENDC
000010DC                          2891mmm 
000010DC                 FALSE    2892mmm     IFNE DEBUG
000010DC                          2893mmm     ENDC
000010DC                          2894mmm 
000010DC                          2895mmm     ENDM
000010DC  60E4                    2896mm     BRA LOOP_213
000010DE                          2897mm EXIT_213
000010DE                          2898mm     ENDM
000010DE                          2899m     ENDM
000010DE                          2900  
000010DE                          2901m     PROGRAM D0,(A0),D2
000010DE  3080                    2902m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010E0                          2903m 
000010E0                          2904m WAIT_FOR_COMPLETE_215
000010E0  3410                    2905m         MOVE.W (A0),D2
000010E2                          2906m 
000010E2                          2907m         IF.W D2 <NE> D0 THEN
000010E2  B440                    2908ms     CMP.W   D0,D2
000010E4  6700 0004               2909ms     BEQ _00000016
000010E8  60F6                    2910m             BRA WAIT_FOR_COMPLETE_215
000010EA                          2911m         ENDI
000010EA                          2912ms _00000016
000010EA                          2913m         ENDM
000010EA                          2914  
000010EA                          2915m     PROTECT
000010EA  31FC AAAA 2AAA          2916m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010F0  31FC 5555 1554          2917m     MOVE.W #$5555,$1554
000010F6  31FC A0A0 2AAA          2918m     MOVE.W #$A0A0,$2AAA
000010FC                          2919m     ENDM
000010FC                          2920  
000010FC  6000 F0FC               2921      BRA MAIN_LOOP
00001100                          2922      
00001100                          2923  M
00001100  7000                    2924      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001102  7200                    2925      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001104                          2926  
00001104                          2927      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001104  343C 0000               2928s     MOVE.W  #0,D2
00001108  6000 0046               2929s     BRA _2000000F
0000110C                          2930s _2000000E
0000110C  E989                    2931          LSL.L #4,D1                                     ; make what we have so far more significant
0000110E                          2932m         WAIT_CHAR D3,D4                                 ; next character -> D2
0000110E                          2933m WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000110E                 TRUE     2934m     IFEQ DEBUG
0000110E  1839 00C00003           2935m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001114  0804 0000               2936m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001118  67F4                    2937m         BEQ WAIT_FOR_READY_217                      ; NOTHING, CHECK AGAIN
0000111A                          2938m     ENDC
0000111A                          2939m 
0000111A                          2940mm     READ_CHAR D3
0000111A                 TRUE     2941mm     IFEQ DEBUG
0000111A  1639 00C00007           2942mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001120                          2943mm     ENDC
00001120                 FALSE    2944mm     IFNE DEBUG
00001120                          2945mm     ENDC
00001120                          2946mm 
00001120  B63C 001B               2947mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001124  6700 EEEA               2948mm     BEQ START
00001128                          2949mm     ENDM
00001128                          2950m 
00001128                 TRUE     2951m     IFEQ DEBUG
00001128                          2952mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001128                          2953mm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001128                 TRUE     2954mm     IFEQ DEBUG
00001128  1839 00C00003           2955mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000112E  0804 0002               2956mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001132  67F4                    2957mm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
00001134  13C3 00C00007           2958mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000113A                          2959mm     ENDC
0000113A                          2960mm 
0000113A                 FALSE    2961mm     IFNE DEBUG
0000113A                          2962mm     ENDC
0000113A                          2963mm 
0000113A                          2964mm     ENDM
0000113A                          2965m     ENDC
0000113A                          2966m     ENDM
0000113A                          2967m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
0000113A  41FA 0480               2968m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000113E  0403 0030               2969m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001142  C6BC 000000FF           2970m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00001148  1630 3000               2971m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
0000114C                          2972m     ENDM
0000114C  8203                    2973          OR.B D3,D1
0000114E                          2974      ENDF
0000114E  5242                    2975s     ADD.W   #1,D2
00001150                          2976s _2000000F
00001150  B47C 0007               2977s     CMP.W   #7,D2
00001154  6FB6                    2978s     BLE _2000000E
00001156                          2979m     PRINT_CRLF D2,A1
00001156  43FA 0491               2980m     LEA CRLF(PC),A1
0000115A                          2981mm     PRINT_STR A1,D2
0000115A                          2982mm LOOP_222
0000115A  0C11 0000               2983mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000115E  6700 0016               2984mm     BEQ EXIT_222
00001162                          2985mmm     PRINT_CHAR (A1)+,D2
00001162                          2986mmm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001162                 TRUE     2987mmm     IFEQ DEBUG
00001162  1439 00C00003           2988mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001168  0802 0002               2989mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000116C  67F4                    2990mmm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
0000116E  13D9 00C00007           2991mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001174                          2992mmm     ENDC
00001174                          2993mmm 
00001174                 FALSE    2994mmm     IFNE DEBUG
00001174                          2995mmm     ENDC
00001174                          2996mmm 
00001174                          2997mmm     ENDM
00001174  60E4                    2998mm     BRA LOOP_222
00001176                          2999mm EXIT_222
00001176                          3000mm     ENDM
00001176                          3001m     ENDM
00001176                          3002  
00001176  3001                    3003      MOVE.W D1,D0                                        ; extract the LSword for the length
00001178  E089                    3004      LSR.L #8,D1                                         ; extract the MSword for the address
0000117A  E089                    3005      LSR.L #8,D1
0000117C                          3006  
0000117C  2241                    3007      MOVE.L D1,A1
0000117E                          3008      
0000117E  2047                    3009      MOVE.L D7,A0                                        ; address accumulator -> target address register
00001180                          3010      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00001180                          3011  
00001180                          3012      WHILE D0 <GT> #0 DO
00001180                          3013s _10000016
00001180  B07C 0000               3014s     CMP.W   #0,D0
00001184  6F00 000E               3015s     BLE _10000017
00001188  5580                    3016          SUB.L #2,D0
0000118A                          3017  
0000118A  13D1 00E00001           3018          MOVE.B (A1),DISPLAY
00001190  30D9                    3019          MOVE.W (A1)+,(A0)+
00001192                          3020      ENDW
00001192  60EC                    3021s     BRA _10000016
00001194                          3022s _10000017
00001194                          3023      
00001194  6000 F064               3024      BRA MAIN_LOOP
00001198                          3025  
00001198                          3026  X
00001198  45FA 0462               3027      LEA STATUS_REGISTER(PC),A2
0000119C                          3028m     PRINT_STR A2,D3
0000119C                          3029m LOOP_224
0000119C  0C12 0000               3030m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011A0  6700 0016               3031m     BEQ EXIT_224
000011A4                          3032mm     PRINT_CHAR (A2)+,D3
000011A4                          3033mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011A4                 TRUE     3034mm     IFEQ DEBUG
000011A4  1639 00C00003           3035mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011AA  0803 0002               3036mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011AE  67F4                    3037mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
000011B0  13DA 00C00007           3038mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011B6                          3039mm     ENDC
000011B6                          3040mm 
000011B6                 FALSE    3041mm     IFNE DEBUG
000011B6                          3042mm     ENDC
000011B6                          3043mm 
000011B6                          3044mm     ENDM
000011B6  60E4                    3045m     BRA LOOP_224
000011B8                          3046m EXIT_224
000011B8                          3047m     ENDM
000011B8                          3048  
000011B8  40C0                    3049      MOVE SR,D0
000011BA                          3050m     PRINT_REG D0,D3,D4,D5,A2
000011BA  45FA 0433               3051m     LEA OX(PC),A2
000011BE                          3052mm     PRINT_STR A2,D3
000011BE                          3053mm LOOP_227
000011BE  0C12 0000               3054mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011C2  6700 0016               3055mm     BEQ EXIT_227
000011C6                          3056mmm     PRINT_CHAR (A2)+,D3
000011C6                          3057mmm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011C6                 TRUE     3058mmm     IFEQ DEBUG
000011C6  1639 00C00003           3059mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011CC  0803 0002               3060mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011D0  67F4                    3061mmm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
000011D2  13DA 00C00007           3062mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011D8                          3063mmm     ENDC
000011D8                          3064mmm 
000011D8                 FALSE    3065mmm     IFNE DEBUG
000011D8                          3066mmm     ENDC
000011D8                          3067mmm 
000011D8                          3068mmm     ENDM
000011D8  60E4                    3069mm     BRA LOOP_227
000011DA                          3070mm EXIT_227
000011DA                          3071mm     ENDM
000011DA  7A07                    3072m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011DC                          3073m LOOP_226
000011DC                          3074mm     BIN2HEX D0,D4,A2
000011DC  45FA 03CE               3075mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011E0  E998                    3076mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011E2  1800                    3077mm     MOVE.B D0,D4
000011E4  0284 0000000F           3078mm     ANDI.L #$F,D4
000011EA  1832 4000               3079mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011EE                          3080mm     ENDM
000011EE                          3081mm     PRINT_CHAR D4,D3
000011EE                          3082mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011EE                 TRUE     3083mm     IFEQ DEBUG
000011EE  1639 00C00003           3084mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011F4  0803 0002               3085mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011F8  67F4                    3086mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
000011FA  13C4 00C00007           3087mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001200                          3088mm     ENDC
00001200                          3089mm 
00001200                 FALSE    3090mm     IFNE DEBUG
00001200                          3091mm     ENDC
00001200                          3092mm 
00001200                          3093mm     ENDM
00001200  57CD FFDA               3094m     DBEQ D5,LOOP_226
00001204                          3095m     ENDM
00001204                          3096m     PRINT_CRLF D3,A2
00001204  45FA 03E3               3097m     LEA CRLF(PC),A2
00001208                          3098mm     PRINT_STR A2,D3
00001208                          3099mm LOOP_232
00001208  0C12 0000               3100mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000120C  6700 0016               3101mm     BEQ EXIT_232
00001210                          3102mmm     PRINT_CHAR (A2)+,D3
00001210                          3103mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001210                 TRUE     3104mmm     IFEQ DEBUG
00001210  1639 00C00003           3105mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001216  0803 0002               3106mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000121A  67F4                    3107mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
0000121C  13DA 00C00007           3108mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001222                          3109mmm     ENDC
00001222                          3110mmm 
00001222                 FALSE    3111mmm     IFNE DEBUG
00001222                          3112mmm     ENDC
00001222                          3113mmm 
00001222                          3114mmm     ENDM
00001222  60E4                    3115mm     BRA LOOP_232
00001224                          3116mm EXIT_232
00001224                          3117mm     ENDM
00001224                          3118m     ENDM
00001224                          3119  
00001224  45FA 03D1               3120      LEA STACK_POINTER(PC),A2
00001228                          3121m     PRINT_STR A2,D3
00001228                          3122m LOOP_234
00001228  0C12 0000               3123m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000122C  6700 0016               3124m     BEQ EXIT_234
00001230                          3125mm     PRINT_CHAR (A2)+,D3
00001230                          3126mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001230                 TRUE     3127mm     IFEQ DEBUG
00001230  1639 00C00003           3128mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001236  0803 0002               3129mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000123A  67F4                    3130mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
0000123C  13DA 00C00007           3131mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001242                          3132mm     ENDC
00001242                          3133mm 
00001242                 FALSE    3134mm     IFNE DEBUG
00001242                          3135mm     ENDC
00001242                          3136mm 
00001242                          3137mm     ENDM
00001242  60E4                    3138m     BRA LOOP_234
00001244                          3139m EXIT_234
00001244                          3140m     ENDM
00001244                          3141  
00001244  200F                    3142      MOVE.L SP,D0
00001246                          3143m     PRINT_REG D0,D3,D4,D5,A2
00001246  45FA 03A7               3144m     LEA OX(PC),A2
0000124A                          3145mm     PRINT_STR A2,D3
0000124A                          3146mm LOOP_237
0000124A  0C12 0000               3147mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000124E  6700 0016               3148mm     BEQ EXIT_237
00001252                          3149mmm     PRINT_CHAR (A2)+,D3
00001252                          3150mmm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001252                 TRUE     3151mmm     IFEQ DEBUG
00001252  1639 00C00003           3152mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001258  0803 0002               3153mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000125C  67F4                    3154mmm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
0000125E  13DA 00C00007           3155mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001264                          3156mmm     ENDC
00001264                          3157mmm 
00001264                 FALSE    3158mmm     IFNE DEBUG
00001264                          3159mmm     ENDC
00001264                          3160mmm 
00001264                          3161mmm     ENDM
00001264  60E4                    3162mm     BRA LOOP_237
00001266                          3163mm EXIT_237
00001266                          3164mm     ENDM
00001266  7A07                    3165m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001268                          3166m LOOP_236
00001268                          3167mm     BIN2HEX D0,D4,A2
00001268  45FA 0342               3168mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000126C  E998                    3169mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000126E  1800                    3170mm     MOVE.B D0,D4
00001270  0284 0000000F           3171mm     ANDI.L #$F,D4
00001276  1832 4000               3172mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000127A                          3173mm     ENDM
0000127A                          3174mm     PRINT_CHAR D4,D3
0000127A                          3175mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000127A                 TRUE     3176mm     IFEQ DEBUG
0000127A  1639 00C00003           3177mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001280  0803 0002               3178mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001284  67F4                    3179mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
00001286  13C4 00C00007           3180mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000128C                          3181mm     ENDC
0000128C                          3182mm 
0000128C                 FALSE    3183mm     IFNE DEBUG
0000128C                          3184mm     ENDC
0000128C                          3185mm 
0000128C                          3186mm     ENDM
0000128C  57CD FFDA               3187m     DBEQ D5,LOOP_236
00001290                          3188m     ENDM
00001290                          3189m     PRINT_CRLF D3,A2
00001290  45FA 0357               3190m     LEA CRLF(PC),A2
00001294                          3191mm     PRINT_STR A2,D3
00001294                          3192mm LOOP_242
00001294  0C12 0000               3193mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001298  6700 0016               3194mm     BEQ EXIT_242
0000129C                          3195mmm     PRINT_CHAR (A2)+,D3
0000129C                          3196mmm WAIT_FOR_READY_243                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000129C                 TRUE     3197mmm     IFEQ DEBUG
0000129C  1639 00C00003           3198mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012A2  0803 0002               3199mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012A6  67F4                    3200mmm         BEQ WAIT_FOR_READY_243                      ; NO SPACE, CHECK AGAIN
000012A8  13DA 00C00007           3201mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012AE                          3202mmm     ENDC
000012AE                          3203mmm 
000012AE                 FALSE    3204mmm     IFNE DEBUG
000012AE                          3205mmm     ENDC
000012AE                          3206mmm 
000012AE                          3207mmm     ENDM
000012AE  60E4                    3208mm     BRA LOOP_242
000012B0                          3209mm EXIT_242
000012B0                          3210mm     ENDM
000012B0                          3211m     ENDM
000012B0                          3212  
000012B0  6000 EF48               3213      BRA MAIN_LOOP
000012B4                          3214  
000012B4                          3215          
000012B4                          3216  HEX_DIGIT
000012B4  E98F                    3217      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000012B6                          3218m     HEX2BIN D2,D2,A0
000012B6  41FA 0304               3219m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000012BA  0402 0030               3220m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000012BE  C4BC 000000FF           3221m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000012C4  1430 2000               3222m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000012C8                          3223m     ENDM
000012C8  8E02                    3224      OR.B D2,D7  
000012CA  6000 EF4E               3225      BRA GET_INPUT
000012CE                          3226  
000012CE  FFFF FFFF               3227      SIMHALT                                             ; halt simulator
000012D2                          3228  
000012D2                          3229  ; exceptions
000012D2                          3230  BUS_ERROR_HANDLER
000012D2                          3231  
000012D2  41FA 032D               3232      LEA BUS_ERROR(PC),A0
000012D6                          3233m     PRINT_STR A0,D1
000012D6                          3234m LOOP_245
000012D6  0C10 0000               3235m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000012DA  6700 0016               3236m     BEQ EXIT_245
000012DE                          3237mm     PRINT_CHAR (A0)+,D1
000012DE                          3238mm WAIT_FOR_READY_246                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DE                 TRUE     3239mm     IFEQ DEBUG
000012DE  1239 00C00003           3240mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000012E4  0801 0002               3241mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000012E8  67F4                    3242mm         BEQ WAIT_FOR_READY_246                      ; NO SPACE, CHECK AGAIN
000012EA  13D8 00C00007           3243mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012F0                          3244mm     ENDC
000012F0                          3245mm 
000012F0                 FALSE    3246mm     IFNE DEBUG
000012F0                          3247mm     ENDC
000012F0                          3248mm 
000012F0                          3249mm     ENDM
000012F0  60E4                    3250m     BRA LOOP_245
000012F2                          3251m EXIT_245
000012F2                          3252m     ENDM
000012F2                          3253  
000012F2  7000                    3254      MOVE.L #0,D0
000012F4  3017                    3255      MOVE.W (SP),D0
000012F6                          3256  
000012F6  0800 0004               3257      BTST #4,D0
000012FA  6700 0026               3258      BEQ WRITE
000012FE                          3259      
000012FE  41FA 0316               3260      LEA READING(PC),A0
00001302                          3261m     PRINT_STR A0,D1
00001302                          3262m LOOP_247
00001302  0C10 0000               3263m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001306  6700 0016               3264m     BEQ EXIT_247
0000130A                          3265mm     PRINT_CHAR (A0)+,D1
0000130A                          3266mm WAIT_FOR_READY_248                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000130A                 TRUE     3267mm     IFEQ DEBUG
0000130A  1239 00C00003           3268mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001310  0801 0002               3269mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001314  67F4                    3270mm         BEQ WAIT_FOR_READY_248                      ; NO SPACE, CHECK AGAIN
00001316  13D8 00C00007           3271mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000131C                          3272mm     ENDC
0000131C                          3273mm 
0000131C                 FALSE    3274mm     IFNE DEBUG
0000131C                          3275mm     ENDC
0000131C                          3276mm 
0000131C                          3277mm     ENDM
0000131C  60E4                    3278m     BRA LOOP_247
0000131E                          3279m EXIT_247
0000131E                          3280m     ENDM
0000131E                          3281  
0000131E  6000 0022               3282      BRA CONTINUE    
00001322                          3283  WRITE
00001322  41FA 02FB               3284      LEA WRITING(PC),A0
00001326                          3285m     PRINT_STR A0,D1
00001326                          3286m LOOP_249
00001326  0C10 0000               3287m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000132A  6700 0016               3288m     BEQ EXIT_249
0000132E                          3289mm     PRINT_CHAR (A0)+,D1
0000132E                          3290mm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000132E                 TRUE     3291mm     IFEQ DEBUG
0000132E  1239 00C00003           3292mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001334  0801 0002               3293mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001338  67F4                    3294mm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
0000133A  13D8 00C00007           3295mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001340                          3296mm     ENDC
00001340                          3297mm 
00001340                 FALSE    3298mm     IFNE DEBUG
00001340                          3299mm     ENDC
00001340                          3300mm 
00001340                          3301mm     ENDM
00001340  60E4                    3302m     BRA LOOP_249
00001342                          3303m EXIT_249
00001342                          3304m     ENDM
00001342                          3305  
00001342                          3306  CONTINUE
00001342  222F 0002               3307      MOVE.L 2(SP),D1
00001346                          3308m     PRINT_REG D1,D2,D3,D4,A0
00001346  41FA 02A7               3309m     LEA OX(PC),A0
0000134A                          3310mm     PRINT_STR A0,D2
0000134A                          3311mm LOOP_252
0000134A  0C10 0000               3312mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000134E  6700 0016               3313mm     BEQ EXIT_252
00001352                          3314mmm     PRINT_CHAR (A0)+,D2
00001352                          3315mmm WAIT_FOR_READY_253                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001352                 TRUE     3316mmm     IFEQ DEBUG
00001352  1439 00C00003           3317mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001358  0802 0002               3318mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000135C  67F4                    3319mmm         BEQ WAIT_FOR_READY_253                      ; NO SPACE, CHECK AGAIN
0000135E  13D8 00C00007           3320mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001364                          3321mmm     ENDC
00001364                          3322mmm 
00001364                 FALSE    3323mmm     IFNE DEBUG
00001364                          3324mmm     ENDC
00001364                          3325mmm 
00001364                          3326mmm     ENDM
00001364  60E4                    3327mm     BRA LOOP_252
00001366                          3328mm EXIT_252
00001366                          3329mm     ENDM
00001366  7807                    3330m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001368                          3331m LOOP_251
00001368                          3332mm     BIN2HEX D1,D3,A0
00001368  41FA 0242               3333mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000136C  E999                    3334mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000136E  1601                    3335mm     MOVE.B D1,D3
00001370  0283 0000000F           3336mm     ANDI.L #$F,D3
00001376  1630 3000               3337mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000137A                          3338mm     ENDM
0000137A                          3339mm     PRINT_CHAR D3,D2
0000137A                          3340mm WAIT_FOR_READY_255                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000137A                 TRUE     3341mm     IFEQ DEBUG
0000137A  1439 00C00003           3342mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001380  0802 0002               3343mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001384  67F4                    3344mm         BEQ WAIT_FOR_READY_255                      ; NO SPACE, CHECK AGAIN
00001386  13C3 00C00007           3345mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000138C                          3346mm     ENDC
0000138C                          3347mm 
0000138C                 FALSE    3348mm     IFNE DEBUG
0000138C                          3349mm     ENDC
0000138C                          3350mm 
0000138C                          3351mm     ENDM
0000138C  57CC FFDA               3352m     DBEQ D4,LOOP_251
00001390                          3353m     ENDM
00001390                          3354  
00001390  41FA 0296               3355      LEA FROM(PC),A0
00001394                          3356m     PRINT_STR A0,D0
00001394                          3357m LOOP_256
00001394  0C10 0000               3358m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001398  6700 0016               3359m     BEQ EXIT_256
0000139C                          3360mm     PRINT_CHAR (A0)+,D0
0000139C                          3361mm WAIT_FOR_READY_257                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000139C                 TRUE     3362mm     IFEQ DEBUG
0000139C  1039 00C00003           3363mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000013A2  0800 0002               3364mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000013A6  67F4                    3365mm         BEQ WAIT_FOR_READY_257                      ; NO SPACE, CHECK AGAIN
000013A8  13D8 00C00007           3366mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013AE                          3367mm     ENDC
000013AE                          3368mm 
000013AE                 FALSE    3369mm     IFNE DEBUG
000013AE                          3370mm     ENDC
000013AE                          3371mm 
000013AE                          3372mm     ENDM
000013AE  60E4                    3373m     BRA LOOP_256
000013B0                          3374m EXIT_256
000013B0                          3375m     ENDM
000013B0                          3376  
000013B0  222F 000A               3377      MOVE.L 10(SP),D1
000013B4                          3378m     PRINT_REG D1,D2,D3,D4,A0
000013B4  41FA 0239               3379m     LEA OX(PC),A0
000013B8                          3380mm     PRINT_STR A0,D2
000013B8                          3381mm LOOP_259
000013B8  0C10 0000               3382mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000013BC  6700 0016               3383mm     BEQ EXIT_259
000013C0                          3384mmm     PRINT_CHAR (A0)+,D2
000013C0                          3385mmm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013C0                 TRUE     3386mmm     IFEQ DEBUG
000013C0  1439 00C00003           3387mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013C6  0802 0002               3388mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013CA  67F4                    3389mmm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
000013CC  13D8 00C00007           3390mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013D2                          3391mmm     ENDC
000013D2                          3392mmm 
000013D2                 FALSE    3393mmm     IFNE DEBUG
000013D2                          3394mmm     ENDC
000013D2                          3395mmm 
000013D2                          3396mmm     ENDM
000013D2  60E4                    3397mm     BRA LOOP_259
000013D4                          3398mm EXIT_259
000013D4                          3399mm     ENDM
000013D4  7807                    3400m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000013D6                          3401m LOOP_258
000013D6                          3402mm     BIN2HEX D1,D3,A0
000013D6  41FA 01D4               3403mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000013DA  E999                    3404mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000013DC  1601                    3405mm     MOVE.B D1,D3
000013DE  0283 0000000F           3406mm     ANDI.L #$F,D3
000013E4  1630 3000               3407mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000013E8                          3408mm     ENDM
000013E8                          3409mm     PRINT_CHAR D3,D2
000013E8                          3410mm WAIT_FOR_READY_262                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013E8                 TRUE     3411mm     IFEQ DEBUG
000013E8  1439 00C00003           3412mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013EE  0802 0002               3413mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013F2  67F4                    3414mm         BEQ WAIT_FOR_READY_262                      ; NO SPACE, CHECK AGAIN
000013F4  13C3 00C00007           3415mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013FA                          3416mm     ENDC
000013FA                          3417mm 
000013FA                 FALSE    3418mm     IFNE DEBUG
000013FA                          3419mm     ENDC
000013FA                          3420mm 
000013FA                          3421mm     ENDM
000013FA  57CC FFDA               3422m     DBEQ D4,LOOP_258
000013FE                          3423m     ENDM
000013FE                          3424m     PRINT_CRLF D0,A0
000013FE  41FA 01E9               3425m     LEA CRLF(PC),A0
00001402                          3426mm     PRINT_STR A0,D0
00001402                          3427mm LOOP_264
00001402  0C10 0000               3428mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001406  6700 0016               3429mm     BEQ EXIT_264
0000140A                          3430mmm     PRINT_CHAR (A0)+,D0
0000140A                          3431mmm WAIT_FOR_READY_265                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000140A                 TRUE     3432mmm     IFEQ DEBUG
0000140A  1039 00C00003           3433mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001410  0800 0002               3434mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001414  67F4                    3435mmm         BEQ WAIT_FOR_READY_265                      ; NO SPACE, CHECK AGAIN
00001416  13D8 00C00007           3436mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000141C                          3437mmm     ENDC
0000141C                          3438mmm 
0000141C                 FALSE    3439mmm     IFNE DEBUG
0000141C                          3440mmm     ENDC
0000141C                          3441mmm 
0000141C                          3442mmm     ENDM
0000141C  60E4                    3443mm     BRA LOOP_264
0000141E                          3444mm EXIT_264
0000141E                          3445mm     ENDM
0000141E                          3446m     ENDM
0000141E                          3447      
0000141E  2078 0004               3448      MOVE.L 4,A0
00001422  4ED0                    3449      JMP (A0)
00001424                          3450          
00001424                          3451  ; strings
00001424= 50 72 65 73 73 20 ...   3452  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001437= 5B 3F 5D 09 09 09 ...   3453  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001443= 5B 76 5D 09 09 09 ...   3454          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001452= 78 78 78 78 78 78 ...   3455          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
0000146A= 78 78 78 78 78 78 ...   3456          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000148A= 78 78 78 78 78 78 ...   3457          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
000014AB= 78 78 78 78 78 78 ...   3458          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
000014BC= 5B 7A 5D 09 09 09 ...   3459          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
000014CE= 78 78 78 78 78 78 ...   3460          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000014EF= 78 78 78 78 78 78 ...   3461          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
0000150E= 78 78 78 78 78 78 ...   3462          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001532= 5B 78 5D 09 09 09 ...   3463          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF,NULL
0000154A= 48 75 68 3F 0D 0A 00    3464  HUH  DC.B 'Huh?',CR,LF,NULL
00001551= 20 53 20 72 65 63 ...   3465  READ    DC.B ' S records read, start address = ',NULL
00001573= 57 3A 20 55 6E 6B ...   3466  UNREC   DC.B 'W: Unknown Srec type: ',NULL
0000158A= 21 20 43 53 20 66 ...   3467  CS_FAILURE  DC.B '! CS failure at ',NULL
0000159B= 21 20 52 41 4D 20 ...   3468  RAM_ERROR   DC.B '! RAM error at: ',NULL
000015AC= 30 31 32 33 34 35 ...   3469  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000015BC= 00 01 02 03 04 05 ...   3470  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000015D3= 4C 6F 61 64 69 3A ...   3471  LOADING DC.B 'Loadi:wng EEPROM...',CR,LF,NULL
000015E9= 0D 0A 00                3472  CRLF    DC.B CR,LF,NULL
000015EC= 3E 20 00                3473  PROMPT  DC.B '> ',NULL
000015EF= 30 78 00                3474  ox      DC.B '0x',NULL
000015F2= 20 2D 3E 20 00          3475  to      DC.B ' -> ',NULL
000015F7= 53 50 3A 20 00          3476  STACK_POINTER DC.B 'SP: ',NULL
000015FC= 53 52 3A 20 00          3477  STATUS_REGISTER DC.B 'SR: ',NULL
00001601= 2A 20 42 75 73 2F ...   3478  BUS_ERROR DC.B '* Bus/address error ',NULL
00001616= 72 65 61 64 69 6E ...   3479  READING DC.B 'reading ',NULL
0000161F= 77 72 69 74 69 6E ...   3480  WRITING DC.B 'writing ',NULL
00001628= 20 66 72 6F 6D 20 00    3481  FROM DC.B ' from ',NULL
0000162F= 4D 44 46 2D 6D 6F ...   3482  VERSION DC.B 'MDF-mon V1.103 (25/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
0000164D= 00                      3483  END     DC.B 0
0000164E                          3484      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         15AC
BUS_ERROR           1601
BUS_ERROR_HANDLER   12D2
CONTINUE            1342
CONTINUE_113        9D2
CONTINUE_54         4AE
CONTINUE_57         4FE
CONTINUE_61         554
CONTINUE_69         608
CONTINUE_74         67A
CONTINUE_79         6F6
CONTINUE_84         774
CONTINUE_89         7FC
CONTINUE_94         86E
CONTINUE_99         8E0
CR                  D
CRLF                15E9
CS_FAILURE          158A
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       ADC
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 164D
EXIT_10             166
EXIT_104            952
EXIT_106            972
EXIT_110            9A4
EXIT_118            A3A
EXIT_120            A62
EXIT_123            A82
EXIT_128            ACC
EXIT_131            AFC
EXIT_135            B46
EXIT_138            B68
EXIT_143            BB2
EXIT_145            C2E
EXIT_148            C52
EXIT_15             1B0
EXIT_153            C9C
EXIT_160            D28
EXIT_163            D7E
EXIT_166            DA0
EXIT_17             1D0
EXIT_170            DEA
EXIT_173            E0C
EXIT_178            E56
EXIT_195            FB6
EXIT_198            1008
EXIT_20             1F0
EXIT_201            1028
EXIT_205            1072
EXIT_208            1094
EXIT_213            10DE
EXIT_22             21A
EXIT_222            1176
EXIT_224            11B8
EXIT_227            11DA
EXIT_232            1224
EXIT_234            1244
EXIT_237            1266
EXIT_242            12B0
EXIT_245            12F2
EXIT_247            131E
EXIT_249            1342
EXIT_252            1366
EXIT_256            13B0
EXIT_259            13D4
EXIT_264            141E
EXIT_28             2AE
EXIT_30             306
EXIT_32             332
EXIT_35             35C
EXIT_45             40A
EXIT_5              11E
EXIT_52             480
EXIT_66             5C4
EXIT_7              13E
FROM                1628
G                   BB6
GET_INPUT           21A
H                   30A
HELP                1437
HELPPROMPT          1424
HEX2BIN             10B
HEX2BIN_LUT         15BC
HEX_DIGIT           12B4
HUH                 154A
L                   CAC
LF                  A
LOADING             15D3
LOOP_10             14A
LOOP_104            936
LOOP_106            956
LOOP_110            988
LOOP_118            A1E
LOOP_120            A46
LOOP_122            A84
LOOP_123            A66
LOOP_128            AB0
LOOP_130            AFE
LOOP_131            AE0
LOOP_135            B2A
LOOP_137            B6A
LOOP_138            B4C
LOOP_143            B96
LOOP_145            C12
LOOP_147            C54
LOOP_148            C36
LOOP_15             194
LOOP_153            C80
LOOP_160            D0C
LOOP_163            D62
LOOP_165            DA2
LOOP_166            D84
LOOP_17             1B4
LOOP_170            DCE
LOOP_172            E0E
LOOP_173            DF0
LOOP_178            E3A
LOOP_195            F9A
LOOP_198            FEC
LOOP_20             1D4
LOOP_200            102A
LOOP_201            100C
LOOP_205            1056
LOOP_207            1096
LOOP_208            1078
LOOP_213            10C2
LOOP_22             1FE
LOOP_222            115A
LOOP_224            119C
LOOP_226            11DC
LOOP_227            11BE
LOOP_232            1208
LOOP_234            1228
LOOP_236            1268
LOOP_237            124A
LOOP_242            1294
LOOP_245            12D6
LOOP_247            1302
LOOP_249            1326
LOOP_251            1368
LOOP_252            134A
LOOP_256            1394
LOOP_258            13D6
LOOP_259            13B8
LOOP_264            1402
LOOP_28             292
LOOP_30             2EA
LOOP_32             316
LOOP_34             35E
LOOP_35             340
LOOP_45             3EE
LOOP_5              102
LOOP_52             464
LOOP_66             5A8
LOOP_7              122
LOOP_9              168
M                   1100
MAIN_LOOP           1FA
NULL                0
OX                  15EF
P                   F42
PRINTSTR            316
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              15EC
PROTECT             A40
R                   336
RAM                 200000
RAM_ERROR           159B
READ                1551
READING             1616
READ_CHAR           62D
RESET               4
ROM                 0
S                   48A
STACK               0
STACK_POINTER       15F7
START               10
STATUS_REGISTER     15FC
TAB                 9
TO                  15F2
UNPROTECT           979
UNREC               1573
V                   312
VECS                8
VERSION             162F
W                   40E
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_180  E68
WAIT_FOR_COMPLETE_181  E7E
WAIT_FOR_COMPLETE_182  E92
WAIT_FOR_COMPLETE_183  EA4
WAIT_FOR_COMPLETE_184  EB8
WAIT_FOR_COMPLETE_185  ED8
WAIT_FOR_COMPLETE_186  EEC
WAIT_FOR_COMPLETE_187  F0C
WAIT_FOR_COMPLETE_188  F20
WAIT_FOR_COMPLETE_215  10E0
WAIT_FOR_READY_1    BA
WAIT_FOR_READY_101  8F8
WAIT_FOR_READY_105  93E
WAIT_FOR_READY_107  95E
WAIT_FOR_READY_108  972
WAIT_FOR_READY_11   152
WAIT_FOR_READY_111  990
WAIT_FOR_READY_113  9B6
WAIT_FOR_READY_115  9EA
WAIT_FOR_READY_119  A26
WAIT_FOR_READY_121  A4E
WAIT_FOR_READY_124  A6E
WAIT_FOR_READY_126  A96
WAIT_FOR_READY_129  AB8
WAIT_FOR_READY_13   17A
WAIT_FOR_READY_132  AE8
WAIT_FOR_READY_134  B10
WAIT_FOR_READY_136  B32
WAIT_FOR_READY_139  B54
WAIT_FOR_READY_141  B7C
WAIT_FOR_READY_144  B9E
WAIT_FOR_READY_146  C1A
WAIT_FOR_READY_149  C3E
WAIT_FOR_READY_151  C66
WAIT_FOR_READY_154  C88
WAIT_FOR_READY_155  CBA
WAIT_FOR_READY_157  CD4
WAIT_FOR_READY_16   19C
WAIT_FOR_READY_161  D14
WAIT_FOR_READY_164  D6A
WAIT_FOR_READY_167  D8C
WAIT_FOR_READY_169  DB4
WAIT_FOR_READY_171  DD6
WAIT_FOR_READY_174  DF8
WAIT_FOR_READY_176  E20
WAIT_FOR_READY_179  E42
WAIT_FOR_READY_18   1BC
WAIT_FOR_READY_190  F4E
WAIT_FOR_READY_192  F68
WAIT_FOR_READY_196  FA2
WAIT_FOR_READY_199  FF4
WAIT_FOR_READY_2    CE
WAIT_FOR_READY_202  1014
WAIT_FOR_READY_204  103C
WAIT_FOR_READY_206  105E
WAIT_FOR_READY_209  1080
WAIT_FOR_READY_21   1DC
WAIT_FOR_READY_211  10A8
WAIT_FOR_READY_214  10CA
WAIT_FOR_READY_217  110E
WAIT_FOR_READY_219  1128
WAIT_FOR_READY_223  1162
WAIT_FOR_READY_225  11A4
WAIT_FOR_READY_228  11C6
WAIT_FOR_READY_23   206
WAIT_FOR_READY_230  11EE
WAIT_FOR_READY_233  1210
WAIT_FOR_READY_235  1230
WAIT_FOR_READY_238  1252
WAIT_FOR_READY_24   21A
WAIT_FOR_READY_240  127A
WAIT_FOR_READY_243  129C
WAIT_FOR_READY_246  12DE
WAIT_FOR_READY_248  130A
WAIT_FOR_READY_250  132E
WAIT_FOR_READY_253  1352
WAIT_FOR_READY_255  137A
WAIT_FOR_READY_257  139C
WAIT_FOR_READY_26   234
WAIT_FOR_READY_260  13C0
WAIT_FOR_READY_262  13E8
WAIT_FOR_READY_265  140A
WAIT_FOR_READY_29   29A
WAIT_FOR_READY_3    E2
WAIT_FOR_READY_31   2F2
WAIT_FOR_READY_33   31E
WAIT_FOR_READY_36   348
WAIT_FOR_READY_38   370
WAIT_FOR_READY_39   386
WAIT_FOR_READY_40   39C
WAIT_FOR_READY_41   3B0
WAIT_FOR_READY_42   3C4
WAIT_FOR_READY_43   3D8
WAIT_FOR_READY_46   3F6
WAIT_FOR_READY_47   418
WAIT_FOR_READY_49   432
WAIT_FOR_READY_53   46C
WAIT_FOR_READY_54   492
WAIT_FOR_READY_56   4CC
WAIT_FOR_READY_57   4E2
WAIT_FOR_READY_59   516
WAIT_FOR_READY_6    10A
WAIT_FOR_READY_61   538
WAIT_FOR_READY_63   56C
WAIT_FOR_READY_67   5B0
WAIT_FOR_READY_69   5EC
WAIT_FOR_READY_71   620
WAIT_FOR_READY_74   65E
WAIT_FOR_READY_76   692
WAIT_FOR_READY_79   6DA
WAIT_FOR_READY_8    12A
WAIT_FOR_READY_81   70E
WAIT_FOR_READY_84   758
WAIT_FOR_READY_86   78C
WAIT_FOR_READY_89   7E0
WAIT_FOR_READY_91   814
WAIT_FOR_READY_94   852
WAIT_FOR_READY_96   886
WAIT_FOR_READY_99   8C4
WAIT_FOR_SRECORD    492
WRITE               1322
WRITING             161F
X                   1198
Z                   BBC
_00000000           25A
_00000001           26E
_00000002           5CC
_00000003           9A8
_00000004           5DA
_00000005           7C8
_00000006           73E
_00000007           9A8
_00000008           932
_00000009           9A8
_0000000A           AD0
_0000000B           ADC
_0000000C           C9C
_0000000D           E72
_0000000E           E8C
_0000000F           EA0
_00000010           EB0
_00000011           EC4
_00000012           EE4
_00000013           EF8
_00000014           F18
_00000015           F2C
_00000016           10EA
_10000000           52E
_10000001           596
_10000002           5E2
_10000003           64A
_10000004           654
_10000005           6BC
_10000006           6D0
_10000007           738
_10000008           742
_10000009           7C2
_1000000A           74E
_1000000B           7B6
_1000000C           7D6
_1000000D           83E
_1000000E           848
_1000000F           8B0
_10000010           8BA
_10000011           922
_10000012           9AC
_10000013           A14
_10000014           E56
_10000015           E78
_10000016           1180
_10000017           1194
_20000000           36
_20000001           42
_20000002           50
_20000003           5C
_20000004           416
_20000005           45A
_20000006           BCE
_20000007           BDE
_20000008           BF8
_20000009           C9E
_2000000A           CB8
_2000000B           CFC
_2000000C           F4C
_2000000D           F90
_2000000E           110C
_2000000F           1150
