00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 01/06/2021 20:17:54

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           190  PRINT_REG_4BIT MACRO
00000000                           191      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           192      MOVE.B \1,\3
00000000                           193      ANDI.L #$F,\3
00000000                           194      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           195      PRINT_CHAR \3,\2
00000000                           196      ENDM
00000000                           197  
00000000                           198  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           199  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           200  PRINT_REG MACRO
00000000                           201      LEA ox(PC),\5
00000000                           202      PRINT_STR \5,\2
00000000                           203      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           204  LOOP\@
00000000                           205      BIN2HEX \1,\3,\5
00000000                           206      PRINT_CHAR \3,\2
00000000                           207      DBEQ \4,LOOP\@
00000000                           208      ENDM
00000000                           209  
00000000                           210  ; wait for a char from the serial port
00000000                           211  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           212  ; will stamp on D0 and D1 in debug mode
00000000                           213  WAIT_CHAR MACRO
00000000                           214  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           215      IFEQ DEBUG
00000000                           216          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           217          BTST #0,\2                                  ; check for character
00000000                           218          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           219      ENDC
00000000                           220  
00000000                           221      READ_CHAR \1
00000000                           222  
00000000                           223      IFEQ DEBUG
00000000                           224          PRINT_CHAR \1,\2                            ; echo it back
00000000                           225      ENDC
00000000                           226      ENDM
00000000                           227  
00000000                           228  ; read a char from the serial port - assumes that there is one!
00000000                           229  ; \ 1= data register for read char
00000000                           230  ; will stamp on D0 and D1 in debug mode
00000000                           231  READ_CHAR MACRO
00000000                           232      IFEQ DEBUG
00000000                           233          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           234      ENDC
00000000                           235      IFNE DEBUG
00000000                           236          MOVE.L #5,D0    
00000000                           237          TRAP #15                                    ; read from keyboard in simulator
00000000                           238          MOVE.L D1,\1
00000000                           239      ENDC
00000000                           240  
00000000                           241      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           242      BEQ START
00000000                           243      ENDM
00000000                           244  
00000000                           245  
00000000                           246  ; read data from the download serial port
00000000                           247  ; \ 1= data register for read char
00000000                           248  DOWNLOAD MACRO
00000000                           249  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           250  
00000000                           251      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           252      BTST #0,\1                                      ; check for character
00000000                           253      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           254  
00000000                           255      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           256  CONTINUE\@
00000000                           257      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           258      BTST #0,\1                                      ; check for character
00000000                           259      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           260      
00000000                           261      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           262      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           263  
00000000                           264      ENDM
00000000                           265  
00000000                           266  ; unprotect the EEPROM
00000000                           267  UNPROTECT MACRO
00000000                           268      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           269      NOP
00000000                           270      MOVE.W #$5555,$1554
00000000                           271      NOP
00000000                           272      MOVE.W #$8080,$2AAA
00000000                           273      NOP
00000000                           274      MOVE.W #$AAAA,$2AAA
00000000                           275      NOP
00000000                           276      MOVE.W #$5555,$1554
00000000                           277      NOP
00000000                           278      MOVE.W #$2020,$2AAA
00000000                           279      ENDM
00000000                           280      
00000000                           281  ; protect the EEPROM
00000000                           282  PROTECT MACRO
00000000                           283      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           284      MOVE.W #$5555,$1554
00000000                           285      MOVE.W #$A0A0,$2AAA
00000000                           286      ENDM
00000000                           287  
00000000                           288  
00000000                           289  ; read two hex digits from the download serial port and convert to a byte
00000000                           290  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           291  DOWNLOAD_BYTE MACRO
00000000                           292      MOVE.B #2,\4
00000000                           293      WHILE.B \4 <GT> 0 DO
00000000                           294          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           295          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           296          ;PRINT_CHAR \2,\3
00000000                           297          HEX2BIN \2,\2,\6
00000000                           298          OR.B \2,\1
00000000                           299          SUB.B #1,\4
00000000                           300      ENDW
00000000                           301  
00000000                           302      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           303      MOVE.B \1,\2
00000000                           304      ADD.L \1,\5
00000000                           305  
00000000                           306      ENDM
00000000                           307  
00000000                           308  ; write word to EEPROM
00000000                           309  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           310  PROGRAM MACRO
00000000                           311    MOVE.W \1,\2                                      ; write the data
00000000                           312  
00000000                           313  WAIT_FOR_COMPLETE\@
00000000                           314          MOVE.W \2,\3
00000000                           315  
00000000                           316          IF.W \3 <NE> \1 THEN
00000000                           317              BRA WAIT_FOR_COMPLETE\@
00000000                           318          ENDI
00000000                           319          ENDM
00000000                           320          
00000000                           321  ; program vector to EEPROM
00000000                           322  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           323  PROGRAM_VECTOR MACRO
00000000                           324      ADD.L #2,\2
00000000                           325      PROGRAM \1, (\2), \3                            ; write it
00000000                           326      LSR.L #8,\1
00000000                           327      LSR.L #8,\1
00000000                           328      SUB.L #2,\2
00000000                           329      PROGRAM \1, (\2), \3
00000000                           330      ENDM
00000000                           331  
00000000                           332  ; read an ide register
00000000                           333  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           334  READ_8 MACRO
00000000                           335      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           336      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           337      ORI.B \1, \3
00000000                           338      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           339      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           340      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           341      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           342      ORI.B #MC68230_PORT_C_READ, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           345      ENDM
00000000                           346      
00000000                           347  ; write an ide register
00000000                           348  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           349  WRITE_8 MACRO
00000000                           350      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           351      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           352      ORI.B \2, \3
00000000                           353      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           354      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           355      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           356      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           357      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           358      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           359      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           360      ENDM
00000000                           361  
00000000                           362  ; read ide data
00000000                           363  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           364  READ_16 MACRO
00000000                           365      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           366      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           367      
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           369      ORI.B \1, \3
00000000                           370      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           371      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           372      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           373      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           374      LSL.W #8, \2
00000000                           375      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           376      ORI.B #MC68230_PORT_C_READ, \3
00000000                           377      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           378      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           379      ENDM
00000000                           380      
00000000                           381  ; read ide data
00000000                           382  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           383  READ_32 MACRO
00000000                           384      READ_16 \1, \2, \3
00000000                           385      LSL.L #8, \2
00000000                           386      LSL.L #8, \2
00000000                           387      READ_16 \1, \2, \3
00000000                           388      ENDM
00000000                           389          
00000000                           390  ; read ide status
00000000                           391  ;\1 = data register for result, \2 = working data register 
00000000                           392  READ_IDE_STATUS MACRO   
00000000                           393      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           394      ENDM
00000000                           395      
00000000                           396  ; wait for ide drive to be ready
00000000                           397  ;\1 = working data register 1, \2 = working data register 2
00000000                           398  WAIT_DRIVE_READY MACRO
00000000                           399  LOOP\@
00000000                           400      READ_IDE_STATUS \1, \2
00000000                           401      BTST #IDE_STATUS_READY, \1
00000000                           402      BEQ LOOP\@
00000000                           403      ENDM
00000000                           404      
00000000                           405  ; wait for ide drive to be not busy
00000000                           406  ;\1 = working data register 1, \2 = working data register 2
00000000                           407  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           408  LOOP\@
00000000                           409      READ_IDE_STATUS \1, \2
00000000                           410      BTST #IDE_STATUS_BUSY, \1
00000000                           411      BNE LOOP\@
00000000                           412      ENDM
00000000                           413      
00000000                           414  ; wait for ide drive to have data for us
00000000                           415  ;\1 = working data register 1, \2 = working data register 2
00000000                           416  WAIT_DRIVE_DRQ MACRO
00000000                           417  LOOP\@
00000000                           418      READ_IDE_STATUS \1, \2
00000000                           419      BTST #IDE_STATUS_DRQ, \1
00000000                           420      BEQ LOOP\@
00000000                           421      ENDM
00000000                           422      
00000000                           423  ; prepare to send a read command
00000000                           424  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           425  SET_READ_ADDRESS MACRO
00000000                           426      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           427      MOVE.L \1,\3
00000000                           428      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           429      LSR.L #8, \3
00000000                           430      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           431      LSR.L #8, \3                                
00000000                           432      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           433      LSR.L #8, \3
00000000                           434      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           435      ANDI.B #$0F,\3
00000000                           436      OR.B \3,\4
00000000                           437      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           438      ENDM
00000000                           439  
00000000                           440  ; send command
00000000                           441  ; \1 = command, \2 = working data register 1,
00000000                           442  SEND_COMMAND MACRO
00000000                           443      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           444      ENDM
00000000                           445      
00000000                           446  ; send read command and wait
00000000                           447  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           448  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           449      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           450      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           451      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           452      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           453      WAIT_DRIVE_DRQ \2, \3
00000000                           454      ENDM
00000000                           455  
00000000                           456  ; register catalogue
00000000                           457  ; D0 - used for simulator I/O
00000000                           458  ; D1 - used for simulator I/O
00000000                           459  ; D2 - read character
00000000                           460  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           461  ; D6 - working register used in R/W
00000000                           462  ; D7 - address accumulator, reset by download
00000000                           463  ; A0 - address of string to print 
00000000                           464  
00000000                           465  ; start vector
00000000= 002E0000                 466  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 467  RESET   DC.L START                              ; RESET
00000008= 00001CD0                 468  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001CD0                 469          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001E24                 470          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001E34                 471          DC.L UNHANDLED_HANDLER
00000018= 00001E34                 472          DC.L UNHANDLED_HANDLER
0000001C= 00001E34                 473          DC.L UNHANDLED_HANDLER
00000020= 00001E34                 474          DC.L UNHANDLED_HANDLER
00000024= 00001E34                 475          DC.L UNHANDLED_HANDLER
00000028= 00001E34                 476          DC.L UNHANDLED_HANDLER
0000002C= 00001E34                 477          DC.L UNHANDLED_HANDLER
00000030= 00001E34                 478          DC.L UNHANDLED_HANDLER
00000034= 00001E34                 479          DC.L UNHANDLED_HANDLER
00000038= 00001E34                 480          DC.L UNHANDLED_HANDLER
0000003C= 00001E34                 481          DC.L UNHANDLED_HANDLER
00000040= 00001E34                 482          DC.L UNHANDLED_HANDLER
00000044= 00001E34                 483          DC.L UNHANDLED_HANDLER
00000048= 00001E34                 484          DC.L UNHANDLED_HANDLER
0000004C= 00001E34                 485          DC.L UNHANDLED_HANDLER
00000050= 00001E34                 486          DC.L UNHANDLED_HANDLER
00000054= 00001E34                 487          DC.L UNHANDLED_HANDLER
00000058= 00001E34                 488          DC.L UNHANDLED_HANDLER
0000005C= 00001E34                 489          DC.L UNHANDLED_HANDLER
00000060= 00001E58                 490          DC.L SPURIOUS_HANDLER
00000064= 00001E34                 491          DC.L UNHANDLED_HANDLER
00000068= 00001E34                 492          DC.L UNHANDLED_HANDLER
0000006C= 00001E34                 493          DC.L UNHANDLED_HANDLER
00000070= 00001E34                 494          DC.L UNHANDLED_HANDLER
00000074= 00001E34                 495          DC.L UNHANDLED_HANDLER
00000078= 00001E34                 496          DC.L UNHANDLED_HANDLER
0000007C= 00001E34                 497          DC.L UNHANDLED_HANDLER
00000080= 00001E34                 498          DC.L UNHANDLED_HANDLER
00000084= 00001E34                 499          DC.L UNHANDLED_HANDLER
00000088= 00001E34                 500          DC.L UNHANDLED_HANDLER
0000008C= 00001E34                 501          DC.L UNHANDLED_HANDLER
00000090= 00001E34                 502          DC.L UNHANDLED_HANDLER
00000094= 00001E34                 503          DC.L UNHANDLED_HANDLER
00000098= 00001E34                 504          DC.L UNHANDLED_HANDLER
0000009C= 00001E34                 505          DC.L UNHANDLED_HANDLER
000000A0= 00001E34                 506          DC.L UNHANDLED_HANDLER
000000A4= 00001E34                 507          DC.L UNHANDLED_HANDLER
000000A8= 00001E34                 508          DC.L UNHANDLED_HANDLER
000000AC= 00001E34                 509          DC.L UNHANDLED_HANDLER
000000B0= 00001E34                 510          DC.L UNHANDLED_HANDLER
000000B4= 00001E34                 511          DC.L UNHANDLED_HANDLER
000000B8= 00001E34                 512          DC.L UNHANDLED_HANDLER
000000BC= 00001E34                 513          DC.L UNHANDLED_HANDLER
000000C0= 00001E34                 514          DC.L UNHANDLED_HANDLER
000000C4= 00001E34                 515          DC.L UNHANDLED_HANDLER
000000C8= 00001E34                 516          DC.L UNHANDLED_HANDLER
000000CC= 00001E34                 517          DC.L UNHANDLED_HANDLER
000000D0= 00001E34                 518          DC.L UNHANDLED_HANDLER
000000D4= 00001E34                 519          DC.L UNHANDLED_HANDLER
000000D8= 00001E34                 520          DC.L UNHANDLED_HANDLER 
000000DC= 00001E34                 521          DC.L UNHANDLED_HANDLER
000000E0= 00001E34                 522          DC.L UNHANDLED_HANDLER
000000E4= 00001E34                 523          DC.L UNHANDLED_HANDLER 
000000E8= 00001E34                 524          DC.L UNHANDLED_HANDLER 
000000EC= 00001E34                 525          DC.L UNHANDLED_HANDLER
000000F0= 00001E34                 526          DC.L UNHANDLED_HANDLER 
000000F4= 00001E34                 527          DC.L UNHANDLED_HANDLER 
000000F8= 00001E34                 528          DC.L UNHANDLED_HANDLER 
000000FC= 00001E34                 529          DC.L UNHANDLED_HANDLER
00000100= 00001E48                 530  USER    DC.L TICK_HANDLER
00000104                           531      ; start of program  
00000104                           532  START
00000104  2E7C 002E0000            533      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       534      MOVE.B #0,DISPLAY
00000112                           535  
00000112  7000                     536      MOVE.L #0,D0
00000114  1039 00C00019            537      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           538  
0000011A                           539  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       540      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       541      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           542      
0000012A                           543      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                544s     MOVE.W  #$50,D1
0000012E  6000 000E                545s     BRA _20000001
00000132                           546s _20000000
00000132  13C1 00C00005            547          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     548          NOP
0000013A                           549      ENDF
0000013A  0441 0010                550s     SUB.W   #$10,D1
0000013E                           551s _20000001
0000013E  B27C 0010                552s     CMP.W   #$10,D1
00000142  6CEE                     553s     BGE _20000000
00000144                           554  
00000144                           555      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                556s     MOVE.W  #$50,D1
00000148  6000 000E                557s     BRA _20000003
0000014C                           558s _20000002
0000014C  13C1 00C00015            559          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     560          NOP
00000154                           561      ENDF
00000154  0441 0010                562s     SUB.W   #$10,D1
00000158                           563s _20000003
00000158  B27C 0010                564s     CMP.W   #$10,D1
0000015C  6CEE                     565s     BGE _20000002
0000015E                           566      
0000015E                           567  ;initialise UART
0000015E  13FC 0000 00C0000B       568      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       569      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       570      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       571      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       572      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           573  
00000186                           574  ; channel A
00000186  13FC 0013 00C00001       575      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       576      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       577      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       578      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           579  
000001A6                           580  ; channel B
000001A6  13FC 0013 00C00011       581      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       582      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       583      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       584      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       585      MOVE.B #64,DUART_IVR
000001CE                           586  
000001CE                           587m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           588m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      589m     IFEQ DEBUG
000001CE  1239 00C00003            590m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                591m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     592m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       593m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           594m     ENDC
000001E2                           595m 
000001E2                 FALSE     596m     IFNE DEBUG
000001E2                           597m     ENDC
000001E2                           598m 
000001E2                           599m     ENDM
000001E2                           600m     PRINT_CHAR #0,D1
000001E2                           601m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      602m     IFEQ DEBUG
000001E2  1239 00C00003            603m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                604m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     605m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       606m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           607m     ENDC
000001F6                           608m 
000001F6                 FALSE     609m     IFNE DEBUG
000001F6                           610m     ENDC
000001F6                           611m 
000001F6                           612m     ENDM
000001F6                           613m     PRINT_CHAR #0,D1
000001F6                           614m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      615m     IFEQ DEBUG
000001F6  1239 00C00003            616m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                617m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     618m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       619m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           620m     ENDC
0000020A                           621m 
0000020A                 FALSE     622m     IFNE DEBUG
0000020A                           623m     ENDC
0000020A                           624m 
0000020A                           625m     ENDM
0000020A                           626      
0000020A                           627      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                628s     CMP.W   #$0F,D0
0000020E  6600 0008                629s     BNE _00000000
00000212  1039 00C00005            630          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           631      ENDI
00000218                           632s _00000000
00000218                           633  
00000218  13FC 0001 00E00001       634      MOVE.B #1,DISPLAY
00000220                           635      
00000220                           636m     PRINT_CRLF D1,A0
00000220  41FA 1E81                637m     LEA CRLF(PC),A0
00000224                           638mm     PRINT_STR A0,D1
00000224                           639mm LOOP_5
00000224  0C10 0000                640mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                641mm     BEQ EXIT_5
0000022C                           642mmm     PRINT_CHAR (A0)+,D1
0000022C                           643mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      644mmm     IFEQ DEBUG
0000022C  1239 00C00003            645mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                646mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     647mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            648mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           649mmm     ENDC
0000023E                           650mmm 
0000023E                 FALSE     651mmm     IFNE DEBUG
0000023E                           652mmm     ENDC
0000023E                           653mmm 
0000023E                           654mmm     ENDM
0000023E  60E4                     655mm     BRA LOOP_5
00000240                           656mm EXIT_5
00000240                           657mm     ENDM
00000240                           658m     ENDM
00000240  41FA 1F16                659      LEA VERSION(PC),A0
00000244                           660m     PRINT_STR A0,D3
00000244                           661m LOOP_7
00000244  0C10 0000                662m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                663m     BEQ EXIT_7
0000024C                           664mm     PRINT_CHAR (A0)+,D3
0000024C                           665mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      666mm     IFEQ DEBUG
0000024C  1639 00C00003            667mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                668mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     669mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            670mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           671mm     ENDC
0000025E                           672mm 
0000025E                 FALSE     673mm     IFNE DEBUG
0000025E                           674mm     ENDC
0000025E                           675mm 
0000025E                           676mm     ENDM
0000025E  60E4                     677m     BRA LOOP_7
00000260                           678m EXIT_7
00000260                           679m     ENDM
00000260                           680  
00000260  41F9 00002176            681      LEA END,A0
00000266  2008                     682      MOVE.L A0,D0
00000268                           683m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1E3F                684m     LEA OX(PC),A0
0000026C                           685mm     PRINT_STR A0,D1
0000026C                           686mm LOOP_10
0000026C  0C10 0000                687mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                688mm     BEQ EXIT_10
00000274                           689mmm     PRINT_CHAR (A0)+,D1
00000274                           690mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      691mmm     IFEQ DEBUG
00000274  1239 00C00003            692mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                693mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     694mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            695mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           696mmm     ENDC
00000286                           697mmm 
00000286                 FALSE     698mmm     IFNE DEBUG
00000286                           699mmm     ENDC
00000286                           700mmm 
00000286                           701mmm     ENDM
00000286  60E4                     702mm     BRA LOOP_10
00000288                           703mm EXIT_10
00000288                           704mm     ENDM
00000288  7607                     705m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           706m LOOP_9
0000028A                           707mm     BIN2HEX D0,D2,A0
0000028A  41FA 1DDC                708mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     709mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     710mm     MOVE.B D0,D2
00000292  0282 0000000F            711mm     ANDI.L #$F,D2
00000298  1430 2000                712mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           713mm     ENDM
0000029C                           714mm     PRINT_CHAR D2,D1
0000029C                           715mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      716mm     IFEQ DEBUG
0000029C  1239 00C00003            717mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                718mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     719mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            720mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           721mm     ENDC
000002AE                           722mm 
000002AE                 FALSE     723mm     IFNE DEBUG
000002AE                           724mm     ENDC
000002AE                           725mm 
000002AE                           726mm     ENDM
000002AE  57CB FFDA                727m     DBEQ D3,LOOP_9
000002B2                           728m     ENDM
000002B2                           729m     PRINT_CRLF D1,A0
000002B2  41FA 1DEF                730m     LEA CRLF(PC),A0
000002B6                           731mm     PRINT_STR A0,D1
000002B6                           732mm LOOP_15
000002B6  0C10 0000                733mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                734mm     BEQ EXIT_15
000002BE                           735mmm     PRINT_CHAR (A0)+,D1
000002BE                           736mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      737mmm     IFEQ DEBUG
000002BE  1239 00C00003            738mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                739mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     740mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            741mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           742mmm     ENDC
000002D0                           743mmm 
000002D0                 FALSE     744mmm     IFNE DEBUG
000002D0                           745mmm     ENDC
000002D0                           746mmm 
000002D0                           747mmm     ENDM
000002D0  60E4                     748mm     BRA LOOP_15
000002D2                           749mm EXIT_15
000002D2                           750mm     ENDM
000002D2                           751m     ENDM
000002D2                           752  
000002D2  41FA 1BAA                753      LEA HELPPROMPT(PC),A0
000002D6                           754m     PRINT_STR A0,D3
000002D6                           755m LOOP_17
000002D6  0C10 0000                756m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                757m     BEQ EXIT_17
000002DE                           758mm     PRINT_CHAR (A0)+,D3
000002DE                           759mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      760mm     IFEQ DEBUG
000002DE  1639 00C00003            761mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                762mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     763mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            764mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           765mm     ENDC
000002F0                           766mm 
000002F0                 FALSE     767mm     IFNE DEBUG
000002F0                           768mm     ENDC
000002F0                           769mm 
000002F0                           770mm     ENDM
000002F0  60E4                     771m     BRA LOOP_17
000002F2                           772m EXIT_17
000002F2                           773m     ENDM
000002F2                           774  
000002F2                           775m     PRINT_CRLF D3,A0
000002F2  41FA 1DAF                776m     LEA CRLF(PC),A0
000002F6                           777mm     PRINT_STR A0,D3
000002F6                           778mm LOOP_20
000002F6  0C10 0000                779mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                780mm     BEQ EXIT_20
000002FE                           781mmm     PRINT_CHAR (A0)+,D3
000002FE                           782mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      783mmm     IFEQ DEBUG
000002FE  1639 00C00003            784mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                785mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     786mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            787mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           788mmm     ENDC
00000310                           789mmm 
00000310                 FALSE     790mmm     IFNE DEBUG
00000310                           791mmm     ENDC
00000310                           792mmm 
00000310                           793mmm     ENDM
00000310  60E4                     794mm     BRA LOOP_20
00000312                           795mm EXIT_20
00000312                           796mm     ENDM
00000312                           797m     ENDM
00000312                           798  
00000312  7E00                     799      MOVE.L #0,D7                                    ; address accumulator
00000314                           800  
00000314  13FC 0002 00E00001       801      MOVE.B #2,DISPLAY
0000031C                           802      
0000031C  13FC 0000 00A00001       803      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       804      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       805      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       806      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           807      
0000033C  13FC 0003 00E00001       808      MOVE.B #3,DISPLAY
00000344                           809      
00000344                           810      
00000344                           811  MAIN_LOOP
00000344  41FA 1D60                812      LEA PROMPT(PC),A0
00000348                           813m     PRINT_STR A0,D3
00000348                           814m LOOP_22
00000348  0C10 0000                815m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                816m     BEQ EXIT_22
00000350                           817mm     PRINT_CHAR (A0)+,D3
00000350                           818mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      819mm     IFEQ DEBUG
00000350  1639 00C00003            820mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                821mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     822mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            823mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           824mm     ENDC
00000362                           825mm 
00000362                 FALSE     826mm     IFNE DEBUG
00000362                           827mm     ENDC
00000362                           828mm 
00000362                           829mm     ENDM
00000362  60E4                     830m     BRA LOOP_22
00000364                           831m EXIT_22
00000364                           832m     ENDM
00000364                           833  
00000364                           834  GET_INPUT
00000364                           835m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           836m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      837m     IFEQ DEBUG
00000364  1639 00C00003            838m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                839m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     840m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           841m     ENDC
00000370                           842m 
00000370                           843mm     READ_CHAR D2
00000370                 TRUE      844mm     IFEQ DEBUG
00000370  1439 00C00007            845mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           846mm     ENDC
00000376                 FALSE     847mm     IFNE DEBUG
00000376                           848mm     ENDC
00000376                           849mm 
00000376  B43C 001B                850mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                851mm     BEQ START
0000037E                           852mm     ENDM
0000037E                           853m 
0000037E                 TRUE      854m     IFEQ DEBUG
0000037E                           855mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           856mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      857mm     IFEQ DEBUG
0000037E  1639 00C00003            858mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                859mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     860mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            861mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           862mm     ENDC
00000390                           863mm 
00000390                 FALSE     864mm     IFNE DEBUG
00000390                           865mm     ENDC
00000390                           866mm 
00000390                           867mm     ENDM
00000390                           868m     ENDC
00000390                           869m     ENDM
00000390                           870  
00000390                           871      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                872s     CMP.B   #'0',D2
00000394  6D00 000E                873s     BLT _00000001
00000398  B43C 0039                874s     CMP.B   #'9',D2
0000039C  6E00 0006                875s     BGT _00000001
000003A0  6000 1914                876          BRA HEX_DIGIT
000003A4                           877      ENDI
000003A4                           878s _00000001
000003A4                           879      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                880s     CMP.B   #'A',D2
000003A8  6D00 000E                881s     BLT _00000002
000003AC  B43C 0046                882s     CMP.B   #'F',D2
000003B0  6E00 0006                883s     BGT _00000002
000003B4  6000 1900                884          BRA HEX_DIGIT
000003B8                           885      ENDI
000003B8                           886s _00000002
000003B8                           887  
000003B8  B43C 0077                888      CMP.B #'w',D2
000003BC  6700 01C6                889      BEQ W
000003C0                           890  
000003C0  B43C 006C                891      CMP.B #'l',D2
000003C4  6700 09A8                892      BEQ L 
000003C8                           893  
000003C8  B43C 0070                894      CMP.B #'p',D2
000003CC  6700 0C82                895      BEQ P
000003D0                           896  
000003D0                           897m     PRINT_CRLF D3,A0
000003D0  41FA 1CD1                898m     LEA CRLF(PC),A0
000003D4                           899mm     PRINT_STR A0,D3
000003D4                           900mm LOOP_28
000003D4  0C10 0000                901mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                902mm     BEQ EXIT_28
000003DC                           903mmm     PRINT_CHAR (A0)+,D3
000003DC                           904mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      905mmm     IFEQ DEBUG
000003DC  1639 00C00003            906mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                907mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     908mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            909mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           910mmm     ENDC
000003EE                           911mmm 
000003EE                 FALSE     912mmm     IFNE DEBUG
000003EE                           913mmm     ENDC
000003EE                           914mmm 
000003EE                           915mmm     ENDM
000003EE  60E4                     916mm     BRA LOOP_28
000003F0                           917mm EXIT_28
000003F0                           918mm     ENDM
000003F0                           919m     ENDM
000003F0                           920   
000003F0  B43C 003F                921      CMP.B #'?',D2
000003F4  6700 008A                922      BEQ H
000003F8                           923   
000003F8  B43C 0076                924      CMP.B #'v',D2
000003FC  6700 008A                925      BEQ V
00000400                           926      
00000400  B43C 0072                927      CMP.B #'r',D2
00000404  6700 00A6                928      BEQ R
00000408                           929  
00000408  B43C 0073                930      CMP.B #'s',D2
0000040C  6700 01F0                931      BEQ S
00000410                           932  
00000410  B43C 0067                933      CMP.B #'g',D2
00000414  6700 0862                934      BEQ G   
00000418                           935  
00000418  B43C 007A                936      CMP.B #'z',D2
0000041C  6700 0860                937      BEQ Z   
00000420                           938  
00000420  B43C 0078                939      CMP.B #'x',D2
00000424  6700 0DFA                940      BEQ X
00000428                           941  
00000428  B43C 0049                942      CMP.B #'I',D2
0000042C  6700 0F0E                943      BEQ EI
00000430                           944  
00000430  B43C 006F                945      CMP.B #'o',D2
00000434  6700 0F16                946      BEQ DI
00000438                           947  
00000438  B43C 0023                948      CMP.B #'#',D2
0000043C  6700 0F1E                949      BEQ HASH
00000440                           950  
00000440  B43C 0069                951      CMP.B #'i',D2
00000444  2A7C 00000000            952      MOVE.L #0, A5               ; not boot
0000044A  6700 0F26                953      BEQ IB
0000044E                           954  
0000044E  B43C 0062                955      CMP.B #'b',D2
00000452  2A7C 00000001            956      MOVE.L #1, A5               ; boot
00000458  6700 0F18                957      BEQ IB
0000045C                           958  
0000045C  41FA 1BA8                959      LEA HUH(PC),A0
00000460                           960m     PRINT_STR A0,D3
00000460                           961m LOOP_30
00000460  0C10 0000                962m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000464  6700 0016                963m     BEQ EXIT_30
00000468                           964mm     PRINT_CHAR (A0)+,D3
00000468                           965mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      966mm     IFEQ DEBUG
00000468  1639 00C00003            967mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000046E  0803 0002                968mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000472  67F4                     969mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000474  13D8 00C00007            970mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047A                           971mm     ENDC
0000047A                           972mm 
0000047A                 FALSE     973mm     IFNE DEBUG
0000047A                           974mm     ENDC
0000047A                           975mm 
0000047A                           976mm     ENDM
0000047A  60E4                     977m     BRA LOOP_30
0000047C                           978m EXIT_30
0000047C                           979m     ENDM
0000047C                           980  
0000047C  6000 FEC6                981      BRA MAIN_LOOP
00000480                           982  
00000480                           983  ; commands
00000480                           984  H
00000480  41FA 1A0F                985      LEA HELP(PC),A0
00000484  6000 0006                986      BRA PRINTIT
00000488                           987  
00000488                           988  V
00000488  41FA 1CCE                989      LEA VERSION(PC),A0
0000048C                           990  PRINTIT
0000048C                           991m     PRINT_STR A0,D3    
0000048C                           992m LOOP_32
0000048C  0C10 0000                993m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000490  6700 0016                994m     BEQ EXIT_32
00000494                           995mm     PRINT_CHAR (A0)+,D3
00000494                           996mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000494                 TRUE      997mm     IFEQ DEBUG
00000494  1639 00C00003            998mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000049A  0803 0002                999mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000049E  67F4                    1000mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
000004A0  13D8 00C00007           1001mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004A6                          1002mm     ENDC
000004A6                          1003mm 
000004A6                 FALSE    1004mm     IFNE DEBUG
000004A6                          1005mm     ENDC
000004A6                          1006mm 
000004A6                          1007mm     ENDM
000004A6  60E4                    1008m     BRA LOOP_32
000004A8                          1009m EXIT_32
000004A8                          1010m     ENDM
000004A8  6000 FE9A               1011      BRA MAIN_LOOP
000004AC                          1012  
000004AC                          1013  R
000004AC  2047                    1014      MOVE.L D7,A0                                    ; address accumulator -> address register
000004AE  7E00                    1015      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B0  2410                    1016      MOVE.L (A0),D2                                  ; read the memory and print it
000004B2                          1017m     PRINT_REG D2,D3,D4,D5,A0
000004B2  41FA 1BF5               1018m     LEA OX(PC),A0
000004B6                          1019mm     PRINT_STR A0,D3
000004B6                          1020mm LOOP_35
000004B6  0C10 0000               1021mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004BA  6700 0016               1022mm     BEQ EXIT_35
000004BE                          1023mmm     PRINT_CHAR (A0)+,D3
000004BE                          1024mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                 TRUE     1025mmm     IFEQ DEBUG
000004BE  1639 00C00003           1026mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004C4  0803 0002               1027mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C8  67F4                    1028mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004CA  13D8 00C00007           1029mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004D0                          1030mmm     ENDC
000004D0                          1031mmm 
000004D0                 FALSE    1032mmm     IFNE DEBUG
000004D0                          1033mmm     ENDC
000004D0                          1034mmm 
000004D0                          1035mmm     ENDM
000004D0  60E4                    1036mm     BRA LOOP_35
000004D2                          1037mm EXIT_35
000004D2                          1038mm     ENDM
000004D2  7A07                    1039m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004D4                          1040m LOOP_34
000004D4                          1041mm     BIN2HEX D2,D4,A0
000004D4  41FA 1B92               1042mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004D8  E99A                    1043mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004DA  1802                    1044mm     MOVE.B D2,D4
000004DC  0284 0000000F           1045mm     ANDI.L #$F,D4
000004E2  1830 4000               1046mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004E6                          1047mm     ENDM
000004E6                          1048mm     PRINT_CHAR D4,D3
000004E6                          1049mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E6                 TRUE     1050mm     IFEQ DEBUG
000004E6  1639 00C00003           1051mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EC  0803 0002               1052mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F0  67F4                    1053mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004F2  13C4 00C00007           1054mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F8                          1055mm     ENDC
000004F8                          1056mm 
000004F8                 FALSE    1057mm     IFNE DEBUG
000004F8                          1058mm     ENDC
000004F8                          1059mm 
000004F8                          1060mm     ENDM
000004F8  57CD FFDA               1061m     DBEQ D5,LOOP_34
000004FC                          1062m     ENDM
000004FC                          1063      
000004FC                          1064m     PRINT_CHAR #32,D3
000004FC                          1065m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FC                 TRUE     1066m     IFEQ DEBUG
000004FC  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000502  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000506  67F4                    1069m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000508  13FC 0020 00C00007      1070m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000510                          1071m     ENDC
00000510                          1072m 
00000510                 FALSE    1073m     IFNE DEBUG
00000510                          1074m     ENDC
00000510                          1075m 
00000510                          1076m     ENDM
00000510                          1077  
00000510  E19A                    1078      ROL.L #8,D2
00000512                          1079m     PRINT_CHAR D2,D3
00000512                          1080m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1081m     IFEQ DEBUG
00000512  1639 00C00003           1082m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1083m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1084m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1085m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1086m     ENDC
00000524                          1087m 
00000524                 FALSE    1088m     IFNE DEBUG
00000524                          1089m     ENDC
00000524                          1090m 
00000524                          1091m     ENDM
00000524  E19A                    1092      ROL.L #8,D2
00000526                          1093m     PRINT_CHAR D2,D3
00000526                          1094m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1095m     IFEQ DEBUG
00000526  1639 00C00003           1096m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1097m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1098m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1099m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1100m     ENDC
00000538                          1101m 
00000538                 FALSE    1102m     IFNE DEBUG
00000538                          1103m     ENDC
00000538                          1104m 
00000538                          1105m     ENDM
00000538  E19A                    1106      ROL.L #8,D2
0000053A                          1107m     PRINT_CHAR D2,D3
0000053A                          1108m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1109m     IFEQ DEBUG
0000053A  1639 00C00003           1110m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1111m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1112m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1113m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1114m     ENDC
0000054C                          1115m 
0000054C                 FALSE    1116m     IFNE DEBUG
0000054C                          1117m     ENDC
0000054C                          1118m 
0000054C                          1119m     ENDM
0000054C  E19A                    1120      ROL.L #8,D2
0000054E                          1121m     PRINT_CHAR D2,D3
0000054E                          1122m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054E                 TRUE     1123m     IFEQ DEBUG
0000054E  1639 00C00003           1124m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000554  0803 0002               1125m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000558  67F4                    1126m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000055A  13C2 00C00007           1127m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000560                          1128m     ENDC
00000560                          1129m 
00000560                 FALSE    1130m     IFNE DEBUG
00000560                          1131m     ENDC
00000560                          1132m 
00000560                          1133m     ENDM
00000560                          1134  
00000560                          1135m     PRINT_CRLF D3,A0
00000560  41FA 1B41               1136m     LEA CRLF(PC),A0
00000564                          1137mm     PRINT_STR A0,D3
00000564                          1138mm LOOP_45
00000564  0C10 0000               1139mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016               1140mm     BEQ EXIT_45
0000056C                          1141mmm     PRINT_CHAR (A0)+,D3
0000056C                          1142mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE     1143mmm     IFEQ DEBUG
0000056C  1639 00C00003           1144mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000572  0803 0002               1145mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                    1146mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007           1147mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                          1148mmm     ENDC
0000057E                          1149mmm 
0000057E                 FALSE    1150mmm     IFNE DEBUG
0000057E                          1151mmm     ENDC
0000057E                          1152mmm 
0000057E                          1153mmm     ENDM
0000057E  60E4                    1154mm     BRA LOOP_45
00000580                          1155mm EXIT_45
00000580                          1156mm     ENDM
00000580                          1157m     ENDM
00000580                          1158      
00000580  6000 FDC2               1159      BRA MAIN_LOOP
00000584                          1160  
00000584                          1161  W
00000584                          1162      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000584  3C3C 0000               1163s     MOVE.W  #0,D6
00000588  6000 0046               1164s     BRA _20000005
0000058C                          1165s _20000004
0000058C  E98D                    1166          LSL.L #4,D5                                     ; make what we have so far more significant
0000058E                          1167m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000058E                          1168m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058E                 TRUE     1169m     IFEQ DEBUG
0000058E  1639 00C00003           1170m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000594  0803 0000               1171m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000598  67F4                    1172m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
0000059A                          1173m     ENDC
0000059A                          1174m 
0000059A                          1175mm     READ_CHAR D2
0000059A                 TRUE     1176mm     IFEQ DEBUG
0000059A  1439 00C00007           1177mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000005A0                          1178mm     ENDC
000005A0                 FALSE    1179mm     IFNE DEBUG
000005A0                          1180mm     ENDC
000005A0                          1181mm 
000005A0  B43C 001B               1182mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000005A4  6700 FB5E               1183mm     BEQ START
000005A8                          1184mm     ENDM
000005A8                          1185m 
000005A8                 TRUE     1186m     IFEQ DEBUG
000005A8                          1187mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000005A8                          1188mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A8                 TRUE     1189mm     IFEQ DEBUG
000005A8  1639 00C00003           1190mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005AE  0803 0002               1191mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B2  67F4                    1192mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005B4  13C2 00C00007           1193mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005BA                          1194mm     ENDC
000005BA                          1195mm 
000005BA                 FALSE    1196mm     IFNE DEBUG
000005BA                          1197mm     ENDC
000005BA                          1198mm 
000005BA                          1199mm     ENDM
000005BA                          1200m     ENDC
000005BA                          1201m     ENDM
000005BA                          1202m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005BA  41FA 1ABC               1203m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005BE  0402 0030               1204m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005C2  C4BC 000000FF           1205m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005C8  1430 2000               1206m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005CC                          1207m     ENDM
000005CC  8A02                    1208          OR.B D2,D5
000005CE                          1209      ENDF
000005CE  5246                    1210s     ADD.W   #1,D6
000005D0                          1211s _20000005
000005D0  BC7C 0007               1212s     CMP.W   #7,D6
000005D4  6FB6                    1213s     BLE _20000004
000005D6                          1214  
000005D6                          1215m     PRINT_CRLF D3,A0
000005D6  41FA 1ACB               1216m     LEA CRLF(PC),A0
000005DA                          1217mm     PRINT_STR A0,D3
000005DA                          1218mm LOOP_52
000005DA  0C10 0000               1219mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005DE  6700 0016               1220mm     BEQ EXIT_52
000005E2                          1221mmm     PRINT_CHAR (A0)+,D3
000005E2                          1222mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                 TRUE     1223mmm     IFEQ DEBUG
000005E2  1639 00C00003           1224mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005E8  0803 0002               1225mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005EC  67F4                    1226mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005EE  13D8 00C00007           1227mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005F4                          1228mmm     ENDC
000005F4                          1229mmm 
000005F4                 FALSE    1230mmm     IFNE DEBUG
000005F4                          1231mmm     ENDC
000005F4                          1232mmm 
000005F4                          1233mmm     ENDM
000005F4  60E4                    1234mm     BRA LOOP_52
000005F6                          1235mm EXIT_52
000005F6                          1236mm     ENDM
000005F6                          1237m     ENDM
000005F6                          1238  
000005F6  2047                    1239      MOVE.L D7,A0                                    ; address accumulator -> address register
000005F8                          1240  
000005F8  2085                    1241      MOVE.L D5,(A0)                                  ; write the data
000005FA                          1242  
000005FA  6000 FD48               1243      BRA MAIN_LOOP
000005FE                          1244  
000005FE                          1245  ; register map for S
000005FE                          1246  ; A0 - start address
000005FE                          1247  ; A1 - offset
000005FE                          1248  ; A2 - next address to write
000005FE                          1249  ; A3 - next location (jmp)
000005FE                          1250  ; A4 - Working Address Register
000005FE                          1251  ; D0 - record count
000005FE                          1252  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005FE                          1253  ; D2 - checksum
000005FE                          1254  ; D3 - data byte count
000005FE                          1255  ; D4 - read address, moved into A2
000005FE                          1256  ; D5 - temp
000005FE                          1257  ; D6 - temp
000005FE                          1258  ; D7 - temp
000005FE                          1259  S
000005FE  2078 0000               1260      MOVE.L 0,A0                                     ; start address -> A0
00000602  2247                    1261      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000604  7E00                    1262      MOVE.L #0,D7
00000606  7000                    1263      MOVE.L #0,D0                                    ; count of records read -> D0
00000608                          1264          
00000608                          1265  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000608                          1266m     DOWNLOAD D1
00000608                          1267m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1268m 
00000608  1239 00C00003           1269m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000060E  0801 0000               1270m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000612  6700 0010               1271m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000616                          1272m 
00000616                          1273mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000616                 TRUE     1274mm     IFEQ DEBUG
00000616  1239 00C00007           1275mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000061C                          1276mm     ENDC
0000061C                 FALSE    1277mm     IFNE DEBUG
0000061C                          1278mm     ENDC
0000061C                          1279mm 
0000061C  B23C 001B               1280mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000620  6700 FAE2               1281mm     BEQ START
00000624                          1282mm     ENDM
00000624                          1283m CONTINUE_54
00000624  1239 00C00013           1284m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000062A  0801 0000               1285m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000062E  67D8                    1286m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
00000630                          1287m     
00000630  1239 00C00017           1288m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000636  13C1 00E00001           1289m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000063C                          1290m 
0000063C                          1291m     ENDM
0000063C  B23C 0053               1292      CMP.B #'S',D1                                   ; found S?
00000640  66C6                    1293      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000642                          1294      
00000642                          1295m     PRINT_CHAR #'.',D5                              ; print a progress indicator
00000642                          1296m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000642                 TRUE     1297m     IFEQ DEBUG
00000642  1A39 00C00003           1298m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000648  0805 0002               1299m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000064C  67F4                    1300m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000064E  13FC 002E 00C00007      1301m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000656                          1302m     ENDC
00000656                          1303m 
00000656                 FALSE    1304m     IFNE DEBUG
00000656                          1305m     ENDC
00000656                          1306m 
00000656                          1307m     ENDM
00000656                          1308      ;PRINT_CHAR #'S',D5                             ; print the S
00000656  5280                    1309      ADD.L #1,D0                                     ; read another S record, increment count
00000658                          1310      
00000658                          1311m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000658                          1312m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000658                          1313m 
00000658  1239 00C00003           1314m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000065E  0801 0000               1315m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000662  6700 0010               1316m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000666                          1317m 
00000666                          1318mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000666                 TRUE     1319mm     IFEQ DEBUG
00000666  1239 00C00007           1320mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000066C                          1321mm     ENDC
0000066C                 FALSE    1322mm     IFNE DEBUG
0000066C                          1323mm     ENDC
0000066C                          1324mm 
0000066C  B23C 001B               1325mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000670  6700 FA92               1326mm     BEQ START
00000674                          1327mm     ENDM
00000674                          1328m CONTINUE_57
00000674  1239 00C00013           1329m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000067A  0801 0000               1330m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000067E  67D8                    1331m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
00000680                          1332m     
00000680  1239 00C00017           1333m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000686  13C1 00E00001           1334m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000068C                          1335m 
0000068C                          1336m     ENDM
0000068C                          1337      ;PRINT_CHAR D1,D5
0000068C                          1338  
0000068C  7400                    1339      MOVE.L #0,D2                                    ; clear the checksum
0000068E                          1340  
0000068E                          1341m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000068E  1E3C 0002               1342m     MOVE.B #2,D7
00000692                          1343m     WHILE.B D7 <GT> 0 DO
00000692                          1344ms _10000000
00000692  BE38 0000               1345ms     CMP.B   0,D7
00000696  6F00 0050               1346ms     BLE _10000001
0000069A  E98B                    1347m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000069C                          1348mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000069C                          1349mm WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069C                          1350mm 
0000069C  1A39 00C00003           1351mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006A2  0805 0000               1352mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006A6  6700 0010               1353mm     BEQ CONTINUE_60                                 ; NOTHING, CONTINUE
000006AA                          1354mm 
000006AA                          1355mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006AA                 TRUE     1356mmm     IFEQ DEBUG
000006AA  1A39 00C00007           1357mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006B0                          1358mmm     ENDC
000006B0                 FALSE    1359mmm     IFNE DEBUG
000006B0                          1360mmm     ENDC
000006B0                          1361mmm 
000006B0  BA3C 001B               1362mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006B4  6700 FA4E               1363mmm     BEQ START
000006B8                          1364mmm     ENDM
000006B8                          1365mm CONTINUE_60
000006B8  1A39 00C00013           1366mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006BE  0805 0000               1367mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C2  67D8                    1368mm     BEQ WAIT_FOR_READY_60                           ; NOTHING, CHECK AGAIN
000006C4                          1369mm     
000006C4  1A39 00C00017           1370mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006CA  13C5 00E00001           1371mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006D0                          1372mm 
000006D0                          1373mm     ENDM
000006D0                          1374m         ;PRINT_CHAR D5,D6
000006D0                          1375mm         HEX2BIN D5,D5,A4
000006D0  49FA 19A6               1376mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006D4  0405 0030               1377mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006D8  CABC 000000FF           1378mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006DE  1A34 5000               1379mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006E2                          1380mm     ENDM
000006E2  8605                    1381m         OR.B D5,D3
000006E4  5307                    1382m         SUB.B #1,D7
000006E6                          1383m     ENDW
000006E6  60AA                    1384ms     BRA _10000000
000006E8                          1385ms _10000001
000006E8                          1386m 
000006E8  7A00                    1387m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006EA  1A03                    1388m     MOVE.B D3,D5
000006EC  D483                    1389m     ADD.L D3,D2
000006EE                          1390m 
000006EE                          1391m     ENDM
000006EE                          1392  
000006EE                          1393      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006EE  B23C 0030               1394s     CMP.B   #'0',D1
000006F2  6600 000A               1395s     BNE.L   _00000003
000006F6                          1396          ;PRINT_CRLF D5,A4
000006F6  6000 FF10               1397          BRA WAIT_FOR_SRECORD
000006FA                          1398      ELSE
000006FA  6000 0360               1399s     BRA _00000004
000006FE                          1400s _00000003
000006FE                          1401          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006FE  B23C 0031               1402s     CMP.B   #'1',D1
00000702  6708                    1403s     BEQ.S   _00000005
00000704  B23C 0032               1404s     CMP.B   #'2',D1
00000708  6600 01A8               1405s     BNE.L   _00000006
0000070C                          1406s _00000005
0000070C  5783                    1407              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000070E                          1408  
0000070E  7800                    1409              MOVE.L #0,D4                            ; read two bytes of address
00000710                          1410m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000710  1E3C 0002               1411m     MOVE.B #2,D7
00000714                          1412m     WHILE.B D7 <GT> 0 DO
00000714                          1413ms _10000002
00000714  BE38 0000               1414ms     CMP.B   0,D7
00000718  6F00 0050               1415ms     BLE _10000003
0000071C  E98C                    1416m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000071E                          1417mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000071E                          1418mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071E                          1419mm 
0000071E  1A39 00C00003           1420mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000724  0805 0000               1421mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000728  6700 0010               1422mm     BEQ CONTINUE_64                                 ; NOTHING, CONTINUE
0000072C                          1423mm 
0000072C                          1424mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000072C                 TRUE     1425mmm     IFEQ DEBUG
0000072C  1A39 00C00007           1426mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000732                          1427mmm     ENDC
00000732                 FALSE    1428mmm     IFNE DEBUG
00000732                          1429mmm     ENDC
00000732                          1430mmm 
00000732  BA3C 001B               1431mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000736  6700 F9CC               1432mmm     BEQ START
0000073A                          1433mmm     ENDM
0000073A                          1434mm CONTINUE_64
0000073A  1A39 00C00013           1435mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000740  0805 0000               1436mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000744  67D8                    1437mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
00000746                          1438mm     
00000746  1A39 00C00017           1439mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000074C  13C5 00E00001           1440mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000752                          1441mm 
00000752                          1442mm     ENDM
00000752                          1443m         ;PRINT_CHAR D5,D6
00000752                          1444mm         HEX2BIN D5,D5,A4
00000752  49FA 1924               1445mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000756  0405 0030               1446mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000075A  CABC 000000FF           1447mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000760  1A34 5000               1448mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000764                          1449mm     ENDM
00000764  8805                    1450m         OR.B D5,D4
00000766  5307                    1451m         SUB.B #1,D7
00000768                          1452m     ENDW
00000768  60AA                    1453ms     BRA _10000002
0000076A                          1454ms _10000003
0000076A                          1455m 
0000076A  7A00                    1456m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000076C  1A04                    1457m     MOVE.B D4,D5
0000076E  D484                    1458m     ADD.L D4,D2
00000770                          1459m 
00000770                          1460m     ENDM
00000770                          1461m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000770  1E3C 0002               1462m     MOVE.B #2,D7
00000774                          1463m     WHILE.B D7 <GT> 0 DO
00000774                          1464ms _10000004
00000774  BE38 0000               1465ms     CMP.B   0,D7
00000778  6F00 0050               1466ms     BLE _10000005
0000077C  E98C                    1467m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000077E                          1468mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000077E                          1469mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000077E                          1470mm 
0000077E  1A39 00C00003           1471mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000784  0805 0000               1472mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000788  6700 0010               1473mm     BEQ CONTINUE_68                                 ; NOTHING, CONTINUE
0000078C                          1474mm 
0000078C                          1475mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000078C                 TRUE     1476mmm     IFEQ DEBUG
0000078C  1A39 00C00007           1477mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000792                          1478mmm     ENDC
00000792                 FALSE    1479mmm     IFNE DEBUG
00000792                          1480mmm     ENDC
00000792                          1481mmm 
00000792  BA3C 001B               1482mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000796  6700 F96C               1483mmm     BEQ START
0000079A                          1484mmm     ENDM
0000079A                          1485mm CONTINUE_68
0000079A  1A39 00C00013           1486mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007A0  0805 0000               1487mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007A4  67D8                    1488mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
000007A6                          1489mm     
000007A6  1A39 00C00017           1490mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007AC  13C5 00E00001           1491mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007B2                          1492mm 
000007B2                          1493mm     ENDM
000007B2                          1494m         ;PRINT_CHAR D5,D6
000007B2                          1495mm         HEX2BIN D5,D5,A4
000007B2  49FA 18C4               1496mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007B6  0405 0030               1497mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007BA  CABC 000000FF           1498mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007C0  1A34 5000               1499mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007C4                          1500mm     ENDM
000007C4  8805                    1501m         OR.B D5,D4
000007C6  5307                    1502m         SUB.B #1,D7
000007C8                          1503m     ENDW
000007C8  60AA                    1504ms     BRA _10000004
000007CA                          1505ms _10000005
000007CA                          1506m 
000007CA  7A00                    1507m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007CC  1A04                    1508m     MOVE.B D4,D5
000007CE  D484                    1509m     ADD.L D4,D2
000007D0                          1510m 
000007D0                          1511m     ENDM
000007D0                          1512  
000007D0                          1513              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000007D0  B23C 0032               1514s     CMP.B   #'2',D1
000007D4  6600 0064               1515s     BNE.L   _00000007
000007D8  5383                    1516                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000007DA                          1517m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000007DA  1E3C 0002               1518m     MOVE.B #2,D7
000007DE                          1519m     WHILE.B D7 <GT> 0 DO
000007DE                          1520ms _10000006
000007DE  BE38 0000               1521ms     CMP.B   0,D7
000007E2  6F00 0050               1522ms     BLE _10000007
000007E6  E98C                    1523m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007E8                          1524mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007E8                          1525mm WAIT_FOR_READY_72                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007E8                          1526mm 
000007E8  1A39 00C00003           1527mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007EE  0805 0000               1528mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007F2  6700 0010               1529mm     BEQ CONTINUE_72                                 ; NOTHING, CONTINUE
000007F6                          1530mm 
000007F6                          1531mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007F6                 TRUE     1532mmm     IFEQ DEBUG
000007F6  1A39 00C00007           1533mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007FC                          1534mmm     ENDC
000007FC                 FALSE    1535mmm     IFNE DEBUG
000007FC                          1536mmm     ENDC
000007FC                          1537mmm 
000007FC  BA3C 001B               1538mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000800  6700 F902               1539mmm     BEQ START
00000804                          1540mmm     ENDM
00000804                          1541mm CONTINUE_72
00000804  1A39 00C00013           1542mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000080A  0805 0000               1543mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000080E  67D8                    1544mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
00000810                          1545mm     
00000810  1A39 00C00017           1546mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000816  13C5 00E00001           1547mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000081C                          1548mm 
0000081C                          1549mm     ENDM
0000081C                          1550m         ;PRINT_CHAR D5,D6
0000081C                          1551mm         HEX2BIN D5,D5,A4
0000081C  49FA 185A               1552mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000820  0405 0030               1553mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000824  CABC 000000FF           1554mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000082A  1A34 5000               1555mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000082E                          1556mm     ENDM
0000082E  8805                    1557m         OR.B D5,D4
00000830  5307                    1558m         SUB.B #1,D7
00000832                          1559m     ENDW
00000832  60AA                    1560ms     BRA _10000006
00000834                          1561ms _10000007
00000834                          1562m 
00000834  7A00                    1563m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000836  1A04                    1564m     MOVE.B D4,D5
00000838  D484                    1565m     ADD.L D4,D2
0000083A                          1566m 
0000083A                          1567m     ENDM
0000083A                          1568              ENDI
0000083A                          1569s _00000007
0000083A                          1570  
0000083A  2444                    1571              MOVE.L D4,A2                            ; put the address in an address register
0000083C  D5C9                    1572              ADD.L A1,A2                             ; add in the offset
0000083E                          1573  
0000083E                          1574              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000083E                          1575s _10000008
0000083E  B63C 0000               1576s     CMP.B   #0,D3
00000842  6F00 0068               1577s     BLE _10000009
00000846                          1578m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000846  1E3C 0002               1579m     MOVE.B #2,D7
0000084A                          1580m     WHILE.B D7 <GT> 0 DO
0000084A                          1581ms _1000000A
0000084A  BE38 0000               1582ms     CMP.B   0,D7
0000084E  6F00 0050               1583ms     BLE _1000000B
00000852  E989                    1584m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000854                          1585mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000854                          1586mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000854                          1587mm 
00000854  1A39 00C00003           1588mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000085A  0805 0000               1589mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000085E  6700 0010               1590mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
00000862                          1591mm 
00000862                          1592mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000862                 TRUE     1593mmm     IFEQ DEBUG
00000862  1A39 00C00007           1594mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000868                          1595mmm     ENDC
00000868                 FALSE    1596mmm     IFNE DEBUG
00000868                          1597mmm     ENDC
00000868                          1598mmm 
00000868  BA3C 001B               1599mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000086C  6700 F896               1600mmm     BEQ START
00000870                          1601mmm     ENDM
00000870                          1602mm CONTINUE_76
00000870  1A39 00C00013           1603mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000876  0805 0000               1604mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000087A  67D8                    1605mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
0000087C                          1606mm     
0000087C  1A39 00C00017           1607mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000882  13C5 00E00001           1608mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000888                          1609mm 
00000888                          1610mm     ENDM
00000888                          1611m         ;PRINT_CHAR D5,D6
00000888                          1612mm         HEX2BIN D5,D5,A4
00000888  49FA 17EE               1613mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000088C  0405 0030               1614mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000890  CABC 000000FF           1615mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000896  1A34 5000               1616mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000089A                          1617mm     ENDM
0000089A  8205                    1618m         OR.B D5,D1
0000089C  5307                    1619m         SUB.B #1,D7
0000089E                          1620m     ENDW
0000089E  60AA                    1621ms     BRA _1000000A
000008A0                          1622ms _1000000B
000008A0                          1623m 
000008A0  7A00                    1624m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008A2  1A01                    1625m     MOVE.B D1,D5
000008A4  D481                    1626m     ADD.L D1,D2
000008A6                          1627m 
000008A6                          1628m     ENDM
000008A6                          1629   
000008A6  14C1                    1630                  MOVE.B D1,(A2)+                     ; store it!
000008A8                          1631  
000008A8  5303                    1632                  SUB.B #1,D3                         ; 1 less byte to go
000008AA                          1633              ENDW
000008AA  6092                    1634s     BRA _10000008
000008AC                          1635s _10000009
000008AC                          1636  
000008AC  7200                    1637              MOVE.L #0,D1                            ; not done yet
000008AE                          1638          ELSE
000008AE  6000 01AC               1639s     BRA _00000008
000008B2                          1640s _00000006
000008B2                          1641              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000008B2  B23C 0038               1642s     CMP.B   #'8',D1
000008B6  6600 012E               1643s     BNE.L   _00000009
000008BA  7800                    1644                  MOVE.L #0,D4                        ; read the 24 bit start address
000008BC                          1645m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000008BC  1E3C 0002               1646m     MOVE.B #2,D7
000008C0                          1647m     WHILE.B D7 <GT> 0 DO
000008C0                          1648ms _1000000C
000008C0  BE38 0000               1649ms     CMP.B   0,D7
000008C4  6F00 0050               1650ms     BLE _1000000D
000008C8  E98C                    1651m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008CA                          1652mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008CA                          1653mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008CA                          1654mm 
000008CA  1A39 00C00003           1655mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008D0  0805 0000               1656mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008D4  6700 0010               1657mm     BEQ CONTINUE_80                                 ; NOTHING, CONTINUE
000008D8                          1658mm 
000008D8                          1659mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008D8                 TRUE     1660mmm     IFEQ DEBUG
000008D8  1A39 00C00007           1661mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008DE                          1662mmm     ENDC
000008DE                 FALSE    1663mmm     IFNE DEBUG
000008DE                          1664mmm     ENDC
000008DE                          1665mmm 
000008DE  BA3C 001B               1666mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008E2  6700 F820               1667mmm     BEQ START
000008E6                          1668mmm     ENDM
000008E6                          1669mm CONTINUE_80
000008E6  1A39 00C00013           1670mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008EC  0805 0000               1671mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008F0  67D8                    1672mm     BEQ WAIT_FOR_READY_80                           ; NOTHING, CHECK AGAIN
000008F2                          1673mm     
000008F2  1A39 00C00017           1674mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008F8  13C5 00E00001           1675mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008FE                          1676mm 
000008FE                          1677mm     ENDM
000008FE                          1678m         ;PRINT_CHAR D5,D6
000008FE                          1679mm         HEX2BIN D5,D5,A4
000008FE  49FA 1778               1680mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000902  0405 0030               1681mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000906  CABC 000000FF           1682mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000090C  1A34 5000               1683mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000910                          1684mm     ENDM
00000910  8805                    1685m         OR.B D5,D4
00000912  5307                    1686m         SUB.B #1,D7
00000914                          1687m     ENDW
00000914  60AA                    1688ms     BRA _1000000C
00000916                          1689ms _1000000D
00000916                          1690m 
00000916  7A00                    1691m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000918  1A04                    1692m     MOVE.B D4,D5
0000091A  D484                    1693m     ADD.L D4,D2
0000091C                          1694m 
0000091C                          1695m     ENDM
0000091C                          1696m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000091C  1E3C 0002               1697m     MOVE.B #2,D7
00000920                          1698m     WHILE.B D7 <GT> 0 DO
00000920                          1699ms _1000000E
00000920  BE38 0000               1700ms     CMP.B   0,D7
00000924  6F00 0050               1701ms     BLE _1000000F
00000928  E98C                    1702m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000092A                          1703mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000092A                          1704mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092A                          1705mm 
0000092A  1A39 00C00003           1706mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000930  0805 0000               1707mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000934  6700 0010               1708mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000938                          1709mm 
00000938                          1710mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000938                 TRUE     1711mmm     IFEQ DEBUG
00000938  1A39 00C00007           1712mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000093E                          1713mmm     ENDC
0000093E                 FALSE    1714mmm     IFNE DEBUG
0000093E                          1715mmm     ENDC
0000093E                          1716mmm 
0000093E  BA3C 001B               1717mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000942  6700 F7C0               1718mmm     BEQ START
00000946                          1719mmm     ENDM
00000946                          1720mm CONTINUE_84
00000946  1A39 00C00013           1721mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000094C  0805 0000               1722mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000950  67D8                    1723mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
00000952                          1724mm     
00000952  1A39 00C00017           1725mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000958  13C5 00E00001           1726mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000095E                          1727mm 
0000095E                          1728mm     ENDM
0000095E                          1729m         ;PRINT_CHAR D5,D6
0000095E                          1730mm         HEX2BIN D5,D5,A4
0000095E  49FA 1718               1731mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000962  0405 0030               1732mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000966  CABC 000000FF           1733mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000096C  1A34 5000               1734mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000970                          1735mm     ENDM
00000970  8805                    1736m         OR.B D5,D4
00000972  5307                    1737m         SUB.B #1,D7
00000974                          1738m     ENDW
00000974  60AA                    1739ms     BRA _1000000E
00000976                          1740ms _1000000F
00000976                          1741m 
00000976  7A00                    1742m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000978  1A04                    1743m     MOVE.B D4,D5
0000097A  D484                    1744m     ADD.L D4,D2
0000097C                          1745m 
0000097C                          1746m     ENDM
0000097C                          1747m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
0000097C  1E3C 0002               1748m     MOVE.B #2,D7
00000980                          1749m     WHILE.B D7 <GT> 0 DO
00000980                          1750ms _10000010
00000980  BE38 0000               1751ms     CMP.B   0,D7
00000984  6F00 0050               1752ms     BLE _10000011
00000988  E98C                    1753m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000098A                          1754mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000098A                          1755mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098A                          1756mm 
0000098A  1A39 00C00003           1757mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000990  0805 0000               1758mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000994  6700 0010               1759mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
00000998                          1760mm 
00000998                          1761mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000998                 TRUE     1762mmm     IFEQ DEBUG
00000998  1A39 00C00007           1763mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000099E                          1764mmm     ENDC
0000099E                 FALSE    1765mmm     IFNE DEBUG
0000099E                          1766mmm     ENDC
0000099E                          1767mmm 
0000099E  BA3C 001B               1768mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009A2  6700 F760               1769mmm     BEQ START
000009A6                          1770mmm     ENDM
000009A6                          1771mm CONTINUE_88
000009A6  1A39 00C00013           1772mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009AC  0805 0000               1773mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009B0  67D8                    1774mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
000009B2                          1775mm     
000009B2  1A39 00C00017           1776mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009B8  13C5 00E00001           1777mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009BE                          1778mm 
000009BE                          1779mm     ENDM
000009BE                          1780m         ;PRINT_CHAR D5,D6
000009BE                          1781mm         HEX2BIN D5,D5,A4
000009BE  49FA 16B8               1782mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009C2  0405 0030               1783mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009C6  CABC 000000FF           1784mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009CC  1A34 5000               1785mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009D0                          1786mm     ENDM
000009D0  8805                    1787m         OR.B D5,D4
000009D2  5307                    1788m         SUB.B #1,D7
000009D4                          1789m     ENDW
000009D4  60AA                    1790ms     BRA _10000010
000009D6                          1791ms _10000011
000009D6                          1792m 
000009D6  7A00                    1793m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009D8  1A04                    1794m     MOVE.B D4,D5
000009DA  D484                    1795m     ADD.L D4,D2
000009DC                          1796m 
000009DC                          1797m     ENDM
000009DC                          1798  
000009DC  2044                    1799                  MOVE.L D4,A0                        ; start address -> A0
000009DE  D1C9                    1800                  ADD.L A1,A0                         ; add in the offset
000009E0                          1801  
000009E0  72FF                    1802                  MOVE.L #$FFFFFFFF,D1                ; done
000009E2                          1803              ELSE
000009E2  6000 0078               1804s     BRA _0000000A
000009E6                          1805s _00000009
000009E6                          1806m                 PRINT_CRLF D5,A4
000009E6  49FA 16BB               1807m     LEA CRLF(PC),A4
000009EA                          1808mm     PRINT_STR A4,D5
000009EA                          1809mm LOOP_92
000009EA  0C14 0000               1810mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009EE  6700 0016               1811mm     BEQ EXIT_92
000009F2                          1812mmm     PRINT_CHAR (A4)+,D5
000009F2                          1813mmm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F2                 TRUE     1814mmm     IFEQ DEBUG
000009F2  1A39 00C00003           1815mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009F8  0805 0002               1816mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009FC  67F4                    1817mmm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
000009FE  13DC 00C00007           1818mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A04                          1819mmm     ENDC
00000A04                          1820mmm 
00000A04                 FALSE    1821mmm     IFNE DEBUG
00000A04                          1822mmm     ENDC
00000A04                          1823mmm 
00000A04                          1824mmm     ENDM
00000A04  60E4                    1825mm     BRA LOOP_92
00000A06                          1826mm EXIT_92
00000A06                          1827mm     ENDM
00000A06                          1828m     ENDM
00000A06                          1829  
00000A06  49FA 1627               1830                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000A0A                          1831m                 PRINT_STR A4,D5
00000A0A                          1832m LOOP_94
00000A0A  0C14 0000               1833m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A0E  6700 0016               1834m     BEQ EXIT_94
00000A12                          1835mm     PRINT_CHAR (A4)+,D5
00000A12                          1836mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A12                 TRUE     1837mm     IFEQ DEBUG
00000A12  1A39 00C00003           1838mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A18  0805 0002               1839mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A1C  67F4                    1840mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000A1E  13DC 00C00007           1841mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A24                          1842mm     ENDC
00000A24                          1843mm 
00000A24                 FALSE    1844mm     IFNE DEBUG
00000A24                          1845mm     ENDC
00000A24                          1846mm 
00000A24                          1847mm     ENDM
00000A24  60E4                    1848m     BRA LOOP_94
00000A26                          1849m EXIT_94
00000A26                          1850m     ENDM
00000A26                          1851m                 PRINT_CHAR D1,D5
00000A26                          1852m WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1853m     IFEQ DEBUG
00000A26  1A39 00C00003           1854m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A2C  0805 0002               1855m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1856m         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
00000A32  13C1 00C00007           1857m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A38                          1858m     ENDC
00000A38                          1859m 
00000A38                 FALSE    1860m     IFNE DEBUG
00000A38                          1861m     ENDC
00000A38                          1862m 
00000A38                          1863m     ENDM
00000A38                          1864m                 PRINT_CRLF D5,A4
00000A38  49FA 1669               1865m     LEA CRLF(PC),A4
00000A3C                          1866mm     PRINT_STR A4,D5
00000A3C                          1867mm LOOP_98
00000A3C  0C14 0000               1868mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A40  6700 0016               1869mm     BEQ EXIT_98
00000A44                          1870mmm     PRINT_CHAR (A4)+,D5
00000A44                          1871mmm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A44                 TRUE     1872mmm     IFEQ DEBUG
00000A44  1A39 00C00003           1873mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A4A  0805 0002               1874mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A4E  67F4                    1875mmm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
00000A50  13DC 00C00007           1876mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A56                          1877mmm     ENDC
00000A56                          1878mmm 
00000A56                 FALSE    1879mmm     IFNE DEBUG
00000A56                          1880mmm     ENDC
00000A56                          1881mmm 
00000A56                          1882mmm     ENDM
00000A56  60E4                    1883mm     BRA LOOP_98
00000A58                          1884mm EXIT_98
00000A58                          1885mm     ENDM
00000A58                          1886m     ENDM
00000A58                          1887  
00000A58  6000 FBAE               1888                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000A5C                          1889              ENDI
00000A5C                          1890s _0000000A
00000A5C                          1891          ENDI
00000A5C                          1892s _00000008
00000A5C                          1893      ENDI
00000A5C                          1894s _00000004
00000A5C                          1895  
00000A5C                          1896m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000A5C  1E3C 0002               1897m     MOVE.B #2,D7
00000A60                          1898m     WHILE.B D7 <GT> 0 DO
00000A60                          1899ms _10000012
00000A60  BE38 0000               1900ms     CMP.B   0,D7
00000A64  6F00 0050               1901ms     BLE _10000013
00000A68  E98C                    1902m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A6A                          1903mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A6A                          1904mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A6A                          1905mm 
00000A6A  1A39 00C00003           1906mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A70  0805 0000               1907mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A74  6700 0010               1908mm     BEQ CONTINUE_101                                    ; NOTHING, CONTINUE
00000A78                          1909mm 
00000A78                          1910mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A78                 TRUE     1911mmm     IFEQ DEBUG
00000A78  1A39 00C00007           1912mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A7E                          1913mmm     ENDC
00000A7E                 FALSE    1914mmm     IFNE DEBUG
00000A7E                          1915mmm     ENDC
00000A7E                          1916mmm 
00000A7E  BA3C 001B               1917mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A82  6700 F680               1918mmm     BEQ START
00000A86                          1919mmm     ENDM
00000A86                          1920mm CONTINUE_101
00000A86  1A39 00C00013           1921mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A8C  0805 0000               1922mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A90  67D8                    1923mm     BEQ WAIT_FOR_READY_101                          ; NOTHING, CHECK AGAIN
00000A92                          1924mm     
00000A92  1A39 00C00017           1925mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A98  13C5 00E00001           1926mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A9E                          1927mm 
00000A9E                          1928mm     ENDM
00000A9E                          1929m         ;PRINT_CHAR D5,D6
00000A9E                          1930mm         HEX2BIN D5,D5,A4
00000A9E  49FA 15D8               1931mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000AA2  0405 0030               1932mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AA6  CABC 000000FF           1933mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000AAC  1A34 5000               1934mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000AB0                          1935mm     ENDM
00000AB0  8805                    1936m         OR.B D5,D4
00000AB2  5307                    1937m         SUB.B #1,D7
00000AB4                          1938m     ENDW
00000AB4  60AA                    1939ms     BRA _10000012
00000AB6                          1940ms _10000013
00000AB6                          1941m 
00000AB6  7A00                    1942m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AB8  1A04                    1943m     MOVE.B D4,D5
00000ABA  D484                    1944m     ADD.L D4,D2
00000ABC                          1945m 
00000ABC                          1946m     ENDM
00000ABC                          1947  
00000ABC                          1948      IF.B D2 <NE> #$FF THEN.L
00000ABC  B43C 00FF               1949s     CMP.B   #$FF,D2
00000AC0  6700 00B0               1950s     BEQ.L   _0000000B
00000AC4                          1951m         PRINT_CRLF D5,A4
00000AC4  49FA 15DD               1952m     LEA CRLF(PC),A4
00000AC8                          1953mm     PRINT_STR A4,D5
00000AC8                          1954mm LOOP_105
00000AC8  0C14 0000               1955mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ACC  6700 0016               1956mm     BEQ EXIT_105
00000AD0                          1957mmm     PRINT_CHAR (A4)+,D5
00000AD0                          1958mmm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD0                 TRUE     1959mmm     IFEQ DEBUG
00000AD0  1A39 00C00003           1960mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD6  0805 0002               1961mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ADA  67F4                    1962mmm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000ADC  13DC 00C00007           1963mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AE2                          1964mmm     ENDC
00000AE2                          1965mmm 
00000AE2                 FALSE    1966mmm     IFNE DEBUG
00000AE2                          1967mmm     ENDC
00000AE2                          1968mmm 
00000AE2                          1969mmm     ENDM
00000AE2  60E4                    1970mm     BRA LOOP_105
00000AE4                          1971mm EXIT_105
00000AE4                          1972mm     ENDM
00000AE4                          1973m     ENDM
00000AE4  49FA 1560               1974          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000AE8                          1975m         PRINT_STR A4,D5
00000AE8                          1976m LOOP_107
00000AE8  0C14 0000               1977m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AEC  6700 0016               1978m     BEQ EXIT_107
00000AF0                          1979mm     PRINT_CHAR (A4)+,D5
00000AF0                          1980mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF0                 TRUE     1981mm     IFEQ DEBUG
00000AF0  1A39 00C00003           1982mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF6  0805 0002               1983mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFA  67F4                    1984mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AFC  13DC 00C00007           1985mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B02                          1986mm     ENDC
00000B02                          1987mm 
00000B02                 FALSE    1988mm     IFNE DEBUG
00000B02                          1989mm     ENDC
00000B02                          1990mm 
00000B02                          1991mm     ENDM
00000B02  60E4                    1992m     BRA LOOP_107
00000B04                          1993m EXIT_107
00000B04                          1994m     ENDM
00000B04                          1995m         PRINT_REG D0,D5,D3,D6,A4
00000B04  49FA 15A3               1996m     LEA OX(PC),A4
00000B08                          1997mm     PRINT_STR A4,D5
00000B08                          1998mm LOOP_110
00000B08  0C14 0000               1999mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B0C  6700 0016               2000mm     BEQ EXIT_110
00000B10                          2001mmm     PRINT_CHAR (A4)+,D5
00000B10                          2002mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B10                 TRUE     2003mmm     IFEQ DEBUG
00000B10  1A39 00C00003           2004mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B16  0805 0002               2005mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B1A  67F4                    2006mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000B1C  13DC 00C00007           2007mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B22                          2008mmm     ENDC
00000B22                          2009mmm 
00000B22                 FALSE    2010mmm     IFNE DEBUG
00000B22                          2011mmm     ENDC
00000B22                          2012mmm 
00000B22                          2013mmm     ENDM
00000B22  60E4                    2014mm     BRA LOOP_110
00000B24                          2015mm EXIT_110
00000B24                          2016mm     ENDM
00000B24  7C07                    2017m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B26                          2018m LOOP_109
00000B26                          2019mm     BIN2HEX D0,D3,A4
00000B26  49FA 1540               2020mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B2A  E998                    2021mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B2C  1600                    2022mm     MOVE.B D0,D3
00000B2E  0283 0000000F           2023mm     ANDI.L #$F,D3
00000B34  1634 3000               2024mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000B38                          2025mm     ENDM
00000B38                          2026mm     PRINT_CHAR D3,D5
00000B38                          2027mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B38                 TRUE     2028mm     IFEQ DEBUG
00000B38  1A39 00C00003           2029mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B3E  0805 0002               2030mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B42  67F4                    2031mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000B44  13C3 00C00007           2032mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B4A                          2033mm     ENDC
00000B4A                          2034mm 
00000B4A                 FALSE    2035mm     IFNE DEBUG
00000B4A                          2036mm     ENDC
00000B4A                          2037mm 
00000B4A                          2038mm     ENDM
00000B4A  57CE FFDA               2039m     DBEQ D6,LOOP_109
00000B4E                          2040m     ENDM
00000B4E                          2041m         PRINT_CRLF D5,A4
00000B4E  49FA 1553               2042m     LEA CRLF(PC),A4
00000B52                          2043mm     PRINT_STR A4,D5
00000B52                          2044mm LOOP_115
00000B52  0C14 0000               2045mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B56  6700 0016               2046mm     BEQ EXIT_115
00000B5A                          2047mmm     PRINT_CHAR (A4)+,D5
00000B5A                          2048mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     2049mmm     IFEQ DEBUG
00000B5A  1A39 00C00003           2050mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B60  0805 0002               2051mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B64  67F4                    2052mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000B66  13DC 00C00007           2053mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B6C                          2054mmm     ENDC
00000B6C                          2055mmm 
00000B6C                 FALSE    2056mmm     IFNE DEBUG
00000B6C                          2057mmm     ENDC
00000B6C                          2058mmm 
00000B6C                          2059mmm     ENDM
00000B6C  60E4                    2060mm     BRA LOOP_115
00000B6E                          2061mm EXIT_115
00000B6E                          2062mm     ENDM
00000B6E                          2063m     ENDM
00000B6E                          2064          
00000B6E  6000 F7D4               2065          BRA MAIN_LOOP
00000B72                          2066      ENDI
00000B72                          2067s _0000000B
00000B72                          2068  
00000B72                          2069      IF D1 <EQ> #0 THEN
00000B72  B27C 0000               2070s     CMP.W   #0,D1
00000B76  6600 0006               2071s     BNE _0000000C
00000B7A  6000 FA8C               2072        BRA WAIT_FOR_SRECORD
00000B7E                          2073      ENDI
00000B7E                          2074s _0000000C
00000B7E                          2075  DOWNLOAD_DONE
00000B7E                          2076m     PRINT_CRLF D5,A4
00000B7E  49FA 1523               2077m     LEA CRLF(PC),A4
00000B82                          2078mm     PRINT_STR A4,D5
00000B82                          2079mm LOOP_118
00000B82  0C14 0000               2080mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B86  6700 0016               2081mm     BEQ EXIT_118
00000B8A                          2082mmm     PRINT_CHAR (A4)+,D5
00000B8A                          2083mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B8A                 TRUE     2084mmm     IFEQ DEBUG
00000B8A  1A39 00C00003           2085mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B90  0805 0002               2086mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B94  67F4                    2087mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B96  13DC 00C00007           2088mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9C                          2089mmm     ENDC
00000B9C                          2090mmm 
00000B9C                 FALSE    2091mmm     IFNE DEBUG
00000B9C                          2092mmm     ENDC
00000B9C                          2093mmm 
00000B9C                          2094mmm     ENDM
00000B9C  60E4                    2095mm     BRA LOOP_118
00000B9E                          2096mm EXIT_118
00000B9E                          2097mm     ENDM
00000B9E                          2098m     ENDM
00000B9E                          2099m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000B9E  43FA 1509               2100m     LEA OX(PC),A1
00000BA2                          2101mm     PRINT_STR A1,D5
00000BA2                          2102mm LOOP_121
00000BA2  0C11 0000               2103mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BA6  6700 0016               2104mm     BEQ EXIT_121
00000BAA                          2105mmm     PRINT_CHAR (A1)+,D5
00000BAA                          2106mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAA                 TRUE     2107mmm     IFEQ DEBUG
00000BAA  1A39 00C00003           2108mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BB0  0805 0002               2109mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BB4  67F4                    2110mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000BB6  13D9 00C00007           2111mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BBC                          2112mmm     ENDC
00000BBC                          2113mmm 
00000BBC                 FALSE    2114mmm     IFNE DEBUG
00000BBC                          2115mmm     ENDC
00000BBC                          2116mmm 
00000BBC                          2117mmm     ENDM
00000BBC  60E4                    2118mm     BRA LOOP_121
00000BBE                          2119mm EXIT_121
00000BBE                          2120mm     ENDM
00000BBE  7407                    2121m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BC0                          2122m LOOP_120
00000BC0                          2123mm     BIN2HEX D0,D6,A1
00000BC0  43FA 14A6               2124mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BC4  E998                    2125mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC6  1C00                    2126mm     MOVE.B D0,D6
00000BC8  0286 0000000F           2127mm     ANDI.L #$F,D6
00000BCE  1C31 6000               2128mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000BD2                          2129mm     ENDM
00000BD2                          2130mm     PRINT_CHAR D6,D5
00000BD2                          2131mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                 TRUE     2132mm     IFEQ DEBUG
00000BD2  1A39 00C00003           2133mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD8  0805 0002               2134mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BDC  67F4                    2135mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BDE  13C6 00C00007           2136mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BE4                          2137mm     ENDC
00000BE4                          2138mm 
00000BE4                 FALSE    2139mm     IFNE DEBUG
00000BE4                          2140mm     ENDC
00000BE4                          2141mm 
00000BE4                          2142mm     ENDM
00000BE4  57CA FFDA               2143m     DBEQ D2,LOOP_120
00000BE8                          2144m     ENDM
00000BE8  43FA 1423               2145      LEA READ(PC),A1
00000BEC                          2146m     PRINT_STR A1,D5
00000BEC                          2147m LOOP_125
00000BEC  0C11 0000               2148m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BF0  6700 0016               2149m     BEQ EXIT_125
00000BF4                          2150mm     PRINT_CHAR (A1)+,D5
00000BF4                          2151mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF4                 TRUE     2152mm     IFEQ DEBUG
00000BF4  1A39 00C00003           2153mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BFA  0805 0002               2154mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BFE  67F4                    2155mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000C00  13D9 00C00007           2156mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C06                          2157mm     ENDC
00000C06                          2158mm 
00000C06                 FALSE    2159mm     IFNE DEBUG
00000C06                          2160mm     ENDC
00000C06                          2161mm 
00000C06                          2162mm     ENDM
00000C06  60E4                    2163m     BRA LOOP_125
00000C08                          2164m EXIT_125
00000C08                          2165m     ENDM
00000C08  2E08                    2166      MOVE.L A0,D7                                    ; set address accumulator to start address
00000C0A                          2167m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000C0A  43FA 149D               2168m     LEA OX(PC),A1
00000C0E                          2169mm     PRINT_STR A1,D5
00000C0E                          2170mm LOOP_128
00000C0E  0C11 0000               2171mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C12  6700 0016               2172mm     BEQ EXIT_128
00000C16                          2173mmm     PRINT_CHAR (A1)+,D5
00000C16                          2174mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C16                 TRUE     2175mmm     IFEQ DEBUG
00000C16  1A39 00C00003           2176mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C1C  0805 0002               2177mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C20  67F4                    2178mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000C22  13D9 00C00007           2179mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C28                          2180mmm     ENDC
00000C28                          2181mmm 
00000C28                 FALSE    2182mmm     IFNE DEBUG
00000C28                          2183mmm     ENDC
00000C28                          2184mmm 
00000C28                          2185mmm     ENDM
00000C28  60E4                    2186mm     BRA LOOP_128
00000C2A                          2187mm EXIT_128
00000C2A                          2188mm     ENDM
00000C2A  7407                    2189m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C2C                          2190m LOOP_127
00000C2C                          2191mm     BIN2HEX D7,D6,A1
00000C2C  43FA 143A               2192mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C30  E99F                    2193mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C32  1C07                    2194mm     MOVE.B D7,D6
00000C34  0286 0000000F           2195mm     ANDI.L #$F,D6
00000C3A  1C31 6000               2196mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C3E                          2197mm     ENDM
00000C3E                          2198mm     PRINT_CHAR D6,D5
00000C3E                          2199mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C3E                 TRUE     2200mm     IFEQ DEBUG
00000C3E  1A39 00C00003           2201mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C44  0805 0002               2202mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C48  67F4                    2203mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000C4A  13C6 00C00007           2204mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C50                          2205mm     ENDC
00000C50                          2206mm 
00000C50                 FALSE    2207mm     IFNE DEBUG
00000C50                          2208mm     ENDC
00000C50                          2209mm 
00000C50                          2210mm     ENDM
00000C50  57CA FFDA               2211m     DBEQ D2,LOOP_127
00000C54                          2212m     ENDM
00000C54                          2213m     PRINT_CRLF D5,A4
00000C54  49FA 144D               2214m     LEA CRLF(PC),A4
00000C58                          2215mm     PRINT_STR A4,D5
00000C58                          2216mm LOOP_133
00000C58  0C14 0000               2217mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C5C  6700 0016               2218mm     BEQ EXIT_133
00000C60                          2219mmm     PRINT_CHAR (A4)+,D5
00000C60                          2220mmm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C60                 TRUE     2221mmm     IFEQ DEBUG
00000C60  1A39 00C00003           2222mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C66  0805 0002               2223mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C6A  67F4                    2224mmm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C6C  13DC 00C00007           2225mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C72                          2226mmm     ENDC
00000C72                          2227mmm 
00000C72                 FALSE    2228mmm     IFNE DEBUG
00000C72                          2229mmm     ENDC
00000C72                          2230mmm 
00000C72                          2231mmm     ENDM
00000C72  60E4                    2232mm     BRA LOOP_133
00000C74                          2233mm EXIT_133
00000C74                          2234mm     ENDM
00000C74                          2235m     ENDM
00000C74                          2236  
00000C74  6000 F6CE               2237      BRA MAIN_LOOP
00000C78                          2238  
00000C78                          2239  G
00000C78  2047                    2240      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000C7A  7E00                    2241      MOVE.L #0,D7
00000C7C                          2242  
00000C7C  4ED0                    2243      JMP (A0)
00000C7E                          2244          
00000C7E                          2245  Z
00000C7E  207C 00200000           2246      MOVE.L #RAM,A0                                  ; address of RAM
00000C84  D1FC 00100000           2247      ADD.L #$100000,A0
00000C8A                          2248  
00000C8A                          2249      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000C8A  7000                    2250s     MOVE.L  #0,D0
00000C8C  6000 0012               2251s     BRA _20000007
00000C90                          2252s _20000006
00000C90  2200                    2253          MOVE.L D0,D1                                ; progress update
00000C92  E089                    2254          LSR.L #8,D1 
00000C94  E089                    2255          LSR.L #8,D1
00000C96  13C1 00E00001           2256          MOVE.B D1,DISPLAY
00000C9C                          2257          
00000C9C  2108                    2258          MOVE.L A0,-(A0)
00000C9E                          2259      ENDF
00000C9E  5880                    2260s     ADD.L   #4,D0
00000CA0                          2261s _20000007
00000CA0  B0BC 000FFFFC           2262s     CMP.L   #$FFFFC,D0
00000CA6  6FE8                    2263s     BLE _20000006
00000CA8                          2264  
00000CA8  207C 00200000           2265      MOVE.L #RAM,A0                                  ; address of RAM
00000CAE  D1FC 00100000           2266      ADD.L #$100000,A0
00000CB4                          2267  
00000CB4                          2268      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000CB4  7000                    2269s     MOVE.L  #0,D0
00000CB6  6000 00A8               2270s     BRA _20000009
00000CBA                          2271s _20000008
00000CBA  2200                    2272          MOVE.L D0,D1                                ; progress update
00000CBC  E089                    2273          LSR.L #8,D1
00000CBE  E089                    2274          LSR.L #8,D1
00000CC0  13C1 00E00001           2275          MOVE.B D1,DISPLAY
00000CC6                          2276  
00000CC6  2408                    2277          MOVE.L A0,D2
00000CC8  2220                    2278          MOVE.L -(A0),D1
00000CCA                          2279  
00000CCA                          2280          IF.L D2 <NE> D1 THEN
00000CCA  B481                    2281s     CMP.L   D1,D2
00000CCC  6700 0090               2282s     BEQ _0000000D
00000CD0  43FA 1385               2283              LEA RAM_ERROR(PC),A1
00000CD4                          2284m             PRINT_STR A1,D1
00000CD4                          2285m LOOP_135
00000CD4  0C11 0000               2286m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CD8  6700 0016               2287m     BEQ EXIT_135
00000CDC                          2288mm     PRINT_CHAR (A1)+,D1
00000CDC                          2289mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDC                 TRUE     2290mm     IFEQ DEBUG
00000CDC  1239 00C00003           2291mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000CE2  0801 0002               2292mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000CE6  67F4                    2293mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CE8  13D9 00C00007           2294mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CEE                          2295mm     ENDC
00000CEE                          2296mm 
00000CEE                 FALSE    2297mm     IFNE DEBUG
00000CEE                          2298mm     ENDC
00000CEE                          2299mm 
00000CEE                          2300mm     ENDM
00000CEE  60E4                    2301m     BRA LOOP_135
00000CF0                          2302m EXIT_135
00000CF0                          2303m     ENDM
00000CF0  2208                    2304              MOVE.L A0,D1
00000CF2  5981                    2305              SUB.L #4,D1
00000CF4                          2306m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000CF4  43FA 13B3               2307m     LEA OX(PC),A1
00000CF8                          2308mm     PRINT_STR A1,D3
00000CF8                          2309mm LOOP_138
00000CF8  0C11 0000               2310mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CFC  6700 0016               2311mm     BEQ EXIT_138
00000D00                          2312mmm     PRINT_CHAR (A1)+,D3
00000D00                          2313mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2314mmm     IFEQ DEBUG
00000D00  1639 00C00003           2315mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D06  0803 0002               2316mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2317mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000D0C  13D9 00C00007           2318mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D12                          2319mmm     ENDC
00000D12                          2320mmm 
00000D12                 FALSE    2321mmm     IFNE DEBUG
00000D12                          2322mmm     ENDC
00000D12                          2323mmm 
00000D12                          2324mmm     ENDM
00000D12  60E4                    2325mm     BRA LOOP_138
00000D14                          2326mm EXIT_138
00000D14                          2327mm     ENDM
00000D14  7C07                    2328m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D16                          2329m LOOP_137
00000D16                          2330mm     BIN2HEX D1,D2,A1
00000D16  43FA 1350               2331mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000D1A  E999                    2332mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D1C  1401                    2333mm     MOVE.B D1,D2
00000D1E  0282 0000000F           2334mm     ANDI.L #$F,D2
00000D24  1431 2000               2335mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000D28                          2336mm     ENDM
00000D28                          2337mm     PRINT_CHAR D2,D3
00000D28                          2338mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D28                 TRUE     2339mm     IFEQ DEBUG
00000D28  1639 00C00003           2340mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D2E  0803 0002               2341mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D32  67F4                    2342mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000D34  13C2 00C00007           2343mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D3A                          2344mm     ENDC
00000D3A                          2345mm 
00000D3A                 FALSE    2346mm     IFNE DEBUG
00000D3A                          2347mm     ENDC
00000D3A                          2348mm 
00000D3A                          2349mm     ENDM
00000D3A  57CE FFDA               2350m     DBEQ D6,LOOP_137
00000D3E                          2351m     ENDM
00000D3E                          2352m             PRINT_CRLF D3,A1
00000D3E  43FA 1363               2353m     LEA CRLF(PC),A1
00000D42                          2354mm     PRINT_STR A1,D3
00000D42                          2355mm LOOP_143
00000D42  0C11 0000               2356mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D46  6700 0016               2357mm     BEQ EXIT_143
00000D4A                          2358mmm     PRINT_CHAR (A1)+,D3
00000D4A                          2359mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D4A                 TRUE     2360mmm     IFEQ DEBUG
00000D4A  1639 00C00003           2361mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D50  0803 0002               2362mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D54  67F4                    2363mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D56  13D9 00C00007           2364mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D5C                          2365mmm     ENDC
00000D5C                          2366mmm 
00000D5C                 FALSE    2367mmm     IFNE DEBUG
00000D5C                          2368mmm     ENDC
00000D5C                          2369mmm 
00000D5C                          2370mmm     ENDM
00000D5C  60E4                    2371mm     BRA LOOP_143
00000D5E                          2372mm EXIT_143
00000D5E                          2373mm     ENDM
00000D5E                          2374m     ENDM
00000D5E                          2375          ENDI 
00000D5E                          2376s _0000000D
00000D5E                          2377      ENDF
00000D5E  5880                    2378s     ADD.L   #4,D0
00000D60                          2379s _20000009
00000D60  B0BC 000FFFFC           2380s     CMP.L   #$FFFFC,D0
00000D66  6F00 FF52               2381s     BLE _20000008
00000D6A                          2382  
00000D6A  6000 F5D8               2383      BRA MAIN_LOOP
00000D6E                          2384  
00000D6E                          2385  L
00000D6E  7000                    2386      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000D70  7200                    2387      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000D72                          2388  
00000D72                          2389      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000D72  343C 0000               2390s     MOVE.W  #0,D2
00000D76  6000 0046               2391s     BRA _2000000B
00000D7A                          2392s _2000000A
00000D7A  E989                    2393          LSL.L #4,D1                                 ; make what we have so far more significant
00000D7C                          2394m         WAIT_CHAR D3,D4                             ; next character -> D2
00000D7C                          2395m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7C                 TRUE     2396m     IFEQ DEBUG
00000D7C  1839 00C00003           2397m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000D82  0804 0000               2398m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000D86  67F4                    2399m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D88                          2400m     ENDC
00000D88                          2401m 
00000D88                          2402mm     READ_CHAR D3
00000D88                 TRUE     2403mm     IFEQ DEBUG
00000D88  1639 00C00007           2404mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000D8E                          2405mm     ENDC
00000D8E                 FALSE    2406mm     IFNE DEBUG
00000D8E                          2407mm     ENDC
00000D8E                          2408mm 
00000D8E  B63C 001B               2409mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000D92  6700 F370               2410mm     BEQ START
00000D96                          2411mm     ENDM
00000D96                          2412m 
00000D96                 TRUE     2413m     IFEQ DEBUG
00000D96                          2414mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000D96                          2415mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D96                 TRUE     2416mm     IFEQ DEBUG
00000D96  1839 00C00003           2417mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000D9C  0804 0002               2418mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000DA0  67F4                    2419mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000DA2  13C3 00C00007           2420mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DA8                          2421mm     ENDC
00000DA8                          2422mm 
00000DA8                 FALSE    2423mm     IFNE DEBUG
00000DA8                          2424mm     ENDC
00000DA8                          2425mm 
00000DA8                          2426mm     ENDM
00000DA8                          2427m     ENDC
00000DA8                          2428m     ENDM
00000DA8                          2429m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000DA8  41FA 12CE               2430m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000DAC  0403 0030               2431m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DB0  C6BC 000000FF           2432m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000DB6  1630 3000               2433m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000DBA                          2434m     ENDM
00000DBA  8203                    2435          OR.B D3,D1
00000DBC                          2436      ENDF
00000DBC  5242                    2437s     ADD.W   #1,D2
00000DBE                          2438s _2000000B
00000DBE  B47C 0007               2439s     CMP.W   #7,D2
00000DC2  6FB6                    2440s     BLE _2000000A
00000DC4                          2441  
00000DC4  3001                    2442      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000DC6  0480 00000104           2443      SUB.L #START,D0                                 ; remove the vector table from the length
00000DCC  E089                    2444      LSR.L #8,D1                                     ; extract the MSword for the address
00000DCE  E089                    2445      LSR.L #8,D1
00000DD0                          2446  
00000DD0                          2447m     PRINT_CRLF D2,A1
00000DD0  43FA 12D1               2448m     LEA CRLF(PC),A1
00000DD4                          2449mm     PRINT_STR A1,D2
00000DD4                          2450mm LOOP_150
00000DD4  0C11 0000               2451mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DD8  6700 0016               2452mm     BEQ EXIT_150
00000DDC                          2453mmm     PRINT_CHAR (A1)+,D2
00000DDC                          2454mmm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDC                 TRUE     2455mmm     IFEQ DEBUG
00000DDC  1439 00C00003           2456mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DE2  0802 0002               2457mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DE6  67F4                    2458mmm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DE8  13D9 00C00007           2459mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DEE                          2460mmm     ENDC
00000DEE                          2461mmm 
00000DEE                 FALSE    2462mmm     IFNE DEBUG
00000DEE                          2463mmm     ENDC
00000DEE                          2464mmm 
00000DEE                          2465mmm     ENDM
00000DEE  60E4                    2466mm     BRA LOOP_150
00000DF0                          2467mm EXIT_150
00000DF0                          2468mm     ENDM
00000DF0                          2469m     ENDM
00000DF0                          2470  
00000DF0  2041                    2471      MOVE.L D1,A0                                    ; target address
00000DF2  2641                    2472      MOVE.L D1,A3                                    ; keep a copy for later
00000DF4                          2473  
00000DF4  2247                    2474      MOVE.L D7,A1                                    ; address accumulator -> address register
00000DF6  D3FC 00000104           2475      ADD.L #START,A1                                 ; skip the vectors
00000DFC  2847                    2476      MOVE.L D7,A4                                    ; keep a clean copy for later
00000DFE  7E00                    2477      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E00                          2478  
00000E00                          2479m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000E00  31FC AAAA 2AAA          2480m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E06  4E71                    2481m     NOP
00000E08  31FC 5555 1554          2482m     MOVE.W #$5555,$1554
00000E0E  4E71                    2483m     NOP
00000E10  31FC 8080 2AAA          2484m     MOVE.W #$8080,$2AAA
00000E16  4E71                    2485m     NOP
00000E18  31FC AAAA 2AAA          2486m     MOVE.W #$AAAA,$2AAA
00000E1E  4E71                    2487m     NOP
00000E20  31FC 5555 1554          2488m     MOVE.W #$5555,$1554
00000E26  4E71                    2489m     NOP
00000E28  31FC 2020 2AAA          2490m     MOVE.W #$2020,$2AAA
00000E2E                          2491m     ENDM
00000E2E                          2492                      
00000E2E                          2493      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000E2E  3E3C 0000               2494s     MOVE.W  #$0,D7
00000E32  6000 0006               2495s     BRA _2000000D
00000E36                          2496s _2000000C
00000E36  4E71                    2497          NOP
00000E38                          2498      ENDF
00000E38  5247                    2499s     ADD.W   #1,D7
00000E3A                          2500s _2000000D
00000E3A  BE7C FFFF               2501s     CMP.W   #$FFFFFFFF,D7
00000E3E  6FF6                    2502s     BLE _2000000C
00000E40                          2503                  
00000E40  45FA 124D               2504      LEA LOADING(PC),A2
00000E44                          2505m     PRINT_STR A2,D2
00000E44                          2506m LOOP_153
00000E44  0C12 0000               2507m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E48  6700 0016               2508m     BEQ EXIT_153
00000E4C                          2509mm     PRINT_CHAR (A2)+,D2
00000E4C                          2510mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4C                 TRUE     2511mm     IFEQ DEBUG
00000E4C  1439 00C00003           2512mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E52  0802 0002               2513mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E56  67F4                    2514mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000E58  13DA 00C00007           2515mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E5E                          2516mm     ENDC
00000E5E                          2517mm 
00000E5E                 FALSE    2518mm     IFNE DEBUG
00000E5E                          2519mm     ENDC
00000E5E                          2520mm 
00000E5E                          2521mm     ENDM
00000E5E  60E4                    2522m     BRA LOOP_153
00000E60                          2523m EXIT_153
00000E60                          2524m     ENDM
00000E60                          2525          
00000E60  2409                    2526      MOVE.L A1,D2
00000E62                          2527m     PRINT_REG D2,D3,D4,D5,A2
00000E62  45FA 1245               2528m     LEA OX(PC),A2
00000E66                          2529mm     PRINT_STR A2,D3
00000E66                          2530mm LOOP_156
00000E66  0C12 0000               2531mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E6A  6700 0016               2532mm     BEQ EXIT_156
00000E6E                          2533mmm     PRINT_CHAR (A2)+,D3
00000E6E                          2534mmm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E6E                 TRUE     2535mmm     IFEQ DEBUG
00000E6E  1639 00C00003           2536mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E74  0803 0002               2537mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E78  67F4                    2538mmm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E7A  13DA 00C00007           2539mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E80                          2540mmm     ENDC
00000E80                          2541mmm 
00000E80                 FALSE    2542mmm     IFNE DEBUG
00000E80                          2543mmm     ENDC
00000E80                          2544mmm 
00000E80                          2545mmm     ENDM
00000E80  60E4                    2546mm     BRA LOOP_156
00000E82                          2547mm EXIT_156
00000E82                          2548mm     ENDM
00000E82  7A07                    2549m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E84                          2550m LOOP_155
00000E84                          2551mm     BIN2HEX D2,D4,A2
00000E84  45FA 11E2               2552mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E88  E99A                    2553mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E8A  1802                    2554mm     MOVE.B D2,D4
00000E8C  0284 0000000F           2555mm     ANDI.L #$F,D4
00000E92  1832 4000               2556mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E96                          2557mm     ENDM
00000E96                          2558mm     PRINT_CHAR D4,D3
00000E96                          2559mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E96                 TRUE     2560mm     IFEQ DEBUG
00000E96  1639 00C00003           2561mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E9C  0803 0002               2562mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EA0  67F4                    2563mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000EA2  13C4 00C00007           2564mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EA8                          2565mm     ENDC
00000EA8                          2566mm 
00000EA8                 FALSE    2567mm     IFNE DEBUG
00000EA8                          2568mm     ENDC
00000EA8                          2569mm 
00000EA8                          2570mm     ENDM
00000EA8  57CD FFDA               2571m     DBEQ D5,LOOP_155
00000EAC                          2572m     ENDM
00000EAC                          2573  
00000EAC  45FA 11FE               2574      LEA TO(PC),A2
00000EB0                          2575m     PRINT_STR A2,D3
00000EB0                          2576m LOOP_160
00000EB0  0C12 0000               2577m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EB4  6700 0016               2578m     BEQ EXIT_160
00000EB8                          2579mm     PRINT_CHAR (A2)+,D3
00000EB8                          2580mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EB8                 TRUE     2581mm     IFEQ DEBUG
00000EB8  1639 00C00003           2582mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EBE  0803 0002               2583mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EC2  67F4                    2584mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000EC4  13DA 00C00007           2585mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ECA                          2586mm     ENDC
00000ECA                          2587mm 
00000ECA                 FALSE    2588mm     IFNE DEBUG
00000ECA                          2589mm     ENDC
00000ECA                          2590mm 
00000ECA                          2591mm     ENDM
00000ECA  60E4                    2592m     BRA LOOP_160
00000ECC                          2593m EXIT_160
00000ECC                          2594m     ENDM
00000ECC                          2595  
00000ECC  2408                    2596      MOVE.L A0,D2
00000ECE                          2597m     PRINT_REG D2,D3,D4,D5,A2
00000ECE  45FA 11D9               2598m     LEA OX(PC),A2
00000ED2                          2599mm     PRINT_STR A2,D3
00000ED2                          2600mm LOOP_163
00000ED2  0C12 0000               2601mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000ED6  6700 0016               2602mm     BEQ EXIT_163
00000EDA                          2603mmm     PRINT_CHAR (A2)+,D3
00000EDA                          2604mmm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EDA                 TRUE     2605mmm     IFEQ DEBUG
00000EDA  1639 00C00003           2606mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EE0  0803 0002               2607mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EE4  67F4                    2608mmm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EE6  13DA 00C00007           2609mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EEC                          2610mmm     ENDC
00000EEC                          2611mmm 
00000EEC                 FALSE    2612mmm     IFNE DEBUG
00000EEC                          2613mmm     ENDC
00000EEC                          2614mmm 
00000EEC                          2615mmm     ENDM
00000EEC  60E4                    2616mm     BRA LOOP_163
00000EEE                          2617mm EXIT_163
00000EEE                          2618mm     ENDM
00000EEE  7A07                    2619m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EF0                          2620m LOOP_162
00000EF0                          2621mm     BIN2HEX D2,D4,A2
00000EF0  45FA 1176               2622mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EF4  E99A                    2623mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EF6  1802                    2624mm     MOVE.B D2,D4
00000EF8  0284 0000000F           2625mm     ANDI.L #$F,D4
00000EFE  1832 4000               2626mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F02                          2627mm     ENDM
00000F02                          2628mm     PRINT_CHAR D4,D3
00000F02                          2629mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F02                 TRUE     2630mm     IFEQ DEBUG
00000F02  1639 00C00003           2631mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F08  0803 0002               2632mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F0C  67F4                    2633mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000F0E  13C4 00C00007           2634mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F14                          2635mm     ENDC
00000F14                          2636mm 
00000F14                 FALSE    2637mm     IFNE DEBUG
00000F14                          2638mm     ENDC
00000F14                          2639mm 
00000F14                          2640mm     ENDM
00000F14  57CD FFDA               2641m     DBEQ D5,LOOP_162
00000F18                          2642m     ENDM
00000F18                          2643  
00000F18  45FA 1197               2644      LEA FOR(PC),A2
00000F1C                          2645m     PRINT_STR A2,D3
00000F1C                          2646m LOOP_167
00000F1C  0C12 0000               2647m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F20  6700 0016               2648m     BEQ EXIT_167
00000F24                          2649mm     PRINT_CHAR (A2)+,D3
00000F24                          2650mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F24                 TRUE     2651mm     IFEQ DEBUG
00000F24  1639 00C00003           2652mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2A  0803 0002               2653mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F2E  67F4                    2654mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000F30  13DA 00C00007           2655mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F36                          2656mm     ENDC
00000F36                          2657mm 
00000F36                 FALSE    2658mm     IFNE DEBUG
00000F36                          2659mm     ENDC
00000F36                          2660mm 
00000F36                          2661mm     ENDM
00000F36  60E4                    2662m     BRA LOOP_167
00000F38                          2663m EXIT_167
00000F38                          2664m     ENDM
00000F38                          2665m     PRINT_REG D0,D3,D4,D5,A2
00000F38  45FA 116F               2666m     LEA OX(PC),A2
00000F3C                          2667mm     PRINT_STR A2,D3
00000F3C                          2668mm LOOP_170
00000F3C  0C12 0000               2669mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F40  6700 0016               2670mm     BEQ EXIT_170
00000F44                          2671mmm     PRINT_CHAR (A2)+,D3
00000F44                          2672mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F44                 TRUE     2673mmm     IFEQ DEBUG
00000F44  1639 00C00003           2674mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F4A  0803 0002               2675mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F4E  67F4                    2676mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F50  13DA 00C00007           2677mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F56                          2678mmm     ENDC
00000F56                          2679mmm 
00000F56                 FALSE    2680mmm     IFNE DEBUG
00000F56                          2681mmm     ENDC
00000F56                          2682mmm 
00000F56                          2683mmm     ENDM
00000F56  60E4                    2684mm     BRA LOOP_170
00000F58                          2685mm EXIT_170
00000F58                          2686mm     ENDM
00000F58  7A07                    2687m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F5A                          2688m LOOP_169
00000F5A                          2689mm     BIN2HEX D0,D4,A2
00000F5A  45FA 110C               2690mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F5E  E998                    2691mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F60  1800                    2692mm     MOVE.B D0,D4
00000F62  0284 0000000F           2693mm     ANDI.L #$F,D4
00000F68  1832 4000               2694mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F6C                          2695mm     ENDM
00000F6C                          2696mm     PRINT_CHAR D4,D3
00000F6C                          2697mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F6C                 TRUE     2698mm     IFEQ DEBUG
00000F6C  1639 00C00003           2699mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F72  0803 0002               2700mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F76  67F4                    2701mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F78  13C4 00C00007           2702mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F7E                          2703mm     ENDC
00000F7E                          2704mm 
00000F7E                 FALSE    2705mm     IFNE DEBUG
00000F7E                          2706mm     ENDC
00000F7E                          2707mm 
00000F7E                          2708mm     ENDM
00000F7E  57CD FFDA               2709m     DBEQ D5,LOOP_169
00000F82                          2710m     ENDM
00000F82                          2711  
00000F82                          2712m     PRINT_CRLF D3,A2
00000F82  45FA 111F               2713m     LEA CRLF(PC),A2
00000F86                          2714mm     PRINT_STR A2,D3
00000F86                          2715mm LOOP_175
00000F86  0C12 0000               2716mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F8A  6700 0016               2717mm     BEQ EXIT_175
00000F8E                          2718mmm     PRINT_CHAR (A2)+,D3
00000F8E                          2719mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F8E                 TRUE     2720mmm     IFEQ DEBUG
00000F8E  1639 00C00003           2721mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F94  0803 0002               2722mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F98  67F4                    2723mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000F9A  13DA 00C00007           2724mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FA0                          2725mmm     ENDC
00000FA0                          2726mmm 
00000FA0                 FALSE    2727mmm     IFNE DEBUG
00000FA0                          2728mmm     ENDC
00000FA0                          2729mmm 
00000FA0                          2730mmm     ENDM
00000FA0  60E4                    2731mm     BRA LOOP_175
00000FA2                          2732mm EXIT_175
00000FA2                          2733mm     ENDM
00000FA2                          2734m     ENDM
00000FA2                          2735  
00000FA2                          2736      WHILE D0 <GT> #0 DO
00000FA2                          2737s _10000014
00000FA2  B07C 0000               2738s     CMP.W   #0,D0
00000FA6  6F00 001C               2739s     BLE _10000015
00000FAA  5580                    2740          SUB.L #2,D0
00000FAC                          2741  
00000FAC  13D1 00E00001           2742          MOVE.B (A1),DISPLAY
00000FB2                          2743m         PROGRAM (A1),(A0),D2
00000FB2  3091                    2744m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000FB4                          2745m 
00000FB4                          2746m WAIT_FOR_COMPLETE_177
00000FB4  3410                    2747m         MOVE.W (A0),D2
00000FB6                          2748m 
00000FB6                          2749m         IF.W D2 <NE> (A1) THEN
00000FB6  B451                    2750ms     CMP.W   (A1),D2
00000FB8  6700 0004               2751ms     BEQ _0000000E
00000FBC  60F6                    2752m             BRA WAIT_FOR_COMPLETE_177
00000FBE                          2753m         ENDI
00000FBE                          2754ms _0000000E
00000FBE                          2755m         ENDM
00000FBE                          2756                  
00000FBE  5488                    2757          ADD.L #2,A0
00000FC0  5489                    2758          ADD.L #2,A1
00000FC2                          2759      ENDW
00000FC2  60DE                    2760s     BRA _10000014
00000FC4                          2761s _10000015
00000FC4                          2762      
00000FC4  41F8 0000               2763      LEA STACK,A0
00000FC8  D1CC                    2764      ADD.L A4,A0
00000FCA  2010                    2765      MOVE.L (A0),D0
00000FCC                          2766      
00000FCC  207C 00000000           2767      MOVE.L #0,A0
00000FD2                          2768m     PROGRAM_VECTOR D0,A0,D2
00000FD2  5488                    2769m     ADD.L #2,A0
00000FD4                          2770mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000FD4  3080                    2771mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FD6                          2772mm 
00000FD6                          2773mm WAIT_FOR_COMPLETE_179
00000FD6  3410                    2774mm         MOVE.W (A0),D2
00000FD8                          2775mm 
00000FD8                          2776mm         IF.W D2 <NE> D0 THEN
00000FD8  B440                    2777mms     CMP.W   D0,D2
00000FDA  6700 0004               2778mms     BEQ _0000000F
00000FDE  60F6                    2779mm             BRA WAIT_FOR_COMPLETE_179
00000FE0                          2780mm         ENDI
00000FE0                          2781mms _0000000F
00000FE0                          2782mm         ENDM
00000FE0  E088                    2783m     LSR.L #8,D0
00000FE2  E088                    2784m     LSR.L #8,D0
00000FE4  5588                    2785m     SUB.L #2,A0
00000FE6                          2786mm     PROGRAM D0, (A0), D2
00000FE6  3080                    2787mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FE8                          2788mm 
00000FE8                          2789mm WAIT_FOR_COMPLETE_180
00000FE8  3410                    2790mm         MOVE.W (A0),D2
00000FEA                          2791mm 
00000FEA                          2792mm         IF.W D2 <NE> D0 THEN
00000FEA  B440                    2793mms     CMP.W   D0,D2
00000FEC  6700 0004               2794mms     BEQ _00000010
00000FF0  60F6                    2795mm             BRA WAIT_FOR_COMPLETE_180
00000FF2                          2796mm         ENDI
00000FF2                          2797mms _00000010
00000FF2                          2798mm         ENDM
00000FF2                          2799m     ENDM
00000FF2                          2800      
00000FF2                          2801      FOR A0 = #RESET TO #START-4 BY #4 DO
00000FF2  307C 0004               2802s     MOVE.W  #RESET,A0
00000FF6  6000 003C               2803s     BRA _2000000F
00000FFA                          2804s _2000000E
00000FFA                          2805  
00000FFA  2248                    2806          MOVE.L A0,A1
00000FFC  D3CC                    2807          ADD.L A4,A1
00000FFE                          2808              
00000FFE  2011                    2809          MOVE.L (A1),D0  
00001000  D081                    2810          ADD.L D1,D0
00001002  0480 00000104           2811          SUB.L #START,D0
00001008                          2812  
00001008  2408                    2813          MOVE.L A0,D2
0000100A                          2814          
0000100A  2408                    2815          MOVE.L A0,D2
0000100C  13C2 00E00001           2816          MOVE.B D2,DISPLAY
00001012                          2817m         PROGRAM_VECTOR D0,A0,D2
00001012  5488                    2818m     ADD.L #2,A0
00001014                          2819mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00001014  3080                    2820mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001016                          2821mm 
00001016                          2822mm WAIT_FOR_COMPLETE_182
00001016  3410                    2823mm         MOVE.W (A0),D2
00001018                          2824mm 
00001018                          2825mm         IF.W D2 <NE> D0 THEN
00001018  B440                    2826mms     CMP.W   D0,D2
0000101A  6700 0004               2827mms     BEQ _00000011
0000101E  60F6                    2828mm             BRA WAIT_FOR_COMPLETE_182
00001020                          2829mm         ENDI
00001020                          2830mms _00000011
00001020                          2831mm         ENDM
00001020  E088                    2832m     LSR.L #8,D0
00001022  E088                    2833m     LSR.L #8,D0
00001024  5588                    2834m     SUB.L #2,A0
00001026                          2835mm     PROGRAM D0, (A0), D2
00001026  3080                    2836mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001028                          2837mm 
00001028                          2838mm WAIT_FOR_COMPLETE_183
00001028  3410                    2839mm         MOVE.W (A0),D2
0000102A                          2840mm 
0000102A                          2841mm         IF.W D2 <NE> D0 THEN
0000102A  B440                    2842mms     CMP.W   D0,D2
0000102C  6700 0004               2843mms     BEQ _00000012
00001030  60F6                    2844mm             BRA WAIT_FOR_COMPLETE_183
00001032                          2845mm         ENDI
00001032                          2846mms _00000012
00001032                          2847mm         ENDM
00001032                          2848m     ENDM
00001032                          2849      ENDF
00001032  5848                    2850s     ADD.W   #4,A0
00001034                          2851s _2000000F
00001034  B0FC 0100               2852s     CMP.W   #START-4,A0
00001038  6FC0                    2853s     BLE _2000000E
0000103A                          2854                                          
0000103A                          2855m     PROTECT
0000103A  31FC AAAA 2AAA          2856m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001040  31FC 5555 1554          2857m     MOVE.W #$5555,$1554
00001046  31FC A0A0 2AAA          2858m     MOVE.W #$A0A0,$2AAA
0000104C                          2859m     ENDM
0000104C                          2860  
0000104C  6000 F2F6               2861      BRA MAIN_LOOP
00001050                          2862      
00001050                          2863  P
00001050  7000                    2864      MOVE.L #0,D0                                    ; D0 will be the data to write
00001052                          2865  
00001052                          2866      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00001052  323C 0000               2867s     MOVE.W  #0,D1
00001056  6000 0046               2868s     BRA _20000011
0000105A                          2869s _20000010
0000105A  E988                    2870          LSL.L #4,D0                                 ; make what we have so far more significant
0000105C                          2871m         WAIT_CHAR D2,D3                             ; next character -> D2
0000105C                          2872m WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000105C                 TRUE     2873m     IFEQ DEBUG
0000105C  1639 00C00003           2874m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001062  0803 0000               2875m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001066  67F4                    2876m         BEQ WAIT_FOR_READY_185                      ; NOTHING, CHECK AGAIN
00001068                          2877m     ENDC
00001068                          2878m 
00001068                          2879mm     READ_CHAR D2
00001068                 TRUE     2880mm     IFEQ DEBUG
00001068  1439 00C00007           2881mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000106E                          2882mm     ENDC
0000106E                 FALSE    2883mm     IFNE DEBUG
0000106E                          2884mm     ENDC
0000106E                          2885mm 
0000106E  B43C 001B               2886mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001072  6700 F090               2887mm     BEQ START
00001076                          2888mm     ENDM
00001076                          2889m 
00001076                 TRUE     2890m     IFEQ DEBUG
00001076                          2891mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001076                          2892mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001076                 TRUE     2893mm     IFEQ DEBUG
00001076  1639 00C00003           2894mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000107C  0803 0002               2895mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001080  67F4                    2896mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00001082  13C2 00C00007           2897mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001088                          2898mm     ENDC
00001088                          2899mm 
00001088                 FALSE    2900mm     IFNE DEBUG
00001088                          2901mm     ENDC
00001088                          2902mm 
00001088                          2903mm     ENDM
00001088                          2904m     ENDC
00001088                          2905m     ENDM
00001088                          2906m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001088  41FA 0FEE               2907m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000108C  0402 0030               2908m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001090  C4BC 000000FF           2909m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001096  1430 2000               2910m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000109A                          2911m     ENDM
0000109A  8002                    2912          OR.B D2,D0
0000109C                          2913      ENDF
0000109C  5241                    2914s     ADD.W   #1,D1
0000109E                          2915s _20000011
0000109E  B27C 0003               2916s     CMP.W   #3,D1
000010A2  6FB6                    2917s     BLE _20000010
000010A4                          2918  
000010A4                          2919m     PRINT_CRLF D2,A1
000010A4  43FA 0FFD               2920m     LEA CRLF(PC),A1
000010A8                          2921mm     PRINT_STR A1,D2
000010A8                          2922mm LOOP_190
000010A8  0C11 0000               2923mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010AC  6700 0016               2924mm     BEQ EXIT_190
000010B0                          2925mmm     PRINT_CHAR (A1)+,D2
000010B0                          2926mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010B0                 TRUE     2927mmm     IFEQ DEBUG
000010B0  1439 00C00003           2928mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010B6  0802 0002               2929mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010BA  67F4                    2930mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
000010BC  13D9 00C00007           2931mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010C2                          2932mmm     ENDC
000010C2                          2933mmm 
000010C2                 FALSE    2934mmm     IFNE DEBUG
000010C2                          2935mmm     ENDC
000010C2                          2936mmm 
000010C2                          2937mmm     ENDM
000010C2  60E4                    2938mm     BRA LOOP_190
000010C4                          2939mm EXIT_190
000010C4                          2940mm     ENDM
000010C4                          2941m     ENDM
000010C4                          2942  
000010C4  2047                    2943      MOVE.L D7,A0                                    ; address accumulator -> target address register
000010C6  7E00                    2944      MOVE.L #0,D7                                    ; clear the now used address accumulator
000010C8                          2945  
000010C8                          2946m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000010C8  31FC AAAA 2AAA          2947m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000010CE  4E71                    2948m     NOP
000010D0  31FC 5555 1554          2949m     MOVE.W #$5555,$1554
000010D6  4E71                    2950m     NOP
000010D8  31FC 8080 2AAA          2951m     MOVE.W #$8080,$2AAA
000010DE  4E71                    2952m     NOP
000010E0  31FC AAAA 2AAA          2953m     MOVE.W #$AAAA,$2AAA
000010E6  4E71                    2954m     NOP
000010E8  31FC 5555 1554          2955m     MOVE.W #$5555,$1554
000010EE  4E71                    2956m     NOP
000010F0  31FC 2020 2AAA          2957m     MOVE.W #$2020,$2AAA
000010F6                          2958m     ENDM
000010F6                          2959                              
000010F6                          2960      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000010F6  3E3C 0000               2961s     MOVE.W  #$0,D7
000010FA  6000 0006               2962s     BRA _20000013
000010FE                          2963s _20000012
000010FE  4E71                    2964          NOP
00001100                          2965      ENDF
00001100  5247                    2966s     ADD.W   #1,D7
00001102                          2967s _20000013
00001102  BE7C FFFF               2968s     CMP.W   #$FFFFFFFF,D7
00001106  6FF6                    2969s     BLE _20000012
00001108                          2970               
00001108  45FA 0F85               2971      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000110C                          2972m     PRINT_STR A2,D2
0000110C                          2973m LOOP_193
0000110C  0C12 0000               2974m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001110  6700 0016               2975m     BEQ EXIT_193
00001114                          2976mm     PRINT_CHAR (A2)+,D2
00001114                          2977mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001114                 TRUE     2978mm     IFEQ DEBUG
00001114  1439 00C00003           2979mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000111A  0802 0002               2980mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000111E  67F4                    2981mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00001120  13DA 00C00007           2982mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001126                          2983mm     ENDC
00001126                          2984mm 
00001126                 FALSE    2985mm     IFNE DEBUG
00001126                          2986mm     ENDC
00001126                          2987mm 
00001126                          2988mm     ENDM
00001126  60E4                    2989m     BRA LOOP_193
00001128                          2990m EXIT_193
00001128                          2991m     ENDM
00001128                          2992  
00001128                          2993m     PRINT_REG D0,D3,D4,D5,A2
00001128  45FA 0F7F               2994m     LEA OX(PC),A2
0000112C                          2995mm     PRINT_STR A2,D3
0000112C                          2996mm LOOP_196
0000112C  0C12 0000               2997mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001130  6700 0016               2998mm     BEQ EXIT_196
00001134                          2999mmm     PRINT_CHAR (A2)+,D3
00001134                          3000mmm WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001134                 TRUE     3001mmm     IFEQ DEBUG
00001134  1639 00C00003           3002mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000113A  0803 0002               3003mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000113E  67F4                    3004mmm         BEQ WAIT_FOR_READY_197                      ; NO SPACE, CHECK AGAIN
00001140  13DA 00C00007           3005mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001146                          3006mmm     ENDC
00001146                          3007mmm 
00001146                 FALSE    3008mmm     IFNE DEBUG
00001146                          3009mmm     ENDC
00001146                          3010mmm 
00001146                          3011mmm     ENDM
00001146  60E4                    3012mm     BRA LOOP_196
00001148                          3013mm EXIT_196
00001148                          3014mm     ENDM
00001148  7A07                    3015m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000114A                          3016m LOOP_195
0000114A                          3017mm     BIN2HEX D0,D4,A2
0000114A  45FA 0F1C               3018mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000114E  E998                    3019mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001150  1800                    3020mm     MOVE.B D0,D4
00001152  0284 0000000F           3021mm     ANDI.L #$F,D4
00001158  1832 4000               3022mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000115C                          3023mm     ENDM
0000115C                          3024mm     PRINT_CHAR D4,D3
0000115C                          3025mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000115C                 TRUE     3026mm     IFEQ DEBUG
0000115C  1639 00C00003           3027mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001162  0803 0002               3028mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001166  67F4                    3029mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001168  13C4 00C00007           3030mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000116E                          3031mm     ENDC
0000116E                          3032mm 
0000116E                 FALSE    3033mm     IFNE DEBUG
0000116E                          3034mm     ENDC
0000116E                          3035mm 
0000116E                          3036mm     ENDM
0000116E  57CD FFDA               3037m     DBEQ D5,LOOP_195
00001172                          3038m     ENDM
00001172                          3039  
00001172  45FA 0F38               3040      LEA TO(PC),A2
00001176                          3041m     PRINT_STR A2,D3
00001176                          3042m LOOP_200
00001176  0C12 0000               3043m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000117A  6700 0016               3044m     BEQ EXIT_200
0000117E                          3045mm     PRINT_CHAR (A2)+,D3
0000117E                          3046mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000117E                 TRUE     3047mm     IFEQ DEBUG
0000117E  1639 00C00003           3048mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001184  0803 0002               3049mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001188  67F4                    3050mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
0000118A  13DA 00C00007           3051mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001190                          3052mm     ENDC
00001190                          3053mm 
00001190                 FALSE    3054mm     IFNE DEBUG
00001190                          3055mm     ENDC
00001190                          3056mm 
00001190                          3057mm     ENDM
00001190  60E4                    3058m     BRA LOOP_200
00001192                          3059m EXIT_200
00001192                          3060m     ENDM
00001192                          3061  
00001192  2408                    3062      MOVE.L A0,D2
00001194                          3063m     PRINT_REG D2,D3,D4,D5,A2
00001194  45FA 0F13               3064m     LEA OX(PC),A2
00001198                          3065mm     PRINT_STR A2,D3
00001198                          3066mm LOOP_203
00001198  0C12 0000               3067mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000119C  6700 0016               3068mm     BEQ EXIT_203
000011A0                          3069mmm     PRINT_CHAR (A2)+,D3
000011A0                          3070mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011A0                 TRUE     3071mmm     IFEQ DEBUG
000011A0  1639 00C00003           3072mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011A6  0803 0002               3073mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011AA  67F4                    3074mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
000011AC  13DA 00C00007           3075mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011B2                          3076mmm     ENDC
000011B2                          3077mmm 
000011B2                 FALSE    3078mmm     IFNE DEBUG
000011B2                          3079mmm     ENDC
000011B2                          3080mmm 
000011B2                          3081mmm     ENDM
000011B2  60E4                    3082mm     BRA LOOP_203
000011B4                          3083mm EXIT_203
000011B4                          3084mm     ENDM
000011B4  7A07                    3085m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011B6                          3086m LOOP_202
000011B6                          3087mm     BIN2HEX D2,D4,A2
000011B6  45FA 0EB0               3088mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011BA  E99A                    3089mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011BC  1802                    3090mm     MOVE.B D2,D4
000011BE  0284 0000000F           3091mm     ANDI.L #$F,D4
000011C4  1832 4000               3092mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011C8                          3093mm     ENDM
000011C8                          3094mm     PRINT_CHAR D4,D3
000011C8                          3095mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011C8                 TRUE     3096mm     IFEQ DEBUG
000011C8  1639 00C00003           3097mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011CE  0803 0002               3098mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011D2  67F4                    3099mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
000011D4  13C4 00C00007           3100mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011DA                          3101mm     ENDC
000011DA                          3102mm 
000011DA                 FALSE    3103mm     IFNE DEBUG
000011DA                          3104mm     ENDC
000011DA                          3105mm 
000011DA                          3106mm     ENDM
000011DA  57CD FFDA               3107m     DBEQ D5,LOOP_202
000011DE                          3108m     ENDM
000011DE                          3109  
000011DE                          3110m     PRINT_CRLF D3,A2
000011DE  45FA 0EC3               3111m     LEA CRLF(PC),A2
000011E2                          3112mm     PRINT_STR A2,D3
000011E2                          3113mm LOOP_208
000011E2  0C12 0000               3114mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011E6  6700 0016               3115mm     BEQ EXIT_208
000011EA                          3116mmm     PRINT_CHAR (A2)+,D3
000011EA                          3117mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011EA                 TRUE     3118mmm     IFEQ DEBUG
000011EA  1639 00C00003           3119mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011F0  0803 0002               3120mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011F4  67F4                    3121mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
000011F6  13DA 00C00007           3122mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011FC                          3123mmm     ENDC
000011FC                          3124mmm 
000011FC                 FALSE    3125mmm     IFNE DEBUG
000011FC                          3126mmm     ENDC
000011FC                          3127mmm 
000011FC                          3128mmm     ENDM
000011FC  60E4                    3129mm     BRA LOOP_208
000011FE                          3130mm EXIT_208
000011FE                          3131mm     ENDM
000011FE                          3132m     ENDM
000011FE                          3133  
000011FE                          3134m     PROGRAM D0,(A0),D2
000011FE  3080                    3135m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001200                          3136m 
00001200                          3137m WAIT_FOR_COMPLETE_210
00001200  3410                    3138m         MOVE.W (A0),D2
00001202                          3139m 
00001202                          3140m         IF.W D2 <NE> D0 THEN
00001202  B440                    3141ms     CMP.W   D0,D2
00001204  6700 0004               3142ms     BEQ _00000013
00001208  60F6                    3143m             BRA WAIT_FOR_COMPLETE_210
0000120A                          3144m         ENDI
0000120A                          3145ms _00000013
0000120A                          3146m         ENDM
0000120A                          3147  
0000120A                          3148m     PROTECT
0000120A  31FC AAAA 2AAA          3149m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001210  31FC 5555 1554          3150m     MOVE.W #$5555,$1554
00001216  31FC A0A0 2AAA          3151m     MOVE.W #$A0A0,$2AAA
0000121C                          3152m     ENDM
0000121C                          3153      
0000121C  6000 F126               3154      BRA MAIN_LOOP
00001220                          3155      
00001220                          3156  X
00001220  45FA 0E9A               3157      LEA STATUS_REGISTER(PC),A2
00001224                          3158m     PRINT_STR A2,D3
00001224                          3159m LOOP_212
00001224  0C12 0000               3160m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001228  6700 0016               3161m     BEQ EXIT_212
0000122C                          3162mm     PRINT_CHAR (A2)+,D3
0000122C                          3163mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000122C                 TRUE     3164mm     IFEQ DEBUG
0000122C  1639 00C00003           3165mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001232  0803 0002               3166mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001236  67F4                    3167mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
00001238  13DA 00C00007           3168mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000123E                          3169mm     ENDC
0000123E                          3170mm 
0000123E                 FALSE    3171mm     IFNE DEBUG
0000123E                          3172mm     ENDC
0000123E                          3173mm 
0000123E                          3174mm     ENDM
0000123E  60E4                    3175m     BRA LOOP_212
00001240                          3176m EXIT_212
00001240                          3177m     ENDM
00001240                          3178  
00001240  40C0                    3179      MOVE SR,D0
00001242                          3180m     PRINT_REG D0,D3,D4,D5,A2
00001242  45FA 0E65               3181m     LEA OX(PC),A2
00001246                          3182mm     PRINT_STR A2,D3
00001246                          3183mm LOOP_215
00001246  0C12 0000               3184mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000124A  6700 0016               3185mm     BEQ EXIT_215
0000124E                          3186mmm     PRINT_CHAR (A2)+,D3
0000124E                          3187mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000124E                 TRUE     3188mmm     IFEQ DEBUG
0000124E  1639 00C00003           3189mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001254  0803 0002               3190mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001258  67F4                    3191mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
0000125A  13DA 00C00007           3192mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001260                          3193mmm     ENDC
00001260                          3194mmm 
00001260                 FALSE    3195mmm     IFNE DEBUG
00001260                          3196mmm     ENDC
00001260                          3197mmm 
00001260                          3198mmm     ENDM
00001260  60E4                    3199mm     BRA LOOP_215
00001262                          3200mm EXIT_215
00001262                          3201mm     ENDM
00001262  7A07                    3202m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001264                          3203m LOOP_214
00001264                          3204mm     BIN2HEX D0,D4,A2
00001264  45FA 0E02               3205mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001268  E998                    3206mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000126A  1800                    3207mm     MOVE.B D0,D4
0000126C  0284 0000000F           3208mm     ANDI.L #$F,D4
00001272  1832 4000               3209mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001276                          3210mm     ENDM
00001276                          3211mm     PRINT_CHAR D4,D3
00001276                          3212mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001276                 TRUE     3213mm     IFEQ DEBUG
00001276  1639 00C00003           3214mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000127C  0803 0002               3215mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001280  67F4                    3216mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001282  13C4 00C00007           3217mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001288                          3218mm     ENDC
00001288                          3219mm 
00001288                 FALSE    3220mm     IFNE DEBUG
00001288                          3221mm     ENDC
00001288                          3222mm 
00001288                          3223mm     ENDM
00001288  57CD FFDA               3224m     DBEQ D5,LOOP_214
0000128C                          3225m     ENDM
0000128C                          3226m     PRINT_CRLF D3,A2
0000128C  45FA 0E15               3227m     LEA CRLF(PC),A2
00001290                          3228mm     PRINT_STR A2,D3
00001290                          3229mm LOOP_220
00001290  0C12 0000               3230mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001294  6700 0016               3231mm     BEQ EXIT_220
00001298                          3232mmm     PRINT_CHAR (A2)+,D3
00001298                          3233mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001298                 TRUE     3234mmm     IFEQ DEBUG
00001298  1639 00C00003           3235mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000129E  0803 0002               3236mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012A2  67F4                    3237mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
000012A4  13DA 00C00007           3238mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012AA                          3239mmm     ENDC
000012AA                          3240mmm 
000012AA                 FALSE    3241mmm     IFNE DEBUG
000012AA                          3242mmm     ENDC
000012AA                          3243mmm 
000012AA                          3244mmm     ENDM
000012AA  60E4                    3245mm     BRA LOOP_220
000012AC                          3246mm EXIT_220
000012AC                          3247mm     ENDM
000012AC                          3248m     ENDM
000012AC                          3249  
000012AC  45FA 0E09               3250      LEA STACK_POINTER(PC),A2
000012B0                          3251m     PRINT_STR A2,D3
000012B0                          3252m LOOP_222
000012B0  0C12 0000               3253m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012B4  6700 0016               3254m     BEQ EXIT_222
000012B8                          3255mm     PRINT_CHAR (A2)+,D3
000012B8                          3256mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B8                 TRUE     3257mm     IFEQ DEBUG
000012B8  1639 00C00003           3258mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012BE  0803 0002               3259mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012C2  67F4                    3260mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
000012C4  13DA 00C00007           3261mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012CA                          3262mm     ENDC
000012CA                          3263mm 
000012CA                 FALSE    3264mm     IFNE DEBUG
000012CA                          3265mm     ENDC
000012CA                          3266mm 
000012CA                          3267mm     ENDM
000012CA  60E4                    3268m     BRA LOOP_222
000012CC                          3269m EXIT_222
000012CC                          3270m     ENDM
000012CC                          3271  
000012CC  200F                    3272      MOVE.L SP,D0
000012CE                          3273m     PRINT_REG D0,D3,D4,D5,A2
000012CE  45FA 0DD9               3274m     LEA OX(PC),A2
000012D2                          3275mm     PRINT_STR A2,D3
000012D2                          3276mm LOOP_225
000012D2  0C12 0000               3277mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012D6  6700 0016               3278mm     BEQ EXIT_225
000012DA                          3279mmm     PRINT_CHAR (A2)+,D3
000012DA                          3280mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DA                 TRUE     3281mmm     IFEQ DEBUG
000012DA  1639 00C00003           3282mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012E0  0803 0002               3283mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012E4  67F4                    3284mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012E6  13DA 00C00007           3285mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012EC                          3286mmm     ENDC
000012EC                          3287mmm 
000012EC                 FALSE    3288mmm     IFNE DEBUG
000012EC                          3289mmm     ENDC
000012EC                          3290mmm 
000012EC                          3291mmm     ENDM
000012EC  60E4                    3292mm     BRA LOOP_225
000012EE                          3293mm EXIT_225
000012EE                          3294mm     ENDM
000012EE  7A07                    3295m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012F0                          3296m LOOP_224
000012F0                          3297mm     BIN2HEX D0,D4,A2
000012F0  45FA 0D76               3298mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012F4  E998                    3299mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012F6  1800                    3300mm     MOVE.B D0,D4
000012F8  0284 0000000F           3301mm     ANDI.L #$F,D4
000012FE  1832 4000               3302mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001302                          3303mm     ENDM
00001302                          3304mm     PRINT_CHAR D4,D3
00001302                          3305mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001302                 TRUE     3306mm     IFEQ DEBUG
00001302  1639 00C00003           3307mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001308  0803 0002               3308mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000130C  67F4                    3309mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
0000130E  13C4 00C00007           3310mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001314                          3311mm     ENDC
00001314                          3312mm 
00001314                 FALSE    3313mm     IFNE DEBUG
00001314                          3314mm     ENDC
00001314                          3315mm 
00001314                          3316mm     ENDM
00001314  57CD FFDA               3317m     DBEQ D5,LOOP_224
00001318                          3318m     ENDM
00001318                          3319m     PRINT_CRLF D3,A2
00001318  45FA 0D89               3320m     LEA CRLF(PC),A2
0000131C                          3321mm     PRINT_STR A2,D3
0000131C                          3322mm LOOP_230
0000131C  0C12 0000               3323mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001320  6700 0016               3324mm     BEQ EXIT_230
00001324                          3325mmm     PRINT_CHAR (A2)+,D3
00001324                          3326mmm WAIT_FOR_READY_231                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001324                 TRUE     3327mmm     IFEQ DEBUG
00001324  1639 00C00003           3328mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000132A  0803 0002               3329mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000132E  67F4                    3330mmm         BEQ WAIT_FOR_READY_231                      ; NO SPACE, CHECK AGAIN
00001330  13DA 00C00007           3331mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001336                          3332mmm     ENDC
00001336                          3333mmm 
00001336                 FALSE    3334mmm     IFNE DEBUG
00001336                          3335mmm     ENDC
00001336                          3336mmm 
00001336                          3337mmm     ENDM
00001336  60E4                    3338mm     BRA LOOP_230
00001338                          3339mm EXIT_230
00001338                          3340mm     ENDM
00001338                          3341m     ENDM
00001338                          3342  
00001338  6000 F00A               3343      BRA MAIN_LOOP
0000133C                          3344          
0000133C                          3345  EI
0000133C  13FC 0008 00C0000B      3346      MOVE.B #8,DUART_IMR
00001344  027C F8FF               3347      AND.W #$F8FF,SR
00001348  6000 EFFA               3348      BRA MAIN_LOOP
0000134C                          3349      
0000134C                          3350  DI
0000134C  13FC 0000 00C0000B      3351      MOVE.B #0,DUART_IMR
00001354  007C 0700               3352      OR.W #$0700,SR
00001358  6000 EFEA               3353      BRA MAIN_LOOP
0000135C                          3354          
0000135C                          3355  HASH
0000135C                          3356m     PROTECT
0000135C  31FC AAAA 2AAA          3357m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001362  31FC 5555 1554          3358m     MOVE.W #$5555,$1554
00001368  31FC A0A0 2AAA          3359m     MOVE.W #$A0A0,$2AAA
0000136E                          3360m     ENDM
0000136E  6000 EFD4               3361      BRA MAIN_LOOP
00001372                          3362  IB
00001372  13FC 0038 00A00019      3363      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000137A                          3364      
0000137A                          3365m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
0000137A  13FC 00FF 00A00007      3366m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001382  103C 0030               3367m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001386  0000 0006               3368m     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000138A  13C0 00A00019           3369m     MOVE.B D0, MC68230_PORT_C_DATA
00001390  0200 00EF               3370m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001394  13FC 00E0 00A00013      3371m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
0000139C  13C0 00A00019           3372m     MOVE.B D0, MC68230_PORT_C_DATA
000013A2  0000 0010               3373m     ORI.B #MC68230_PORT_C_WRITE, D0
000013A6  13C0 00A00019           3374m     MOVE.B D0, MC68230_PORT_C_DATA
000013AC  13FC 0038 00A00019      3375m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013B4                          3376m     ENDM
000013B4                          3377m     WAIT_DRIVE_READY D0, D1
000013B4                          3378m LOOP_234
000013B4                          3379mm     READ_IDE_STATUS D0, D1
000013B4                          3380mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000013B4  13FC 0000 00A00007      3381mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000013BC  123C 0030               3382mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000013C0  0001 0007               3383mmm     ORI.B #IDE_STATUS_REGISTER, D1
000013C4  13C1 00A00019           3384mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013CA  0201 00DF               3385mmm     ANDI.B #~MC68230_PORT_C_READ, D1
000013CE  13C1 00A00019           3386mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013D4  1039 00A00013           3387mmm     MOVE.B MC68230_PORT_B_DATA, D0
000013DA  0001 0020               3388mmm     ORI.B #MC68230_PORT_C_READ, D1
000013DE  13C1 00A00019           3389mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013E4  13FC 0038 00A00019      3390mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013EC                          3391mmm     ENDM
000013EC                          3392mm     ENDM
000013EC  0800 0006               3393m     BTST #IDE_STATUS_READY, D0
000013F0  67C2                    3394m     BEQ LOOP_234
000013F2                          3395m     ENDM
000013F2                          3396          
000013F2                          3397m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
000013F2                          3398mm     WAIT_DRIVE_NOT_BUSY D0, D1
000013F2                          3399mm LOOP_238
000013F2                          3400mmm     READ_IDE_STATUS D0, D1
000013F2                          3401mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000013F2  13FC 0000 00A00007      3402mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000013FA  123C 0030               3403mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000013FE  0001 0007               3404mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001402  13C1 00A00019           3405mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001408  0201 00DF               3406mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000140C  13C1 00A00019           3407mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001412  1039 00A00013           3408mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001418  0001 0020               3409mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000141C  13C1 00A00019           3410mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001422  13FC 0038 00A00019      3411mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000142A                          3412mmmm     ENDM
0000142A                          3413mmm     ENDM
0000142A  0800 0007               3414mm     BTST #IDE_STATUS_BUSY, D0
0000142E  66C2                    3415mm     BNE LOOP_238
00001430                          3416mm     ENDM
00001430                          3417mm     SET_READ_ADDRESS #0, D0, D1, D2
00001430                          3418mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
00001430  13FC 00FF 00A00007      3419mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001438  103C 0030               3420mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000143C  0000 0002               3421mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
00001440  13C0 00A00019           3422mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001446  0200 00EF               3423mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000144A  13FC 0001 00A00013      3424mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001452  13C0 00A00019           3425mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001458  0000 0010               3426mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000145C  13C0 00A00019           3427mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001462  13FC 0038 00A00019      3428mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000146A                          3429mmm     ENDM
0000146A  7200                    3430mm     MOVE.L #0,D1
0000146C                          3431mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
0000146C  13FC 00FF 00A00007      3432mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001474  103C 0030               3433mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001478  0000 0003               3434mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
0000147C  13C0 00A00019           3435mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001482  0200 00EF               3436mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001486  13C1 00A00013           3437mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000148C  13C0 00A00019           3438mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001492  0000 0010               3439mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001496  13C0 00A00019           3440mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000149C  13FC 0038 00A00019      3441mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014A4                          3442mmm     ENDM
000014A4  E089                    3443mm     LSR.L #8, D1
000014A6                          3444mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
000014A6  13FC 00FF 00A00007      3445mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014AE  103C 0030               3446mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014B2  0000 0004               3447mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
000014B6  13C0 00A00019           3448mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014BC  0200 00EF               3449mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014C0  13C1 00A00013           3450mmm     MOVE.B D1, MC68230_PORT_B_DATA
000014C6  13C0 00A00019           3451mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014CC  0000 0010               3452mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014D0  13C0 00A00019           3453mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014D6  13FC 0038 00A00019      3454mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014DE                          3455mmm     ENDM
000014DE  E089                    3456mm     LSR.L #8, D1                                
000014E0                          3457mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
000014E0  13FC 00FF 00A00007      3458mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014E8  103C 0030               3459mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014EC  0000 0005               3460mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
000014F0  13C0 00A00019           3461mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014F6  0200 00EF               3462mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014FA  13C1 00A00013           3463mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001500  13C0 00A00019           3464mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001506  0000 0010               3465mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000150A  13C0 00A00019           3466mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001510  13FC 0038 00A00019      3467mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001518                          3468mmm     ENDM
00001518  E089                    3469mm     LSR.L #8, D1
0000151A                          3470mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
0000151A  13FC 0000 00A00007      3471mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001522  103C 0030               3472mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001526  0000 0006               3473mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000152A  13C0 00A00019           3474mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001530  0200 00DF               3475mmm     ANDI.B #~MC68230_PORT_C_READ, D0
00001534  13C0 00A00019           3476mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000153A  1439 00A00013           3477mmm     MOVE.B MC68230_PORT_B_DATA, D2
00001540  0000 0020               3478mmm     ORI.B #MC68230_PORT_C_READ, D0
00001544  13C0 00A00019           3479mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000154A  13FC 0038 00A00019      3480mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001552                          3481mmm     ENDM
00001552  0201 000F               3482mm     ANDI.B #$0F,D1
00001556  8401                    3483mm     OR.B D1,D2
00001558                          3484mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
00001558  13FC 00FF 00A00007      3485mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001560  103C 0030               3486mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001564  0000 0006               3487mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001568  13C0 00A00019           3488mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000156E  0200 00EF               3489mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001572  13C2 00A00013           3490mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001578  13C0 00A00019           3491mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000157E  0000 0010               3492mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001582  13C0 00A00019           3493mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001588  13FC 0038 00A00019      3494mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001590                          3495mmm     ENDM
00001590                          3496mm     ENDM
00001590                          3497mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
00001590                          3498mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
00001590  13FC 00FF 00A00007      3499mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001598  103C 0030               3500mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000159C  0000 0007               3501mmm     ORI.B #IDE_COMMAND_REGISTER, D0
000015A0  13C0 00A00019           3502mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015A6  0200 00EF               3503mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000015AA  13FC 0020 00A00013      3504mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
000015B2  13C0 00A00019           3505mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015B8  0000 0010               3506mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000015BC  13C0 00A00019           3507mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015C2  13FC 0038 00A00019      3508mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015CA                          3509mmm     ENDM
000015CA                          3510mm     ENDM
000015CA                          3511mm     WAIT_DRIVE_NOT_BUSY D0, D1
000015CA                          3512mm LOOP_250
000015CA                          3513mmm     READ_IDE_STATUS D0, D1
000015CA                          3514mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000015CA  13FC 0000 00A00007      3515mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015D2  123C 0030               3516mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000015D6  0001 0007               3517mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000015DA  13C1 00A00019           3518mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015E0  0201 00DF               3519mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000015E4  13C1 00A00019           3520mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015EA  1039 00A00013           3521mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000015F0  0001 0020               3522mmmm     ORI.B #MC68230_PORT_C_READ, D1
000015F4  13C1 00A00019           3523mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015FA  13FC 0038 00A00019      3524mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001602                          3525mmmm     ENDM
00001602                          3526mmm     ENDM
00001602  0800 0007               3527mm     BTST #IDE_STATUS_BUSY, D0
00001606  66C2                    3528mm     BNE LOOP_250
00001608                          3529mm     ENDM
00001608                          3530mm     WAIT_DRIVE_DRQ D0, D1
00001608                          3531mm LOOP_253
00001608                          3532mmm     READ_IDE_STATUS D0, D1
00001608                          3533mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001608  13FC 0000 00A00007      3534mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001610  123C 0030               3535mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001614  0001 0007               3536mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001618  13C1 00A00019           3537mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000161E  0201 00DF               3538mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001622  13C1 00A00019           3539mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001628  1039 00A00013           3540mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000162E  0001 0020               3541mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001632  13C1 00A00019           3542mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001638  13FC 0038 00A00019      3543mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001640                          3544mmmm     ENDM
00001640                          3545mmm     ENDM
00001640  0800 0003               3546mm     BTST #IDE_STATUS_DRQ, D0
00001644  67C2                    3547mm     BEQ LOOP_253
00001646                          3548mm     ENDM
00001646                          3549m     ENDM
00001646                          3550      
00001646                          3551      FOR D1 = #0 to #7 DO
00001646  323C 0000               3552s     MOVE.W  #0,D1
0000164A  6000 0098               3553s     BRA _20000015
0000164E                          3554s _20000014
0000164E                          3555m         READ_32 #IDE_DATA_REGISTER, D0, D6      ; num entries in boot table -> D0 (it's written 8 times to fill the block up)
0000164E                          3556mm     READ_16 #IDE_DATA_REGISTER, D0, D6
0000164E  13FC 0000 00A00007      3557mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001656  13FC 0000 00A00005      3558mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000165E                          3559mm     
0000165E  1C3C 0030               3560mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
00001662  0006 0000               3561mm     ORI.B #IDE_DATA_REGISTER, D6
00001666  13C6 00A00019           3562mm     MOVE.B D6, MC68230_PORT_C_DATA
0000166C  0206 00DF               3563mm     ANDI.B #~MC68230_PORT_C_READ, D6
00001670  13C6 00A00019           3564mm     MOVE.B D6, MC68230_PORT_C_DATA
00001676  1039 00A00011           3565mm     MOVE.B MC68230_PORT_A_DATA, D0
0000167C  E148                    3566mm     LSL.W #8, D0
0000167E  1039 00A00013           3567mm     MOVE.B MC68230_PORT_B_DATA, D0
00001684  0006 0020               3568mm     ORI.B #MC68230_PORT_C_READ, D6
00001688  13C6 00A00019           3569mm     MOVE.B D6, MC68230_PORT_C_DATA
0000168E  13FC 0038 00A00019      3570mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001696                          3571mm     ENDM
00001696  E188                    3572m     LSL.L #8, D0
00001698  E188                    3573m     LSL.L #8, D0
0000169A                          3574mm     READ_16 #IDE_DATA_REGISTER, D0, D6
0000169A  13FC 0000 00A00007      3575mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016A2  13FC 0000 00A00005      3576mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000016AA                          3577mm     
000016AA  1C3C 0030               3578mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
000016AE  0006 0000               3579mm     ORI.B #IDE_DATA_REGISTER, D6
000016B2  13C6 00A00019           3580mm     MOVE.B D6, MC68230_PORT_C_DATA
000016B8  0206 00DF               3581mm     ANDI.B #~MC68230_PORT_C_READ, D6
000016BC  13C6 00A00019           3582mm     MOVE.B D6, MC68230_PORT_C_DATA
000016C2  1039 00A00011           3583mm     MOVE.B MC68230_PORT_A_DATA, D0
000016C8  E148                    3584mm     LSL.W #8, D0
000016CA  1039 00A00013           3585mm     MOVE.B MC68230_PORT_B_DATA, D0
000016D0  0006 0020               3586mm     ORI.B #MC68230_PORT_C_READ, D6
000016D4  13C6 00A00019           3587mm     MOVE.B D6, MC68230_PORT_C_DATA
000016DA  13FC 0038 00A00019      3588mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016E2                          3589mm     ENDM
000016E2                          3590m     ENDM
000016E2                          3591      ENDF
000016E2  5241                    3592s     ADD.W   #1,D1
000016E4                          3593s _20000015
000016E4  B27C 0007               3594s     CMP.W   #7,D1
000016E8  6F00 FF64               3595s     BLE _20000014
000016EC  7200                    3596      MOVE.L #0, D1                               ; current boot table index -> D1
000016EE                          3597                          
000016EE                          3598      IF A5 <EQ> #1 THEN                          ; if we are booting...
000016EE  BAFC 0001               3599s     CMP.W   #1,A5
000016F2  6600 0018               3600s     BNE _00000014
000016F6  CEBC 0000000F           3601          AND.L #$F,D7                            ; consider bottom 4 bits of address accumulator only
000016FC                          3602          IF D7 <GE> D0 THEN                      ; don't boot if off the end of the boot table
000016FC  BE40                    3603s     CMP.W   D0,D7
000016FE  6D00 0008               3604s     BLT _00000015
00001702  2A7C 00000002           3605              MOVE.L #2, A5
00001708                          3606          ENDI
00001708                          3607s _00000015
00001708                          3608  
00001708  2007                    3609          MOVE.L D7, D0                           ; then shorten the boot table to the selected entry 
0000170A  5280                    3610          ADD.L #1, D0
0000170C                          3611      ENDI
0000170C                          3612s _00000014
0000170C                          3613      
0000170C  227C 00000000           3614      MOVE.L #0, A1
00001712                          3615      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
00001712  143C 0000               3616s     MOVE.B  #0,D2
00001716  6000 0236               3617s     BRA _20000017
0000171A                          3618s _20000016
0000171A  1A3C 0001               3619          MOVE.B #1, D5                           ; assume empty
0000171E                          3620          FOR.B D3 = #0 TO #11 DO                 ; words read from this boot table entry -> D2
0000171E  163C 0000               3621s     MOVE.B  #0,D3
00001722  6000 01EE               3622s     BRA _20000019
00001726                          3623s _20000018
00001726                          3624m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
00001726                          3625mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001726  13FC 0000 00A00007      3626mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000172E  13FC 0000 00A00005      3627mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001736                          3628mm     
00001736  1E3C 0030               3629mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
0000173A  0007 0000               3630mm     ORI.B #IDE_DATA_REGISTER, D7
0000173E  13C7 00A00019           3631mm     MOVE.B D7, MC68230_PORT_C_DATA
00001744  0207 00DF               3632mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001748  13C7 00A00019           3633mm     MOVE.B D7, MC68230_PORT_C_DATA
0000174E  1839 00A00011           3634mm     MOVE.B MC68230_PORT_A_DATA, D4
00001754  E14C                    3635mm     LSL.W #8, D4
00001756  1839 00A00013           3636mm     MOVE.B MC68230_PORT_B_DATA, D4
0000175C  0007 0020               3637mm     ORI.B #MC68230_PORT_C_READ, D7
00001760  13C7 00A00019           3638mm     MOVE.B D7, MC68230_PORT_C_DATA
00001766  13FC 0038 00A00019      3639mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000176E                          3640mm     ENDM
0000176E  E18C                    3641m     LSL.L #8, D4
00001770  E18C                    3642m     LSL.L #8, D4
00001772                          3643mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001772  13FC 0000 00A00007      3644mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000177A  13FC 0000 00A00005      3645mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001782                          3646mm     
00001782  1E3C 0030               3647mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001786  0007 0000               3648mm     ORI.B #IDE_DATA_REGISTER, D7
0000178A  13C7 00A00019           3649mm     MOVE.B D7, MC68230_PORT_C_DATA
00001790  0207 00DF               3650mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001794  13C7 00A00019           3651mm     MOVE.B D7, MC68230_PORT_C_DATA
0000179A  1839 00A00011           3652mm     MOVE.B MC68230_PORT_A_DATA, D4
000017A0  E14C                    3653mm     LSL.W #8, D4
000017A2  1839 00A00013           3654mm     MOVE.B MC68230_PORT_B_DATA, D4
000017A8  0007 0020               3655mm     ORI.B #MC68230_PORT_C_READ, D7
000017AC  13C7 00A00019           3656mm     MOVE.B D7, MC68230_PORT_C_DATA
000017B2  13FC 0038 00A00019      3657mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017BA                          3658mm     ENDM
000017BA                          3659m     ENDM
000017BA                          3660              IF.B D1 <LT> D0 THEN                ; still in the boot table?
000017BA  B200                    3661s     CMP.B   D0,D1
000017BC  6C00 0152               3662s     BGE _00000016
000017C0                          3663                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
000017C0  B63C 0000               3664s     CMP.B   #0,D3
000017C4  6600 0004               3665s     BNE _00000017
000017C8  1A04                    3666                      MOVE.B D4, D5               ; empty flag -> D5
000017CA                          3667                  ENDI
000017CA                          3668s _00000017
000017CA                          3669                  
000017CA                          3670                  IF.B D5 <NE> #1 THEN            ; not empty         
000017CA  BA3C 0001               3671s     CMP.B   #1,D5
000017CE  6700 013A               3672s     BEQ _00000018
000017D2                          3673                      IF A5 <EQ> #0 THEN          ; not booting, so print
000017D2  BAFC 0000               3674s     CMP.W   #0,A5
000017D6  6600 00FE               3675s     BNE _00000019
000017DA                          3676                          IF.B D3 <EQ> #0 THEN    ; first word in boot table, print the index
000017DA  B63C 0000               3677s     CMP.B   #0,D3
000017DE  6600 0044               3678s     BNE _0000001A
000017E2                          3679m                             PRINT_REG_4BIT D1, D6, D7, A0   
000017E2  41FA 0884               3680m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000017E6  1E01                    3681m     MOVE.B D1,D7
000017E8  0287 0000000F           3682m     ANDI.L #$F,D7
000017EE  1E30 7000               3683m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
000017F2                          3684mm     PRINT_CHAR D7,D6
000017F2                          3685mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017F2                 TRUE     3686mm     IFEQ DEBUG
000017F2  1C39 00C00003           3687mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000017F8  0806 0002               3688mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000017FC  67F4                    3689mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
000017FE  13C7 00C00007           3690mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001804                          3691mm     ENDC
00001804                          3692mm 
00001804                 FALSE    3693mm     IFNE DEBUG
00001804                          3694mm     ENDC
00001804                          3695mm 
00001804                          3696mm     ENDM
00001804                          3697m     ENDM
00001804  41FA 08BB               3698                              LEA INDEX_SEP(PC), A0
00001808                          3699m                             PRINT_STR A0, D7
00001808                          3700m LOOP_264
00001808  0C10 0000               3701m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000180C  6700 0016               3702m     BEQ EXIT_264
00001810                          3703mm     PRINT_CHAR (A0)+,D7
00001810                          3704mm WAIT_FOR_READY_265                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001810                 TRUE     3705mm     IFEQ DEBUG
00001810  1E39 00C00003           3706mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001816  0807 0002               3707mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000181A  67F4                    3708mm         BEQ WAIT_FOR_READY_265                      ; NO SPACE, CHECK AGAIN
0000181C  13D8 00C00007           3709mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001822                          3710mm     ENDC
00001822                          3711mm 
00001822                 FALSE    3712mm     IFNE DEBUG
00001822                          3713mm     ENDC
00001822                          3714mm 
00001822                          3715mm     ENDM
00001822  60E4                    3716m     BRA LOOP_264
00001824                          3717m EXIT_264
00001824                          3718m     ENDM
00001824                          3719                          ENDI
00001824                          3720s _0000001A
00001824                          3721  
00001824                          3722                          IF.B D3 <GT> #1 AND.B D3 <LT> #7 THEN   ; str, print it
00001824  B63C 0001               3723s     CMP.B   #1,D3
00001828  6F00 002E               3724s     BLE _0000001B
0000182C  B63C 0007               3725s     CMP.B   #7,D3
00001830  6C00 0026               3726s     BGE _0000001B
00001834                          3727                              FOR.B D6 = #0 TO #3 DO
00001834  1C3C 0000               3728s     MOVE.B  #0,D6
00001838  6000 0018               3729s     BRA _2000001B
0000183C                          3730s _2000001A
0000183C  E19C                    3731                                  ROL.L #8, D4                    
0000183E                          3732m                                 PRINT_CHAR D4, D7
0000183E                          3733m WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000183E                 TRUE     3734m     IFEQ DEBUG
0000183E  1E39 00C00003           3735m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001844  0807 0002               3736m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001848  67F4                    3737m         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
0000184A  13C4 00C00007           3738m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001850                          3739m     ENDC
00001850                          3740m 
00001850                 FALSE    3741m     IFNE DEBUG
00001850                          3742m     ENDC
00001850                          3743m 
00001850                          3744m     ENDM
00001850                          3745                              ENDF
00001850  5206                    3746s     ADD.B   #1,D6
00001852                          3747s _2000001B
00001852  BC3C 0003               3748s     CMP.B   #3,D6
00001856  6FE4                    3749s     BLE _2000001A
00001858                          3750                          ENDI
00001858                          3751s _0000001B
00001858                          3752                      
00001858                          3753                          IF.B D3 <GT> #7 AND.B D3 <LT> #12 THEN
00001858  B63C 0007               3754s     CMP.B   #7,D3
0000185C  6F00 0078               3755s     BLE _0000001C
00001860  B63C 000C               3756s     CMP.B   #12,D3
00001864  6C00 0070               3757s     BGE _0000001C
00001868  2C45                    3758                              MOVE.L D5, A6       ; preserve the empty flag, we're gonna use D5
0000186A  41FA 0855               3759                              LEA INDEX_SEP(PC), A0
0000186E                          3760m                             PRINT_STR A0, D7
0000186E                          3761m LOOP_267
0000186E  0C10 0000               3762m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001872  6700 0016               3763m     BEQ EXIT_267
00001876                          3764mm     PRINT_CHAR (A0)+,D7
00001876                          3765mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001876                 TRUE     3766mm     IFEQ DEBUG
00001876  1E39 00C00003           3767mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000187C  0807 0002               3768mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001880  67F4                    3769mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
00001882  13D8 00C00007           3770mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001888                          3771mm     ENDC
00001888                          3772mm 
00001888                 FALSE    3773mm     IFNE DEBUG
00001888                          3774mm     ENDC
00001888                          3775mm 
00001888                          3776mm     ENDM
00001888  60E4                    3777m     BRA LOOP_267
0000188A                          3778m EXIT_267
0000188A                          3779m     ENDM
0000188A                          3780m                             PRINT_REG D4, D5, D6, D7, A0
0000188A  41FA 081D               3781m     LEA OX(PC),A0
0000188E                          3782mm     PRINT_STR A0,D5
0000188E                          3783mm LOOP_270
0000188E  0C10 0000               3784mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001892  6700 0016               3785mm     BEQ EXIT_270
00001896                          3786mmm     PRINT_CHAR (A0)+,D5
00001896                          3787mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001896                 TRUE     3788mmm     IFEQ DEBUG
00001896  1A39 00C00003           3789mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000189C  0805 0002               3790mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000018A0  67F4                    3791mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
000018A2  13D8 00C00007           3792mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018A8                          3793mmm     ENDC
000018A8                          3794mmm 
000018A8                 FALSE    3795mmm     IFNE DEBUG
000018A8                          3796mmm     ENDC
000018A8                          3797mmm 
000018A8                          3798mmm     ENDM
000018A8  60E4                    3799mm     BRA LOOP_270
000018AA                          3800mm EXIT_270
000018AA                          3801mm     ENDM
000018AA  7E07                    3802m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000018AC                          3803m LOOP_269
000018AC                          3804mm     BIN2HEX D4,D6,A0
000018AC  41FA 07BA               3805mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000018B0  E99C                    3806mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000018B2  1C04                    3807mm     MOVE.B D4,D6
000018B4  0286 0000000F           3808mm     ANDI.L #$F,D6
000018BA  1C30 6000               3809mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
000018BE                          3810mm     ENDM
000018BE                          3811mm     PRINT_CHAR D6,D5
000018BE                          3812mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018BE                 TRUE     3813mm     IFEQ DEBUG
000018BE  1A39 00C00003           3814mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000018C4  0805 0002               3815mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000018C8  67F4                    3816mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000018CA  13C6 00C00007           3817mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
000018D0                          3818mm     ENDC
000018D0                          3819mm 
000018D0                 FALSE    3820mm     IFNE DEBUG
000018D0                          3821mm     ENDC
000018D0                          3822mm 
000018D0                          3823mm     ENDM
000018D0  57CF FFDA               3824m     DBEQ D7,LOOP_269
000018D4                          3825m     ENDM
000018D4  2A0E                    3826                              MOVE.L A6, D5       ; restore the empty flag into D5
000018D6                          3827                          ENDI
000018D6                          3828s _0000001C
000018D6                          3829                      ENDI
000018D6                          3830s _00000019
000018D6                          3831                      
000018D6                          3832                      IF A5 <EQ> #1 THEN          ; save the params if we are booting
000018D6  BAFC 0001               3833s     CMP.W   #1,A5
000018DA  6600 002A               3834s     BNE _0000001D
000018DE                          3835                          IF.B D3 <EQ> #8 THEN                        
000018DE  B63C 0008               3836s     CMP.B   #8,D3
000018E2  6600 0004               3837s     BNE _0000001E
000018E6  2244                    3838                              MOVE.L D4, A1       ; length -> A1
000018E8                          3839                          ENDI
000018E8                          3840s _0000001E
000018E8                          3841              
000018E8                          3842                          IF.B D3 <EQ> #9 THEN
000018E8  B63C 0009               3843s     CMP.B   #9,D3
000018EC  6600 0004               3844s     BNE _0000001F
000018F0  2444                    3845                              MOVE.L D4, A2       ; start address -> A2
000018F2                          3846                          ENDI
000018F2                          3847s _0000001F
000018F2                          3848  
000018F2                          3849                          IF.B D3 <EQ> #10 THEN
000018F2  B63C 000A               3850s     CMP.B   #10,D3
000018F6  6600 0004               3851s     BNE _00000020
000018FA  2644                    3852                              MOVE.L D4, A3       ; go address -> A3
000018FC                          3853                          ENDI
000018FC                          3854s _00000020
000018FC                          3855  
000018FC                          3856                          IF.B D3 <EQ> #11 THEN
000018FC  B63C 000B               3857s     CMP.B   #11,D3
00001900  6600 0004               3858s     BNE _00000021
00001904  2844                    3859                              MOVE.L D4, A4       ; start block -> A4
00001906                          3860                          ENDI                    
00001906                          3861s _00000021
00001906                          3862                      ENDI
00001906                          3863s _0000001D
00001906                          3864                  ELSE
00001906  6000 0008               3865s     BRA _00000022
0000190A                          3866s _00000018
0000190A  227C 00000000           3867                      MOVE.L #0, A1
00001910                          3868                  ENDI
00001910                          3869s _00000022
00001910                          3870              ENDI            
00001910                          3871s _00000016
00001910                          3872          ENDF
00001910  5203                    3873s     ADD.B   #1,D3
00001912                          3874s _20000019
00001912  B63C 000B               3875s     CMP.B   #11,D3
00001916  6F00 FE0E               3876s     BLE _20000018
0000191A                          3877  
0000191A                          3878          IF A5 <EQ> #0 THEN                  ; not booting?          
0000191A  BAFC 0000               3879s     CMP.W   #0,A5
0000191E  6600 002A               3880s     BNE _00000023
00001922                          3881              IF.B D5 <NE> #1 THEN            ; not booting and not empty, so print crlf
00001922  BA3C 0001               3882s     CMP.B   #1,D5
00001926  6700 0022               3883s     BEQ _00000024
0000192A                          3884m                 PRINT_CRLF D7, A0
0000192A  41FA 0777               3885m     LEA CRLF(PC),A0
0000192E                          3886mm     PRINT_STR A0,D7
0000192E                          3887mm LOOP_275
0000192E  0C10 0000               3888mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001932  6700 0016               3889mm     BEQ EXIT_275
00001936                          3890mmm     PRINT_CHAR (A0)+,D7
00001936                          3891mmm WAIT_FOR_READY_276                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001936                 TRUE     3892mmm     IFEQ DEBUG
00001936  1E39 00C00003           3893mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000193C  0807 0002               3894mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001940  67F4                    3895mmm         BEQ WAIT_FOR_READY_276                      ; NO SPACE, CHECK AGAIN
00001942  13D8 00C00007           3896mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001948                          3897mmm     ENDC
00001948                          3898mmm 
00001948                 FALSE    3899mmm     IFNE DEBUG
00001948                          3900mmm     ENDC
00001948                          3901mmm 
00001948                          3902mmm     ENDM
00001948  60E4                    3903mm     BRA LOOP_275
0000194A                          3904mm EXIT_275
0000194A                          3905mm     ENDM
0000194A                          3906m     ENDM
0000194A                          3907              ENDI
0000194A                          3908s _00000024
0000194A                          3909          ENDI
0000194A                          3910s _00000023
0000194A                          3911          
0000194A  5281                    3912          ADD.L #1,D1                         ; next boot table index
0000194C                          3913      ENDF
0000194C  5202                    3914s     ADD.B   #1,D2
0000194E                          3915s _20000017
0000194E  B43C 0009               3916s     CMP.B   #9,D2
00001952  6F00 FDC6               3917s     BLE _20000016
00001956                          3918                          
00001956                          3919      IF A5 <NE> #0 THEN                      ; check for boot from empty slot
00001956  BAFC 0000               3920s     CMP.W   #0,A5
0000195A  6700 0034               3921s     BEQ _00000025
0000195E                          3922          IF A5 <EQ> #2 OR A1 <EQ> #0  THEN 
0000195E  BAFC 0002               3923s     CMP.W   #2,A5
00001962  6708                    3924s     BEQ.S   _00000026
00001964  B2FC 0000               3925s     CMP.W   #0,A1
00001968  6600 0026               3926s     BNE _00000027
0000196C                          3927s _00000026
0000196C  41FA 075F               3928              LEA NOT_FOUND(PC), A0
00001970                          3929m             PRINT_STR A0, D7
00001970                          3930m LOOP_277
00001970  0C10 0000               3931m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001974  6700 0016               3932m     BEQ EXIT_277
00001978                          3933mm     PRINT_CHAR (A0)+,D7
00001978                          3934mm WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001978                 TRUE     3935mm     IFEQ DEBUG
00001978  1E39 00C00003           3936mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000197E  0807 0002               3937mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001982  67F4                    3938mm         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
00001984  13D8 00C00007           3939mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000198A                          3940mm     ENDC
0000198A                          3941mm 
0000198A                 FALSE    3942mm     IFNE DEBUG
0000198A                          3943mm     ENDC
0000198A                          3944mm 
0000198A                          3945mm     ENDM
0000198A  60E4                    3946m     BRA LOOP_277
0000198C                          3947m EXIT_277
0000198C                          3948m     ENDM
0000198C  6000 E9B6               3949              BRA MAIN_LOOP
00001990                          3950          ENDI
00001990                          3951s _00000027
00001990                          3952      ENDI
00001990                          3953s _00000025
00001990                          3954      
00001990                          3955      IF A5 <EQ> #1 THEN                      ; booting?
00001990  BAFC 0001               3956s     CMP.W   #1,A5
00001994  6600 031C               3957s     BNE _00000028
00001998  41FA 072B               3958          LEA BOOT(PC), A0
0000199C                          3959m         PRINT_STR A0, D7
0000199C                          3960m LOOP_279
0000199C  0C10 0000               3961m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019A0  6700 0016               3962m     BEQ EXIT_279
000019A4                          3963mm     PRINT_CHAR (A0)+,D7
000019A4                          3964mm WAIT_FOR_READY_280                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019A4                 TRUE     3965mm     IFEQ DEBUG
000019A4  1E39 00C00003           3966mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000019AA  0807 0002               3967mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000019AE  67F4                    3968mm         BEQ WAIT_FOR_READY_280                      ; NO SPACE, CHECK AGAIN
000019B0  13D8 00C00007           3969mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019B6                          3970mm     ENDC
000019B6                          3971mm 
000019B6                 FALSE    3972mm     IFNE DEBUG
000019B6                          3973mm     ENDC
000019B6                          3974mm 
000019B6                          3975mm     ENDM
000019B6  60E4                    3976m     BRA LOOP_279
000019B8                          3977m EXIT_279
000019B8                          3978m     ENDM
000019B8                          3979      
000019B8  2009                    3980          MOVE.L A1, D0                       ; length -> D0              
000019BA  220C                    3981          MOVE.L A4, D1                       ; start block -> D1
000019BC                          3982          
000019BC                          3983          WHILE.L D0 <GT> #0 DO
000019BC                          3984s _10000016
000019BC  B0BC 00000000           3985s     CMP.L   #0,D0
000019C2  6F00 02CC               3986s     BLE _10000017
000019C6                          3987m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
000019C6                          3988mm     WAIT_DRIVE_NOT_BUSY D5, D6
000019C6                          3989mm LOOP_282
000019C6                          3990mmm     READ_IDE_STATUS D5, D6
000019C6                          3991mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
000019C6  13FC 0000 00A00007      3992mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000019CE  1C3C 0030               3993mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
000019D2  0006 0007               3994mmmm     ORI.B #IDE_STATUS_REGISTER, D6
000019D6  13C6 00A00019           3995mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000019DC  0206 00DF               3996mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
000019E0  13C6 00A00019           3997mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000019E6  1A39 00A00013           3998mmmm     MOVE.B MC68230_PORT_B_DATA, D5
000019EC  0006 0020               3999mmmm     ORI.B #MC68230_PORT_C_READ, D6
000019F0  13C6 00A00019           4000mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000019F6  13FC 0038 00A00019      4001mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019FE                          4002mmmm     ENDM
000019FE                          4003mmm     ENDM
000019FE  0805 0007               4004mm     BTST #IDE_STATUS_BUSY, D5
00001A02  66C2                    4005mm     BNE LOOP_282
00001A04                          4006mm     ENDM
00001A04                          4007mm     SET_READ_ADDRESS D1, D5, D6, D7
00001A04                          4008mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D5
00001A04  13FC 00FF 00A00007      4009mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A0C  1A3C 0030               4010mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A10  0005 0002               4011mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D5
00001A14  13C5 00A00019           4012mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A1A  0205 00EF               4013mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A1E  13FC 0001 00A00013      4014mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001A26  13C5 00A00019           4015mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A2C  0005 0010               4016mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A30  13C5 00A00019           4017mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A36  13FC 0038 00A00019      4018mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A3E                          4019mmm     ENDM
00001A3E  2C01                    4020mm     MOVE.L D1,D6
00001A40                          4021mmm     WRITE_8 D6, #IDE_LBA_0_7_REGISTER, D5
00001A40  13FC 00FF 00A00007      4022mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A48  1A3C 0030               4023mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A4C  0005 0003               4024mmm     ORI.B #IDE_LBA_0_7_REGISTER, D5
00001A50  13C5 00A00019           4025mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A56  0205 00EF               4026mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A5A  13C6 00A00013           4027mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A60  13C5 00A00019           4028mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A66  0005 0010               4029mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A6A  13C5 00A00019           4030mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A70  13FC 0038 00A00019      4031mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A78                          4032mmm     ENDM
00001A78  E08E                    4033mm     LSR.L #8, D6
00001A7A                          4034mmm     WRITE_8 D6, #IDE_LBA_8_15_REGISTER, D5
00001A7A  13FC 00FF 00A00007      4035mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A82  1A3C 0030               4036mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A86  0005 0004               4037mmm     ORI.B #IDE_LBA_8_15_REGISTER, D5
00001A8A  13C5 00A00019           4038mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A90  0205 00EF               4039mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A94  13C6 00A00013           4040mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A9A  13C5 00A00019           4041mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AA0  0005 0010               4042mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001AA4  13C5 00A00019           4043mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AAA  13FC 0038 00A00019      4044mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AB2                          4045mmm     ENDM
00001AB2  E08E                    4046mm     LSR.L #8, D6                                
00001AB4                          4047mmm     WRITE_8 D6, #IDE_LBA_16_23_REGISTER, D5
00001AB4  13FC 00FF 00A00007      4048mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001ABC  1A3C 0030               4049mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AC0  0005 0005               4050mmm     ORI.B #IDE_LBA_16_23_REGISTER, D5
00001AC4  13C5 00A00019           4051mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001ACA  0205 00EF               4052mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001ACE  13C6 00A00013           4053mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001AD4  13C5 00A00019           4054mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001ADA  0005 0010               4055mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001ADE  13C5 00A00019           4056mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AE4  13FC 0038 00A00019      4057mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AEC                          4058mmm     ENDM
00001AEC  E08E                    4059mm     LSR.L #8, D6
00001AEE                          4060mmm     READ_8 #IDE_DRIVESEL_REGISTER, D7, D5
00001AEE  13FC 0000 00A00007      4061mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001AF6  1A3C 0030               4062mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AFA  0005 0006               4063mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001AFE  13C5 00A00019           4064mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B04  0205 00DF               4065mmm     ANDI.B #~MC68230_PORT_C_READ, D5
00001B08  13C5 00A00019           4066mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B0E  1E39 00A00013           4067mmm     MOVE.B MC68230_PORT_B_DATA, D7
00001B14  0005 0020               4068mmm     ORI.B #MC68230_PORT_C_READ, D5
00001B18  13C5 00A00019           4069mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B1E  13FC 0038 00A00019      4070mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B26                          4071mmm     ENDM
00001B26  0206 000F               4072mm     ANDI.B #$0F,D6
00001B2A  8E06                    4073mm     OR.B D6,D7
00001B2C                          4074mmm     WRITE_8 D7, #IDE_DRIVESEL_REGISTER, D5
00001B2C  13FC 00FF 00A00007      4075mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001B34  1A3C 0030               4076mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001B38  0005 0006               4077mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001B3C  13C5 00A00019           4078mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B42  0205 00EF               4079mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001B46  13C7 00A00013           4080mmm     MOVE.B D7, MC68230_PORT_B_DATA
00001B4C  13C5 00A00019           4081mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B52  0005 0010               4082mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001B56  13C5 00A00019           4083mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B5C  13FC 0038 00A00019      4084mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B64                          4085mmm     ENDM
00001B64                          4086mm     ENDM
00001B64                          4087mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D5
00001B64                          4088mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D5
00001B64  13FC 00FF 00A00007      4089mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001B6C  1A3C 0030               4090mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001B70  0005 0007               4091mmm     ORI.B #IDE_COMMAND_REGISTER, D5
00001B74  13C5 00A00019           4092mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B7A  0205 00EF               4093mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001B7E  13FC 0020 00A00013      4094mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001B86  13C5 00A00019           4095mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B8C  0005 0010               4096mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001B90  13C5 00A00019           4097mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B96  13FC 0038 00A00019      4098mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B9E                          4099mmm     ENDM
00001B9E                          4100mm     ENDM
00001B9E                          4101mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001B9E                          4102mm LOOP_294
00001B9E                          4103mmm     READ_IDE_STATUS D5, D6
00001B9E                          4104mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001B9E  13FC 0000 00A00007      4105mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BA6  1C3C 0030               4106mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001BAA  0006 0007               4107mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001BAE  13C6 00A00019           4108mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BB4  0206 00DF               4109mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001BB8  13C6 00A00019           4110mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BBE  1A39 00A00013           4111mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001BC4  0006 0020               4112mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001BC8  13C6 00A00019           4113mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BCE  13FC 0038 00A00019      4114mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001BD6                          4115mmmm     ENDM
00001BD6                          4116mmm     ENDM
00001BD6  0805 0007               4117mm     BTST #IDE_STATUS_BUSY, D5
00001BDA  66C2                    4118mm     BNE LOOP_294
00001BDC                          4119mm     ENDM
00001BDC                          4120mm     WAIT_DRIVE_DRQ D5, D6
00001BDC                          4121mm LOOP_297
00001BDC                          4122mmm     READ_IDE_STATUS D5, D6
00001BDC                          4123mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001BDC  13FC 0000 00A00007      4124mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BE4  1C3C 0030               4125mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001BE8  0006 0007               4126mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001BEC  13C6 00A00019           4127mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BF2  0206 00DF               4128mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001BF6  13C6 00A00019           4129mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BFC  1A39 00A00013           4130mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001C02  0006 0020               4131mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001C06  13C6 00A00019           4132mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001C0C  13FC 0038 00A00019      4133mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001C14                          4134mmmm     ENDM
00001C14                          4135mmm     ENDM
00001C14  0805 0003               4136mm     BTST #IDE_STATUS_DRQ, D5
00001C18  67C2                    4137mm     BEQ LOOP_297
00001C1A                          4138mm     ENDM
00001C1A                          4139m     ENDM
00001C1A                          4140m             PRINT_CHAR #'.', D7
00001C1A                          4141m WAIT_FOR_READY_300                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C1A                 TRUE     4142m     IFEQ DEBUG
00001C1A  1E39 00C00003           4143m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001C20  0807 0002               4144m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001C24  67F4                    4145m         BEQ WAIT_FOR_READY_300                      ; NO SPACE, CHECK AGAIN
00001C26  13FC 002E 00C00007      4146m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001C2E                          4147m     ENDC
00001C2E                          4148m 
00001C2E                 FALSE    4149m     IFNE DEBUG
00001C2E                          4150m     ENDC
00001C2E                          4151m 
00001C2E                          4152m     ENDM
00001C2E                          4153              
00001C2E                          4154              FOR.L D3 = #0 TO #255 DO
00001C2E  7600                    4155s     MOVE.L  #0,D3
00001C30  6000 0050               4156s     BRA _2000001D
00001C34                          4157s _2000001C
00001C34                          4158m                 READ_16 #IDE_DATA_REGISTER, D4, D7
00001C34  13FC 0000 00A00007      4159m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001C3C  13FC 0000 00A00005      4160m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001C44                          4161m     
00001C44  1E3C 0030               4162m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001C48  0007 0000               4163m     ORI.B #IDE_DATA_REGISTER, D7
00001C4C  13C7 00A00019           4164m     MOVE.B D7, MC68230_PORT_C_DATA
00001C52  0207 00DF               4165m     ANDI.B #~MC68230_PORT_C_READ, D7
00001C56  13C7 00A00019           4166m     MOVE.B D7, MC68230_PORT_C_DATA
00001C5C  1839 00A00011           4167m     MOVE.B MC68230_PORT_A_DATA, D4
00001C62  E14C                    4168m     LSL.W #8, D4
00001C64  1839 00A00013           4169m     MOVE.B MC68230_PORT_B_DATA, D4
00001C6A  0007 0020               4170m     ORI.B #MC68230_PORT_C_READ, D7
00001C6E  13C7 00A00019           4171m     MOVE.B D7, MC68230_PORT_C_DATA
00001C74  13FC 0038 00A00019      4172m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001C7C                          4173m     ENDM
00001C7C  34C4                    4174                  MOVE.W D4,(A2)+
00001C7E  5580                    4175                  SUB.L #2, D0
00001C80                          4176              ENDF
00001C80  5283                    4177s     ADD.L   #1,D3
00001C82                          4178s _2000001D
00001C82  B6BC 000000FF           4179s     CMP.L   #255,D3
00001C88  6FAA                    4180s     BLE _2000001C
00001C8A                          4181          
00001C8A  5281                    4182              ADD.L #1, D1                    ; next block
00001C8C                          4183          ENDW
00001C8C  6000 FD2E               4184s     BRA _10000016
00001C90                          4185s _10000017
00001C90                          4186  
00001C90                          4187m         PRINT_CRLF D3, A6   
00001C90  4DFA 0411               4188m     LEA CRLF(PC),A6
00001C94                          4189mm     PRINT_STR A6,D3
00001C94                          4190mm LOOP_303
00001C94  0C16 0000               4191mm     CMP.B #NULL,(A6)                                ; 0 -> DONE
00001C98  6700 0016               4192mm     BEQ EXIT_303
00001C9C                          4193mmm     PRINT_CHAR (A6)+,D3
00001C9C                          4194mmm WAIT_FOR_READY_304                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C9C                 TRUE     4195mmm     IFEQ DEBUG
00001C9C  1639 00C00003           4196mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001CA2  0803 0002               4197mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001CA6  67F4                    4198mmm         BEQ WAIT_FOR_READY_304                      ; NO SPACE, CHECK AGAIN
00001CA8  13DE 00C00007           4199mmm         MOVE.B (A6)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CAE                          4200mmm     ENDC
00001CAE                          4201mmm 
00001CAE                 FALSE    4202mmm     IFNE DEBUG
00001CAE                          4203mmm     ENDC
00001CAE                          4204mmm 
00001CAE                          4205mmm     ENDM
00001CAE  60E4                    4206mm     BRA LOOP_303
00001CB0                          4207mm EXIT_303
00001CB0                          4208mm     ENDM
00001CB0                          4209m     ENDM
00001CB0                          4210      
00001CB0  2E0B                    4211          MOVE.L A3, D7                           ; set go address
00001CB2                          4212      ENDI
00001CB2                          4213s _00000028
00001CB2                          4214  
00001CB2  6000 E690               4215      BRA MAIN_LOOP
00001CB6                          4216  
00001CB6                          4217  HEX_DIGIT
00001CB6  E98F                    4218      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001CB8                          4219m     HEX2BIN D2,D2,A0
00001CB8  41FA 03BE               4220m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001CBC  0402 0030               4221m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001CC0  C4BC 000000FF           4222m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001CC6  1430 2000               4223m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001CCA                          4224m     ENDM
00001CCA  8E02                    4225      OR.B D2,D7  
00001CCC  6000 E696               4226      BRA GET_INPUT
00001CD0                          4227  
00001CD0                          4228  ; exceptions    
00001CD0                          4229  BUS_ERROR_HANDLER
00001CD0                          4230  
00001CD0  41FA 040E               4231      LEA BUS_ERROR(PC),A0
00001CD4                          4232m     PRINT_STR A0,D1
00001CD4                          4233m LOOP_306
00001CD4  0C10 0000               4234m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CD8  6700 0016               4235m     BEQ EXIT_306
00001CDC                          4236mm     PRINT_CHAR (A0)+,D1
00001CDC                          4237mm WAIT_FOR_READY_307                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CDC                 TRUE     4238mm     IFEQ DEBUG
00001CDC  1239 00C00003           4239mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CE2  0801 0002               4240mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CE6  67F4                    4241mm         BEQ WAIT_FOR_READY_307                      ; NO SPACE, CHECK AGAIN
00001CE8  13D8 00C00007           4242mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CEE                          4243mm     ENDC
00001CEE                          4244mm 
00001CEE                 FALSE    4245mm     IFNE DEBUG
00001CEE                          4246mm     ENDC
00001CEE                          4247mm 
00001CEE                          4248mm     ENDM
00001CEE  60E4                    4249m     BRA LOOP_306
00001CF0                          4250m EXIT_306
00001CF0                          4251m     ENDM
00001CF0                          4252  
00001CF0  7000                    4253      MOVE.L #0,D0
00001CF2  3017                    4254      MOVE.W (SP),D0
00001CF4                          4255  
00001CF4  0800 0004               4256      BTST #4,D0
00001CF8  6700 0026               4257      BEQ WRITE
00001CFC                          4258      
00001CFC  41FA 03F7               4259      LEA READING(PC),A0
00001D00                          4260m     PRINT_STR A0,D1
00001D00                          4261m LOOP_308
00001D00  0C10 0000               4262m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D04  6700 0016               4263m     BEQ EXIT_308
00001D08                          4264mm     PRINT_CHAR (A0)+,D1
00001D08                          4265mm WAIT_FOR_READY_309                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D08                 TRUE     4266mm     IFEQ DEBUG
00001D08  1239 00C00003           4267mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001D0E  0801 0002               4268mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001D12  67F4                    4269mm         BEQ WAIT_FOR_READY_309                      ; NO SPACE, CHECK AGAIN
00001D14  13D8 00C00007           4270mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D1A                          4271mm     ENDC
00001D1A                          4272mm 
00001D1A                 FALSE    4273mm     IFNE DEBUG
00001D1A                          4274mm     ENDC
00001D1A                          4275mm 
00001D1A                          4276mm     ENDM
00001D1A  60E4                    4277m     BRA LOOP_308
00001D1C                          4278m EXIT_308
00001D1C                          4279m     ENDM
00001D1C                          4280  
00001D1C  6000 0022               4281      BRA CONTINUE    
00001D20                          4282  WRITE
00001D20  41FA 03DC               4283      LEA WRITING(PC),A0
00001D24                          4284m     PRINT_STR A0,D1
00001D24                          4285m LOOP_310
00001D24  0C10 0000               4286m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D28  6700 0016               4287m     BEQ EXIT_310
00001D2C                          4288mm     PRINT_CHAR (A0)+,D1
00001D2C                          4289mm WAIT_FOR_READY_311                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D2C                 TRUE     4290mm     IFEQ DEBUG
00001D2C  1239 00C00003           4291mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001D32  0801 0002               4292mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001D36  67F4                    4293mm         BEQ WAIT_FOR_READY_311                      ; NO SPACE, CHECK AGAIN
00001D38  13D8 00C00007           4294mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D3E                          4295mm     ENDC
00001D3E                          4296mm 
00001D3E                 FALSE    4297mm     IFNE DEBUG
00001D3E                          4298mm     ENDC
00001D3E                          4299mm 
00001D3E                          4300mm     ENDM
00001D3E  60E4                    4301m     BRA LOOP_310
00001D40                          4302m EXIT_310
00001D40                          4303m     ENDM
00001D40                          4304  
00001D40                          4305  CONTINUE
00001D40  222F 0002               4306      MOVE.L 2(SP),D1
00001D44                          4307m     PRINT_REG D1,D2,D3,D4,A0
00001D44  41FA 0363               4308m     LEA OX(PC),A0
00001D48                          4309mm     PRINT_STR A0,D2
00001D48                          4310mm LOOP_313
00001D48  0C10 0000               4311mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D4C  6700 0016               4312mm     BEQ EXIT_313
00001D50                          4313mmm     PRINT_CHAR (A0)+,D2
00001D50                          4314mmm WAIT_FOR_READY_314                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D50                 TRUE     4315mmm     IFEQ DEBUG
00001D50  1439 00C00003           4316mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D56  0802 0002               4317mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D5A  67F4                    4318mmm         BEQ WAIT_FOR_READY_314                      ; NO SPACE, CHECK AGAIN
00001D5C  13D8 00C00007           4319mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D62                          4320mmm     ENDC
00001D62                          4321mmm 
00001D62                 FALSE    4322mmm     IFNE DEBUG
00001D62                          4323mmm     ENDC
00001D62                          4324mmm 
00001D62                          4325mmm     ENDM
00001D62  60E4                    4326mm     BRA LOOP_313
00001D64                          4327mm EXIT_313
00001D64                          4328mm     ENDM
00001D64  7807                    4329m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001D66                          4330m LOOP_312
00001D66                          4331mm     BIN2HEX D1,D3,A0
00001D66  41FA 0300               4332mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001D6A  E999                    4333mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001D6C  1601                    4334mm     MOVE.B D1,D3
00001D6E  0283 0000000F           4335mm     ANDI.L #$F,D3
00001D74  1630 3000               4336mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D78                          4337mm     ENDM
00001D78                          4338mm     PRINT_CHAR D3,D2
00001D78                          4339mm WAIT_FOR_READY_316                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D78                 TRUE     4340mm     IFEQ DEBUG
00001D78  1439 00C00003           4341mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D7E  0802 0002               4342mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D82  67F4                    4343mm         BEQ WAIT_FOR_READY_316                      ; NO SPACE, CHECK AGAIN
00001D84  13C3 00C00007           4344mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D8A                          4345mm     ENDC
00001D8A                          4346mm 
00001D8A                 FALSE    4347mm     IFNE DEBUG
00001D8A                          4348mm     ENDC
00001D8A                          4349mm 
00001D8A                          4350mm     ENDM
00001D8A  57CC FFDA               4351m     DBEQ D4,LOOP_312
00001D8E                          4352m     ENDM
00001D8E                          4353  
00001D8E  41FA 0377               4354      LEA FROM(PC),A0
00001D92                          4355m     PRINT_STR A0,D0
00001D92                          4356m LOOP_317
00001D92  0C10 0000               4357m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D96  6700 0016               4358m     BEQ EXIT_317
00001D9A                          4359mm     PRINT_CHAR (A0)+,D0
00001D9A                          4360mm WAIT_FOR_READY_318                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D9A                 TRUE     4361mm     IFEQ DEBUG
00001D9A  1039 00C00003           4362mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001DA0  0800 0002               4363mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001DA4  67F4                    4364mm         BEQ WAIT_FOR_READY_318                      ; NO SPACE, CHECK AGAIN
00001DA6  13D8 00C00007           4365mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DAC                          4366mm     ENDC
00001DAC                          4367mm 
00001DAC                 FALSE    4368mm     IFNE DEBUG
00001DAC                          4369mm     ENDC
00001DAC                          4370mm 
00001DAC                          4371mm     ENDM
00001DAC  60E4                    4372m     BRA LOOP_317
00001DAE                          4373m EXIT_317
00001DAE                          4374m     ENDM
00001DAE                          4375  
00001DAE  222F 000A               4376      MOVE.L 10(SP),D1
00001DB2                          4377m     PRINT_REG D1,D2,D3,D4,A0
00001DB2  41FA 02F5               4378m     LEA OX(PC),A0
00001DB6                          4379mm     PRINT_STR A0,D2
00001DB6                          4380mm LOOP_320
00001DB6  0C10 0000               4381mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001DBA  6700 0016               4382mm     BEQ EXIT_320
00001DBE                          4383mmm     PRINT_CHAR (A0)+,D2
00001DBE                          4384mmm WAIT_FOR_READY_321                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DBE                 TRUE     4385mmm     IFEQ DEBUG
00001DBE  1439 00C00003           4386mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001DC4  0802 0002               4387mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001DC8  67F4                    4388mmm         BEQ WAIT_FOR_READY_321                      ; NO SPACE, CHECK AGAIN
00001DCA  13D8 00C00007           4389mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DD0                          4390mmm     ENDC
00001DD0                          4391mmm 
00001DD0                 FALSE    4392mmm     IFNE DEBUG
00001DD0                          4393mmm     ENDC
00001DD0                          4394mmm 
00001DD0                          4395mmm     ENDM
00001DD0  60E4                    4396mm     BRA LOOP_320
00001DD2                          4397mm EXIT_320
00001DD2                          4398mm     ENDM
00001DD2  7807                    4399m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001DD4                          4400m LOOP_319
00001DD4                          4401mm     BIN2HEX D1,D3,A0
00001DD4  41FA 0292               4402mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001DD8  E999                    4403mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001DDA  1601                    4404mm     MOVE.B D1,D3
00001DDC  0283 0000000F           4405mm     ANDI.L #$F,D3
00001DE2  1630 3000               4406mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001DE6                          4407mm     ENDM
00001DE6                          4408mm     PRINT_CHAR D3,D2
00001DE6                          4409mm WAIT_FOR_READY_323                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DE6                 TRUE     4410mm     IFEQ DEBUG
00001DE6  1439 00C00003           4411mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001DEC  0802 0002               4412mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001DF0  67F4                    4413mm         BEQ WAIT_FOR_READY_323                      ; NO SPACE, CHECK AGAIN
00001DF2  13C3 00C00007           4414mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001DF8                          4415mm     ENDC
00001DF8                          4416mm 
00001DF8                 FALSE    4417mm     IFNE DEBUG
00001DF8                          4418mm     ENDC
00001DF8                          4419mm 
00001DF8                          4420mm     ENDM
00001DF8  57CC FFDA               4421m     DBEQ D4,LOOP_319
00001DFC                          4422m     ENDM
00001DFC                          4423m     PRINT_CRLF D0,A0
00001DFC  41FA 02A5               4424m     LEA CRLF(PC),A0
00001E00                          4425mm     PRINT_STR A0,D0
00001E00                          4426mm LOOP_325
00001E00  0C10 0000               4427mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001E04  6700 0016               4428mm     BEQ EXIT_325
00001E08                          4429mmm     PRINT_CHAR (A0)+,D0
00001E08                          4430mmm WAIT_FOR_READY_326                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001E08                 TRUE     4431mmm     IFEQ DEBUG
00001E08  1039 00C00003           4432mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001E0E  0800 0002               4433mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001E12  67F4                    4434mmm         BEQ WAIT_FOR_READY_326                      ; NO SPACE, CHECK AGAIN
00001E14  13D8 00C00007           4435mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001E1A                          4436mmm     ENDC
00001E1A                          4437mmm 
00001E1A                 FALSE    4438mmm     IFNE DEBUG
00001E1A                          4439mmm     ENDC
00001E1A                          4440mmm 
00001E1A                          4441mmm     ENDM
00001E1A  60E4                    4442mm     BRA LOOP_325
00001E1C                          4443mm EXIT_325
00001E1C                          4444mm     ENDM
00001E1C                          4445m     ENDM
00001E1C                          4446      
00001E1C  207C 00000004           4447      MOVE.L #4,A0
00001E22  4ED0                    4448      JMP (A0)
00001E24                          4449          
00001E24                          4450  ILLEGAL_HANDLER
00001E24  13FC 0007 00E00001      4451      MOVE.B #7,DISPLAY   
00001E2C  207C 00000004           4452      MOVE.L #4,A0
00001E32  4ED0                    4453      JMP (A0)
00001E34                          4454          
00001E34                          4455  UNHANDLED_HANDLER
00001E34  41FA 02D8               4456      LEA UNHANDLED(PC),A0
00001E38  4EF9 00001E5C           4457      JMP PRINTIT_RTE
00001E3E                          4458      
00001E3E                          4459  UNINITIALISED_HANDLER
00001E3E  41FA 02E4               4460      LEA UNINITIALISED(PC),A0
00001E42  4EF9 00001E5C           4461      JMP PRINTIT_RTE
00001E48                          4462  
00001E48                          4463  TICK_HANDLER
00001E48  1039 00C0001F           4464      MOVE.B DUART_RESET_OPR,D0
00001E4E  41FA 0289               4465      LEA TICK(PC),A0
00001E52  4EF9 00001E5C           4466      JMP PRINTIT_RTE
00001E58                          4467  
00001E58                          4468  SPURIOUS_HANDLER
00001E58  41FA 02E9               4469      LEA SPURIOUS(PC),A0
00001E5C                          4470  PRINTIT_RTE
00001E5C                          4471m     PRINT_STR A0,D1
00001E5C                          4472m LOOP_327
00001E5C  0C10 0000               4473m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001E60  6700 0016               4474m     BEQ EXIT_327
00001E64                          4475mm     PRINT_CHAR (A0)+,D1
00001E64                          4476mm WAIT_FOR_READY_328                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001E64                 TRUE     4477mm     IFEQ DEBUG
00001E64  1239 00C00003           4478mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001E6A  0801 0002               4479mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001E6E  67F4                    4480mm         BEQ WAIT_FOR_READY_328                      ; NO SPACE, CHECK AGAIN
00001E70  13D8 00C00007           4481mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001E76                          4482mm     ENDC
00001E76                          4483mm 
00001E76                 FALSE    4484mm     IFNE DEBUG
00001E76                          4485mm     ENDC
00001E76                          4486mm 
00001E76                          4487mm     ENDM
00001E76  60E4                    4488m     BRA LOOP_327
00001E78                          4489m EXIT_327
00001E78                          4490m     ENDM
00001E78  4E73                    4491      RTE 
00001E7A                          4492      
00001E7A  FFFF FFFF               4493      SIMHALT                                             ; halt simulator
00001E7E                          4494  
00001E7E                          4495  ; strings
00001E7E= 50 72 65 73 73 20 ...   4496  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001E91= 5B 3F 5D 09 09 09 ...   4497  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001E9D= 5B 76 5D 09 09 09 ...   4498          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001EAC= 78 78 78 78 78 78 ...   4499          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001EC4= 78 78 78 78 78 78 ...   4500          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001EE4= 78 78 78 78 78 78 ...   4501          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001F05= 78 78 78 78 78 78 ...   4502          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001F16= 5B 7A 5D 09 09 09 ...   4503          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001F28= 78 78 78 78 78 78 ...   4504          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001F4C= 78 78 78 78 78 78 ...   4505          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001F6E= 23 09 09 09 77 72 ...   4506          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001F88= 5B 78 5D 09 09 09 ...   4507          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001F9F= 5B 49 5D 09 09 09 ...   4508          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001FB8= 5B 6F 5D 09 09 09 ...   4509          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001FD2= 5B 69 5D 09 09 09 ...   4510          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001FE8= 78 78 78 78 78 78 ...   4511          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00002006= 48 75 68 3F 0D 0A 00    4512  HUH  DC.B 'Huh?',CR,LF,NULL
0000200D= 20 53 20 72 65 63 ...   4513  READ    DC.B ' S records read, start address = ',NULL
0000202F= 57 3A 20 55 6E 6B ...   4514  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00002046= 21 20 43 53 20 66 ...   4515  CS_FAILURE  DC.B '! CS failure at ',NULL
00002057= 21 20 52 41 4D 20 ...   4516  RAM_ERROR   DC.B '! RAM error at: ',NULL
00002068= 30 31 32 33 34 35 ...   4517  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00002078= 00 01 02 03 04 05 ...   4518  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000208F= 4C 6F 61 64 69 6E ...   4519  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000020A3= 0D 0A 00                4520  CRLF    DC.B CR,LF,NULL
000020A6= 3E 20 00                4521  PROMPT  DC.B '> ',NULL
000020A9= 30 78 00                4522  ox      DC.B '0x',NULL
000020AC= 20 2D 3E 20 00          4523  to      DC.B ' -> ',NULL
000020B1= 20 66 6F 72 20 00       4524  for     DC.B ' for ',NULL
000020B7= 53 50 3A 20 00          4525  STACK_POINTER DC.B 'SP: ',NULL
000020BC= 53 52 3A 20 00          4526  STATUS_REGISTER DC.B 'SR: ',NULL
000020C1= 20 3A 20 00             4527  INDEX_SEP DC.B ' : ',NULL
000020C5= 42 6F 6F 74 69 6E ...   4528  BOOT DC.B 'Booting',NULL
000020CD= 4E 6F 74 20 66 6F ...   4529  NOT_FOUND DC.B 'Not found',CR,LF,NULL
000020D9= 74 69 63 6B 0D 0A 00    4530  TICK DC.B 'tick',CR,LF,NULL
000020E0= 2A 20 42 75 73 2F ...   4531  BUS_ERROR DC.B '* Bus/address error ',NULL
000020F5= 72 65 61 64 69 6E ...   4532  READING DC.B 'reading ',NULL
000020FE= 77 72 69 74 69 6E ...   4533  WRITING DC.B 'writing ',NULL
00002107= 20 66 72 6F 6D 20 00    4534  FROM DC.B ' from ',NULL
0000210E= 2A 20 55 6E 68 61 ...   4535  UNHANDLED DC.B '* Unhandled interrupt',NULL
00002124= 2A 20 55 6E 69 74 ...   4536  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00002143= 2A 20 53 70 75 72 ...   4537  SPURIOUS DC.B '* Spurious interrupt',NULL
00002158= 4D 44 46 2D 6D 6F ...   4538  VERSION DC.B 'MDF-mon V1.149 (01/06/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00002176= 00                      4539  END     DC.B 0
00002177                          4540      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         2068
BOOT                20C5
BUS_ERROR           20E0
BUS_ERROR_HANDLER   1CD0
CONTINUE            1D40
CONTINUE_101        A86
CONTINUE_54         624
CONTINUE_57         674
CONTINUE_60         6B8
CONTINUE_64         73A
CONTINUE_68         79A
CONTINUE_72         804
CONTINUE_76         870
CONTINUE_80         8E6
CONTINUE_84         946
CONTINUE_88         9A6
CR                  D
CRLF                20A3
CS_FAILURE          2046
DEBUG               0
DI                  134C
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       B54
DOWNLOAD_DONE       B7E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  133C
END                 2176
EXIT_10             288
EXIT_105            AE4
EXIT_107            B04
EXIT_110            B24
EXIT_115            B6E
EXIT_118            B9E
EXIT_121            BBE
EXIT_125            C08
EXIT_128            C2A
EXIT_133            C74
EXIT_135            CF0
EXIT_138            D14
EXIT_143            D5E
EXIT_15             2D2
EXIT_150            DF0
EXIT_153            E60
EXIT_156            E82
EXIT_160            ECC
EXIT_163            EEE
EXIT_167            F38
EXIT_17             2F2
EXIT_170            F58
EXIT_175            FA2
EXIT_190            10C4
EXIT_193            1128
EXIT_196            1148
EXIT_20             312
EXIT_200            1192
EXIT_203            11B4
EXIT_208            11FE
EXIT_212            1240
EXIT_215            1262
EXIT_22             364
EXIT_220            12AC
EXIT_222            12CC
EXIT_225            12EE
EXIT_230            1338
EXIT_264            1824
EXIT_267            188A
EXIT_270            18AA
EXIT_275            194A
EXIT_277            198C
EXIT_279            19B8
EXIT_28             3F0
EXIT_30             47C
EXIT_303            1CB0
EXIT_306            1CF0
EXIT_308            1D1C
EXIT_310            1D40
EXIT_313            1D64
EXIT_317            1DAE
EXIT_32             4A8
EXIT_320            1DD2
EXIT_325            1E1C
EXIT_327            1E78
EXIT_35             4D2
EXIT_45             580
EXIT_5              240
EXIT_52             5F6
EXIT_7              260
EXIT_92             A06
EXIT_94             A26
EXIT_98             A58
FOR                 20B1
FROM                2107
G                   C78
GET_INPUT           364
H                   480
HASH                135C
HELP                1E91
HELPPROMPT          1E7E
HEX2BIN             10B
HEX2BIN_LUT         2078
HEX_DIGIT           1CB6
HUH                 2006
IB                  1372
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1E24
INDEX_SEP           20C1
L                   D6E
LF                  A
LOADING             208F
LOOP_10             26C
LOOP_105            AC8
LOOP_107            AE8
LOOP_109            B26
LOOP_110            B08
LOOP_115            B52
LOOP_118            B82
LOOP_120            BC0
LOOP_121            BA2
LOOP_125            BEC
LOOP_127            C2C
LOOP_128            C0E
LOOP_133            C58
LOOP_135            CD4
LOOP_137            D16
LOOP_138            CF8
LOOP_143            D42
LOOP_15             2B6
LOOP_150            DD4
LOOP_153            E44
LOOP_155            E84
LOOP_156            E66
LOOP_160            EB0
LOOP_162            EF0
LOOP_163            ED2
LOOP_167            F1C
LOOP_169            F5A
LOOP_17             2D6
LOOP_170            F3C
LOOP_175            F86
LOOP_190            10A8
LOOP_193            110C
LOOP_195            114A
LOOP_196            112C
LOOP_20             2F6
LOOP_200            1176
LOOP_202            11B6
LOOP_203            1198
LOOP_208            11E2
LOOP_212            1224
LOOP_214            1264
LOOP_215            1246
LOOP_22             348
LOOP_220            1290
LOOP_222            12B0
LOOP_224            12F0
LOOP_225            12D2
LOOP_230            131C
LOOP_234            13B4
LOOP_238            13F2
LOOP_250            15CA
LOOP_253            1608
LOOP_264            1808
LOOP_267            186E
LOOP_269            18AC
LOOP_270            188E
LOOP_275            192E
LOOP_277            1970
LOOP_279            199C
LOOP_28             3D4
LOOP_282            19C6
LOOP_294            1B9E
LOOP_297            1BDC
LOOP_30             460
LOOP_303            1C94
LOOP_306            1CD4
LOOP_308            1D00
LOOP_310            1D24
LOOP_312            1D66
LOOP_313            1D48
LOOP_317            1D92
LOOP_319            1DD4
LOOP_32             48C
LOOP_320            1DB6
LOOP_325            1E00
LOOP_327            1E5C
LOOP_34             4D4
LOOP_35             4B6
LOOP_45             564
LOOP_5              224
LOOP_52             5DA
LOOP_7              244
LOOP_9              28A
LOOP_92             9EA
LOOP_94             A0A
LOOP_98             A3C
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           20CD
NULL                0
OX                  20A9
P                   1050
PRINTIT             48C
PRINTIT_RTE         1E5C
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             CFE
PROGRAM_VECTOR      D95
PROMPT              20A6
PROTECT             AF0
R                   4AC
RAM                 200000
RAM_ERROR           2057
READ                200D
READING             20F5
READ_16             1188
READ_32             13B5
READ_8              E13
READ_CHAR           6DD
READ_IDE_STATUS     1404
RESET               4
ROM                 0
S                   5FE
SEND_COMMAND        1686
SEND_READ_COMMAND_AND_WAIT  16B5
SET_READ_ADDRESS    1524
SPURIOUS            2143
SPURIOUS_HANDLER    1E58
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       20B7
START               104
STATUS_REGISTER     20BC
TAB                 9
TICK                20D9
TICK_HANDLER        1E48
TO                  20AC
UNHANDLED           210E
UNHANDLED_HANDLER   1E34
UNINITIALISED       2124
UNINITIALISED_HANDLER  1E3E
UNPROTECT           A29
UNREC               202F
USER                100
V                   488
VECS                8
VERSION             2158
W                   584
WAIT_CHAR           599
WAIT_DRIVE_DRQ      14D4
WAIT_DRIVE_NOT_BUSY  1483
WAIT_DRIVE_READY    1431
WAIT_FOR_COMPLETE_177  FB4
WAIT_FOR_COMPLETE_179  FD6
WAIT_FOR_COMPLETE_180  FE8
WAIT_FOR_COMPLETE_182  1016
WAIT_FOR_COMPLETE_183  1028
WAIT_FOR_COMPLETE_210  1200
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A6A
WAIT_FOR_READY_106  AD0
WAIT_FOR_READY_108  AF0
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  B10
WAIT_FOR_READY_113  B38
WAIT_FOR_READY_116  B5A
WAIT_FOR_READY_119  B8A
WAIT_FOR_READY_122  BAA
WAIT_FOR_READY_124  BD2
WAIT_FOR_READY_126  BF4
WAIT_FOR_READY_129  C16
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_131  C3E
WAIT_FOR_READY_134  C60
WAIT_FOR_READY_136  CDC
WAIT_FOR_READY_139  D00
WAIT_FOR_READY_141  D28
WAIT_FOR_READY_144  D4A
WAIT_FOR_READY_145  D7C
WAIT_FOR_READY_147  D96
WAIT_FOR_READY_151  DDC
WAIT_FOR_READY_154  E4C
WAIT_FOR_READY_157  E6E
WAIT_FOR_READY_159  E96
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  EB8
WAIT_FOR_READY_164  EDA
WAIT_FOR_READY_166  F02
WAIT_FOR_READY_168  F24
WAIT_FOR_READY_171  F44
WAIT_FOR_READY_173  F6C
WAIT_FOR_READY_176  F8E
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_185  105C
WAIT_FOR_READY_187  1076
WAIT_FOR_READY_191  10B0
WAIT_FOR_READY_194  1114
WAIT_FOR_READY_197  1134
WAIT_FOR_READY_199  115C
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  117E
WAIT_FOR_READY_204  11A0
WAIT_FOR_READY_206  11C8
WAIT_FOR_READY_209  11EA
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_213  122C
WAIT_FOR_READY_216  124E
WAIT_FOR_READY_218  1276
WAIT_FOR_READY_221  1298
WAIT_FOR_READY_223  12B8
WAIT_FOR_READY_226  12DA
WAIT_FOR_READY_228  1302
WAIT_FOR_READY_23   350
WAIT_FOR_READY_231  1324
WAIT_FOR_READY_24   364
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_263  17F2
WAIT_FOR_READY_265  1810
WAIT_FOR_READY_266  183E
WAIT_FOR_READY_268  1876
WAIT_FOR_READY_271  1896
WAIT_FOR_READY_273  18BE
WAIT_FOR_READY_276  1936
WAIT_FOR_READY_278  1978
WAIT_FOR_READY_280  19A4
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_300  1C1A
WAIT_FOR_READY_304  1C9C
WAIT_FOR_READY_307  1CDC
WAIT_FOR_READY_309  1D08
WAIT_FOR_READY_31   468
WAIT_FOR_READY_311  1D2C
WAIT_FOR_READY_314  1D50
WAIT_FOR_READY_316  1D78
WAIT_FOR_READY_318  1D9A
WAIT_FOR_READY_321  1DBE
WAIT_FOR_READY_323  1DE6
WAIT_FOR_READY_326  1E08
WAIT_FOR_READY_328  1E64
WAIT_FOR_READY_33   494
WAIT_FOR_READY_36   4BE
WAIT_FOR_READY_38   4E6
WAIT_FOR_READY_39   4FC
WAIT_FOR_READY_40   512
WAIT_FOR_READY_41   526
WAIT_FOR_READY_42   53A
WAIT_FOR_READY_43   54E
WAIT_FOR_READY_46   56C
WAIT_FOR_READY_47   58E
WAIT_FOR_READY_49   5A8
WAIT_FOR_READY_53   5E2
WAIT_FOR_READY_54   608
WAIT_FOR_READY_56   642
WAIT_FOR_READY_57   658
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_60   69C
WAIT_FOR_READY_64   71E
WAIT_FOR_READY_68   77E
WAIT_FOR_READY_72   7E8
WAIT_FOR_READY_76   854
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_80   8CA
WAIT_FOR_READY_84   92A
WAIT_FOR_READY_88   98A
WAIT_FOR_READY_93   9F2
WAIT_FOR_READY_95   A12
WAIT_FOR_READY_96   A26
WAIT_FOR_READY_99   A44
WAIT_FOR_SRECORD    608
WRITE               1D20
WRITE_8             FCC
WRITING             20FE
X                   1220
Z                   C7E
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6FE
_00000004           A5C
_00000005           70C
_00000006           8B2
_00000007           83A
_00000008           A5C
_00000009           9E6
_0000000A           A5C
_0000000B           B72
_0000000C           B7E
_0000000D           D5E
_0000000E           FBE
_0000000F           FE0
_00000010           FF2
_00000011           1020
_00000012           1032
_00000013           120A
_00000014           170C
_00000015           1708
_00000016           1910
_00000017           17CA
_00000018           190A
_00000019           18D6
_0000001A           1824
_0000001B           1858
_0000001C           18D6
_0000001D           1906
_0000001E           18E8
_0000001F           18F2
_00000020           18FC
_00000021           1906
_00000022           1910
_00000023           194A
_00000024           194A
_00000025           1990
_00000026           196C
_00000027           1990
_00000028           1CB2
_10000000           692
_10000001           6E8
_10000002           714
_10000003           76A
_10000004           774
_10000005           7CA
_10000006           7DE
_10000007           834
_10000008           83E
_10000009           8AC
_1000000A           84A
_1000000B           8A0
_1000000C           8C0
_1000000D           916
_1000000E           920
_1000000F           976
_10000010           980
_10000011           9D6
_10000012           A60
_10000013           AB6
_10000014           FA2
_10000015           FC4
_10000016           19BC
_10000017           1C90
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           58C
_20000005           5D0
_20000006           C90
_20000007           CA0
_20000008           CBA
_20000009           D60
_2000000A           D7A
_2000000B           DBE
_2000000C           E36
_2000000D           E3A
_2000000E           FFA
_2000000F           1034
_20000010           105A
_20000011           109E
_20000012           10FE
_20000013           1102
_20000014           164E
_20000015           16E4
_20000016           171A
_20000017           194E
_20000018           1726
_20000019           1912
_2000001A           183C
_2000001B           1852
_2000001C           1C34
_2000001D           1C82
