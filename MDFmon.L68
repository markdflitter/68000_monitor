00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 17/05/2021 19:01:24

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           190  PRINT_REG MACRO
00000000                           191      LEA ox(PC),\5
00000000                           192      PRINT_STR \5,\2
00000000                           193      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           194  LOOP\@
00000000                           195      BIN2HEX \1,\3,\5
00000000                           196      PRINT_CHAR \3,\2
00000000                           197      DBEQ \4,LOOP\@
00000000                           198      ENDM
00000000                           199  
00000000                           200  ; wait for a char from the serial port
00000000                           201  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           202  ; will stamp on D0 and D1 in debug mode
00000000                           203  WAIT_CHAR MACRO
00000000                           204  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           205      IFEQ DEBUG
00000000                           206          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           207          BTST #0,\2                                  ; check for character
00000000                           208          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           209      ENDC
00000000                           210  
00000000                           211      READ_CHAR \1
00000000                           212  
00000000                           213      IFEQ DEBUG
00000000                           214          PRINT_CHAR \1,\2                            ; echo it back
00000000                           215      ENDC
00000000                           216      ENDM
00000000                           217  
00000000                           218  ; read a char from the serial port - assumes that there is one!
00000000                           219  ; \ 1= data register for read char
00000000                           220  ; will stamp on D0 and D1 in debug mode
00000000                           221  READ_CHAR MACRO
00000000                           222      IFEQ DEBUG
00000000                           223          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           224      ENDC
00000000                           225      IFNE DEBUG
00000000                           226          MOVE.L #5,D0    
00000000                           227          TRAP #15                                    ; read from keyboard in simulator
00000000                           228          MOVE.L D1,\1
00000000                           229      ENDC
00000000                           230  
00000000                           231      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           232      BEQ START
00000000                           233      ENDM
00000000                           234  
00000000                           235  
00000000                           236  ; read data from the download serial port
00000000                           237  ; \ 1= data register for read char
00000000                           238  DOWNLOAD MACRO
00000000                           239  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           240  
00000000                           241      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           242      BTST #0,\1                                      ; check for character
00000000                           243      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           244  
00000000                           245      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           246  CONTINUE\@
00000000                           247      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           248      BTST #0,\1                                      ; check for character
00000000                           249      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           250      
00000000                           251      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           252      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           253  
00000000                           254      ENDM
00000000                           255  
00000000                           256  ; unprotect the EEPROM
00000000                           257  UNPROTECT MACRO
00000000                           258      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           259      NOP
00000000                           260      MOVE.W #$5555,$1554
00000000                           261      NOP
00000000                           262      MOVE.W #$8080,$2AAA
00000000                           263      NOP
00000000                           264      MOVE.W #$AAAA,$2AAA
00000000                           265      NOP
00000000                           266      MOVE.W #$5555,$1554
00000000                           267      NOP
00000000                           268      MOVE.W #$2020,$2AAA
00000000                           269      ENDM
00000000                           270      
00000000                           271  ; protect the EEPROM
00000000                           272  PROTECT MACRO
00000000                           273      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           274      MOVE.W #$5555,$1554
00000000                           275      MOVE.W #$A0A0,$2AAA
00000000                           276      ENDM
00000000                           277  
00000000                           278  
00000000                           279  ; read two hex digits from the download serial port and convert to a byte
00000000                           280  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           281  DOWNLOAD_BYTE MACRO
00000000                           282      MOVE.B #2,\4
00000000                           283      WHILE.B \4 <GT> 0 DO
00000000                           284          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           285          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           286          PRINT_CHAR \2,\3
00000000                           287          HEX2BIN \2,\2,\6
00000000                           288          OR.B \2,\1
00000000                           289          SUB.B #1,\4
00000000                           290      ENDW
00000000                           291  
00000000                           292      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           293      MOVE.B \1,\2
00000000                           294      ADD.L \1,\5
00000000                           295  
00000000                           296      ENDM
00000000                           297  
00000000                           298  ; write word to EEPROM
00000000                           299  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           300  PROGRAM MACRO
00000000                           301    MOVE.W \1,\2                                      ; write the data
00000000                           302  
00000000                           303  WAIT_FOR_COMPLETE\@
00000000                           304          MOVE.W \2,\3
00000000                           305  
00000000                           306          IF.W \3 <NE> \1 THEN
00000000                           307              BRA WAIT_FOR_COMPLETE\@
00000000                           308          ENDI
00000000                           309          ENDM
00000000                           310          
00000000                           311  ; program vector to EEPROM
00000000                           312  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           313  PROGRAM_VECTOR MACRO
00000000                           314      ADD.L #2,\2
00000000                           315      PROGRAM \1, (\2), \3                            ; write it
00000000                           316      LSR.L #8,\1
00000000                           317      LSR.L #8,\1
00000000                           318      SUB.L #2,\2
00000000                           319      PROGRAM \1, (\2), \3
00000000                           320      ENDM
00000000                           321  
00000000                           322  ; read an ide register
00000000                           323  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           324  READ_8 MACRO
00000000                           325      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           326      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           327      ORI.B \1, \3
00000000                           328      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           329      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           330      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           331      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           332      ORI.B #MC68230_PORT_C_READ, \3
00000000                           333      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           334      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           335      ENDM
00000000                           336      
00000000                           337  ; write an ide register
00000000                           338  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           339  WRITE_8 MACRO
00000000                           340      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           341      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           342      ORI.B \2, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           345      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           346      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           347      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           348      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           349      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           350      ENDM
00000000                           351  
00000000                           352  ; read ide data
00000000                           353  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           354  READ_16 MACRO
00000000                           355      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           356      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           357      
00000000                           358      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           359      ORI.B \1, \3
00000000                           360      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           361      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           362      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           363      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           364      LSL.W #8, \2
00000000                           365      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           366      ORI.B #MC68230_PORT_C_READ, \3
00000000                           367      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           369      ENDM
00000000                           370      
00000000                           371  ; read ide data
00000000                           372  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           373  READ_32 MACRO
00000000                           374      READ_16 \1, \2, \3
00000000                           375      LSL.L #8, \2
00000000                           376      LSL.L #8, \2
00000000                           377      READ_16 \1, \2, \3
00000000                           378      ENDM
00000000                           379          
00000000                           380  ; read ide status
00000000                           381  ;\1 = data register for result, \2 = working data register 
00000000                           382  READ_IDE_STATUS MACRO   
00000000                           383      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           384      ENDM
00000000                           385      
00000000                           386  ; wait for ide drive to be ready
00000000                           387  ;\1 = working data register 1, \2 = working data register 2
00000000                           388  WAIT_DRIVE_READY MACRO
00000000                           389  LOOP\@
00000000                           390      READ_IDE_STATUS \1, \2
00000000                           391      BTST #IDE_STATUS_READY, \1
00000000                           392      BEQ LOOP\@
00000000                           393      ENDM
00000000                           394      
00000000                           395  ; wait for ide drive to be not busy
00000000                           396  ;\1 = working data register 1, \2 = working data register 2
00000000                           397  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           398  LOOP\@
00000000                           399      READ_IDE_STATUS \1, \2
00000000                           400      BTST #IDE_STATUS_BUSY, \1
00000000                           401      BNE LOOP\@
00000000                           402      ENDM
00000000                           403      
00000000                           404  ; wait for ide drive to have data for us
00000000                           405  ;\1 = working data register 1, \2 = working data register 2
00000000                           406  WAIT_DRIVE_DRQ MACRO
00000000                           407  LOOP\@
00000000                           408      READ_IDE_STATUS \1, \2
00000000                           409      BTST #IDE_STATUS_DRQ, \1
00000000                           410      BEQ LOOP\@
00000000                           411      ENDM
00000000                           412      
00000000                           413  ; prepare to send a read command
00000000                           414  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           415  SET_READ_ADDRESS MACRO
00000000                           416      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           417      MOVE.L \1,\3
00000000                           418      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           419      LSR.L #8, \3
00000000                           420      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           421      LSR.L #8, \3                                
00000000                           422      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           423      LSR.L #8, \3
00000000                           424      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           425      ANDI.B #$0F,\3
00000000                           426      OR.B \3,\4
00000000                           427      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           428      ENDM
00000000                           429  
00000000                           430  ; send command
00000000                           431  ; \1 = command, \2 = working data register 1,
00000000                           432  SEND_COMMAND MACRO
00000000                           433      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           434      ENDM
00000000                           435      
00000000                           436  ; send read command and wait
00000000                           437  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           438  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           439      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           440      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           441      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           442      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           443      WAIT_DRIVE_DRQ \2, \3
00000000                           444      ENDM
00000000                           445  
00000000                           446  ; register catalogue
00000000                           447  ; D0 - used for simulator I/O
00000000                           448  ; D1 - used for simulator I/O
00000000                           449  ; D2 - read character
00000000                           450  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           451  ; D6 - working register used in R/W
00000000                           452  ; D7 - address accumulator, reset by download
00000000                           453  ; A0 - address of string to print 
00000000                           454  
00000000                           455  ; start vector
00000000= 002E0000                 456  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 457  RESET   DC.L START                              ; RESET
00000008= 0000197C                 458  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 0000197C                 459          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001AD0                 460          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001AE0                 461          DC.L UNHANDLED_HANDLER
00000018= 00001AE0                 462          DC.L UNHANDLED_HANDLER
0000001C= 00001AE0                 463          DC.L UNHANDLED_HANDLER
00000020= 00001AE0                 464          DC.L UNHANDLED_HANDLER
00000024= 00001AE0                 465          DC.L UNHANDLED_HANDLER
00000028= 00001AE0                 466          DC.L UNHANDLED_HANDLER
0000002C= 00001AE0                 467          DC.L UNHANDLED_HANDLER
00000030= 00001AE0                 468          DC.L UNHANDLED_HANDLER
00000034= 00001AE0                 469          DC.L UNHANDLED_HANDLER
00000038= 00001AE0                 470          DC.L UNHANDLED_HANDLER
0000003C= 00001AE0                 471          DC.L UNHANDLED_HANDLER
00000040= 00001AE0                 472          DC.L UNHANDLED_HANDLER
00000044= 00001AE0                 473          DC.L UNHANDLED_HANDLER
00000048= 00001AE0                 474          DC.L UNHANDLED_HANDLER
0000004C= 00001AE0                 475          DC.L UNHANDLED_HANDLER
00000050= 00001AE0                 476          DC.L UNHANDLED_HANDLER
00000054= 00001AE0                 477          DC.L UNHANDLED_HANDLER
00000058= 00001AE0                 478          DC.L UNHANDLED_HANDLER
0000005C= 00001AE0                 479          DC.L UNHANDLED_HANDLER
00000060= 00001B04                 480          DC.L SPURIOUS_HANDLER
00000064= 00001AE0                 481          DC.L UNHANDLED_HANDLER
00000068= 00001AE0                 482          DC.L UNHANDLED_HANDLER
0000006C= 00001AE0                 483          DC.L UNHANDLED_HANDLER
00000070= 00001AE0                 484          DC.L UNHANDLED_HANDLER
00000074= 00001AE0                 485          DC.L UNHANDLED_HANDLER
00000078= 00001AE0                 486          DC.L UNHANDLED_HANDLER
0000007C= 00001AE0                 487          DC.L UNHANDLED_HANDLER
00000080= 00001AE0                 488          DC.L UNHANDLED_HANDLER
00000084= 00001AE0                 489          DC.L UNHANDLED_HANDLER
00000088= 00001AE0                 490          DC.L UNHANDLED_HANDLER
0000008C= 00001AE0                 491          DC.L UNHANDLED_HANDLER
00000090= 00001AE0                 492          DC.L UNHANDLED_HANDLER
00000094= 00001AE0                 493          DC.L UNHANDLED_HANDLER
00000098= 00001AE0                 494          DC.L UNHANDLED_HANDLER
0000009C= 00001AE0                 495          DC.L UNHANDLED_HANDLER
000000A0= 00001AE0                 496          DC.L UNHANDLED_HANDLER
000000A4= 00001AE0                 497          DC.L UNHANDLED_HANDLER
000000A8= 00001AE0                 498          DC.L UNHANDLED_HANDLER
000000AC= 00001AE0                 499          DC.L UNHANDLED_HANDLER
000000B0= 00001AE0                 500          DC.L UNHANDLED_HANDLER
000000B4= 00001AE0                 501          DC.L UNHANDLED_HANDLER
000000B8= 00001AE0                 502          DC.L UNHANDLED_HANDLER
000000BC= 00001AE0                 503          DC.L UNHANDLED_HANDLER
000000C0= 00001AE0                 504          DC.L UNHANDLED_HANDLER
000000C4= 00001AE0                 505          DC.L UNHANDLED_HANDLER
000000C8= 00001AE0                 506          DC.L UNHANDLED_HANDLER
000000CC= 00001AE0                 507          DC.L UNHANDLED_HANDLER
000000D0= 00001AE0                 508          DC.L UNHANDLED_HANDLER
000000D4= 00001AE0                 509          DC.L UNHANDLED_HANDLER
000000D8= 00001AE0                 510          DC.L UNHANDLED_HANDLER 
000000DC= 00001AE0                 511          DC.L UNHANDLED_HANDLER
000000E0= 00001AE0                 512          DC.L UNHANDLED_HANDLER
000000E4= 00001AE0                 513          DC.L UNHANDLED_HANDLER 
000000E8= 00001AE0                 514          DC.L UNHANDLED_HANDLER 
000000EC= 00001AE0                 515          DC.L UNHANDLED_HANDLER
000000F0= 00001AE0                 516          DC.L UNHANDLED_HANDLER 
000000F4= 00001AE0                 517          DC.L UNHANDLED_HANDLER 
000000F8= 00001AE0                 518          DC.L UNHANDLED_HANDLER 
000000FC= 00001AE0                 519          DC.L UNHANDLED_HANDLER
00000100= 00001AF4                 520  USER    DC.L TICK_HANDLER
00000104                           521      ; start of program  
00000104                           522  START
00000104  2E7C 002E0000            523      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       524      MOVE.B #0,DISPLAY
00000112                           525  
00000112  7000                     526      MOVE.L #0,D0
00000114  1039 00C00019            527      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           528  
0000011A                           529  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       530      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       531      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           532      
0000012A                           533      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                534s     MOVE.W  #$50,D1
0000012E  6000 000E                535s     BRA _20000001
00000132                           536s _20000000
00000132  13C1 00C00005            537          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     538          NOP
0000013A                           539      ENDF
0000013A  0441 0010                540s     SUB.W   #$10,D1
0000013E                           541s _20000001
0000013E  B27C 0010                542s     CMP.W   #$10,D1
00000142  6CEE                     543s     BGE _20000000
00000144                           544  
00000144                           545      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                546s     MOVE.W  #$50,D1
00000148  6000 000E                547s     BRA _20000003
0000014C                           548s _20000002
0000014C  13C1 00C00015            549          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     550          NOP
00000154                           551      ENDF
00000154  0441 0010                552s     SUB.W   #$10,D1
00000158                           553s _20000003
00000158  B27C 0010                554s     CMP.W   #$10,D1
0000015C  6CEE                     555s     BGE _20000002
0000015E                           556      
0000015E                           557  ;initialise UART
0000015E  13FC 0000 00C0000B       558      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       559      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       560      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       561      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       562      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           563  
00000186                           564  ; channel A
00000186  13FC 0013 00C00001       565      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       566      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       567      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       568      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           569  
000001A6                           570  ; channel B
000001A6  13FC 0013 00C00011       571      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       572      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       573      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       574      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       575      MOVE.B #64,DUART_IVR
000001CE                           576  
000001CE                           577m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           578m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      579m     IFEQ DEBUG
000001CE  1239 00C00003            580m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                581m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     582m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       583m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           584m     ENDC
000001E2                           585m 
000001E2                 FALSE     586m     IFNE DEBUG
000001E2                           587m     ENDC
000001E2                           588m 
000001E2                           589m     ENDM
000001E2                           590m     PRINT_CHAR #0,D1
000001E2                           591m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      592m     IFEQ DEBUG
000001E2  1239 00C00003            593m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                594m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     595m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       596m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           597m     ENDC
000001F6                           598m 
000001F6                 FALSE     599m     IFNE DEBUG
000001F6                           600m     ENDC
000001F6                           601m 
000001F6                           602m     ENDM
000001F6                           603m     PRINT_CHAR #0,D1
000001F6                           604m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      605m     IFEQ DEBUG
000001F6  1239 00C00003            606m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                607m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     608m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       609m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           610m     ENDC
0000020A                           611m 
0000020A                 FALSE     612m     IFNE DEBUG
0000020A                           613m     ENDC
0000020A                           614m 
0000020A                           615m     ENDM
0000020A                           616      
0000020A                           617      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                618s     CMP.W   #$0F,D0
0000020E  6600 0008                619s     BNE _00000000
00000212  1039 00C00005            620          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           621      ENDI
00000218                           622s _00000000
00000218                           623  
00000218  13FC 0001 00E00001       624      MOVE.B #1,DISPLAY
00000220                           625      
00000220                           626m     PRINT_CRLF D1,A0
00000220  41FA 1B10                627m     LEA CRLF(PC),A0
00000224                           628mm     PRINT_STR A0,D1
00000224                           629mm LOOP_5
00000224  0C10 0000                630mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                631mm     BEQ EXIT_5
0000022C                           632mmm     PRINT_CHAR (A0)+,D1
0000022C                           633mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      634mmm     IFEQ DEBUG
0000022C  1239 00C00003            635mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                636mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     637mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            638mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           639mmm     ENDC
0000023E                           640mmm 
0000023E                 FALSE     641mmm     IFNE DEBUG
0000023E                           642mmm     ENDC
0000023E                           643mmm 
0000023E                           644mmm     ENDM
0000023E  60E4                     645mm     BRA LOOP_5
00000240                           646mm EXIT_5
00000240                           647mm     ENDM
00000240                           648m     ENDM
00000240  41FA 1B8D                649      LEA VERSION(PC),A0
00000244                           650m     PRINT_STR A0,D3
00000244                           651m LOOP_7
00000244  0C10 0000                652m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                653m     BEQ EXIT_7
0000024C                           654mm     PRINT_CHAR (A0)+,D3
0000024C                           655mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      656mm     IFEQ DEBUG
0000024C  1639 00C00003            657mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                658mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     659mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            660mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           661mm     ENDC
0000025E                           662mm 
0000025E                 FALSE     663mm     IFNE DEBUG
0000025E                           664mm     ENDC
0000025E                           665mm 
0000025E                           666mm     ENDM
0000025E  60E4                     667m     BRA LOOP_7
00000260                           668m EXIT_7
00000260                           669m     ENDM
00000260                           670  
00000260  41F9 00001DED            671      LEA END,A0
00000266  2008                     672      MOVE.L A0,D0
00000268                           673m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1ACE                674m     LEA OX(PC),A0
0000026C                           675mm     PRINT_STR A0,D1
0000026C                           676mm LOOP_10
0000026C  0C10 0000                677mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                678mm     BEQ EXIT_10
00000274                           679mmm     PRINT_CHAR (A0)+,D1
00000274                           680mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      681mmm     IFEQ DEBUG
00000274  1239 00C00003            682mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                683mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     684mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            685mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           686mmm     ENDC
00000286                           687mmm 
00000286                 FALSE     688mmm     IFNE DEBUG
00000286                           689mmm     ENDC
00000286                           690mmm 
00000286                           691mmm     ENDM
00000286  60E4                     692mm     BRA LOOP_10
00000288                           693mm EXIT_10
00000288                           694mm     ENDM
00000288  7607                     695m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           696m LOOP_9
0000028A                           697mm     BIN2HEX D0,D2,A0
0000028A  41FA 1A6B                698mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     699mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     700mm     MOVE.B D0,D2
00000292  0282 0000000F            701mm     ANDI.L #$F,D2
00000298  1430 2000                702mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           703mm     ENDM
0000029C                           704mm     PRINT_CHAR D2,D1
0000029C                           705mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      706mm     IFEQ DEBUG
0000029C  1239 00C00003            707mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                708mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     709mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            710mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           711mm     ENDC
000002AE                           712mm 
000002AE                 FALSE     713mm     IFNE DEBUG
000002AE                           714mm     ENDC
000002AE                           715mm 
000002AE                           716mm     ENDM
000002AE  57CB FFDA                717m     DBEQ D3,LOOP_9
000002B2                           718m     ENDM
000002B2                           719m     PRINT_CRLF D1,A0
000002B2  41FA 1A7E                720m     LEA CRLF(PC),A0
000002B6                           721mm     PRINT_STR A0,D1
000002B6                           722mm LOOP_15
000002B6  0C10 0000                723mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                724mm     BEQ EXIT_15
000002BE                           725mmm     PRINT_CHAR (A0)+,D1
000002BE                           726mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      727mmm     IFEQ DEBUG
000002BE  1239 00C00003            728mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                729mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     730mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            731mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           732mmm     ENDC
000002D0                           733mmm 
000002D0                 FALSE     734mmm     IFNE DEBUG
000002D0                           735mmm     ENDC
000002D0                           736mmm 
000002D0                           737mmm     ENDM
000002D0  60E4                     738mm     BRA LOOP_15
000002D2                           739mm EXIT_15
000002D2                           740mm     ENDM
000002D2                           741m     ENDM
000002D2                           742  
000002D2  41FA 1856                743      LEA HELPPROMPT(PC),A0
000002D6                           744m     PRINT_STR A0,D3
000002D6                           745m LOOP_17
000002D6  0C10 0000                746m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                747m     BEQ EXIT_17
000002DE                           748mm     PRINT_CHAR (A0)+,D3
000002DE                           749mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      750mm     IFEQ DEBUG
000002DE  1639 00C00003            751mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                752mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     753mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            754mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           755mm     ENDC
000002F0                           756mm 
000002F0                 FALSE     757mm     IFNE DEBUG
000002F0                           758mm     ENDC
000002F0                           759mm 
000002F0                           760mm     ENDM
000002F0  60E4                     761m     BRA LOOP_17
000002F2                           762m EXIT_17
000002F2                           763m     ENDM
000002F2                           764  
000002F2                           765m     PRINT_CRLF D3,A0
000002F2  41FA 1A3E                766m     LEA CRLF(PC),A0
000002F6                           767mm     PRINT_STR A0,D3
000002F6                           768mm LOOP_20
000002F6  0C10 0000                769mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                770mm     BEQ EXIT_20
000002FE                           771mmm     PRINT_CHAR (A0)+,D3
000002FE                           772mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      773mmm     IFEQ DEBUG
000002FE  1639 00C00003            774mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                775mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     776mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            777mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           778mmm     ENDC
00000310                           779mmm 
00000310                 FALSE     780mmm     IFNE DEBUG
00000310                           781mmm     ENDC
00000310                           782mmm 
00000310                           783mmm     ENDM
00000310  60E4                     784mm     BRA LOOP_20
00000312                           785mm EXIT_20
00000312                           786mm     ENDM
00000312                           787m     ENDM
00000312                           788  
00000312  7E00                     789      MOVE.L #0,D7                                    ; address accumulator
00000314                           790  
00000314  13FC 0002 00E00001       791      MOVE.B #2,DISPLAY
0000031C                           792      
0000031C  13FC 0000 00A00001       793      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       794      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       795      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       796      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           797      
0000033C  13FC 0003 00E00001       798      MOVE.B #3,DISPLAY
00000344                           799      
00000344                           800      
00000344                           801  MAIN_LOOP
00000344  41FA 19EF                802      LEA PROMPT(PC),A0
00000348                           803m     PRINT_STR A0,D3
00000348                           804m LOOP_22
00000348  0C10 0000                805m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                806m     BEQ EXIT_22
00000350                           807mm     PRINT_CHAR (A0)+,D3
00000350                           808mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      809mm     IFEQ DEBUG
00000350  1639 00C00003            810mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                811mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     812mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            813mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           814mm     ENDC
00000362                           815mm 
00000362                 FALSE     816mm     IFNE DEBUG
00000362                           817mm     ENDC
00000362                           818mm 
00000362                           819mm     ENDM
00000362  60E4                     820m     BRA LOOP_22
00000364                           821m EXIT_22
00000364                           822m     ENDM
00000364                           823  
00000364                           824  GET_INPUT
00000364                           825m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           826m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      827m     IFEQ DEBUG
00000364  1639 00C00003            828m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                829m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     830m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           831m     ENDC
00000370                           832m 
00000370                           833mm     READ_CHAR D2
00000370                 TRUE      834mm     IFEQ DEBUG
00000370  1439 00C00007            835mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           836mm     ENDC
00000376                 FALSE     837mm     IFNE DEBUG
00000376                           838mm     ENDC
00000376                           839mm 
00000376  B43C 001B                840mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                841mm     BEQ START
0000037E                           842mm     ENDM
0000037E                           843m 
0000037E                 TRUE      844m     IFEQ DEBUG
0000037E                           845mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           846mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      847mm     IFEQ DEBUG
0000037E  1639 00C00003            848mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                849mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     850mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            851mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           852mm     ENDC
00000390                           853mm 
00000390                 FALSE     854mm     IFNE DEBUG
00000390                           855mm     ENDC
00000390                           856mm 
00000390                           857mm     ENDM
00000390                           858m     ENDC
00000390                           859m     ENDM
00000390                           860  
00000390                           861      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                862s     CMP.B   #'0',D2
00000394  6D00 000E                863s     BLT _00000001
00000398  B43C 0039                864s     CMP.B   #'9',D2
0000039C  6E00 0006                865s     BGT _00000001
000003A0  6000 15C0                866          BRA HEX_DIGIT
000003A4                           867      ENDI
000003A4                           868s _00000001
000003A4                           869      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                870s     CMP.B   #'A',D2
000003A8  6D00 000E                871s     BLT _00000002
000003AC  B43C 0046                872s     CMP.B   #'F',D2
000003B0  6E00 0006                873s     BGT _00000002
000003B4  6000 15AC                874          BRA HEX_DIGIT
000003B8                           875      ENDI
000003B8                           876s _00000002
000003B8                           877  
000003B8  B43C 0077                878      CMP.B #'w',D2
000003BC  6700 01B2                879      BEQ W
000003C0                           880  
000003C0  B43C 006C                881      CMP.B #'l',D2
000003C4  6700 0A48                882      BEQ L 
000003C8                           883  
000003C8  B43C 0070                884      CMP.B #'p',D2
000003CC  6700 0D22                885      BEQ P
000003D0                           886  
000003D0                           887m     PRINT_CRLF D3,A0
000003D0  41FA 1960                888m     LEA CRLF(PC),A0
000003D4                           889mm     PRINT_STR A0,D3
000003D4                           890mm LOOP_28
000003D4  0C10 0000                891mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                892mm     BEQ EXIT_28
000003DC                           893mmm     PRINT_CHAR (A0)+,D3
000003DC                           894mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      895mmm     IFEQ DEBUG
000003DC  1639 00C00003            896mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                897mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     898mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            899mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           900mmm     ENDC
000003EE                           901mmm 
000003EE                 FALSE     902mmm     IFNE DEBUG
000003EE                           903mmm     ENDC
000003EE                           904mmm 
000003EE                           905mmm     ENDM
000003EE  60E4                     906mm     BRA LOOP_28
000003F0                           907mm EXIT_28
000003F0                           908mm     ENDM
000003F0                           909m     ENDM
000003F0                           910   
000003F0  B43C 003F                911      CMP.B #'?',D2
000003F4  6700 0076                912      BEQ H
000003F8                           913   
000003F8  B43C 0076                914      CMP.B #'v',D2
000003FC  6700 0076                915      BEQ V
00000400                           916      
00000400  B43C 0072                917      CMP.B #'r',D2
00000404  6700 0092                918      BEQ R
00000408                           919  
00000408  B43C 0073                920      CMP.B #'s',D2
0000040C  6700 01DE                921      BEQ S
00000410                           922  
00000410  B43C 0067                923      CMP.B #'g',D2
00000414  6700 0902                924      BEQ G   
00000418                           925  
00000418  B43C 007A                926      CMP.B #'z',D2
0000041C  6700 0900                927      BEQ Z   
00000420                           928  
00000420  B43C 0078                929      CMP.B #'x',D2
00000424  6700 0E9A                930      BEQ X
00000428                           931  
00000428  B43C 0069                932      CMP.B #'i',D2
0000042C  6700 0FAE                933      BEQ I
00000430                           934  
00000430  B43C 006F                935      CMP.B #'o',D2
00000434  6700 0FB6                936      BEQ O
00000438                           937  
00000438  B43C 0023                938      CMP.B #'#',D2
0000043C  6700 0FBE                939      BEQ HASH
00000440                           940  
00000440  B43C 0062                941      CMP.B #'b',D2
00000444  6700 0FCC                942      BEQ B
00000448                           943  
00000448  41FA 184B                944      LEA HUH(PC),A0
0000044C                           945m     PRINT_STR A0,D3
0000044C                           946m LOOP_30
0000044C  0C10 0000                947m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000450  6700 0016                948m     BEQ EXIT_30
00000454                           949mm     PRINT_CHAR (A0)+,D3
00000454                           950mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000454                 TRUE      951mm     IFEQ DEBUG
00000454  1639 00C00003            952mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000045A  0803 0002                953mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000045E  67F4                     954mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000460  13D8 00C00007            955mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000466                           956mm     ENDC
00000466                           957mm 
00000466                 FALSE     958mm     IFNE DEBUG
00000466                           959mm     ENDC
00000466                           960mm 
00000466                           961mm     ENDM
00000466  60E4                     962m     BRA LOOP_30
00000468                           963m EXIT_30
00000468                           964m     ENDM
00000468                           965  
00000468  6000 FEDA                966      BRA MAIN_LOOP
0000046C                           967  
0000046C                           968  ; commands
0000046C                           969  H
0000046C  41FA 16CF                970      LEA HELP(PC),A0
00000470  6000 0006                971      BRA PRINTIT
00000474                           972  
00000474                           973  V
00000474  41FA 1959                974      LEA VERSION(PC),A0
00000478                           975  PRINTIT
00000478                           976m     PRINT_STR A0,D3    
00000478                           977m LOOP_32
00000478  0C10 0000                978m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000047C  6700 0016                979m     BEQ EXIT_32
00000480                           980mm     PRINT_CHAR (A0)+,D3
00000480                           981mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000480                 TRUE      982mm     IFEQ DEBUG
00000480  1639 00C00003            983mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000486  0803 0002                984mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000048A  67F4                     985mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000048C  13D8 00C00007            986mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000492                           987mm     ENDC
00000492                           988mm 
00000492                 FALSE     989mm     IFNE DEBUG
00000492                           990mm     ENDC
00000492                           991mm 
00000492                           992mm     ENDM
00000492  60E4                     993m     BRA LOOP_32
00000494                           994m EXIT_32
00000494                           995m     ENDM
00000494  6000 FEAE                996      BRA MAIN_LOOP
00000498                           997  
00000498                           998  R
00000498  2047                     999      MOVE.L D7,A0                                    ; address accumulator -> address register
0000049A  7E00                    1000      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000049C  2410                    1001      MOVE.L (A0),D2                                  ; read the memory and print it
0000049E                          1002m     PRINT_REG D2,D3,D4,D5,A0
0000049E  41FA 1898               1003m     LEA OX(PC),A0
000004A2                          1004mm     PRINT_STR A0,D3
000004A2                          1005mm LOOP_35
000004A2  0C10 0000               1006mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004A6  6700 0016               1007mm     BEQ EXIT_35
000004AA                          1008mmm     PRINT_CHAR (A0)+,D3
000004AA                          1009mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AA                 TRUE     1010mmm     IFEQ DEBUG
000004AA  1639 00C00003           1011mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004B0  0803 0002               1012mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004B4  67F4                    1013mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004B6  13D8 00C00007           1014mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004BC                          1015mmm     ENDC
000004BC                          1016mmm 
000004BC                 FALSE    1017mmm     IFNE DEBUG
000004BC                          1018mmm     ENDC
000004BC                          1019mmm 
000004BC                          1020mmm     ENDM
000004BC  60E4                    1021mm     BRA LOOP_35
000004BE                          1022mm EXIT_35
000004BE                          1023mm     ENDM
000004BE  7A07                    1024m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004C0                          1025m LOOP_34
000004C0                          1026mm     BIN2HEX D2,D4,A0
000004C0  41FA 1835               1027mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004C4  E99A                    1028mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004C6  1802                    1029mm     MOVE.B D2,D4
000004C8  0284 0000000F           1030mm     ANDI.L #$F,D4
000004CE  1830 4000               1031mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004D2                          1032mm     ENDM
000004D2                          1033mm     PRINT_CHAR D4,D3
000004D2                          1034mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D2                 TRUE     1035mm     IFEQ DEBUG
000004D2  1639 00C00003           1036mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004D8  0803 0002               1037mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004DC  67F4                    1038mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004DE  13C4 00C00007           1039mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E4                          1040mm     ENDC
000004E4                          1041mm 
000004E4                 FALSE    1042mm     IFNE DEBUG
000004E4                          1043mm     ENDC
000004E4                          1044mm 
000004E4                          1045mm     ENDM
000004E4  57CD FFDA               1046m     DBEQ D5,LOOP_34
000004E8                          1047m     ENDM
000004E8                          1048      
000004E8                          1049m     PRINT_CHAR #32,D3
000004E8                          1050m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E8                 TRUE     1051m     IFEQ DEBUG
000004E8  1639 00C00003           1052m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EE  0803 0002               1053m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F2  67F4                    1054m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004F4  13FC 0020 00C00007      1055m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004FC                          1056m     ENDC
000004FC                          1057m 
000004FC                 FALSE    1058m     IFNE DEBUG
000004FC                          1059m     ENDC
000004FC                          1060m 
000004FC                          1061m     ENDM
000004FC                          1062  
000004FC  E19A                    1063      ROL.L #8,D2
000004FE                          1064m     PRINT_CHAR D2,D3
000004FE                          1065m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FE                 TRUE     1066m     IFEQ DEBUG
000004FE  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000504  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000508  67F4                    1069m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000050A  13C2 00C00007           1070m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000510                          1071m     ENDC
00000510                          1072m 
00000510                 FALSE    1073m     IFNE DEBUG
00000510                          1074m     ENDC
00000510                          1075m 
00000510                          1076m     ENDM
00000510  E19A                    1077      ROL.L #8,D2
00000512                          1078m     PRINT_CHAR D2,D3
00000512                          1079m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1080m     IFEQ DEBUG
00000512  1639 00C00003           1081m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1082m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1083m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1084m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1085m     ENDC
00000524                          1086m 
00000524                 FALSE    1087m     IFNE DEBUG
00000524                          1088m     ENDC
00000524                          1089m 
00000524                          1090m     ENDM
00000524  E19A                    1091      ROL.L #8,D2
00000526                          1092m     PRINT_CHAR D2,D3
00000526                          1093m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1094m     IFEQ DEBUG
00000526  1639 00C00003           1095m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1096m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1097m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1098m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1099m     ENDC
00000538                          1100m 
00000538                 FALSE    1101m     IFNE DEBUG
00000538                          1102m     ENDC
00000538                          1103m 
00000538                          1104m     ENDM
00000538  E19A                    1105      ROL.L #8,D2
0000053A                          1106m     PRINT_CHAR D2,D3
0000053A                          1107m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1108m     IFEQ DEBUG
0000053A  1639 00C00003           1109m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1110m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1111m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1112m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1113m     ENDC
0000054C                          1114m 
0000054C                 FALSE    1115m     IFNE DEBUG
0000054C                          1116m     ENDC
0000054C                          1117m 
0000054C                          1118m     ENDM
0000054C                          1119  
0000054C                          1120m     PRINT_CRLF D3,A0
0000054C  41FA 17E4               1121m     LEA CRLF(PC),A0
00000550                          1122mm     PRINT_STR A0,D3
00000550                          1123mm LOOP_45
00000550  0C10 0000               1124mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000554  6700 0016               1125mm     BEQ EXIT_45
00000558                          1126mmm     PRINT_CHAR (A0)+,D3
00000558                          1127mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000558                 TRUE     1128mmm     IFEQ DEBUG
00000558  1639 00C00003           1129mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000055E  0803 0002               1130mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000562  67F4                    1131mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000564  13D8 00C00007           1132mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000056A                          1133mmm     ENDC
0000056A                          1134mmm 
0000056A                 FALSE    1135mmm     IFNE DEBUG
0000056A                          1136mmm     ENDC
0000056A                          1137mmm 
0000056A                          1138mmm     ENDM
0000056A  60E4                    1139mm     BRA LOOP_45
0000056C                          1140mm EXIT_45
0000056C                          1141mm     ENDM
0000056C                          1142m     ENDM
0000056C                          1143      
0000056C  6000 FDD6               1144      BRA MAIN_LOOP
00000570                          1145  
00000570                          1146  W
00000570                          1147      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000570  3C3C 0000               1148s     MOVE.W  #0,D6
00000574  6000 0046               1149s     BRA _20000005
00000578                          1150s _20000004
00000578  E98D                    1151          LSL.L #4,D5                                     ; make what we have so far more significant
0000057A                          1152m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000057A                          1153m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000057A                 TRUE     1154m     IFEQ DEBUG
0000057A  1639 00C00003           1155m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000580  0803 0000               1156m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000584  67F4                    1157m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000586                          1158m     ENDC
00000586                          1159m 
00000586                          1160mm     READ_CHAR D2
00000586                 TRUE     1161mm     IFEQ DEBUG
00000586  1439 00C00007           1162mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000058C                          1163mm     ENDC
0000058C                 FALSE    1164mm     IFNE DEBUG
0000058C                          1165mm     ENDC
0000058C                          1166mm 
0000058C  B43C 001B               1167mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000590  6700 FB72               1168mm     BEQ START
00000594                          1169mm     ENDM
00000594                          1170m 
00000594                 TRUE     1171m     IFEQ DEBUG
00000594                          1172mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000594                          1173mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                 TRUE     1174mm     IFEQ DEBUG
00000594  1639 00C00003           1175mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000059A  0803 0002               1176mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000059E  67F4                    1177mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005A0  13C2 00C00007           1178mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A6                          1179mm     ENDC
000005A6                          1180mm 
000005A6                 FALSE    1181mm     IFNE DEBUG
000005A6                          1182mm     ENDC
000005A6                          1183mm 
000005A6                          1184mm     ENDM
000005A6                          1185m     ENDC
000005A6                          1186m     ENDM
000005A6                          1187m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005A6  41FA 175F               1188m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005AA  0402 0030               1189m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005AE  C4BC 000000FF           1190m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005B4  1430 2000               1191m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B8                          1192m     ENDM
000005B8  8A02                    1193          OR.B D2,D5
000005BA                          1194      ENDF
000005BA  5246                    1195s     ADD.W   #1,D6
000005BC                          1196s _20000005
000005BC  BC7C 0007               1197s     CMP.W   #7,D6
000005C0  6FB6                    1198s     BLE _20000004
000005C2                          1199  
000005C2                          1200m     PRINT_CRLF D3,A0
000005C2  41FA 176E               1201m     LEA CRLF(PC),A0
000005C6                          1202mm     PRINT_STR A0,D3
000005C6                          1203mm LOOP_52
000005C6  0C10 0000               1204mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005CA  6700 0016               1205mm     BEQ EXIT_52
000005CE                          1206mmm     PRINT_CHAR (A0)+,D3
000005CE                          1207mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                 TRUE     1208mmm     IFEQ DEBUG
000005CE  1639 00C00003           1209mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005D4  0803 0002               1210mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005D8  67F4                    1211mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005DA  13D8 00C00007           1212mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005E0                          1213mmm     ENDC
000005E0                          1214mmm 
000005E0                 FALSE    1215mmm     IFNE DEBUG
000005E0                          1216mmm     ENDC
000005E0                          1217mmm 
000005E0                          1218mmm     ENDM
000005E0  60E4                    1219mm     BRA LOOP_52
000005E2                          1220mm EXIT_52
000005E2                          1221mm     ENDM
000005E2                          1222m     ENDM
000005E2                          1223  
000005E2  2047                    1224      MOVE.L D7,A0                                    ; address accumulator -> address register
000005E4  7E00                    1225      MOVE.L #0,D7                                    ; clear the now used address accumulator
000005E6                          1226  
000005E6  2085                    1227      MOVE.L D5,(A0)                                  ; write the data
000005E8                          1228  
000005E8  6000 FD5A               1229      BRA MAIN_LOOP
000005EC                          1230  
000005EC                          1231  ; register map for S
000005EC                          1232  ; A0 - start address
000005EC                          1233  ; A1 - offset
000005EC                          1234  ; A2 - next address to write
000005EC                          1235  ; A3 - next location (jmp)
000005EC                          1236  ; A4 - Working Address Register
000005EC                          1237  ; D0 - record count
000005EC                          1238  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005EC                          1239  ; D2 - checksum
000005EC                          1240  ; D3 - data byte count
000005EC                          1241  ; D4 - read address, moved into A2
000005EC                          1242  ; D5 - temp
000005EC                          1243  ; D6 - temp
000005EC                          1244  ; D7 - temp
000005EC                          1245  S
000005EC  2078 0000               1246      MOVE.L 0,A0                                     ; start address -> A0
000005F0  2247                    1247      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005F2                          1248      
000005F2  7000                    1249      MOVE.L #0,D0                                    ; count of records read -> D0
000005F4                          1250          
000005F4                          1251  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005F4                          1252m     DOWNLOAD D1
000005F4                          1253m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F4                          1254m 
000005F4  1239 00C00003           1255m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005FA  0801 0000               1256m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005FE  6700 0010               1257m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000602                          1258m 
00000602                          1259mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000602                 TRUE     1260mm     IFEQ DEBUG
00000602  1239 00C00007           1261mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000608                          1262mm     ENDC
00000608                 FALSE    1263mm     IFNE DEBUG
00000608                          1264mm     ENDC
00000608                          1265mm 
00000608  B23C 001B               1266mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000060C  6700 FAF6               1267mm     BEQ START
00000610                          1268mm     ENDM
00000610                          1269m CONTINUE_54
00000610  1239 00C00013           1270m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000616  0801 0000               1271m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061A  67D8                    1272m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
0000061C                          1273m     
0000061C  1239 00C00017           1274m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000622  13C1 00E00001           1275m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000628                          1276m 
00000628                          1277m     ENDM
00000628  B23C 0053               1278      CMP.B #'S',D1                                   ; found S?
0000062C  66C6                    1279      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000062E                          1280      
0000062E                          1281m     PRINT_CHAR #'S',D5                              ; print the S
0000062E                          1282m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                 TRUE     1283m     IFEQ DEBUG
0000062E  1A39 00C00003           1284m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000634  0805 0002               1285m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000638  67F4                    1286m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000063A  13FC 0053 00C00007      1287m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000642                          1288m     ENDC
00000642                          1289m 
00000642                 FALSE    1290m     IFNE DEBUG
00000642                          1291m     ENDC
00000642                          1292m 
00000642                          1293m     ENDM
00000642  5280                    1294      ADD.L #1,D0                                     ; read another S record, increment count
00000644                          1295      
00000644                          1296m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000644                          1297m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000644                          1298m 
00000644  1239 00C00003           1299m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000064A  0801 0000               1300m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000064E  6700 0010               1301m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000652                          1302m 
00000652                          1303mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000652                 TRUE     1304mm     IFEQ DEBUG
00000652  1239 00C00007           1305mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000658                          1306mm     ENDC
00000658                 FALSE    1307mm     IFNE DEBUG
00000658                          1308mm     ENDC
00000658                          1309mm 
00000658  B23C 001B               1310mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000065C  6700 FAA6               1311mm     BEQ START
00000660                          1312mm     ENDM
00000660                          1313m CONTINUE_57
00000660  1239 00C00013           1314m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000666  0801 0000               1315m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000066A  67D8                    1316m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000066C                          1317m     
0000066C  1239 00C00017           1318m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000672  13C1 00E00001           1319m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000678                          1320m 
00000678                          1321m     ENDM
00000678                          1322m     PRINT_CHAR D1,D5
00000678                          1323m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000678                 TRUE     1324m     IFEQ DEBUG
00000678  1A39 00C00003           1325m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000067E  0805 0002               1326m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000682  67F4                    1327m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000684  13C1 00C00007           1328m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000068A                          1329m     ENDC
0000068A                          1330m 
0000068A                 FALSE    1331m     IFNE DEBUG
0000068A                          1332m     ENDC
0000068A                          1333m 
0000068A                          1334m     ENDM
0000068A                          1335  
0000068A  7400                    1336      MOVE.L #0,D2                                    ; clear the checksum
0000068C                          1337  
0000068C                          1338m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000068C  1E3C 0002               1339m     MOVE.B #2,D7
00000690                          1340m     WHILE.B D7 <GT> 0 DO
00000690                          1341ms _10000000
00000690  BE38 0000               1342ms     CMP.B   0,D7
00000694  6F00 0062               1343ms     BLE _10000001
00000698  E98B                    1344m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000069A                          1345mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000069A                          1346mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069A                          1347mm 
0000069A  1A39 00C00003           1348mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006A0  0805 0000               1349mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006A4  6700 0010               1350mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
000006A8                          1351mm 
000006A8                          1352mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006A8                 TRUE     1353mmm     IFEQ DEBUG
000006A8  1A39 00C00007           1354mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006AE                          1355mmm     ENDC
000006AE                 FALSE    1356mmm     IFNE DEBUG
000006AE                          1357mmm     ENDC
000006AE                          1358mmm 
000006AE  BA3C 001B               1359mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006B2  6700 FA50               1360mmm     BEQ START
000006B6                          1361mmm     ENDM
000006B6                          1362mm CONTINUE_61
000006B6  1A39 00C00013           1363mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006BC  0805 0000               1364mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C0  67D8                    1365mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000006C2                          1366mm     
000006C2  1A39 00C00017           1367mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006C8  13C5 00E00001           1368mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006CE                          1369mm 
000006CE                          1370mm     ENDM
000006CE                          1371mm         PRINT_CHAR D5,D6
000006CE                          1372mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006CE                 TRUE     1373mm     IFEQ DEBUG
000006CE  1C39 00C00003           1374mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006D4  0806 0002               1375mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006D8  67F4                    1376mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006DA  13C5 00C00007           1377mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006E0                          1378mm     ENDC
000006E0                          1379mm 
000006E0                 FALSE    1380mm     IFNE DEBUG
000006E0                          1381mm     ENDC
000006E0                          1382mm 
000006E0                          1383mm     ENDM
000006E0                          1384mm         HEX2BIN D5,D5,A4
000006E0  49FA 1625               1385mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006E4  0405 0030               1386mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006E8  CABC 000000FF           1387mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006EE  1A34 5000               1388mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006F2                          1389mm     ENDM
000006F2  8605                    1390m         OR.B D5,D3
000006F4  5307                    1391m         SUB.B #1,D7
000006F6                          1392m     ENDW
000006F6  6098                    1393ms     BRA _10000000
000006F8                          1394ms _10000001
000006F8                          1395m 
000006F8  7A00                    1396m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006FA  1A03                    1397m     MOVE.B D3,D5
000006FC  D483                    1398m     ADD.L D3,D2
000006FE                          1399m 
000006FE                          1400m     ENDM
000006FE                          1401  
000006FE                          1402      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006FE  B23C 0030               1403s     CMP.B   #'0',D1
00000702  6600 002A               1404s     BNE.L   _00000003
00000706                          1405m         PRINT_CRLF D5,A4
00000706  49FA 162A               1406m     LEA CRLF(PC),A4
0000070A                          1407mm     PRINT_STR A4,D5
0000070A                          1408mm LOOP_66
0000070A  0C14 0000               1409mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000070E  6700 0016               1410mm     BEQ EXIT_66
00000712                          1411mmm     PRINT_CHAR (A4)+,D5
00000712                          1412mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                 TRUE     1413mmm     IFEQ DEBUG
00000712  1A39 00C00003           1414mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000718  0805 0002               1415mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000071C  67F4                    1416mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
0000071E  13DC 00C00007           1417mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000724                          1418mmm     ENDC
00000724                          1419mmm 
00000724                 FALSE    1420mmm     IFNE DEBUG
00000724                          1421mmm     ENDC
00000724                          1422mmm 
00000724                          1423mmm     ENDM
00000724  60E4                    1424mm     BRA LOOP_66
00000726                          1425mm EXIT_66
00000726                          1426mm     ENDM
00000726                          1427m     ENDM
00000726  6000 FECC               1428          BRA WAIT_FOR_SRECORD
0000072A                          1429      ELSE
0000072A  6000 03DE               1430s     BRA _00000004
0000072E                          1431s _00000003
0000072E                          1432          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
0000072E  B23C 0031               1433s     CMP.B   #'1',D1
00000732  6708                    1434s     BEQ.S   _00000005
00000734  B23C 0032               1435s     CMP.B   #'2',D1
00000738  6600 01F0               1436s     BNE.L   _00000006
0000073C                          1437s _00000005
0000073C  5783                    1438              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000073E                          1439  
0000073E  7800                    1440              MOVE.L #0,D4                            ; read two bytes of address
00000740                          1441m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000740  1E3C 0002               1442m     MOVE.B #2,D7
00000744                          1443m     WHILE.B D7 <GT> 0 DO
00000744                          1444ms _10000002
00000744  BE38 0000               1445ms     CMP.B   0,D7
00000748  6F00 0062               1446ms     BLE _10000003
0000074C  E98C                    1447m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000074E                          1448mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000074E                          1449mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000074E                          1450mm 
0000074E  1A39 00C00003           1451mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000754  0805 0000               1452mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000758  6700 0010               1453mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
0000075C                          1454mm 
0000075C                          1455mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075C                 TRUE     1456mmm     IFEQ DEBUG
0000075C  1A39 00C00007           1457mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000762                          1458mmm     ENDC
00000762                 FALSE    1459mmm     IFNE DEBUG
00000762                          1460mmm     ENDC
00000762                          1461mmm 
00000762  BA3C 001B               1462mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000766  6700 F99C               1463mmm     BEQ START
0000076A                          1464mmm     ENDM
0000076A                          1465mm CONTINUE_69
0000076A  1A39 00C00013           1466mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000770  0805 0000               1467mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000774  67D8                    1468mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000776                          1469mm     
00000776  1A39 00C00017           1470mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000077C  13C5 00E00001           1471mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000782                          1472mm 
00000782                          1473mm     ENDM
00000782                          1474mm         PRINT_CHAR D5,D6
00000782                          1475mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000782                 TRUE     1476mm     IFEQ DEBUG
00000782  1C39 00C00003           1477mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000788  0806 0002               1478mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000078C  67F4                    1479mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000078E  13C5 00C00007           1480mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000794                          1481mm     ENDC
00000794                          1482mm 
00000794                 FALSE    1483mm     IFNE DEBUG
00000794                          1484mm     ENDC
00000794                          1485mm 
00000794                          1486mm     ENDM
00000794                          1487mm         HEX2BIN D5,D5,A4
00000794  49FA 1571               1488mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000798  0405 0030               1489mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000079C  CABC 000000FF           1490mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007A2  1A34 5000               1491mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007A6                          1492mm     ENDM
000007A6  8805                    1493m         OR.B D5,D4
000007A8  5307                    1494m         SUB.B #1,D7
000007AA                          1495m     ENDW
000007AA  6098                    1496ms     BRA _10000002
000007AC                          1497ms _10000003
000007AC                          1498m 
000007AC  7A00                    1499m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007AE  1A04                    1500m     MOVE.B D4,D5
000007B0  D484                    1501m     ADD.L D4,D2
000007B2                          1502m 
000007B2                          1503m     ENDM
000007B2                          1504m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000007B2  1E3C 0002               1505m     MOVE.B #2,D7
000007B6                          1506m     WHILE.B D7 <GT> 0 DO
000007B6                          1507ms _10000004
000007B6  BE38 0000               1508ms     CMP.B   0,D7
000007BA  6F00 0062               1509ms     BLE _10000005
000007BE  E98C                    1510m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007C0                          1511mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007C0                          1512mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C0                          1513mm 
000007C0  1A39 00C00003           1514mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007C6  0805 0000               1515mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CA  6700 0010               1516mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
000007CE                          1517mm 
000007CE                          1518mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007CE                 TRUE     1519mmm     IFEQ DEBUG
000007CE  1A39 00C00007           1520mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007D4                          1521mmm     ENDC
000007D4                 FALSE    1522mmm     IFNE DEBUG
000007D4                          1523mmm     ENDC
000007D4                          1524mmm 
000007D4  BA3C 001B               1525mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007D8  6700 F92A               1526mmm     BEQ START
000007DC                          1527mmm     ENDM
000007DC                          1528mm CONTINUE_74
000007DC  1A39 00C00013           1529mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E2  0805 0000               1530mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E6  67D8                    1531mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000007E8                          1532mm     
000007E8  1A39 00C00017           1533mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007EE  13C5 00E00001           1534mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007F4                          1535mm 
000007F4                          1536mm     ENDM
000007F4                          1537mm         PRINT_CHAR D5,D6
000007F4                          1538mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F4                 TRUE     1539mm     IFEQ DEBUG
000007F4  1C39 00C00003           1540mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007FA  0806 0002               1541mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007FE  67F4                    1542mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
00000800  13C5 00C00007           1543mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000806                          1544mm     ENDC
00000806                          1545mm 
00000806                 FALSE    1546mm     IFNE DEBUG
00000806                          1547mm     ENDC
00000806                          1548mm 
00000806                          1549mm     ENDM
00000806                          1550mm         HEX2BIN D5,D5,A4
00000806  49FA 14FF               1551mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000080A  0405 0030               1552mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000080E  CABC 000000FF           1553mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000814  1A34 5000               1554mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000818                          1555mm     ENDM
00000818  8805                    1556m         OR.B D5,D4
0000081A  5307                    1557m         SUB.B #1,D7
0000081C                          1558m     ENDW
0000081C  6098                    1559ms     BRA _10000004
0000081E                          1560ms _10000005
0000081E                          1561m 
0000081E  7A00                    1562m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000820  1A04                    1563m     MOVE.B D4,D5
00000822  D484                    1564m     ADD.L D4,D2
00000824                          1565m 
00000824                          1566m     ENDM
00000824                          1567  
00000824                          1568              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000824  B23C 0032               1569s     CMP.B   #'2',D1
00000828  6600 0076               1570s     BNE.L   _00000007
0000082C  5383                    1571                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000082E                          1572m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000082E  1E3C 0002               1573m     MOVE.B #2,D7
00000832                          1574m     WHILE.B D7 <GT> 0 DO
00000832                          1575ms _10000006
00000832  BE38 0000               1576ms     CMP.B   0,D7
00000836  6F00 0062               1577ms     BLE _10000007
0000083A  E98C                    1578m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000083C                          1579mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000083C                          1580mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083C                          1581mm 
0000083C  1A39 00C00003           1582mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000842  0805 0000               1583mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000846  6700 0010               1584mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000084A                          1585mm 
0000084A                          1586mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                 TRUE     1587mmm     IFEQ DEBUG
0000084A  1A39 00C00007           1588mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000850                          1589mmm     ENDC
00000850                 FALSE    1590mmm     IFNE DEBUG
00000850                          1591mmm     ENDC
00000850                          1592mmm 
00000850  BA3C 001B               1593mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000854  6700 F8AE               1594mmm     BEQ START
00000858                          1595mmm     ENDM
00000858                          1596mm CONTINUE_79
00000858  1A39 00C00013           1597mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000085E  0805 0000               1598mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000862  67D8                    1599mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000864                          1600mm     
00000864  1A39 00C00017           1601mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000086A  13C5 00E00001           1602mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000870                          1603mm 
00000870                          1604mm     ENDM
00000870                          1605mm         PRINT_CHAR D5,D6
00000870                          1606mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1607mm     IFEQ DEBUG
00000870  1C39 00C00003           1608mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000876  0806 0002               1609mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1610mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
0000087C  13C5 00C00007           1611mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000882                          1612mm     ENDC
00000882                          1613mm 
00000882                 FALSE    1614mm     IFNE DEBUG
00000882                          1615mm     ENDC
00000882                          1616mm 
00000882                          1617mm     ENDM
00000882                          1618mm         HEX2BIN D5,D5,A4
00000882  49FA 1483               1619mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000886  0405 0030               1620mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000088A  CABC 000000FF           1621mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000890  1A34 5000               1622mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000894                          1623mm     ENDM
00000894  8805                    1624m         OR.B D5,D4
00000896  5307                    1625m         SUB.B #1,D7
00000898                          1626m     ENDW
00000898  6098                    1627ms     BRA _10000006
0000089A                          1628ms _10000007
0000089A                          1629m 
0000089A  7A00                    1630m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000089C  1A04                    1631m     MOVE.B D4,D5
0000089E  D484                    1632m     ADD.L D4,D2
000008A0                          1633m 
000008A0                          1634m     ENDM
000008A0                          1635              ENDI
000008A0                          1636s _00000007
000008A0                          1637  
000008A0  2444                    1638              MOVE.L D4,A2                            ; put the address in an address register
000008A2  D5C9                    1639              ADD.L A1,A2                             ; add in the offset
000008A4                          1640  
000008A4                          1641              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000008A4                          1642s _10000008
000008A4  B63C 0000               1643s     CMP.B   #0,D3
000008A8  6F00 007A               1644s     BLE _10000009
000008AC                          1645m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000008AC  1E3C 0002               1646m     MOVE.B #2,D7
000008B0                          1647m     WHILE.B D7 <GT> 0 DO
000008B0                          1648ms _1000000A
000008B0  BE38 0000               1649ms     CMP.B   0,D7
000008B4  6F00 0062               1650ms     BLE _1000000B
000008B8  E989                    1651m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000008BA                          1652mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008BA                          1653mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BA                          1654mm 
000008BA  1A39 00C00003           1655mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008C0  0805 0000               1656mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C4  6700 0010               1657mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
000008C8                          1658mm 
000008C8                          1659mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008C8                 TRUE     1660mmm     IFEQ DEBUG
000008C8  1A39 00C00007           1661mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008CE                          1662mmm     ENDC
000008CE                 FALSE    1663mmm     IFNE DEBUG
000008CE                          1664mmm     ENDC
000008CE                          1665mmm 
000008CE  BA3C 001B               1666mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008D2  6700 F830               1667mmm     BEQ START
000008D6                          1668mmm     ENDM
000008D6                          1669mm CONTINUE_84
000008D6  1A39 00C00013           1670mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DC  0805 0000               1671mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E0  67D8                    1672mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000008E2                          1673mm     
000008E2  1A39 00C00017           1674mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008E8  13C5 00E00001           1675mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008EE                          1676mm 
000008EE                          1677mm     ENDM
000008EE                          1678mm         PRINT_CHAR D5,D6
000008EE                          1679mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EE                 TRUE     1680mm     IFEQ DEBUG
000008EE  1C39 00C00003           1681mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008F4  0806 0002               1682mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008F8  67F4                    1683mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
000008FA  13C5 00C00007           1684mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000900                          1685mm     ENDC
00000900                          1686mm 
00000900                 FALSE    1687mm     IFNE DEBUG
00000900                          1688mm     ENDC
00000900                          1689mm 
00000900                          1690mm     ENDM
00000900                          1691mm         HEX2BIN D5,D5,A4
00000900  49FA 1405               1692mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000904  0405 0030               1693mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000908  CABC 000000FF           1694mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000090E  1A34 5000               1695mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000912                          1696mm     ENDM
00000912  8205                    1697m         OR.B D5,D1
00000914  5307                    1698m         SUB.B #1,D7
00000916                          1699m     ENDW
00000916  6098                    1700ms     BRA _1000000A
00000918                          1701ms _1000000B
00000918                          1702m 
00000918  7A00                    1703m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000091A  1A01                    1704m     MOVE.B D1,D5
0000091C  D481                    1705m     ADD.L D1,D2
0000091E                          1706m 
0000091E                          1707m     ENDM
0000091E                          1708   
0000091E  14C1                    1709                  MOVE.B D1,(A2)+                     ; store it!
00000920                          1710  
00000920  5303                    1711                  SUB.B #1,D3                         ; 1 less byte to go
00000922                          1712              ENDW
00000922  6080                    1713s     BRA _10000008
00000924                          1714s _10000009
00000924                          1715  
00000924  7200                    1716              MOVE.L #0,D1                            ; not done yet
00000926                          1717          ELSE
00000926  6000 01E2               1718s     BRA _00000008
0000092A                          1719s _00000006
0000092A                          1720              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
0000092A  B23C 0038               1721s     CMP.B   #'8',D1
0000092E  6600 0164               1722s     BNE.L   _00000009
00000932  7800                    1723                  MOVE.L #0,D4                        ; read the 24 bit start address
00000934                          1724m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000934  1E3C 0002               1725m     MOVE.B #2,D7
00000938                          1726m     WHILE.B D7 <GT> 0 DO
00000938                          1727ms _1000000C
00000938  BE38 0000               1728ms     CMP.B   0,D7
0000093C  6F00 0062               1729ms     BLE _1000000D
00000940  E98C                    1730m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000942                          1731mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000942                          1732mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000942                          1733mm 
00000942  1A39 00C00003           1734mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000948  0805 0000               1735mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000094C  6700 0010               1736mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000950                          1737mm 
00000950                          1738mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000950                 TRUE     1739mmm     IFEQ DEBUG
00000950  1A39 00C00007           1740mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000956                          1741mmm     ENDC
00000956                 FALSE    1742mmm     IFNE DEBUG
00000956                          1743mmm     ENDC
00000956                          1744mmm 
00000956  BA3C 001B               1745mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000095A  6700 F7A8               1746mmm     BEQ START
0000095E                          1747mmm     ENDM
0000095E                          1748mm CONTINUE_89
0000095E  1A39 00C00013           1749mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000964  0805 0000               1750mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000968  67D8                    1751mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
0000096A                          1752mm     
0000096A  1A39 00C00017           1753mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000970  13C5 00E00001           1754mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000976                          1755mm 
00000976                          1756mm     ENDM
00000976                          1757mm         PRINT_CHAR D5,D6
00000976                          1758mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000976                 TRUE     1759mm     IFEQ DEBUG
00000976  1C39 00C00003           1760mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000097C  0806 0002               1761mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000980  67F4                    1762mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000982  13C5 00C00007           1763mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000988                          1764mm     ENDC
00000988                          1765mm 
00000988                 FALSE    1766mm     IFNE DEBUG
00000988                          1767mm     ENDC
00000988                          1768mm 
00000988                          1769mm     ENDM
00000988                          1770mm         HEX2BIN D5,D5,A4
00000988  49FA 137D               1771mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000098C  0405 0030               1772mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000990  CABC 000000FF           1773mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000996  1A34 5000               1774mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000099A                          1775mm     ENDM
0000099A  8805                    1776m         OR.B D5,D4
0000099C  5307                    1777m         SUB.B #1,D7
0000099E                          1778m     ENDW
0000099E  6098                    1779ms     BRA _1000000C
000009A0                          1780ms _1000000D
000009A0                          1781m 
000009A0  7A00                    1782m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009A2  1A04                    1783m     MOVE.B D4,D5
000009A4  D484                    1784m     ADD.L D4,D2
000009A6                          1785m 
000009A6                          1786m     ENDM
000009A6                          1787m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000009A6  1E3C 0002               1788m     MOVE.B #2,D7
000009AA                          1789m     WHILE.B D7 <GT> 0 DO
000009AA                          1790ms _1000000E
000009AA  BE38 0000               1791ms     CMP.B   0,D7
000009AE  6F00 0062               1792ms     BLE _1000000F
000009B2  E98C                    1793m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B4                          1794mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B4                          1795mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B4                          1796mm 
000009B4  1A39 00C00003           1797mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009BA  0805 0000               1798mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009BE  6700 0010               1799mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
000009C2                          1800mm 
000009C2                          1801mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C2                 TRUE     1802mmm     IFEQ DEBUG
000009C2  1A39 00C00007           1803mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C8                          1804mmm     ENDC
000009C8                 FALSE    1805mmm     IFNE DEBUG
000009C8                          1806mmm     ENDC
000009C8                          1807mmm 
000009C8  BA3C 001B               1808mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CC  6700 F736               1809mmm     BEQ START
000009D0                          1810mmm     ENDM
000009D0                          1811mm CONTINUE_94
000009D0  1A39 00C00013           1812mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D6  0805 0000               1813mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009DA  67D8                    1814mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
000009DC                          1815mm     
000009DC  1A39 00C00017           1816mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E2  13C5 00E00001           1817mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E8                          1818mm 
000009E8                          1819mm     ENDM
000009E8                          1820mm         PRINT_CHAR D5,D6
000009E8                          1821mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E8                 TRUE     1822mm     IFEQ DEBUG
000009E8  1C39 00C00003           1823mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009EE  0806 0002               1824mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F2  67F4                    1825mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000009F4  13C5 00C00007           1826mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009FA                          1827mm     ENDC
000009FA                          1828mm 
000009FA                 FALSE    1829mm     IFNE DEBUG
000009FA                          1830mm     ENDC
000009FA                          1831mm 
000009FA                          1832mm     ENDM
000009FA                          1833mm         HEX2BIN D5,D5,A4
000009FA  49FA 130B               1834mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009FE  0405 0030               1835mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A02  CABC 000000FF           1836mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A08  1A34 5000               1837mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0C                          1838mm     ENDM
00000A0C  8805                    1839m         OR.B D5,D4
00000A0E  5307                    1840m         SUB.B #1,D7
00000A10                          1841m     ENDW
00000A10  6098                    1842ms     BRA _1000000E
00000A12                          1843ms _1000000F
00000A12                          1844m 
00000A12  7A00                    1845m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A14  1A04                    1846m     MOVE.B D4,D5
00000A16  D484                    1847m     ADD.L D4,D2
00000A18                          1848m 
00000A18                          1849m     ENDM
00000A18                          1850m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000A18  1E3C 0002               1851m     MOVE.B #2,D7
00000A1C                          1852m     WHILE.B D7 <GT> 0 DO
00000A1C                          1853ms _10000010
00000A1C  BE38 0000               1854ms     CMP.B   0,D7
00000A20  6F00 0062               1855ms     BLE _10000011
00000A24  E98C                    1856m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A26                          1857mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A26                          1858mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                          1859mm 
00000A26  1A39 00C00003           1860mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A2C  0805 0000               1861mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A30  6700 0010               1862mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000A34                          1863mm 
00000A34                          1864mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A34                 TRUE     1865mmm     IFEQ DEBUG
00000A34  1A39 00C00007           1866mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A3A                          1867mmm     ENDC
00000A3A                 FALSE    1868mmm     IFNE DEBUG
00000A3A                          1869mmm     ENDC
00000A3A                          1870mmm 
00000A3A  BA3C 001B               1871mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A3E  6700 F6C4               1872mmm     BEQ START
00000A42                          1873mmm     ENDM
00000A42                          1874mm CONTINUE_99
00000A42  1A39 00C00013           1875mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A48  0805 0000               1876mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A4C  67D8                    1877mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000A4E                          1878mm     
00000A4E  1A39 00C00017           1879mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A54  13C5 00E00001           1880mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A5A                          1881mm 
00000A5A                          1882mm     ENDM
00000A5A                          1883mm         PRINT_CHAR D5,D6
00000A5A                          1884mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5A                 TRUE     1885mm     IFEQ DEBUG
00000A5A  1C39 00C00003           1886mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A60  0806 0002               1887mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A64  67F4                    1888mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000A66  13C5 00C00007           1889mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A6C                          1890mm     ENDC
00000A6C                          1891mm 
00000A6C                 FALSE    1892mm     IFNE DEBUG
00000A6C                          1893mm     ENDC
00000A6C                          1894mm 
00000A6C                          1895mm     ENDM
00000A6C                          1896mm         HEX2BIN D5,D5,A4
00000A6C  49FA 1299               1897mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A70  0405 0030               1898mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A74  CABC 000000FF           1899mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A7A  1A34 5000               1900mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A7E                          1901mm     ENDM
00000A7E  8805                    1902m         OR.B D5,D4
00000A80  5307                    1903m         SUB.B #1,D7
00000A82                          1904m     ENDW
00000A82  6098                    1905ms     BRA _10000010
00000A84                          1906ms _10000011
00000A84                          1907m 
00000A84  7A00                    1908m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A86  1A04                    1909m     MOVE.B D4,D5
00000A88  D484                    1910m     ADD.L D4,D2
00000A8A                          1911m 
00000A8A                          1912m     ENDM
00000A8A                          1913  
00000A8A  2044                    1914                  MOVE.L D4,A0                        ; start address -> A0
00000A8C  D1C9                    1915                  ADD.L A1,A0                         ; add in the offset
00000A8E                          1916  
00000A8E  72FF                    1917                  MOVE.L #$FFFFFFFF,D1                ; done
00000A90                          1918              ELSE
00000A90  6000 0078               1919s     BRA _0000000A
00000A94                          1920s _00000009
00000A94                          1921m                 PRINT_CRLF D5,A4
00000A94  49FA 129C               1922m     LEA CRLF(PC),A4
00000A98                          1923mm     PRINT_STR A4,D5
00000A98                          1924mm LOOP_104
00000A98  0C14 0000               1925mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A9C  6700 0016               1926mm     BEQ EXIT_104
00000AA0                          1927mmm     PRINT_CHAR (A4)+,D5
00000AA0                          1928mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA0                 TRUE     1929mmm     IFEQ DEBUG
00000AA0  1A39 00C00003           1930mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA6  0805 0002               1931mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAA  67F4                    1932mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000AAC  13DC 00C00007           1933mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AB2                          1934mmm     ENDC
00000AB2                          1935mmm 
00000AB2                 FALSE    1936mmm     IFNE DEBUG
00000AB2                          1937mmm     ENDC
00000AB2                          1938mmm 
00000AB2                          1939mmm     ENDM
00000AB2  60E4                    1940mm     BRA LOOP_104
00000AB4                          1941mm EXIT_104
00000AB4                          1942mm     ENDM
00000AB4                          1943m     ENDM
00000AB4                          1944  
00000AB4  49FA 1208               1945                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000AB8                          1946m                 PRINT_STR A4,D5
00000AB8                          1947m LOOP_106
00000AB8  0C14 0000               1948m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ABC  6700 0016               1949m     BEQ EXIT_106
00000AC0                          1950mm     PRINT_CHAR (A4)+,D5
00000AC0                          1951mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC0                 TRUE     1952mm     IFEQ DEBUG
00000AC0  1A39 00C00003           1953mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC6  0805 0002               1954mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACA  67F4                    1955mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000ACC  13DC 00C00007           1956mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD2                          1957mm     ENDC
00000AD2                          1958mm 
00000AD2                 FALSE    1959mm     IFNE DEBUG
00000AD2                          1960mm     ENDC
00000AD2                          1961mm 
00000AD2                          1962mm     ENDM
00000AD2  60E4                    1963m     BRA LOOP_106
00000AD4                          1964m EXIT_106
00000AD4                          1965m     ENDM
00000AD4                          1966m                 PRINT_CHAR D1,D5
00000AD4                          1967m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD4                 TRUE     1968m     IFEQ DEBUG
00000AD4  1A39 00C00003           1969m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ADA  0805 0002               1970m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ADE  67F4                    1971m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AE0  13C1 00C00007           1972m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AE6                          1973m     ENDC
00000AE6                          1974m 
00000AE6                 FALSE    1975m     IFNE DEBUG
00000AE6                          1976m     ENDC
00000AE6                          1977m 
00000AE6                          1978m     ENDM
00000AE6                          1979m                 PRINT_CRLF D5,A4
00000AE6  49FA 124A               1980m     LEA CRLF(PC),A4
00000AEA                          1981mm     PRINT_STR A4,D5
00000AEA                          1982mm LOOP_110
00000AEA  0C14 0000               1983mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AEE  6700 0016               1984mm     BEQ EXIT_110
00000AF2                          1985mmm     PRINT_CHAR (A4)+,D5
00000AF2                          1986mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF2                 TRUE     1987mmm     IFEQ DEBUG
00000AF2  1A39 00C00003           1988mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF8  0805 0002               1989mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFC  67F4                    1990mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000AFE  13DC 00C00007           1991mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B04                          1992mmm     ENDC
00000B04                          1993mmm 
00000B04                 FALSE    1994mmm     IFNE DEBUG
00000B04                          1995mmm     ENDC
00000B04                          1996mmm 
00000B04                          1997mmm     ENDM
00000B04  60E4                    1998mm     BRA LOOP_110
00000B06                          1999mm EXIT_110
00000B06                          2000mm     ENDM
00000B06                          2001m     ENDM
00000B06                          2002  
00000B06  6000 FAEC               2003                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000B0A                          2004              ENDI
00000B0A                          2005s _0000000A
00000B0A                          2006          ENDI
00000B0A                          2007s _00000008
00000B0A                          2008      ENDI
00000B0A                          2009s _00000004
00000B0A                          2010  
00000B0A                          2011m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000B0A  1E3C 0002               2012m     MOVE.B #2,D7
00000B0E                          2013m     WHILE.B D7 <GT> 0 DO
00000B0E                          2014ms _10000012
00000B0E  BE38 0000               2015ms     CMP.B   0,D7
00000B12  6F00 0062               2016ms     BLE _10000013
00000B16  E98C                    2017m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B18                          2018mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B18                          2019mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B18                          2020mm 
00000B18  1A39 00C00003           2021mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B1E  0805 0000               2022mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B22  6700 0010               2023mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000B26                          2024mm 
00000B26                          2025mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B26                 TRUE     2026mmm     IFEQ DEBUG
00000B26  1A39 00C00007           2027mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B2C                          2028mmm     ENDC
00000B2C                 FALSE    2029mmm     IFNE DEBUG
00000B2C                          2030mmm     ENDC
00000B2C                          2031mmm 
00000B2C  BA3C 001B               2032mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B30  6700 F5D2               2033mmm     BEQ START
00000B34                          2034mmm     ENDM
00000B34                          2035mm CONTINUE_113
00000B34  1A39 00C00013           2036mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B3A  0805 0000               2037mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B3E  67D8                    2038mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000B40                          2039mm     
00000B40  1A39 00C00017           2040mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B46  13C5 00E00001           2041mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B4C                          2042mm 
00000B4C                          2043mm     ENDM
00000B4C                          2044mm         PRINT_CHAR D5,D6
00000B4C                          2045mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4C                 TRUE     2046mm     IFEQ DEBUG
00000B4C  1C39 00C00003           2047mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B52  0806 0002               2048mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B56  67F4                    2049mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B58  13C5 00C00007           2050mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B5E                          2051mm     ENDC
00000B5E                          2052mm 
00000B5E                 FALSE    2053mm     IFNE DEBUG
00000B5E                          2054mm     ENDC
00000B5E                          2055mm 
00000B5E                          2056mm     ENDM
00000B5E                          2057mm         HEX2BIN D5,D5,A4
00000B5E  49FA 11A7               2058mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B62  0405 0030               2059mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B66  CABC 000000FF           2060mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B6C  1A34 5000               2061mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B70                          2062mm     ENDM
00000B70  8805                    2063m         OR.B D5,D4
00000B72  5307                    2064m         SUB.B #1,D7
00000B74                          2065m     ENDW
00000B74  6098                    2066ms     BRA _10000012
00000B76                          2067ms _10000013
00000B76                          2068m 
00000B76  7A00                    2069m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B78  1A04                    2070m     MOVE.B D4,D5
00000B7A  D484                    2071m     ADD.L D4,D2
00000B7C                          2072m 
00000B7C                          2073m     ENDM
00000B7C                          2074m     PRINT_CRLF D5,A4
00000B7C  49FA 11B4               2075m     LEA CRLF(PC),A4
00000B80                          2076mm     PRINT_STR A4,D5
00000B80                          2077mm LOOP_118
00000B80  0C14 0000               2078mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B84  6700 0016               2079mm     BEQ EXIT_118
00000B88                          2080mmm     PRINT_CHAR (A4)+,D5
00000B88                          2081mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2082mmm     IFEQ DEBUG
00000B88  1A39 00C00003           2083mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B8E  0805 0002               2084mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2085mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B94  13DC 00C00007           2086mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9A                          2087mmm     ENDC
00000B9A                          2088mmm 
00000B9A                 FALSE    2089mmm     IFNE DEBUG
00000B9A                          2090mmm     ENDC
00000B9A                          2091mmm 
00000B9A                          2092mmm     ENDM
00000B9A  60E4                    2093mm     BRA LOOP_118
00000B9C                          2094mm EXIT_118
00000B9C                          2095mm     ENDM
00000B9C                          2096m     ENDM
00000B9C                          2097  
00000B9C                          2098      IF.B D2 <NE> #$FF THEN.L
00000B9C  B43C 00FF               2099s     CMP.B   #$FF,D2
00000BA0  6700 0090               2100s     BEQ.L   _0000000B
00000BA4  49FA 112F               2101          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000BA8                          2102m         PRINT_STR A4,D5
00000BA8                          2103m LOOP_120
00000BA8  0C14 0000               2104m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BAC  6700 0016               2105m     BEQ EXIT_120
00000BB0                          2106mm     PRINT_CHAR (A4)+,D5
00000BB0                          2107mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB0                 TRUE     2108mm     IFEQ DEBUG
00000BB0  1A39 00C00003           2109mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BB6  0805 0002               2110mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BBA  67F4                    2111mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000BBC  13DC 00C00007           2112mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BC2                          2113mm     ENDC
00000BC2                          2114mm 
00000BC2                 FALSE    2115mm     IFNE DEBUG
00000BC2                          2116mm     ENDC
00000BC2                          2117mm 
00000BC2                          2118mm     ENDM
00000BC2  60E4                    2119m     BRA LOOP_120
00000BC4                          2120m EXIT_120
00000BC4                          2121m     ENDM
00000BC4                          2122m         PRINT_REG D0,D5,D3,D6,A4
00000BC4  49FA 1172               2123m     LEA OX(PC),A4
00000BC8                          2124mm     PRINT_STR A4,D5
00000BC8                          2125mm LOOP_123
00000BC8  0C14 0000               2126mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BCC  6700 0016               2127mm     BEQ EXIT_123
00000BD0                          2128mmm     PRINT_CHAR (A4)+,D5
00000BD0                          2129mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                 TRUE     2130mmm     IFEQ DEBUG
00000BD0  1A39 00C00003           2131mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD6  0805 0002               2132mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BDA  67F4                    2133mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BDC  13DC 00C00007           2134mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BE2                          2135mmm     ENDC
00000BE2                          2136mmm 
00000BE2                 FALSE    2137mmm     IFNE DEBUG
00000BE2                          2138mmm     ENDC
00000BE2                          2139mmm 
00000BE2                          2140mmm     ENDM
00000BE2  60E4                    2141mm     BRA LOOP_123
00000BE4                          2142mm EXIT_123
00000BE4                          2143mm     ENDM
00000BE4  7C07                    2144m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BE6                          2145m LOOP_122
00000BE6                          2146mm     BIN2HEX D0,D3,A4
00000BE6  49FA 110F               2147mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000BEA  E998                    2148mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BEC  1600                    2149mm     MOVE.B D0,D3
00000BEE  0283 0000000F           2150mm     ANDI.L #$F,D3
00000BF4  1634 3000               2151mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000BF8                          2152mm     ENDM
00000BF8                          2153mm     PRINT_CHAR D3,D5
00000BF8                          2154mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF8                 TRUE     2155mm     IFEQ DEBUG
00000BF8  1A39 00C00003           2156mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BFE  0805 0002               2157mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C02  67F4                    2158mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000C04  13C3 00C00007           2159mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C0A                          2160mm     ENDC
00000C0A                          2161mm 
00000C0A                 FALSE    2162mm     IFNE DEBUG
00000C0A                          2163mm     ENDC
00000C0A                          2164mm 
00000C0A                          2165mm     ENDM
00000C0A  57CE FFDA               2166m     DBEQ D6,LOOP_122
00000C0E                          2167m     ENDM
00000C0E                          2168m         PRINT_CRLF D5,A4
00000C0E  49FA 1122               2169m     LEA CRLF(PC),A4
00000C12                          2170mm     PRINT_STR A4,D5
00000C12                          2171mm LOOP_128
00000C12  0C14 0000               2172mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C16  6700 0016               2173mm     BEQ EXIT_128
00000C1A                          2174mmm     PRINT_CHAR (A4)+,D5
00000C1A                          2175mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1A                 TRUE     2176mmm     IFEQ DEBUG
00000C1A  1A39 00C00003           2177mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C20  0805 0002               2178mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C24  67F4                    2179mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000C26  13DC 00C00007           2180mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C2C                          2181mmm     ENDC
00000C2C                          2182mmm 
00000C2C                 FALSE    2183mmm     IFNE DEBUG
00000C2C                          2184mmm     ENDC
00000C2C                          2185mmm 
00000C2C                          2186mmm     ENDM
00000C2C  60E4                    2187mm     BRA LOOP_128
00000C2E                          2188mm EXIT_128
00000C2E                          2189mm     ENDM
00000C2E                          2190m     ENDM
00000C2E                          2191          
00000C2E  6000 F714               2192          BRA MAIN_LOOP
00000C32                          2193      ENDI
00000C32                          2194s _0000000B
00000C32                          2195  
00000C32                          2196      IF D1 <EQ> #0 THEN
00000C32  B27C 0000               2197s     CMP.W   #0,D1
00000C36  6600 0006               2198s     BNE _0000000C
00000C3A  6000 F9B8               2199        BRA WAIT_FOR_SRECORD
00000C3E                          2200      ENDI
00000C3E                          2201s _0000000C
00000C3E                          2202  DOWNLOAD_DONE
00000C3E                          2203m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C3E  43FA 10F8               2204m     LEA OX(PC),A1
00000C42                          2205mm     PRINT_STR A1,D5
00000C42                          2206mm LOOP_131
00000C42  0C11 0000               2207mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C46  6700 0016               2208mm     BEQ EXIT_131
00000C4A                          2209mmm     PRINT_CHAR (A1)+,D5
00000C4A                          2210mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2211mmm     IFEQ DEBUG
00000C4A  1A39 00C00003           2212mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C50  0805 0002               2213mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2214mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000C56  13D9 00C00007           2215mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C5C                          2216mmm     ENDC
00000C5C                          2217mmm 
00000C5C                 FALSE    2218mmm     IFNE DEBUG
00000C5C                          2219mmm     ENDC
00000C5C                          2220mmm 
00000C5C                          2221mmm     ENDM
00000C5C  60E4                    2222mm     BRA LOOP_131
00000C5E                          2223mm EXIT_131
00000C5E                          2224mm     ENDM
00000C5E  7407                    2225m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C60                          2226m LOOP_130
00000C60                          2227mm     BIN2HEX D0,D6,A1
00000C60  43FA 1095               2228mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C64  E998                    2229mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C66  1C00                    2230mm     MOVE.B D0,D6
00000C68  0286 0000000F           2231mm     ANDI.L #$F,D6
00000C6E  1C31 6000               2232mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C72                          2233mm     ENDM
00000C72                          2234mm     PRINT_CHAR D6,D5
00000C72                          2235mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C72                 TRUE     2236mm     IFEQ DEBUG
00000C72  1A39 00C00003           2237mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C78  0805 0002               2238mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C7C  67F4                    2239mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C7E  13C6 00C00007           2240mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C84                          2241mm     ENDC
00000C84                          2242mm 
00000C84                 FALSE    2243mm     IFNE DEBUG
00000C84                          2244mm     ENDC
00000C84                          2245mm 
00000C84                          2246mm     ENDM
00000C84  57CA FFDA               2247m     DBEQ D2,LOOP_130
00000C88                          2248m     ENDM
00000C88  43FA 1012               2249      LEA READ(PC),A1
00000C8C                          2250m     PRINT_STR A1,D5
00000C8C                          2251m LOOP_135
00000C8C  0C11 0000               2252m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C90  6700 0016               2253m     BEQ EXIT_135
00000C94                          2254mm     PRINT_CHAR (A1)+,D5
00000C94                          2255mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C94                 TRUE     2256mm     IFEQ DEBUG
00000C94  1A39 00C00003           2257mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C9A  0805 0002               2258mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C9E  67F4                    2259mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CA0  13D9 00C00007           2260mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA6                          2261mm     ENDC
00000CA6                          2262mm 
00000CA6                 FALSE    2263mm     IFNE DEBUG
00000CA6                          2264mm     ENDC
00000CA6                          2265mm 
00000CA6                          2266mm     ENDM
00000CA6  60E4                    2267m     BRA LOOP_135
00000CA8                          2268m EXIT_135
00000CA8                          2269m     ENDM
00000CA8  2E08                    2270      MOVE.L A0,D7                                    ; set address accumulator to start address
00000CAA                          2271m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000CAA  43FA 108C               2272m     LEA OX(PC),A1
00000CAE                          2273mm     PRINT_STR A1,D5
00000CAE                          2274mm LOOP_138
00000CAE  0C11 0000               2275mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CB2  6700 0016               2276mm     BEQ EXIT_138
00000CB6                          2277mmm     PRINT_CHAR (A1)+,D5
00000CB6                          2278mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2279mmm     IFEQ DEBUG
00000CB6  1A39 00C00003           2280mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CBC  0805 0002               2281mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2282mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CC2  13D9 00C00007           2283mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CC8                          2284mmm     ENDC
00000CC8                          2285mmm 
00000CC8                 FALSE    2286mmm     IFNE DEBUG
00000CC8                          2287mmm     ENDC
00000CC8                          2288mmm 
00000CC8                          2289mmm     ENDM
00000CC8  60E4                    2290mm     BRA LOOP_138
00000CCA                          2291mm EXIT_138
00000CCA                          2292mm     ENDM
00000CCA  7407                    2293m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CCC                          2294m LOOP_137
00000CCC                          2295mm     BIN2HEX D7,D6,A1
00000CCC  43FA 1029               2296mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CD0  E99F                    2297mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CD2  1C07                    2298mm     MOVE.B D7,D6
00000CD4  0286 0000000F           2299mm     ANDI.L #$F,D6
00000CDA  1C31 6000               2300mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CDE                          2301mm     ENDM
00000CDE                          2302mm     PRINT_CHAR D6,D5
00000CDE                          2303mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDE                 TRUE     2304mm     IFEQ DEBUG
00000CDE  1A39 00C00003           2305mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CE4  0805 0002               2306mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CE8  67F4                    2307mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CEA  13C6 00C00007           2308mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CF0                          2309mm     ENDC
00000CF0                          2310mm 
00000CF0                 FALSE    2311mm     IFNE DEBUG
00000CF0                          2312mm     ENDC
00000CF0                          2313mm 
00000CF0                          2314mm     ENDM
00000CF0  57CA FFDA               2315m     DBEQ D2,LOOP_137
00000CF4                          2316m     ENDM
00000CF4                          2317m     PRINT_CRLF D5,A4
00000CF4  49FA 103C               2318m     LEA CRLF(PC),A4
00000CF8                          2319mm     PRINT_STR A4,D5
00000CF8                          2320mm LOOP_143
00000CF8  0C14 0000               2321mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000CFC  6700 0016               2322mm     BEQ EXIT_143
00000D00                          2323mmm     PRINT_CHAR (A4)+,D5
00000D00                          2324mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2325mmm     IFEQ DEBUG
00000D00  1A39 00C00003           2326mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D06  0805 0002               2327mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2328mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D0C  13DC 00C00007           2329mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D12                          2330mmm     ENDC
00000D12                          2331mmm 
00000D12                 FALSE    2332mmm     IFNE DEBUG
00000D12                          2333mmm     ENDC
00000D12                          2334mmm 
00000D12                          2335mmm     ENDM
00000D12  60E4                    2336mm     BRA LOOP_143
00000D14                          2337mm EXIT_143
00000D14                          2338mm     ENDM
00000D14                          2339m     ENDM
00000D14                          2340  
00000D14  6000 F62E               2341      BRA MAIN_LOOP
00000D18                          2342  
00000D18                          2343  G
00000D18  2047                    2344      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000D1A  7E00                    2345      MOVE.L #0,D7
00000D1C                          2346  
00000D1C  4ED0                    2347      JMP (A0)
00000D1E                          2348          
00000D1E                          2349  Z
00000D1E  207C 00200000           2350      MOVE.L #RAM,A0                                  ; address of RAM
00000D24  D1FC 00100000           2351      ADD.L #$100000,A0
00000D2A                          2352  
00000D2A                          2353      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000D2A  7000                    2354s     MOVE.L  #0,D0
00000D2C  6000 0012               2355s     BRA _20000007
00000D30                          2356s _20000006
00000D30  2200                    2357          MOVE.L D0,D1                                ; progress update
00000D32  E089                    2358          LSR.L #8,D1 
00000D34  E089                    2359          LSR.L #8,D1
00000D36  13C1 00E00001           2360          MOVE.B D1,DISPLAY
00000D3C                          2361          
00000D3C  2108                    2362          MOVE.L A0,-(A0)
00000D3E                          2363      ENDF
00000D3E  5880                    2364s     ADD.L   #4,D0
00000D40                          2365s _20000007
00000D40  B0BC 000FFFFC           2366s     CMP.L   #$FFFFC,D0
00000D46  6FE8                    2367s     BLE _20000006
00000D48                          2368  
00000D48  207C 00200000           2369      MOVE.L #RAM,A0                                  ; address of RAM
00000D4E  D1FC 00100000           2370      ADD.L #$100000,A0
00000D54                          2371  
00000D54                          2372      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D54  7000                    2373s     MOVE.L  #0,D0
00000D56  6000 00A8               2374s     BRA _20000009
00000D5A                          2375s _20000008
00000D5A  2200                    2376          MOVE.L D0,D1                                ; progress update
00000D5C  E089                    2377          LSR.L #8,D1
00000D5E  E089                    2378          LSR.L #8,D1
00000D60  13C1 00E00001           2379          MOVE.B D1,DISPLAY
00000D66                          2380  
00000D66  2408                    2381          MOVE.L A0,D2
00000D68  2220                    2382          MOVE.L -(A0),D1
00000D6A                          2383  
00000D6A                          2384          IF.L D2 <NE> D1 THEN
00000D6A  B481                    2385s     CMP.L   D1,D2
00000D6C  6700 0090               2386s     BEQ _0000000D
00000D70  43FA 0F74               2387              LEA RAM_ERROR(PC),A1
00000D74                          2388m             PRINT_STR A1,D1
00000D74                          2389m LOOP_145
00000D74  0C11 0000               2390m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D78  6700 0016               2391m     BEQ EXIT_145
00000D7C                          2392mm     PRINT_CHAR (A1)+,D1
00000D7C                          2393mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7C                 TRUE     2394mm     IFEQ DEBUG
00000D7C  1239 00C00003           2395mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D82  0801 0002               2396mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000D86  67F4                    2397mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000D88  13D9 00C00007           2398mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D8E                          2399mm     ENDC
00000D8E                          2400mm 
00000D8E                 FALSE    2401mm     IFNE DEBUG
00000D8E                          2402mm     ENDC
00000D8E                          2403mm 
00000D8E                          2404mm     ENDM
00000D8E  60E4                    2405m     BRA LOOP_145
00000D90                          2406m EXIT_145
00000D90                          2407m     ENDM
00000D90  2208                    2408              MOVE.L A0,D1
00000D92  5981                    2409              SUB.L #4,D1
00000D94                          2410m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000D94  43FA 0FA2               2411m     LEA OX(PC),A1
00000D98                          2412mm     PRINT_STR A1,D3
00000D98                          2413mm LOOP_148
00000D98  0C11 0000               2414mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D9C  6700 0016               2415mm     BEQ EXIT_148
00000DA0                          2416mmm     PRINT_CHAR (A1)+,D3
00000DA0                          2417mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA0                 TRUE     2418mmm     IFEQ DEBUG
00000DA0  1639 00C00003           2419mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DA6  0803 0002               2420mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DAA  67F4                    2421mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000DAC  13D9 00C00007           2422mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DB2                          2423mmm     ENDC
00000DB2                          2424mmm 
00000DB2                 FALSE    2425mmm     IFNE DEBUG
00000DB2                          2426mmm     ENDC
00000DB2                          2427mmm 
00000DB2                          2428mmm     ENDM
00000DB2  60E4                    2429mm     BRA LOOP_148
00000DB4                          2430mm EXIT_148
00000DB4                          2431mm     ENDM
00000DB4  7C07                    2432m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DB6                          2433m LOOP_147
00000DB6                          2434mm     BIN2HEX D1,D2,A1
00000DB6  43FA 0F3F               2435mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000DBA  E999                    2436mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DBC  1401                    2437mm     MOVE.B D1,D2
00000DBE  0282 0000000F           2438mm     ANDI.L #$F,D2
00000DC4  1431 2000               2439mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000DC8                          2440mm     ENDM
00000DC8                          2441mm     PRINT_CHAR D2,D3
00000DC8                          2442mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC8                 TRUE     2443mm     IFEQ DEBUG
00000DC8  1639 00C00003           2444mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DCE  0803 0002               2445mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DD2  67F4                    2446mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DD4  13C2 00C00007           2447mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DDA                          2448mm     ENDC
00000DDA                          2449mm 
00000DDA                 FALSE    2450mm     IFNE DEBUG
00000DDA                          2451mm     ENDC
00000DDA                          2452mm 
00000DDA                          2453mm     ENDM
00000DDA  57CE FFDA               2454m     DBEQ D6,LOOP_147
00000DDE                          2455m     ENDM
00000DDE                          2456m             PRINT_CRLF D3,A1
00000DDE  43FA 0F52               2457m     LEA CRLF(PC),A1
00000DE2                          2458mm     PRINT_STR A1,D3
00000DE2                          2459mm LOOP_153
00000DE2  0C11 0000               2460mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DE6  6700 0016               2461mm     BEQ EXIT_153
00000DEA                          2462mmm     PRINT_CHAR (A1)+,D3
00000DEA                          2463mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEA                 TRUE     2464mmm     IFEQ DEBUG
00000DEA  1639 00C00003           2465mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DF0  0803 0002               2466mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DF4  67F4                    2467mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DF6  13D9 00C00007           2468mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DFC                          2469mmm     ENDC
00000DFC                          2470mmm 
00000DFC                 FALSE    2471mmm     IFNE DEBUG
00000DFC                          2472mmm     ENDC
00000DFC                          2473mmm 
00000DFC                          2474mmm     ENDM
00000DFC  60E4                    2475mm     BRA LOOP_153
00000DFE                          2476mm EXIT_153
00000DFE                          2477mm     ENDM
00000DFE                          2478m     ENDM
00000DFE                          2479          ENDI 
00000DFE                          2480s _0000000D
00000DFE                          2481      ENDF
00000DFE  5880                    2482s     ADD.L   #4,D0
00000E00                          2483s _20000009
00000E00  B0BC 000FFFFC           2484s     CMP.L   #$FFFFC,D0
00000E06  6F00 FF52               2485s     BLE _20000008
00000E0A                          2486  
00000E0A  6000 F538               2487      BRA MAIN_LOOP
00000E0E                          2488  
00000E0E                          2489  L
00000E0E  7000                    2490      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000E10  7200                    2491      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000E12                          2492  
00000E12                          2493      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000E12  343C 0000               2494s     MOVE.W  #0,D2
00000E16  6000 0046               2495s     BRA _2000000B
00000E1A                          2496s _2000000A
00000E1A  E989                    2497          LSL.L #4,D1                                 ; make what we have so far more significant
00000E1C                          2498m         WAIT_CHAR D3,D4                             ; next character -> D2
00000E1C                          2499m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E1C                 TRUE     2500m     IFEQ DEBUG
00000E1C  1839 00C00003           2501m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E22  0804 0000               2502m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000E26  67F4                    2503m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000E28                          2504m     ENDC
00000E28                          2505m 
00000E28                          2506mm     READ_CHAR D3
00000E28                 TRUE     2507mm     IFEQ DEBUG
00000E28  1639 00C00007           2508mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000E2E                          2509mm     ENDC
00000E2E                 FALSE    2510mm     IFNE DEBUG
00000E2E                          2511mm     ENDC
00000E2E                          2512mm 
00000E2E  B63C 001B               2513mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E32  6700 F2D0               2514mm     BEQ START
00000E36                          2515mm     ENDM
00000E36                          2516m 
00000E36                 TRUE     2517m     IFEQ DEBUG
00000E36                          2518mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E36                          2519mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E36                 TRUE     2520mm     IFEQ DEBUG
00000E36  1839 00C00003           2521mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E3C  0804 0002               2522mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E40  67F4                    2523mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E42  13C3 00C00007           2524mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E48                          2525mm     ENDC
00000E48                          2526mm 
00000E48                 FALSE    2527mm     IFNE DEBUG
00000E48                          2528mm     ENDC
00000E48                          2529mm 
00000E48                          2530mm     ENDM
00000E48                          2531m     ENDC
00000E48                          2532m     ENDM
00000E48                          2533m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E48  41FA 0EBD               2534m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E4C  0403 0030               2535m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E50  C6BC 000000FF           2536m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E56  1630 3000               2537m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E5A                          2538m     ENDM
00000E5A  8203                    2539          OR.B D3,D1
00000E5C                          2540      ENDF
00000E5C  5242                    2541s     ADD.W   #1,D2
00000E5E                          2542s _2000000B
00000E5E  B47C 0007               2543s     CMP.W   #7,D2
00000E62  6FB6                    2544s     BLE _2000000A
00000E64                          2545  
00000E64  3001                    2546      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E66  0480 00000104           2547      SUB.L #START,D0                                 ; remove the vector table from the length
00000E6C  E089                    2548      LSR.L #8,D1                                     ; extract the MSword for the address
00000E6E  E089                    2549      LSR.L #8,D1
00000E70                          2550  
00000E70                          2551m     PRINT_CRLF D2,A1
00000E70  43FA 0EC0               2552m     LEA CRLF(PC),A1
00000E74                          2553mm     PRINT_STR A1,D2
00000E74                          2554mm LOOP_160
00000E74  0C11 0000               2555mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E78  6700 0016               2556mm     BEQ EXIT_160
00000E7C                          2557mmm     PRINT_CHAR (A1)+,D2
00000E7C                          2558mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E7C                 TRUE     2559mmm     IFEQ DEBUG
00000E7C  1439 00C00003           2560mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E82  0802 0002               2561mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E86  67F4                    2562mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E88  13D9 00C00007           2563mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E8E                          2564mmm     ENDC
00000E8E                          2565mmm 
00000E8E                 FALSE    2566mmm     IFNE DEBUG
00000E8E                          2567mmm     ENDC
00000E8E                          2568mmm 
00000E8E                          2569mmm     ENDM
00000E8E  60E4                    2570mm     BRA LOOP_160
00000E90                          2571mm EXIT_160
00000E90                          2572mm     ENDM
00000E90                          2573m     ENDM
00000E90                          2574  
00000E90  2041                    2575      MOVE.L D1,A0                                    ; target address
00000E92  2641                    2576      MOVE.L D1,A3                                    ; keep a copy for later
00000E94                          2577  
00000E94  2247                    2578      MOVE.L D7,A1                                    ; address accumulator -> address register
00000E96  D3FC 00000104           2579      ADD.L #START,A1                                 ; skip the vectors
00000E9C  2847                    2580      MOVE.L D7,A4                                    ; keep a clean copy for later
00000E9E  7E00                    2581      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EA0                          2582  
00000EA0                          2583m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000EA0  31FC AAAA 2AAA          2584m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EA6  4E71                    2585m     NOP
00000EA8  31FC 5555 1554          2586m     MOVE.W #$5555,$1554
00000EAE  4E71                    2587m     NOP
00000EB0  31FC 8080 2AAA          2588m     MOVE.W #$8080,$2AAA
00000EB6  4E71                    2589m     NOP
00000EB8  31FC AAAA 2AAA          2590m     MOVE.W #$AAAA,$2AAA
00000EBE  4E71                    2591m     NOP
00000EC0  31FC 5555 1554          2592m     MOVE.W #$5555,$1554
00000EC6  4E71                    2593m     NOP
00000EC8  31FC 2020 2AAA          2594m     MOVE.W #$2020,$2AAA
00000ECE                          2595m     ENDM
00000ECE                          2596                      
00000ECE                          2597      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000ECE  3E3C 0000               2598s     MOVE.W  #$0,D7
00000ED2  6000 0006               2599s     BRA _2000000D
00000ED6                          2600s _2000000C
00000ED6  4E71                    2601          NOP
00000ED8                          2602      ENDF
00000ED8  5247                    2603s     ADD.W   #1,D7
00000EDA                          2604s _2000000D
00000EDA  BE7C FFFF               2605s     CMP.W   #$FFFFFFFF,D7
00000EDE  6FF6                    2606s     BLE _2000000C
00000EE0                          2607                  
00000EE0  45FA 0E3C               2608      LEA LOADING(PC),A2
00000EE4                          2609m     PRINT_STR A2,D2
00000EE4                          2610m LOOP_163
00000EE4  0C12 0000               2611m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EE8  6700 0016               2612m     BEQ EXIT_163
00000EEC                          2613mm     PRINT_CHAR (A2)+,D2
00000EEC                          2614mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEC                 TRUE     2615mm     IFEQ DEBUG
00000EEC  1439 00C00003           2616mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EF2  0802 0002               2617mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EF6  67F4                    2618mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EF8  13DA 00C00007           2619mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFE                          2620mm     ENDC
00000EFE                          2621mm 
00000EFE                 FALSE    2622mm     IFNE DEBUG
00000EFE                          2623mm     ENDC
00000EFE                          2624mm 
00000EFE                          2625mm     ENDM
00000EFE  60E4                    2626m     BRA LOOP_163
00000F00                          2627m EXIT_163
00000F00                          2628m     ENDM
00000F00                          2629          
00000F00  2409                    2630      MOVE.L A1,D2
00000F02                          2631m     PRINT_REG D2,D3,D4,D5,A2
00000F02  45FA 0E34               2632m     LEA OX(PC),A2
00000F06                          2633mm     PRINT_STR A2,D3
00000F06                          2634mm LOOP_166
00000F06  0C12 0000               2635mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F0A  6700 0016               2636mm     BEQ EXIT_166
00000F0E                          2637mmm     PRINT_CHAR (A2)+,D3
00000F0E                          2638mmm WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F0E                 TRUE     2639mmm     IFEQ DEBUG
00000F0E  1639 00C00003           2640mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F14  0803 0002               2641mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F18  67F4                    2642mmm         BEQ WAIT_FOR_READY_167                      ; NO SPACE, CHECK AGAIN
00000F1A  13DA 00C00007           2643mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F20                          2644mmm     ENDC
00000F20                          2645mmm 
00000F20                 FALSE    2646mmm     IFNE DEBUG
00000F20                          2647mmm     ENDC
00000F20                          2648mmm 
00000F20                          2649mmm     ENDM
00000F20  60E4                    2650mm     BRA LOOP_166
00000F22                          2651mm EXIT_166
00000F22                          2652mm     ENDM
00000F22  7A07                    2653m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F24                          2654m LOOP_165
00000F24                          2655mm     BIN2HEX D2,D4,A2
00000F24  45FA 0DD1               2656mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F28  E99A                    2657mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F2A  1802                    2658mm     MOVE.B D2,D4
00000F2C  0284 0000000F           2659mm     ANDI.L #$F,D4
00000F32  1832 4000               2660mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F36                          2661mm     ENDM
00000F36                          2662mm     PRINT_CHAR D4,D3
00000F36                          2663mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F36                 TRUE     2664mm     IFEQ DEBUG
00000F36  1639 00C00003           2665mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F3C  0803 0002               2666mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F40  67F4                    2667mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F42  13C4 00C00007           2668mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F48                          2669mm     ENDC
00000F48                          2670mm 
00000F48                 FALSE    2671mm     IFNE DEBUG
00000F48                          2672mm     ENDC
00000F48                          2673mm 
00000F48                          2674mm     ENDM
00000F48  57CD FFDA               2675m     DBEQ D5,LOOP_165
00000F4C                          2676m     ENDM
00000F4C                          2677  
00000F4C  45FA 0DED               2678      LEA TO(PC),A2
00000F50                          2679m     PRINT_STR A2,D3
00000F50                          2680m LOOP_170
00000F50  0C12 0000               2681m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F54  6700 0016               2682m     BEQ EXIT_170
00000F58                          2683mm     PRINT_CHAR (A2)+,D3
00000F58                          2684mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F58                 TRUE     2685mm     IFEQ DEBUG
00000F58  1639 00C00003           2686mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F5E  0803 0002               2687mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F62  67F4                    2688mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F64  13DA 00C00007           2689mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F6A                          2690mm     ENDC
00000F6A                          2691mm 
00000F6A                 FALSE    2692mm     IFNE DEBUG
00000F6A                          2693mm     ENDC
00000F6A                          2694mm 
00000F6A                          2695mm     ENDM
00000F6A  60E4                    2696m     BRA LOOP_170
00000F6C                          2697m EXIT_170
00000F6C                          2698m     ENDM
00000F6C                          2699  
00000F6C  2408                    2700      MOVE.L A0,D2
00000F6E                          2701m     PRINT_REG D2,D3,D4,D5,A2
00000F6E  45FA 0DC8               2702m     LEA OX(PC),A2
00000F72                          2703mm     PRINT_STR A2,D3
00000F72                          2704mm LOOP_173
00000F72  0C12 0000               2705mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F76  6700 0016               2706mm     BEQ EXIT_173
00000F7A                          2707mmm     PRINT_CHAR (A2)+,D3
00000F7A                          2708mmm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F7A                 TRUE     2709mmm     IFEQ DEBUG
00000F7A  1639 00C00003           2710mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F80  0803 0002               2711mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F84  67F4                    2712mmm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00000F86  13DA 00C00007           2713mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F8C                          2714mmm     ENDC
00000F8C                          2715mmm 
00000F8C                 FALSE    2716mmm     IFNE DEBUG
00000F8C                          2717mmm     ENDC
00000F8C                          2718mmm 
00000F8C                          2719mmm     ENDM
00000F8C  60E4                    2720mm     BRA LOOP_173
00000F8E                          2721mm EXIT_173
00000F8E                          2722mm     ENDM
00000F8E  7A07                    2723m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F90                          2724m LOOP_172
00000F90                          2725mm     BIN2HEX D2,D4,A2
00000F90  45FA 0D65               2726mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F94  E99A                    2727mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F96  1802                    2728mm     MOVE.B D2,D4
00000F98  0284 0000000F           2729mm     ANDI.L #$F,D4
00000F9E  1832 4000               2730mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FA2                          2731mm     ENDM
00000FA2                          2732mm     PRINT_CHAR D4,D3
00000FA2                          2733mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FA2                 TRUE     2734mm     IFEQ DEBUG
00000FA2  1639 00C00003           2735mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FA8  0803 0002               2736mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FAC  67F4                    2737mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000FAE  13C4 00C00007           2738mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FB4                          2739mm     ENDC
00000FB4                          2740mm 
00000FB4                 FALSE    2741mm     IFNE DEBUG
00000FB4                          2742mm     ENDC
00000FB4                          2743mm 
00000FB4                          2744mm     ENDM
00000FB4  57CD FFDA               2745m     DBEQ D5,LOOP_172
00000FB8                          2746m     ENDM
00000FB8                          2747  
00000FB8  45FA 0D86               2748      LEA FOR(PC),A2
00000FBC                          2749m     PRINT_STR A2,D3
00000FBC                          2750m LOOP_177
00000FBC  0C12 0000               2751m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FC0  6700 0016               2752m     BEQ EXIT_177
00000FC4                          2753mm     PRINT_CHAR (A2)+,D3
00000FC4                          2754mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC4                 TRUE     2755mm     IFEQ DEBUG
00000FC4  1639 00C00003           2756mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FCA  0803 0002               2757mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FCE  67F4                    2758mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000FD0  13DA 00C00007           2759mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FD6                          2760mm     ENDC
00000FD6                          2761mm 
00000FD6                 FALSE    2762mm     IFNE DEBUG
00000FD6                          2763mm     ENDC
00000FD6                          2764mm 
00000FD6                          2765mm     ENDM
00000FD6  60E4                    2766m     BRA LOOP_177
00000FD8                          2767m EXIT_177
00000FD8                          2768m     ENDM
00000FD8                          2769m     PRINT_REG D0,D3,D4,D5,A2
00000FD8  45FA 0D5E               2770m     LEA OX(PC),A2
00000FDC                          2771mm     PRINT_STR A2,D3
00000FDC                          2772mm LOOP_180
00000FDC  0C12 0000               2773mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FE0  6700 0016               2774mm     BEQ EXIT_180
00000FE4                          2775mmm     PRINT_CHAR (A2)+,D3
00000FE4                          2776mmm WAIT_FOR_READY_181                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FE4                 TRUE     2777mmm     IFEQ DEBUG
00000FE4  1639 00C00003           2778mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FEA  0803 0002               2779mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FEE  67F4                    2780mmm         BEQ WAIT_FOR_READY_181                      ; NO SPACE, CHECK AGAIN
00000FF0  13DA 00C00007           2781mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FF6                          2782mmm     ENDC
00000FF6                          2783mmm 
00000FF6                 FALSE    2784mmm     IFNE DEBUG
00000FF6                          2785mmm     ENDC
00000FF6                          2786mmm 
00000FF6                          2787mmm     ENDM
00000FF6  60E4                    2788mm     BRA LOOP_180
00000FF8                          2789mm EXIT_180
00000FF8                          2790mm     ENDM
00000FF8  7A07                    2791m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FFA                          2792m LOOP_179
00000FFA                          2793mm     BIN2HEX D0,D4,A2
00000FFA  45FA 0CFB               2794mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FFE  E998                    2795mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001000  1800                    2796mm     MOVE.B D0,D4
00001002  0284 0000000F           2797mm     ANDI.L #$F,D4
00001008  1832 4000               2798mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000100C                          2799mm     ENDM
0000100C                          2800mm     PRINT_CHAR D4,D3
0000100C                          2801mm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000100C                 TRUE     2802mm     IFEQ DEBUG
0000100C  1639 00C00003           2803mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001012  0803 0002               2804mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001016  67F4                    2805mm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00001018  13C4 00C00007           2806mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000101E                          2807mm     ENDC
0000101E                          2808mm 
0000101E                 FALSE    2809mm     IFNE DEBUG
0000101E                          2810mm     ENDC
0000101E                          2811mm 
0000101E                          2812mm     ENDM
0000101E  57CD FFDA               2813m     DBEQ D5,LOOP_179
00001022                          2814m     ENDM
00001022                          2815  
00001022                          2816m     PRINT_CRLF D3,A2
00001022  45FA 0D0E               2817m     LEA CRLF(PC),A2
00001026                          2818mm     PRINT_STR A2,D3
00001026                          2819mm LOOP_185
00001026  0C12 0000               2820mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000102A  6700 0016               2821mm     BEQ EXIT_185
0000102E                          2822mmm     PRINT_CHAR (A2)+,D3
0000102E                          2823mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000102E                 TRUE     2824mmm     IFEQ DEBUG
0000102E  1639 00C00003           2825mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001034  0803 0002               2826mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001038  67F4                    2827mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
0000103A  13DA 00C00007           2828mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001040                          2829mmm     ENDC
00001040                          2830mmm 
00001040                 FALSE    2831mmm     IFNE DEBUG
00001040                          2832mmm     ENDC
00001040                          2833mmm 
00001040                          2834mmm     ENDM
00001040  60E4                    2835mm     BRA LOOP_185
00001042                          2836mm EXIT_185
00001042                          2837mm     ENDM
00001042                          2838m     ENDM
00001042                          2839  
00001042                          2840      WHILE D0 <GT> #0 DO
00001042                          2841s _10000014
00001042  B07C 0000               2842s     CMP.W   #0,D0
00001046  6F00 001C               2843s     BLE _10000015
0000104A  5580                    2844          SUB.L #2,D0
0000104C                          2845  
0000104C  13D1 00E00001           2846          MOVE.B (A1),DISPLAY
00001052                          2847m         PROGRAM (A1),(A0),D2
00001052  3091                    2848m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001054                          2849m 
00001054                          2850m WAIT_FOR_COMPLETE_187
00001054  3410                    2851m         MOVE.W (A0),D2
00001056                          2852m 
00001056                          2853m         IF.W D2 <NE> (A1) THEN
00001056  B451                    2854ms     CMP.W   (A1),D2
00001058  6700 0004               2855ms     BEQ _0000000E
0000105C  60F6                    2856m             BRA WAIT_FOR_COMPLETE_187
0000105E                          2857m         ENDI
0000105E                          2858ms _0000000E
0000105E                          2859m         ENDM
0000105E                          2860                  
0000105E  5488                    2861          ADD.L #2,A0
00001060  5489                    2862          ADD.L #2,A1
00001062                          2863      ENDW
00001062  60DE                    2864s     BRA _10000014
00001064                          2865s _10000015
00001064                          2866      
00001064  41F8 0000               2867      LEA STACK,A0
00001068  D1CC                    2868      ADD.L A4,A0
0000106A  2010                    2869      MOVE.L (A0),D0
0000106C                          2870      
0000106C  207C 00000000           2871      MOVE.L #0,A0
00001072                          2872m     PROGRAM_VECTOR D0,A0,D2
00001072  5488                    2873m     ADD.L #2,A0
00001074                          2874mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00001074  3080                    2875mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001076                          2876mm 
00001076                          2877mm WAIT_FOR_COMPLETE_189
00001076  3410                    2878mm         MOVE.W (A0),D2
00001078                          2879mm 
00001078                          2880mm         IF.W D2 <NE> D0 THEN
00001078  B440                    2881mms     CMP.W   D0,D2
0000107A  6700 0004               2882mms     BEQ _0000000F
0000107E  60F6                    2883mm             BRA WAIT_FOR_COMPLETE_189
00001080                          2884mm         ENDI
00001080                          2885mms _0000000F
00001080                          2886mm         ENDM
00001080  E088                    2887m     LSR.L #8,D0
00001082  E088                    2888m     LSR.L #8,D0
00001084  5588                    2889m     SUB.L #2,A0
00001086                          2890mm     PROGRAM D0, (A0), D2
00001086  3080                    2891mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001088                          2892mm 
00001088                          2893mm WAIT_FOR_COMPLETE_190
00001088  3410                    2894mm         MOVE.W (A0),D2
0000108A                          2895mm 
0000108A                          2896mm         IF.W D2 <NE> D0 THEN
0000108A  B440                    2897mms     CMP.W   D0,D2
0000108C  6700 0004               2898mms     BEQ _00000010
00001090  60F6                    2899mm             BRA WAIT_FOR_COMPLETE_190
00001092                          2900mm         ENDI
00001092                          2901mms _00000010
00001092                          2902mm         ENDM
00001092                          2903m     ENDM
00001092                          2904      
00001092                          2905      FOR A0 = #RESET TO #START-4 BY #4 DO
00001092  307C 0004               2906s     MOVE.W  #RESET,A0
00001096  6000 003C               2907s     BRA _2000000F
0000109A                          2908s _2000000E
0000109A                          2909  
0000109A  2248                    2910          MOVE.L A0,A1
0000109C  D3CC                    2911          ADD.L A4,A1
0000109E                          2912              
0000109E  2011                    2913          MOVE.L (A1),D0  
000010A0  D081                    2914          ADD.L D1,D0
000010A2  0480 00000104           2915          SUB.L #START,D0
000010A8                          2916  
000010A8  2408                    2917          MOVE.L A0,D2
000010AA                          2918          
000010AA  2408                    2919          MOVE.L A0,D2
000010AC  13C2 00E00001           2920          MOVE.B D2,DISPLAY
000010B2                          2921m         PROGRAM_VECTOR D0,A0,D2
000010B2  5488                    2922m     ADD.L #2,A0
000010B4                          2923mm     PROGRAM D0, (A0), D2                            ; WRITE IT
000010B4  3080                    2924mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010B6                          2925mm 
000010B6                          2926mm WAIT_FOR_COMPLETE_192
000010B6  3410                    2927mm         MOVE.W (A0),D2
000010B8                          2928mm 
000010B8                          2929mm         IF.W D2 <NE> D0 THEN
000010B8  B440                    2930mms     CMP.W   D0,D2
000010BA  6700 0004               2931mms     BEQ _00000011
000010BE  60F6                    2932mm             BRA WAIT_FOR_COMPLETE_192
000010C0                          2933mm         ENDI
000010C0                          2934mms _00000011
000010C0                          2935mm         ENDM
000010C0  E088                    2936m     LSR.L #8,D0
000010C2  E088                    2937m     LSR.L #8,D0
000010C4  5588                    2938m     SUB.L #2,A0
000010C6                          2939mm     PROGRAM D0, (A0), D2
000010C6  3080                    2940mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010C8                          2941mm 
000010C8                          2942mm WAIT_FOR_COMPLETE_193
000010C8  3410                    2943mm         MOVE.W (A0),D2
000010CA                          2944mm 
000010CA                          2945mm         IF.W D2 <NE> D0 THEN
000010CA  B440                    2946mms     CMP.W   D0,D2
000010CC  6700 0004               2947mms     BEQ _00000012
000010D0  60F6                    2948mm             BRA WAIT_FOR_COMPLETE_193
000010D2                          2949mm         ENDI
000010D2                          2950mms _00000012
000010D2                          2951mm         ENDM
000010D2                          2952m     ENDM
000010D2                          2953      ENDF
000010D2  5848                    2954s     ADD.W   #4,A0
000010D4                          2955s _2000000F
000010D4  B0FC 0100               2956s     CMP.W   #START-4,A0
000010D8  6FC0                    2957s     BLE _2000000E
000010DA                          2958                                          
000010DA                          2959m     PROTECT
000010DA  31FC AAAA 2AAA          2960m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010E0  31FC 5555 1554          2961m     MOVE.W #$5555,$1554
000010E6  31FC A0A0 2AAA          2962m     MOVE.W #$A0A0,$2AAA
000010EC                          2963m     ENDM
000010EC                          2964  
000010EC  6000 F256               2965      BRA MAIN_LOOP
000010F0                          2966      
000010F0                          2967  P
000010F0  7000                    2968      MOVE.L #0,D0                                    ; D0 will be the data to write
000010F2                          2969  
000010F2                          2970      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000010F2  323C 0000               2971s     MOVE.W  #0,D1
000010F6  6000 0046               2972s     BRA _20000011
000010FA                          2973s _20000010
000010FA  E988                    2974          LSL.L #4,D0                                 ; make what we have so far more significant
000010FC                          2975m         WAIT_CHAR D2,D3                             ; next character -> D2
000010FC                          2976m WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010FC                 TRUE     2977m     IFEQ DEBUG
000010FC  1639 00C00003           2978m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001102  0803 0000               2979m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001106  67F4                    2980m         BEQ WAIT_FOR_READY_195                      ; NOTHING, CHECK AGAIN
00001108                          2981m     ENDC
00001108                          2982m 
00001108                          2983mm     READ_CHAR D2
00001108                 TRUE     2984mm     IFEQ DEBUG
00001108  1439 00C00007           2985mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000110E                          2986mm     ENDC
0000110E                 FALSE    2987mm     IFNE DEBUG
0000110E                          2988mm     ENDC
0000110E                          2989mm 
0000110E  B43C 001B               2990mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001112  6700 EFF0               2991mm     BEQ START
00001116                          2992mm     ENDM
00001116                          2993m 
00001116                 TRUE     2994m     IFEQ DEBUG
00001116                          2995mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001116                          2996mm WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001116                 TRUE     2997mm     IFEQ DEBUG
00001116  1639 00C00003           2998mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000111C  0803 0002               2999mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001120  67F4                    3000mm         BEQ WAIT_FOR_READY_197                      ; NO SPACE, CHECK AGAIN
00001122  13C2 00C00007           3001mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001128                          3002mm     ENDC
00001128                          3003mm 
00001128                 FALSE    3004mm     IFNE DEBUG
00001128                          3005mm     ENDC
00001128                          3006mm 
00001128                          3007mm     ENDM
00001128                          3008m     ENDC
00001128                          3009m     ENDM
00001128                          3010m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001128  41FA 0BDD               3011m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000112C  0402 0030               3012m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001130  C4BC 000000FF           3013m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001136  1430 2000               3014m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000113A                          3015m     ENDM
0000113A  8002                    3016          OR.B D2,D0
0000113C                          3017      ENDF
0000113C  5241                    3018s     ADD.W   #1,D1
0000113E                          3019s _20000011
0000113E  B27C 0003               3020s     CMP.W   #3,D1
00001142  6FB6                    3021s     BLE _20000010
00001144                          3022  
00001144                          3023m     PRINT_CRLF D2,A1
00001144  43FA 0BEC               3024m     LEA CRLF(PC),A1
00001148                          3025mm     PRINT_STR A1,D2
00001148                          3026mm LOOP_200
00001148  0C11 0000               3027mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000114C  6700 0016               3028mm     BEQ EXIT_200
00001150                          3029mmm     PRINT_CHAR (A1)+,D2
00001150                          3030mmm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001150                 TRUE     3031mmm     IFEQ DEBUG
00001150  1439 00C00003           3032mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001156  0802 0002               3033mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000115A  67F4                    3034mmm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
0000115C  13D9 00C00007           3035mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001162                          3036mmm     ENDC
00001162                          3037mmm 
00001162                 FALSE    3038mmm     IFNE DEBUG
00001162                          3039mmm     ENDC
00001162                          3040mmm 
00001162                          3041mmm     ENDM
00001162  60E4                    3042mm     BRA LOOP_200
00001164                          3043mm EXIT_200
00001164                          3044mm     ENDM
00001164                          3045m     ENDM
00001164                          3046  
00001164  2047                    3047      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001166  7E00                    3048      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001168                          3049  
00001168                          3050m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001168  31FC AAAA 2AAA          3051m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000116E  4E71                    3052m     NOP
00001170  31FC 5555 1554          3053m     MOVE.W #$5555,$1554
00001176  4E71                    3054m     NOP
00001178  31FC 8080 2AAA          3055m     MOVE.W #$8080,$2AAA
0000117E  4E71                    3056m     NOP
00001180  31FC AAAA 2AAA          3057m     MOVE.W #$AAAA,$2AAA
00001186  4E71                    3058m     NOP
00001188  31FC 5555 1554          3059m     MOVE.W #$5555,$1554
0000118E  4E71                    3060m     NOP
00001190  31FC 2020 2AAA          3061m     MOVE.W #$2020,$2AAA
00001196                          3062m     ENDM
00001196                          3063                              
00001196                          3064      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001196  3E3C 0000               3065s     MOVE.W  #$0,D7
0000119A  6000 0006               3066s     BRA _20000013
0000119E                          3067s _20000012
0000119E  4E71                    3068          NOP
000011A0                          3069      ENDF
000011A0  5247                    3070s     ADD.W   #1,D7
000011A2                          3071s _20000013
000011A2  BE7C FFFF               3072s     CMP.W   #$FFFFFFFF,D7
000011A6  6FF6                    3073s     BLE _20000012
000011A8                          3074               
000011A8  45FA 0B74               3075      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
000011AC                          3076m     PRINT_STR A2,D2
000011AC                          3077m LOOP_203
000011AC  0C12 0000               3078m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011B0  6700 0016               3079m     BEQ EXIT_203
000011B4                          3080mm     PRINT_CHAR (A2)+,D2
000011B4                          3081mm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011B4                 TRUE     3082mm     IFEQ DEBUG
000011B4  1439 00C00003           3083mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011BA  0802 0002               3084mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011BE  67F4                    3085mm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
000011C0  13DA 00C00007           3086mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011C6                          3087mm     ENDC
000011C6                          3088mm 
000011C6                 FALSE    3089mm     IFNE DEBUG
000011C6                          3090mm     ENDC
000011C6                          3091mm 
000011C6                          3092mm     ENDM
000011C6  60E4                    3093m     BRA LOOP_203
000011C8                          3094m EXIT_203
000011C8                          3095m     ENDM
000011C8                          3096  
000011C8                          3097m     PRINT_REG D0,D3,D4,D5,A2
000011C8  45FA 0B6E               3098m     LEA OX(PC),A2
000011CC                          3099mm     PRINT_STR A2,D3
000011CC                          3100mm LOOP_206
000011CC  0C12 0000               3101mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D0  6700 0016               3102mm     BEQ EXIT_206
000011D4                          3103mmm     PRINT_CHAR (A2)+,D3
000011D4                          3104mmm WAIT_FOR_READY_207                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011D4                 TRUE     3105mmm     IFEQ DEBUG
000011D4  1639 00C00003           3106mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011DA  0803 0002               3107mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011DE  67F4                    3108mmm         BEQ WAIT_FOR_READY_207                      ; NO SPACE, CHECK AGAIN
000011E0  13DA 00C00007           3109mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011E6                          3110mmm     ENDC
000011E6                          3111mmm 
000011E6                 FALSE    3112mmm     IFNE DEBUG
000011E6                          3113mmm     ENDC
000011E6                          3114mmm 
000011E6                          3115mmm     ENDM
000011E6  60E4                    3116mm     BRA LOOP_206
000011E8                          3117mm EXIT_206
000011E8                          3118mm     ENDM
000011E8  7A07                    3119m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011EA                          3120m LOOP_205
000011EA                          3121mm     BIN2HEX D0,D4,A2
000011EA  45FA 0B0B               3122mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011EE  E998                    3123mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011F0  1800                    3124mm     MOVE.B D0,D4
000011F2  0284 0000000F           3125mm     ANDI.L #$F,D4
000011F8  1832 4000               3126mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011FC                          3127mm     ENDM
000011FC                          3128mm     PRINT_CHAR D4,D3
000011FC                          3129mm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011FC                 TRUE     3130mm     IFEQ DEBUG
000011FC  1639 00C00003           3131mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001202  0803 0002               3132mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001206  67F4                    3133mm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
00001208  13C4 00C00007           3134mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000120E                          3135mm     ENDC
0000120E                          3136mm 
0000120E                 FALSE    3137mm     IFNE DEBUG
0000120E                          3138mm     ENDC
0000120E                          3139mm 
0000120E                          3140mm     ENDM
0000120E  57CD FFDA               3141m     DBEQ D5,LOOP_205
00001212                          3142m     ENDM
00001212                          3143  
00001212  45FA 0B27               3144      LEA TO(PC),A2
00001216                          3145m     PRINT_STR A2,D3
00001216                          3146m LOOP_210
00001216  0C12 0000               3147m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000121A  6700 0016               3148m     BEQ EXIT_210
0000121E                          3149mm     PRINT_CHAR (A2)+,D3
0000121E                          3150mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121E                 TRUE     3151mm     IFEQ DEBUG
0000121E  1639 00C00003           3152mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001224  0803 0002               3153mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001228  67F4                    3154mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0000122A  13DA 00C00007           3155mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001230                          3156mm     ENDC
00001230                          3157mm 
00001230                 FALSE    3158mm     IFNE DEBUG
00001230                          3159mm     ENDC
00001230                          3160mm 
00001230                          3161mm     ENDM
00001230  60E4                    3162m     BRA LOOP_210
00001232                          3163m EXIT_210
00001232                          3164m     ENDM
00001232                          3165  
00001232  2408                    3166      MOVE.L A0,D2
00001234                          3167m     PRINT_REG D2,D3,D4,D5,A2
00001234  45FA 0B02               3168m     LEA OX(PC),A2
00001238                          3169mm     PRINT_STR A2,D3
00001238                          3170mm LOOP_213
00001238  0C12 0000               3171mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000123C  6700 0016               3172mm     BEQ EXIT_213
00001240                          3173mmm     PRINT_CHAR (A2)+,D3
00001240                          3174mmm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001240                 TRUE     3175mmm     IFEQ DEBUG
00001240  1639 00C00003           3176mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001246  0803 0002               3177mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000124A  67F4                    3178mmm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
0000124C  13DA 00C00007           3179mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001252                          3180mmm     ENDC
00001252                          3181mmm 
00001252                 FALSE    3182mmm     IFNE DEBUG
00001252                          3183mmm     ENDC
00001252                          3184mmm 
00001252                          3185mmm     ENDM
00001252  60E4                    3186mm     BRA LOOP_213
00001254                          3187mm EXIT_213
00001254                          3188mm     ENDM
00001254  7A07                    3189m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001256                          3190m LOOP_212
00001256                          3191mm     BIN2HEX D2,D4,A2
00001256  45FA 0A9F               3192mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000125A  E99A                    3193mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000125C  1802                    3194mm     MOVE.B D2,D4
0000125E  0284 0000000F           3195mm     ANDI.L #$F,D4
00001264  1832 4000               3196mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001268                          3197mm     ENDM
00001268                          3198mm     PRINT_CHAR D4,D3
00001268                          3199mm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001268                 TRUE     3200mm     IFEQ DEBUG
00001268  1639 00C00003           3201mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126E  0803 0002               3202mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001272  67F4                    3203mm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001274  13C4 00C00007           3204mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000127A                          3205mm     ENDC
0000127A                          3206mm 
0000127A                 FALSE    3207mm     IFNE DEBUG
0000127A                          3208mm     ENDC
0000127A                          3209mm 
0000127A                          3210mm     ENDM
0000127A  57CD FFDA               3211m     DBEQ D5,LOOP_212
0000127E                          3212m     ENDM
0000127E                          3213  
0000127E                          3214m     PRINT_CRLF D3,A2
0000127E  45FA 0AB2               3215m     LEA CRLF(PC),A2
00001282                          3216mm     PRINT_STR A2,D3
00001282                          3217mm LOOP_218
00001282  0C12 0000               3218mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001286  6700 0016               3219mm     BEQ EXIT_218
0000128A                          3220mmm     PRINT_CHAR (A2)+,D3
0000128A                          3221mmm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000128A                 TRUE     3222mmm     IFEQ DEBUG
0000128A  1639 00C00003           3223mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001290  0803 0002               3224mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001294  67F4                    3225mmm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
00001296  13DA 00C00007           3226mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000129C                          3227mmm     ENDC
0000129C                          3228mmm 
0000129C                 FALSE    3229mmm     IFNE DEBUG
0000129C                          3230mmm     ENDC
0000129C                          3231mmm 
0000129C                          3232mmm     ENDM
0000129C  60E4                    3233mm     BRA LOOP_218
0000129E                          3234mm EXIT_218
0000129E                          3235mm     ENDM
0000129E                          3236m     ENDM
0000129E                          3237  
0000129E                          3238m     PROGRAM D0,(A0),D2
0000129E  3080                    3239m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000012A0                          3240m 
000012A0                          3241m WAIT_FOR_COMPLETE_220
000012A0  3410                    3242m         MOVE.W (A0),D2
000012A2                          3243m 
000012A2                          3244m         IF.W D2 <NE> D0 THEN
000012A2  B440                    3245ms     CMP.W   D0,D2
000012A4  6700 0004               3246ms     BEQ _00000013
000012A8  60F6                    3247m             BRA WAIT_FOR_COMPLETE_220
000012AA                          3248m         ENDI
000012AA                          3249ms _00000013
000012AA                          3250m         ENDM
000012AA                          3251  
000012AA                          3252m     PROTECT
000012AA  31FC AAAA 2AAA          3253m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000012B0  31FC 5555 1554          3254m     MOVE.W #$5555,$1554
000012B6  31FC A0A0 2AAA          3255m     MOVE.W #$A0A0,$2AAA
000012BC                          3256m     ENDM
000012BC                          3257  
000012BC  6000 F086               3258      BRA MAIN_LOOP
000012C0                          3259      
000012C0                          3260  X
000012C0  45FA 0A89               3261      LEA STATUS_REGISTER(PC),A2
000012C4                          3262m     PRINT_STR A2,D3
000012C4                          3263m LOOP_222
000012C4  0C12 0000               3264m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012C8  6700 0016               3265m     BEQ EXIT_222
000012CC                          3266mm     PRINT_CHAR (A2)+,D3
000012CC                          3267mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012CC                 TRUE     3268mm     IFEQ DEBUG
000012CC  1639 00C00003           3269mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012D2  0803 0002               3270mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012D6  67F4                    3271mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
000012D8  13DA 00C00007           3272mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012DE                          3273mm     ENDC
000012DE                          3274mm 
000012DE                 FALSE    3275mm     IFNE DEBUG
000012DE                          3276mm     ENDC
000012DE                          3277mm 
000012DE                          3278mm     ENDM
000012DE  60E4                    3279m     BRA LOOP_222
000012E0                          3280m EXIT_222
000012E0                          3281m     ENDM
000012E0                          3282  
000012E0  40C0                    3283      MOVE SR,D0
000012E2                          3284m     PRINT_REG D0,D3,D4,D5,A2
000012E2  45FA 0A54               3285m     LEA OX(PC),A2
000012E6                          3286mm     PRINT_STR A2,D3
000012E6                          3287mm LOOP_225
000012E6  0C12 0000               3288mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012EA  6700 0016               3289mm     BEQ EXIT_225
000012EE                          3290mmm     PRINT_CHAR (A2)+,D3
000012EE                          3291mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012EE                 TRUE     3292mmm     IFEQ DEBUG
000012EE  1639 00C00003           3293mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012F4  0803 0002               3294mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012F8  67F4                    3295mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012FA  13DA 00C00007           3296mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001300                          3297mmm     ENDC
00001300                          3298mmm 
00001300                 FALSE    3299mmm     IFNE DEBUG
00001300                          3300mmm     ENDC
00001300                          3301mmm 
00001300                          3302mmm     ENDM
00001300  60E4                    3303mm     BRA LOOP_225
00001302                          3304mm EXIT_225
00001302                          3305mm     ENDM
00001302  7A07                    3306m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001304                          3307m LOOP_224
00001304                          3308mm     BIN2HEX D0,D4,A2
00001304  45FA 09F1               3309mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001308  E998                    3310mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000130A  1800                    3311mm     MOVE.B D0,D4
0000130C  0284 0000000F           3312mm     ANDI.L #$F,D4
00001312  1832 4000               3313mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001316                          3314mm     ENDM
00001316                          3315mm     PRINT_CHAR D4,D3
00001316                          3316mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001316                 TRUE     3317mm     IFEQ DEBUG
00001316  1639 00C00003           3318mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000131C  0803 0002               3319mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001320  67F4                    3320mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
00001322  13C4 00C00007           3321mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001328                          3322mm     ENDC
00001328                          3323mm 
00001328                 FALSE    3324mm     IFNE DEBUG
00001328                          3325mm     ENDC
00001328                          3326mm 
00001328                          3327mm     ENDM
00001328  57CD FFDA               3328m     DBEQ D5,LOOP_224
0000132C                          3329m     ENDM
0000132C                          3330m     PRINT_CRLF D3,A2
0000132C  45FA 0A04               3331m     LEA CRLF(PC),A2
00001330                          3332mm     PRINT_STR A2,D3
00001330                          3333mm LOOP_230
00001330  0C12 0000               3334mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001334  6700 0016               3335mm     BEQ EXIT_230
00001338                          3336mmm     PRINT_CHAR (A2)+,D3
00001338                          3337mmm WAIT_FOR_READY_231                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001338                 TRUE     3338mmm     IFEQ DEBUG
00001338  1639 00C00003           3339mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000133E  0803 0002               3340mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001342  67F4                    3341mmm         BEQ WAIT_FOR_READY_231                      ; NO SPACE, CHECK AGAIN
00001344  13DA 00C00007           3342mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000134A                          3343mmm     ENDC
0000134A                          3344mmm 
0000134A                 FALSE    3345mmm     IFNE DEBUG
0000134A                          3346mmm     ENDC
0000134A                          3347mmm 
0000134A                          3348mmm     ENDM
0000134A  60E4                    3349mm     BRA LOOP_230
0000134C                          3350mm EXIT_230
0000134C                          3351mm     ENDM
0000134C                          3352m     ENDM
0000134C                          3353  
0000134C  45FA 09F8               3354      LEA STACK_POINTER(PC),A2
00001350                          3355m     PRINT_STR A2,D3
00001350                          3356m LOOP_232
00001350  0C12 0000               3357m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001354  6700 0016               3358m     BEQ EXIT_232
00001358                          3359mm     PRINT_CHAR (A2)+,D3
00001358                          3360mm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001358                 TRUE     3361mm     IFEQ DEBUG
00001358  1639 00C00003           3362mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000135E  0803 0002               3363mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001362  67F4                    3364mm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001364  13DA 00C00007           3365mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000136A                          3366mm     ENDC
0000136A                          3367mm 
0000136A                 FALSE    3368mm     IFNE DEBUG
0000136A                          3369mm     ENDC
0000136A                          3370mm 
0000136A                          3371mm     ENDM
0000136A  60E4                    3372m     BRA LOOP_232
0000136C                          3373m EXIT_232
0000136C                          3374m     ENDM
0000136C                          3375  
0000136C  200F                    3376      MOVE.L SP,D0
0000136E                          3377m     PRINT_REG D0,D3,D4,D5,A2
0000136E  45FA 09C8               3378m     LEA OX(PC),A2
00001372                          3379mm     PRINT_STR A2,D3
00001372                          3380mm LOOP_235
00001372  0C12 0000               3381mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001376  6700 0016               3382mm     BEQ EXIT_235
0000137A                          3383mmm     PRINT_CHAR (A2)+,D3
0000137A                          3384mmm WAIT_FOR_READY_236                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000137A                 TRUE     3385mmm     IFEQ DEBUG
0000137A  1639 00C00003           3386mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001380  0803 0002               3387mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001384  67F4                    3388mmm         BEQ WAIT_FOR_READY_236                      ; NO SPACE, CHECK AGAIN
00001386  13DA 00C00007           3389mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000138C                          3390mmm     ENDC
0000138C                          3391mmm 
0000138C                 FALSE    3392mmm     IFNE DEBUG
0000138C                          3393mmm     ENDC
0000138C                          3394mmm 
0000138C                          3395mmm     ENDM
0000138C  60E4                    3396mm     BRA LOOP_235
0000138E                          3397mm EXIT_235
0000138E                          3398mm     ENDM
0000138E  7A07                    3399m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001390                          3400m LOOP_234
00001390                          3401mm     BIN2HEX D0,D4,A2
00001390  45FA 0965               3402mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001394  E998                    3403mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001396  1800                    3404mm     MOVE.B D0,D4
00001398  0284 0000000F           3405mm     ANDI.L #$F,D4
0000139E  1832 4000               3406mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000013A2                          3407mm     ENDM
000013A2                          3408mm     PRINT_CHAR D4,D3
000013A2                          3409mm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013A2                 TRUE     3410mm     IFEQ DEBUG
000013A2  1639 00C00003           3411mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013A8  0803 0002               3412mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013AC  67F4                    3413mm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
000013AE  13C4 00C00007           3414mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013B4                          3415mm     ENDC
000013B4                          3416mm 
000013B4                 FALSE    3417mm     IFNE DEBUG
000013B4                          3418mm     ENDC
000013B4                          3419mm 
000013B4                          3420mm     ENDM
000013B4  57CD FFDA               3421m     DBEQ D5,LOOP_234
000013B8                          3422m     ENDM
000013B8                          3423m     PRINT_CRLF D3,A2
000013B8  45FA 0978               3424m     LEA CRLF(PC),A2
000013BC                          3425mm     PRINT_STR A2,D3
000013BC                          3426mm LOOP_240
000013BC  0C12 0000               3427mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013C0  6700 0016               3428mm     BEQ EXIT_240
000013C4                          3429mmm     PRINT_CHAR (A2)+,D3
000013C4                          3430mmm WAIT_FOR_READY_241                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013C4                 TRUE     3431mmm     IFEQ DEBUG
000013C4  1639 00C00003           3432mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013CA  0803 0002               3433mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013CE  67F4                    3434mmm         BEQ WAIT_FOR_READY_241                      ; NO SPACE, CHECK AGAIN
000013D0  13DA 00C00007           3435mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013D6                          3436mmm     ENDC
000013D6                          3437mmm 
000013D6                 FALSE    3438mmm     IFNE DEBUG
000013D6                          3439mmm     ENDC
000013D6                          3440mmm 
000013D6                          3441mmm     ENDM
000013D6  60E4                    3442mm     BRA LOOP_240
000013D8                          3443mm EXIT_240
000013D8                          3444mm     ENDM
000013D8                          3445m     ENDM
000013D8                          3446  
000013D8  6000 EF6A               3447      BRA MAIN_LOOP
000013DC                          3448          
000013DC                          3449  I
000013DC  13FC 0008 00C0000B      3450      MOVE.B #8,DUART_IMR
000013E4  027C F8FF               3451      AND.W #$F8FF,SR
000013E8  6000 EF5A               3452      BRA MAIN_LOOP
000013EC                          3453      
000013EC                          3454  O
000013EC  13FC 0000 00C0000B      3455      MOVE.B #0,DUART_IMR
000013F4  007C 0700               3456      OR.W #$0700,SR
000013F8  6000 EF4A               3457      BRA MAIN_LOOP
000013FC                          3458          
000013FC                          3459  HASH
000013FC                          3460m     PROTECT
000013FC  31FC AAAA 2AAA          3461m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001402  31FC 5555 1554          3462m     MOVE.W #$5555,$1554
00001408  31FC A0A0 2AAA          3463m     MOVE.W #$A0A0,$2AAA
0000140E                          3464m     ENDM
0000140E  6000 EF34               3465      BRA MAIN_LOOP
00001412                          3466      
00001412                          3467  B
00001412  13FC 0038 00A00019      3468      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000141A                          3469      
0000141A                          3470m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
0000141A  13FC 00FF 00A00007      3471m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001422  103C 0030               3472m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001426  0000 0006               3473m     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000142A  13C0 00A00019           3474m     MOVE.B D0, MC68230_PORT_C_DATA
00001430  0200 00EF               3475m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001434  13FC 00E0 00A00013      3476m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
0000143C  13C0 00A00019           3477m     MOVE.B D0, MC68230_PORT_C_DATA
00001442  0000 0010               3478m     ORI.B #MC68230_PORT_C_WRITE, D0
00001446  13C0 00A00019           3479m     MOVE.B D0, MC68230_PORT_C_DATA
0000144C  13FC 0038 00A00019      3480m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001454                          3481m     ENDM
00001454                          3482m     WAIT_DRIVE_READY D0, D1
00001454                          3483m LOOP_244
00001454                          3484mm     READ_IDE_STATUS D0, D1
00001454                          3485mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001454  13FC 0000 00A00007      3486mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000145C  123C 0030               3487mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001460  0001 0007               3488mmm     ORI.B #IDE_STATUS_REGISTER, D1
00001464  13C1 00A00019           3489mmm     MOVE.B D1, MC68230_PORT_C_DATA
0000146A  0201 00DF               3490mmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000146E  13C1 00A00019           3491mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001474  1039 00A00013           3492mmm     MOVE.B MC68230_PORT_B_DATA, D0
0000147A  0001 0020               3493mmm     ORI.B #MC68230_PORT_C_READ, D1
0000147E  13C1 00A00019           3494mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001484  13FC 0038 00A00019      3495mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000148C                          3496mmm     ENDM
0000148C                          3497mm     ENDM
0000148C  0800 0006               3498m     BTST #IDE_STATUS_READY, D0
00001490  67C2                    3499m     BEQ LOOP_244
00001492                          3500m     ENDM
00001492                          3501          
00001492  263C 00000201           3502      MOVE.L #513,D3
00001498                          3503      
00001498  7801                    3504      MOVE.L #1, D4                           ; flag for first iteration
0000149A  7A01                    3505      MOVE.L #1, D5                           ; sentinel to prime the loop
0000149C                          3506      WHILE D5 <GT> #0 DO
0000149C                          3507s _10000016
0000149C  BA7C 0000               3508s     CMP.W   #0,D5
000014A0  6F00 049C               3509s     BLE _10000017
000014A4                          3510m         SEND_READ_COMMAND_AND_WAIT D3, D0, D1, D2
000014A4                          3511mm     WAIT_DRIVE_NOT_BUSY D0, D1
000014A4                          3512mm LOOP_248
000014A4                          3513mmm     READ_IDE_STATUS D0, D1
000014A4                          3514mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000014A4  13FC 0000 00A00007      3515mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014AC  123C 0030               3516mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000014B0  0001 0007               3517mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000014B4  13C1 00A00019           3518mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014BA  0201 00DF               3519mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000014BE  13C1 00A00019           3520mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014C4  1039 00A00013           3521mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000014CA  0001 0020               3522mmmm     ORI.B #MC68230_PORT_C_READ, D1
000014CE  13C1 00A00019           3523mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014D4  13FC 0038 00A00019      3524mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014DC                          3525mmmm     ENDM
000014DC                          3526mmm     ENDM
000014DC  0800 0007               3527mm     BTST #IDE_STATUS_BUSY, D0
000014E0  66C2                    3528mm     BNE LOOP_248
000014E2                          3529mm     ENDM
000014E2                          3530mm     SET_READ_ADDRESS D3, D0, D1, D2
000014E2                          3531mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
000014E2  13FC 00FF 00A00007      3532mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014EA  103C 0030               3533mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014EE  0000 0002               3534mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
000014F2  13C0 00A00019           3535mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014F8  0200 00EF               3536mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014FC  13FC 0001 00A00013      3537mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001504  13C0 00A00019           3538mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000150A  0000 0010               3539mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000150E  13C0 00A00019           3540mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001514  13FC 0038 00A00019      3541mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000151C                          3542mmm     ENDM
0000151C  2203                    3543mm     MOVE.L D3,D1
0000151E                          3544mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
0000151E  13FC 00FF 00A00007      3545mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001526  103C 0030               3546mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000152A  0000 0003               3547mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
0000152E  13C0 00A00019           3548mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001534  0200 00EF               3549mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001538  13C1 00A00013           3550mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000153E  13C0 00A00019           3551mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001544  0000 0010               3552mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001548  13C0 00A00019           3553mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000154E  13FC 0038 00A00019      3554mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001556                          3555mmm     ENDM
00001556  E089                    3556mm     LSR.L #8, D1
00001558                          3557mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001558  13FC 00FF 00A00007      3558mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001560  103C 0030               3559mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001564  0000 0004               3560mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
00001568  13C0 00A00019           3561mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000156E  0200 00EF               3562mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001572  13C1 00A00013           3563mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001578  13C0 00A00019           3564mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000157E  0000 0010               3565mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001582  13C0 00A00019           3566mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001588  13FC 0038 00A00019      3567mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001590                          3568mmm     ENDM
00001590  E089                    3569mm     LSR.L #8, D1                                
00001592                          3570mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
00001592  13FC 00FF 00A00007      3571mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000159A  103C 0030               3572mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000159E  0000 0005               3573mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
000015A2  13C0 00A00019           3574mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015A8  0200 00EF               3575mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000015AC  13C1 00A00013           3576mmm     MOVE.B D1, MC68230_PORT_B_DATA
000015B2  13C0 00A00019           3577mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015B8  0000 0010               3578mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000015BC  13C0 00A00019           3579mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015C2  13FC 0038 00A00019      3580mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015CA                          3581mmm     ENDM
000015CA  E089                    3582mm     LSR.L #8, D1
000015CC                          3583mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
000015CC  13FC 0000 00A00007      3584mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015D4  103C 0030               3585mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000015D8  0000 0006               3586mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000015DC  13C0 00A00019           3587mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015E2  0200 00DF               3588mmm     ANDI.B #~MC68230_PORT_C_READ, D0
000015E6  13C0 00A00019           3589mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015EC  1439 00A00013           3590mmm     MOVE.B MC68230_PORT_B_DATA, D2
000015F2  0000 0020               3591mmm     ORI.B #MC68230_PORT_C_READ, D0
000015F6  13C0 00A00019           3592mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015FC  13FC 0038 00A00019      3593mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001604                          3594mmm     ENDM
00001604  0201 000F               3595mm     ANDI.B #$0F,D1
00001608  8401                    3596mm     OR.B D1,D2
0000160A                          3597mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
0000160A  13FC 00FF 00A00007      3598mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001612  103C 0030               3599mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001616  0000 0006               3600mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000161A  13C0 00A00019           3601mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001620  0200 00EF               3602mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001624  13C2 00A00013           3603mmm     MOVE.B D2, MC68230_PORT_B_DATA
0000162A  13C0 00A00019           3604mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001630  0000 0010               3605mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001634  13C0 00A00019           3606mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000163A  13FC 0038 00A00019      3607mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001642                          3608mmm     ENDM
00001642                          3609mm     ENDM
00001642                          3610mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
00001642                          3611mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
00001642  13FC 00FF 00A00007      3612mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000164A  103C 0030               3613mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000164E  0000 0007               3614mmm     ORI.B #IDE_COMMAND_REGISTER, D0
00001652  13C0 00A00019           3615mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001658  0200 00EF               3616mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000165C  13FC 0020 00A00013      3617mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001664  13C0 00A00019           3618mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000166A  0000 0010               3619mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000166E  13C0 00A00019           3620mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001674  13FC 0038 00A00019      3621mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000167C                          3622mmm     ENDM
0000167C                          3623mm     ENDM
0000167C                          3624mm     WAIT_DRIVE_NOT_BUSY D0, D1
0000167C                          3625mm LOOP_260
0000167C                          3626mmm     READ_IDE_STATUS D0, D1
0000167C                          3627mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
0000167C  13FC 0000 00A00007      3628mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001684  123C 0030               3629mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001688  0001 0007               3630mmmm     ORI.B #IDE_STATUS_REGISTER, D1
0000168C  13C1 00A00019           3631mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001692  0201 00DF               3632mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001696  13C1 00A00019           3633mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000169C  1039 00A00013           3634mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000016A2  0001 0020               3635mmmm     ORI.B #MC68230_PORT_C_READ, D1
000016A6  13C1 00A00019           3636mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016AC  13FC 0038 00A00019      3637mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016B4                          3638mmmm     ENDM
000016B4                          3639mmm     ENDM
000016B4  0800 0007               3640mm     BTST #IDE_STATUS_BUSY, D0
000016B8  66C2                    3641mm     BNE LOOP_260
000016BA                          3642mm     ENDM
000016BA                          3643mm     WAIT_DRIVE_DRQ D0, D1
000016BA                          3644mm LOOP_263
000016BA                          3645mmm     READ_IDE_STATUS D0, D1
000016BA                          3646mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000016BA  13FC 0000 00A00007      3647mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016C2  123C 0030               3648mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000016C6  0001 0007               3649mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000016CA  13C1 00A00019           3650mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016D0  0201 00DF               3651mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000016D4  13C1 00A00019           3652mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016DA  1039 00A00013           3653mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000016E0  0001 0020               3654mmmm     ORI.B #MC68230_PORT_C_READ, D1
000016E4  13C1 00A00019           3655mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016EA  13FC 0038 00A00019      3656mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016F2                          3657mmmm     ENDM
000016F2                          3658mmm     ENDM
000016F2  0800 0003               3659mm     BTST #IDE_STATUS_DRQ, D0
000016F6  67C2                    3660mm     BEQ LOOP_263
000016F8                          3661mm     ENDM
000016F8                          3662m     ENDM
000016F8                          3663m         PRINT_CHAR #'.', D1
000016F8                          3664m WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016F8                 TRUE     3665m     IFEQ DEBUG
000016F8  1239 00C00003           3666m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000016FE  0801 0002               3667m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001702  67F4                    3668m         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
00001704  13FC 002E 00C00007      3669m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000170C                          3670m     ENDC
0000170C                          3671m 
0000170C                 FALSE    3672m     IFNE DEBUG
0000170C                          3673m     ENDC
0000170C                          3674m 
0000170C                          3675m     ENDM
0000170C                          3676          
0000170C                          3677          IF D4 <EQ> #1 THEN
0000170C  B87C 0001               3678s     CMP.W   #1,D4
00001710  6600 01C8               3679s     BNE _00000014
00001714                          3680m             READ_32 #IDE_DATA_REGISTER, D2, D1      ; start -> D2
00001714                          3681mm     READ_16 #IDE_DATA_REGISTER, D2, D1
00001714  13FC 0000 00A00007      3682mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000171C  13FC 0000 00A00005      3683mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001724                          3684mm     
00001724  123C 0030               3685mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001728  0001 0000               3686mm     ORI.B #IDE_DATA_REGISTER, D1
0000172C  13C1 00A00019           3687mm     MOVE.B D1, MC68230_PORT_C_DATA
00001732  0201 00DF               3688mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001736  13C1 00A00019           3689mm     MOVE.B D1, MC68230_PORT_C_DATA
0000173C  1439 00A00011           3690mm     MOVE.B MC68230_PORT_A_DATA, D2
00001742  E14A                    3691mm     LSL.W #8, D2
00001744  1439 00A00013           3692mm     MOVE.B MC68230_PORT_B_DATA, D2
0000174A  0001 0020               3693mm     ORI.B #MC68230_PORT_C_READ, D1
0000174E  13C1 00A00019           3694mm     MOVE.B D1, MC68230_PORT_C_DATA
00001754  13FC 0038 00A00019      3695mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000175C                          3696mm     ENDM
0000175C  E18A                    3697m     LSL.L #8, D2
0000175E  E18A                    3698m     LSL.L #8, D2
00001760                          3699mm     READ_16 #IDE_DATA_REGISTER, D2, D1
00001760  13FC 0000 00A00007      3700mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001768  13FC 0000 00A00005      3701mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001770                          3702mm     
00001770  123C 0030               3703mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001774  0001 0000               3704mm     ORI.B #IDE_DATA_REGISTER, D1
00001778  13C1 00A00019           3705mm     MOVE.B D1, MC68230_PORT_C_DATA
0000177E  0201 00DF               3706mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001782  13C1 00A00019           3707mm     MOVE.B D1, MC68230_PORT_C_DATA
00001788  1439 00A00011           3708mm     MOVE.B MC68230_PORT_A_DATA, D2
0000178E  E14A                    3709mm     LSL.W #8, D2
00001790  1439 00A00013           3710mm     MOVE.B MC68230_PORT_B_DATA, D2
00001796  0001 0020               3711mm     ORI.B #MC68230_PORT_C_READ, D1
0000179A  13C1 00A00019           3712mm     MOVE.B D1, MC68230_PORT_C_DATA
000017A0  13FC 0038 00A00019      3713mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017A8                          3714mm     ENDM
000017A8                          3715m     ENDM
000017A8  2042                    3716              MOVE.L D2, A0                           ; set up target         
000017AA                          3717m             READ_32 #IDE_DATA_REGISTER, D5, D1      ; end -> D5
000017AA                          3718mm     READ_16 #IDE_DATA_REGISTER, D5, D1
000017AA  13FC 0000 00A00007      3719mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000017B2  13FC 0000 00A00005      3720mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000017BA                          3721mm     
000017BA  123C 0030               3722mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000017BE  0001 0000               3723mm     ORI.B #IDE_DATA_REGISTER, D1
000017C2  13C1 00A00019           3724mm     MOVE.B D1, MC68230_PORT_C_DATA
000017C8  0201 00DF               3725mm     ANDI.B #~MC68230_PORT_C_READ, D1
000017CC  13C1 00A00019           3726mm     MOVE.B D1, MC68230_PORT_C_DATA
000017D2  1A39 00A00011           3727mm     MOVE.B MC68230_PORT_A_DATA, D5
000017D8  E14D                    3728mm     LSL.W #8, D5
000017DA  1A39 00A00013           3729mm     MOVE.B MC68230_PORT_B_DATA, D5
000017E0  0001 0020               3730mm     ORI.B #MC68230_PORT_C_READ, D1
000017E4  13C1 00A00019           3731mm     MOVE.B D1, MC68230_PORT_C_DATA
000017EA  13FC 0038 00A00019      3732mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017F2                          3733mm     ENDM
000017F2  E18D                    3734m     LSL.L #8, D5
000017F4  E18D                    3735m     LSL.L #8, D5
000017F6                          3736mm     READ_16 #IDE_DATA_REGISTER, D5, D1
000017F6  13FC 0000 00A00007      3737mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000017FE  13FC 0000 00A00005      3738mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001806                          3739mm     
00001806  123C 0030               3740mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
0000180A  0001 0000               3741mm     ORI.B #IDE_DATA_REGISTER, D1
0000180E  13C1 00A00019           3742mm     MOVE.B D1, MC68230_PORT_C_DATA
00001814  0201 00DF               3743mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001818  13C1 00A00019           3744mm     MOVE.B D1, MC68230_PORT_C_DATA
0000181E  1A39 00A00011           3745mm     MOVE.B MC68230_PORT_A_DATA, D5
00001824  E14D                    3746mm     LSL.W #8, D5
00001826  1A39 00A00013           3747mm     MOVE.B MC68230_PORT_B_DATA, D5
0000182C  0001 0020               3748mm     ORI.B #MC68230_PORT_C_READ, D1
00001830  13C1 00A00019           3749mm     MOVE.B D1, MC68230_PORT_C_DATA
00001836  13FC 0038 00A00019      3750mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000183E                          3751mm     ENDM
0000183E                          3752m     ENDM
0000183E  9A82                    3753              SUB.L D2, D5                            ; work out num bytes
00001840                          3754m             READ_32 #IDE_DATA_REGISTER, D7, D1      ; read entry point into address accumulator
00001840                          3755mm     READ_16 #IDE_DATA_REGISTER, D7, D1
00001840  13FC 0000 00A00007      3756mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001848  13FC 0000 00A00005      3757mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001850                          3758mm     
00001850  123C 0030               3759mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001854  0001 0000               3760mm     ORI.B #IDE_DATA_REGISTER, D1
00001858  13C1 00A00019           3761mm     MOVE.B D1, MC68230_PORT_C_DATA
0000185E  0201 00DF               3762mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001862  13C1 00A00019           3763mm     MOVE.B D1, MC68230_PORT_C_DATA
00001868  1E39 00A00011           3764mm     MOVE.B MC68230_PORT_A_DATA, D7
0000186E  E14F                    3765mm     LSL.W #8, D7
00001870  1E39 00A00013           3766mm     MOVE.B MC68230_PORT_B_DATA, D7
00001876  0001 0020               3767mm     ORI.B #MC68230_PORT_C_READ, D1
0000187A  13C1 00A00019           3768mm     MOVE.B D1, MC68230_PORT_C_DATA
00001880  13FC 0038 00A00019      3769mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001888                          3770mm     ENDM
00001888  E18F                    3771m     LSL.L #8, D7
0000188A  E18F                    3772m     LSL.L #8, D7
0000188C                          3773mm     READ_16 #IDE_DATA_REGISTER, D7, D1
0000188C  13FC 0000 00A00007      3774mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001894  13FC 0000 00A00005      3775mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000189C                          3776mm     
0000189C  123C 0030               3777mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000018A0  0001 0000               3778mm     ORI.B #IDE_DATA_REGISTER, D1
000018A4  13C1 00A00019           3779mm     MOVE.B D1, MC68230_PORT_C_DATA
000018AA  0201 00DF               3780mm     ANDI.B #~MC68230_PORT_C_READ, D1
000018AE  13C1 00A00019           3781mm     MOVE.B D1, MC68230_PORT_C_DATA
000018B4  1E39 00A00011           3782mm     MOVE.B MC68230_PORT_A_DATA, D7
000018BA  E14F                    3783mm     LSL.W #8, D7
000018BC  1E39 00A00013           3784mm     MOVE.B MC68230_PORT_B_DATA, D7
000018C2  0001 0020               3785mm     ORI.B #MC68230_PORT_C_READ, D1
000018C6  13C1 00A00019           3786mm     MOVE.B D1, MC68230_PORT_C_DATA
000018CC  13FC 0038 00A00019      3787mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000018D4                          3788mm     ENDM
000018D4                          3789m     ENDM
000018D4  7406                    3790              MOVE.L #6, D2                           ; words read so far
000018D6                          3791          ELSE
000018D6  6000 0004               3792s     BRA _00000015
000018DA                          3793s _00000014
000018DA  7400                    3794              MOVE.L #0, D2                           ; words read so far
000018DC                          3795          ENDI
000018DC                          3796s _00000015
000018DC                          3797              
000018DC                          3798          FOR D6 = D2 TO #255 DO
000018DC  3C02                    3799s     MOVE.W  D2,D6
000018DE  6000 0050               3800s     BRA _20000015
000018E2                          3801s _20000014
000018E2                          3802m             READ_16 #IDE_DATA_REGISTER, D0, D1
000018E2  13FC 0000 00A00007      3803m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000018EA  13FC 0000 00A00005      3804m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000018F2                          3805m     
000018F2  123C 0030               3806m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000018F6  0001 0000               3807m     ORI.B #IDE_DATA_REGISTER, D1
000018FA  13C1 00A00019           3808m     MOVE.B D1, MC68230_PORT_C_DATA
00001900  0201 00DF               3809m     ANDI.B #~MC68230_PORT_C_READ, D1
00001904  13C1 00A00019           3810m     MOVE.B D1, MC68230_PORT_C_DATA
0000190A  1039 00A00011           3811m     MOVE.B MC68230_PORT_A_DATA, D0
00001910  E148                    3812m     LSL.W #8, D0
00001912  1039 00A00013           3813m     MOVE.B MC68230_PORT_B_DATA, D0
00001918  0001 0020               3814m     ORI.B #MC68230_PORT_C_READ, D1
0000191C  13C1 00A00019           3815m     MOVE.B D1, MC68230_PORT_C_DATA
00001922  13FC 0038 00A00019      3816m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000192A                          3817m     ENDM
0000192A  30C0                    3818              MOVE.W D0,(A0)+
0000192C  5585                    3819              SUB.L #2, D5
0000192E                          3820          ENDF
0000192E  5246                    3821s     ADD.W   #1,D6
00001930                          3822s _20000015
00001930  BC7C 00FF               3823s     CMP.W   #255,D6
00001934  6FAC                    3824s     BLE _20000014
00001936                          3825          
00001936  5283                    3826          ADD.L #1, D3                                ; next block
00001938  7800                    3827          MOVE.L #0, D4                               ; not the first anymore
0000193A                          3828      ENDW
0000193A  6000 FB60               3829s     BRA _10000016
0000193E                          3830s _10000017
0000193E                          3831  
0000193E                          3832m     PRINT_CRLF D3,A3
0000193E  47FA 03F2               3833m     LEA CRLF(PC),A3
00001942                          3834mm     PRINT_STR A3,D3
00001942                          3835mm LOOP_278
00001942  0C13 0000               3836mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001946  6700 0016               3837mm     BEQ EXIT_278
0000194A                          3838mmm     PRINT_CHAR (A3)+,D3
0000194A                          3839mmm WAIT_FOR_READY_279                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000194A                 TRUE     3840mmm     IFEQ DEBUG
0000194A  1639 00C00003           3841mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001950  0803 0002               3842mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001954  67F4                    3843mmm         BEQ WAIT_FOR_READY_279                      ; NO SPACE, CHECK AGAIN
00001956  13DB 00C00007           3844mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000195C                          3845mmm     ENDC
0000195C                          3846mmm 
0000195C                 FALSE    3847mmm     IFNE DEBUG
0000195C                          3848mmm     ENDC
0000195C                          3849mmm 
0000195C                          3850mmm     ENDM
0000195C  60E4                    3851mm     BRA LOOP_278
0000195E                          3852mm EXIT_278
0000195E                          3853mm     ENDM
0000195E                          3854m     ENDM
0000195E                          3855      
0000195E  6000 E9E4               3856      BRA MAIN_LOOP
00001962                          3857  
00001962                          3858  HEX_DIGIT
00001962  E98F                    3859      LSL.L #4,D7                                     ; add the next digit in the next 4 bits
00001964                          3860m     HEX2BIN D2,D2,A0
00001964  41FA 03A1               3861m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001968  0402 0030               3862m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000196C  C4BC 000000FF           3863m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001972  1430 2000               3864m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001976                          3865m     ENDM
00001976  8E02                    3866      OR.B D2,D7  
00001978  6000 E9EA               3867      BRA GET_INPUT
0000197C                          3868  
0000197C                          3869  ; exceptions    
0000197C                          3870  BUS_ERROR_HANDLER
0000197C                          3871  
0000197C  41FA 03D9               3872      LEA BUS_ERROR(PC),A0
00001980                          3873m     PRINT_STR A0,D1
00001980                          3874m LOOP_281
00001980  0C10 0000               3875m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001984  6700 0016               3876m     BEQ EXIT_281
00001988                          3877mm     PRINT_CHAR (A0)+,D1
00001988                          3878mm WAIT_FOR_READY_282                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001988                 TRUE     3879mm     IFEQ DEBUG
00001988  1239 00C00003           3880mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000198E  0801 0002               3881mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001992  67F4                    3882mm         BEQ WAIT_FOR_READY_282                      ; NO SPACE, CHECK AGAIN
00001994  13D8 00C00007           3883mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000199A                          3884mm     ENDC
0000199A                          3885mm 
0000199A                 FALSE    3886mm     IFNE DEBUG
0000199A                          3887mm     ENDC
0000199A                          3888mm 
0000199A                          3889mm     ENDM
0000199A  60E4                    3890m     BRA LOOP_281
0000199C                          3891m EXIT_281
0000199C                          3892m     ENDM
0000199C                          3893  
0000199C  7000                    3894      MOVE.L #0,D0
0000199E  3017                    3895      MOVE.W (SP),D0
000019A0                          3896  
000019A0  0800 0004               3897      BTST #4,D0
000019A4  6700 0026               3898      BEQ WRITE
000019A8                          3899      
000019A8  41FA 03C2               3900      LEA READING(PC),A0
000019AC                          3901m     PRINT_STR A0,D1
000019AC                          3902m LOOP_283
000019AC  0C10 0000               3903m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019B0  6700 0016               3904m     BEQ EXIT_283
000019B4                          3905mm     PRINT_CHAR (A0)+,D1
000019B4                          3906mm WAIT_FOR_READY_284                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019B4                 TRUE     3907mm     IFEQ DEBUG
000019B4  1239 00C00003           3908mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000019BA  0801 0002               3909mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000019BE  67F4                    3910mm         BEQ WAIT_FOR_READY_284                      ; NO SPACE, CHECK AGAIN
000019C0  13D8 00C00007           3911mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019C6                          3912mm     ENDC
000019C6                          3913mm 
000019C6                 FALSE    3914mm     IFNE DEBUG
000019C6                          3915mm     ENDC
000019C6                          3916mm 
000019C6                          3917mm     ENDM
000019C6  60E4                    3918m     BRA LOOP_283
000019C8                          3919m EXIT_283
000019C8                          3920m     ENDM
000019C8                          3921  
000019C8  6000 0022               3922      BRA CONTINUE    
000019CC                          3923  WRITE
000019CC  41FA 03A7               3924      LEA WRITING(PC),A0
000019D0                          3925m     PRINT_STR A0,D1
000019D0                          3926m LOOP_285
000019D0  0C10 0000               3927m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019D4  6700 0016               3928m     BEQ EXIT_285
000019D8                          3929mm     PRINT_CHAR (A0)+,D1
000019D8                          3930mm WAIT_FOR_READY_286                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019D8                 TRUE     3931mm     IFEQ DEBUG
000019D8  1239 00C00003           3932mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000019DE  0801 0002               3933mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000019E2  67F4                    3934mm         BEQ WAIT_FOR_READY_286                      ; NO SPACE, CHECK AGAIN
000019E4  13D8 00C00007           3935mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019EA                          3936mm     ENDC
000019EA                          3937mm 
000019EA                 FALSE    3938mm     IFNE DEBUG
000019EA                          3939mm     ENDC
000019EA                          3940mm 
000019EA                          3941mm     ENDM
000019EA  60E4                    3942m     BRA LOOP_285
000019EC                          3943m EXIT_285
000019EC                          3944m     ENDM
000019EC                          3945  
000019EC                          3946  CONTINUE
000019EC  222F 0002               3947      MOVE.L 2(SP),D1
000019F0                          3948m     PRINT_REG D1,D2,D3,D4,A0
000019F0  41FA 0346               3949m     LEA OX(PC),A0
000019F4                          3950mm     PRINT_STR A0,D2
000019F4                          3951mm LOOP_288
000019F4  0C10 0000               3952mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019F8  6700 0016               3953mm     BEQ EXIT_288
000019FC                          3954mmm     PRINT_CHAR (A0)+,D2
000019FC                          3955mmm WAIT_FOR_READY_289                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019FC                 TRUE     3956mmm     IFEQ DEBUG
000019FC  1439 00C00003           3957mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A02  0802 0002               3958mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A06  67F4                    3959mmm         BEQ WAIT_FOR_READY_289                      ; NO SPACE, CHECK AGAIN
00001A08  13D8 00C00007           3960mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A0E                          3961mmm     ENDC
00001A0E                          3962mmm 
00001A0E                 FALSE    3963mmm     IFNE DEBUG
00001A0E                          3964mmm     ENDC
00001A0E                          3965mmm 
00001A0E                          3966mmm     ENDM
00001A0E  60E4                    3967mm     BRA LOOP_288
00001A10                          3968mm EXIT_288
00001A10                          3969mm     ENDM
00001A10  7807                    3970m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A12                          3971m LOOP_287
00001A12                          3972mm     BIN2HEX D1,D3,A0
00001A12  41FA 02E3               3973mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A16  E999                    3974mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A18  1601                    3975mm     MOVE.B D1,D3
00001A1A  0283 0000000F           3976mm     ANDI.L #$F,D3
00001A20  1630 3000               3977mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A24                          3978mm     ENDM
00001A24                          3979mm     PRINT_CHAR D3,D2
00001A24                          3980mm WAIT_FOR_READY_291                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A24                 TRUE     3981mm     IFEQ DEBUG
00001A24  1439 00C00003           3982mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A2A  0802 0002               3983mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A2E  67F4                    3984mm         BEQ WAIT_FOR_READY_291                      ; NO SPACE, CHECK AGAIN
00001A30  13C3 00C00007           3985mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001A36                          3986mm     ENDC
00001A36                          3987mm 
00001A36                 FALSE    3988mm     IFNE DEBUG
00001A36                          3989mm     ENDC
00001A36                          3990mm 
00001A36                          3991mm     ENDM
00001A36  57CC FFDA               3992m     DBEQ D4,LOOP_287
00001A3A                          3993m     ENDM
00001A3A                          3994  
00001A3A  41FA 0342               3995      LEA FROM(PC),A0
00001A3E                          3996m     PRINT_STR A0,D0
00001A3E                          3997m LOOP_292
00001A3E  0C10 0000               3998m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A42  6700 0016               3999m     BEQ EXIT_292
00001A46                          4000mm     PRINT_CHAR (A0)+,D0
00001A46                          4001mm WAIT_FOR_READY_293                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A46                 TRUE     4002mm     IFEQ DEBUG
00001A46  1039 00C00003           4003mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001A4C  0800 0002               4004mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001A50  67F4                    4005mm         BEQ WAIT_FOR_READY_293                      ; NO SPACE, CHECK AGAIN
00001A52  13D8 00C00007           4006mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A58                          4007mm     ENDC
00001A58                          4008mm 
00001A58                 FALSE    4009mm     IFNE DEBUG
00001A58                          4010mm     ENDC
00001A58                          4011mm 
00001A58                          4012mm     ENDM
00001A58  60E4                    4013m     BRA LOOP_292
00001A5A                          4014m EXIT_292
00001A5A                          4015m     ENDM
00001A5A                          4016  
00001A5A  222F 000A               4017      MOVE.L 10(SP),D1
00001A5E                          4018m     PRINT_REG D1,D2,D3,D4,A0
00001A5E  41FA 02D8               4019m     LEA OX(PC),A0
00001A62                          4020mm     PRINT_STR A0,D2
00001A62                          4021mm LOOP_295
00001A62  0C10 0000               4022mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A66  6700 0016               4023mm     BEQ EXIT_295
00001A6A                          4024mmm     PRINT_CHAR (A0)+,D2
00001A6A                          4025mmm WAIT_FOR_READY_296                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A6A                 TRUE     4026mmm     IFEQ DEBUG
00001A6A  1439 00C00003           4027mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A70  0802 0002               4028mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A74  67F4                    4029mmm         BEQ WAIT_FOR_READY_296                      ; NO SPACE, CHECK AGAIN
00001A76  13D8 00C00007           4030mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A7C                          4031mmm     ENDC
00001A7C                          4032mmm 
00001A7C                 FALSE    4033mmm     IFNE DEBUG
00001A7C                          4034mmm     ENDC
00001A7C                          4035mmm 
00001A7C                          4036mmm     ENDM
00001A7C  60E4                    4037mm     BRA LOOP_295
00001A7E                          4038mm EXIT_295
00001A7E                          4039mm     ENDM
00001A7E  7807                    4040m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A80                          4041m LOOP_294
00001A80                          4042mm     BIN2HEX D1,D3,A0
00001A80  41FA 0275               4043mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A84  E999                    4044mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A86  1601                    4045mm     MOVE.B D1,D3
00001A88  0283 0000000F           4046mm     ANDI.L #$F,D3
00001A8E  1630 3000               4047mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A92                          4048mm     ENDM
00001A92                          4049mm     PRINT_CHAR D3,D2
00001A92                          4050mm WAIT_FOR_READY_298                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A92                 TRUE     4051mm     IFEQ DEBUG
00001A92  1439 00C00003           4052mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A98  0802 0002               4053mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A9C  67F4                    4054mm         BEQ WAIT_FOR_READY_298                      ; NO SPACE, CHECK AGAIN
00001A9E  13C3 00C00007           4055mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001AA4                          4056mm     ENDC
00001AA4                          4057mm 
00001AA4                 FALSE    4058mm     IFNE DEBUG
00001AA4                          4059mm     ENDC
00001AA4                          4060mm 
00001AA4                          4061mm     ENDM
00001AA4  57CC FFDA               4062m     DBEQ D4,LOOP_294
00001AA8                          4063m     ENDM
00001AA8                          4064m     PRINT_CRLF D0,A0
00001AA8  41FA 0288               4065m     LEA CRLF(PC),A0
00001AAC                          4066mm     PRINT_STR A0,D0
00001AAC                          4067mm LOOP_300
00001AAC  0C10 0000               4068mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001AB0  6700 0016               4069mm     BEQ EXIT_300
00001AB4                          4070mmm     PRINT_CHAR (A0)+,D0
00001AB4                          4071mmm WAIT_FOR_READY_301                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001AB4                 TRUE     4072mmm     IFEQ DEBUG
00001AB4  1039 00C00003           4073mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001ABA  0800 0002               4074mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001ABE  67F4                    4075mmm         BEQ WAIT_FOR_READY_301                      ; NO SPACE, CHECK AGAIN
00001AC0  13D8 00C00007           4076mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AC6                          4077mmm     ENDC
00001AC6                          4078mmm 
00001AC6                 FALSE    4079mmm     IFNE DEBUG
00001AC6                          4080mmm     ENDC
00001AC6                          4081mmm 
00001AC6                          4082mmm     ENDM
00001AC6  60E4                    4083mm     BRA LOOP_300
00001AC8                          4084mm EXIT_300
00001AC8                          4085mm     ENDM
00001AC8                          4086m     ENDM
00001AC8                          4087      
00001AC8  207C 00000004           4088      MOVE.L #4,A0
00001ACE  4ED0                    4089      JMP (A0)
00001AD0                          4090          
00001AD0                          4091  ILLEGAL_HANDLER
00001AD0  13FC 0007 00E00001      4092      MOVE.B #7,DISPLAY   
00001AD8  207C 00000004           4093      MOVE.L #4,A0
00001ADE  4ED0                    4094      JMP (A0)
00001AE0                          4095          
00001AE0                          4096  UNHANDLED_HANDLER
00001AE0  41FA 02A3               4097      LEA UNHANDLED(PC),A0
00001AE4  4EF9 00001B08           4098      JMP PRINTIT_RTE
00001AEA                          4099      
00001AEA                          4100  UNINITIALISED_HANDLER
00001AEA  41FA 02AF               4101      LEA UNINITIALISED(PC),A0
00001AEE  4EF9 00001B08           4102      JMP PRINTIT_RTE
00001AF4                          4103  
00001AF4                          4104  TICK_HANDLER
00001AF4  1039 00C0001F           4105      MOVE.B DUART_RESET_OPR,D0
00001AFA  41FA 0254               4106      LEA TICK(PC),A0
00001AFE  4EF9 00001B08           4107      JMP PRINTIT_RTE
00001B04                          4108  
00001B04                          4109  SPURIOUS_HANDLER
00001B04  41FA 02B4               4110      LEA SPURIOUS(PC),A0
00001B08                          4111  PRINTIT_RTE
00001B08                          4112m     PRINT_STR A0,D1
00001B08                          4113m LOOP_302
00001B08  0C10 0000               4114m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001B0C  6700 0016               4115m     BEQ EXIT_302
00001B10                          4116mm     PRINT_CHAR (A0)+,D1
00001B10                          4117mm WAIT_FOR_READY_303                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B10                 TRUE     4118mm     IFEQ DEBUG
00001B10  1239 00C00003           4119mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001B16  0801 0002               4120mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001B1A  67F4                    4121mm         BEQ WAIT_FOR_READY_303                      ; NO SPACE, CHECK AGAIN
00001B1C  13D8 00C00007           4122mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001B22                          4123mm     ENDC
00001B22                          4124mm 
00001B22                 FALSE    4125mm     IFNE DEBUG
00001B22                          4126mm     ENDC
00001B22                          4127mm 
00001B22                          4128mm     ENDM
00001B22  60E4                    4129m     BRA LOOP_302
00001B24                          4130m EXIT_302
00001B24                          4131m     ENDM
00001B24  4E73                    4132      RTE 
00001B26                          4133      
00001B26  FFFF FFFF               4134      SIMHALT                                             ; halt simulator
00001B2A                          4135  
00001B2A                          4136  ; strings
00001B2A= 50 72 65 73 73 20 ...   4137  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001B3D= 5B 3F 5D 09 09 09 ...   4138  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001B49= 5B 76 5D 09 09 09 ...   4139          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001B58= 78 78 78 78 78 78 ...   4140          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001B70= 78 78 78 78 78 78 ...   4141          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001B90= 78 78 78 78 78 78 ...   4142          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001BB1= 78 78 78 78 78 78 ...   4143          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001BC2= 5B 7A 5D 09 09 09 ...   4144          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001BD4= 78 78 78 78 78 78 ...   4145          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001BF8= 78 78 78 78 78 78 ...   4146          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001C1A= 23 09 09 09 77 72 ...   4147          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001C34= 5B 78 5D 09 09 09 ...   4148          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001C4B= 5B 69 5D 09 09 09 ...   4149          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001C64= 5B 6F 5D 09 09 09 ...   4150          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001C7E= 5B 62 5D 09 09 09 ...   4151          DC.B '[b]',TAB,TAB,TAB,'boot from disk',CR,LF,NULL
00001C95= 48 75 68 3F 0D 0A 00    4152  HUH  DC.B 'Huh?',CR,LF,NULL
00001C9C= 20 53 20 72 65 63 ...   4153  READ    DC.B ' S records read, start address = ',NULL
00001CBE= 57 3A 20 55 6E 6B ...   4154  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001CD5= 21 20 43 53 20 66 ...   4155  CS_FAILURE  DC.B '! CS failure at ',NULL
00001CE6= 21 20 52 41 4D 20 ...   4156  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001CF7= 30 31 32 33 34 35 ...   4157  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001D07= 00 01 02 03 04 05 ...   4158  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001D1E= 4C 6F 61 64 69 6E ...   4159  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001D32= 0D 0A 00                4160  CRLF    DC.B CR,LF,NULL
00001D35= 3E 20 00                4161  PROMPT  DC.B '> ',NULL
00001D38= 30 78 00                4162  ox      DC.B '0x',NULL
00001D3B= 20 2D 3E 20 00          4163  to      DC.B ' -> ',NULL
00001D40= 20 66 6F 72 20 00       4164  for     DC.B ' for ',NULL
00001D46= 53 50 3A 20 00          4165  STACK_POINTER DC.B 'SP: ',NULL
00001D4B= 53 52 3A 20 00          4166  STATUS_REGISTER DC.B 'SR: ',NULL
00001D50= 74 69 63 6B 0D 0A 00    4167  TICK DC.B 'tick',CR,LF,NULL
00001D57= 2A 20 42 75 73 2F ...   4168  BUS_ERROR DC.B '* Bus/address error ',NULL
00001D6C= 72 65 61 64 69 6E ...   4169  READING DC.B 'reading ',NULL
00001D75= 77 72 69 74 69 6E ...   4170  WRITING DC.B 'writing ',NULL
00001D7E= 20 66 72 6F 6D 20 00    4171  FROM DC.B ' from ',NULL
00001D85= 2A 20 55 6E 68 61 ...   4172  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001D9B= 2A 20 55 6E 69 74 ...   4173  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00001DBA= 2A 20 53 70 75 72 ...   4174  SPURIOUS DC.B '* Spurious interrupt',NULL
00001DCF= 4D 44 46 2D 6D 6F ...   4175  VERSION DC.B 'MDF-mon V1.138 (17/05/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001DED= 00                      4176  END     DC.B 0
00001DEE                          4177      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B                   1412
BIN2HEX             0
BIN2HEX_LUT         1CF7
BUS_ERROR           1D57
BUS_ERROR_HANDLER   197C
CONTINUE            19EC
CONTINUE_113        B34
CONTINUE_54         610
CONTINUE_57         660
CONTINUE_61         6B6
CONTINUE_69         76A
CONTINUE_74         7DC
CONTINUE_79         858
CONTINUE_84         8D6
CONTINUE_89         95E
CONTINUE_94         9D0
CONTINUE_99         A42
CR                  D
CRLF                1D32
CS_FAILURE          1CD5
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C3E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1DED
EXIT_10             288
EXIT_104            AB4
EXIT_106            AD4
EXIT_110            B06
EXIT_118            B9C
EXIT_120            BC4
EXIT_123            BE4
EXIT_128            C2E
EXIT_131            C5E
EXIT_135            CA8
EXIT_138            CCA
EXIT_143            D14
EXIT_145            D90
EXIT_148            DB4
EXIT_15             2D2
EXIT_153            DFE
EXIT_160            E90
EXIT_163            F00
EXIT_166            F22
EXIT_17             2F2
EXIT_170            F6C
EXIT_173            F8E
EXIT_177            FD8
EXIT_180            FF8
EXIT_185            1042
EXIT_20             312
EXIT_200            1164
EXIT_203            11C8
EXIT_206            11E8
EXIT_210            1232
EXIT_213            1254
EXIT_218            129E
EXIT_22             364
EXIT_222            12E0
EXIT_225            1302
EXIT_230            134C
EXIT_232            136C
EXIT_235            138E
EXIT_240            13D8
EXIT_278            195E
EXIT_28             3F0
EXIT_281            199C
EXIT_283            19C8
EXIT_285            19EC
EXIT_288            1A10
EXIT_292            1A5A
EXIT_295            1A7E
EXIT_30             468
EXIT_300            1AC8
EXIT_302            1B24
EXIT_32             494
EXIT_35             4BE
EXIT_45             56C
EXIT_5              240
EXIT_52             5E2
EXIT_66             726
EXIT_7              260
FOR                 1D40
FROM                1D7E
G                   D18
GET_INPUT           364
H                   46C
HASH                13FC
HELP                1B3D
HELPPROMPT          1B2A
HEX2BIN             10B
HEX2BIN_LUT         1D07
HEX_DIGIT           1962
HUH                 1C95
I                   13DC
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1AD0
L                   E0E
LF                  A
LOADING             1D1E
LOOP_10             26C
LOOP_104            A98
LOOP_106            AB8
LOOP_110            AEA
LOOP_118            B80
LOOP_120            BA8
LOOP_122            BE6
LOOP_123            BC8
LOOP_128            C12
LOOP_130            C60
LOOP_131            C42
LOOP_135            C8C
LOOP_137            CCC
LOOP_138            CAE
LOOP_143            CF8
LOOP_145            D74
LOOP_147            DB6
LOOP_148            D98
LOOP_15             2B6
LOOP_153            DE2
LOOP_160            E74
LOOP_163            EE4
LOOP_165            F24
LOOP_166            F06
LOOP_17             2D6
LOOP_170            F50
LOOP_172            F90
LOOP_173            F72
LOOP_177            FBC
LOOP_179            FFA
LOOP_180            FDC
LOOP_185            1026
LOOP_20             2F6
LOOP_200            1148
LOOP_203            11AC
LOOP_205            11EA
LOOP_206            11CC
LOOP_210            1216
LOOP_212            1256
LOOP_213            1238
LOOP_218            1282
LOOP_22             348
LOOP_222            12C4
LOOP_224            1304
LOOP_225            12E6
LOOP_230            1330
LOOP_232            1350
LOOP_234            1390
LOOP_235            1372
LOOP_240            13BC
LOOP_244            1454
LOOP_248            14A4
LOOP_260            167C
LOOP_263            16BA
LOOP_278            1942
LOOP_28             3D4
LOOP_281            1980
LOOP_283            19AC
LOOP_285            19D0
LOOP_287            1A12
LOOP_288            19F4
LOOP_292            1A3E
LOOP_294            1A80
LOOP_295            1A62
LOOP_30             44C
LOOP_300            1AAC
LOOP_302            1B08
LOOP_32             478
LOOP_34             4C0
LOOP_35             4A2
LOOP_45             550
LOOP_5              224
LOOP_52             5C6
LOOP_66             70A
LOOP_7              244
LOOP_9              28A
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NULL                0
O                   13EC
OX                  1D38
P                   10F0
PRINTIT             478
PRINTIT_RTE         1B08
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1D35
PROTECT             A40
R                   498
RAM                 200000
RAM_ERROR           1CE6
READ                1C9C
READING             1D6C
READ_16             10D7
READ_32             1304
READ_8              D62
READ_CHAR           62D
READ_IDE_STATUS     1353
RESET               4
ROM                 0
S                   5EC
SEND_COMMAND        15D5
SEND_READ_COMMAND_AND_WAIT  1604
SET_READ_ADDRESS    1473
SPURIOUS            1DBA
SPURIOUS_HANDLER    1B04
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1D46
START               104
STATUS_REGISTER     1D4B
TAB                 9
TICK                1D50
TICK_HANDLER        1AF4
TO                  1D3B
UNHANDLED           1D85
UNHANDLED_HANDLER   1AE0
UNINITIALISED       1D9B
UNINITIALISED_HANDLER  1AEA
UNPROTECT           979
UNREC               1CBE
USER                100
V                   474
VECS                8
VERSION             1DCF
W                   570
WAIT_CHAR           4E9
WAIT_DRIVE_DRQ      1423
WAIT_DRIVE_NOT_BUSY  13D2
WAIT_DRIVE_READY    1380
WAIT_FOR_COMPLETE_187  1054
WAIT_FOR_COMPLETE_189  1076
WAIT_FOR_COMPLETE_190  1088
WAIT_FOR_COMPLETE_192  10B6
WAIT_FOR_COMPLETE_193  10C8
WAIT_FOR_COMPLETE_220  12A0
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A5A
WAIT_FOR_READY_105  AA0
WAIT_FOR_READY_107  AC0
WAIT_FOR_READY_108  AD4
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AF2
WAIT_FOR_READY_113  B18
WAIT_FOR_READY_115  B4C
WAIT_FOR_READY_119  B88
WAIT_FOR_READY_121  BB0
WAIT_FOR_READY_124  BD0
WAIT_FOR_READY_126  BF8
WAIT_FOR_READY_129  C1A
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_132  C4A
WAIT_FOR_READY_134  C72
WAIT_FOR_READY_136  C94
WAIT_FOR_READY_139  CB6
WAIT_FOR_READY_141  CDE
WAIT_FOR_READY_144  D00
WAIT_FOR_READY_146  D7C
WAIT_FOR_READY_149  DA0
WAIT_FOR_READY_151  DC8
WAIT_FOR_READY_154  DEA
WAIT_FOR_READY_155  E1C
WAIT_FOR_READY_157  E36
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E7C
WAIT_FOR_READY_164  EEC
WAIT_FOR_READY_167  F0E
WAIT_FOR_READY_169  F36
WAIT_FOR_READY_171  F58
WAIT_FOR_READY_174  F7A
WAIT_FOR_READY_176  FA2
WAIT_FOR_READY_178  FC4
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_181  FE4
WAIT_FOR_READY_183  100C
WAIT_FOR_READY_186  102E
WAIT_FOR_READY_195  10FC
WAIT_FOR_READY_197  1116
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  1150
WAIT_FOR_READY_204  11B4
WAIT_FOR_READY_207  11D4
WAIT_FOR_READY_209  11FC
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  121E
WAIT_FOR_READY_214  1240
WAIT_FOR_READY_216  1268
WAIT_FOR_READY_219  128A
WAIT_FOR_READY_223  12CC
WAIT_FOR_READY_226  12EE
WAIT_FOR_READY_228  1316
WAIT_FOR_READY_23   350
WAIT_FOR_READY_231  1338
WAIT_FOR_READY_233  1358
WAIT_FOR_READY_236  137A
WAIT_FOR_READY_238  13A2
WAIT_FOR_READY_24   364
WAIT_FOR_READY_241  13C4
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_266  16F8
WAIT_FOR_READY_279  194A
WAIT_FOR_READY_282  1988
WAIT_FOR_READY_284  19B4
WAIT_FOR_READY_286  19D8
WAIT_FOR_READY_289  19FC
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_291  1A24
WAIT_FOR_READY_293  1A46
WAIT_FOR_READY_296  1A6A
WAIT_FOR_READY_298  1A92
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_301  1AB4
WAIT_FOR_READY_303  1B10
WAIT_FOR_READY_31   454
WAIT_FOR_READY_33   480
WAIT_FOR_READY_36   4AA
WAIT_FOR_READY_38   4D2
WAIT_FOR_READY_39   4E8
WAIT_FOR_READY_40   4FE
WAIT_FOR_READY_41   512
WAIT_FOR_READY_42   526
WAIT_FOR_READY_43   53A
WAIT_FOR_READY_46   558
WAIT_FOR_READY_47   57A
WAIT_FOR_READY_49   594
WAIT_FOR_READY_53   5CE
WAIT_FOR_READY_54   5F4
WAIT_FOR_READY_56   62E
WAIT_FOR_READY_57   644
WAIT_FOR_READY_59   678
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   69A
WAIT_FOR_READY_63   6CE
WAIT_FOR_READY_67   712
WAIT_FOR_READY_69   74E
WAIT_FOR_READY_71   782
WAIT_FOR_READY_74   7C0
WAIT_FOR_READY_76   7F4
WAIT_FOR_READY_79   83C
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_81   870
WAIT_FOR_READY_84   8BA
WAIT_FOR_READY_86   8EE
WAIT_FOR_READY_89   942
WAIT_FOR_READY_91   976
WAIT_FOR_READY_94   9B4
WAIT_FOR_READY_96   9E8
WAIT_FOR_READY_99   A26
WAIT_FOR_SRECORD    5F4
WRITE               19CC
WRITE_8             F1B
WRITING             1D75
X                   12C0
Z                   D1E
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           72E
_00000004           B0A
_00000005           73C
_00000006           92A
_00000007           8A0
_00000008           B0A
_00000009           A94
_0000000A           B0A
_0000000B           C32
_0000000C           C3E
_0000000D           DFE
_0000000E           105E
_0000000F           1080
_00000010           1092
_00000011           10C0
_00000012           10D2
_00000013           12AA
_00000014           18DA
_00000015           18DC
_10000000           690
_10000001           6F8
_10000002           744
_10000003           7AC
_10000004           7B6
_10000005           81E
_10000006           832
_10000007           89A
_10000008           8A4
_10000009           924
_1000000A           8B0
_1000000B           918
_1000000C           938
_1000000D           9A0
_1000000E           9AA
_1000000F           A12
_10000010           A1C
_10000011           A84
_10000012           B0E
_10000013           B76
_10000014           1042
_10000015           1064
_10000016           149C
_10000017           193E
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           578
_20000005           5BC
_20000006           D30
_20000007           D40
_20000008           D5A
_20000009           E00
_2000000A           E1A
_2000000B           E5E
_2000000C           ED6
_2000000D           EDA
_2000000E           109A
_2000000F           10D4
_20000010           10FA
_20000011           113E
_20000012           119E
_20000013           11A2
_20000014           18E2
_20000015           1930
