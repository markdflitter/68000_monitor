00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/04/2021 12:33:06

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00C00000                 22  DUART_BASE          EQU $C00000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000006                 31  DUART_CTUR_         EQU $6
00000000  =00000007                 32  DUART_CTLR_         EQU $7
00000000  =00000008                 33  DUART_MRB_          EQU $8
00000000  =00000009                 34  DUART_CSRB_         EQU $9
00000000  =00000009                 35  DUART_SRB_          EQU $9
00000000  =0000000A                 36  DUART_CRB_          EQU $A
00000000  =0000000B                 37  DUART_TXB_          EQU $B
00000000  =0000000B                 38  DUART_RXB_          EQU $B
00000000  =0000000C                 39  DUART_IVR_          EQU $C
00000000  =0000000D                 40  DUART_OPCR_         EQU $D
00000000  =0000000E                 41  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 42  DUART_RESET_OPR_    EQU $F
00000000                            43  
00000000  =00C00001                 44  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 45  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 46  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 47  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 48  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 49  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            50  
00000000  =00C00011                 51  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 52  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 53  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 54  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 55  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 56  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            57  
00000000  =00C00009                 58  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 59  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 60  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 61  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 62  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 63  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 64  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 65  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            66  
00000000  =00E00000                 67  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 68  DISPLAY_            EQU $0
00000000  =00E00001                 69  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            77      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78      MOVE.B \1,\2
00000000                            79      ANDI.L #$F,\2
00000000                            80      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            81      ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            88      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            89      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            90      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           100          BTST #2,\2                                  ; check for space to send
00000000                           101          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           102          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           103      ENDC
00000000                           104  
00000000                           105      IFNE DEBUG
00000000                           106          MOVE.B \1,D1
00000000                           107          MOVE.L #6,D0   
00000000                           108          TRAP #15                                    ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll, /2 = working address register
00000000                           115  PRINT_CRLF MACRO
00000000                           116      LEA CRLF(PC),\2
00000000                           117      PRINT_STR \2,\1
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      BRA LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           133  PRINT_REG MACRO
00000000                           134      LEA ox(PC),\5
00000000                           135      PRINT_STR \5,\2
00000000                           136      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142  
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           148      IFEQ DEBUG
00000000                           149          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           150          BTST #0,\2                                  ; check for character
00000000                           151          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           152      ENDC
00000000                           153  
00000000                           154      READ_CHAR \1
00000000                           155  
00000000                           156      IFEQ DEBUG
00000000                           157          PRINT_CHAR \1,\2                            ; echo it back
00000000                           158      ENDC
00000000                           159      ENDM
00000000                           160  
00000000                           161  ; read a char from the serial port - assumes that there is one!
00000000                           162  ; \ 1= data register for read char
00000000                           163  ; will stamp on D0 and D1 in debug mode
00000000                           164  READ_CHAR MACRO
00000000                           165      IFEQ DEBUG
00000000                           166          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           167      ENDC
00000000                           168      IFNE DEBUG
00000000                           169          MOVE.L #5,D0    
00000000                           170          TRAP #15                                    ; read from keyboard in simulator
00000000                           171          MOVE.L D1,\1
00000000                           172      ENDC
00000000                           173  
00000000                           174      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           175      BEQ START
00000000                           176      ENDM
00000000                           177  
00000000                           178  
00000000                           179  ; read data from the download serial port
00000000                           180  ; \ 1= data register for read char
00000000                           181  DOWNLOAD MACRO
00000000                           182  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           183  
00000000                           184      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           185      BTST #0,\1                                      ; check for character
00000000                           186      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           187  
00000000                           188      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           189  CONTINUE\@
00000000                           190      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           193      
00000000                           194      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           195      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           196  
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; unprotect the EEPROM
00000000                           200  UNPROTECT MACRO
00000000                           201      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           202      NOP
00000000                           203      MOVE.W #$5555,$1554
00000000                           204      NOP
00000000                           205      MOVE.W #$8080,$2AAA
00000000                           206      NOP
00000000                           207      MOVE.W #$AAAA,$2AAA
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$2020,$2AAA
00000000                           212      ENDM
00000000                           213      
00000000                           214  ; protect the EEPROM
00000000                           215  PROTECT MACRO
00000000                           216      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           217      MOVE.W #$5555,$1554
00000000                           218      MOVE.W #$A0A0,$2AAA
00000000                           219      ENDM
00000000                           220  
00000000                           221  
00000000                           222  ; read two hex digits from the download serial port and convert to a byte
00000000                           223  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           224  DOWNLOAD_BYTE MACRO
00000000                           225      MOVE.B #2,\4
00000000                           226      WHILE.B \4 <GT> 0 DO
00000000                           227          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           228          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           229          PRINT_CHAR \2,\3
00000000                           230          HEX2BIN \2,\2,\6
00000000                           231          OR.B \2,\1
00000000                           232          SUB.B #1,\4
00000000                           233      ENDW
00000000                           234  
00000000                           235      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           236      MOVE.B \1,\2
00000000                           237      ADD.L \1,\5
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; write word to EEPROM
00000000                           242  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           243  PROGRAM MACRO
00000000                           244    MOVE.W \1,\2                                      ; write the data
00000000                           245  
00000000                           246  WAIT_FOR_COMPLETE\@
00000000                           247          MOVE.W \2,\3
00000000                           248  
00000000                           249          IF.W \3 <NE> \1 THEN
00000000                           250              BRA WAIT_FOR_COMPLETE\@
00000000                           251          ENDI
00000000                           252          ENDM
00000000                           253          
00000000                           254  ; program vector to EEPROM
00000000                           255  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           256  PROGRAM_VECTOR MACRO
00000000                           257      ADD.L #2,\2
00000000                           258      PROGRAM \1, (\2), \3                                ; write it
00000000                           259      LSR.L #8,\1
00000000                           260      LSR.L #8,\1
00000000                           261      SUB.L #2,\2
00000000                           262      PROGRAM \1, (\2), \3
00000000                           263      ENDM
00000000                           264  
00000000                           265  
00000000                           266  ; register catalogue
00000000                           267  ; D0 - used for simulator I/O
00000000                           268  ; D1 - used for simulator I/O
00000000                           269  ; D2 - read character
00000000                           270  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           271  ; D6 - working register used in R/W
00000000                           272  ; D7 - address accumulator, reset by download
00000000                           273  ; A0 - address of string to print 
00000000                           274  
00000000                           275  ; start vector
00000000= 002E0000                 276  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 277  RESET   DC.L START                              ; RESET
00000008= 0000167C                 278  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 0000167C                 279          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 000017D0                 280          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 000017E0                 281          DC.L UNHANDLED_HANDLER
00000018= 000017E0                 282          DC.L UNHANDLED_HANDLER
0000001C= 000017E0                 283          DC.L UNHANDLED_HANDLER
00000020= 000017E0                 284          DC.L UNHANDLED_HANDLER
00000024= 000017E0                 285          DC.L UNHANDLED_HANDLER
00000028= 000017E0                 286          DC.L UNHANDLED_HANDLER
0000002C= 000017E0                 287          DC.L UNHANDLED_HANDLER
00000030= 000017E0                 288          DC.L UNHANDLED_HANDLER
00000034= 000017E0                 289          DC.L UNHANDLED_HANDLER
00000038= 000017E0                 290          DC.L UNHANDLED_HANDLER
0000003C= 000017E0                 291          DC.L UNHANDLED_HANDLER
00000040= 000017E0                 292          DC.L UNHANDLED_HANDLER
00000044= 000017E0                 293          DC.L UNHANDLED_HANDLER
00000048= 000017E0                 294          DC.L UNHANDLED_HANDLER
0000004C= 000017E0                 295          DC.L UNHANDLED_HANDLER
00000050= 000017E0                 296          DC.L UNHANDLED_HANDLER
00000054= 000017E0                 297          DC.L UNHANDLED_HANDLER
00000058= 000017E0                 298          DC.L UNHANDLED_HANDLER
0000005C= 000017E0                 299          DC.L UNHANDLED_HANDLER
00000060= 00001824                 300          DC.L SPURIOUS_HANDLER
00000064= 000017E0                 301          DC.L UNHANDLED_HANDLER
00000068= 000017E0                 302          DC.L UNHANDLED_HANDLER
0000006C= 000017E0                 303          DC.L UNHANDLED_HANDLER
00000070= 000017E0                 304          DC.L UNHANDLED_HANDLER
00000074= 000017E0                 305          DC.L UNHANDLED_HANDLER
00000078= 000017E0                 306          DC.L UNHANDLED_HANDLER
0000007C= 000017E0                 307          DC.L UNHANDLED_HANDLER
00000080= 000017E0                 308          DC.L UNHANDLED_HANDLER
00000084= 000017E0                 309          DC.L UNHANDLED_HANDLER
00000088= 000017E0                 310          DC.L UNHANDLED_HANDLER
0000008C= 000017E0                 311          DC.L UNHANDLED_HANDLER
00000090= 000017E0                 312          DC.L UNHANDLED_HANDLER
00000094= 000017E0                 313          DC.L UNHANDLED_HANDLER
00000098= 000017E0                 314          DC.L UNHANDLED_HANDLER
0000009C= 000017E0                 315          DC.L UNHANDLED_HANDLER
000000A0= 000017E0                 316          DC.L UNHANDLED_HANDLER
000000A4= 000017E0                 317          DC.L UNHANDLED_HANDLER
000000A8= 000017E0                 318          DC.L UNHANDLED_HANDLER
000000AC= 000017E0                 319          DC.L UNHANDLED_HANDLER
000000B0= 000017E0                 320          DC.L UNHANDLED_HANDLER
000000B4= 000017E0                 321          DC.L UNHANDLED_HANDLER
000000B8= 000017E0                 322          DC.L UNHANDLED_HANDLER
000000BC= 000017E0                 323          DC.L UNHANDLED_HANDLER
000000C0= 000017E0                 324          DC.L UNHANDLED_HANDLER
000000C4= 000017E0                 325          DC.L UNHANDLED_HANDLER
000000C8= 000017E0                 326          DC.L UNHANDLED_HANDLER
000000CC= 000017E0                 327          DC.L UNHANDLED_HANDLER
000000D0= 000017E0                 328          DC.L UNHANDLED_HANDLER
000000D4= 000017E0                 329          DC.L UNHANDLED_HANDLER
000000D8= 000017E0                 330          DC.L UNHANDLED_HANDLER 
000000DC= 000017E0                 331          DC.L UNHANDLED_HANDLER
000000E0= 000017E0                 332          DC.L UNHANDLED_HANDLER
000000E4= 000017E0                 333          DC.L UNHANDLED_HANDLER 
000000E8= 000017E0                 334          DC.L UNHANDLED_HANDLER 
000000EC= 000017E0                 335          DC.L UNHANDLED_HANDLER
000000F0= 000017E0                 336          DC.L UNHANDLED_HANDLER 
000000F4= 000017E0                 337          DC.L UNHANDLED_HANDLER 
000000F8= 000017E0                 338          DC.L UNHANDLED_HANDLER 
000000FC= 000017E0                 339          DC.L UNHANDLED_HANDLER
00000100= 00001846                 340  USER    DC.L TICK_HANDLER
00000104                           341      ; start of program  
00000104                           342  START
00000104  2E7C 002E0000            343      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       344      MOVE.B #0,DISPLAY
00000112                           345  
00000112  7000                     346      MOVE.L #0,D0
00000114  1039 00C00019            347      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           348  
0000011A                           349  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       350      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       351      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           352      
0000012A                           353      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                354s     MOVE.W  #$50,D1
0000012E  6000 000E                355s     BRA _20000001
00000132                           356s _20000000
00000132  13C1 00C00005            357          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     358          NOP
0000013A                           359      ENDF
0000013A  0441 0010                360s     SUB.W   #$10,D1
0000013E                           361s _20000001
0000013E  B27C 0010                362s     CMP.W   #$10,D1
00000142  6CEE                     363s     BGE _20000000
00000144                           364  
00000144                           365      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                366s     MOVE.W  #$50,D1
00000148  6000 000E                367s     BRA _20000003
0000014C                           368s _20000002
0000014C  13C1 00C00015            369          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     370          NOP
00000154                           371      ENDF
00000154  0441 0010                372s     SUB.W   #$10,D1
00000158                           373s _20000003
00000158  B27C 0010                374s     CMP.W   #$10,D1
0000015C  6CEE                     375s     BGE _20000002
0000015E                           376      
0000015E                           377  ;initialise UART
0000015E  13FC 0000 00C0000B       378      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       379      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       380      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       381      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       382      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           383  
00000186                           384  ; channel A
00000186  13FC 0013 00C00001       385      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       386      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       387      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       388      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           389  
000001A6                           390  ; channel B
000001A6  13FC 0013 00C00011       391      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       392      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       393      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       394      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       395      MOVE.B #64,DUART_IVR
000001CE                           396  
000001CE                           397m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           398m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      399m     IFEQ DEBUG
000001CE  1239 00C00003            400m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                401m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     402m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       403m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           404m     ENDC
000001E2                           405m 
000001E2                 FALSE     406m     IFNE DEBUG
000001E2                           407m     ENDC
000001E2                           408m 
000001E2                           409m     ENDM
000001E2                           410m     PRINT_CHAR #0,D1
000001E2                           411m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      412m     IFEQ DEBUG
000001E2  1239 00C00003            413m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                414m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     415m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       416m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           417m     ENDC
000001F6                           418m 
000001F6                 FALSE     419m     IFNE DEBUG
000001F6                           420m     ENDC
000001F6                           421m 
000001F6                           422m     ENDM
000001F6                           423m     PRINT_CHAR #0,D1
000001F6                           424m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      425m     IFEQ DEBUG
000001F6  1239 00C00003            426m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                427m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     428m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       429m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           430m     ENDC
0000020A                           431m 
0000020A                 FALSE     432m     IFNE DEBUG
0000020A                           433m     ENDC
0000020A                           434m 
0000020A                           435m     ENDM
0000020A                           436      
0000020A                           437      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                438s     CMP.W   #$0F,D0
0000020E  6600 002C                439s     BNE _00000000
00000212  1039 00C00005            440          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           441  
00000218  41FA 1945                442          LEA COLD_START(PC),A0
0000021C                           443m         PRINT_STR A0,D0
0000021C                           444m LOOP_4
0000021C  0C10 0000                445m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000220  6700 0016                446m     BEQ EXIT_4
00000224                           447mm     PRINT_CHAR (A0)+,D0
00000224                           448mm WAIT_FOR_READY_5                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000224                 TRUE      449mm     IFEQ DEBUG
00000224  1039 00C00003            450mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000022A  0800 0002                451mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000022E  67F4                     452mm         BEQ WAIT_FOR_READY_5                        ; NO SPACE, CHECK AGAIN
00000230  13D8 00C00007            453mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000236                           454mm     ENDC
00000236                           455mm 
00000236                 FALSE     456mm     IFNE DEBUG
00000236                           457mm     ENDC
00000236                           458mm 
00000236                           459mm     ENDM
00000236  60E4                     460m     BRA LOOP_4
00000238                           461m EXIT_4
00000238                           462m     ENDM
00000238                           463      ELSE
00000238  6000 0022                464s     BRA _00000001
0000023C                           465s _00000000
0000023C  41FA 1935                466          LEA WARM_START(PC),A0
00000240                           467m         PRINT_STR A0,D0
00000240                           468m LOOP_6
00000240  0C10 0000                469m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000244  6700 0016                470m     BEQ EXIT_6
00000248                           471mm     PRINT_CHAR (A0)+,D0
00000248                           472mm WAIT_FOR_READY_7                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000248                 TRUE      473mm     IFEQ DEBUG
00000248  1039 00C00003            474mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000024E  0800 0002                475mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00000252  67F4                     476mm         BEQ WAIT_FOR_READY_7                        ; NO SPACE, CHECK AGAIN
00000254  13D8 00C00007            477mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025A                           478mm     ENDC
0000025A                           479mm 
0000025A                 FALSE     480mm     IFNE DEBUG
0000025A                           481mm     ENDC
0000025A                           482mm 
0000025A                           483mm     ENDM
0000025A  60E4                     484m     BRA LOOP_6
0000025C                           485m EXIT_6
0000025C                           486m     ENDM
0000025C                           487      ENDI
0000025C                           488s _00000001
0000025C                           489  
0000025C  13FC 0001 00E00001       490      MOVE.B #1,DISPLAY
00000264                           491      
00000264                           492m     PRINT_CRLF D1,A0
00000264  41FA 185B                493m     LEA CRLF(PC),A0
00000268                           494mm     PRINT_STR A0,D1
00000268                           495mm LOOP_9
00000268  0C10 0000                496mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000026C  6700 0016                497mm     BEQ EXIT_9
00000270                           498mmm     PRINT_CHAR (A0)+,D1
00000270                           499mmm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000270                 TRUE      500mmm     IFEQ DEBUG
00000270  1239 00C00003            501mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000276  0801 0002                502mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027A  67F4                     503mmm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
0000027C  13D8 00C00007            504mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000282                           505mmm     ENDC
00000282                           506mmm 
00000282                 FALSE     507mmm     IFNE DEBUG
00000282                           508mmm     ENDC
00000282                           509mmm 
00000282                           510mmm     ENDM
00000282  60E4                     511mm     BRA LOOP_9
00000284                           512mm EXIT_9
00000284                           513mm     ENDM
00000284                           514m     ENDM
00000284  41FA 1901                515      LEA VERSION(PC),A0
00000288                           516m     PRINT_STR A0,D3
00000288                           517m LOOP_11
00000288  0C10 0000                518m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000028C  6700 0016                519m     BEQ EXIT_11
00000290                           520mm     PRINT_CHAR (A0)+,D3
00000290                           521mm WAIT_FOR_READY_12                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000290                 TRUE      522mm     IFEQ DEBUG
00000290  1639 00C00003            523mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000296  0803 0002                524mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000029A  67F4                     525mm         BEQ WAIT_FOR_READY_12                       ; NO SPACE, CHECK AGAIN
0000029C  13D8 00C00007            526mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002A2                           527mm     ENDC
000002A2                           528mm 
000002A2                 FALSE     529mm     IFNE DEBUG
000002A2                           530mm     ENDC
000002A2                           531mm 
000002A2                           532mm     ENDM
000002A2  60E4                     533m     BRA LOOP_11
000002A4                           534m EXIT_11
000002A4                           535m     ENDM
000002A4                           536  
000002A4  41F9 00001BA5            537      LEA END,A0
000002AA  2008                     538      MOVE.L A0,D0
000002AC                           539m     PRINT_REG D0,D1,D2,D3,A0
000002AC  41FA 1819                540m     LEA OX(PC),A0
000002B0                           541mm     PRINT_STR A0,D1
000002B0                           542mm LOOP_14
000002B0  0C10 0000                543mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002B4  6700 0016                544mm     BEQ EXIT_14
000002B8                           545mmm     PRINT_CHAR (A0)+,D1
000002B8                           546mmm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002B8                 TRUE      547mmm     IFEQ DEBUG
000002B8  1239 00C00003            548mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002BE  0801 0002                549mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C2  67F4                     550mmm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
000002C4  13D8 00C00007            551mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002CA                           552mmm     ENDC
000002CA                           553mmm 
000002CA                 FALSE     554mmm     IFNE DEBUG
000002CA                           555mmm     ENDC
000002CA                           556mmm 
000002CA                           557mmm     ENDM
000002CA  60E4                     558mm     BRA LOOP_14
000002CC                           559mm EXIT_14
000002CC                           560mm     ENDM
000002CC  7607                     561m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002CE                           562m LOOP_13
000002CE                           563mm     BIN2HEX D0,D2,A0
000002CE  41FA 1773                564mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002D2  E998                     565mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002D4  1400                     566mm     MOVE.B D0,D2
000002D6  0282 0000000F            567mm     ANDI.L #$F,D2
000002DC  1430 2000                568mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000002E0                           569mm     ENDM
000002E0                           570mm     PRINT_CHAR D2,D1
000002E0                           571mm WAIT_FOR_READY_17                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E0                 TRUE      572mm     IFEQ DEBUG
000002E0  1239 00C00003            573mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002E6  0801 0002                574mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002EA  67F4                     575mm         BEQ WAIT_FOR_READY_17                       ; NO SPACE, CHECK AGAIN
000002EC  13C2 00C00007            576mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002F2                           577mm     ENDC
000002F2                           578mm 
000002F2                 FALSE     579mm     IFNE DEBUG
000002F2                           580mm     ENDC
000002F2                           581mm 
000002F2                           582mm     ENDM
000002F2  57CB FFDA                583m     DBEQ D3,LOOP_13
000002F6                           584m     ENDM
000002F6                           585m     PRINT_CRLF D1,A0
000002F6  41FA 17C9                586m     LEA CRLF(PC),A0
000002FA                           587mm     PRINT_STR A0,D1
000002FA                           588mm LOOP_19
000002FA  0C10 0000                589mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FE  6700 0016                590mm     BEQ EXIT_19
00000302                           591mmm     PRINT_CHAR (A0)+,D1
00000302                           592mmm WAIT_FOR_READY_20                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000302                 TRUE      593mmm     IFEQ DEBUG
00000302  1239 00C00003            594mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000308  0801 0002                595mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000030C  67F4                     596mmm         BEQ WAIT_FOR_READY_20                       ; NO SPACE, CHECK AGAIN
0000030E  13D8 00C00007            597mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000314                           598mmm     ENDC
00000314                           599mmm 
00000314                 FALSE     600mmm     IFNE DEBUG
00000314                           601mmm     ENDC
00000314                           602mmm 
00000314                           603mmm     ENDM
00000314  60E4                     604mm     BRA LOOP_19
00000316                           605mm EXIT_19
00000316                           606mm     ENDM
00000316                           607m     ENDM
00000316                           608  
00000316  41FA 1556                609      LEA HELPPROMPT(PC),A0
0000031A                           610m     PRINT_STR A0,D3
0000031A                           611m LOOP_21
0000031A  0C10 0000                612m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000031E  6700 0016                613m     BEQ EXIT_21
00000322                           614mm     PRINT_CHAR (A0)+,D3
00000322                           615mm WAIT_FOR_READY_22                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000322                 TRUE      616mm     IFEQ DEBUG
00000322  1639 00C00003            617mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000328  0803 0002                618mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000032C  67F4                     619mm         BEQ WAIT_FOR_READY_22                       ; NO SPACE, CHECK AGAIN
0000032E  13D8 00C00007            620mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000334                           621mm     ENDC
00000334                           622mm 
00000334                 FALSE     623mm     IFNE DEBUG
00000334                           624mm     ENDC
00000334                           625mm 
00000334                           626mm     ENDM
00000334  60E4                     627m     BRA LOOP_21
00000336                           628m EXIT_21
00000336                           629m     ENDM
00000336                           630  
00000336                           631m     PRINT_CRLF D3,A0
00000336  41FA 1789                632m     LEA CRLF(PC),A0
0000033A                           633mm     PRINT_STR A0,D3
0000033A                           634mm LOOP_24
0000033A  0C10 0000                635mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000033E  6700 0016                636mm     BEQ EXIT_24
00000342                           637mmm     PRINT_CHAR (A0)+,D3
00000342                           638mmm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000342                 TRUE      639mmm     IFEQ DEBUG
00000342  1639 00C00003            640mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000348  0803 0002                641mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000034C  67F4                     642mmm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
0000034E  13D8 00C00007            643mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000354                           644mmm     ENDC
00000354                           645mmm 
00000354                 FALSE     646mmm     IFNE DEBUG
00000354                           647mmm     ENDC
00000354                           648mmm 
00000354                           649mmm     ENDM
00000354  60E4                     650mm     BRA LOOP_24
00000356                           651mm EXIT_24
00000356                           652mm     ENDM
00000356                           653m     ENDM
00000356                           654  
00000356  7E00                     655      MOVE.L #0,D7                                    ; address accumulator
00000358                           656  
00000358  13FC 0002 00E00001       657      MOVE.B #2,DISPLAY
00000360                           658      
00000360                           659  MAIN_LOOP
00000360  41FA 1762                660      LEA PROMPT(PC),A0
00000364                           661m     PRINT_STR A0,D3
00000364                           662m LOOP_26
00000364  0C10 0000                663m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000368  6700 0016                664m     BEQ EXIT_26
0000036C                           665mm     PRINT_CHAR (A0)+,D3
0000036C                           666mm WAIT_FOR_READY_27                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036C                 TRUE      667mm     IFEQ DEBUG
0000036C  1639 00C00003            668mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000372  0803 0002                669mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000376  67F4                     670mm         BEQ WAIT_FOR_READY_27                       ; NO SPACE, CHECK AGAIN
00000378  13D8 00C00007            671mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000037E                           672mm     ENDC
0000037E                           673mm 
0000037E                 FALSE     674mm     IFNE DEBUG
0000037E                           675mm     ENDC
0000037E                           676mm 
0000037E                           677mm     ENDM
0000037E  60E4                     678m     BRA LOOP_26
00000380                           679m EXIT_26
00000380                           680m     ENDM
00000380                           681  
00000380                           682  GET_INPUT
00000380                           683m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000380                           684m WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000380                 TRUE      685m     IFEQ DEBUG
00000380  1639 00C00003            686m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000386  0803 0000                687m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000038A  67F4                     688m         BEQ WAIT_FOR_READY_28                       ; NOTHING, CHECK AGAIN
0000038C                           689m     ENDC
0000038C                           690m 
0000038C                           691mm     READ_CHAR D2
0000038C                 TRUE      692mm     IFEQ DEBUG
0000038C  1439 00C00007            693mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000392                           694mm     ENDC
00000392                 FALSE     695mm     IFNE DEBUG
00000392                           696mm     ENDC
00000392                           697mm 
00000392  B43C 001B                698mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000396  6700 FD6C                699mm     BEQ START
0000039A                           700mm     ENDM
0000039A                           701m 
0000039A                 TRUE      702m     IFEQ DEBUG
0000039A                           703mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000039A                           704mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039A                 TRUE      705mm     IFEQ DEBUG
0000039A  1639 00C00003            706mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003A0  0803 0002                707mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003A4  67F4                     708mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000003A6  13C2 00C00007            709mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003AC                           710mm     ENDC
000003AC                           711mm 
000003AC                 FALSE     712mm     IFNE DEBUG
000003AC                           713mm     ENDC
000003AC                           714mm 
000003AC                           715mm     ENDM
000003AC                           716m     ENDC
000003AC                           717m     ENDM
000003AC                           718  
000003AC                           719      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000003AC  B43C 0030                720s     CMP.B   #'0',D2
000003B0  6D00 000E                721s     BLT _00000002
000003B4  B43C 0039                722s     CMP.B   #'9',D2
000003B8  6E00 0006                723s     BGT _00000002
000003BC  6000 12A0                724          BRA HEX_DIGIT
000003C0                           725      ENDI
000003C0                           726s _00000002
000003C0                           727      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003C0  B43C 0041                728s     CMP.B   #'A',D2
000003C4  6D00 000E                729s     BLT _00000003
000003C8  B43C 0046                730s     CMP.B   #'F',D2
000003CC  6E00 0006                731s     BGT _00000003
000003D0  6000 128C                732          BRA HEX_DIGIT
000003D4                           733      ENDI
000003D4                           734s _00000003
000003D4                           735  
000003D4  B43C 0077                736      CMP.B #'w',D2
000003D8  6700 01B2                737      BEQ W
000003DC                           738  
000003DC  B43C 006C                739      CMP.B #'l',D2
000003E0  6700 0A48                740      BEQ L 
000003E4                           741  
000003E4  B43C 0070                742      CMP.B #'p',D2
000003E8  6700 0EBA                743      BEQ P
000003EC                           744  
000003EC  B43C 006D                745      CMP.B #'m',D2
000003F0  6700 1082                746      BEQ M
000003F4                           747  
000003F4                           748m     PRINT_CRLF D3,A0
000003F4  41FA 16CB                749m     LEA CRLF(PC),A0
000003F8                           750mm     PRINT_STR A0,D3
000003F8                           751mm LOOP_32
000003F8  0C10 0000                752mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003FC  6700 0016                753mm     BEQ EXIT_32
00000400                           754mmm     PRINT_CHAR (A0)+,D3
00000400                           755mmm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000400                 TRUE      756mmm     IFEQ DEBUG
00000400  1639 00C00003            757mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000406  0803 0002                758mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000040A  67F4                     759mmm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000040C  13D8 00C00007            760mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000412                           761mmm     ENDC
00000412                           762mmm 
00000412                 FALSE     763mmm     IFNE DEBUG
00000412                           764mmm     ENDC
00000412                           765mmm 
00000412                           766mmm     ENDM
00000412  60E4                     767mm     BRA LOOP_32
00000414                           768mm EXIT_32
00000414                           769mm     ENDM
00000414                           770m     ENDM
00000414                           771   
00000414  B43C 003F                772      CMP.B #'?',D2
00000418  6700 006E                773      BEQ H
0000041C                           774   
0000041C  B43C 0076                775      CMP.B #'v',D2
00000420  6700 006E                776      BEQ V
00000424                           777      
00000424  B43C 0072                778      CMP.B #'r',D2
00000428  6700 008A                779      BEQ R
0000042C                           780  
0000042C  B43C 0073                781      CMP.B #'s',D2
00000430  6700 01D6                782      BEQ S
00000434                           783  
00000434  B43C 0067                784      CMP.B #'g',D2
00000438  6700 08FA                785      BEQ G   
0000043C                           786  
0000043C  B43C 007A                787      CMP.B #'z',D2
00000440  6700 08F8                788      BEQ Z   
00000444                           789  
00000444  B43C 0078                790      CMP.B #'x',D2
00000448  6700 10C2                791      BEQ X
0000044C                           792  
0000044C  B43C 0069                793      CMP.B #'i',D2
00000450  6700 11D6                794      BEQ I
00000454                           795  
00000454  B43C 006F                796      CMP.B #'o',D2
00000458  6700 11DE                797      BEQ O
0000045C                           798  
0000045C  B43C 0023                799      CMP.B #'#',D2
00000460  6700 11E6                800      BEQ HASH
00000464                           801  
00000464  41FA 157B                802      LEA HUH(PC),A0
00000468                           803m     PRINT_STR A0,D3
00000468                           804m LOOP_34
00000468  0C10 0000                805m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000046C  6700 0016                806m     BEQ EXIT_34
00000470                           807mm     PRINT_CHAR (A0)+,D3
00000470                           808mm WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000470                 TRUE      809mm     IFEQ DEBUG
00000470  1639 00C00003            810mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000476  0803 0002                811mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000047A  67F4                     812mm         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
0000047C  13D8 00C00007            813mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000482                           814mm     ENDC
00000482                           815mm 
00000482                 FALSE     816mm     IFNE DEBUG
00000482                           817mm     ENDC
00000482                           818mm 
00000482                           819mm     ENDM
00000482  60E4                     820m     BRA LOOP_34
00000484                           821m EXIT_34
00000484                           822m     ENDM
00000484                           823  
00000484  6000 FEDA                824      BRA MAIN_LOOP
00000488                           825  
00000488                           826  ; commands
00000488                           827  H
00000488  41FA 13F7                828      LEA HELP(PC),A0
0000048C  6000 0006                829      BRA PRINTSTR
00000490                           830  
00000490                           831  V
00000490  41FA 16F5                832      LEA VERSION(PC),A0
00000494                           833  PRINTSTR
00000494                           834m     PRINT_STR A0,D3    
00000494                           835m LOOP_36
00000494  0C10 0000                836m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000498  6700 0016                837m     BEQ EXIT_36
0000049C                           838mm     PRINT_CHAR (A0)+,D3
0000049C                           839mm WAIT_FOR_READY_37                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000049C                 TRUE      840mm     IFEQ DEBUG
0000049C  1639 00C00003            841mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004A2  0803 0002                842mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004A6  67F4                     843mm         BEQ WAIT_FOR_READY_37                       ; NO SPACE, CHECK AGAIN
000004A8  13D8 00C00007            844mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004AE                           845mm     ENDC
000004AE                           846mm 
000004AE                 FALSE     847mm     IFNE DEBUG
000004AE                           848mm     ENDC
000004AE                           849mm 
000004AE                           850mm     ENDM
000004AE  60E4                     851m     BRA LOOP_36
000004B0                           852m EXIT_36
000004B0                           853m     ENDM
000004B0  6000 FEAE                854      BRA MAIN_LOOP
000004B4                           855  
000004B4                           856  R
000004B4  2047                     857      MOVE.L D7,A0                                    ; address accumulator -> address register
000004B6  7E00                     858      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B8  2410                     859      MOVE.L (A0),D2                                  ; read the memory and print it
000004BA                           860m     PRINT_REG D2,D3,D4,D5,A0
000004BA  41FA 160B                861m     LEA OX(PC),A0
000004BE                           862mm     PRINT_STR A0,D3
000004BE                           863mm LOOP_39
000004BE  0C10 0000                864mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004C2  6700 0016                865mm     BEQ EXIT_39
000004C6                           866mmm     PRINT_CHAR (A0)+,D3
000004C6                           867mmm WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C6                 TRUE      868mmm     IFEQ DEBUG
000004C6  1639 00C00003            869mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004CC  0803 0002                870mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004D0  67F4                     871mmm         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000004D2  13D8 00C00007            872mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004D8                           873mmm     ENDC
000004D8                           874mmm 
000004D8                 FALSE     875mmm     IFNE DEBUG
000004D8                           876mmm     ENDC
000004D8                           877mmm 
000004D8                           878mmm     ENDM
000004D8  60E4                     879mm     BRA LOOP_39
000004DA                           880mm EXIT_39
000004DA                           881mm     ENDM
000004DA  7A07                     882m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004DC                           883m LOOP_38
000004DC                           884mm     BIN2HEX D2,D4,A0
000004DC  41FA 1565                885mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004E0  E99A                     886mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004E2  1802                     887mm     MOVE.B D2,D4
000004E4  0284 0000000F            888mm     ANDI.L #$F,D4
000004EA  1830 4000                889mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004EE                           890mm     ENDM
000004EE                           891mm     PRINT_CHAR D4,D3
000004EE                           892mm WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004EE                 TRUE      893mm     IFEQ DEBUG
000004EE  1639 00C00003            894mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004F4  0803 0002                895mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F8  67F4                     896mm         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000004FA  13C4 00C00007            897mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000500                           898mm     ENDC
00000500                           899mm 
00000500                 FALSE     900mm     IFNE DEBUG
00000500                           901mm     ENDC
00000500                           902mm 
00000500                           903mm     ENDM
00000500  57CD FFDA                904m     DBEQ D5,LOOP_38
00000504                           905m     ENDM
00000504                           906      
00000504                           907m     PRINT_CHAR #32,D3
00000504                           908m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000504                 TRUE      909m     IFEQ DEBUG
00000504  1639 00C00003            910m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000050A  0803 0002                911m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000050E  67F4                     912m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000510  13FC 0020 00C00007       913m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000518                           914m     ENDC
00000518                           915m 
00000518                 FALSE     916m     IFNE DEBUG
00000518                           917m     ENDC
00000518                           918m 
00000518                           919m     ENDM
00000518                           920  
00000518  E19A                     921      ROL.L #8,D2
0000051A                           922m     PRINT_CHAR D2,D3
0000051A                           923m WAIT_FOR_READY_44                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000051A                 TRUE      924m     IFEQ DEBUG
0000051A  1639 00C00003            925m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000520  0803 0002                926m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000524  67F4                     927m         BEQ WAIT_FOR_READY_44                       ; NO SPACE, CHECK AGAIN
00000526  13C2 00C00007            928m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000052C                           929m     ENDC
0000052C                           930m 
0000052C                 FALSE     931m     IFNE DEBUG
0000052C                           932m     ENDC
0000052C                           933m 
0000052C                           934m     ENDM
0000052C  E19A                     935      ROL.L #8,D2
0000052E                           936m     PRINT_CHAR D2,D3
0000052E                           937m WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052E                 TRUE      938m     IFEQ DEBUG
0000052E  1639 00C00003            939m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000534  0803 0002                940m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000538  67F4                     941m         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
0000053A  13C2 00C00007            942m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000540                           943m     ENDC
00000540                           944m 
00000540                 FALSE     945m     IFNE DEBUG
00000540                           946m     ENDC
00000540                           947m 
00000540                           948m     ENDM
00000540  E19A                     949      ROL.L #8,D2
00000542                           950m     PRINT_CHAR D2,D3
00000542                           951m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000542                 TRUE      952m     IFEQ DEBUG
00000542  1639 00C00003            953m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000548  0803 0002                954m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000054C  67F4                     955m         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
0000054E  13C2 00C00007            956m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000554                           957m     ENDC
00000554                           958m 
00000554                 FALSE     959m     IFNE DEBUG
00000554                           960m     ENDC
00000554                           961m 
00000554                           962m     ENDM
00000554  E19A                     963      ROL.L #8,D2
00000556                           964m     PRINT_CHAR D2,D3
00000556                           965m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000556                 TRUE      966m     IFEQ DEBUG
00000556  1639 00C00003            967m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000055C  0803 0002                968m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000560  67F4                     969m         BEQ WAIT_FOR_READY_47                       ; NO SPACE, CHECK AGAIN
00000562  13C2 00C00007            970m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000568                           971m     ENDC
00000568                           972m 
00000568                 FALSE     973m     IFNE DEBUG
00000568                           974m     ENDC
00000568                           975m 
00000568                           976m     ENDM
00000568                           977  
00000568                           978m     PRINT_CRLF D3,A0
00000568  41FA 1557                979m     LEA CRLF(PC),A0
0000056C                           980mm     PRINT_STR A0,D3
0000056C                           981mm LOOP_49
0000056C  0C10 0000                982mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000570  6700 0016                983mm     BEQ EXIT_49
00000574                           984mmm     PRINT_CHAR (A0)+,D3
00000574                           985mmm WAIT_FOR_READY_50                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000574                 TRUE      986mmm     IFEQ DEBUG
00000574  1639 00C00003            987mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000057A  0803 0002                988mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000057E  67F4                     989mmm         BEQ WAIT_FOR_READY_50                       ; NO SPACE, CHECK AGAIN
00000580  13D8 00C00007            990mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000586                           991mmm     ENDC
00000586                           992mmm 
00000586                 FALSE     993mmm     IFNE DEBUG
00000586                           994mmm     ENDC
00000586                           995mmm 
00000586                           996mmm     ENDM
00000586  60E4                     997mm     BRA LOOP_49
00000588                           998mm EXIT_49
00000588                           999mm     ENDM
00000588                          1000m     ENDM
00000588                          1001      
00000588  6000 FDD6               1002      BRA MAIN_LOOP
0000058C                          1003  
0000058C                          1004  W
0000058C                          1005      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
0000058C  3C3C 0000               1006s     MOVE.W  #0,D6
00000590  6000 0046               1007s     BRA _20000005
00000594                          1008s _20000004
00000594  E98D                    1009          LSL.L #4,D5                                     ; make what we have so far more significant
00000596                          1010m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000596                          1011m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000596                 TRUE     1012m     IFEQ DEBUG
00000596  1639 00C00003           1013m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000059C  0803 0000               1014m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000005A0  67F4                    1015m         BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
000005A2                          1016m     ENDC
000005A2                          1017m 
000005A2                          1018mm     READ_CHAR D2
000005A2                 TRUE     1019mm     IFEQ DEBUG
000005A2  1439 00C00007           1020mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000005A8                          1021mm     ENDC
000005A8                 FALSE    1022mm     IFNE DEBUG
000005A8                          1023mm     ENDC
000005A8                          1024mm 
000005A8  B43C 001B               1025mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000005AC  6700 FB56               1026mm     BEQ START
000005B0                          1027mm     ENDM
000005B0                          1028m 
000005B0                 TRUE     1029m     IFEQ DEBUG
000005B0                          1030mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000005B0                          1031mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B0                 TRUE     1032mm     IFEQ DEBUG
000005B0  1639 00C00003           1033mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005B6  0803 0002               1034mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005BA  67F4                    1035mm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005BC  13C2 00C00007           1036mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005C2                          1037mm     ENDC
000005C2                          1038mm 
000005C2                 FALSE    1039mm     IFNE DEBUG
000005C2                          1040mm     ENDC
000005C2                          1041mm 
000005C2                          1042mm     ENDM
000005C2                          1043m     ENDC
000005C2                          1044m     ENDM
000005C2                          1045m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005C2  41FA 148F               1046m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005C6  0402 0030               1047m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005CA  C4BC 000000FF           1048m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005D0  1430 2000               1049m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005D4                          1050m     ENDM
000005D4  8A02                    1051          OR.B D2,D5
000005D6                          1052      ENDF
000005D6  5246                    1053s     ADD.W   #1,D6
000005D8                          1054s _20000005
000005D8  BC7C 0007               1055s     CMP.W   #7,D6
000005DC  6FB6                    1056s     BLE _20000004
000005DE                          1057  
000005DE                          1058m     PRINT_CRLF D3,A0
000005DE  41FA 14E1               1059m     LEA CRLF(PC),A0
000005E2                          1060mm     PRINT_STR A0,D3
000005E2                          1061mm LOOP_56
000005E2  0C10 0000               1062mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005E6  6700 0016               1063mm     BEQ EXIT_56
000005EA                          1064mmm     PRINT_CHAR (A0)+,D3
000005EA                          1065mmm WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005EA                 TRUE     1066mmm     IFEQ DEBUG
000005EA  1639 00C00003           1067mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005F0  0803 0002               1068mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005F4  67F4                    1069mmm         BEQ WAIT_FOR_READY_57                       ; NO SPACE, CHECK AGAIN
000005F6  13D8 00C00007           1070mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005FC                          1071mmm     ENDC
000005FC                          1072mmm 
000005FC                 FALSE    1073mmm     IFNE DEBUG
000005FC                          1074mmm     ENDC
000005FC                          1075mmm 
000005FC                          1076mmm     ENDM
000005FC  60E4                    1077mm     BRA LOOP_56
000005FE                          1078mm EXIT_56
000005FE                          1079mm     ENDM
000005FE                          1080m     ENDM
000005FE                          1081  
000005FE  2047                    1082      MOVE.L D7,A0                                    ; address accumulator -> address register
00000600  7E00                    1083      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000602                          1084  
00000602  2085                    1085      MOVE.L D5,(A0)                                  ; write the data
00000604                          1086  
00000604  6000 FD5A               1087      BRA MAIN_LOOP
00000608                          1088  
00000608                          1089  ; register map for S
00000608                          1090  ; A0 - start address
00000608                          1091  ; A1 - offset
00000608                          1092  ; A2 - next address to write
00000608                          1093  ; A3 - next location (jmp)
00000608                          1094  ; A4 - Working Address Register
00000608                          1095  ; D0 - record count
00000608                          1096  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000608                          1097  ; D2 - checksum
00000608                          1098  ; D3 - data byte count
00000608                          1099  ; D4 - read address, moved into A2
00000608                          1100  ; D5 - temp
00000608                          1101  ; D6 - temp
00000608                          1102  ; D7 - temp
00000608                          1103  S
00000608  2078 0000               1104      MOVE.L 0,A0                                     ; start address -> A0
0000060C  2247                    1105      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000060E                          1106      
0000060E  7000                    1107      MOVE.L #0,D0                                    ; count of records read -> D0
00000610                          1108          
00000610                          1109  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000610                          1110m     DOWNLOAD D1
00000610                          1111m WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000610                          1112m 
00000610  1239 00C00003           1113m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000616  0801 0000               1114m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061A  6700 0010               1115m     BEQ CONTINUE_58                                 ; NOTHING, CONTINUE
0000061E                          1116m 
0000061E                          1117mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000061E                 TRUE     1118mm     IFEQ DEBUG
0000061E  1239 00C00007           1119mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000624                          1120mm     ENDC
00000624                 FALSE    1121mm     IFNE DEBUG
00000624                          1122mm     ENDC
00000624                          1123mm 
00000624  B23C 001B               1124mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000628  6700 FADA               1125mm     BEQ START
0000062C                          1126mm     ENDM
0000062C                          1127m CONTINUE_58
0000062C  1239 00C00013           1128m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000632  0801 0000               1129m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000636  67D8                    1130m     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000638                          1131m     
00000638  1239 00C00017           1132m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000063E  13C1 00E00001           1133m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000644                          1134m 
00000644                          1135m     ENDM
00000644  B23C 0053               1136      CMP.B #'S',D1                                   ; found S?
00000648  66C6                    1137      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000064A                          1138      
0000064A                          1139m     PRINT_CHAR #'S',D5                              ; print the S
0000064A                          1140m WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000064A                 TRUE     1141m     IFEQ DEBUG
0000064A  1A39 00C00003           1142m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000650  0805 0002               1143m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000654  67F4                    1144m         BEQ WAIT_FOR_READY_60                       ; NO SPACE, CHECK AGAIN
00000656  13FC 0053 00C00007      1145m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000065E                          1146m     ENDC
0000065E                          1147m 
0000065E                 FALSE    1148m     IFNE DEBUG
0000065E                          1149m     ENDC
0000065E                          1150m 
0000065E                          1151m     ENDM
0000065E  5280                    1152      ADD.L #1,D0                                     ; read another S record, increment count
00000660                          1153      
00000660                          1154m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000660                          1155m WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000660                          1156m 
00000660  1239 00C00003           1157m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000666  0801 0000               1158m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000066A  6700 0010               1159m     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000066E                          1160m 
0000066E                          1161mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000066E                 TRUE     1162mm     IFEQ DEBUG
0000066E  1239 00C00007           1163mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000674                          1164mm     ENDC
00000674                 FALSE    1165mm     IFNE DEBUG
00000674                          1166mm     ENDC
00000674                          1167mm 
00000674  B23C 001B               1168mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000678  6700 FA8A               1169mm     BEQ START
0000067C                          1170mm     ENDM
0000067C                          1171m CONTINUE_61
0000067C  1239 00C00013           1172m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000682  0801 0000               1173m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000686  67D8                    1174m     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000688                          1175m     
00000688  1239 00C00017           1176m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000068E  13C1 00E00001           1177m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000694                          1178m 
00000694                          1179m     ENDM
00000694                          1180m     PRINT_CHAR D1,D5
00000694                          1181m WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000694                 TRUE     1182m     IFEQ DEBUG
00000694  1A39 00C00003           1183m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000069A  0805 0002               1184m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000069E  67F4                    1185m         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006A0  13C1 00C00007           1186m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006A6                          1187m     ENDC
000006A6                          1188m 
000006A6                 FALSE    1189m     IFNE DEBUG
000006A6                          1190m     ENDC
000006A6                          1191m 
000006A6                          1192m     ENDM
000006A6                          1193  
000006A6  7400                    1194      MOVE.L #0,D2                                    ; clear the checksum
000006A8                          1195  
000006A8                          1196m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
000006A8  1E3C 0002               1197m     MOVE.B #2,D7
000006AC                          1198m     WHILE.B D7 <GT> 0 DO
000006AC                          1199ms _10000000
000006AC  BE38 0000               1200ms     CMP.B   0,D7
000006B0  6F00 0062               1201ms     BLE _10000001
000006B4  E98B                    1202m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000006B6                          1203mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006B6                          1204mm WAIT_FOR_READY_65                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006B6                          1205mm 
000006B6  1A39 00C00003           1206mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006BC  0805 0000               1207mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C0  6700 0010               1208mm     BEQ CONTINUE_65                                 ; NOTHING, CONTINUE
000006C4                          1209mm 
000006C4                          1210mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006C4                 TRUE     1211mmm     IFEQ DEBUG
000006C4  1A39 00C00007           1212mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006CA                          1213mmm     ENDC
000006CA                 FALSE    1214mmm     IFNE DEBUG
000006CA                          1215mmm     ENDC
000006CA                          1216mmm 
000006CA  BA3C 001B               1217mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006CE  6700 FA34               1218mmm     BEQ START
000006D2                          1219mmm     ENDM
000006D2                          1220mm CONTINUE_65
000006D2  1A39 00C00013           1221mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006D8  0805 0000               1222mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006DC  67D8                    1223mm     BEQ WAIT_FOR_READY_65                           ; NOTHING, CHECK AGAIN
000006DE                          1224mm     
000006DE  1A39 00C00017           1225mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006E4  13C5 00E00001           1226mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006EA                          1227mm 
000006EA                          1228mm     ENDM
000006EA                          1229mm         PRINT_CHAR D5,D6
000006EA                          1230mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006EA                 TRUE     1231mm     IFEQ DEBUG
000006EA  1C39 00C00003           1232mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006F0  0806 0002               1233mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006F4  67F4                    1234mm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000006F6  13C5 00C00007           1235mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006FC                          1236mm     ENDC
000006FC                          1237mm 
000006FC                 FALSE    1238mm     IFNE DEBUG
000006FC                          1239mm     ENDC
000006FC                          1240mm 
000006FC                          1241mm     ENDM
000006FC                          1242mm         HEX2BIN D5,D5,A4
000006FC  49FA 1355               1243mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000700  0405 0030               1244mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000704  CABC 000000FF           1245mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000070A  1A34 5000               1246mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000070E                          1247mm     ENDM
0000070E  8605                    1248m         OR.B D5,D3
00000710  5307                    1249m         SUB.B #1,D7
00000712                          1250m     ENDW
00000712  6098                    1251ms     BRA _10000000
00000714                          1252ms _10000001
00000714                          1253m 
00000714  7A00                    1254m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000716  1A03                    1255m     MOVE.B D3,D5
00000718  D483                    1256m     ADD.L D3,D2
0000071A                          1257m 
0000071A                          1258m     ENDM
0000071A                          1259  
0000071A                          1260      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000071A  B23C 0030               1261s     CMP.B   #'0',D1
0000071E  6600 002A               1262s     BNE.L   _00000004
00000722                          1263m         PRINT_CRLF D5,A4
00000722  49FA 139D               1264m     LEA CRLF(PC),A4
00000726                          1265mm     PRINT_STR A4,D5
00000726                          1266mm LOOP_70
00000726  0C14 0000               1267mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000072A  6700 0016               1268mm     BEQ EXIT_70
0000072E                          1269mmm     PRINT_CHAR (A4)+,D5
0000072E                          1270mmm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000072E                 TRUE     1271mmm     IFEQ DEBUG
0000072E  1A39 00C00003           1272mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000734  0805 0002               1273mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000738  67F4                    1274mmm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000073A  13DC 00C00007           1275mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000740                          1276mmm     ENDC
00000740                          1277mmm 
00000740                 FALSE    1278mmm     IFNE DEBUG
00000740                          1279mmm     ENDC
00000740                          1280mmm 
00000740                          1281mmm     ENDM
00000740  60E4                    1282mm     BRA LOOP_70
00000742                          1283mm EXIT_70
00000742                          1284mm     ENDM
00000742                          1285m     ENDM
00000742  6000 FECC               1286          BRA WAIT_FOR_SRECORD
00000746                          1287      ELSE
00000746  6000 03DE               1288s     BRA _00000005
0000074A                          1289s _00000004
0000074A                          1290          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
0000074A  B23C 0031               1291s     CMP.B   #'1',D1
0000074E  6708                    1292s     BEQ.S   _00000006
00000750  B23C 0032               1293s     CMP.B   #'2',D1
00000754  6600 01F0               1294s     BNE.L   _00000007
00000758                          1295s _00000006
00000758  5783                    1296              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000075A                          1297  
0000075A  7800                    1298              MOVE.L #0,D4                            ; read two bytes of address
0000075C                          1299m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
0000075C  1E3C 0002               1300m     MOVE.B #2,D7
00000760                          1301m     WHILE.B D7 <GT> 0 DO
00000760                          1302ms _10000002
00000760  BE38 0000               1303ms     CMP.B   0,D7
00000764  6F00 0062               1304ms     BLE _10000003
00000768  E98C                    1305m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000076A                          1306mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000076A                          1307mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076A                          1308mm 
0000076A  1A39 00C00003           1309mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000770  0805 0000               1310mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000774  6700 0010               1311mm     BEQ CONTINUE_73                                 ; NOTHING, CONTINUE
00000778                          1312mm 
00000778                          1313mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000778                 TRUE     1314mmm     IFEQ DEBUG
00000778  1A39 00C00007           1315mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000077E                          1316mmm     ENDC
0000077E                 FALSE    1317mmm     IFNE DEBUG
0000077E                          1318mmm     ENDC
0000077E                          1319mmm 
0000077E  BA3C 001B               1320mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000782  6700 F980               1321mmm     BEQ START
00000786                          1322mmm     ENDM
00000786                          1323mm CONTINUE_73
00000786  1A39 00C00013           1324mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000078C  0805 0000               1325mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000790  67D8                    1326mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
00000792                          1327mm     
00000792  1A39 00C00017           1328mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000798  13C5 00E00001           1329mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000079E                          1330mm 
0000079E                          1331mm     ENDM
0000079E                          1332mm         PRINT_CHAR D5,D6
0000079E                          1333mm WAIT_FOR_READY_75                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000079E                 TRUE     1334mm     IFEQ DEBUG
0000079E  1C39 00C00003           1335mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007A4  0806 0002               1336mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007A8  67F4                    1337mm         BEQ WAIT_FOR_READY_75                       ; NO SPACE, CHECK AGAIN
000007AA  13C5 00C00007           1338mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007B0                          1339mm     ENDC
000007B0                          1340mm 
000007B0                 FALSE    1341mm     IFNE DEBUG
000007B0                          1342mm     ENDC
000007B0                          1343mm 
000007B0                          1344mm     ENDM
000007B0                          1345mm         HEX2BIN D5,D5,A4
000007B0  49FA 12A1               1346mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007B4  0405 0030               1347mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B8  CABC 000000FF           1348mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007BE  1A34 5000               1349mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007C2                          1350mm     ENDM
000007C2  8805                    1351m         OR.B D5,D4
000007C4  5307                    1352m         SUB.B #1,D7
000007C6                          1353m     ENDW
000007C6  6098                    1354ms     BRA _10000002
000007C8                          1355ms _10000003
000007C8                          1356m 
000007C8  7A00                    1357m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007CA  1A04                    1358m     MOVE.B D4,D5
000007CC  D484                    1359m     ADD.L D4,D2
000007CE                          1360m 
000007CE                          1361m     ENDM
000007CE                          1362m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000007CE  1E3C 0002               1363m     MOVE.B #2,D7
000007D2                          1364m     WHILE.B D7 <GT> 0 DO
000007D2                          1365ms _10000004
000007D2  BE38 0000               1366ms     CMP.B   0,D7
000007D6  6F00 0062               1367ms     BLE _10000005
000007DA  E98C                    1368m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007DC                          1369mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007DC                          1370mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DC                          1371mm 
000007DC  1A39 00C00003           1372mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007E2  0805 0000               1373mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E6  6700 0010               1374mm     BEQ CONTINUE_78                                 ; NOTHING, CONTINUE
000007EA                          1375mm 
000007EA                          1376mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007EA                 TRUE     1377mmm     IFEQ DEBUG
000007EA  1A39 00C00007           1378mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007F0                          1379mmm     ENDC
000007F0                 FALSE    1380mmm     IFNE DEBUG
000007F0                          1381mmm     ENDC
000007F0                          1382mmm 
000007F0  BA3C 001B               1383mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007F4  6700 F90E               1384mmm     BEQ START
000007F8                          1385mmm     ENDM
000007F8                          1386mm CONTINUE_78
000007F8  1A39 00C00013           1387mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007FE  0805 0000               1388mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000802  67D8                    1389mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
00000804                          1390mm     
00000804  1A39 00C00017           1391mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000080A  13C5 00E00001           1392mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000810                          1393mm 
00000810                          1394mm     ENDM
00000810                          1395mm         PRINT_CHAR D5,D6
00000810                          1396mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000810                 TRUE     1397mm     IFEQ DEBUG
00000810  1C39 00C00003           1398mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000816  0806 0002               1399mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000081A  67F4                    1400mm         BEQ WAIT_FOR_READY_80                       ; NO SPACE, CHECK AGAIN
0000081C  13C5 00C00007           1401mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000822                          1402mm     ENDC
00000822                          1403mm 
00000822                 FALSE    1404mm     IFNE DEBUG
00000822                          1405mm     ENDC
00000822                          1406mm 
00000822                          1407mm     ENDM
00000822                          1408mm         HEX2BIN D5,D5,A4
00000822  49FA 122F               1409mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000826  0405 0030               1410mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000082A  CABC 000000FF           1411mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000830  1A34 5000               1412mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000834                          1413mm     ENDM
00000834  8805                    1414m         OR.B D5,D4
00000836  5307                    1415m         SUB.B #1,D7
00000838                          1416m     ENDW
00000838  6098                    1417ms     BRA _10000004
0000083A                          1418ms _10000005
0000083A                          1419m 
0000083A  7A00                    1420m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000083C  1A04                    1421m     MOVE.B D4,D5
0000083E  D484                    1422m     ADD.L D4,D2
00000840                          1423m 
00000840                          1424m     ENDM
00000840                          1425  
00000840                          1426              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000840  B23C 0032               1427s     CMP.B   #'2',D1
00000844  6600 0076               1428s     BNE.L   _00000008
00000848  5383                    1429                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000084A                          1430m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000084A  1E3C 0002               1431m     MOVE.B #2,D7
0000084E                          1432m     WHILE.B D7 <GT> 0 DO
0000084E                          1433ms _10000006
0000084E  BE38 0000               1434ms     CMP.B   0,D7
00000852  6F00 0062               1435ms     BLE _10000007
00000856  E98C                    1436m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000858                          1437mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000858                          1438mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000858                          1439mm 
00000858  1A39 00C00003           1440mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000085E  0805 0000               1441mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000862  6700 0010               1442mm     BEQ CONTINUE_83                                 ; NOTHING, CONTINUE
00000866                          1443mm 
00000866                          1444mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000866                 TRUE     1445mmm     IFEQ DEBUG
00000866  1A39 00C00007           1446mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000086C                          1447mmm     ENDC
0000086C                 FALSE    1448mmm     IFNE DEBUG
0000086C                          1449mmm     ENDC
0000086C                          1450mmm 
0000086C  BA3C 001B               1451mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000870  6700 F892               1452mmm     BEQ START
00000874                          1453mmm     ENDM
00000874                          1454mm CONTINUE_83
00000874  1A39 00C00013           1455mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000087A  0805 0000               1456mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000087E  67D8                    1457mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
00000880                          1458mm     
00000880  1A39 00C00017           1459mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000886  13C5 00E00001           1460mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000088C                          1461mm 
0000088C                          1462mm     ENDM
0000088C                          1463mm         PRINT_CHAR D5,D6
0000088C                          1464mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088C                 TRUE     1465mm     IFEQ DEBUG
0000088C  1C39 00C00003           1466mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000892  0806 0002               1467mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000896  67F4                    1468mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000898  13C5 00C00007           1469mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000089E                          1470mm     ENDC
0000089E                          1471mm 
0000089E                 FALSE    1472mm     IFNE DEBUG
0000089E                          1473mm     ENDC
0000089E                          1474mm 
0000089E                          1475mm     ENDM
0000089E                          1476mm         HEX2BIN D5,D5,A4
0000089E  49FA 11B3               1477mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008A2  0405 0030               1478mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008A6  CABC 000000FF           1479mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008AC  1A34 5000               1480mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008B0                          1481mm     ENDM
000008B0  8805                    1482m         OR.B D5,D4
000008B2  5307                    1483m         SUB.B #1,D7
000008B4                          1484m     ENDW
000008B4  6098                    1485ms     BRA _10000006
000008B6                          1486ms _10000007
000008B6                          1487m 
000008B6  7A00                    1488m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008B8  1A04                    1489m     MOVE.B D4,D5
000008BA  D484                    1490m     ADD.L D4,D2
000008BC                          1491m 
000008BC                          1492m     ENDM
000008BC                          1493              ENDI
000008BC                          1494s _00000008
000008BC                          1495  
000008BC  2444                    1496              MOVE.L D4,A2                            ; put the address in an address register
000008BE  D5C9                    1497              ADD.L A1,A2                             ; add in the offset
000008C0                          1498  
000008C0                          1499              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000008C0                          1500s _10000008
000008C0  B63C 0000               1501s     CMP.B   #0,D3
000008C4  6F00 007A               1502s     BLE _10000009
000008C8                          1503m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000008C8  1E3C 0002               1504m     MOVE.B #2,D7
000008CC                          1505m     WHILE.B D7 <GT> 0 DO
000008CC                          1506ms _1000000A
000008CC  BE38 0000               1507ms     CMP.B   0,D7
000008D0  6F00 0062               1508ms     BLE _1000000B
000008D4  E989                    1509m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000008D6                          1510mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008D6                          1511mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                          1512mm 
000008D6  1A39 00C00003           1513mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008DC  0805 0000               1514mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E0  6700 0010               1515mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
000008E4                          1516mm 
000008E4                          1517mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008E4                 TRUE     1518mmm     IFEQ DEBUG
000008E4  1A39 00C00007           1519mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008EA                          1520mmm     ENDC
000008EA                 FALSE    1521mmm     IFNE DEBUG
000008EA                          1522mmm     ENDC
000008EA                          1523mmm 
000008EA  BA3C 001B               1524mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008EE  6700 F814               1525mmm     BEQ START
000008F2                          1526mmm     ENDM
000008F2                          1527mm CONTINUE_88
000008F2  1A39 00C00013           1528mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008F8  0805 0000               1529mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008FC  67D8                    1530mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
000008FE                          1531mm     
000008FE  1A39 00C00017           1532mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000904  13C5 00E00001           1533mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000090A                          1534mm 
0000090A                          1535mm     ENDM
0000090A                          1536mm         PRINT_CHAR D5,D6
0000090A                          1537mm WAIT_FOR_READY_90                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090A                 TRUE     1538mm     IFEQ DEBUG
0000090A  1C39 00C00003           1539mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000910  0806 0002               1540mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000914  67F4                    1541mm         BEQ WAIT_FOR_READY_90                       ; NO SPACE, CHECK AGAIN
00000916  13C5 00C00007           1542mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000091C                          1543mm     ENDC
0000091C                          1544mm 
0000091C                 FALSE    1545mm     IFNE DEBUG
0000091C                          1546mm     ENDC
0000091C                          1547mm 
0000091C                          1548mm     ENDM
0000091C                          1549mm         HEX2BIN D5,D5,A4
0000091C  49FA 1135               1550mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000920  0405 0030               1551mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000924  CABC 000000FF           1552mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000092A  1A34 5000               1553mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000092E                          1554mm     ENDM
0000092E  8205                    1555m         OR.B D5,D1
00000930  5307                    1556m         SUB.B #1,D7
00000932                          1557m     ENDW
00000932  6098                    1558ms     BRA _1000000A
00000934                          1559ms _1000000B
00000934                          1560m 
00000934  7A00                    1561m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000936  1A01                    1562m     MOVE.B D1,D5
00000938  D481                    1563m     ADD.L D1,D2
0000093A                          1564m 
0000093A                          1565m     ENDM
0000093A                          1566   
0000093A  14C1                    1567                  MOVE.B D1,(A2)+                     ; store it!
0000093C                          1568  
0000093C  5303                    1569                  SUB.B #1,D3                         ; 1 less byte to go
0000093E                          1570              ENDW
0000093E  6080                    1571s     BRA _10000008
00000940                          1572s _10000009
00000940                          1573  
00000940  7200                    1574              MOVE.L #0,D1                            ; not done yet
00000942                          1575          ELSE
00000942  6000 01E2               1576s     BRA _00000009
00000946                          1577s _00000007
00000946                          1578              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000946  B23C 0038               1579s     CMP.B   #'8',D1
0000094A  6600 0164               1580s     BNE.L   _0000000A
0000094E  7800                    1581                  MOVE.L #0,D4                        ; read the 24 bit start address
00000950                          1582m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000950  1E3C 0002               1583m     MOVE.B #2,D7
00000954                          1584m     WHILE.B D7 <GT> 0 DO
00000954                          1585ms _1000000C
00000954  BE38 0000               1586ms     CMP.B   0,D7
00000958  6F00 0062               1587ms     BLE _1000000D
0000095C  E98C                    1588m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000095E                          1589mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000095E                          1590mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                          1591mm 
0000095E  1A39 00C00003           1592mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000964  0805 0000               1593mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000968  6700 0010               1594mm     BEQ CONTINUE_93                                 ; NOTHING, CONTINUE
0000096C                          1595mm 
0000096C                          1596mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000096C                 TRUE     1597mmm     IFEQ DEBUG
0000096C  1A39 00C00007           1598mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000972                          1599mmm     ENDC
00000972                 FALSE    1600mmm     IFNE DEBUG
00000972                          1601mmm     ENDC
00000972                          1602mmm 
00000972  BA3C 001B               1603mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000976  6700 F78C               1604mmm     BEQ START
0000097A                          1605mmm     ENDM
0000097A                          1606mm CONTINUE_93
0000097A  1A39 00C00013           1607mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000980  0805 0000               1608mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000984  67D8                    1609mm     BEQ WAIT_FOR_READY_93                           ; NOTHING, CHECK AGAIN
00000986                          1610mm     
00000986  1A39 00C00017           1611mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000098C  13C5 00E00001           1612mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000992                          1613mm 
00000992                          1614mm     ENDM
00000992                          1615mm         PRINT_CHAR D5,D6
00000992                          1616mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000992                 TRUE     1617mm     IFEQ DEBUG
00000992  1C39 00C00003           1618mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000998  0806 0002               1619mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000099C  67F4                    1620mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
0000099E  13C5 00C00007           1621mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009A4                          1622mm     ENDC
000009A4                          1623mm 
000009A4                 FALSE    1624mm     IFNE DEBUG
000009A4                          1625mm     ENDC
000009A4                          1626mm 
000009A4                          1627mm     ENDM
000009A4                          1628mm         HEX2BIN D5,D5,A4
000009A4  49FA 10AD               1629mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009A8  0405 0030               1630mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009AC  CABC 000000FF           1631mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009B2  1A34 5000               1632mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009B6                          1633mm     ENDM
000009B6  8805                    1634m         OR.B D5,D4
000009B8  5307                    1635m         SUB.B #1,D7
000009BA                          1636m     ENDW
000009BA  6098                    1637ms     BRA _1000000C
000009BC                          1638ms _1000000D
000009BC                          1639m 
000009BC  7A00                    1640m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009BE  1A04                    1641m     MOVE.B D4,D5
000009C0  D484                    1642m     ADD.L D4,D2
000009C2                          1643m 
000009C2                          1644m     ENDM
000009C2                          1645m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000009C2  1E3C 0002               1646m     MOVE.B #2,D7
000009C6                          1647m     WHILE.B D7 <GT> 0 DO
000009C6                          1648ms _1000000E
000009C6  BE38 0000               1649ms     CMP.B   0,D7
000009CA  6F00 0062               1650ms     BLE _1000000F
000009CE  E98C                    1651m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009D0                          1652mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009D0                          1653mm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009D0                          1654mm 
000009D0  1A39 00C00003           1655mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009D6  0805 0000               1656mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009DA  6700 0010               1657mm     BEQ CONTINUE_98                                 ; NOTHING, CONTINUE
000009DE                          1658mm 
000009DE                          1659mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009DE                 TRUE     1660mmm     IFEQ DEBUG
000009DE  1A39 00C00007           1661mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009E4                          1662mmm     ENDC
000009E4                 FALSE    1663mmm     IFNE DEBUG
000009E4                          1664mmm     ENDC
000009E4                          1665mmm 
000009E4  BA3C 001B               1666mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009E8  6700 F71A               1667mmm     BEQ START
000009EC                          1668mmm     ENDM
000009EC                          1669mm CONTINUE_98
000009EC  1A39 00C00013           1670mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009F2  0805 0000               1671mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009F6  67D8                    1672mm     BEQ WAIT_FOR_READY_98                           ; NOTHING, CHECK AGAIN
000009F8                          1673mm     
000009F8  1A39 00C00017           1674mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009FE  13C5 00E00001           1675mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A04                          1676mm 
00000A04                          1677mm     ENDM
00000A04                          1678mm         PRINT_CHAR D5,D6
00000A04                          1679mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A04                 TRUE     1680mm     IFEQ DEBUG
00000A04  1C39 00C00003           1681mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A0A  0806 0002               1682mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A0E  67F4                    1683mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000A10  13C5 00C00007           1684mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A16                          1685mm     ENDC
00000A16                          1686mm 
00000A16                 FALSE    1687mm     IFNE DEBUG
00000A16                          1688mm     ENDC
00000A16                          1689mm 
00000A16                          1690mm     ENDM
00000A16                          1691mm         HEX2BIN D5,D5,A4
00000A16  49FA 103B               1692mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A1A  0405 0030               1693mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A1E  CABC 000000FF           1694mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A24  1A34 5000               1695mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A28                          1696mm     ENDM
00000A28  8805                    1697m         OR.B D5,D4
00000A2A  5307                    1698m         SUB.B #1,D7
00000A2C                          1699m     ENDW
00000A2C  6098                    1700ms     BRA _1000000E
00000A2E                          1701ms _1000000F
00000A2E                          1702m 
00000A2E  7A00                    1703m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A30  1A04                    1704m     MOVE.B D4,D5
00000A32  D484                    1705m     ADD.L D4,D2
00000A34                          1706m 
00000A34                          1707m     ENDM
00000A34                          1708m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000A34  1E3C 0002               1709m     MOVE.B #2,D7
00000A38                          1710m     WHILE.B D7 <GT> 0 DO
00000A38                          1711ms _10000010
00000A38  BE38 0000               1712ms     CMP.B   0,D7
00000A3C  6F00 0062               1713ms     BLE _10000011
00000A40  E98C                    1714m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A42                          1715mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A42                          1716mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A42                          1717mm 
00000A42  1A39 00C00003           1718mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A48  0805 0000               1719mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A4C  6700 0010               1720mm     BEQ CONTINUE_103                                    ; NOTHING, CONTINUE
00000A50                          1721mm 
00000A50                          1722mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A50                 TRUE     1723mmm     IFEQ DEBUG
00000A50  1A39 00C00007           1724mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A56                          1725mmm     ENDC
00000A56                 FALSE    1726mmm     IFNE DEBUG
00000A56                          1727mmm     ENDC
00000A56                          1728mmm 
00000A56  BA3C 001B               1729mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A5A  6700 F6A8               1730mmm     BEQ START
00000A5E                          1731mmm     ENDM
00000A5E                          1732mm CONTINUE_103
00000A5E  1A39 00C00013           1733mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A64  0805 0000               1734mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A68  67D8                    1735mm     BEQ WAIT_FOR_READY_103                          ; NOTHING, CHECK AGAIN
00000A6A                          1736mm     
00000A6A  1A39 00C00017           1737mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A70  13C5 00E00001           1738mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A76                          1739mm 
00000A76                          1740mm     ENDM
00000A76                          1741mm         PRINT_CHAR D5,D6
00000A76                          1742mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A76                 TRUE     1743mm     IFEQ DEBUG
00000A76  1C39 00C00003           1744mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A7C  0806 0002               1745mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A80  67F4                    1746mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A82  13C5 00C00007           1747mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A88                          1748mm     ENDC
00000A88                          1749mm 
00000A88                 FALSE    1750mm     IFNE DEBUG
00000A88                          1751mm     ENDC
00000A88                          1752mm 
00000A88                          1753mm     ENDM
00000A88                          1754mm         HEX2BIN D5,D5,A4
00000A88  49FA 0FC9               1755mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A8C  0405 0030               1756mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A90  CABC 000000FF           1757mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A96  1A34 5000               1758mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A9A                          1759mm     ENDM
00000A9A  8805                    1760m         OR.B D5,D4
00000A9C  5307                    1761m         SUB.B #1,D7
00000A9E                          1762m     ENDW
00000A9E  6098                    1763ms     BRA _10000010
00000AA0                          1764ms _10000011
00000AA0                          1765m 
00000AA0  7A00                    1766m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AA2  1A04                    1767m     MOVE.B D4,D5
00000AA4  D484                    1768m     ADD.L D4,D2
00000AA6                          1769m 
00000AA6                          1770m     ENDM
00000AA6                          1771  
00000AA6  2044                    1772                  MOVE.L D4,A0                        ; start address -> A0
00000AA8  D1C9                    1773                  ADD.L A1,A0                         ; add in the offset
00000AAA                          1774  
00000AAA  72FF                    1775                  MOVE.L #$FFFFFFFF,D1                ; done
00000AAC                          1776              ELSE
00000AAC  6000 0078               1777s     BRA _0000000B
00000AB0                          1778s _0000000A
00000AB0                          1779m                 PRINT_CRLF D5,A4
00000AB0  49FA 100F               1780m     LEA CRLF(PC),A4
00000AB4                          1781mm     PRINT_STR A4,D5
00000AB4                          1782mm LOOP_108
00000AB4  0C14 0000               1783mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AB8  6700 0016               1784mm     BEQ EXIT_108
00000ABC                          1785mmm     PRINT_CHAR (A4)+,D5
00000ABC                          1786mmm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ABC                 TRUE     1787mmm     IFEQ DEBUG
00000ABC  1A39 00C00003           1788mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC2  0805 0002               1789mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AC6  67F4                    1790mmm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000AC8  13DC 00C00007           1791mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ACE                          1792mmm     ENDC
00000ACE                          1793mmm 
00000ACE                 FALSE    1794mmm     IFNE DEBUG
00000ACE                          1795mmm     ENDC
00000ACE                          1796mmm 
00000ACE                          1797mmm     ENDM
00000ACE  60E4                    1798mm     BRA LOOP_108
00000AD0                          1799mm EXIT_108
00000AD0                          1800mm     ENDM
00000AD0                          1801m     ENDM
00000AD0                          1802  
00000AD0  49FA 0F38               1803                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000AD4                          1804m                 PRINT_STR A4,D5
00000AD4                          1805m LOOP_110
00000AD4  0C14 0000               1806m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AD8  6700 0016               1807m     BEQ EXIT_110
00000ADC                          1808mm     PRINT_CHAR (A4)+,D5
00000ADC                          1809mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ADC                 TRUE     1810mm     IFEQ DEBUG
00000ADC  1A39 00C00003           1811mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AE2  0805 0002               1812mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AE6  67F4                    1813mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000AE8  13DC 00C00007           1814mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AEE                          1815mm     ENDC
00000AEE                          1816mm 
00000AEE                 FALSE    1817mm     IFNE DEBUG
00000AEE                          1818mm     ENDC
00000AEE                          1819mm 
00000AEE                          1820mm     ENDM
00000AEE  60E4                    1821m     BRA LOOP_110
00000AF0                          1822m EXIT_110
00000AF0                          1823m     ENDM
00000AF0                          1824m                 PRINT_CHAR D1,D5
00000AF0                          1825m WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF0                 TRUE     1826m     IFEQ DEBUG
00000AF0  1A39 00C00003           1827m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF6  0805 0002               1828m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFA  67F4                    1829m         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000AFC  13C1 00C00007           1830m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B02                          1831m     ENDC
00000B02                          1832m 
00000B02                 FALSE    1833m     IFNE DEBUG
00000B02                          1834m     ENDC
00000B02                          1835m 
00000B02                          1836m     ENDM
00000B02                          1837m                 PRINT_CRLF D5,A4
00000B02  49FA 0FBD               1838m     LEA CRLF(PC),A4
00000B06                          1839mm     PRINT_STR A4,D5
00000B06                          1840mm LOOP_114
00000B06  0C14 0000               1841mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B0A  6700 0016               1842mm     BEQ EXIT_114
00000B0E                          1843mmm     PRINT_CHAR (A4)+,D5
00000B0E                          1844mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0E                 TRUE     1845mmm     IFEQ DEBUG
00000B0E  1A39 00C00003           1846mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B14  0805 0002               1847mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B18  67F4                    1848mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B1A  13DC 00C00007           1849mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B20                          1850mmm     ENDC
00000B20                          1851mmm 
00000B20                 FALSE    1852mmm     IFNE DEBUG
00000B20                          1853mmm     ENDC
00000B20                          1854mmm 
00000B20                          1855mmm     ENDM
00000B20  60E4                    1856mm     BRA LOOP_114
00000B22                          1857mm EXIT_114
00000B22                          1858mm     ENDM
00000B22                          1859m     ENDM
00000B22                          1860  
00000B22  6000 FAEC               1861                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000B26                          1862              ENDI
00000B26                          1863s _0000000B
00000B26                          1864          ENDI
00000B26                          1865s _00000009
00000B26                          1866      ENDI
00000B26                          1867s _00000005
00000B26                          1868  
00000B26                          1869m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000B26  1E3C 0002               1870m     MOVE.B #2,D7
00000B2A                          1871m     WHILE.B D7 <GT> 0 DO
00000B2A                          1872ms _10000012
00000B2A  BE38 0000               1873ms     CMP.B   0,D7
00000B2E  6F00 0062               1874ms     BLE _10000013
00000B32  E98C                    1875m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B34                          1876mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B34                          1877mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B34                          1878mm 
00000B34  1A39 00C00003           1879mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B3A  0805 0000               1880mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B3E  6700 0010               1881mm     BEQ CONTINUE_117                                    ; NOTHING, CONTINUE
00000B42                          1882mm 
00000B42                          1883mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B42                 TRUE     1884mmm     IFEQ DEBUG
00000B42  1A39 00C00007           1885mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B48                          1886mmm     ENDC
00000B48                 FALSE    1887mmm     IFNE DEBUG
00000B48                          1888mmm     ENDC
00000B48                          1889mmm 
00000B48  BA3C 001B               1890mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B4C  6700 F5B6               1891mmm     BEQ START
00000B50                          1892mmm     ENDM
00000B50                          1893mm CONTINUE_117
00000B50  1A39 00C00013           1894mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B56  0805 0000               1895mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B5A  67D8                    1896mm     BEQ WAIT_FOR_READY_117                          ; NOTHING, CHECK AGAIN
00000B5C                          1897mm     
00000B5C  1A39 00C00017           1898mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B62  13C5 00E00001           1899mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B68                          1900mm 
00000B68                          1901mm     ENDM
00000B68                          1902mm         PRINT_CHAR D5,D6
00000B68                          1903mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B68                 TRUE     1904mm     IFEQ DEBUG
00000B68  1C39 00C00003           1905mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B6E  0806 0002               1906mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B72  67F4                    1907mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B74  13C5 00C00007           1908mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B7A                          1909mm     ENDC
00000B7A                          1910mm 
00000B7A                 FALSE    1911mm     IFNE DEBUG
00000B7A                          1912mm     ENDC
00000B7A                          1913mm 
00000B7A                          1914mm     ENDM
00000B7A                          1915mm         HEX2BIN D5,D5,A4
00000B7A  49FA 0ED7               1916mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B7E  0405 0030               1917mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B82  CABC 000000FF           1918mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B88  1A34 5000               1919mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B8C                          1920mm     ENDM
00000B8C  8805                    1921m         OR.B D5,D4
00000B8E  5307                    1922m         SUB.B #1,D7
00000B90                          1923m     ENDW
00000B90  6098                    1924ms     BRA _10000012
00000B92                          1925ms _10000013
00000B92                          1926m 
00000B92  7A00                    1927m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B94  1A04                    1928m     MOVE.B D4,D5
00000B96  D484                    1929m     ADD.L D4,D2
00000B98                          1930m 
00000B98                          1931m     ENDM
00000B98                          1932m     PRINT_CRLF D5,A4
00000B98  49FA 0F27               1933m     LEA CRLF(PC),A4
00000B9C                          1934mm     PRINT_STR A4,D5
00000B9C                          1935mm LOOP_122
00000B9C  0C14 0000               1936mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BA0  6700 0016               1937mm     BEQ EXIT_122
00000BA4                          1938mmm     PRINT_CHAR (A4)+,D5
00000BA4                          1939mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA4                 TRUE     1940mmm     IFEQ DEBUG
00000BA4  1A39 00C00003           1941mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BAA  0805 0002               1942mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BAE  67F4                    1943mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000BB0  13DC 00C00007           1944mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BB6                          1945mmm     ENDC
00000BB6                          1946mmm 
00000BB6                 FALSE    1947mmm     IFNE DEBUG
00000BB6                          1948mmm     ENDC
00000BB6                          1949mmm 
00000BB6                          1950mmm     ENDM
00000BB6  60E4                    1951mm     BRA LOOP_122
00000BB8                          1952mm EXIT_122
00000BB8                          1953mm     ENDM
00000BB8                          1954m     ENDM
00000BB8                          1955  
00000BB8                          1956      IF.B D2 <NE> #$FF THEN.L
00000BB8  B43C 00FF               1957s     CMP.B   #$FF,D2
00000BBC  6700 0090               1958s     BEQ.L   _0000000C
00000BC0  49FA 0E5F               1959          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000BC4                          1960m         PRINT_STR A4,D5
00000BC4                          1961m LOOP_124
00000BC4  0C14 0000               1962m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BC8  6700 0016               1963m     BEQ EXIT_124
00000BCC                          1964mm     PRINT_CHAR (A4)+,D5
00000BCC                          1965mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCC                 TRUE     1966mm     IFEQ DEBUG
00000BCC  1A39 00C00003           1967mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD2  0805 0002               1968mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BD6  67F4                    1969mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000BD8  13DC 00C00007           1970mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BDE                          1971mm     ENDC
00000BDE                          1972mm 
00000BDE                 FALSE    1973mm     IFNE DEBUG
00000BDE                          1974mm     ENDC
00000BDE                          1975mm 
00000BDE                          1976mm     ENDM
00000BDE  60E4                    1977m     BRA LOOP_124
00000BE0                          1978m EXIT_124
00000BE0                          1979m     ENDM
00000BE0                          1980m         PRINT_REG D0,D5,D3,D6,A4
00000BE0  49FA 0EE5               1981m     LEA OX(PC),A4
00000BE4                          1982mm     PRINT_STR A4,D5
00000BE4                          1983mm LOOP_127
00000BE4  0C14 0000               1984mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BE8  6700 0016               1985mm     BEQ EXIT_127
00000BEC                          1986mmm     PRINT_CHAR (A4)+,D5
00000BEC                          1987mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BEC                 TRUE     1988mmm     IFEQ DEBUG
00000BEC  1A39 00C00003           1989mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BF2  0805 0002               1990mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BF6  67F4                    1991mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000BF8  13DC 00C00007           1992mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BFE                          1993mmm     ENDC
00000BFE                          1994mmm 
00000BFE                 FALSE    1995mmm     IFNE DEBUG
00000BFE                          1996mmm     ENDC
00000BFE                          1997mmm 
00000BFE                          1998mmm     ENDM
00000BFE  60E4                    1999mm     BRA LOOP_127
00000C00                          2000mm EXIT_127
00000C00                          2001mm     ENDM
00000C00  7C07                    2002m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C02                          2003m LOOP_126
00000C02                          2004mm     BIN2HEX D0,D3,A4
00000C02  49FA 0E3F               2005mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000C06  E998                    2006mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C08  1600                    2007mm     MOVE.B D0,D3
00000C0A  0283 0000000F           2008mm     ANDI.L #$F,D3
00000C10  1634 3000               2009mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000C14                          2010mm     ENDM
00000C14                          2011mm     PRINT_CHAR D3,D5
00000C14                          2012mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C14                 TRUE     2013mm     IFEQ DEBUG
00000C14  1A39 00C00003           2014mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C1A  0805 0002               2015mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C1E  67F4                    2016mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000C20  13C3 00C00007           2017mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C26                          2018mm     ENDC
00000C26                          2019mm 
00000C26                 FALSE    2020mm     IFNE DEBUG
00000C26                          2021mm     ENDC
00000C26                          2022mm 
00000C26                          2023mm     ENDM
00000C26  57CE FFDA               2024m     DBEQ D6,LOOP_126
00000C2A                          2025m     ENDM
00000C2A                          2026m         PRINT_CRLF D5,A4
00000C2A  49FA 0E95               2027m     LEA CRLF(PC),A4
00000C2E                          2028mm     PRINT_STR A4,D5
00000C2E                          2029mm LOOP_132
00000C2E  0C14 0000               2030mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C32  6700 0016               2031mm     BEQ EXIT_132
00000C36                          2032mmm     PRINT_CHAR (A4)+,D5
00000C36                          2033mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C36                 TRUE     2034mmm     IFEQ DEBUG
00000C36  1A39 00C00003           2035mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C3C  0805 0002               2036mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C40  67F4                    2037mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000C42  13DC 00C00007           2038mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C48                          2039mmm     ENDC
00000C48                          2040mmm 
00000C48                 FALSE    2041mmm     IFNE DEBUG
00000C48                          2042mmm     ENDC
00000C48                          2043mmm 
00000C48                          2044mmm     ENDM
00000C48  60E4                    2045mm     BRA LOOP_132
00000C4A                          2046mm EXIT_132
00000C4A                          2047mm     ENDM
00000C4A                          2048m     ENDM
00000C4A                          2049          
00000C4A  6000 F714               2050          BRA MAIN_LOOP
00000C4E                          2051      ENDI
00000C4E                          2052s _0000000C
00000C4E                          2053  
00000C4E                          2054      IF D1 <EQ> #0 THEN
00000C4E  B27C 0000               2055s     CMP.W   #0,D1
00000C52  6600 0006               2056s     BNE _0000000D
00000C56  6000 F9B8               2057        BRA WAIT_FOR_SRECORD
00000C5A                          2058      ENDI
00000C5A                          2059s _0000000D
00000C5A                          2060  DOWNLOAD_DONE
00000C5A                          2061m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C5A  43FA 0E6B               2062m     LEA OX(PC),A1
00000C5E                          2063mm     PRINT_STR A1,D5
00000C5E                          2064mm LOOP_135
00000C5E  0C11 0000               2065mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C62  6700 0016               2066mm     BEQ EXIT_135
00000C66                          2067mmm     PRINT_CHAR (A1)+,D5
00000C66                          2068mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C66                 TRUE     2069mmm     IFEQ DEBUG
00000C66  1A39 00C00003           2070mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C6C  0805 0002               2071mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C70  67F4                    2072mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C72  13D9 00C00007           2073mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C78                          2074mmm     ENDC
00000C78                          2075mmm 
00000C78                 FALSE    2076mmm     IFNE DEBUG
00000C78                          2077mmm     ENDC
00000C78                          2078mmm 
00000C78                          2079mmm     ENDM
00000C78  60E4                    2080mm     BRA LOOP_135
00000C7A                          2081mm EXIT_135
00000C7A                          2082mm     ENDM
00000C7A  7407                    2083m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C7C                          2084m LOOP_134
00000C7C                          2085mm     BIN2HEX D0,D6,A1
00000C7C  43FA 0DC5               2086mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C80  E998                    2087mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C82  1C00                    2088mm     MOVE.B D0,D6
00000C84  0286 0000000F           2089mm     ANDI.L #$F,D6
00000C8A  1C31 6000               2090mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C8E                          2091mm     ENDM
00000C8E                          2092mm     PRINT_CHAR D6,D5
00000C8E                          2093mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     2094mm     IFEQ DEBUG
00000C8E  1A39 00C00003           2095mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C94  0805 0002               2096mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    2097mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000C9A  13C6 00C00007           2098mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CA0                          2099mm     ENDC
00000CA0                          2100mm 
00000CA0                 FALSE    2101mm     IFNE DEBUG
00000CA0                          2102mm     ENDC
00000CA0                          2103mm 
00000CA0                          2104mm     ENDM
00000CA0  57CA FFDA               2105m     DBEQ D2,LOOP_134
00000CA4                          2106m     ENDM
00000CA4  43FA 0D42               2107      LEA READ(PC),A1
00000CA8                          2108m     PRINT_STR A1,D5
00000CA8                          2109m LOOP_139
00000CA8  0C11 0000               2110m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CAC  6700 0016               2111m     BEQ EXIT_139
00000CB0                          2112mm     PRINT_CHAR (A1)+,D5
00000CB0                          2113mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB0                 TRUE     2114mm     IFEQ DEBUG
00000CB0  1A39 00C00003           2115mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CB6  0805 0002               2116mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CBA  67F4                    2117mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000CBC  13D9 00C00007           2118mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CC2                          2119mm     ENDC
00000CC2                          2120mm 
00000CC2                 FALSE    2121mm     IFNE DEBUG
00000CC2                          2122mm     ENDC
00000CC2                          2123mm 
00000CC2                          2124mm     ENDM
00000CC2  60E4                    2125m     BRA LOOP_139
00000CC4                          2126m EXIT_139
00000CC4                          2127m     ENDM
00000CC4  2E08                    2128      MOVE.L A0,D7                                    ; set address accumulator to start address
00000CC6                          2129m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000CC6  43FA 0DFF               2130m     LEA OX(PC),A1
00000CCA                          2131mm     PRINT_STR A1,D5
00000CCA                          2132mm LOOP_142
00000CCA  0C11 0000               2133mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CCE  6700 0016               2134mm     BEQ EXIT_142
00000CD2                          2135mmm     PRINT_CHAR (A1)+,D5
00000CD2                          2136mmm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD2                 TRUE     2137mmm     IFEQ DEBUG
00000CD2  1A39 00C00003           2138mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CD8  0805 0002               2139mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CDC  67F4                    2140mmm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000CDE  13D9 00C00007           2141mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CE4                          2142mmm     ENDC
00000CE4                          2143mmm 
00000CE4                 FALSE    2144mmm     IFNE DEBUG
00000CE4                          2145mmm     ENDC
00000CE4                          2146mmm 
00000CE4                          2147mmm     ENDM
00000CE4  60E4                    2148mm     BRA LOOP_142
00000CE6                          2149mm EXIT_142
00000CE6                          2150mm     ENDM
00000CE6  7407                    2151m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CE8                          2152m LOOP_141
00000CE8                          2153mm     BIN2HEX D7,D6,A1
00000CE8  43FA 0D59               2154mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CEC  E99F                    2155mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CEE  1C07                    2156mm     MOVE.B D7,D6
00000CF0  0286 0000000F           2157mm     ANDI.L #$F,D6
00000CF6  1C31 6000               2158mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CFA                          2159mm     ENDM
00000CFA                          2160mm     PRINT_CHAR D6,D5
00000CFA                          2161mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CFA                 TRUE     2162mm     IFEQ DEBUG
00000CFA  1A39 00C00003           2163mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D00  0805 0002               2164mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D04  67F4                    2165mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000D06  13C6 00C00007           2166mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D0C                          2167mm     ENDC
00000D0C                          2168mm 
00000D0C                 FALSE    2169mm     IFNE DEBUG
00000D0C                          2170mm     ENDC
00000D0C                          2171mm 
00000D0C                          2172mm     ENDM
00000D0C  57CA FFDA               2173m     DBEQ D2,LOOP_141
00000D10                          2174m     ENDM
00000D10                          2175m     PRINT_CRLF D5,A4
00000D10  49FA 0DAF               2176m     LEA CRLF(PC),A4
00000D14                          2177mm     PRINT_STR A4,D5
00000D14                          2178mm LOOP_147
00000D14  0C14 0000               2179mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000D18  6700 0016               2180mm     BEQ EXIT_147
00000D1C                          2181mmm     PRINT_CHAR (A4)+,D5
00000D1C                          2182mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D1C                 TRUE     2183mmm     IFEQ DEBUG
00000D1C  1A39 00C00003           2184mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D22  0805 0002               2185mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D26  67F4                    2186mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000D28  13DC 00C00007           2187mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D2E                          2188mmm     ENDC
00000D2E                          2189mmm 
00000D2E                 FALSE    2190mmm     IFNE DEBUG
00000D2E                          2191mmm     ENDC
00000D2E                          2192mmm 
00000D2E                          2193mmm     ENDM
00000D2E  60E4                    2194mm     BRA LOOP_147
00000D30                          2195mm EXIT_147
00000D30                          2196mm     ENDM
00000D30                          2197m     ENDM
00000D30                          2198  
00000D30  6000 F62E               2199      BRA MAIN_LOOP
00000D34                          2200  
00000D34                          2201  G
00000D34  2047                    2202      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000D36  7E00                    2203      MOVE.L #0,D7
00000D38                          2204  
00000D38  4ED0                    2205      JMP (A0)
00000D3A                          2206          
00000D3A                          2207  Z
00000D3A  207C 00200000           2208      MOVE.L #RAM,A0                                  ; address of RAM
00000D40  D1FC 00100000           2209      ADD.L #$100000,A0
00000D46                          2210  
00000D46                          2211      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000D46  7000                    2212s     MOVE.L  #0,D0
00000D48  6000 0012               2213s     BRA _20000007
00000D4C                          2214s _20000006
00000D4C  2200                    2215          MOVE.L D0,D1                                ; progress update
00000D4E  E089                    2216          LSR.L #8,D1 
00000D50  E089                    2217          LSR.L #8,D1
00000D52  13C1 00E00001           2218          MOVE.B D1,DISPLAY
00000D58                          2219          
00000D58  2108                    2220          MOVE.L A0,-(A0)
00000D5A                          2221      ENDF
00000D5A  5880                    2222s     ADD.L   #4,D0
00000D5C                          2223s _20000007
00000D5C  B0BC 000FFFFC           2224s     CMP.L   #$FFFFC,D0
00000D62  6FE8                    2225s     BLE _20000006
00000D64                          2226  
00000D64  207C 00200000           2227      MOVE.L #RAM,A0                                  ; address of RAM
00000D6A  D1FC 00100000           2228      ADD.L #$100000,A0
00000D70                          2229  
00000D70                          2230      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D70  7000                    2231s     MOVE.L  #0,D0
00000D72  6000 00A8               2232s     BRA _20000009
00000D76                          2233s _20000008
00000D76  2200                    2234          MOVE.L D0,D1                                ; progress update
00000D78  E089                    2235          LSR.L #8,D1
00000D7A  E089                    2236          LSR.L #8,D1
00000D7C  13C1 00E00001           2237          MOVE.B D1,DISPLAY
00000D82                          2238  
00000D82  2408                    2239          MOVE.L A0,D2
00000D84  2220                    2240          MOVE.L -(A0),D1
00000D86                          2241  
00000D86                          2242          IF.L D2 <NE> D1 THEN
00000D86  B481                    2243s     CMP.L   D1,D2
00000D88  6700 0090               2244s     BEQ _0000000E
00000D8C  43FA 0CA4               2245              LEA RAM_ERROR(PC),A1
00000D90                          2246m             PRINT_STR A1,D1
00000D90                          2247m LOOP_149
00000D90  0C11 0000               2248m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D94  6700 0016               2249m     BEQ EXIT_149
00000D98                          2250mm     PRINT_CHAR (A1)+,D1
00000D98                          2251mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D98                 TRUE     2252mm     IFEQ DEBUG
00000D98  1239 00C00003           2253mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D9E  0801 0002               2254mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000DA2  67F4                    2255mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00000DA4  13D9 00C00007           2256mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DAA                          2257mm     ENDC
00000DAA                          2258mm 
00000DAA                 FALSE    2259mm     IFNE DEBUG
00000DAA                          2260mm     ENDC
00000DAA                          2261mm 
00000DAA                          2262mm     ENDM
00000DAA  60E4                    2263m     BRA LOOP_149
00000DAC                          2264m EXIT_149
00000DAC                          2265m     ENDM
00000DAC  2208                    2266              MOVE.L A0,D1
00000DAE  5981                    2267              SUB.L #4,D1
00000DB0                          2268m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000DB0  43FA 0D15               2269m     LEA OX(PC),A1
00000DB4                          2270mm     PRINT_STR A1,D3
00000DB4                          2271mm LOOP_152
00000DB4  0C11 0000               2272mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DB8  6700 0016               2273mm     BEQ EXIT_152
00000DBC                          2274mmm     PRINT_CHAR (A1)+,D3
00000DBC                          2275mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBC                 TRUE     2276mmm     IFEQ DEBUG
00000DBC  1639 00C00003           2277mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DC2  0803 0002               2278mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DC6  67F4                    2279mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000DC8  13D9 00C00007           2280mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DCE                          2281mmm     ENDC
00000DCE                          2282mmm 
00000DCE                 FALSE    2283mmm     IFNE DEBUG
00000DCE                          2284mmm     ENDC
00000DCE                          2285mmm 
00000DCE                          2286mmm     ENDM
00000DCE  60E4                    2287mm     BRA LOOP_152
00000DD0                          2288mm EXIT_152
00000DD0                          2289mm     ENDM
00000DD0  7C07                    2290m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DD2                          2291m LOOP_151
00000DD2                          2292mm     BIN2HEX D1,D2,A1
00000DD2  43FA 0C6F               2293mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000DD6  E999                    2294mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DD8  1401                    2295mm     MOVE.B D1,D2
00000DDA  0282 0000000F           2296mm     ANDI.L #$F,D2
00000DE0  1431 2000               2297mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000DE4                          2298mm     ENDM
00000DE4                          2299mm     PRINT_CHAR D2,D3
00000DE4                          2300mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE4                 TRUE     2301mm     IFEQ DEBUG
00000DE4  1639 00C00003           2302mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DEA  0803 0002               2303mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DEE  67F4                    2304mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
00000DF0  13C2 00C00007           2305mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DF6                          2306mm     ENDC
00000DF6                          2307mm 
00000DF6                 FALSE    2308mm     IFNE DEBUG
00000DF6                          2309mm     ENDC
00000DF6                          2310mm 
00000DF6                          2311mm     ENDM
00000DF6  57CE FFDA               2312m     DBEQ D6,LOOP_151
00000DFA                          2313m     ENDM
00000DFA                          2314m             PRINT_CRLF D3,A1
00000DFA  43FA 0CC5               2315m     LEA CRLF(PC),A1
00000DFE                          2316mm     PRINT_STR A1,D3
00000DFE                          2317mm LOOP_157
00000DFE  0C11 0000               2318mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E02  6700 0016               2319mm     BEQ EXIT_157
00000E06                          2320mmm     PRINT_CHAR (A1)+,D3
00000E06                          2321mmm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E06                 TRUE     2322mmm     IFEQ DEBUG
00000E06  1639 00C00003           2323mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E0C  0803 0002               2324mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E10  67F4                    2325mmm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
00000E12  13D9 00C00007           2326mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E18                          2327mmm     ENDC
00000E18                          2328mmm 
00000E18                 FALSE    2329mmm     IFNE DEBUG
00000E18                          2330mmm     ENDC
00000E18                          2331mmm 
00000E18                          2332mmm     ENDM
00000E18  60E4                    2333mm     BRA LOOP_157
00000E1A                          2334mm EXIT_157
00000E1A                          2335mm     ENDM
00000E1A                          2336m     ENDM
00000E1A                          2337          ENDI 
00000E1A                          2338s _0000000E
00000E1A                          2339      ENDF
00000E1A  5880                    2340s     ADD.L   #4,D0
00000E1C                          2341s _20000009
00000E1C  B0BC 000FFFFC           2342s     CMP.L   #$FFFFC,D0
00000E22  6F00 FF52               2343s     BLE _20000008
00000E26                          2344  
00000E26  6000 F538               2345      BRA MAIN_LOOP
00000E2A                          2346  
00000E2A                          2347  L
00000E2A  7000                    2348      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000E2C  7200                    2349      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000E2E                          2350  
00000E2E                          2351      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000E2E  343C 0000               2352s     MOVE.W  #0,D2
00000E32  6000 0046               2353s     BRA _2000000B
00000E36                          2354s _2000000A
00000E36  E989                    2355          LSL.L #4,D1                                 ; make what we have so far more significant
00000E38                          2356m         WAIT_CHAR D3,D4                             ; next character -> D2
00000E38                          2357m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E38                 TRUE     2358m     IFEQ DEBUG
00000E38  1839 00C00003           2359m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E3E  0804 0000               2360m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000E42  67F4                    2361m         BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00000E44                          2362m     ENDC
00000E44                          2363m 
00000E44                          2364mm     READ_CHAR D3
00000E44                 TRUE     2365mm     IFEQ DEBUG
00000E44  1639 00C00007           2366mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000E4A                          2367mm     ENDC
00000E4A                 FALSE    2368mm     IFNE DEBUG
00000E4A                          2369mm     ENDC
00000E4A                          2370mm 
00000E4A  B63C 001B               2371mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E4E  6700 F2B4               2372mm     BEQ START
00000E52                          2373mm     ENDM
00000E52                          2374m 
00000E52                 TRUE     2375m     IFEQ DEBUG
00000E52                          2376mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E52                          2377mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E52                 TRUE     2378mm     IFEQ DEBUG
00000E52  1839 00C00003           2379mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E58  0804 0002               2380mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E5C  67F4                    2381mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E5E  13C3 00C00007           2382mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E64                          2383mm     ENDC
00000E64                          2384mm 
00000E64                 FALSE    2385mm     IFNE DEBUG
00000E64                          2386mm     ENDC
00000E64                          2387mm 
00000E64                          2388mm     ENDM
00000E64                          2389m     ENDC
00000E64                          2390m     ENDM
00000E64                          2391m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E64  41FA 0BED               2392m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E68  0403 0030               2393m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E6C  C6BC 000000FF           2394m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E72  1630 3000               2395m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E76                          2396m     ENDM
00000E76  8203                    2397          OR.B D3,D1
00000E78                          2398      ENDF
00000E78  5242                    2399s     ADD.W   #1,D2
00000E7A                          2400s _2000000B
00000E7A  B47C 0007               2401s     CMP.W   #7,D2
00000E7E  6FB6                    2402s     BLE _2000000A
00000E80                          2403  
00000E80  3001                    2404      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E82  0480 00000104           2405      SUB.L #START,D0                                 ; remove the vector table from the length
00000E88  E089                    2406      LSR.L #8,D1                                     ; extract the MSword for the address
00000E8A  E089                    2407      LSR.L #8,D1
00000E8C                          2408  
00000E8C                          2409m     PRINT_CRLF D2,A1
00000E8C  43FA 0C33               2410m     LEA CRLF(PC),A1
00000E90                          2411mm     PRINT_STR A1,D2
00000E90                          2412mm LOOP_164
00000E90  0C11 0000               2413mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E94  6700 0016               2414mm     BEQ EXIT_164
00000E98                          2415mmm     PRINT_CHAR (A1)+,D2
00000E98                          2416mmm WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E98                 TRUE     2417mmm     IFEQ DEBUG
00000E98  1439 00C00003           2418mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E9E  0802 0002               2419mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EA2  67F4                    2420mmm         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
00000EA4  13D9 00C00007           2421mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EAA                          2422mmm     ENDC
00000EAA                          2423mmm 
00000EAA                 FALSE    2424mmm     IFNE DEBUG
00000EAA                          2425mmm     ENDC
00000EAA                          2426mmm 
00000EAA                          2427mmm     ENDM
00000EAA  60E4                    2428mm     BRA LOOP_164
00000EAC                          2429mm EXIT_164
00000EAC                          2430mm     ENDM
00000EAC                          2431m     ENDM
00000EAC                          2432  
00000EAC  2041                    2433      MOVE.L D1,A0                                    ; target address
00000EAE  2641                    2434      MOVE.L D1,A3                                    ; keep a copy for later
00000EB0                          2435  
00000EB0  2247                    2436      MOVE.L D7,A1                                    ; address accumulator -> address register
00000EB2  D3FC 00000104           2437      ADD.L #START,A1                                 ; skip the vectors
00000EB8  2847                    2438      MOVE.L D7,A4                                    ; keep a clean copy for later
00000EBA  7E00                    2439      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EBC                          2440  
00000EBC                          2441m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000EBC  31FC AAAA 2AAA          2442m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EC2  4E71                    2443m     NOP
00000EC4  31FC 5555 1554          2444m     MOVE.W #$5555,$1554
00000ECA  4E71                    2445m     NOP
00000ECC  31FC 8080 2AAA          2446m     MOVE.W #$8080,$2AAA
00000ED2  4E71                    2447m     NOP
00000ED4  31FC AAAA 2AAA          2448m     MOVE.W #$AAAA,$2AAA
00000EDA  4E71                    2449m     NOP
00000EDC  31FC 5555 1554          2450m     MOVE.W #$5555,$1554
00000EE2  4E71                    2451m     NOP
00000EE4  31FC 2020 2AAA          2452m     MOVE.W #$2020,$2AAA
00000EEA                          2453m     ENDM
00000EEA                          2454                              
00000EEA                          2455      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000EEA  3E3C 0000               2456s     MOVE.W  #$0,D7
00000EEE  6000 0006               2457s     BRA _2000000D
00000EF2                          2458s _2000000C
00000EF2  4E71                    2459          NOP
00000EF4                          2460      ENDF
00000EF4  5247                    2461s     ADD.W   #1,D7
00000EF6                          2462s _2000000D
00000EF6  BE7C FFFF               2463s     CMP.W   #$FFFFFFFF,D7
00000EFA  6FF6                    2464s     BLE _2000000C
00000EFC                          2465  
00000EFC  45FA 0B6C               2466      LEA LOADING(PC),A2
00000F00                          2467m     PRINT_STR A2,D2
00000F00                          2468m LOOP_167
00000F00  0C12 0000               2469m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F04  6700 0016               2470m     BEQ EXIT_167
00000F08                          2471mm     PRINT_CHAR (A2)+,D2
00000F08                          2472mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F08                 TRUE     2473mm     IFEQ DEBUG
00000F08  1439 00C00003           2474mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F0E  0802 0002               2475mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F12  67F4                    2476mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000F14  13DA 00C00007           2477mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F1A                          2478mm     ENDC
00000F1A                          2479mm 
00000F1A                 FALSE    2480mm     IFNE DEBUG
00000F1A                          2481mm     ENDC
00000F1A                          2482mm 
00000F1A                          2483mm     ENDM
00000F1A  60E4                    2484m     BRA LOOP_167
00000F1C                          2485m EXIT_167
00000F1C                          2486m     ENDM
00000F1C                          2487      
00000F1C  45FA 0B60               2488      LEA CODE(PC),A2
00000F20                          2489m     PRINT_STR A2,D2
00000F20                          2490m LOOP_169
00000F20  0C12 0000               2491m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F24  6700 0016               2492m     BEQ EXIT_169
00000F28                          2493mm     PRINT_CHAR (A2)+,D2
00000F28                          2494mm WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F28                 TRUE     2495mm     IFEQ DEBUG
00000F28  1439 00C00003           2496mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F2E  0802 0002               2497mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F32  67F4                    2498mm         BEQ WAIT_FOR_READY_170                      ; NO SPACE, CHECK AGAIN
00000F34  13DA 00C00007           2499mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F3A                          2500mm     ENDC
00000F3A                          2501mm 
00000F3A                 FALSE    2502mm     IFNE DEBUG
00000F3A                          2503mm     ENDC
00000F3A                          2504mm 
00000F3A                          2505mm     ENDM
00000F3A  60E4                    2506m     BRA LOOP_169
00000F3C                          2507m EXIT_169
00000F3C                          2508m     ENDM
00000F3C                          2509      
00000F3C  2409                    2510      MOVE.L A1,D2
00000F3E                          2511m     PRINT_REG D2,D3,D4,D5,A2
00000F3E  45FA 0B87               2512m     LEA OX(PC),A2
00000F42                          2513mm     PRINT_STR A2,D3
00000F42                          2514mm LOOP_172
00000F42  0C12 0000               2515mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F46  6700 0016               2516mm     BEQ EXIT_172
00000F4A                          2517mmm     PRINT_CHAR (A2)+,D3
00000F4A                          2518mmm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F4A                 TRUE     2519mmm     IFEQ DEBUG
00000F4A  1639 00C00003           2520mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F50  0803 0002               2521mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F54  67F4                    2522mmm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F56  13DA 00C00007           2523mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F5C                          2524mmm     ENDC
00000F5C                          2525mmm 
00000F5C                 FALSE    2526mmm     IFNE DEBUG
00000F5C                          2527mmm     ENDC
00000F5C                          2528mmm 
00000F5C                          2529mmm     ENDM
00000F5C  60E4                    2530mm     BRA LOOP_172
00000F5E                          2531mm EXIT_172
00000F5E                          2532mm     ENDM
00000F5E  7A07                    2533m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F60                          2534m LOOP_171
00000F60                          2535mm     BIN2HEX D2,D4,A2
00000F60  45FA 0AE1               2536mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F64  E99A                    2537mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F66  1802                    2538mm     MOVE.B D2,D4
00000F68  0284 0000000F           2539mm     ANDI.L #$F,D4
00000F6E  1832 4000               2540mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F72                          2541mm     ENDM
00000F72                          2542mm     PRINT_CHAR D4,D3
00000F72                          2543mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F72                 TRUE     2544mm     IFEQ DEBUG
00000F72  1639 00C00003           2545mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F78  0803 0002               2546mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F7C  67F4                    2547mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00000F7E  13C4 00C00007           2548mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F84                          2549mm     ENDC
00000F84                          2550mm 
00000F84                 FALSE    2551mm     IFNE DEBUG
00000F84                          2552mm     ENDC
00000F84                          2553mm 
00000F84                          2554mm     ENDM
00000F84  57CD FFDA               2555m     DBEQ D5,LOOP_171
00000F88                          2556m     ENDM
00000F88                          2557  
00000F88  45FA 0B40               2558      LEA TO(PC),A2
00000F8C                          2559m     PRINT_STR A2,D3
00000F8C                          2560m LOOP_176
00000F8C  0C12 0000               2561m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F90  6700 0016               2562m     BEQ EXIT_176
00000F94                          2563mm     PRINT_CHAR (A2)+,D3
00000F94                          2564mm WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F94                 TRUE     2565mm     IFEQ DEBUG
00000F94  1639 00C00003           2566mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F9A  0803 0002               2567mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F9E  67F4                    2568mm         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
00000FA0  13DA 00C00007           2569mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FA6                          2570mm     ENDC
00000FA6                          2571mm 
00000FA6                 FALSE    2572mm     IFNE DEBUG
00000FA6                          2573mm     ENDC
00000FA6                          2574mm 
00000FA6                          2575mm     ENDM
00000FA6  60E4                    2576m     BRA LOOP_176
00000FA8                          2577m EXIT_176
00000FA8                          2578m     ENDM
00000FA8                          2579  
00000FA8  2408                    2580      MOVE.L A0,D2
00000FAA                          2581m     PRINT_REG D2,D3,D4,D5,A2
00000FAA  45FA 0B1B               2582m     LEA OX(PC),A2
00000FAE                          2583mm     PRINT_STR A2,D3
00000FAE                          2584mm LOOP_179
00000FAE  0C12 0000               2585mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FB2  6700 0016               2586mm     BEQ EXIT_179
00000FB6                          2587mmm     PRINT_CHAR (A2)+,D3
00000FB6                          2588mmm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FB6                 TRUE     2589mmm     IFEQ DEBUG
00000FB6  1639 00C00003           2590mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FBC  0803 0002               2591mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FC0  67F4                    2592mmm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000FC2  13DA 00C00007           2593mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FC8                          2594mmm     ENDC
00000FC8                          2595mmm 
00000FC8                 FALSE    2596mmm     IFNE DEBUG
00000FC8                          2597mmm     ENDC
00000FC8                          2598mmm 
00000FC8                          2599mmm     ENDM
00000FC8  60E4                    2600mm     BRA LOOP_179
00000FCA                          2601mm EXIT_179
00000FCA                          2602mm     ENDM
00000FCA  7A07                    2603m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FCC                          2604m LOOP_178
00000FCC                          2605mm     BIN2HEX D2,D4,A2
00000FCC  45FA 0A75               2606mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FD0  E99A                    2607mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FD2  1802                    2608mm     MOVE.B D2,D4
00000FD4  0284 0000000F           2609mm     ANDI.L #$F,D4
00000FDA  1832 4000               2610mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FDE                          2611mm     ENDM
00000FDE                          2612mm     PRINT_CHAR D4,D3
00000FDE                          2613mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FDE                 TRUE     2614mm     IFEQ DEBUG
00000FDE  1639 00C00003           2615mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FE4  0803 0002               2616mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FE8  67F4                    2617mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000FEA  13C4 00C00007           2618mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FF0                          2619mm     ENDC
00000FF0                          2620mm 
00000FF0                 FALSE    2621mm     IFNE DEBUG
00000FF0                          2622mm     ENDC
00000FF0                          2623mm 
00000FF0                          2624mm     ENDM
00000FF0  57CD FFDA               2625m     DBEQ D5,LOOP_178
00000FF4                          2626m     ENDM
00000FF4                          2627  
00000FF4  45FA 0AD9               2628      LEA FOR(PC),A2
00000FF8                          2629m     PRINT_STR A2,D3
00000FF8                          2630m LOOP_183
00000FF8  0C12 0000               2631m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FFC  6700 0016               2632m     BEQ EXIT_183
00001000                          2633mm     PRINT_CHAR (A2)+,D3
00001000                          2634mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001000                 TRUE     2635mm     IFEQ DEBUG
00001000  1639 00C00003           2636mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001006  0803 0002               2637mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000100A  67F4                    2638mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
0000100C  13DA 00C00007           2639mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001012                          2640mm     ENDC
00001012                          2641mm 
00001012                 FALSE    2642mm     IFNE DEBUG
00001012                          2643mm     ENDC
00001012                          2644mm 
00001012                          2645mm     ENDM
00001012  60E4                    2646m     BRA LOOP_183
00001014                          2647m EXIT_183
00001014                          2648m     ENDM
00001014                          2649m     PRINT_REG D0,D3,D4,D5,A2
00001014  45FA 0AB1               2650m     LEA OX(PC),A2
00001018                          2651mm     PRINT_STR A2,D3
00001018                          2652mm LOOP_186
00001018  0C12 0000               2653mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000101C  6700 0016               2654mm     BEQ EXIT_186
00001020                          2655mmm     PRINT_CHAR (A2)+,D3
00001020                          2656mmm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001020                 TRUE     2657mmm     IFEQ DEBUG
00001020  1639 00C00003           2658mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001026  0803 0002               2659mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000102A  67F4                    2660mmm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
0000102C  13DA 00C00007           2661mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001032                          2662mmm     ENDC
00001032                          2663mmm 
00001032                 FALSE    2664mmm     IFNE DEBUG
00001032                          2665mmm     ENDC
00001032                          2666mmm 
00001032                          2667mmm     ENDM
00001032  60E4                    2668mm     BRA LOOP_186
00001034                          2669mm EXIT_186
00001034                          2670mm     ENDM
00001034  7A07                    2671m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001036                          2672m LOOP_185
00001036                          2673mm     BIN2HEX D0,D4,A2
00001036  45FA 0A0B               2674mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000103A  E998                    2675mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000103C  1800                    2676mm     MOVE.B D0,D4
0000103E  0284 0000000F           2677mm     ANDI.L #$F,D4
00001044  1832 4000               2678mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001048                          2679mm     ENDM
00001048                          2680mm     PRINT_CHAR D4,D3
00001048                          2681mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001048                 TRUE     2682mm     IFEQ DEBUG
00001048  1639 00C00003           2683mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000104E  0803 0002               2684mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001052  67F4                    2685mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
00001054  13C4 00C00007           2686mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000105A                          2687mm     ENDC
0000105A                          2688mm 
0000105A                 FALSE    2689mm     IFNE DEBUG
0000105A                          2690mm     ENDC
0000105A                          2691mm 
0000105A                          2692mm     ENDM
0000105A  57CD FFDA               2693m     DBEQ D5,LOOP_185
0000105E                          2694m     ENDM
0000105E                          2695  
0000105E                          2696m     PRINT_CRLF D3,A2
0000105E  45FA 0A61               2697m     LEA CRLF(PC),A2
00001062                          2698mm     PRINT_STR A2,D3
00001062                          2699mm LOOP_191
00001062  0C12 0000               2700mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001066  6700 0016               2701mm     BEQ EXIT_191
0000106A                          2702mmm     PRINT_CHAR (A2)+,D3
0000106A                          2703mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000106A                 TRUE     2704mmm     IFEQ DEBUG
0000106A  1639 00C00003           2705mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001070  0803 0002               2706mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001074  67F4                    2707mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00001076  13DA 00C00007           2708mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000107C                          2709mmm     ENDC
0000107C                          2710mmm 
0000107C                 FALSE    2711mmm     IFNE DEBUG
0000107C                          2712mmm     ENDC
0000107C                          2713mmm 
0000107C                          2714mmm     ENDM
0000107C  60E4                    2715mm     BRA LOOP_191
0000107E                          2716mm EXIT_191
0000107E                          2717mm     ENDM
0000107E                          2718m     ENDM
0000107E                          2719  
0000107E                          2720      WHILE D0 <GT> #0 DO
0000107E                          2721s _10000014
0000107E  B07C 0000               2722s     CMP.W   #0,D0
00001082  6F00 001C               2723s     BLE _10000015
00001086  5580                    2724          SUB.L #2,D0
00001088                          2725  
00001088  13D1 00E00001           2726          MOVE.B (A1),DISPLAY
0000108E                          2727m         PROGRAM (A1),(A0),D2
0000108E  3091                    2728m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001090                          2729m 
00001090                          2730m WAIT_FOR_COMPLETE_193
00001090  3410                    2731m         MOVE.W (A0),D2
00001092                          2732m 
00001092                          2733m         IF.W D2 <NE> (A1) THEN
00001092  B451                    2734ms     CMP.W   (A1),D2
00001094  6700 0004               2735ms     BEQ _0000000F
00001098  60F6                    2736m             BRA WAIT_FOR_COMPLETE_193
0000109A                          2737m         ENDI
0000109A                          2738ms _0000000F
0000109A                          2739m         ENDM
0000109A                          2740          
0000109A                          2741          ;PRINT_CHAR #'.',D7
0000109A                          2742          
0000109A  5488                    2743          ADD.L #2,A0
0000109C  5489                    2744          ADD.L #2,A1
0000109E                          2745      ENDW
0000109E  60DE                    2746s     BRA _10000014
000010A0                          2747s _10000015
000010A0                          2748  
000010A0  45FA 09EB               2749      LEA SP(PC),A2
000010A4                          2750m     PRINT_STR A2,D2
000010A4                          2751m LOOP_194
000010A4  0C12 0000               2752m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010A8  6700 0016               2753m     BEQ EXIT_194
000010AC                          2754mm     PRINT_CHAR (A2)+,D2
000010AC                          2755mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010AC                 TRUE     2756mm     IFEQ DEBUG
000010AC  1439 00C00003           2757mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010B2  0802 0002               2758mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010B6  67F4                    2759mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
000010B8  13DA 00C00007           2760mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010BE                          2761mm     ENDC
000010BE                          2762mm 
000010BE                 FALSE    2763mm     IFNE DEBUG
000010BE                          2764mm     ENDC
000010BE                          2765mm 
000010BE                          2766mm     ENDM
000010BE  60E4                    2767m     BRA LOOP_194
000010C0                          2768m EXIT_194
000010C0                          2769m     ENDM
000010C0                          2770      
000010C0  41F8 0000               2771      LEA STACK,A0
000010C4  D1CC                    2772      ADD.L A4,A0
000010C6  2010                    2773      MOVE.L (A0),D0
000010C8                          2774m     PRINT_REG D0,D2,D3,D4,A3
000010C8  47FA 09FD               2775m     LEA OX(PC),A3
000010CC                          2776mm     PRINT_STR A3,D2
000010CC                          2777mm LOOP_197
000010CC  0C13 0000               2778mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000010D0  6700 0016               2779mm     BEQ EXIT_197
000010D4                          2780mmm     PRINT_CHAR (A3)+,D2
000010D4                          2781mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010D4                 TRUE     2782mmm     IFEQ DEBUG
000010D4  1439 00C00003           2783mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010DA  0802 0002               2784mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010DE  67F4                    2785mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
000010E0  13DB 00C00007           2786mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010E6                          2787mmm     ENDC
000010E6                          2788mmm 
000010E6                 FALSE    2789mmm     IFNE DEBUG
000010E6                          2790mmm     ENDC
000010E6                          2791mmm 
000010E6                          2792mmm     ENDM
000010E6  60E4                    2793mm     BRA LOOP_197
000010E8                          2794mm EXIT_197
000010E8                          2795mm     ENDM
000010E8  7807                    2796m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010EA                          2797m LOOP_196
000010EA                          2798mm     BIN2HEX D0,D3,A3
000010EA  47FA 0957               2799mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000010EE  E998                    2800mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010F0  1600                    2801mm     MOVE.B D0,D3
000010F2  0283 0000000F           2802mm     ANDI.L #$F,D3
000010F8  1633 3000               2803mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000010FC                          2804mm     ENDM
000010FC                          2805mm     PRINT_CHAR D3,D2
000010FC                          2806mm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010FC                 TRUE     2807mm     IFEQ DEBUG
000010FC  1439 00C00003           2808mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001102  0802 0002               2809mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001106  67F4                    2810mm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
00001108  13C3 00C00007           2811mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000110E                          2812mm     ENDC
0000110E                          2813mm 
0000110E                 FALSE    2814mm     IFNE DEBUG
0000110E                          2815mm     ENDC
0000110E                          2816mm 
0000110E                          2817mm     ENDM
0000110E  57CC FFDA               2818m     DBEQ D4,LOOP_196
00001112                          2819m     ENDM
00001112                          2820m     PRINT_CRLF D2,A2
00001112  45FA 09AD               2821m     LEA CRLF(PC),A2
00001116                          2822mm     PRINT_STR A2,D2
00001116                          2823mm LOOP_202
00001116  0C12 0000               2824mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000111A  6700 0016               2825mm     BEQ EXIT_202
0000111E                          2826mmm     PRINT_CHAR (A2)+,D2
0000111E                          2827mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000111E                 TRUE     2828mmm     IFEQ DEBUG
0000111E  1439 00C00003           2829mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001124  0802 0002               2830mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001128  67F4                    2831mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
0000112A  13DA 00C00007           2832mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001130                          2833mmm     ENDC
00001130                          2834mmm 
00001130                 FALSE    2835mmm     IFNE DEBUG
00001130                          2836mmm     ENDC
00001130                          2837mmm 
00001130                          2838mmm     ENDM
00001130  60E4                    2839mm     BRA LOOP_202
00001132                          2840mm EXIT_202
00001132                          2841mm     ENDM
00001132                          2842m     ENDM
00001132                          2843      
00001132  207C 00000000           2844      MOVE.L #0,A0
00001138                          2845m     PROGRAM_VECTOR D0,A0,D2
00001138  5488                    2846m     ADD.L #2,A0
0000113A                          2847mm     PROGRAM D0, (A0), D2                                ; WRITE IT
0000113A  3080                    2848mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000113C                          2849mm 
0000113C                          2850mm WAIT_FOR_COMPLETE_205
0000113C  3410                    2851mm         MOVE.W (A0),D2
0000113E                          2852mm 
0000113E                          2853mm         IF.W D2 <NE> D0 THEN
0000113E  B440                    2854mms     CMP.W   D0,D2
00001140  6700 0004               2855mms     BEQ _00000010
00001144  60F6                    2856mm             BRA WAIT_FOR_COMPLETE_205
00001146                          2857mm         ENDI
00001146                          2858mms _00000010
00001146                          2859mm         ENDM
00001146  E088                    2860m     LSR.L #8,D0
00001148  E088                    2861m     LSR.L #8,D0
0000114A  5588                    2862m     SUB.L #2,A0
0000114C                          2863mm     PROGRAM D0, (A0), D2
0000114C  3080                    2864mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000114E                          2865mm 
0000114E                          2866mm WAIT_FOR_COMPLETE_206
0000114E  3410                    2867mm         MOVE.W (A0),D2
00001150                          2868mm 
00001150                          2869mm         IF.W D2 <NE> D0 THEN
00001150  B440                    2870mms     CMP.W   D0,D2
00001152  6700 0004               2871mms     BEQ _00000011
00001156  60F6                    2872mm             BRA WAIT_FOR_COMPLETE_206
00001158                          2873mm         ENDI
00001158                          2874mms _00000011
00001158                          2875mm         ENDM
00001158                          2876m     ENDM
00001158                          2877      
00001158  45FA 0955               2878      LEA VECTORS(PC),A2
0000115C                          2879m     PRINT_STR A2,D2
0000115C                          2880m LOOP_207
0000115C  0C12 0000               2881m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001160  6700 0016               2882m     BEQ EXIT_207
00001164                          2883mm     PRINT_CHAR (A2)+,D2
00001164                          2884mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001164                 TRUE     2885mm     IFEQ DEBUG
00001164  1439 00C00003           2886mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000116A  0802 0002               2887mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000116E  67F4                    2888mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
00001170  13DA 00C00007           2889mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001176                          2890mm     ENDC
00001176                          2891mm 
00001176                 FALSE    2892mm     IFNE DEBUG
00001176                          2893mm     ENDC
00001176                          2894mm 
00001176                          2895mm     ENDM
00001176  60E4                    2896m     BRA LOOP_207
00001178                          2897m EXIT_207
00001178                          2898m     ENDM
00001178                          2899  
00001178                          2900      FOR A0 = #RESET TO #START-4 BY #4 DO
00001178  307C 0004               2901s     MOVE.W  #RESET,A0
0000117C  6000 0108               2902s     BRA _2000000F
00001180                          2903s _2000000E
00001180                          2904  
00001180  2248                    2905          MOVE.L A0,A1
00001182  D3CC                    2906          ADD.L A4,A1
00001184                          2907              
00001184  2011                    2908          MOVE.L (A1),D0  
00001186  D081                    2909          ADD.L D1,D0
00001188  0480 00000104           2910          SUB.L #START,D0
0000118E                          2911m         PRINT_REG D0,D2,D3,D4,A3
0000118E  47FA 0937               2912m     LEA OX(PC),A3
00001192                          2913mm     PRINT_STR A3,D2
00001192                          2914mm LOOP_210
00001192  0C13 0000               2915mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001196  6700 0016               2916mm     BEQ EXIT_210
0000119A                          2917mmm     PRINT_CHAR (A3)+,D2
0000119A                          2918mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000119A                 TRUE     2919mmm     IFEQ DEBUG
0000119A  1439 00C00003           2920mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011A0  0802 0002               2921mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011A4  67F4                    2922mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000011A6  13DB 00C00007           2923mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011AC                          2924mmm     ENDC
000011AC                          2925mmm 
000011AC                 FALSE    2926mmm     IFNE DEBUG
000011AC                          2927mmm     ENDC
000011AC                          2928mmm 
000011AC                          2929mmm     ENDM
000011AC  60E4                    2930mm     BRA LOOP_210
000011AE                          2931mm EXIT_210
000011AE                          2932mm     ENDM
000011AE  7807                    2933m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011B0                          2934m LOOP_209
000011B0                          2935mm     BIN2HEX D0,D3,A3
000011B0  47FA 0891               2936mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000011B4  E998                    2937mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011B6  1600                    2938mm     MOVE.B D0,D3
000011B8  0283 0000000F           2939mm     ANDI.L #$F,D3
000011BE  1633 3000               2940mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000011C2                          2941mm     ENDM
000011C2                          2942mm     PRINT_CHAR D3,D2
000011C2                          2943mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011C2                 TRUE     2944mm     IFEQ DEBUG
000011C2  1439 00C00003           2945mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011C8  0802 0002               2946mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011CC  67F4                    2947mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
000011CE  13C3 00C00007           2948mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011D4                          2949mm     ENDC
000011D4                          2950mm 
000011D4                 FALSE    2951mm     IFNE DEBUG
000011D4                          2952mm     ENDC
000011D4                          2953mm 
000011D4                          2954mm     ENDM
000011D4  57CC FFDA               2955m     DBEQ D4,LOOP_209
000011D8                          2956m     ENDM
000011D8                          2957  
000011D8  47FA 08F0               2958          LEA TO(PC),A3
000011DC                          2959m         PRINT_STR A3,D3
000011DC                          2960m LOOP_214
000011DC  0C13 0000               2961m     CMP.B #NULL,(A3)                                ; 0 -> DONE
000011E0  6700 0016               2962m     BEQ EXIT_214
000011E4                          2963mm     PRINT_CHAR (A3)+,D3
000011E4                          2964mm WAIT_FOR_READY_215                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011E4                 TRUE     2965mm     IFEQ DEBUG
000011E4  1639 00C00003           2966mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011EA  0803 0002               2967mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011EE  67F4                    2968mm         BEQ WAIT_FOR_READY_215                      ; NO SPACE, CHECK AGAIN
000011F0  13DB 00C00007           2969mm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011F6                          2970mm     ENDC
000011F6                          2971mm 
000011F6                 FALSE    2972mm     IFNE DEBUG
000011F6                          2973mm     ENDC
000011F6                          2974mm 
000011F6                          2975mm     ENDM
000011F6  60E4                    2976m     BRA LOOP_214
000011F8                          2977m EXIT_214
000011F8                          2978m     ENDM
000011F8                          2979  
000011F8  2408                    2980          MOVE.L A0,D2
000011FA                          2981m         PRINT_REG D2,D3,D4,D5,A3
000011FA  47FA 08CB               2982m     LEA OX(PC),A3
000011FE                          2983mm     PRINT_STR A3,D3
000011FE                          2984mm LOOP_217
000011FE  0C13 0000               2985mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001202  6700 0016               2986mm     BEQ EXIT_217
00001206                          2987mmm     PRINT_CHAR (A3)+,D3
00001206                          2988mmm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001206                 TRUE     2989mmm     IFEQ DEBUG
00001206  1639 00C00003           2990mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000120C  0803 0002               2991mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001210  67F4                    2992mmm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001212  13DB 00C00007           2993mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001218                          2994mmm     ENDC
00001218                          2995mmm 
00001218                 FALSE    2996mmm     IFNE DEBUG
00001218                          2997mmm     ENDC
00001218                          2998mmm 
00001218                          2999mmm     ENDM
00001218  60E4                    3000mm     BRA LOOP_217
0000121A                          3001mm EXIT_217
0000121A                          3002mm     ENDM
0000121A  7A07                    3003m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000121C                          3004m LOOP_216
0000121C                          3005mm     BIN2HEX D2,D4,A3
0000121C  47FA 0825               3006mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
00001220  E99A                    3007mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001222  1802                    3008mm     MOVE.B D2,D4
00001224  0284 0000000F           3009mm     ANDI.L #$F,D4
0000122A  1833 4000               3010mm     MOVE.B 0(A3,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000122E                          3011mm     ENDM
0000122E                          3012mm     PRINT_CHAR D4,D3
0000122E                          3013mm WAIT_FOR_READY_220                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000122E                 TRUE     3014mm     IFEQ DEBUG
0000122E  1639 00C00003           3015mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001234  0803 0002               3016mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001238  67F4                    3017mm         BEQ WAIT_FOR_READY_220                      ; NO SPACE, CHECK AGAIN
0000123A  13C4 00C00007           3018mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001240                          3019mm     ENDC
00001240                          3020mm 
00001240                 FALSE    3021mm     IFNE DEBUG
00001240                          3022mm     ENDC
00001240                          3023mm 
00001240                          3024mm     ENDM
00001240  57CD FFDA               3025m     DBEQ D5,LOOP_216
00001244                          3026m     ENDM
00001244                          3027          
00001244                          3028m         PRINT_CRLF D2,A3
00001244  47FA 087B               3029m     LEA CRLF(PC),A3
00001248                          3030mm     PRINT_STR A3,D2
00001248                          3031mm LOOP_222
00001248  0C13 0000               3032mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000124C  6700 0016               3033mm     BEQ EXIT_222
00001250                          3034mmm     PRINT_CHAR (A3)+,D2
00001250                          3035mmm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001250                 TRUE     3036mmm     IFEQ DEBUG
00001250  1439 00C00003           3037mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001256  0802 0002               3038mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000125A  67F4                    3039mmm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
0000125C  13DB 00C00007           3040mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001262                          3041mmm     ENDC
00001262                          3042mmm 
00001262                 FALSE    3043mmm     IFNE DEBUG
00001262                          3044mmm     ENDC
00001262                          3045mmm 
00001262                          3046mmm     ENDM
00001262  60E4                    3047mm     BRA LOOP_222
00001264                          3048mm EXIT_222
00001264                          3049mm     ENDM
00001264                          3050m     ENDM
00001264                          3051          
00001264                          3052m         PROGRAM_VECTOR D0,A0,D2
00001264  5488                    3053m     ADD.L #2,A0
00001266                          3054mm     PROGRAM D0, (A0), D2                                ; WRITE IT
00001266  3080                    3055mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001268                          3056mm 
00001268                          3057mm WAIT_FOR_COMPLETE_225
00001268  3410                    3058mm         MOVE.W (A0),D2
0000126A                          3059mm 
0000126A                          3060mm         IF.W D2 <NE> D0 THEN
0000126A  B440                    3061mms     CMP.W   D0,D2
0000126C  6700 0004               3062mms     BEQ _00000012
00001270  60F6                    3063mm             BRA WAIT_FOR_COMPLETE_225
00001272                          3064mm         ENDI
00001272                          3065mms _00000012
00001272                          3066mm         ENDM
00001272  E088                    3067m     LSR.L #8,D0
00001274  E088                    3068m     LSR.L #8,D0
00001276  5588                    3069m     SUB.L #2,A0
00001278                          3070mm     PROGRAM D0, (A0), D2
00001278  3080                    3071mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000127A                          3072mm 
0000127A                          3073mm WAIT_FOR_COMPLETE_226
0000127A  3410                    3074mm         MOVE.W (A0),D2
0000127C                          3075mm 
0000127C                          3076mm         IF.W D2 <NE> D0 THEN
0000127C  B440                    3077mms     CMP.W   D0,D2
0000127E  6700 0004               3078mms     BEQ _00000013
00001282  60F6                    3079mm             BRA WAIT_FOR_COMPLETE_226
00001284                          3080mm         ENDI
00001284                          3081mms _00000013
00001284                          3082mm         ENDM
00001284                          3083m     ENDM
00001284                          3084      ENDF
00001284  5848                    3085s     ADD.W   #4,A0
00001286                          3086s _2000000F
00001286  B0FC 0100               3087s     CMP.W   #START-4,A0
0000128A  6F00 FEF4               3088s     BLE _2000000E
0000128E                          3089                                          
0000128E                          3090m     PROTECT
0000128E  31FC AAAA 2AAA          3091m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001294  31FC 5555 1554          3092m     MOVE.W #$5555,$1554
0000129A  31FC A0A0 2AAA          3093m     MOVE.W #$A0A0,$2AAA
000012A0                          3094m     ENDM
000012A0                          3095  
000012A0  6000 F0BE               3096      BRA MAIN_LOOP
000012A4                          3097      
000012A4                          3098  P
000012A4  7000                    3099      MOVE.L #0,D0                                    ; D0 will be the data to write
000012A6                          3100  
000012A6                          3101      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000012A6  323C 0000               3102s     MOVE.W  #0,D1
000012AA  6000 0046               3103s     BRA _20000011
000012AE                          3104s _20000010
000012AE  E988                    3105          LSL.L #4,D0                                 ; make what we have so far more significant
000012B0                          3106m         WAIT_CHAR D2,D3                             ; next character -> D2
000012B0                          3107m WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B0                 TRUE     3108m     IFEQ DEBUG
000012B0  1639 00C00003           3109m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B6  0803 0000               3110m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000012BA  67F4                    3111m         BEQ WAIT_FOR_READY_228                      ; NOTHING, CHECK AGAIN
000012BC                          3112m     ENDC
000012BC                          3113m 
000012BC                          3114mm     READ_CHAR D2
000012BC                 TRUE     3115mm     IFEQ DEBUG
000012BC  1439 00C00007           3116mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000012C2                          3117mm     ENDC
000012C2                 FALSE    3118mm     IFNE DEBUG
000012C2                          3119mm     ENDC
000012C2                          3120mm 
000012C2  B43C 001B               3121mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000012C6  6700 EE3C               3122mm     BEQ START
000012CA                          3123mm     ENDM
000012CA                          3124m 
000012CA                 TRUE     3125m     IFEQ DEBUG
000012CA                          3126mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000012CA                          3127mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012CA                 TRUE     3128mm     IFEQ DEBUG
000012CA  1639 00C00003           3129mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012D0  0803 0002               3130mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012D4  67F4                    3131mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
000012D6  13C2 00C00007           3132mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012DC                          3133mm     ENDC
000012DC                          3134mm 
000012DC                 FALSE    3135mm     IFNE DEBUG
000012DC                          3136mm     ENDC
000012DC                          3137mm 
000012DC                          3138mm     ENDM
000012DC                          3139m     ENDC
000012DC                          3140m     ENDM
000012DC                          3141m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000012DC  41FA 0775               3142m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000012E0  0402 0030               3143m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000012E4  C4BC 000000FF           3144m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000012EA  1430 2000               3145m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000012EE                          3146m     ENDM
000012EE  8002                    3147          OR.B D2,D0
000012F0                          3148      ENDF
000012F0  5241                    3149s     ADD.W   #1,D1
000012F2                          3150s _20000011
000012F2  B27C 0003               3151s     CMP.W   #3,D1
000012F6  6FB6                    3152s     BLE _20000010
000012F8                          3153  
000012F8                          3154m     PRINT_CRLF D2,A1
000012F8  43FA 07C7               3155m     LEA CRLF(PC),A1
000012FC                          3156mm     PRINT_STR A1,D2
000012FC                          3157mm LOOP_233
000012FC  0C11 0000               3158mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001300  6700 0016               3159mm     BEQ EXIT_233
00001304                          3160mmm     PRINT_CHAR (A1)+,D2
00001304                          3161mmm WAIT_FOR_READY_234                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001304                 TRUE     3162mmm     IFEQ DEBUG
00001304  1439 00C00003           3163mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000130A  0802 0002               3164mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000130E  67F4                    3165mmm         BEQ WAIT_FOR_READY_234                      ; NO SPACE, CHECK AGAIN
00001310  13D9 00C00007           3166mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001316                          3167mmm     ENDC
00001316                          3168mmm 
00001316                 FALSE    3169mmm     IFNE DEBUG
00001316                          3170mmm     ENDC
00001316                          3171mmm 
00001316                          3172mmm     ENDM
00001316  60E4                    3173mm     BRA LOOP_233
00001318                          3174mm EXIT_233
00001318                          3175mm     ENDM
00001318                          3176m     ENDM
00001318                          3177  
00001318  2047                    3178      MOVE.L D7,A0                                    ; address accumulator -> target address register
0000131A  7E00                    3179      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000131C                          3180  
0000131C                          3181m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
0000131C  31FC AAAA 2AAA          3182m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00001322  4E71                    3183m     NOP
00001324  31FC 5555 1554          3184m     MOVE.W #$5555,$1554
0000132A  4E71                    3185m     NOP
0000132C  31FC 8080 2AAA          3186m     MOVE.W #$8080,$2AAA
00001332  4E71                    3187m     NOP
00001334  31FC AAAA 2AAA          3188m     MOVE.W #$AAAA,$2AAA
0000133A  4E71                    3189m     NOP
0000133C  31FC 5555 1554          3190m     MOVE.W #$5555,$1554
00001342  4E71                    3191m     NOP
00001344  31FC 2020 2AAA          3192m     MOVE.W #$2020,$2AAA
0000134A                          3193m     ENDM
0000134A                          3194                              
0000134A                          3195      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
0000134A  3E3C 0000               3196s     MOVE.W  #$0,D7
0000134E  6000 0006               3197s     BRA _20000013
00001352                          3198s _20000012
00001352  4E71                    3199          NOP
00001354                          3200      ENDF
00001354  5247                    3201s     ADD.W   #1,D7
00001356                          3202s _20000013
00001356  BE7C FFFF               3203s     CMP.W   #$FFFFFFFF,D7
0000135A  6FF6                    3204s     BLE _20000012
0000135C                          3205               
0000135C  45FA 070C               3206      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00001360                          3207m     PRINT_STR A2,D2
00001360                          3208m LOOP_236
00001360  0C12 0000               3209m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001364  6700 0016               3210m     BEQ EXIT_236
00001368                          3211mm     PRINT_CHAR (A2)+,D2
00001368                          3212mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001368                 TRUE     3213mm     IFEQ DEBUG
00001368  1439 00C00003           3214mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000136E  0802 0002               3215mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001372  67F4                    3216mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
00001374  13DA 00C00007           3217mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000137A                          3218mm     ENDC
0000137A                          3219mm 
0000137A                 FALSE    3220mm     IFNE DEBUG
0000137A                          3221mm     ENDC
0000137A                          3222mm 
0000137A                          3223mm     ENDM
0000137A  60E4                    3224m     BRA LOOP_236
0000137C                          3225m EXIT_236
0000137C                          3226m     ENDM
0000137C                          3227  
0000137C                          3228m     PRINT_REG D0,D3,D4,D5,A2
0000137C  45FA 0749               3229m     LEA OX(PC),A2
00001380                          3230mm     PRINT_STR A2,D3
00001380                          3231mm LOOP_239
00001380  0C12 0000               3232mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001384  6700 0016               3233mm     BEQ EXIT_239
00001388                          3234mmm     PRINT_CHAR (A2)+,D3
00001388                          3235mmm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001388                 TRUE     3236mmm     IFEQ DEBUG
00001388  1639 00C00003           3237mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000138E  0803 0002               3238mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001392  67F4                    3239mmm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
00001394  13DA 00C00007           3240mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000139A                          3241mmm     ENDC
0000139A                          3242mmm 
0000139A                 FALSE    3243mmm     IFNE DEBUG
0000139A                          3244mmm     ENDC
0000139A                          3245mmm 
0000139A                          3246mmm     ENDM
0000139A  60E4                    3247mm     BRA LOOP_239
0000139C                          3248mm EXIT_239
0000139C                          3249mm     ENDM
0000139C  7A07                    3250m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000139E                          3251m LOOP_238
0000139E                          3252mm     BIN2HEX D0,D4,A2
0000139E  45FA 06A3               3253mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000013A2  E998                    3254mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000013A4  1800                    3255mm     MOVE.B D0,D4
000013A6  0284 0000000F           3256mm     ANDI.L #$F,D4
000013AC  1832 4000               3257mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000013B0                          3258mm     ENDM
000013B0                          3259mm     PRINT_CHAR D4,D3
000013B0                          3260mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013B0                 TRUE     3261mm     IFEQ DEBUG
000013B0  1639 00C00003           3262mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013B6  0803 0002               3263mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013BA  67F4                    3264mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
000013BC  13C4 00C00007           3265mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013C2                          3266mm     ENDC
000013C2                          3267mm 
000013C2                 FALSE    3268mm     IFNE DEBUG
000013C2                          3269mm     ENDC
000013C2                          3270mm 
000013C2                          3271mm     ENDM
000013C2  57CD FFDA               3272m     DBEQ D5,LOOP_238
000013C6                          3273m     ENDM
000013C6                          3274  
000013C6  45FA 0702               3275      LEA TO(PC),A2
000013CA                          3276m     PRINT_STR A2,D3
000013CA                          3277m LOOP_243
000013CA  0C12 0000               3278m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013CE  6700 0016               3279m     BEQ EXIT_243
000013D2                          3280mm     PRINT_CHAR (A2)+,D3
000013D2                          3281mm WAIT_FOR_READY_244                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013D2                 TRUE     3282mm     IFEQ DEBUG
000013D2  1639 00C00003           3283mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013D8  0803 0002               3284mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013DC  67F4                    3285mm         BEQ WAIT_FOR_READY_244                      ; NO SPACE, CHECK AGAIN
000013DE  13DA 00C00007           3286mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013E4                          3287mm     ENDC
000013E4                          3288mm 
000013E4                 FALSE    3289mm     IFNE DEBUG
000013E4                          3290mm     ENDC
000013E4                          3291mm 
000013E4                          3292mm     ENDM
000013E4  60E4                    3293m     BRA LOOP_243
000013E6                          3294m EXIT_243
000013E6                          3295m     ENDM
000013E6                          3296  
000013E6  2408                    3297      MOVE.L A0,D2
000013E8                          3298m     PRINT_REG D2,D3,D4,D5,A2
000013E8  45FA 06DD               3299m     LEA OX(PC),A2
000013EC                          3300mm     PRINT_STR A2,D3
000013EC                          3301mm LOOP_246
000013EC  0C12 0000               3302mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013F0  6700 0016               3303mm     BEQ EXIT_246
000013F4                          3304mmm     PRINT_CHAR (A2)+,D3
000013F4                          3305mmm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013F4                 TRUE     3306mmm     IFEQ DEBUG
000013F4  1639 00C00003           3307mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013FA  0803 0002               3308mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013FE  67F4                    3309mmm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
00001400  13DA 00C00007           3310mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001406                          3311mmm     ENDC
00001406                          3312mmm 
00001406                 FALSE    3313mmm     IFNE DEBUG
00001406                          3314mmm     ENDC
00001406                          3315mmm 
00001406                          3316mmm     ENDM
00001406  60E4                    3317mm     BRA LOOP_246
00001408                          3318mm EXIT_246
00001408                          3319mm     ENDM
00001408  7A07                    3320m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000140A                          3321m LOOP_245
0000140A                          3322mm     BIN2HEX D2,D4,A2
0000140A  45FA 0637               3323mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000140E  E99A                    3324mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001410  1802                    3325mm     MOVE.B D2,D4
00001412  0284 0000000F           3326mm     ANDI.L #$F,D4
00001418  1832 4000               3327mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000141C                          3328mm     ENDM
0000141C                          3329mm     PRINT_CHAR D4,D3
0000141C                          3330mm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000141C                 TRUE     3331mm     IFEQ DEBUG
0000141C  1639 00C00003           3332mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001422  0803 0002               3333mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001426  67F4                    3334mm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
00001428  13C4 00C00007           3335mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000142E                          3336mm     ENDC
0000142E                          3337mm 
0000142E                 FALSE    3338mm     IFNE DEBUG
0000142E                          3339mm     ENDC
0000142E                          3340mm 
0000142E                          3341mm     ENDM
0000142E  57CD FFDA               3342m     DBEQ D5,LOOP_245
00001432                          3343m     ENDM
00001432                          3344  
00001432                          3345m     PRINT_CRLF D3,A2
00001432  45FA 068D               3346m     LEA CRLF(PC),A2
00001436                          3347mm     PRINT_STR A2,D3
00001436                          3348mm LOOP_251
00001436  0C12 0000               3349mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000143A  6700 0016               3350mm     BEQ EXIT_251
0000143E                          3351mmm     PRINT_CHAR (A2)+,D3
0000143E                          3352mmm WAIT_FOR_READY_252                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000143E                 TRUE     3353mmm     IFEQ DEBUG
0000143E  1639 00C00003           3354mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001444  0803 0002               3355mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001448  67F4                    3356mmm         BEQ WAIT_FOR_READY_252                      ; NO SPACE, CHECK AGAIN
0000144A  13DA 00C00007           3357mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001450                          3358mmm     ENDC
00001450                          3359mmm 
00001450                 FALSE    3360mmm     IFNE DEBUG
00001450                          3361mmm     ENDC
00001450                          3362mmm 
00001450                          3363mmm     ENDM
00001450  60E4                    3364mm     BRA LOOP_251
00001452                          3365mm EXIT_251
00001452                          3366mm     ENDM
00001452                          3367m     ENDM
00001452                          3368  
00001452                          3369m     PROGRAM D0,(A0),D2
00001452  3080                    3370m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001454                          3371m 
00001454                          3372m WAIT_FOR_COMPLETE_253
00001454  3410                    3373m         MOVE.W (A0),D2
00001456                          3374m 
00001456                          3375m         IF.W D2 <NE> D0 THEN
00001456  B440                    3376ms     CMP.W   D0,D2
00001458  6700 0004               3377ms     BEQ _00000014
0000145C  60F6                    3378m             BRA WAIT_FOR_COMPLETE_253
0000145E                          3379m         ENDI
0000145E                          3380ms _00000014
0000145E                          3381m         ENDM
0000145E                          3382  
0000145E                          3383m     PROTECT
0000145E  31FC AAAA 2AAA          3384m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001464  31FC 5555 1554          3385m     MOVE.W #$5555,$1554
0000146A  31FC A0A0 2AAA          3386m     MOVE.W #$A0A0,$2AAA
00001470                          3387m     ENDM
00001470                          3388  
00001470  6000 EEEE               3389      BRA MAIN_LOOP
00001474                          3390      
00001474                          3391  M
00001474  7000                    3392      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001476  7200                    3393      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001478                          3394  
00001478                          3395      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001478  343C 0000               3396s     MOVE.W  #0,D2
0000147C  6000 0046               3397s     BRA _20000015
00001480                          3398s _20000014
00001480  E989                    3399          LSL.L #4,D1                                     ; make what we have so far more significant
00001482                          3400m         WAIT_CHAR D3,D4                                 ; next character -> D2
00001482                          3401m WAIT_FOR_READY_255                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001482                 TRUE     3402m     IFEQ DEBUG
00001482  1839 00C00003           3403m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001488  0804 0000               3404m         BTST #0,D4                                  ; CHECK FOR CHARACTER
0000148C  67F4                    3405m         BEQ WAIT_FOR_READY_255                      ; NOTHING, CHECK AGAIN
0000148E                          3406m     ENDC
0000148E                          3407m 
0000148E                          3408mm     READ_CHAR D3
0000148E                 TRUE     3409mm     IFEQ DEBUG
0000148E  1639 00C00007           3410mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001494                          3411mm     ENDC
00001494                 FALSE    3412mm     IFNE DEBUG
00001494                          3413mm     ENDC
00001494                          3414mm 
00001494  B63C 001B               3415mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001498  6700 EC6A               3416mm     BEQ START
0000149C                          3417mm     ENDM
0000149C                          3418m 
0000149C                 TRUE     3419m     IFEQ DEBUG
0000149C                          3420mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
0000149C                          3421mm WAIT_FOR_READY_257                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000149C                 TRUE     3422mm     IFEQ DEBUG
0000149C  1839 00C00003           3423mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000014A2  0804 0002               3424mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
000014A6  67F4                    3425mm         BEQ WAIT_FOR_READY_257                      ; NO SPACE, CHECK AGAIN
000014A8  13C3 00C00007           3426mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014AE                          3427mm     ENDC
000014AE                          3428mm 
000014AE                 FALSE    3429mm     IFNE DEBUG
000014AE                          3430mm     ENDC
000014AE                          3431mm 
000014AE                          3432mm     ENDM
000014AE                          3433m     ENDC
000014AE                          3434m     ENDM
000014AE                          3435m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
000014AE  41FA 05A3               3436m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000014B2  0403 0030               3437m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000014B6  C6BC 000000FF           3438m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
000014BC  1630 3000               3439m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
000014C0                          3440m     ENDM
000014C0  8203                    3441          OR.B D3,D1
000014C2                          3442      ENDF
000014C2  5242                    3443s     ADD.W   #1,D2
000014C4                          3444s _20000015
000014C4  B47C 0007               3445s     CMP.W   #7,D2
000014C8  6FB6                    3446s     BLE _20000014
000014CA                          3447m     PRINT_CRLF D2,A1
000014CA  43FA 05F5               3448m     LEA CRLF(PC),A1
000014CE                          3449mm     PRINT_STR A1,D2
000014CE                          3450mm LOOP_260
000014CE  0C11 0000               3451mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000014D2  6700 0016               3452mm     BEQ EXIT_260
000014D6                          3453mmm     PRINT_CHAR (A1)+,D2
000014D6                          3454mmm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014D6                 TRUE     3455mmm     IFEQ DEBUG
000014D6  1439 00C00003           3456mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014DC  0802 0002               3457mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014E0  67F4                    3458mmm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000014E2  13D9 00C00007           3459mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014E8                          3460mmm     ENDC
000014E8                          3461mmm 
000014E8                 FALSE    3462mmm     IFNE DEBUG
000014E8                          3463mmm     ENDC
000014E8                          3464mmm 
000014E8                          3465mmm     ENDM
000014E8  60E4                    3466mm     BRA LOOP_260
000014EA                          3467mm EXIT_260
000014EA                          3468mm     ENDM
000014EA                          3469m     ENDM
000014EA                          3470  
000014EA  3001                    3471      MOVE.W D1,D0                                        ; extract the LSword for the length
000014EC  E089                    3472      LSR.L #8,D1                                         ; extract the MSword for the address
000014EE  E089                    3473      LSR.L #8,D1
000014F0                          3474  
000014F0  2241                    3475      MOVE.L D1,A1
000014F2                          3476      
000014F2  2047                    3477      MOVE.L D7,A0                                        ; address accumulator -> target address register
000014F4                          3478      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
000014F4                          3479  
000014F4                          3480      WHILE D0 <GT> #0 DO
000014F4                          3481s _10000016
000014F4  B07C 0000               3482s     CMP.W   #0,D0
000014F8  6F00 000E               3483s     BLE _10000017
000014FC  5580                    3484          SUB.L #2,D0
000014FE                          3485  
000014FE  13D1 00E00001           3486          MOVE.B (A1),DISPLAY
00001504  30D9                    3487          MOVE.W (A1)+,(A0)+
00001506                          3488      ENDW
00001506  60EC                    3489s     BRA _10000016
00001508                          3490s _10000017
00001508                          3491      
00001508  6000 EE56               3492      BRA MAIN_LOOP
0000150C                          3493  
0000150C                          3494  X
0000150C  45FA 05CC               3495      LEA STATUS_REGISTER(PC),A2
00001510                          3496m     PRINT_STR A2,D3
00001510                          3497m LOOP_262
00001510  0C12 0000               3498m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001514  6700 0016               3499m     BEQ EXIT_262
00001518                          3500mm     PRINT_CHAR (A2)+,D3
00001518                          3501mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001518                 TRUE     3502mm     IFEQ DEBUG
00001518  1639 00C00003           3503mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000151E  0803 0002               3504mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001522  67F4                    3505mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
00001524  13DA 00C00007           3506mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000152A                          3507mm     ENDC
0000152A                          3508mm 
0000152A                 FALSE    3509mm     IFNE DEBUG
0000152A                          3510mm     ENDC
0000152A                          3511mm 
0000152A                          3512mm     ENDM
0000152A  60E4                    3513m     BRA LOOP_262
0000152C                          3514m EXIT_262
0000152C                          3515m     ENDM
0000152C                          3516  
0000152C  40C0                    3517      MOVE SR,D0
0000152E                          3518m     PRINT_REG D0,D3,D4,D5,A2
0000152E  45FA 0597               3519m     LEA OX(PC),A2
00001532                          3520mm     PRINT_STR A2,D3
00001532                          3521mm LOOP_265
00001532  0C12 0000               3522mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001536  6700 0016               3523mm     BEQ EXIT_265
0000153A                          3524mmm     PRINT_CHAR (A2)+,D3
0000153A                          3525mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000153A                 TRUE     3526mmm     IFEQ DEBUG
0000153A  1639 00C00003           3527mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001540  0803 0002               3528mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001544  67F4                    3529mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
00001546  13DA 00C00007           3530mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000154C                          3531mmm     ENDC
0000154C                          3532mmm 
0000154C                 FALSE    3533mmm     IFNE DEBUG
0000154C                          3534mmm     ENDC
0000154C                          3535mmm 
0000154C                          3536mmm     ENDM
0000154C  60E4                    3537mm     BRA LOOP_265
0000154E                          3538mm EXIT_265
0000154E                          3539mm     ENDM
0000154E  7A07                    3540m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001550                          3541m LOOP_264
00001550                          3542mm     BIN2HEX D0,D4,A2
00001550  45FA 04F1               3543mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001554  E998                    3544mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001556  1800                    3545mm     MOVE.B D0,D4
00001558  0284 0000000F           3546mm     ANDI.L #$F,D4
0000155E  1832 4000               3547mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001562                          3548mm     ENDM
00001562                          3549mm     PRINT_CHAR D4,D3
00001562                          3550mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001562                 TRUE     3551mm     IFEQ DEBUG
00001562  1639 00C00003           3552mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001568  0803 0002               3553mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000156C  67F4                    3554mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
0000156E  13C4 00C00007           3555mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001574                          3556mm     ENDC
00001574                          3557mm 
00001574                 FALSE    3558mm     IFNE DEBUG
00001574                          3559mm     ENDC
00001574                          3560mm 
00001574                          3561mm     ENDM
00001574  57CD FFDA               3562m     DBEQ D5,LOOP_264
00001578                          3563m     ENDM
00001578                          3564m     PRINT_CRLF D3,A2
00001578  45FA 0547               3565m     LEA CRLF(PC),A2
0000157C                          3566mm     PRINT_STR A2,D3
0000157C                          3567mm LOOP_270
0000157C  0C12 0000               3568mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001580  6700 0016               3569mm     BEQ EXIT_270
00001584                          3570mmm     PRINT_CHAR (A2)+,D3
00001584                          3571mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001584                 TRUE     3572mmm     IFEQ DEBUG
00001584  1639 00C00003           3573mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000158A  0803 0002               3574mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000158E  67F4                    3575mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
00001590  13DA 00C00007           3576mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001596                          3577mmm     ENDC
00001596                          3578mmm 
00001596                 FALSE    3579mmm     IFNE DEBUG
00001596                          3580mmm     ENDC
00001596                          3581mmm 
00001596                          3582mmm     ENDM
00001596  60E4                    3583mm     BRA LOOP_270
00001598                          3584mm EXIT_270
00001598                          3585mm     ENDM
00001598                          3586m     ENDM
00001598                          3587  
00001598  45FA 053B               3588      LEA STACK_POINTER(PC),A2
0000159C                          3589m     PRINT_STR A2,D3
0000159C                          3590m LOOP_272
0000159C  0C12 0000               3591m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000015A0  6700 0016               3592m     BEQ EXIT_272
000015A4                          3593mm     PRINT_CHAR (A2)+,D3
000015A4                          3594mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015A4                 TRUE     3595mm     IFEQ DEBUG
000015A4  1639 00C00003           3596mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000015AA  0803 0002               3597mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000015AE  67F4                    3598mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000015B0  13DA 00C00007           3599mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015B6                          3600mm     ENDC
000015B6                          3601mm 
000015B6                 FALSE    3602mm     IFNE DEBUG
000015B6                          3603mm     ENDC
000015B6                          3604mm 
000015B6                          3605mm     ENDM
000015B6  60E4                    3606m     BRA LOOP_272
000015B8                          3607m EXIT_272
000015B8                          3608m     ENDM
000015B8                          3609  
000015B8  200F                    3610      MOVE.L SP,D0
000015BA                          3611m     PRINT_REG D0,D3,D4,D5,A2
000015BA  45FA 050B               3612m     LEA OX(PC),A2
000015BE                          3613mm     PRINT_STR A2,D3
000015BE                          3614mm LOOP_275
000015BE  0C12 0000               3615mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000015C2  6700 0016               3616mm     BEQ EXIT_275
000015C6                          3617mmm     PRINT_CHAR (A2)+,D3
000015C6                          3618mmm WAIT_FOR_READY_276                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015C6                 TRUE     3619mmm     IFEQ DEBUG
000015C6  1639 00C00003           3620mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000015CC  0803 0002               3621mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000015D0  67F4                    3622mmm         BEQ WAIT_FOR_READY_276                      ; NO SPACE, CHECK AGAIN
000015D2  13DA 00C00007           3623mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015D8                          3624mmm     ENDC
000015D8                          3625mmm 
000015D8                 FALSE    3626mmm     IFNE DEBUG
000015D8                          3627mmm     ENDC
000015D8                          3628mmm 
000015D8                          3629mmm     ENDM
000015D8  60E4                    3630mm     BRA LOOP_275
000015DA                          3631mm EXIT_275
000015DA                          3632mm     ENDM
000015DA  7A07                    3633m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000015DC                          3634m LOOP_274
000015DC                          3635mm     BIN2HEX D0,D4,A2
000015DC  45FA 0465               3636mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000015E0  E998                    3637mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000015E2  1800                    3638mm     MOVE.B D0,D4
000015E4  0284 0000000F           3639mm     ANDI.L #$F,D4
000015EA  1832 4000               3640mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000015EE                          3641mm     ENDM
000015EE                          3642mm     PRINT_CHAR D4,D3
000015EE                          3643mm WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015EE                 TRUE     3644mm     IFEQ DEBUG
000015EE  1639 00C00003           3645mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000015F4  0803 0002               3646mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000015F8  67F4                    3647mm         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
000015FA  13C4 00C00007           3648mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001600                          3649mm     ENDC
00001600                          3650mm 
00001600                 FALSE    3651mm     IFNE DEBUG
00001600                          3652mm     ENDC
00001600                          3653mm 
00001600                          3654mm     ENDM
00001600  57CD FFDA               3655m     DBEQ D5,LOOP_274
00001604                          3656m     ENDM
00001604                          3657m     PRINT_CRLF D3,A2
00001604  45FA 04BB               3658m     LEA CRLF(PC),A2
00001608                          3659mm     PRINT_STR A2,D3
00001608                          3660mm LOOP_280
00001608  0C12 0000               3661mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000160C  6700 0016               3662mm     BEQ EXIT_280
00001610                          3663mmm     PRINT_CHAR (A2)+,D3
00001610                          3664mmm WAIT_FOR_READY_281                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001610                 TRUE     3665mmm     IFEQ DEBUG
00001610  1639 00C00003           3666mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001616  0803 0002               3667mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000161A  67F4                    3668mmm         BEQ WAIT_FOR_READY_281                      ; NO SPACE, CHECK AGAIN
0000161C  13DA 00C00007           3669mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001622                          3670mmm     ENDC
00001622                          3671mmm 
00001622                 FALSE    3672mmm     IFNE DEBUG
00001622                          3673mmm     ENDC
00001622                          3674mmm 
00001622                          3675mmm     ENDM
00001622  60E4                    3676mm     BRA LOOP_280
00001624                          3677mm EXIT_280
00001624                          3678mm     ENDM
00001624                          3679m     ENDM
00001624                          3680  
00001624  6000 ED3A               3681      BRA MAIN_LOOP
00001628                          3682  
00001628                          3683          
00001628                          3684  I
00001628  13FC 0008 00C0000B      3685      MOVE.B #8,DUART_IMR
00001630  027C F8FF               3686      AND.W #$F8FF,SR
00001634  6000 ED2A               3687      BRA MAIN_LOOP
00001638                          3688      
00001638                          3689  O
00001638  13FC 0000 00C0000B      3690      MOVE.B #0,DUART_IMR
00001640  007C 0700               3691      OR.W #$0700,SR
00001644  6000 ED1A               3692      BRA MAIN_LOOP
00001648                          3693          
00001648                          3694  HASH
00001648                          3695m     PROTECT
00001648  31FC AAAA 2AAA          3696m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000164E  31FC 5555 1554          3697m     MOVE.W #$5555,$1554
00001654  31FC A0A0 2AAA          3698m     MOVE.W #$A0A0,$2AAA
0000165A                          3699m     ENDM
0000165A  6000 ED04               3700      BRA MAIN_LOOP
0000165E                          3701  
0000165E                          3702  
0000165E                          3703  
0000165E                          3704  HEX_DIGIT
0000165E  E98F                    3705      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
00001660                          3706m     HEX2BIN D2,D2,A0
00001660  41FA 03F1               3707m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001664  0402 0030               3708m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001668  C4BC 000000FF           3709m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000166E  1430 2000               3710m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001672                          3711m     ENDM
00001672  8E02                    3712      OR.B D2,D7  
00001674  6000 ED0A               3713      BRA GET_INPUT
00001678                          3714  
00001678  FFFF FFFF               3715      SIMHALT                                             ; halt simulator
0000167C                          3716  
0000167C                          3717  ; exceptions    
0000167C                          3718  BUS_ERROR_HANDLER
0000167C                          3719  
0000167C  41FA 0468               3720      LEA BUS_ERROR(PC),A0
00001680                          3721m     PRINT_STR A0,D1
00001680                          3722m LOOP_284
00001680  0C10 0000               3723m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001684  6700 0016               3724m     BEQ EXIT_284
00001688                          3725mm     PRINT_CHAR (A0)+,D1
00001688                          3726mm WAIT_FOR_READY_285                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001688                 TRUE     3727mm     IFEQ DEBUG
00001688  1239 00C00003           3728mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000168E  0801 0002               3729mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001692  67F4                    3730mm         BEQ WAIT_FOR_READY_285                      ; NO SPACE, CHECK AGAIN
00001694  13D8 00C00007           3731mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000169A                          3732mm     ENDC
0000169A                          3733mm 
0000169A                 FALSE    3734mm     IFNE DEBUG
0000169A                          3735mm     ENDC
0000169A                          3736mm 
0000169A                          3737mm     ENDM
0000169A  60E4                    3738m     BRA LOOP_284
0000169C                          3739m EXIT_284
0000169C                          3740m     ENDM
0000169C                          3741  
0000169C  7000                    3742      MOVE.L #0,D0
0000169E  3017                    3743      MOVE.W (SP),D0
000016A0                          3744  
000016A0  0800 0004               3745      BTST #4,D0
000016A4  6700 0026               3746      BEQ WRITE
000016A8                          3747      
000016A8  41FA 0451               3748      LEA READING(PC),A0
000016AC                          3749m     PRINT_STR A0,D1
000016AC                          3750m LOOP_286
000016AC  0C10 0000               3751m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000016B0  6700 0016               3752m     BEQ EXIT_286
000016B4                          3753mm     PRINT_CHAR (A0)+,D1
000016B4                          3754mm WAIT_FOR_READY_287                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016B4                 TRUE     3755mm     IFEQ DEBUG
000016B4  1239 00C00003           3756mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000016BA  0801 0002               3757mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000016BE  67F4                    3758mm         BEQ WAIT_FOR_READY_287                      ; NO SPACE, CHECK AGAIN
000016C0  13D8 00C00007           3759mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016C6                          3760mm     ENDC
000016C6                          3761mm 
000016C6                 FALSE    3762mm     IFNE DEBUG
000016C6                          3763mm     ENDC
000016C6                          3764mm 
000016C6                          3765mm     ENDM
000016C6  60E4                    3766m     BRA LOOP_286
000016C8                          3767m EXIT_286
000016C8                          3768m     ENDM
000016C8                          3769  
000016C8  6000 0022               3770      BRA CONTINUE    
000016CC                          3771  WRITE
000016CC  41FA 0436               3772      LEA WRITING(PC),A0
000016D0                          3773m     PRINT_STR A0,D1
000016D0                          3774m LOOP_288
000016D0  0C10 0000               3775m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000016D4  6700 0016               3776m     BEQ EXIT_288
000016D8                          3777mm     PRINT_CHAR (A0)+,D1
000016D8                          3778mm WAIT_FOR_READY_289                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016D8                 TRUE     3779mm     IFEQ DEBUG
000016D8  1239 00C00003           3780mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000016DE  0801 0002               3781mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000016E2  67F4                    3782mm         BEQ WAIT_FOR_READY_289                      ; NO SPACE, CHECK AGAIN
000016E4  13D8 00C00007           3783mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016EA                          3784mm     ENDC
000016EA                          3785mm 
000016EA                 FALSE    3786mm     IFNE DEBUG
000016EA                          3787mm     ENDC
000016EA                          3788mm 
000016EA                          3789mm     ENDM
000016EA  60E4                    3790m     BRA LOOP_288
000016EC                          3791m EXIT_288
000016EC                          3792m     ENDM
000016EC                          3793  
000016EC                          3794  CONTINUE
000016EC  222F 0002               3795      MOVE.L 2(SP),D1
000016F0                          3796m     PRINT_REG D1,D2,D3,D4,A0
000016F0  41FA 03D5               3797m     LEA OX(PC),A0
000016F4                          3798mm     PRINT_STR A0,D2
000016F4                          3799mm LOOP_291
000016F4  0C10 0000               3800mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000016F8  6700 0016               3801mm     BEQ EXIT_291
000016FC                          3802mmm     PRINT_CHAR (A0)+,D2
000016FC                          3803mmm WAIT_FOR_READY_292                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016FC                 TRUE     3804mmm     IFEQ DEBUG
000016FC  1439 00C00003           3805mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001702  0802 0002               3806mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001706  67F4                    3807mmm         BEQ WAIT_FOR_READY_292                      ; NO SPACE, CHECK AGAIN
00001708  13D8 00C00007           3808mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000170E                          3809mmm     ENDC
0000170E                          3810mmm 
0000170E                 FALSE    3811mmm     IFNE DEBUG
0000170E                          3812mmm     ENDC
0000170E                          3813mmm 
0000170E                          3814mmm     ENDM
0000170E  60E4                    3815mm     BRA LOOP_291
00001710                          3816mm EXIT_291
00001710                          3817mm     ENDM
00001710  7807                    3818m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001712                          3819m LOOP_290
00001712                          3820mm     BIN2HEX D1,D3,A0
00001712  41FA 032F               3821mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001716  E999                    3822mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001718  1601                    3823mm     MOVE.B D1,D3
0000171A  0283 0000000F           3824mm     ANDI.L #$F,D3
00001720  1630 3000               3825mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001724                          3826mm     ENDM
00001724                          3827mm     PRINT_CHAR D3,D2
00001724                          3828mm WAIT_FOR_READY_294                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001724                 TRUE     3829mm     IFEQ DEBUG
00001724  1439 00C00003           3830mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000172A  0802 0002               3831mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000172E  67F4                    3832mm         BEQ WAIT_FOR_READY_294                      ; NO SPACE, CHECK AGAIN
00001730  13C3 00C00007           3833mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001736                          3834mm     ENDC
00001736                          3835mm 
00001736                 FALSE    3836mm     IFNE DEBUG
00001736                          3837mm     ENDC
00001736                          3838mm 
00001736                          3839mm     ENDM
00001736  57CC FFDA               3840m     DBEQ D4,LOOP_290
0000173A                          3841m     ENDM
0000173A                          3842  
0000173A  41FA 03D1               3843      LEA FROM(PC),A0
0000173E                          3844m     PRINT_STR A0,D0
0000173E                          3845m LOOP_295
0000173E  0C10 0000               3846m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001742  6700 0016               3847m     BEQ EXIT_295
00001746                          3848mm     PRINT_CHAR (A0)+,D0
00001746                          3849mm WAIT_FOR_READY_296                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001746                 TRUE     3850mm     IFEQ DEBUG
00001746  1039 00C00003           3851mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000174C  0800 0002               3852mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001750  67F4                    3853mm         BEQ WAIT_FOR_READY_296                      ; NO SPACE, CHECK AGAIN
00001752  13D8 00C00007           3854mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001758                          3855mm     ENDC
00001758                          3856mm 
00001758                 FALSE    3857mm     IFNE DEBUG
00001758                          3858mm     ENDC
00001758                          3859mm 
00001758                          3860mm     ENDM
00001758  60E4                    3861m     BRA LOOP_295
0000175A                          3862m EXIT_295
0000175A                          3863m     ENDM
0000175A                          3864  
0000175A  222F 000A               3865      MOVE.L 10(SP),D1
0000175E                          3866m     PRINT_REG D1,D2,D3,D4,A0
0000175E  41FA 0367               3867m     LEA OX(PC),A0
00001762                          3868mm     PRINT_STR A0,D2
00001762                          3869mm LOOP_298
00001762  0C10 0000               3870mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001766  6700 0016               3871mm     BEQ EXIT_298
0000176A                          3872mmm     PRINT_CHAR (A0)+,D2
0000176A                          3873mmm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000176A                 TRUE     3874mmm     IFEQ DEBUG
0000176A  1439 00C00003           3875mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001770  0802 0002               3876mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001774  67F4                    3877mmm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001776  13D8 00C00007           3878mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000177C                          3879mmm     ENDC
0000177C                          3880mmm 
0000177C                 FALSE    3881mmm     IFNE DEBUG
0000177C                          3882mmm     ENDC
0000177C                          3883mmm 
0000177C                          3884mmm     ENDM
0000177C  60E4                    3885mm     BRA LOOP_298
0000177E                          3886mm EXIT_298
0000177E                          3887mm     ENDM
0000177E  7807                    3888m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001780                          3889m LOOP_297
00001780                          3890mm     BIN2HEX D1,D3,A0
00001780  41FA 02C1               3891mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001784  E999                    3892mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001786  1601                    3893mm     MOVE.B D1,D3
00001788  0283 0000000F           3894mm     ANDI.L #$F,D3
0000178E  1630 3000               3895mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001792                          3896mm     ENDM
00001792                          3897mm     PRINT_CHAR D3,D2
00001792                          3898mm WAIT_FOR_READY_301                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001792                 TRUE     3899mm     IFEQ DEBUG
00001792  1439 00C00003           3900mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001798  0802 0002               3901mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000179C  67F4                    3902mm         BEQ WAIT_FOR_READY_301                      ; NO SPACE, CHECK AGAIN
0000179E  13C3 00C00007           3903mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017A4                          3904mm     ENDC
000017A4                          3905mm 
000017A4                 FALSE    3906mm     IFNE DEBUG
000017A4                          3907mm     ENDC
000017A4                          3908mm 
000017A4                          3909mm     ENDM
000017A4  57CC FFDA               3910m     DBEQ D4,LOOP_297
000017A8                          3911m     ENDM
000017A8                          3912m     PRINT_CRLF D0,A0
000017A8  41FA 0317               3913m     LEA CRLF(PC),A0
000017AC                          3914mm     PRINT_STR A0,D0
000017AC                          3915mm LOOP_303
000017AC  0C10 0000               3916mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017B0  6700 0016               3917mm     BEQ EXIT_303
000017B4                          3918mmm     PRINT_CHAR (A0)+,D0
000017B4                          3919mmm WAIT_FOR_READY_304                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017B4                 TRUE     3920mmm     IFEQ DEBUG
000017B4  1039 00C00003           3921mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000017BA  0800 0002               3922mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000017BE  67F4                    3923mmm         BEQ WAIT_FOR_READY_304                      ; NO SPACE, CHECK AGAIN
000017C0  13D8 00C00007           3924mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017C6                          3925mmm     ENDC
000017C6                          3926mmm 
000017C6                 FALSE    3927mmm     IFNE DEBUG
000017C6                          3928mmm     ENDC
000017C6                          3929mmm 
000017C6                          3930mmm     ENDM
000017C6  60E4                    3931mm     BRA LOOP_303
000017C8                          3932mm EXIT_303
000017C8                          3933mm     ENDM
000017C8                          3934m     ENDM
000017C8                          3935      
000017C8  207C 00000004           3936      MOVE.L #4,A0
000017CE  4ED0                    3937      JMP (A0)
000017D0                          3938          
000017D0                          3939  ILLEGAL_HANDLER
000017D0  13FC 0007 00E00001      3940      MOVE.B #7,DISPLAY   
000017D8                          3941      
000017D8  207C 00000004           3942      MOVE.L #4,A0
000017DE  4ED0                    3943      JMP (A0)
000017E0                          3944          
000017E0                          3945  UNHANDLED_HANDLER
000017E0  41FA 0332               3946      LEA UNHANDLED(PC),A0
000017E4                          3947m     PRINT_STR A0,D1
000017E4                          3948m LOOP_305
000017E4  0C10 0000               3949m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017E8  6700 0016               3950m     BEQ EXIT_305
000017EC                          3951mm     PRINT_CHAR (A0)+,D1
000017EC                          3952mm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017EC                 TRUE     3953mm     IFEQ DEBUG
000017EC  1239 00C00003           3954mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000017F2  0801 0002               3955mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000017F6  67F4                    3956mm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
000017F8  13D8 00C00007           3957mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017FE                          3958mm     ENDC
000017FE                          3959mm 
000017FE                 FALSE    3960mm     IFNE DEBUG
000017FE                          3961mm     ENDC
000017FE                          3962mm 
000017FE                          3963mm     ENDM
000017FE  60E4                    3964m     BRA LOOP_305
00001800                          3965m EXIT_305
00001800                          3966m     ENDM
00001800                          3967  
00001800  4E73                    3968      RTE 
00001802                          3969      
00001802                          3970  UNINITIALISED_HANDLER
00001802  41FA 0326               3971      LEA UNINITIALISED(PC),A0
00001806                          3972m     PRINT_STR A0,D1
00001806                          3973m LOOP_307
00001806  0C10 0000               3974m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000180A  6700 0016               3975m     BEQ EXIT_307
0000180E                          3976mm     PRINT_CHAR (A0)+,D1
0000180E                          3977mm WAIT_FOR_READY_308                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000180E                 TRUE     3978mm     IFEQ DEBUG
0000180E  1239 00C00003           3979mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001814  0801 0002               3980mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001818  67F4                    3981mm         BEQ WAIT_FOR_READY_308                      ; NO SPACE, CHECK AGAIN
0000181A  13D8 00C00007           3982mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001820                          3983mm     ENDC
00001820                          3984mm 
00001820                 FALSE    3985mm     IFNE DEBUG
00001820                          3986mm     ENDC
00001820                          3987mm 
00001820                          3988mm     ENDM
00001820  60E4                    3989m     BRA LOOP_307
00001822                          3990m EXIT_307
00001822                          3991m     ENDM
00001822                          3992  
00001822  4E73                    3993      RTE 
00001824                          3994  
00001824                          3995  SPURIOUS_HANDLER
00001824  41FA 0324               3996      LEA SPURIOUS(PC),A0
00001828                          3997m     PRINT_STR A0,D1
00001828                          3998m LOOP_309
00001828  0C10 0000               3999m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000182C  6700 0016               4000m     BEQ EXIT_309
00001830                          4001mm     PRINT_CHAR (A0)+,D1
00001830                          4002mm WAIT_FOR_READY_310                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001830                 TRUE     4003mm     IFEQ DEBUG
00001830  1239 00C00003           4004mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001836  0801 0002               4005mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000183A  67F4                    4006mm         BEQ WAIT_FOR_READY_310                      ; NO SPACE, CHECK AGAIN
0000183C  13D8 00C00007           4007mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001842                          4008mm     ENDC
00001842                          4009mm 
00001842                 FALSE    4010mm     IFNE DEBUG
00001842                          4011mm     ENDC
00001842                          4012mm 
00001842                          4013mm     ENDM
00001842  60E4                    4014m     BRA LOOP_309
00001844                          4015m EXIT_309
00001844                          4016m     ENDM
00001844                          4017  
00001844  4E73                    4018      RTE 
00001846                          4019      
00001846                          4020  TICK_HANDLER
00001846  41FA 0297               4021      LEA TICK(PC),A0
0000184A                          4022m     PRINT_STR A0,D1
0000184A                          4023m LOOP_311
0000184A  0C10 0000               4024m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000184E  6700 0016               4025m     BEQ EXIT_311
00001852                          4026mm     PRINT_CHAR (A0)+,D1
00001852                          4027mm WAIT_FOR_READY_312                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001852                 TRUE     4028mm     IFEQ DEBUG
00001852  1239 00C00003           4029mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001858  0801 0002               4030mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000185C  67F4                    4031mm         BEQ WAIT_FOR_READY_312                      ; NO SPACE, CHECK AGAIN
0000185E  13D8 00C00007           4032mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001864                          4033mm     ENDC
00001864                          4034mm 
00001864                 FALSE    4035mm     IFNE DEBUG
00001864                          4036mm     ENDC
00001864                          4037mm 
00001864                          4038mm     ENDM
00001864  60E4                    4039m     BRA LOOP_311
00001866                          4040m EXIT_311
00001866                          4041m     ENDM
00001866                          4042      
00001866  1039 00C0001F           4043      MOVE.B DUART_RESET_OPR,D0
0000186C  4E73                    4044      RTE 
0000186E                          4045  
0000186E                          4046  ; strings
0000186E= 50 72 65 73 73 20 ...   4047  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001881= 5B 3F 5D 09 09 09 ...   4048  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
0000188D= 5B 76 5D 09 09 09 ...   4049          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
0000189C= 78 78 78 78 78 78 ...   4050          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
000018B4= 78 78 78 78 78 78 ...   4051          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
000018D4= 78 78 78 78 78 78 ...   4052          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
000018F5= 78 78 78 78 78 78 ...   4053          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001906= 5B 7A 5D 09 09 09 ...   4054          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001918= 78 78 78 78 78 78 ...   4055          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001939= 78 78 78 78 78 78 ...   4056          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
00001958= 78 78 78 78 78 78 ...   4057          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
0000197C= 23 09 09 09 77 72 ...   4058          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001996= 5B 78 5D 09 09 09 ...   4059          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
000019AD= 5B 69 5D 09 09 09 ...   4060          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
000019C6= 5B 6F 5D 09 09 09 ...   4061          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
000019E1= 48 75 68 3F 0D 0A 00    4062  HUH  DC.B 'Huh?',CR,LF,NULL
000019E8= 20 53 20 72 65 63 ...   4063  READ    DC.B ' S records read, start address = ',NULL
00001A0A= 57 3A 20 55 6E 6B ...   4064  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001A21= 21 20 43 53 20 66 ...   4065  CS_FAILURE  DC.B '! CS failure at ',NULL
00001A32= 21 20 52 41 4D 20 ...   4066  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001A43= 30 31 32 33 34 35 ...   4067  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001A53= 00 01 02 03 04 05 ...   4068  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001A6A= 4C 6F 61 64 69 6E ...   4069  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001A7E= 57 72 69 74 69 6E ...   4070  CODE        DC.B 'Writing code: ',NULL
00001A8D= 53 65 74 74 69 6E ...   4071  SP      DC.B 'Setting initial stack pointer to ',NULL
00001AAF= 57 72 69 74 69 6E ...   4072  VECTORS DC.B 'Writing vectors',CR,LF,NULL
00001AC1= 0D 0A 00                4073  CRLF    DC.B CR,LF,NULL
00001AC4= 3E 20 00                4074  PROMPT  DC.B '> ',NULL
00001AC7= 30 78 00                4075  ox      DC.B '0x',NULL
00001ACA= 20 2D 3E 20 00          4076  to      DC.B ' -> ',NULL
00001ACF= 20 66 6F 72 20 00       4077  for     DC.B ' for ',NULL
00001AD5= 53 50 3A 20 00          4078  STACK_POINTER DC.B 'SP: ',NULL
00001ADA= 53 52 3A 20 00          4079  STATUS_REGISTER DC.B 'SR: ',NULL
00001ADF= 74 69 63 6B 0D 0A 00    4080  TICK DC.B 'tick',CR,LF,NULL
00001AE6= 2A 20 42 75 73 2F ...   4081  BUS_ERROR DC.B '* Bus/address error ',NULL
00001AFB= 72 65 61 64 69 6E ...   4082  READING DC.B 'reading ',NULL
00001B04= 77 72 69 74 69 6E ...   4083  WRITING DC.B 'writing ',NULL
00001B0D= 20 66 72 6F 6D 20 00    4084  FROM DC.B ' from ',NULL
00001B14= 2A 20 55 6E 68 61 ...   4085  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001B2A= 2A 20 20 55 6E 69 ...   4086  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
00001B4A= 2A 20 53 70 75 72 ...   4087  SPURIOUS DC.B '* Spurious interrupt',NULL
00001B5F= 43 6F 6C 64 20 73 ...   4088  COLD_START DC.B 'Cold start - brrr',CR,LF,NULL
00001B73= 57 61 72 6D 20 73 ...   4089  WARM_START DC.B 'Warm start - phew',CR,LF,NULL
00001B87= 4D 44 46 2D 6D 6F ...   4090  VERSION DC.B 'MDF-mon V1.128 (30/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001BA5= 00                      4091  END     DC.B 0
00001BA6                          4092      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1A43
BUS_ERROR           1AE6
BUS_ERROR_HANDLER   167C
CODE                1A7E
COLD_START          1B5F
CONTINUE            16EC
CONTINUE_103        A5E
CONTINUE_117        B50
CONTINUE_58         62C
CONTINUE_61         67C
CONTINUE_65         6D2
CONTINUE_73         786
CONTINUE_78         7F8
CONTINUE_83         874
CONTINUE_88         8F2
CONTINUE_93         97A
CONTINUE_98         9EC
CR                  D
CRLF                1AC1
CS_FAILURE          1A21
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C5A
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1BA5
EXIT_108            AD0
EXIT_11             2A4
EXIT_110            AF0
EXIT_114            B22
EXIT_122            BB8
EXIT_124            BE0
EXIT_127            C00
EXIT_132            C4A
EXIT_135            C7A
EXIT_139            CC4
EXIT_14             2CC
EXIT_142            CE6
EXIT_147            D30
EXIT_149            DAC
EXIT_152            DD0
EXIT_157            E1A
EXIT_164            EAC
EXIT_167            F1C
EXIT_169            F3C
EXIT_172            F5E
EXIT_176            FA8
EXIT_179            FCA
EXIT_183            1014
EXIT_186            1034
EXIT_19             316
EXIT_191            107E
EXIT_194            10C0
EXIT_197            10E8
EXIT_202            1132
EXIT_207            1178
EXIT_21             336
EXIT_210            11AE
EXIT_214            11F8
EXIT_217            121A
EXIT_222            1264
EXIT_233            1318
EXIT_236            137C
EXIT_239            139C
EXIT_24             356
EXIT_243            13E6
EXIT_246            1408
EXIT_251            1452
EXIT_26             380
EXIT_260            14EA
EXIT_262            152C
EXIT_265            154E
EXIT_270            1598
EXIT_272            15B8
EXIT_275            15DA
EXIT_280            1624
EXIT_284            169C
EXIT_286            16C8
EXIT_288            16EC
EXIT_291            1710
EXIT_295            175A
EXIT_298            177E
EXIT_303            17C8
EXIT_305            1800
EXIT_307            1822
EXIT_309            1844
EXIT_311            1866
EXIT_32             414
EXIT_34             484
EXIT_36             4B0
EXIT_39             4DA
EXIT_4              238
EXIT_49             588
EXIT_56             5FE
EXIT_6              25C
EXIT_70             742
EXIT_9              284
FOR                 1ACF
FROM                1B0D
G                   D34
GET_INPUT           380
H                   488
HASH                1648
HELP                1881
HELPPROMPT          186E
HEX2BIN             10B
HEX2BIN_LUT         1A53
HEX_DIGIT           165E
HUH                 19E1
I                   1628
ILLEGAL_HANDLER     17D0
L                   E2A
LF                  A
LOADING             1A6A
LOOP_108            AB4
LOOP_11             288
LOOP_110            AD4
LOOP_114            B06
LOOP_122            B9C
LOOP_124            BC4
LOOP_126            C02
LOOP_127            BE4
LOOP_13             2CE
LOOP_132            C2E
LOOP_134            C7C
LOOP_135            C5E
LOOP_139            CA8
LOOP_14             2B0
LOOP_141            CE8
LOOP_142            CCA
LOOP_147            D14
LOOP_149            D90
LOOP_151            DD2
LOOP_152            DB4
LOOP_157            DFE
LOOP_164            E90
LOOP_167            F00
LOOP_169            F20
LOOP_171            F60
LOOP_172            F42
LOOP_176            F8C
LOOP_178            FCC
LOOP_179            FAE
LOOP_183            FF8
LOOP_185            1036
LOOP_186            1018
LOOP_19             2FA
LOOP_191            1062
LOOP_194            10A4
LOOP_196            10EA
LOOP_197            10CC
LOOP_202            1116
LOOP_207            115C
LOOP_209            11B0
LOOP_21             31A
LOOP_210            1192
LOOP_214            11DC
LOOP_216            121C
LOOP_217            11FE
LOOP_222            1248
LOOP_233            12FC
LOOP_236            1360
LOOP_238            139E
LOOP_239            1380
LOOP_24             33A
LOOP_243            13CA
LOOP_245            140A
LOOP_246            13EC
LOOP_251            1436
LOOP_26             364
LOOP_260            14CE
LOOP_262            1510
LOOP_264            1550
LOOP_265            1532
LOOP_270            157C
LOOP_272            159C
LOOP_274            15DC
LOOP_275            15BE
LOOP_280            1608
LOOP_284            1680
LOOP_286            16AC
LOOP_288            16D0
LOOP_290            1712
LOOP_291            16F4
LOOP_295            173E
LOOP_297            1780
LOOP_298            1762
LOOP_303            17AC
LOOP_305            17E4
LOOP_307            1806
LOOP_309            1828
LOOP_311            184A
LOOP_32             3F8
LOOP_34             468
LOOP_36             494
LOOP_38             4DC
LOOP_39             4BE
LOOP_4              21C
LOOP_49             56C
LOOP_56             5E2
LOOP_6              240
LOOP_70             726
LOOP_9              268
M                   1474
MAIN_LOOP           360
NULL                0
O                   1638
OX                  1AC7
P                   12A4
PRINTSTR            494
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1AC4
PROTECT             A40
R                   4B4
RAM                 200000
RAM_ERROR           1A32
READ                19E8
READING             1AFB
READ_CHAR           62D
RESET               4
ROM                 0
S                   608
SP                  1A8D
SPURIOUS            1B4A
SPURIOUS_HANDLER    1824
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1AD5
START               104
STATUS_REGISTER     1ADA
TAB                 9
TICK                1ADF
TICK_HANDLER        1846
TO                  1ACA
UNHANDLED           1B14
UNHANDLED_HANDLER   17E0
UNINITIALISED       1B2A
UNINITIALISED_HANDLER  1802
UNPROTECT           979
UNREC               1A0A
USER                100
V                   490
VECS                8
VECTORS             1AAF
VERSION             1B87
W                   58C
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_193  1090
WAIT_FOR_COMPLETE_205  113C
WAIT_FOR_COMPLETE_206  114E
WAIT_FOR_COMPLETE_225  1268
WAIT_FOR_COMPLETE_226  127A
WAIT_FOR_COMPLETE_253  1454
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_10   270
WAIT_FOR_READY_100  A04
WAIT_FOR_READY_103  A42
WAIT_FOR_READY_105  A76
WAIT_FOR_READY_109  ABC
WAIT_FOR_READY_111  ADC
WAIT_FOR_READY_112  AF0
WAIT_FOR_READY_115  B0E
WAIT_FOR_READY_117  B34
WAIT_FOR_READY_119  B68
WAIT_FOR_READY_12   290
WAIT_FOR_READY_123  BA4
WAIT_FOR_READY_125  BCC
WAIT_FOR_READY_128  BEC
WAIT_FOR_READY_130  C14
WAIT_FOR_READY_133  C36
WAIT_FOR_READY_136  C66
WAIT_FOR_READY_138  C8E
WAIT_FOR_READY_140  CB0
WAIT_FOR_READY_143  CD2
WAIT_FOR_READY_145  CFA
WAIT_FOR_READY_148  D1C
WAIT_FOR_READY_15   2B8
WAIT_FOR_READY_150  D98
WAIT_FOR_READY_153  DBC
WAIT_FOR_READY_155  DE4
WAIT_FOR_READY_158  E06
WAIT_FOR_READY_159  E38
WAIT_FOR_READY_161  E52
WAIT_FOR_READY_165  E98
WAIT_FOR_READY_168  F08
WAIT_FOR_READY_17   2E0
WAIT_FOR_READY_170  F28
WAIT_FOR_READY_173  F4A
WAIT_FOR_READY_175  F72
WAIT_FOR_READY_177  F94
WAIT_FOR_READY_180  FB6
WAIT_FOR_READY_182  FDE
WAIT_FOR_READY_184  1000
WAIT_FOR_READY_187  1020
WAIT_FOR_READY_189  1048
WAIT_FOR_READY_192  106A
WAIT_FOR_READY_195  10AC
WAIT_FOR_READY_198  10D4
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_20   302
WAIT_FOR_READY_200  10FC
WAIT_FOR_READY_203  111E
WAIT_FOR_READY_208  1164
WAIT_FOR_READY_211  119A
WAIT_FOR_READY_213  11C2
WAIT_FOR_READY_215  11E4
WAIT_FOR_READY_218  1206
WAIT_FOR_READY_22   322
WAIT_FOR_READY_220  122E
WAIT_FOR_READY_223  1250
WAIT_FOR_READY_228  12B0
WAIT_FOR_READY_230  12CA
WAIT_FOR_READY_234  1304
WAIT_FOR_READY_237  1368
WAIT_FOR_READY_240  1388
WAIT_FOR_READY_242  13B0
WAIT_FOR_READY_244  13D2
WAIT_FOR_READY_247  13F4
WAIT_FOR_READY_249  141C
WAIT_FOR_READY_25   342
WAIT_FOR_READY_252  143E
WAIT_FOR_READY_255  1482
WAIT_FOR_READY_257  149C
WAIT_FOR_READY_261  14D6
WAIT_FOR_READY_263  1518
WAIT_FOR_READY_266  153A
WAIT_FOR_READY_268  1562
WAIT_FOR_READY_27   36C
WAIT_FOR_READY_271  1584
WAIT_FOR_READY_273  15A4
WAIT_FOR_READY_276  15C6
WAIT_FOR_READY_278  15EE
WAIT_FOR_READY_28   380
WAIT_FOR_READY_281  1610
WAIT_FOR_READY_285  1688
WAIT_FOR_READY_287  16B4
WAIT_FOR_READY_289  16D8
WAIT_FOR_READY_292  16FC
WAIT_FOR_READY_294  1724
WAIT_FOR_READY_296  1746
WAIT_FOR_READY_299  176A
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_30   39A
WAIT_FOR_READY_301  1792
WAIT_FOR_READY_304  17B4
WAIT_FOR_READY_306  17EC
WAIT_FOR_READY_308  180E
WAIT_FOR_READY_310  1830
WAIT_FOR_READY_312  1852
WAIT_FOR_READY_33   400
WAIT_FOR_READY_35   470
WAIT_FOR_READY_37   49C
WAIT_FOR_READY_40   4C6
WAIT_FOR_READY_42   4EE
WAIT_FOR_READY_43   504
WAIT_FOR_READY_44   51A
WAIT_FOR_READY_45   52E
WAIT_FOR_READY_46   542
WAIT_FOR_READY_47   556
WAIT_FOR_READY_5    224
WAIT_FOR_READY_50   574
WAIT_FOR_READY_51   596
WAIT_FOR_READY_53   5B0
WAIT_FOR_READY_57   5EA
WAIT_FOR_READY_58   610
WAIT_FOR_READY_60   64A
WAIT_FOR_READY_61   660
WAIT_FOR_READY_63   694
WAIT_FOR_READY_65   6B6
WAIT_FOR_READY_67   6EA
WAIT_FOR_READY_7    248
WAIT_FOR_READY_71   72E
WAIT_FOR_READY_73   76A
WAIT_FOR_READY_75   79E
WAIT_FOR_READY_78   7DC
WAIT_FOR_READY_80   810
WAIT_FOR_READY_83   858
WAIT_FOR_READY_85   88C
WAIT_FOR_READY_88   8D6
WAIT_FOR_READY_90   90A
WAIT_FOR_READY_93   95E
WAIT_FOR_READY_95   992
WAIT_FOR_READY_98   9D0
WAIT_FOR_SRECORD    610
WARM_START          1B73
WRITE               16CC
WRITING             1B04
X                   150C
Z                   D3A
_00000000           23C
_00000001           25C
_00000002           3C0
_00000003           3D4
_00000004           74A
_00000005           B26
_00000006           758
_00000007           946
_00000008           8BC
_00000009           B26
_0000000A           AB0
_0000000B           B26
_0000000C           C4E
_0000000D           C5A
_0000000E           E1A
_0000000F           109A
_00000010           1146
_00000011           1158
_00000012           1272
_00000013           1284
_00000014           145E
_10000000           6AC
_10000001           714
_10000002           760
_10000003           7C8
_10000004           7D2
_10000005           83A
_10000006           84E
_10000007           8B6
_10000008           8C0
_10000009           940
_1000000A           8CC
_1000000B           934
_1000000C           954
_1000000D           9BC
_1000000E           9C6
_1000000F           A2E
_10000010           A38
_10000011           AA0
_10000012           B2A
_10000013           B92
_10000014           107E
_10000015           10A0
_10000016           14F4
_10000017           1508
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           594
_20000005           5D8
_20000006           D4C
_20000007           D5C
_20000008           D76
_20000009           E1C
_2000000A           E36
_2000000B           E7A
_2000000C           EF2
_2000000D           EF6
_2000000E           1180
_2000000F           1286
_20000010           12AE
_20000011           12F2
_20000012           1352
_20000013           1356
_20000014           1480
_20000015           14C4
