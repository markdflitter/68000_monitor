00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 18/12/2022 13:11:44

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor 
00000000                             6  
00000000                             7  *-----------------------------------------------------------
00000000                             8  
00000000                             9      ORG  $0
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00000000                 14  NULL                EQU 0
00000000  =00000009                 15  TAB                 EQU 9
00000000  =0000000D                 16  CR                  EQU 13
00000000  =0000000A                 17  LF                  EQU 10
00000000                            18  
00000000  =00000000                 19  ROM                 EQU $0
00000000  =00200000                 20  RAM                 EQU $200000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           190  PRINT_REG_4BIT MACRO
00000000                           191      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           192      MOVE.B \1,\3
00000000                           193      ANDI.L #$F,\3
00000000                           194      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           195      PRINT_CHAR \3,\2
00000000                           196      ENDM
00000000                           197  
00000000                           198  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           199  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           200  PRINT_REG MACRO
00000000                           201      LEA ox(PC),\5
00000000                           202      PRINT_STR \5,\2
00000000                           203      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           204  LOOP\@
00000000                           205      BIN2HEX \1,\3,\5
00000000                           206      PRINT_CHAR \3,\2
00000000                           207      DBEQ \4,LOOP\@
00000000                           208      ENDM
00000000                           209  
00000000                           210  ; wait for a char from the serial port
00000000                           211  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           212  ; will stamp on D0 and D1 in debug mode
00000000                           213  WAIT_CHAR MACRO
00000000                           214  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           215      IFEQ DEBUG
00000000                           216          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           217          BTST #0,\2                                  ; check for character
00000000                           218          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           219      ENDC
00000000                           220  
00000000                           221      READ_CHAR \1
00000000                           222  
00000000                           223      IFEQ DEBUG
00000000                           224          PRINT_CHAR \1,\2                            ; echo it back
00000000                           225      ENDC
00000000                           226      ENDM
00000000                           227  
00000000                           228  ; read a char from the serial port - assumes that there is one!
00000000                           229  ; \ 1= data register for read char
00000000                           230  ; will stamp on D0 and D1 in debug mode
00000000                           231  READ_CHAR MACRO
00000000                           232      IFEQ DEBUG
00000000                           233          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           234      ENDC
00000000                           235      IFNE DEBUG
00000000                           236          MOVE.L #5,D0    
00000000                           237          TRAP #15                                    ; read from keyboard in simulator
00000000                           238          MOVE.L D1,\1
00000000                           239      ENDC
00000000                           240  
00000000                           241      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           242      BEQ START
00000000                           243      ENDM
00000000                           244  
00000000                           245  
00000000                           246  ; read data from the download serial port
00000000                           247  ; \ 1= data register for read char
00000000                           248  DOWNLOAD MACRO
00000000                           249  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           250  
00000000                           251      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           252      BTST #0,\1                                      ; check for character
00000000                           253      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           254      
00000000                           255      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           256      
00000000                           257      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           258      BEQ START
00000000                           259  
00000000                           260      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           261  
00000000                           262      ENDM
00000000                           263  
00000000                           264  ; read two hex digits from the download serial port and convert to a byte
00000000                           265  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           266  DOWNLOAD_BYTE MACRO
00000000                           267      MOVE.B #2,\4
00000000                           268      WHILE.B \4 <GT> 0 DO
00000000                           269          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           270          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           271          ;PRINT_CHAR \2,\3
00000000                           272          HEX2BIN \2,\2,\6
00000000                           273          OR.B \2,\1
00000000                           274          SUB.B #1,\4
00000000                           275      ENDW
00000000                           276  
00000000                           277      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           278      MOVE.B \1,\2
00000000                           279      ADD.L \1,\5
00000000                           280  
00000000                           281      ENDM
00000000                           282  
00000000                           283  ; unprotect the EEPROM
00000000                           284  UNPROTECT MACRO
00000000                           285      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           286      NOP
00000000                           287      MOVE.W #$5555,$1554
00000000                           288      NOP
00000000                           289      MOVE.W #$8080,$2AAA
00000000                           290      NOP
00000000                           291      MOVE.W #$AAAA,$2AAA
00000000                           292      NOP
00000000                           293      MOVE.W #$5555,$1554
00000000                           294      NOP
00000000                           295      MOVE.W #$2020,$2AAA
00000000                           296      ENDM
00000000                           297      
00000000                           298  ; protect the EEPROM
00000000                           299  PROTECT MACRO
00000000                           300      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           301      MOVE.W #$5555,$1554
00000000                           302      MOVE.W #$A0A0,$2AAA
00000000                           303      ENDM
00000000                           304  ; write word to EEPROM
00000000                           305  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           306  PROGRAM MACRO
00000000                           307    MOVE.W \1,\2                                      ; write the data
00000000                           308  
00000000                           309  WAIT_FOR_COMPLETE\@
00000000                           310          MOVE.W \2,\3
00000000                           311  
00000000                           312          IF.W \3 <NE> \1 THEN
00000000                           313              BRA WAIT_FOR_COMPLETE\@
00000000                           314          ENDI
00000000                           315          ENDM
00000000                           316          
00000000                           317  ; program vector to EEPROM
00000000                           318  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           319  PROGRAM_VECTOR MACRO
00000000                           320      ADD.L #2,\2
00000000                           321      PROGRAM \1, (\2), \3                            ; write it
00000000                           322      LSR.L #8,\1
00000000                           323      LSR.L #8,\1
00000000                           324      SUB.L #2,\2
00000000                           325      PROGRAM \1, (\2), \3
00000000                           326      ENDM
00000000                           327  
00000000                           328  ; read an ide register
00000000                           329  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           330  READ_8 MACRO
00000000                           331      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           332      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           333      ORI.B \1, \3
00000000                           334      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           335      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           336      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           337      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           338      ORI.B #MC68230_PORT_C_READ, \3
00000000                           339      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           340      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           341      ENDM
00000000                           342      
00000000                           343  ; write an ide register
00000000                           344  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           345  WRITE_8 MACRO
00000000                           346      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           347      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           348      ORI.B \2, \3
00000000                           349      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           350      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           351      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           352      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           353      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           354      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           355      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           356      ENDM
00000000                           357  
00000000                           358  ; read ide data
00000000                           359  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           360  READ_16 MACRO
00000000                           361      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           362      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           363      
00000000                           364      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           365      ORI.B \1, \3
00000000                           366      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           367      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           368      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           369      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           370      LSL.W #8, \2
00000000                           371      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           372      ORI.B #MC68230_PORT_C_READ, \3
00000000                           373      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           374      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           375      ENDM
00000000                           376      
00000000                           377  ; read ide data
00000000                           378  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           379  READ_32 MACRO
00000000                           380      READ_16 \1, \2, \3
00000000                           381      LSL.L #8, \2
00000000                           382      LSL.L #8, \2
00000000                           383      READ_16 \1, \2, \3
00000000                           384      ENDM
00000000                           385          
00000000                           386  ; read ide status
00000000                           387  ;\1 = data register for result, \2 = working data register 
00000000                           388  READ_IDE_STATUS MACRO   
00000000                           389      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           390      ENDM
00000000                           391      
00000000                           392  ; wait for ide drive to be ready
00000000                           393  ;\1 = working data register 1, \2 = working data register 2
00000000                           394  WAIT_DRIVE_READY MACRO
00000000                           395  LOOP\@
00000000                           396      READ_IDE_STATUS \1, \2
00000000                           397      BTST #IDE_STATUS_READY, \1
00000000                           398      BEQ LOOP\@
00000000                           399      ENDM
00000000                           400      
00000000                           401  ; wait for ide drive to be not busy
00000000                           402  ;\1 = working data register 1, \2 = working data register 2
00000000                           403  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           404  LOOP\@
00000000                           405      READ_IDE_STATUS \1, \2
00000000                           406      BTST #IDE_STATUS_BUSY, \1
00000000                           407      BNE LOOP\@
00000000                           408      ENDM
00000000                           409      
00000000                           410  ; wait for ide drive to have data for us
00000000                           411  ;\1 = working data register 1, \2 = working data register 2
00000000                           412  WAIT_DRIVE_DRQ MACRO
00000000                           413  LOOP\@
00000000                           414      READ_IDE_STATUS \1, \2
00000000                           415      BTST #IDE_STATUS_DRQ, \1
00000000                           416      BEQ LOOP\@
00000000                           417      ENDM
00000000                           418      
00000000                           419  ; prepare to send a read command
00000000                           420  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           421  SET_READ_ADDRESS MACRO
00000000                           422      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           423      MOVE.L \1,\3
00000000                           424      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           425      LSR.L #8, \3
00000000                           426      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           427      LSR.L #8, \3                                
00000000                           428      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           429      LSR.L #8, \3
00000000                           430      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           431      ANDI.B #$0F,\3
00000000                           432      OR.B \3,\4
00000000                           433      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           434      ENDM
00000000                           435  
00000000                           436  ; send command
00000000                           437  ; \1 = command, \2 = working data register 1,
00000000                           438  SEND_COMMAND MACRO
00000000                           439      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           440      ENDM
00000000                           441      
00000000                           442  ; send read command and wait
00000000                           443  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           444  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           445      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           446      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           447      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           448      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           449      WAIT_DRIVE_DRQ \2, \3
00000000                           450      ENDM
00000000                           451  
00000000                           452  ; register catalogue
00000000                           453  ; D0 - used for simulator I/O
00000000                           454  ; D1 - used for simulator I/O
00000000                           455  ; D2 - read character
00000000                           456  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           457  ; D6 - working register used in R/W
00000000                           458  ; D7 - address accumulator, reset by download
00000000                           459  ; A0 - address of string to print 
00000000                           460  
00000000                           461  ; start vector
00000000= 00000000                 462  STACK   DC.L 0                                  ; STACK
00000004= 00000008                 463  RESET   DC.L START                              ; RESET
00000008                           464  ; start of program  
00000008                           465  START
00000008  13FC 0000 00E00001       466      MOVE.B #0,DISPLAY
00000010                           467  
00000010  7000                     468      MOVE.L #0,D0
00000012  1039 00C00019            469      MOVE.B DUART_IVR,D0                             ; warm start?
00000018                           470  
00000018                           471  ; reset the UART in case of warm start
00000018  13FC 000A 00C00005       472      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000020  13FC 000A 00C00015       473      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000028                           474      
00000028                           475      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000028  323C 0050                476s     MOVE.W  #$50,D1
0000002C  6000 000E                477s     BRA _20000001
00000030                           478s _20000000
00000030  13C1 00C00005            479          MOVE.B D1,DUART_CRA                         ; reset everyting
00000036  4E71                     480          NOP
00000038                           481      ENDF
00000038  0441 0010                482s     SUB.W   #$10,D1
0000003C                           483s _20000001
0000003C  B27C 0010                484s     CMP.W   #$10,D1
00000040  6CEE                     485s     BGE _20000000
00000042                           486  
00000042                           487      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000042  323C 0050                488s     MOVE.W  #$50,D1
00000046  6000 000E                489s     BRA _20000003
0000004A                           490s _20000002
0000004A  13C1 00C00015            491          MOVE.B D1,DUART_CRB                         ; reset everyting
00000050  4E71                     492          NOP
00000052                           493      ENDF
00000052  0441 0010                494s     SUB.W   #$10,D1
00000056                           495s _20000003
00000056  B27C 0010                496s     CMP.W   #$10,D1
0000005A  6CEE                     497s     BGE _20000002
0000005C                           498      
0000005C                           499  ;initialise UART
0000005C  13FC 0000 00C0000B       500      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 00FF 00C0000D       501      MOVE.B #$FF,DUART_CTUR
0000006C  13FC 00FF 00C0000F       502      MOVE.B #$FF,DUART_CTLR
00000074  13FC 0070 00C00009       503      MOVE.B #$70,DUART_ACR
0000007C  13FC 0004 00C0001B       504      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000084                           505  
00000084                           506  ; channel A
00000084  13FC 0013 00C00001       507      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000008C  13FC 0007 00C00001       508      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000094  13FC 0066 00C00003       509      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000009C  13FC 0005 00C00005       510      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000000A4                           511  
000000A4                           512  ; channel B
000000A4  13FC 0013 00C00011       513      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000000AC  13FC 0007 00C00011       514      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000000B4  13FC 0066 00C00013       515      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000000BC  13FC 0005 00C00015       516      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000C4  13FC 0040 00C00019       517      MOVE.B #64,DUART_IVR
000000CC                           518  
000000CC                           519m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000CC                           520m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000CC                 TRUE      521m     IFEQ DEBUG
000000CC  1239 00C00003            522m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000D2  0801 0002                523m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000D6  67F4                     524m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000D8  13FC 0000 00C00007       525m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E0                           526m     ENDC
000000E0                           527m 
000000E0                 FALSE     528m     IFNE DEBUG
000000E0                           529m     ENDC
000000E0                           530m 
000000E0                           531m     ENDM
000000E0                           532m     PRINT_CHAR #0,D1
000000E0                           533m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E0                 TRUE      534m     IFEQ DEBUG
000000E0  1239 00C00003            535m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000E6  0801 0002                536m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000EA  67F4                     537m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000EC  13FC 0000 00C00007       538m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000F4                           539m     ENDC
000000F4                           540m 
000000F4                 FALSE     541m     IFNE DEBUG
000000F4                           542m     ENDC
000000F4                           543m 
000000F4                           544m     ENDM
000000F4                           545m     PRINT_CHAR #0,D1
000000F4                           546m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000F4                 TRUE      547m     IFEQ DEBUG
000000F4  1239 00C00003            548m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000FA  0801 0002                549m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000FE  67F4                     550m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000100  13FC 0000 00C00007       551m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000108                           552m     ENDC
00000108                           553m 
00000108                 FALSE     554m     IFNE DEBUG
00000108                           555m     ENDC
00000108                           556m 
00000108                           557m     ENDM
00000108                           558      
00000108                           559      IF D0 <EQ> #$0F THEN
00000108  B07C 000F                560s     CMP.W   #$0F,D0
0000010C  6600 0008                561s     BNE _00000000
00000110  1039 00C00005            562          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000116                           563      ENDI
00000116                           564s _00000000
00000116                           565  
00000116  13FC 0001 00E00001       566      MOVE.B #1,DISPLAY
0000011E                           567      
0000011E                           568m     PRINT_CRLF D1,A0
0000011E  41FA 1C45                569m     LEA CRLF(PC),A0
00000122                           570mm     PRINT_STR A0,D1
00000122                           571mm LOOP_5
00000122  0C10 0000                572mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000126  6700 0016                573mm     BEQ EXIT_5
0000012A                           574mmm     PRINT_CHAR (A0)+,D1
0000012A                           575mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      576mmm     IFEQ DEBUG
0000012A  1239 00C00003            577mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000130  0801 0002                578mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000134  67F4                     579mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            580mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000013C                           581mmm     ENDC
0000013C                           582mmm 
0000013C                 FALSE     583mmm     IFNE DEBUG
0000013C                           584mmm     ENDC
0000013C                           585mmm 
0000013C                           586mmm     ENDM
0000013C  60E4                     587mm     BRA LOOP_5
0000013E                           588mm EXIT_5
0000013E                           589mm     ENDM
0000013E                           590m     ENDM
0000013E  41FA 1C5B                591      LEA VERSION(PC),A0
00000142                           592m     PRINT_STR A0,D3
00000142                           593m LOOP_7
00000142  0C10 0000                594m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000146  6700 0016                595m     BEQ EXIT_7
0000014A                           596mm     PRINT_CHAR (A0)+,D3
0000014A                           597mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000014A                 TRUE      598mm     IFEQ DEBUG
0000014A  1639 00C00003            599mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000150  0803 0002                600mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000154  67F4                     601mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000156  13D8 00C00007            602mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000015C                           603mm     ENDC
0000015C                           604mm 
0000015C                 FALSE     605mm     IFNE DEBUG
0000015C                           606mm     ENDC
0000015C                           607mm 
0000015C                           608mm     ENDM
0000015C  60E4                     609m     BRA LOOP_7
0000015E                           610m EXIT_7
0000015E                           611m     ENDM
0000015E                           612  
0000015E  41F9 00001DB9            613      LEA END,A0
00000164  2008                     614      MOVE.L A0,D0
00000166                           615m     PRINT_REG D0,D1,D2,D3,A0
00000166  41FA 1C03                616m     LEA OX(PC),A0
0000016A                           617mm     PRINT_STR A0,D1
0000016A                           618mm LOOP_10
0000016A  0C10 0000                619mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000016E  6700 0016                620mm     BEQ EXIT_10
00000172                           621mmm     PRINT_CHAR (A0)+,D1
00000172                           622mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000172                 TRUE      623mmm     IFEQ DEBUG
00000172  1239 00C00003            624mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000178  0801 0002                625mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000017C  67F4                     626mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
0000017E  13D8 00C00007            627mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000184                           628mmm     ENDC
00000184                           629mmm 
00000184                 FALSE     630mmm     IFNE DEBUG
00000184                           631mmm     ENDC
00000184                           632mmm 
00000184                           633mmm     ENDM
00000184  60E4                     634mm     BRA LOOP_10
00000186                           635mm EXIT_10
00000186                           636mm     ENDM
00000186  7607                     637m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000188                           638m LOOP_9
00000188                           639mm     BIN2HEX D0,D2,A0
00000188  41FA 1BA0                640mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000018C  E998                     641mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000018E  1400                     642mm     MOVE.B D0,D2
00000190  0282 0000000F            643mm     ANDI.L #$F,D2
00000196  1430 2000                644mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000019A                           645mm     ENDM
0000019A                           646mm     PRINT_CHAR D2,D1
0000019A                           647mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      648mm     IFEQ DEBUG
0000019A  1239 00C00003            649mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001A0  0801 0002                650mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001A4  67F4                     651mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000001A6  13C2 00C00007            652mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001AC                           653mm     ENDC
000001AC                           654mm 
000001AC                 FALSE     655mm     IFNE DEBUG
000001AC                           656mm     ENDC
000001AC                           657mm 
000001AC                           658mm     ENDM
000001AC  57CB FFDA                659m     DBEQ D3,LOOP_9
000001B0                           660m     ENDM
000001B0                           661m     PRINT_CRLF D1,A0
000001B0  41FA 1BB3                662m     LEA CRLF(PC),A0
000001B4                           663mm     PRINT_STR A0,D1
000001B4                           664mm LOOP_15
000001B4  0C10 0000                665mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001B8  6700 0016                666mm     BEQ EXIT_15
000001BC                           667mmm     PRINT_CHAR (A0)+,D1
000001BC                           668mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001BC                 TRUE      669mmm     IFEQ DEBUG
000001BC  1239 00C00003            670mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001C2  0801 0002                671mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001C6  67F4                     672mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000001C8  13D8 00C00007            673mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001CE                           674mmm     ENDC
000001CE                           675mmm 
000001CE                 FALSE     676mmm     IFNE DEBUG
000001CE                           677mmm     ENDC
000001CE                           678mmm 
000001CE                           679mmm     ENDM
000001CE  60E4                     680mm     BRA LOOP_15
000001D0                           681mm EXIT_15
000001D0                           682mm     ENDM
000001D0                           683m     ENDM
000001D0                           684  
000001D0  41FA 196E                685      LEA HELPPROMPT(PC),A0
000001D4                           686m     PRINT_STR A0,D3
000001D4                           687m LOOP_17
000001D4  0C10 0000                688m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001D8  6700 0016                689m     BEQ EXIT_17
000001DC                           690mm     PRINT_CHAR (A0)+,D3
000001DC                           691mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001DC                 TRUE      692mm     IFEQ DEBUG
000001DC  1639 00C00003            693mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001E2  0803 0002                694mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001E6  67F4                     695mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001E8  13D8 00C00007            696mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001EE                           697mm     ENDC
000001EE                           698mm 
000001EE                 FALSE     699mm     IFNE DEBUG
000001EE                           700mm     ENDC
000001EE                           701mm 
000001EE                           702mm     ENDM
000001EE  60E4                     703m     BRA LOOP_17
000001F0                           704m EXIT_17
000001F0                           705m     ENDM
000001F0                           706  
000001F0                           707m     PRINT_CRLF D3,A0
000001F0  41FA 1B73                708m     LEA CRLF(PC),A0
000001F4                           709mm     PRINT_STR A0,D3
000001F4                           710mm LOOP_20
000001F4  0C10 0000                711mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001F8  6700 0016                712mm     BEQ EXIT_20
000001FC                           713mmm     PRINT_CHAR (A0)+,D3
000001FC                           714mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001FC                 TRUE      715mmm     IFEQ DEBUG
000001FC  1639 00C00003            716mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000202  0803 0002                717mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000206  67F4                     718mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000208  13D8 00C00007            719mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000020E                           720mmm     ENDC
0000020E                           721mmm 
0000020E                 FALSE     722mmm     IFNE DEBUG
0000020E                           723mmm     ENDC
0000020E                           724mmm 
0000020E                           725mmm     ENDM
0000020E  60E4                     726mm     BRA LOOP_20
00000210                           727mm EXIT_20
00000210                           728mm     ENDM
00000210                           729m     ENDM
00000210                           730  
00000210  7E00                     731      MOVE.L #0,D7                                    ; address accumulator
00000212                           732  
00000212  13FC 0002 00E00001       733      MOVE.B #2,DISPLAY
0000021A                           734      
0000021A  13FC 0000 00A00001       735      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000222  13FC 0040 00A0000D       736      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000022A  13FC 0040 00A0000F       737      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000232  13FC 00FF 00A00009       738      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000023A                           739      
0000023A  13FC 0003 00E00001       740      MOVE.B #3,DISPLAY
00000242                           741      
00000242                           742      
00000242                           743  MAIN_LOOP
00000242  41FA 1B24                744      LEA PROMPT(PC),A0
00000246                           745m     PRINT_STR A0,D3
00000246                           746m LOOP_22
00000246  0C10 0000                747m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000024A  6700 0016                748m     BEQ EXIT_22
0000024E                           749mm     PRINT_CHAR (A0)+,D3
0000024E                           750mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024E                 TRUE      751mm     IFEQ DEBUG
0000024E  1639 00C00003            752mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000254  0803 0002                753mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000258  67F4                     754mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000025A  13D8 00C00007            755mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000260                           756mm     ENDC
00000260                           757mm 
00000260                 FALSE     758mm     IFNE DEBUG
00000260                           759mm     ENDC
00000260                           760mm 
00000260                           761mm     ENDM
00000260  60E4                     762m     BRA LOOP_22
00000262                           763m EXIT_22
00000262                           764m     ENDM
00000262                           765  
00000262                           766  GET_INPUT
00000262                           767m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000262                           768m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000262                 TRUE      769m     IFEQ DEBUG
00000262  1639 00C00003            770m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000268  0803 0000                771m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000026C  67F4                     772m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
0000026E                           773m     ENDC
0000026E                           774m 
0000026E                           775mm     READ_CHAR D2
0000026E                 TRUE      776mm     IFEQ DEBUG
0000026E  1439 00C00007            777mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000274                           778mm     ENDC
00000274                 FALSE     779mm     IFNE DEBUG
00000274                           780mm     ENDC
00000274                           781mm 
00000274  B43C 001B                782mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000278  6700 FD8E                783mm     BEQ START
0000027C                           784mm     ENDM
0000027C                           785m 
0000027C                 TRUE      786m     IFEQ DEBUG
0000027C                           787mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000027C                           788mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000027C                 TRUE      789mm     IFEQ DEBUG
0000027C  1639 00C00003            790mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000282  0803 0002                791mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000286  67F4                     792mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000288  13C2 00C00007            793mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000028E                           794mm     ENDC
0000028E                           795mm 
0000028E                 FALSE     796mm     IFNE DEBUG
0000028E                           797mm     ENDC
0000028E                           798mm 
0000028E                           799mm     ENDM
0000028E                           800m     ENDC
0000028E                           801m     ENDM
0000028E                           802  
0000028E                           803      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
0000028E  B43C 0030                804s     CMP.B   #'0',D2
00000292  6D00 000E                805s     BLT _00000001
00000296  B43C 0039                806s     CMP.B   #'9',D2
0000029A  6E00 0006                807s     BGT _00000001
0000029E  6000 1882                808          BRA HEX_DIGIT
000002A2                           809      ENDI
000002A2                           810s _00000001
000002A2                           811      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000002A2  B43C 0041                812s     CMP.B   #'A',D2
000002A6  6D00 000E                813s     BLT _00000002
000002AA  B43C 0046                814s     CMP.B   #'F',D2
000002AE  6E00 0006                815s     BGT _00000002
000002B2  6000 186E                816          BRA HEX_DIGIT
000002B6                           817      ENDI
000002B6                           818s _00000002
000002B6                           819  
000002B6  B43C 0077                820      CMP.B #'w',D2
000002BA  6700 01C6                821      BEQ W
000002BE                           822  
000002BE  B43C 006C                823      CMP.B #'l',D2
000002C2  6700 08CE                824      BEQ L 
000002C6                           825  
000002C6  B43C 0070                826      CMP.B #'p',D2
000002CA  6700 0BF0                827      BEQ P
000002CE                           828  
000002CE                           829m     PRINT_CRLF D3,A0
000002CE  41FA 1A95                830m     LEA CRLF(PC),A0
000002D2                           831mm     PRINT_STR A0,D3
000002D2                           832mm LOOP_28
000002D2  0C10 0000                833mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002D6  6700 0016                834mm     BEQ EXIT_28
000002DA                           835mmm     PRINT_CHAR (A0)+,D3
000002DA                           836mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DA                 TRUE      837mmm     IFEQ DEBUG
000002DA  1639 00C00003            838mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E0  0803 0002                839mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E4  67F4                     840mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000002E6  13D8 00C00007            841mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002EC                           842mmm     ENDC
000002EC                           843mmm 
000002EC                 FALSE     844mmm     IFNE DEBUG
000002EC                           845mmm     ENDC
000002EC                           846mmm 
000002EC                           847mmm     ENDM
000002EC  60E4                     848mm     BRA LOOP_28
000002EE                           849mm EXIT_28
000002EE                           850mm     ENDM
000002EE                           851m     ENDM
000002EE                           852   
000002EE  B43C 003F                853      CMP.B #'?',D2
000002F2  6700 008A                854      BEQ H
000002F6                           855   
000002F6  B43C 0076                856      CMP.B #'v',D2
000002FA  6700 008A                857      BEQ V
000002FE                           858      
000002FE  B43C 0072                859      CMP.B #'r',D2
00000302  6700 00A6                860      BEQ R
00000306                           861  
00000306  B43C 0073                862      CMP.B #'s',D2
0000030A  6700 01F0                863      BEQ S
0000030E                           864  
0000030E  B43C 0067                865      CMP.B #'g',D2
00000312  6700 0788                866      BEQ G   
00000316                           867  
00000316  B43C 007A                868      CMP.B #'z',D2
0000031A  6700 0786                869      BEQ Z   
0000031E                           870  
0000031E  B43C 0078                871      CMP.B #'x',D2
00000322  6700 0D68                872      BEQ X
00000326                           873  
00000326  B43C 0049                874      CMP.B #'I',D2
0000032A  6700 0E7C                875      BEQ EI
0000032E                           876  
0000032E  B43C 006F                877      CMP.B #'o',D2
00000332  6700 0E84                878      BEQ DI
00000336                           879  
00000336  B43C 0023                880      CMP.B #'#',D2
0000033A  6700 0E8C                881      BEQ HASH
0000033E                           882  
0000033E  B43C 0069                883      CMP.B #'i',D2
00000342  2A7C 00000000            884      MOVE.L #0, A5               ; not boot
00000348  6700 0E94                885      BEQ IB
0000034C                           886  
0000034C  B43C 0062                887      CMP.B #'b',D2
00000350  2A7C 00000001            888      MOVE.L #1, A5               ; boot
00000356  6700 0E86                889      BEQ IB
0000035A                           890  
0000035A  41FA 196C                891      LEA HUH(PC),A0
0000035E                           892m     PRINT_STR A0,D3
0000035E                           893m LOOP_30
0000035E  0C10 0000                894m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000362  6700 0016                895m     BEQ EXIT_30
00000366                           896mm     PRINT_CHAR (A0)+,D3
00000366                           897mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000366                 TRUE      898mm     IFEQ DEBUG
00000366  1639 00C00003            899mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036C  0803 0002                900mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000370  67F4                     901mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000372  13D8 00C00007            902mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000378                           903mm     ENDC
00000378                           904mm 
00000378                 FALSE     905mm     IFNE DEBUG
00000378                           906mm     ENDC
00000378                           907mm 
00000378                           908mm     ENDM
00000378  60E4                     909m     BRA LOOP_30
0000037A                           910m EXIT_30
0000037A                           911m     ENDM
0000037A                           912  
0000037A  6000 FEC6                913      BRA MAIN_LOOP
0000037E                           914  
0000037E                           915  ; commands
0000037E                           916  H
0000037E  41FA 17D3                917      LEA HELP(PC),A0
00000382  6000 0006                918      BRA PRINTIT
00000386                           919  
00000386                           920  V
00000386  41FA 1A13                921      LEA VERSION(PC),A0
0000038A                           922  PRINTIT
0000038A                           923m     PRINT_STR A0,D3    
0000038A                           924m LOOP_32
0000038A  0C10 0000                925m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000038E  6700 0016                926m     BEQ EXIT_32
00000392                           927mm     PRINT_CHAR (A0)+,D3
00000392                           928mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000392                 TRUE      929mm     IFEQ DEBUG
00000392  1639 00C00003            930mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000398  0803 0002                931mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000039C  67F4                     932mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000039E  13D8 00C00007            933mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003A4                           934mm     ENDC
000003A4                           935mm 
000003A4                 FALSE     936mm     IFNE DEBUG
000003A4                           937mm     ENDC
000003A4                           938mm 
000003A4                           939mm     ENDM
000003A4  60E4                     940m     BRA LOOP_32
000003A6                           941m EXIT_32
000003A6                           942m     ENDM
000003A6  6000 FE9A                943      BRA MAIN_LOOP
000003AA                           944  
000003AA                           945  R
000003AA  2047                     946      MOVE.L D7,A0                                    ; address accumulator -> address register
000003AC  7E00                     947      MOVE.L #0,D7                                    ;clear the now used address accumulator
000003AE  2410                     948      MOVE.L (A0),D2                                  ; read the memory and print it
000003B0                           949m     PRINT_REG D2,D3,D4,D5,A0
000003B0  41FA 19B9                950m     LEA OX(PC),A0
000003B4                           951mm     PRINT_STR A0,D3
000003B4                           952mm LOOP_35
000003B4  0C10 0000                953mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003B8  6700 0016                954mm     BEQ EXIT_35
000003BC                           955mmm     PRINT_CHAR (A0)+,D3
000003BC                           956mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BC                 TRUE      957mmm     IFEQ DEBUG
000003BC  1639 00C00003            958mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003C2  0803 0002                959mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003C6  67F4                     960mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000003C8  13D8 00C00007            961mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003CE                           962mmm     ENDC
000003CE                           963mmm 
000003CE                 FALSE     964mmm     IFNE DEBUG
000003CE                           965mmm     ENDC
000003CE                           966mmm 
000003CE                           967mmm     ENDM
000003CE  60E4                     968mm     BRA LOOP_35
000003D0                           969mm EXIT_35
000003D0                           970mm     ENDM
000003D0  7A07                     971m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000003D2                           972m LOOP_34
000003D2                           973mm     BIN2HEX D2,D4,A0
000003D2  41FA 1956                974mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003D6  E99A                     975mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000003D8  1802                     976mm     MOVE.B D2,D4
000003DA  0284 0000000F            977mm     ANDI.L #$F,D4
000003E0  1830 4000                978mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000003E4                           979mm     ENDM
000003E4                           980mm     PRINT_CHAR D4,D3
000003E4                           981mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E4                 TRUE      982mm     IFEQ DEBUG
000003E4  1639 00C00003            983mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003EA  0803 0002                984mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003EE  67F4                     985mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000003F0  13C4 00C00007            986mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003F6                           987mm     ENDC
000003F6                           988mm 
000003F6                 FALSE     989mm     IFNE DEBUG
000003F6                           990mm     ENDC
000003F6                           991mm 
000003F6                           992mm     ENDM
000003F6  57CD FFDA                993m     DBEQ D5,LOOP_34
000003FA                           994m     ENDM
000003FA                           995      
000003FA                           996m     PRINT_CHAR #32,D3
000003FA                           997m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003FA                 TRUE      998m     IFEQ DEBUG
000003FA  1639 00C00003            999m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000400  0803 0002               1000m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000404  67F4                    1001m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000406  13FC 0020 00C00007      1002m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000040E                          1003m     ENDC
0000040E                          1004m 
0000040E                 FALSE    1005m     IFNE DEBUG
0000040E                          1006m     ENDC
0000040E                          1007m 
0000040E                          1008m     ENDM
0000040E                          1009  
0000040E  E19A                    1010      ROL.L #8,D2
00000410                          1011m     PRINT_CHAR D2,D3
00000410                          1012m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000410                 TRUE     1013m     IFEQ DEBUG
00000410  1639 00C00003           1014m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000416  0803 0002               1015m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000041A  67F4                    1016m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000041C  13C2 00C00007           1017m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000422                          1018m     ENDC
00000422                          1019m 
00000422                 FALSE    1020m     IFNE DEBUG
00000422                          1021m     ENDC
00000422                          1022m 
00000422                          1023m     ENDM
00000422  E19A                    1024      ROL.L #8,D2
00000424                          1025m     PRINT_CHAR D2,D3
00000424                          1026m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000424                 TRUE     1027m     IFEQ DEBUG
00000424  1639 00C00003           1028m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000042A  0803 0002               1029m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000042E  67F4                    1030m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
00000430  13C2 00C00007           1031m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000436                          1032m     ENDC
00000436                          1033m 
00000436                 FALSE    1034m     IFNE DEBUG
00000436                          1035m     ENDC
00000436                          1036m 
00000436                          1037m     ENDM
00000436  E19A                    1038      ROL.L #8,D2
00000438                          1039m     PRINT_CHAR D2,D3
00000438                          1040m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000438                 TRUE     1041m     IFEQ DEBUG
00000438  1639 00C00003           1042m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000043E  0803 0002               1043m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000442  67F4                    1044m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000444  13C2 00C00007           1045m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000044A                          1046m     ENDC
0000044A                          1047m 
0000044A                 FALSE    1048m     IFNE DEBUG
0000044A                          1049m     ENDC
0000044A                          1050m 
0000044A                          1051m     ENDM
0000044A  E19A                    1052      ROL.L #8,D2
0000044C                          1053m     PRINT_CHAR D2,D3
0000044C                          1054m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000044C                 TRUE     1055m     IFEQ DEBUG
0000044C  1639 00C00003           1056m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000452  0803 0002               1057m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000456  67F4                    1058m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000458  13C2 00C00007           1059m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000045E                          1060m     ENDC
0000045E                          1061m 
0000045E                 FALSE    1062m     IFNE DEBUG
0000045E                          1063m     ENDC
0000045E                          1064m 
0000045E                          1065m     ENDM
0000045E                          1066  
0000045E                          1067m     PRINT_CRLF D3,A0
0000045E  41FA 1905               1068m     LEA CRLF(PC),A0
00000462                          1069mm     PRINT_STR A0,D3
00000462                          1070mm LOOP_45
00000462  0C10 0000               1071mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000466  6700 0016               1072mm     BEQ EXIT_45
0000046A                          1073mmm     PRINT_CHAR (A0)+,D3
0000046A                          1074mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000046A                 TRUE     1075mmm     IFEQ DEBUG
0000046A  1639 00C00003           1076mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000470  0803 0002               1077mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000474  67F4                    1078mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000476  13D8 00C00007           1079mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047C                          1080mmm     ENDC
0000047C                          1081mmm 
0000047C                 FALSE    1082mmm     IFNE DEBUG
0000047C                          1083mmm     ENDC
0000047C                          1084mmm 
0000047C                          1085mmm     ENDM
0000047C  60E4                    1086mm     BRA LOOP_45
0000047E                          1087mm EXIT_45
0000047E                          1088mm     ENDM
0000047E                          1089m     ENDM
0000047E                          1090      
0000047E  6000 FDC2               1091      BRA MAIN_LOOP
00000482                          1092  
00000482                          1093  W
00000482                          1094      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000482  3C3C 0000               1095s     MOVE.W  #0,D6
00000486  6000 0046               1096s     BRA _20000005
0000048A                          1097s _20000004
0000048A  E98D                    1098          LSL.L #4,D5                                     ; make what we have so far more significant
0000048C                          1099m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000048C                          1100m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048C                 TRUE     1101m     IFEQ DEBUG
0000048C  1639 00C00003           1102m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000492  0803 0000               1103m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000496  67F4                    1104m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000498                          1105m     ENDC
00000498                          1106m 
00000498                          1107mm     READ_CHAR D2
00000498                 TRUE     1108mm     IFEQ DEBUG
00000498  1439 00C00007           1109mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000049E                          1110mm     ENDC
0000049E                 FALSE    1111mm     IFNE DEBUG
0000049E                          1112mm     ENDC
0000049E                          1113mm 
0000049E  B43C 001B               1114mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000004A2  6700 FB64               1115mm     BEQ START
000004A6                          1116mm     ENDM
000004A6                          1117m 
000004A6                 TRUE     1118m     IFEQ DEBUG
000004A6                          1119mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000004A6                          1120mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004A6                 TRUE     1121mm     IFEQ DEBUG
000004A6  1639 00C00003           1122mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004AC  0803 0002               1123mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004B0  67F4                    1124mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000004B2  13C2 00C00007           1125mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004B8                          1126mm     ENDC
000004B8                          1127mm 
000004B8                 FALSE    1128mm     IFNE DEBUG
000004B8                          1129mm     ENDC
000004B8                          1130mm 
000004B8                          1131mm     ENDM
000004B8                          1132m     ENDC
000004B8                          1133m     ENDM
000004B8                          1134m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000004B8  41FA 1880               1135m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004BC  0402 0030               1136m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004C0  C4BC 000000FF           1137m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000004C6  1430 2000               1138m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000004CA                          1139m     ENDM
000004CA  8A02                    1140          OR.B D2,D5
000004CC                          1141      ENDF
000004CC  5246                    1142s     ADD.W   #1,D6
000004CE                          1143s _20000005
000004CE  BC7C 0007               1144s     CMP.W   #7,D6
000004D2  6FB6                    1145s     BLE _20000004
000004D4                          1146  
000004D4                          1147m     PRINT_CRLF D3,A0
000004D4  41FA 188F               1148m     LEA CRLF(PC),A0
000004D8                          1149mm     PRINT_STR A0,D3
000004D8                          1150mm LOOP_52
000004D8  0C10 0000               1151mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004DC  6700 0016               1152mm     BEQ EXIT_52
000004E0                          1153mmm     PRINT_CHAR (A0)+,D3
000004E0                          1154mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E0                 TRUE     1155mmm     IFEQ DEBUG
000004E0  1639 00C00003           1156mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004E6  0803 0002               1157mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004EA  67F4                    1158mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000004EC  13D8 00C00007           1159mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004F2                          1160mmm     ENDC
000004F2                          1161mmm 
000004F2                 FALSE    1162mmm     IFNE DEBUG
000004F2                          1163mmm     ENDC
000004F2                          1164mmm 
000004F2                          1165mmm     ENDM
000004F2  60E4                    1166mm     BRA LOOP_52
000004F4                          1167mm EXIT_52
000004F4                          1168mm     ENDM
000004F4                          1169m     ENDM
000004F4                          1170  
000004F4  2047                    1171      MOVE.L D7,A0                                    ; address accumulator -> address register
000004F6                          1172  
000004F6  2085                    1173      MOVE.L D5,(A0)                                  ; write the data
000004F8                          1174  
000004F8  6000 FD48               1175      BRA MAIN_LOOP
000004FC                          1176  
000004FC                          1177  ; register map for S
000004FC                          1178  ; A0 - start address
000004FC                          1179  ; A1 - offset
000004FC                          1180  ; A2 - next address to write
000004FC                          1181  ; A3 - next location (jmp)
000004FC                          1182  ; A4 - Working Address Register
000004FC                          1183  ; D0 - record count
000004FC                          1184  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000004FC                          1185  ; D2 - checksum
000004FC                          1186  ; D3 - data byte count
000004FC                          1187  ; D4 - read address, moved into A2
000004FC                          1188  ; D5 - temp
000004FC                          1189  ; D6 - temp
000004FC                          1190  ; D7 - temp
000004FC                          1191  S
000004FC  2078 0000               1192      MOVE.L 0,A0                                     ; start address -> A0
00000500  2247                    1193      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000502  7E00                    1194      MOVE.L #0,D7
00000504  7000                    1195      MOVE.L #0,D0                                    ; count of records read -> D0
00000506                          1196          
00000506                          1197  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000506                          1198m     DOWNLOAD D1
00000506                          1199m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000506                          1200m 
00000506  1239 00C00013           1201m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000050C  0801 0000               1202m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000510  67F4                    1203m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
00000512                          1204m     
00000512  1239 00C00017           1205m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000518                          1206m     
00000518  B23C 001B               1207m     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000051C  6700 FAEA               1208m     BEQ START
00000520                          1209m 
00000520  13C1 00E00001           1210m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000526                          1211m 
00000526                          1212m     ENDM
00000526  B23C 0053               1213      CMP.B #'S',D1                                   ; found S?
0000052A  66DA                    1214      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000052C                          1215      
0000052C                          1216m     PRINT_CHAR #'.',D5                              ; print a progress indicator
0000052C                          1217m WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000052C                 TRUE     1218m     IFEQ DEBUG
0000052C  1A39 00C00003           1219m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000532  0805 0002               1220m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000536  67F4                    1221m         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
00000538  13FC 002E 00C00007      1222m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000540                          1223m     ENDC
00000540                          1224m 
00000540                 FALSE    1225m     IFNE DEBUG
00000540                          1226m     ENDC
00000540                          1227m 
00000540                          1228m     ENDM
00000540                          1229      ;PRINT_CHAR #'S',D5                             ; print the S
00000540  5280                    1230      ADD.L #1,D0                                     ; read another S record, increment count
00000542                          1231      
00000542                          1232m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000542                          1233m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000542                          1234m 
00000542  1239 00C00013           1235m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000548  0801 0000               1236m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000054C  67F4                    1237m     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
0000054E                          1238m     
0000054E  1239 00C00017           1239m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000554                          1240m     
00000554  B23C 001B               1241m     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000558  6700 FAAE               1242m     BEQ START
0000055C                          1243m 
0000055C  13C1 00E00001           1244m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000562                          1245m 
00000562                          1246m     ENDM
00000562                          1247      ;PRINT_CHAR D1,D5
00000562                          1248  
00000562  7400                    1249      MOVE.L #0,D2                                    ; clear the checksum
00000564  7600                    1250      MOVE.L #0,D3
00000566                          1251  
00000566                          1252m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000566  1E3C 0002               1253m     MOVE.B #2,D7
0000056A                          1254m     WHILE.B D7 <GT> 0 DO
0000056A                          1255ms _10000000
0000056A  BE38 0000               1256ms     CMP.B   0,D7
0000056E  6F00 003C               1257ms     BLE _10000001
00000572  E98B                    1258m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000574                          1259mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000574                          1260mm WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000574                          1261mm 
00000574  1A39 00C00013           1262mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000057A  0805 0000               1263mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000057E  67F4                    1264mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000580                          1265mm     
00000580  1A39 00C00017           1266mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000586                          1267mm     
00000586  BA3C 001B               1268mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000058A  6700 FA7C               1269mm     BEQ START
0000058E                          1270mm 
0000058E  13C5 00E00001           1271mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000594                          1272mm 
00000594                          1273mm     ENDM
00000594                          1274m         ;PRINT_CHAR D5,D6
00000594                          1275mm         HEX2BIN D5,D5,A4
00000594  49FA 17A4               1276mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000598  0405 0030               1277mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000059C  CABC 000000FF           1278mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005A2  1A34 5000               1279mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005A6                          1280mm     ENDM
000005A6  8605                    1281m         OR.B D5,D3
000005A8  5307                    1282m         SUB.B #1,D7
000005AA                          1283m     ENDW
000005AA  60BE                    1284ms     BRA _10000000
000005AC                          1285ms _10000001
000005AC                          1286m 
000005AC  7A00                    1287m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005AE  1A03                    1288m     MOVE.B D3,D5
000005B0  D483                    1289m     ADD.L D3,D2
000005B2                          1290m 
000005B2                          1291m     ENDM
000005B2                          1292      
000005B2                          1293      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000005B2  B23C 0030               1294s     CMP.B   #'0',D1
000005B6  6600 000A               1295s     BNE.L   _00000003
000005BA                          1296          ;PRINT_CRLF D5,A4
000005BA  6000 FF4A               1297          BRA WAIT_FOR_SRECORD
000005BE                          1298      ELSE
000005BE  6000 02D4               1299s     BRA _00000004
000005C2                          1300s _00000003
000005C2                          1301          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000005C2  B23C 0031               1302s     CMP.B   #'1',D1
000005C6  6708                    1303s     BEQ.S   _00000005
000005C8  B23C 0032               1304s     CMP.B   #'2',D1
000005CC  6600 0158               1305s     BNE.L   _00000006
000005D0                          1306s _00000005
000005D0  5783                    1307              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000005D2                          1308  
000005D2  7800                    1309              MOVE.L #0,D4                            ; read two bytes of address
000005D4                          1310m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000005D4  1E3C 0002               1311m     MOVE.B #2,D7
000005D8                          1312m     WHILE.B D7 <GT> 0 DO
000005D8                          1313ms _10000002
000005D8  BE38 0000               1314ms     CMP.B   0,D7
000005DC  6F00 003C               1315ms     BLE _10000003
000005E0  E98C                    1316m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005E2                          1317mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005E2                          1318mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                          1319mm 
000005E2  1A39 00C00013           1320mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005E8  0805 0000               1321mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005EC  67F4                    1322mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000005EE                          1323mm     
000005EE  1A39 00C00017           1324mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005F4                          1325mm     
000005F4  BA3C 001B               1326mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005F8  6700 FA0E               1327mm     BEQ START
000005FC                          1328mm 
000005FC  13C5 00E00001           1329mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000602                          1330mm 
00000602                          1331mm     ENDM
00000602                          1332m         ;PRINT_CHAR D5,D6
00000602                          1333mm         HEX2BIN D5,D5,A4
00000602  49FA 1736               1334mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000606  0405 0030               1335mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000060A  CABC 000000FF           1336mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000610  1A34 5000               1337mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000614                          1338mm     ENDM
00000614  8805                    1339m         OR.B D5,D4
00000616  5307                    1340m         SUB.B #1,D7
00000618                          1341m     ENDW
00000618  60BE                    1342ms     BRA _10000002
0000061A                          1343ms _10000003
0000061A                          1344m 
0000061A  7A00                    1345m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000061C  1A04                    1346m     MOVE.B D4,D5
0000061E  D484                    1347m     ADD.L D4,D2
00000620                          1348m 
00000620                          1349m     ENDM
00000620                          1350m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000620  1E3C 0002               1351m     MOVE.B #2,D7
00000624                          1352m     WHILE.B D7 <GT> 0 DO
00000624                          1353ms _10000004
00000624  BE38 0000               1354ms     CMP.B   0,D7
00000628  6F00 003C               1355ms     BLE _10000005
0000062C  E98C                    1356m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000062E                          1357mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000062E                          1358mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                          1359mm 
0000062E  1A39 00C00013           1360mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000634  0805 0000               1361mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000638  67F4                    1362mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
0000063A                          1363mm     
0000063A  1A39 00C00017           1364mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000640                          1365mm     
00000640  BA3C 001B               1366mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000644  6700 F9C2               1367mm     BEQ START
00000648                          1368mm 
00000648  13C5 00E00001           1369mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000064E                          1370mm 
0000064E                          1371mm     ENDM
0000064E                          1372m         ;PRINT_CHAR D5,D6
0000064E                          1373mm         HEX2BIN D5,D5,A4
0000064E  49FA 16EA               1374mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000652  0405 0030               1375mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000656  CABC 000000FF           1376mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000065C  1A34 5000               1377mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000660                          1378mm     ENDM
00000660  8805                    1379m         OR.B D5,D4
00000662  5307                    1380m         SUB.B #1,D7
00000664                          1381m     ENDW
00000664  60BE                    1382ms     BRA _10000004
00000666                          1383ms _10000005
00000666                          1384m 
00000666  7A00                    1385m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000668  1A04                    1386m     MOVE.B D4,D5
0000066A  D484                    1387m     ADD.L D4,D2
0000066C                          1388m 
0000066C                          1389m     ENDM
0000066C                          1390  
0000066C                          1391              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
0000066C  B23C 0032               1392s     CMP.B   #'2',D1
00000670  6600 0050               1393s     BNE.L   _00000007
00000674  5383                    1394                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000676                          1395m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000676  1E3C 0002               1396m     MOVE.B #2,D7
0000067A                          1397m     WHILE.B D7 <GT> 0 DO
0000067A                          1398ms _10000006
0000067A  BE38 0000               1399ms     CMP.B   0,D7
0000067E  6F00 003C               1400ms     BLE _10000007
00000682  E98C                    1401m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000684                          1402mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000684                          1403mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000684                          1404mm 
00000684  1A39 00C00013           1405mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000068A  0805 0000               1406mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000068E  67F4                    1407mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000690                          1408mm     
00000690  1A39 00C00017           1409mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000696                          1410mm     
00000696  BA3C 001B               1411mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000069A  6700 F96C               1412mm     BEQ START
0000069E                          1413mm 
0000069E  13C5 00E00001           1414mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006A4                          1415mm 
000006A4                          1416mm     ENDM
000006A4                          1417m         ;PRINT_CHAR D5,D6
000006A4                          1418mm         HEX2BIN D5,D5,A4
000006A4  49FA 1694               1419mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006A8  0405 0030               1420mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006AC  CABC 000000FF           1421mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006B2  1A34 5000               1422mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006B6                          1423mm     ENDM
000006B6  8805                    1424m         OR.B D5,D4
000006B8  5307                    1425m         SUB.B #1,D7
000006BA                          1426m     ENDW
000006BA  60BE                    1427ms     BRA _10000006
000006BC                          1428ms _10000007
000006BC                          1429m 
000006BC  7A00                    1430m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006BE  1A04                    1431m     MOVE.B D4,D5
000006C0  D484                    1432m     ADD.L D4,D2
000006C2                          1433m 
000006C2                          1434m     ENDM
000006C2                          1435              ENDI
000006C2                          1436s _00000007
000006C2                          1437  
000006C2  2444                    1438              MOVE.L D4,A2                            ; put the address in an address register
000006C4  D5C9                    1439              ADD.L A1,A2                             ; add in the offset
000006C6                          1440  
000006C6                          1441              WHILE.B D3 <HI> #0 DO                   ; read the data bytes
000006C6                          1442s _10000008
000006C6  B63C 0000               1443s     CMP.B   #0,D3
000006CA  6300 0054               1444s     BLS _10000009
000006CE                          1445m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000006CE  1E3C 0002               1446m     MOVE.B #2,D7
000006D2                          1447m     WHILE.B D7 <GT> 0 DO
000006D2                          1448ms _1000000A
000006D2  BE38 0000               1449ms     CMP.B   0,D7
000006D6  6F00 003C               1450ms     BLE _1000000B
000006DA  E989                    1451m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000006DC                          1452mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006DC                          1453mm WAIT_FOR_READY_70                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006DC                          1454mm 
000006DC  1A39 00C00013           1455mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006E2  0805 0000               1456mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006E6  67F4                    1457mm     BEQ WAIT_FOR_READY_70                           ; NOTHING, CHECK AGAIN
000006E8                          1458mm     
000006E8  1A39 00C00017           1459mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006EE                          1460mm     
000006EE  BA3C 001B               1461mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006F2  6700 F914               1462mm     BEQ START
000006F6                          1463mm 
000006F6  13C5 00E00001           1464mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006FC                          1465mm 
000006FC                          1466mm     ENDM
000006FC                          1467m         ;PRINT_CHAR D5,D6
000006FC                          1468mm         HEX2BIN D5,D5,A4
000006FC  49FA 163C               1469mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000700  0405 0030               1470mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000704  CABC 000000FF           1471mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000070A  1A34 5000               1472mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000070E                          1473mm     ENDM
0000070E  8205                    1474m         OR.B D5,D1
00000710  5307                    1475m         SUB.B #1,D7
00000712                          1476m     ENDW
00000712  60BE                    1477ms     BRA _1000000A
00000714                          1478ms _1000000B
00000714                          1479m 
00000714  7A00                    1480m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000716  1A01                    1481m     MOVE.B D1,D5
00000718  D481                    1482m     ADD.L D1,D2
0000071A                          1483m 
0000071A                          1484m     ENDM
0000071A                          1485   
0000071A  14C1                    1486                  MOVE.B D1,(A2)+                     ; store it!
0000071C                          1487  
0000071C  5303                    1488                  SUB.B #1,D3                         ; 1 less byte to go
0000071E                          1489              ENDW
0000071E  60A6                    1490s     BRA _10000008
00000720                          1491s _10000009
00000720                          1492  
00000720  7200                    1493              MOVE.L #0,D1                            ; not done yet
00000722                          1494          ELSE
00000722  6000 0170               1495s     BRA _00000008
00000726                          1496s _00000006
00000726                          1497              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000726  B23C 0038               1498s     CMP.B   #'8',D1
0000072A  6600 00F2               1499s     BNE.L   _00000009
0000072E  7800                    1500                  MOVE.L #0,D4                        ; read the 24 bit start address
00000730                          1501m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000730  1E3C 0002               1502m     MOVE.B #2,D7
00000734                          1503m     WHILE.B D7 <GT> 0 DO
00000734                          1504ms _1000000C
00000734  BE38 0000               1505ms     CMP.B   0,D7
00000738  6F00 003C               1506ms     BLE _1000000D
0000073C  E98C                    1507m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000073E                          1508mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000073E                          1509mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000073E                          1510mm 
0000073E  1A39 00C00013           1511mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000744  0805 0000               1512mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000748  67F4                    1513mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
0000074A                          1514mm     
0000074A  1A39 00C00017           1515mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000750                          1516mm     
00000750  BA3C 001B               1517mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000754  6700 F8B2               1518mm     BEQ START
00000758                          1519mm 
00000758  13C5 00E00001           1520mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000075E                          1521mm 
0000075E                          1522mm     ENDM
0000075E                          1523m         ;PRINT_CHAR D5,D6
0000075E                          1524mm         HEX2BIN D5,D5,A4
0000075E  49FA 15DA               1525mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000762  0405 0030               1526mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000766  CABC 000000FF           1527mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000076C  1A34 5000               1528mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000770                          1529mm     ENDM
00000770  8805                    1530m         OR.B D5,D4
00000772  5307                    1531m         SUB.B #1,D7
00000774                          1532m     ENDW
00000774  60BE                    1533ms     BRA _1000000C
00000776                          1534ms _1000000D
00000776                          1535m 
00000776  7A00                    1536m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000778  1A04                    1537m     MOVE.B D4,D5
0000077A  D484                    1538m     ADD.L D4,D2
0000077C                          1539m 
0000077C                          1540m     ENDM
0000077C                          1541m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000077C  1E3C 0002               1542m     MOVE.B #2,D7
00000780                          1543m     WHILE.B D7 <GT> 0 DO
00000780                          1544ms _1000000E
00000780  BE38 0000               1545ms     CMP.B   0,D7
00000784  6F00 003C               1546ms     BLE _1000000F
00000788  E98C                    1547m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000078A                          1548mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000078A                          1549mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078A                          1550mm 
0000078A  1A39 00C00013           1551mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000790  0805 0000               1552mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000794  67F4                    1553mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00000796                          1554mm     
00000796  1A39 00C00017           1555mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000079C                          1556mm     
0000079C  BA3C 001B               1557mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007A0  6700 F866               1558mm     BEQ START
000007A4                          1559mm 
000007A4  13C5 00E00001           1560mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007AA                          1561mm 
000007AA                          1562mm     ENDM
000007AA                          1563m         ;PRINT_CHAR D5,D6
000007AA                          1564mm         HEX2BIN D5,D5,A4
000007AA  49FA 158E               1565mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007AE  0405 0030               1566mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007B2  CABC 000000FF           1567mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007B8  1A34 5000               1568mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007BC                          1569mm     ENDM
000007BC  8805                    1570m         OR.B D5,D4
000007BE  5307                    1571m         SUB.B #1,D7
000007C0                          1572m     ENDW
000007C0  60BE                    1573ms     BRA _1000000E
000007C2                          1574ms _1000000F
000007C2                          1575m 
000007C2  7A00                    1576m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007C4  1A04                    1577m     MOVE.B D4,D5
000007C6  D484                    1578m     ADD.L D4,D2
000007C8                          1579m 
000007C8                          1580m     ENDM
000007C8                          1581m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000007C8  1E3C 0002               1582m     MOVE.B #2,D7
000007CC                          1583m     WHILE.B D7 <GT> 0 DO
000007CC                          1584ms _10000010
000007CC  BE38 0000               1585ms     CMP.B   0,D7
000007D0  6F00 003C               1586ms     BLE _10000011
000007D4  E98C                    1587m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007D6                          1588mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007D6                          1589mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007D6                          1590mm 
000007D6  1A39 00C00013           1591mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007DC  0805 0000               1592mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E0  67F4                    1593mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
000007E2                          1594mm     
000007E2  1A39 00C00017           1595mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007E8                          1596mm     
000007E8  BA3C 001B               1597mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007EC  6700 F81A               1598mm     BEQ START
000007F0                          1599mm 
000007F0  13C5 00E00001           1600mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007F6                          1601mm 
000007F6                          1602mm     ENDM
000007F6                          1603m         ;PRINT_CHAR D5,D6
000007F6                          1604mm         HEX2BIN D5,D5,A4
000007F6  49FA 1542               1605mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007FA  0405 0030               1606mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007FE  CABC 000000FF           1607mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000804  1A34 5000               1608mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000808                          1609mm     ENDM
00000808  8805                    1610m         OR.B D5,D4
0000080A  5307                    1611m         SUB.B #1,D7
0000080C                          1612m     ENDW
0000080C  60BE                    1613ms     BRA _10000010
0000080E                          1614ms _10000011
0000080E                          1615m 
0000080E  7A00                    1616m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000810  1A04                    1617m     MOVE.B D4,D5
00000812  D484                    1618m     ADD.L D4,D2
00000814                          1619m 
00000814                          1620m     ENDM
00000814                          1621  
00000814  2044                    1622                  MOVE.L D4,A0                        ; start address -> A0
00000816  D1C9                    1623                  ADD.L A1,A0                         ; add in the offset
00000818                          1624  
00000818  72FF                    1625                  MOVE.L #$FFFFFFFF,D1                ; done
0000081A                          1626              ELSE
0000081A  6000 0078               1627s     BRA _0000000A
0000081E                          1628s _00000009
0000081E                          1629m                 PRINT_CRLF D5,A4
0000081E  49FA 1545               1630m     LEA CRLF(PC),A4
00000822                          1631mm     PRINT_STR A4,D5
00000822                          1632mm LOOP_82
00000822  0C14 0000               1633mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000826  6700 0016               1634mm     BEQ EXIT_82
0000082A                          1635mmm     PRINT_CHAR (A4)+,D5
0000082A                          1636mmm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082A                 TRUE     1637mmm     IFEQ DEBUG
0000082A  1A39 00C00003           1638mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000830  0805 0002               1639mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000834  67F4                    1640mmm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000836  13DC 00C00007           1641mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000083C                          1642mmm     ENDC
0000083C                          1643mmm 
0000083C                 FALSE    1644mmm     IFNE DEBUG
0000083C                          1645mmm     ENDC
0000083C                          1646mmm 
0000083C                          1647mmm     ENDM
0000083C  60E4                    1648mm     BRA LOOP_82
0000083E                          1649mm EXIT_82
0000083E                          1650mm     ENDM
0000083E                          1651m     ENDM
0000083E                          1652  
0000083E  49FA 14B1               1653                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000842                          1654m                 PRINT_STR A4,D5
00000842                          1655m LOOP_84
00000842  0C14 0000               1656m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000846  6700 0016               1657m     BEQ EXIT_84
0000084A                          1658mm     PRINT_CHAR (A4)+,D5
0000084A                          1659mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000084A                 TRUE     1660mm     IFEQ DEBUG
0000084A  1A39 00C00003           1661mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000850  0805 0002               1662mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000854  67F4                    1663mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000856  13DC 00C00007           1664mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000085C                          1665mm     ENDC
0000085C                          1666mm 
0000085C                 FALSE    1667mm     IFNE DEBUG
0000085C                          1668mm     ENDC
0000085C                          1669mm 
0000085C                          1670mm     ENDM
0000085C  60E4                    1671m     BRA LOOP_84
0000085E                          1672m EXIT_84
0000085E                          1673m     ENDM
0000085E                          1674m                 PRINT_CHAR D1,D5
0000085E                          1675m WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085E                 TRUE     1676m     IFEQ DEBUG
0000085E  1A39 00C00003           1677m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000864  0805 0002               1678m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000868  67F4                    1679m         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
0000086A  13C1 00C00007           1680m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000870                          1681m     ENDC
00000870                          1682m 
00000870                 FALSE    1683m     IFNE DEBUG
00000870                          1684m     ENDC
00000870                          1685m 
00000870                          1686m     ENDM
00000870                          1687m                 PRINT_CRLF D5,A4
00000870  49FA 14F3               1688m     LEA CRLF(PC),A4
00000874                          1689mm     PRINT_STR A4,D5
00000874                          1690mm LOOP_88
00000874  0C14 0000               1691mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000878  6700 0016               1692mm     BEQ EXIT_88
0000087C                          1693mmm     PRINT_CHAR (A4)+,D5
0000087C                          1694mmm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087C                 TRUE     1695mmm     IFEQ DEBUG
0000087C  1A39 00C00003           1696mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000882  0805 0002               1697mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000886  67F4                    1698mmm         BEQ WAIT_FOR_READY_89                       ; NO SPACE, CHECK AGAIN
00000888  13DC 00C00007           1699mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000088E                          1700mmm     ENDC
0000088E                          1701mmm 
0000088E                 FALSE    1702mmm     IFNE DEBUG
0000088E                          1703mmm     ENDC
0000088E                          1704mmm 
0000088E                          1705mmm     ENDM
0000088E  60E4                    1706mm     BRA LOOP_88
00000890                          1707mm EXIT_88
00000890                          1708mm     ENDM
00000890                          1709m     ENDM
00000890                          1710  
00000890  6000 FC74               1711                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000894                          1712              ENDI
00000894                          1713s _0000000A
00000894                          1714          ENDI
00000894                          1715s _00000008
00000894                          1716      ENDI
00000894                          1717s _00000004
00000894                          1718  
00000894                          1719m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000894  1E3C 0002               1720m     MOVE.B #2,D7
00000898                          1721m     WHILE.B D7 <GT> 0 DO
00000898                          1722ms _10000012
00000898  BE38 0000               1723ms     CMP.B   0,D7
0000089C  6F00 003C               1724ms     BLE _10000013
000008A0  E98C                    1725m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008A2                          1726mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008A2                          1727mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008A2                          1728mm 
000008A2  1A39 00C00013           1729mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008A8  0805 0000               1730mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008AC  67F4                    1731mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
000008AE                          1732mm     
000008AE  1A39 00C00017           1733mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008B4                          1734mm     
000008B4  BA3C 001B               1735mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008B8  6700 F74E               1736mm     BEQ START
000008BC                          1737mm 
000008BC  13C5 00E00001           1738mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008C2                          1739mm 
000008C2                          1740mm     ENDM
000008C2                          1741m         ;PRINT_CHAR D5,D6
000008C2                          1742mm         HEX2BIN D5,D5,A4
000008C2  49FA 1476               1743mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008C6  0405 0030               1744mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008CA  CABC 000000FF           1745mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008D0  1A34 5000               1746mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008D4                          1747mm     ENDM
000008D4  8805                    1748m         OR.B D5,D4
000008D6  5307                    1749m         SUB.B #1,D7
000008D8                          1750m     ENDW
000008D8  60BE                    1751ms     BRA _10000012
000008DA                          1752ms _10000013
000008DA                          1753m 
000008DA  7A00                    1754m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008DC  1A04                    1755m     MOVE.B D4,D5
000008DE  D484                    1756m     ADD.L D4,D2
000008E0                          1757m 
000008E0                          1758m     ENDM
000008E0                          1759  
000008E0                          1760      IF.B D2 <NE> #$FF THEN.L
000008E0  B43C 00FF               1761s     CMP.B   #$FF,D2
000008E4  6700 00B0               1762s     BEQ.L   _0000000B
000008E8                          1763m         PRINT_CRLF D5,A4
000008E8  49FA 147B               1764m     LEA CRLF(PC),A4
000008EC                          1765mm     PRINT_STR A4,D5
000008EC                          1766mm LOOP_94
000008EC  0C14 0000               1767mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008F0  6700 0016               1768mm     BEQ EXIT_94
000008F4                          1769mmm     PRINT_CHAR (A4)+,D5
000008F4                          1770mmm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F4                 TRUE     1771mmm     IFEQ DEBUG
000008F4  1A39 00C00003           1772mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008FA  0805 0002               1773mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008FE  67F4                    1774mmm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000900  13DC 00C00007           1775mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000906                          1776mmm     ENDC
00000906                          1777mmm 
00000906                 FALSE    1778mmm     IFNE DEBUG
00000906                          1779mmm     ENDC
00000906                          1780mmm 
00000906                          1781mmm     ENDM
00000906  60E4                    1782mm     BRA LOOP_94
00000908                          1783mm EXIT_94
00000908                          1784mm     ENDM
00000908                          1785m     ENDM
00000908  49FA 13FE               1786          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
0000090C                          1787m         PRINT_STR A4,D5
0000090C                          1788m LOOP_96
0000090C  0C14 0000               1789m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000910  6700 0016               1790m     BEQ EXIT_96
00000914                          1791mm     PRINT_CHAR (A4)+,D5
00000914                          1792mm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000914                 TRUE     1793mm     IFEQ DEBUG
00000914  1A39 00C00003           1794mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000091A  0805 0002               1795mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000091E  67F4                    1796mm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
00000920  13DC 00C00007           1797mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000926                          1798mm     ENDC
00000926                          1799mm 
00000926                 FALSE    1800mm     IFNE DEBUG
00000926                          1801mm     ENDC
00000926                          1802mm 
00000926                          1803mm     ENDM
00000926  60E4                    1804m     BRA LOOP_96
00000928                          1805m EXIT_96
00000928                          1806m     ENDM
00000928                          1807m         PRINT_REG D0,D5,D3,D6,A4
00000928  49FA 1441               1808m     LEA OX(PC),A4
0000092C                          1809mm     PRINT_STR A4,D5
0000092C                          1810mm LOOP_99
0000092C  0C14 0000               1811mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000930  6700 0016               1812mm     BEQ EXIT_99
00000934                          1813mmm     PRINT_CHAR (A4)+,D5
00000934                          1814mmm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000934                 TRUE     1815mmm     IFEQ DEBUG
00000934  1A39 00C00003           1816mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000093A  0805 0002               1817mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000093E  67F4                    1818mmm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000940  13DC 00C00007           1819mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000946                          1820mmm     ENDC
00000946                          1821mmm 
00000946                 FALSE    1822mmm     IFNE DEBUG
00000946                          1823mmm     ENDC
00000946                          1824mmm 
00000946                          1825mmm     ENDM
00000946  60E4                    1826mm     BRA LOOP_99
00000948                          1827mm EXIT_99
00000948                          1828mm     ENDM
00000948  7C07                    1829m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000094A                          1830m LOOP_98
0000094A                          1831mm     BIN2HEX D0,D3,A4
0000094A  49FA 13DE               1832mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000094E  E998                    1833mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000950  1600                    1834mm     MOVE.B D0,D3
00000952  0283 0000000F           1835mm     ANDI.L #$F,D3
00000958  1634 3000               1836mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000095C                          1837mm     ENDM
0000095C                          1838mm     PRINT_CHAR D3,D5
0000095C                          1839mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                 TRUE     1840mm     IFEQ DEBUG
0000095C  1A39 00C00003           1841mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000962  0805 0002               1842mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000966  67F4                    1843mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000968  13C3 00C00007           1844mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000096E                          1845mm     ENDC
0000096E                          1846mm 
0000096E                 FALSE    1847mm     IFNE DEBUG
0000096E                          1848mm     ENDC
0000096E                          1849mm 
0000096E                          1850mm     ENDM
0000096E  57CE FFDA               1851m     DBEQ D6,LOOP_98
00000972                          1852m     ENDM
00000972                          1853m         PRINT_CRLF D5,A4
00000972  49FA 13F1               1854m     LEA CRLF(PC),A4
00000976                          1855mm     PRINT_STR A4,D5
00000976                          1856mm LOOP_104
00000976  0C14 0000               1857mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000097A  6700 0016               1858mm     BEQ EXIT_104
0000097E                          1859mmm     PRINT_CHAR (A4)+,D5
0000097E                          1860mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000097E                 TRUE     1861mmm     IFEQ DEBUG
0000097E  1A39 00C00003           1862mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000984  0805 0002               1863mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000988  67F4                    1864mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
0000098A  13DC 00C00007           1865mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000990                          1866mmm     ENDC
00000990                          1867mmm 
00000990                 FALSE    1868mmm     IFNE DEBUG
00000990                          1869mmm     ENDC
00000990                          1870mmm 
00000990                          1871mmm     ENDM
00000990  60E4                    1872mm     BRA LOOP_104
00000992                          1873mm EXIT_104
00000992                          1874mm     ENDM
00000992                          1875m     ENDM
00000992                          1876          
00000992  6000 F8AE               1877          BRA MAIN_LOOP
00000996                          1878      ENDI
00000996                          1879s _0000000B
00000996                          1880  
00000996                          1881      IF D1 <EQ> #0 THEN
00000996  B27C 0000               1882s     CMP.W   #0,D1
0000099A  6600 0006               1883s     BNE _0000000C
0000099E  6000 FB66               1884        BRA WAIT_FOR_SRECORD
000009A2                          1885      ENDI
000009A2                          1886s _0000000C
000009A2                          1887  DOWNLOAD_DONE
000009A2                          1888m     PRINT_CRLF D5,A4
000009A2  49FA 13C1               1889m     LEA CRLF(PC),A4
000009A6                          1890mm     PRINT_STR A4,D5
000009A6                          1891mm LOOP_107
000009A6  0C14 0000               1892mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009AA  6700 0016               1893mm     BEQ EXIT_107
000009AE                          1894mmm     PRINT_CHAR (A4)+,D5
000009AE                          1895mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009AE                 TRUE     1896mmm     IFEQ DEBUG
000009AE  1A39 00C00003           1897mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009B4  0805 0002               1898mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009B8  67F4                    1899mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
000009BA  13DC 00C00007           1900mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009C0                          1901mmm     ENDC
000009C0                          1902mmm 
000009C0                 FALSE    1903mmm     IFNE DEBUG
000009C0                          1904mmm     ENDC
000009C0                          1905mmm 
000009C0                          1906mmm     ENDM
000009C0  60E4                    1907mm     BRA LOOP_107
000009C2                          1908mm EXIT_107
000009C2                          1909mm     ENDM
000009C2                          1910m     ENDM
000009C2                          1911m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
000009C2  43FA 13A7               1912m     LEA OX(PC),A1
000009C6                          1913mm     PRINT_STR A1,D5
000009C6                          1914mm LOOP_110
000009C6  0C11 0000               1915mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000009CA  6700 0016               1916mm     BEQ EXIT_110
000009CE                          1917mmm     PRINT_CHAR (A1)+,D5
000009CE                          1918mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009CE                 TRUE     1919mmm     IFEQ DEBUG
000009CE  1A39 00C00003           1920mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009D4  0805 0002               1921mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009D8  67F4                    1922mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009DA  13D9 00C00007           1923mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009E0                          1924mmm     ENDC
000009E0                          1925mmm 
000009E0                 FALSE    1926mmm     IFNE DEBUG
000009E0                          1927mmm     ENDC
000009E0                          1928mmm 
000009E0                          1929mmm     ENDM
000009E0  60E4                    1930mm     BRA LOOP_110
000009E2                          1931mm EXIT_110
000009E2                          1932mm     ENDM
000009E2  7407                    1933m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009E4                          1934m LOOP_109
000009E4                          1935mm     BIN2HEX D0,D6,A1
000009E4  43FA 1344               1936mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
000009E8  E998                    1937mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009EA  1C00                    1938mm     MOVE.B D0,D6
000009EC  0286 0000000F           1939mm     ANDI.L #$F,D6
000009F2  1C31 6000               1940mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
000009F6                          1941mm     ENDM
000009F6                          1942mm     PRINT_CHAR D6,D5
000009F6                          1943mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F6                 TRUE     1944mm     IFEQ DEBUG
000009F6  1A39 00C00003           1945mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009FC  0805 0002               1946mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A00  67F4                    1947mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000A02  13C6 00C00007           1948mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A08                          1949mm     ENDC
00000A08                          1950mm 
00000A08                 FALSE    1951mm     IFNE DEBUG
00000A08                          1952mm     ENDC
00000A08                          1953mm 
00000A08                          1954mm     ENDM
00000A08  57CA FFDA               1955m     DBEQ D2,LOOP_109
00000A0C                          1956m     ENDM
00000A0C  43FA 12C1               1957      LEA READ(PC),A1
00000A10                          1958m     PRINT_STR A1,D5
00000A10                          1959m LOOP_114
00000A10  0C11 0000               1960m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A14  6700 0016               1961m     BEQ EXIT_114
00000A18                          1962mm     PRINT_CHAR (A1)+,D5
00000A18                          1963mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A18                 TRUE     1964mm     IFEQ DEBUG
00000A18  1A39 00C00003           1965mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A1E  0805 0002               1966mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A22  67F4                    1967mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000A24  13D9 00C00007           1968mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A2A                          1969mm     ENDC
00000A2A                          1970mm 
00000A2A                 FALSE    1971mm     IFNE DEBUG
00000A2A                          1972mm     ENDC
00000A2A                          1973mm 
00000A2A                          1974mm     ENDM
00000A2A  60E4                    1975m     BRA LOOP_114
00000A2C                          1976m EXIT_114
00000A2C                          1977m     ENDM
00000A2C  2E08                    1978      MOVE.L A0,D7                                    ; set address accumulator to start address
00000A2E                          1979m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000A2E  43FA 133B               1980m     LEA OX(PC),A1
00000A32                          1981mm     PRINT_STR A1,D5
00000A32                          1982mm LOOP_117
00000A32  0C11 0000               1983mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A36  6700 0016               1984mm     BEQ EXIT_117
00000A3A                          1985mmm     PRINT_CHAR (A1)+,D5
00000A3A                          1986mmm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A3A                 TRUE     1987mmm     IFEQ DEBUG
00000A3A  1A39 00C00003           1988mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A40  0805 0002               1989mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A44  67F4                    1990mmm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A46  13D9 00C00007           1991mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A4C                          1992mmm     ENDC
00000A4C                          1993mmm 
00000A4C                 FALSE    1994mmm     IFNE DEBUG
00000A4C                          1995mmm     ENDC
00000A4C                          1996mmm 
00000A4C                          1997mmm     ENDM
00000A4C  60E4                    1998mm     BRA LOOP_117
00000A4E                          1999mm EXIT_117
00000A4E                          2000mm     ENDM
00000A4E  7407                    2001m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A50                          2002m LOOP_116
00000A50                          2003mm     BIN2HEX D7,D6,A1
00000A50  43FA 12D8               2004mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A54  E99F                    2005mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A56  1C07                    2006mm     MOVE.B D7,D6
00000A58  0286 0000000F           2007mm     ANDI.L #$F,D6
00000A5E  1C31 6000               2008mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A62                          2009mm     ENDM
00000A62                          2010mm     PRINT_CHAR D6,D5
00000A62                          2011mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A62                 TRUE     2012mm     IFEQ DEBUG
00000A62  1A39 00C00003           2013mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A68  0805 0002               2014mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A6C  67F4                    2015mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000A6E  13C6 00C00007           2016mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A74                          2017mm     ENDC
00000A74                          2018mm 
00000A74                 FALSE    2019mm     IFNE DEBUG
00000A74                          2020mm     ENDC
00000A74                          2021mm 
00000A74                          2022mm     ENDM
00000A74  57CA FFDA               2023m     DBEQ D2,LOOP_116
00000A78                          2024m     ENDM
00000A78                          2025m     PRINT_CRLF D5,A4
00000A78  49FA 12EB               2026m     LEA CRLF(PC),A4
00000A7C                          2027mm     PRINT_STR A4,D5
00000A7C                          2028mm LOOP_122
00000A7C  0C14 0000               2029mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A80  6700 0016               2030mm     BEQ EXIT_122
00000A84                          2031mmm     PRINT_CHAR (A4)+,D5
00000A84                          2032mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A84                 TRUE     2033mmm     IFEQ DEBUG
00000A84  1A39 00C00003           2034mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A8A  0805 0002               2035mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A8E  67F4                    2036mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000A90  13DC 00C00007           2037mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A96                          2038mmm     ENDC
00000A96                          2039mmm 
00000A96                 FALSE    2040mmm     IFNE DEBUG
00000A96                          2041mmm     ENDC
00000A96                          2042mmm 
00000A96                          2043mmm     ENDM
00000A96  60E4                    2044mm     BRA LOOP_122
00000A98                          2045mm EXIT_122
00000A98                          2046mm     ENDM
00000A98                          2047m     ENDM
00000A98                          2048  
00000A98  6000 F7A8               2049      BRA MAIN_LOOP
00000A9C                          2050  
00000A9C                          2051  G
00000A9C  2047                    2052      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000A9E  7E00                    2053      MOVE.L #0,D7
00000AA0                          2054  
00000AA0  4ED0                    2055      JMP (A0)
00000AA2                          2056          
00000AA2                          2057  Z
00000AA2  207C 00200000           2058      MOVE.L #RAM,A0                                  ; address of RAM
00000AA8  D1FC 00100000           2059      ADD.L #$100000,A0
00000AAE                          2060  
00000AAE                          2061      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000AAE  7000                    2062s     MOVE.L  #0,D0
00000AB0  6000 0012               2063s     BRA _20000007
00000AB4                          2064s _20000006
00000AB4  2200                    2065          MOVE.L D0,D1                                ; progress update
00000AB6  E089                    2066          LSR.L #8,D1 
00000AB8  E089                    2067          LSR.L #8,D1
00000ABA  13C1 00E00001           2068          MOVE.B D1,DISPLAY
00000AC0                          2069          
00000AC0  2108                    2070          MOVE.L A0,-(A0)
00000AC2                          2071      ENDF
00000AC2  5880                    2072s     ADD.L   #4,D0
00000AC4                          2073s _20000007
00000AC4  B0BC 000FFFFC           2074s     CMP.L   #$FFFFC,D0
00000ACA  6FE8                    2075s     BLE _20000006
00000ACC                          2076  
00000ACC  207C 00200000           2077      MOVE.L #RAM,A0                                  ; address of RAM
00000AD2  D1FC 00100000           2078      ADD.L #$100000,A0
00000AD8                          2079  
00000AD8                          2080      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000AD8  7000                    2081s     MOVE.L  #0,D0
00000ADA  6000 00A8               2082s     BRA _20000009
00000ADE                          2083s _20000008
00000ADE  2200                    2084          MOVE.L D0,D1                                ; progress update
00000AE0  E089                    2085          LSR.L #8,D1
00000AE2  E089                    2086          LSR.L #8,D1
00000AE4  13C1 00E00001           2087          MOVE.B D1,DISPLAY
00000AEA                          2088  
00000AEA  2408                    2089          MOVE.L A0,D2
00000AEC  2220                    2090          MOVE.L -(A0),D1
00000AEE                          2091  
00000AEE                          2092          IF.L D2 <NE> D1 THEN
00000AEE  B481                    2093s     CMP.L   D1,D2
00000AF0  6700 0090               2094s     BEQ _0000000D
00000AF4  43FA 1223               2095              LEA RAM_ERROR(PC),A1
00000AF8                          2096m             PRINT_STR A1,D1
00000AF8                          2097m LOOP_124
00000AF8  0C11 0000               2098m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AFC  6700 0016               2099m     BEQ EXIT_124
00000B00                          2100mm     PRINT_CHAR (A1)+,D1
00000B00                          2101mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B00                 TRUE     2102mm     IFEQ DEBUG
00000B00  1239 00C00003           2103mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000B06  0801 0002               2104mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000B0A  67F4                    2105mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000B0C  13D9 00C00007           2106mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B12                          2107mm     ENDC
00000B12                          2108mm 
00000B12                 FALSE    2109mm     IFNE DEBUG
00000B12                          2110mm     ENDC
00000B12                          2111mm 
00000B12                          2112mm     ENDM
00000B12  60E4                    2113m     BRA LOOP_124
00000B14                          2114m EXIT_124
00000B14                          2115m     ENDM
00000B14  2208                    2116              MOVE.L A0,D1
00000B16  5981                    2117              SUB.L #4,D1
00000B18                          2118m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000B18  43FA 1251               2119m     LEA OX(PC),A1
00000B1C                          2120mm     PRINT_STR A1,D3
00000B1C                          2121mm LOOP_127
00000B1C  0C11 0000               2122mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B20  6700 0016               2123mm     BEQ EXIT_127
00000B24                          2124mmm     PRINT_CHAR (A1)+,D3
00000B24                          2125mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B24                 TRUE     2126mmm     IFEQ DEBUG
00000B24  1639 00C00003           2127mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B2A  0803 0002               2128mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B2E  67F4                    2129mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000B30  13D9 00C00007           2130mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B36                          2131mmm     ENDC
00000B36                          2132mmm 
00000B36                 FALSE    2133mmm     IFNE DEBUG
00000B36                          2134mmm     ENDC
00000B36                          2135mmm 
00000B36                          2136mmm     ENDM
00000B36  60E4                    2137mm     BRA LOOP_127
00000B38                          2138mm EXIT_127
00000B38                          2139mm     ENDM
00000B38  7C07                    2140m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B3A                          2141m LOOP_126
00000B3A                          2142mm     BIN2HEX D1,D2,A1
00000B3A  43FA 11EE               2143mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B3E  E999                    2144mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B40  1401                    2145mm     MOVE.B D1,D2
00000B42  0282 0000000F           2146mm     ANDI.L #$F,D2
00000B48  1431 2000               2147mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000B4C                          2148mm     ENDM
00000B4C                          2149mm     PRINT_CHAR D2,D3
00000B4C                          2150mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4C                 TRUE     2151mm     IFEQ DEBUG
00000B4C  1639 00C00003           2152mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B52  0803 0002               2153mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B56  67F4                    2154mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000B58  13C2 00C00007           2155mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B5E                          2156mm     ENDC
00000B5E                          2157mm 
00000B5E                 FALSE    2158mm     IFNE DEBUG
00000B5E                          2159mm     ENDC
00000B5E                          2160mm 
00000B5E                          2161mm     ENDM
00000B5E  57CE FFDA               2162m     DBEQ D6,LOOP_126
00000B62                          2163m     ENDM
00000B62                          2164m             PRINT_CRLF D3,A1
00000B62  43FA 1201               2165m     LEA CRLF(PC),A1
00000B66                          2166mm     PRINT_STR A1,D3
00000B66                          2167mm LOOP_132
00000B66  0C11 0000               2168mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B6A  6700 0016               2169mm     BEQ EXIT_132
00000B6E                          2170mmm     PRINT_CHAR (A1)+,D3
00000B6E                          2171mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B6E                 TRUE     2172mmm     IFEQ DEBUG
00000B6E  1639 00C00003           2173mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B74  0803 0002               2174mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B78  67F4                    2175mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000B7A  13D9 00C00007           2176mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B80                          2177mmm     ENDC
00000B80                          2178mmm 
00000B80                 FALSE    2179mmm     IFNE DEBUG
00000B80                          2180mmm     ENDC
00000B80                          2181mmm 
00000B80                          2182mmm     ENDM
00000B80  60E4                    2183mm     BRA LOOP_132
00000B82                          2184mm EXIT_132
00000B82                          2185mm     ENDM
00000B82                          2186m     ENDM
00000B82                          2187          ENDI 
00000B82                          2188s _0000000D
00000B82                          2189      ENDF
00000B82  5880                    2190s     ADD.L   #4,D0
00000B84                          2191s _20000009
00000B84  B0BC 000FFFFC           2192s     CMP.L   #$FFFFC,D0
00000B8A  6F00 FF52               2193s     BLE _20000008
00000B8E                          2194  
00000B8E  6000 F6B2               2195      BRA MAIN_LOOP
00000B92                          2196  
00000B92                          2197  L
00000B92  7000                    2198      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000B94  7200                    2199      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B96                          2200  
00000B96                          2201      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B96  343C 0000               2202s     MOVE.W  #0,D2
00000B9A  6000 0046               2203s     BRA _2000000B
00000B9E                          2204s _2000000A
00000B9E  E989                    2205          LSL.L #4,D1                                 ; make what we have so far more significant
00000BA0                          2206m         WAIT_CHAR D3,D4                             ; next character -> D2
00000BA0                          2207m WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA0                 TRUE     2208m     IFEQ DEBUG
00000BA0  1839 00C00003           2209m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000BA6  0804 0000               2210m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000BAA  67F4                    2211m         BEQ WAIT_FOR_READY_134                      ; NOTHING, CHECK AGAIN
00000BAC                          2212m     ENDC
00000BAC                          2213m 
00000BAC                          2214mm     READ_CHAR D3
00000BAC                 TRUE     2215mm     IFEQ DEBUG
00000BAC  1639 00C00007           2216mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000BB2                          2217mm     ENDC
00000BB2                 FALSE    2218mm     IFNE DEBUG
00000BB2                          2219mm     ENDC
00000BB2                          2220mm 
00000BB2  B63C 001B               2221mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000BB6  6700 F450               2222mm     BEQ START
00000BBA                          2223mm     ENDM
00000BBA                          2224m 
00000BBA                 TRUE     2225m     IFEQ DEBUG
00000BBA                          2226mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000BBA                          2227mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BBA                 TRUE     2228mm     IFEQ DEBUG
00000BBA  1839 00C00003           2229mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000BC0  0804 0002               2230mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000BC4  67F4                    2231mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000BC6  13C3 00C00007           2232mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BCC                          2233mm     ENDC
00000BCC                          2234mm 
00000BCC                 FALSE    2235mm     IFNE DEBUG
00000BCC                          2236mm     ENDC
00000BCC                          2237mm 
00000BCC                          2238mm     ENDM
00000BCC                          2239m     ENDC
00000BCC                          2240m     ENDM
00000BCC                          2241m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000BCC  41FA 116C               2242m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000BD0  0403 0030               2243m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BD4  C6BC 000000FF           2244m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000BDA  1630 3000               2245m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BDE                          2246m     ENDM
00000BDE  8203                    2247          OR.B D3,D1
00000BE0                          2248      ENDF
00000BE0  5242                    2249s     ADD.W   #1,D2
00000BE2                          2250s _2000000B
00000BE2  B47C 0007               2251s     CMP.W   #7,D2
00000BE6  6FB6                    2252s     BLE _2000000A
00000BE8                          2253  
00000BE8  3001                    2254      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000BEA  5180                    2255      SUB.L #START,D0                                 ; remove the vector table from the length
00000BEC  E089                    2256      LSR.L #8,D1                                     ; extract the MSword for the address
00000BEE  E089                    2257      LSR.L #8,D1
00000BF0                          2258  
00000BF0                          2259m     PRINT_CRLF D2,A1
00000BF0  43FA 1173               2260m     LEA CRLF(PC),A1
00000BF4                          2261mm     PRINT_STR A1,D2
00000BF4                          2262mm LOOP_139
00000BF4  0C11 0000               2263mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BF8  6700 0016               2264mm     BEQ EXIT_139
00000BFC                          2265mmm     PRINT_CHAR (A1)+,D2
00000BFC                          2266mmm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BFC                 TRUE     2267mmm     IFEQ DEBUG
00000BFC  1439 00C00003           2268mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C02  0802 0002               2269mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C06  67F4                    2270mmm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000C08  13D9 00C00007           2271mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C0E                          2272mmm     ENDC
00000C0E                          2273mmm 
00000C0E                 FALSE    2274mmm     IFNE DEBUG
00000C0E                          2275mmm     ENDC
00000C0E                          2276mmm 
00000C0E                          2277mmm     ENDM
00000C0E  60E4                    2278mm     BRA LOOP_139
00000C10                          2279mm EXIT_139
00000C10                          2280mm     ENDM
00000C10                          2281m     ENDM
00000C10                          2282  
00000C10  2041                    2283      MOVE.L D1,A0                                    ; target address
00000C12  2641                    2284      MOVE.L D1,A3                                    ; keep a copy for later
00000C14                          2285  
00000C14  2247                    2286      MOVE.L D7,A1                                    ; address accumulator -> address register
00000C16  5089                    2287      ADD.L #START,A1                                 ; skip the vectors
00000C18  2847                    2288      MOVE.L D7,A4                                    ; keep a clean copy for later
00000C1A  7E00                    2289      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000C1C                          2290  
00000C1C                          2291m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000C1C  31FC AAAA 2AAA          2292m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000C22  4E71                    2293m     NOP
00000C24  31FC 5555 1554          2294m     MOVE.W #$5555,$1554
00000C2A  4E71                    2295m     NOP
00000C2C  31FC 8080 2AAA          2296m     MOVE.W #$8080,$2AAA
00000C32  4E71                    2297m     NOP
00000C34  31FC AAAA 2AAA          2298m     MOVE.W #$AAAA,$2AAA
00000C3A  4E71                    2299m     NOP
00000C3C  31FC 5555 1554          2300m     MOVE.W #$5555,$1554
00000C42  4E71                    2301m     NOP
00000C44  31FC 2020 2AAA          2302m     MOVE.W #$2020,$2AAA
00000C4A                          2303m     ENDM
00000C4A                          2304                      
00000C4A                          2305      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000C4A  3E3C 0000               2306s     MOVE.W  #$0,D7
00000C4E  6000 0006               2307s     BRA _2000000D
00000C52                          2308s _2000000C
00000C52  4E71                    2309          NOP
00000C54                          2310      ENDF
00000C54  5247                    2311s     ADD.W   #1,D7
00000C56                          2312s _2000000D
00000C56  BE7C FFFF               2313s     CMP.W   #$FFFFFFFF,D7
00000C5A  6FF6                    2314s     BLE _2000000C
00000C5C                          2315                  
00000C5C  45FA 10F3               2316      LEA LOADING(PC),A2
00000C60                          2317m     PRINT_STR A2,D2
00000C60                          2318m LOOP_142
00000C60  0C12 0000               2319m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C64  6700 0016               2320m     BEQ EXIT_142
00000C68                          2321mm     PRINT_CHAR (A2)+,D2
00000C68                          2322mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C68                 TRUE     2323mm     IFEQ DEBUG
00000C68  1439 00C00003           2324mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C6E  0802 0002               2325mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C72  67F4                    2326mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000C74  13DA 00C00007           2327mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C7A                          2328mm     ENDC
00000C7A                          2329mm 
00000C7A                 FALSE    2330mm     IFNE DEBUG
00000C7A                          2331mm     ENDC
00000C7A                          2332mm 
00000C7A                          2333mm     ENDM
00000C7A  60E4                    2334m     BRA LOOP_142
00000C7C                          2335m EXIT_142
00000C7C                          2336m     ENDM
00000C7C  45FA 10D3               2337      LEA LOADING(PC),A2
00000C80                          2338m     PRINT_STR A2,D2
00000C80                          2339m LOOP_144
00000C80  0C12 0000               2340m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C84  6700 0016               2341m     BEQ EXIT_144
00000C88                          2342mm     PRINT_CHAR (A2)+,D2
00000C88                          2343mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C88                 TRUE     2344mm     IFEQ DEBUG
00000C88  1439 00C00003           2345mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000C8E  0802 0002               2346mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000C92  67F4                    2347mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000C94  13DA 00C00007           2348mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C9A                          2349mm     ENDC
00000C9A                          2350mm 
00000C9A                 FALSE    2351mm     IFNE DEBUG
00000C9A                          2352mm     ENDC
00000C9A                          2353mm 
00000C9A                          2354mm     ENDM
00000C9A  60E4                    2355m     BRA LOOP_144
00000C9C                          2356m EXIT_144
00000C9C                          2357m     ENDM
00000C9C  45FA 10B3               2358      LEA LOADING(PC),A2
00000CA0                          2359m     PRINT_STR A2,D2
00000CA0                          2360m LOOP_146
00000CA0  0C12 0000               2361m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CA4  6700 0016               2362m     BEQ EXIT_146
00000CA8                          2363mm     PRINT_CHAR (A2)+,D2
00000CA8                          2364mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA8                 TRUE     2365mm     IFEQ DEBUG
00000CA8  1439 00C00003           2366mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CAE  0802 0002               2367mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CB2  67F4                    2368mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000CB4  13DA 00C00007           2369mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CBA                          2370mm     ENDC
00000CBA                          2371mm 
00000CBA                 FALSE    2372mm     IFNE DEBUG
00000CBA                          2373mm     ENDC
00000CBA                          2374mm 
00000CBA                          2375mm     ENDM
00000CBA  60E4                    2376m     BRA LOOP_146
00000CBC                          2377m EXIT_146
00000CBC                          2378m     ENDM
00000CBC  45FA 1093               2379      LEA LOADING(PC),A2
00000CC0                          2380m     PRINT_STR A2,D2
00000CC0                          2381m LOOP_148
00000CC0  0C12 0000               2382m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CC4  6700 0016               2383m     BEQ EXIT_148
00000CC8                          2384mm     PRINT_CHAR (A2)+,D2
00000CC8                          2385mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CC8                 TRUE     2386mm     IFEQ DEBUG
00000CC8  1439 00C00003           2387mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CCE  0802 0002               2388mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CD2  67F4                    2389mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000CD4  13DA 00C00007           2390mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CDA                          2391mm     ENDC
00000CDA                          2392mm 
00000CDA                 FALSE    2393mm     IFNE DEBUG
00000CDA                          2394mm     ENDC
00000CDA                          2395mm 
00000CDA                          2396mm     ENDM
00000CDA  60E4                    2397m     BRA LOOP_148
00000CDC                          2398m EXIT_148
00000CDC                          2399m     ENDM
00000CDC                          2400          
00000CDC  2409                    2401      MOVE.L A1,D2
00000CDE                          2402m     PRINT_REG D2,D3,D4,D5,A2
00000CDE  45FA 108B               2403m     LEA OX(PC),A2
00000CE2                          2404mm     PRINT_STR A2,D3
00000CE2                          2405mm LOOP_151
00000CE2  0C12 0000               2406mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CE6  6700 0016               2407mm     BEQ EXIT_151
00000CEA                          2408mmm     PRINT_CHAR (A2)+,D3
00000CEA                          2409mmm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CEA                 TRUE     2410mmm     IFEQ DEBUG
00000CEA  1639 00C00003           2411mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CF0  0803 0002               2412mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CF4  67F4                    2413mmm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000CF6  13DA 00C00007           2414mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CFC                          2415mmm     ENDC
00000CFC                          2416mmm 
00000CFC                 FALSE    2417mmm     IFNE DEBUG
00000CFC                          2418mmm     ENDC
00000CFC                          2419mmm 
00000CFC                          2420mmm     ENDM
00000CFC  60E4                    2421mm     BRA LOOP_151
00000CFE                          2422mm EXIT_151
00000CFE                          2423mm     ENDM
00000CFE  7A07                    2424m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D00                          2425m LOOP_150
00000D00                          2426mm     BIN2HEX D2,D4,A2
00000D00  45FA 1028               2427mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D04  E99A                    2428mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D06  1802                    2429mm     MOVE.B D2,D4
00000D08  0284 0000000F           2430mm     ANDI.L #$F,D4
00000D0E  1832 4000               2431mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D12                          2432mm     ENDM
00000D12                          2433mm     PRINT_CHAR D4,D3
00000D12                          2434mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D12                 TRUE     2435mm     IFEQ DEBUG
00000D12  1639 00C00003           2436mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D18  0803 0002               2437mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D1C  67F4                    2438mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000D1E  13C4 00C00007           2439mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D24                          2440mm     ENDC
00000D24                          2441mm 
00000D24                 FALSE    2442mm     IFNE DEBUG
00000D24                          2443mm     ENDC
00000D24                          2444mm 
00000D24                          2445mm     ENDM
00000D24  57CD FFDA               2446m     DBEQ D5,LOOP_150
00000D28                          2447m     ENDM
00000D28                          2448  
00000D28  45FA 1044               2449      LEA TO(PC),A2
00000D2C                          2450m     PRINT_STR A2,D3
00000D2C                          2451m LOOP_155
00000D2C  0C12 0000               2452m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D30  6700 0016               2453m     BEQ EXIT_155
00000D34                          2454mm     PRINT_CHAR (A2)+,D3
00000D34                          2455mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D34                 TRUE     2456mm     IFEQ DEBUG
00000D34  1639 00C00003           2457mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D3A  0803 0002               2458mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D3E  67F4                    2459mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000D40  13DA 00C00007           2460mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D46                          2461mm     ENDC
00000D46                          2462mm 
00000D46                 FALSE    2463mm     IFNE DEBUG
00000D46                          2464mm     ENDC
00000D46                          2465mm 
00000D46                          2466mm     ENDM
00000D46  60E4                    2467m     BRA LOOP_155
00000D48                          2468m EXIT_155
00000D48                          2469m     ENDM
00000D48                          2470  
00000D48  2408                    2471      MOVE.L A0,D2
00000D4A                          2472m     PRINT_REG D2,D3,D4,D5,A2
00000D4A  45FA 101F               2473m     LEA OX(PC),A2
00000D4E                          2474mm     PRINT_STR A2,D3
00000D4E                          2475mm LOOP_158
00000D4E  0C12 0000               2476mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D52  6700 0016               2477mm     BEQ EXIT_158
00000D56                          2478mmm     PRINT_CHAR (A2)+,D3
00000D56                          2479mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D56                 TRUE     2480mmm     IFEQ DEBUG
00000D56  1639 00C00003           2481mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D5C  0803 0002               2482mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D60  67F4                    2483mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000D62  13DA 00C00007           2484mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D68                          2485mmm     ENDC
00000D68                          2486mmm 
00000D68                 FALSE    2487mmm     IFNE DEBUG
00000D68                          2488mmm     ENDC
00000D68                          2489mmm 
00000D68                          2490mmm     ENDM
00000D68  60E4                    2491mm     BRA LOOP_158
00000D6A                          2492mm EXIT_158
00000D6A                          2493mm     ENDM
00000D6A  7A07                    2494m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D6C                          2495m LOOP_157
00000D6C                          2496mm     BIN2HEX D2,D4,A2
00000D6C  45FA 0FBC               2497mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D70  E99A                    2498mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D72  1802                    2499mm     MOVE.B D2,D4
00000D74  0284 0000000F           2500mm     ANDI.L #$F,D4
00000D7A  1832 4000               2501mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000D7E                          2502mm     ENDM
00000D7E                          2503mm     PRINT_CHAR D4,D3
00000D7E                          2504mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7E                 TRUE     2505mm     IFEQ DEBUG
00000D7E  1639 00C00003           2506mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D84  0803 0002               2507mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D88  67F4                    2508mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D8A  13C4 00C00007           2509mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D90                          2510mm     ENDC
00000D90                          2511mm 
00000D90                 FALSE    2512mm     IFNE DEBUG
00000D90                          2513mm     ENDC
00000D90                          2514mm 
00000D90                          2515mm     ENDM
00000D90  57CD FFDA               2516m     DBEQ D5,LOOP_157
00000D94                          2517m     ENDM
00000D94                          2518  
00000D94  45FA 0FDD               2519      LEA FOR(PC),A2
00000D98                          2520m     PRINT_STR A2,D3
00000D98                          2521m LOOP_162
00000D98  0C12 0000               2522m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D9C  6700 0016               2523m     BEQ EXIT_162
00000DA0                          2524mm     PRINT_CHAR (A2)+,D3
00000DA0                          2525mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA0                 TRUE     2526mm     IFEQ DEBUG
00000DA0  1639 00C00003           2527mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DA6  0803 0002               2528mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DAA  67F4                    2529mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000DAC  13DA 00C00007           2530mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DB2                          2531mm     ENDC
00000DB2                          2532mm 
00000DB2                 FALSE    2533mm     IFNE DEBUG
00000DB2                          2534mm     ENDC
00000DB2                          2535mm 
00000DB2                          2536mm     ENDM
00000DB2  60E4                    2537m     BRA LOOP_162
00000DB4                          2538m EXIT_162
00000DB4                          2539m     ENDM
00000DB4                          2540m     PRINT_REG D0,D3,D4,D5,A2
00000DB4  45FA 0FB5               2541m     LEA OX(PC),A2
00000DB8                          2542mm     PRINT_STR A2,D3
00000DB8                          2543mm LOOP_165
00000DB8  0C12 0000               2544mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DBC  6700 0016               2545mm     BEQ EXIT_165
00000DC0                          2546mmm     PRINT_CHAR (A2)+,D3
00000DC0                          2547mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC0                 TRUE     2548mmm     IFEQ DEBUG
00000DC0  1639 00C00003           2549mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DC6  0803 0002               2550mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DCA  67F4                    2551mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000DCC  13DA 00C00007           2552mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DD2                          2553mmm     ENDC
00000DD2                          2554mmm 
00000DD2                 FALSE    2555mmm     IFNE DEBUG
00000DD2                          2556mmm     ENDC
00000DD2                          2557mmm 
00000DD2                          2558mmm     ENDM
00000DD2  60E4                    2559mm     BRA LOOP_165
00000DD4                          2560mm EXIT_165
00000DD4                          2561mm     ENDM
00000DD4  7A07                    2562m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DD6                          2563m LOOP_164
00000DD6                          2564mm     BIN2HEX D0,D4,A2
00000DD6  45FA 0F52               2565mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000DDA  E998                    2566mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DDC  1800                    2567mm     MOVE.B D0,D4
00000DDE  0284 0000000F           2568mm     ANDI.L #$F,D4
00000DE4  1832 4000               2569mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000DE8                          2570mm     ENDM
00000DE8                          2571mm     PRINT_CHAR D4,D3
00000DE8                          2572mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DE8                 TRUE     2573mm     IFEQ DEBUG
00000DE8  1639 00C00003           2574mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DEE  0803 0002               2575mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DF2  67F4                    2576mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000DF4  13C4 00C00007           2577mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DFA                          2578mm     ENDC
00000DFA                          2579mm 
00000DFA                 FALSE    2580mm     IFNE DEBUG
00000DFA                          2581mm     ENDC
00000DFA                          2582mm 
00000DFA                          2583mm     ENDM
00000DFA  57CD FFDA               2584m     DBEQ D5,LOOP_164
00000DFE                          2585m     ENDM
00000DFE                          2586  
00000DFE                          2587m     PRINT_CRLF D3,A2
00000DFE  45FA 0F65               2588m     LEA CRLF(PC),A2
00000E02                          2589mm     PRINT_STR A2,D3
00000E02                          2590mm LOOP_170
00000E02  0C12 0000               2591mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E06  6700 0016               2592mm     BEQ EXIT_170
00000E0A                          2593mmm     PRINT_CHAR (A2)+,D3
00000E0A                          2594mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E0A                 TRUE     2595mmm     IFEQ DEBUG
00000E0A  1639 00C00003           2596mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E10  0803 0002               2597mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E14  67F4                    2598mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000E16  13DA 00C00007           2599mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E1C                          2600mmm     ENDC
00000E1C                          2601mmm 
00000E1C                 FALSE    2602mmm     IFNE DEBUG
00000E1C                          2603mmm     ENDC
00000E1C                          2604mmm 
00000E1C                          2605mmm     ENDM
00000E1C  60E4                    2606mm     BRA LOOP_170
00000E1E                          2607mm EXIT_170
00000E1E                          2608mm     ENDM
00000E1E                          2609m     ENDM
00000E1E                          2610  
00000E1E                          2611      WHILE D0 <GT> #0 DO
00000E1E                          2612s _10000014
00000E1E  B07C 0000               2613s     CMP.W   #0,D0
00000E22  6F00 0022               2614s     BLE _10000015
00000E26  5580                    2615          SUB.L #2,D0
00000E28                          2616  
00000E28  2408                    2617          MOVE.L A0,D2
00000E2A  0202 0007               2618          ANDI.B #$7,D2
00000E2E  13C2 00E00001           2619          MOVE.B D2,DISPLAY
00000E34                          2620m         PROGRAM (A1),(A0),D2
00000E34  3091                    2621m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000E36                          2622m 
00000E36                          2623m WAIT_FOR_COMPLETE_172
00000E36  3410                    2624m         MOVE.W (A0),D2
00000E38                          2625m 
00000E38                          2626m         IF.W D2 <NE> (A1) THEN
00000E38  B451                    2627ms     CMP.W   (A1),D2
00000E3A  6700 0004               2628ms     BEQ _0000000E
00000E3E  60F6                    2629m             BRA WAIT_FOR_COMPLETE_172
00000E40                          2630m         ENDI
00000E40                          2631ms _0000000E
00000E40                          2632m         ENDM
00000E40                          2633                  
00000E40  5488                    2634          ADD.L #2,A0
00000E42  5489                    2635          ADD.L #2,A1
00000E44                          2636      ENDW
00000E44  60D8                    2637s     BRA _10000014
00000E46                          2638s _10000015
00000E46                          2639      
00000E46  41F8 0000               2640      LEA STACK,A0
00000E4A  D1CC                    2641      ADD.L A4,A0
00000E4C  2010                    2642      MOVE.L (A0),D0
00000E4E  207C 00000000           2643      MOVE.L #0,A0
00000E54                          2644m     PROGRAM_VECTOR D0,A0,D2
00000E54  5488                    2645m     ADD.L #2,A0
00000E56                          2646mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000E56  3080                    2647mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000E58                          2648mm 
00000E58                          2649mm WAIT_FOR_COMPLETE_174
00000E58  3410                    2650mm         MOVE.W (A0),D2
00000E5A                          2651mm 
00000E5A                          2652mm         IF.W D2 <NE> D0 THEN
00000E5A  B440                    2653mms     CMP.W   D0,D2
00000E5C  6700 0004               2654mms     BEQ _0000000F
00000E60  60F6                    2655mm             BRA WAIT_FOR_COMPLETE_174
00000E62                          2656mm         ENDI
00000E62                          2657mms _0000000F
00000E62                          2658mm         ENDM
00000E62  E088                    2659m     LSR.L #8,D0
00000E64  E088                    2660m     LSR.L #8,D0
00000E66  5588                    2661m     SUB.L #2,A0
00000E68                          2662mm     PROGRAM D0, (A0), D2
00000E68  3080                    2663mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000E6A                          2664mm 
00000E6A                          2665mm WAIT_FOR_COMPLETE_175
00000E6A  3410                    2666mm         MOVE.W (A0),D2
00000E6C                          2667mm 
00000E6C                          2668mm         IF.W D2 <NE> D0 THEN
00000E6C  B440                    2669mms     CMP.W   D0,D2
00000E6E  6700 0004               2670mms     BEQ _00000010
00000E72  60F6                    2671mm             BRA WAIT_FOR_COMPLETE_175
00000E74                          2672mm         ENDI
00000E74                          2673mms _00000010
00000E74                          2674mm         ENDM
00000E74                          2675m     ENDM
00000E74                          2676  
00000E74  41F8 0004               2677      LEA RESET,A0
00000E78  D1CC                    2678      ADD.L A4,A0
00000E7A  2010                    2679      MOVE.L (A0),D0
00000E7C  D081                    2680      ADD.L D1,D0
00000E7E  5180                    2681      SUB.L #START,D0
00000E80  207C 00000004           2682      MOVE.L #4,A0
00000E86                          2683m     PROGRAM_VECTOR D0,A0,D2
00000E86  5488                    2684m     ADD.L #2,A0
00000E88                          2685mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000E88  3080                    2686mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000E8A                          2687mm 
00000E8A                          2688mm WAIT_FOR_COMPLETE_177
00000E8A  3410                    2689mm         MOVE.W (A0),D2
00000E8C                          2690mm 
00000E8C                          2691mm         IF.W D2 <NE> D0 THEN
00000E8C  B440                    2692mms     CMP.W   D0,D2
00000E8E  6700 0004               2693mms     BEQ _00000011
00000E92  60F6                    2694mm             BRA WAIT_FOR_COMPLETE_177
00000E94                          2695mm         ENDI
00000E94                          2696mms _00000011
00000E94                          2697mm         ENDM
00000E94  E088                    2698m     LSR.L #8,D0
00000E96  E088                    2699m     LSR.L #8,D0
00000E98  5588                    2700m     SUB.L #2,A0
00000E9A                          2701mm     PROGRAM D0, (A0), D2
00000E9A  3080                    2702mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000E9C                          2703mm 
00000E9C                          2704mm WAIT_FOR_COMPLETE_178
00000E9C  3410                    2705mm         MOVE.W (A0),D2
00000E9E                          2706mm 
00000E9E                          2707mm         IF.W D2 <NE> D0 THEN
00000E9E  B440                    2708mms     CMP.W   D0,D2
00000EA0  6700 0004               2709mms     BEQ _00000012
00000EA4  60F6                    2710mm             BRA WAIT_FOR_COMPLETE_178
00000EA6                          2711mm         ENDI
00000EA6                          2712mms _00000012
00000EA6                          2713mm         ENDM
00000EA6                          2714m     ENDM
00000EA6                          2715  
00000EA6                          2716m     PROTECT
00000EA6  31FC AAAA 2AAA          2717m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000EAC  31FC 5555 1554          2718m     MOVE.W #$5555,$1554
00000EB2  31FC A0A0 2AAA          2719m     MOVE.W #$A0A0,$2AAA
00000EB8                          2720m     ENDM
00000EB8                          2721  
00000EB8  6000 F388               2722      BRA MAIN_LOOP
00000EBC                          2723      
00000EBC                          2724  P
00000EBC  7000                    2725      MOVE.L #0,D0                                    ; D0 will be the data to write
00000EBE                          2726  
00000EBE                          2727      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000EBE  323C 0000               2728s     MOVE.W  #0,D1
00000EC2  6000 0046               2729s     BRA _2000000F
00000EC6                          2730s _2000000E
00000EC6  E988                    2731          LSL.L #4,D0                                 ; make what we have so far more significant
00000EC8                          2732m         WAIT_CHAR D2,D3                             ; next character -> D2
00000EC8                          2733m WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2734m     IFEQ DEBUG
00000EC8  1639 00C00003           2735m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ECE  0803 0000               2736m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000ED2  67F4                    2737m         BEQ WAIT_FOR_READY_180                      ; NOTHING, CHECK AGAIN
00000ED4                          2738m     ENDC
00000ED4                          2739m 
00000ED4                          2740mm     READ_CHAR D2
00000ED4                 TRUE     2741mm     IFEQ DEBUG
00000ED4  1439 00C00007           2742mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000EDA                          2743mm     ENDC
00000EDA                 FALSE    2744mm     IFNE DEBUG
00000EDA                          2745mm     ENDC
00000EDA                          2746mm 
00000EDA  B43C 001B               2747mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000EDE  6700 F128               2748mm     BEQ START
00000EE2                          2749mm     ENDM
00000EE2                          2750m 
00000EE2                 TRUE     2751m     IFEQ DEBUG
00000EE2                          2752mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000EE2                          2753mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EE2                 TRUE     2754mm     IFEQ DEBUG
00000EE2  1639 00C00003           2755mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EE8  0803 0002               2756mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EEC  67F4                    2757mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000EEE  13C2 00C00007           2758mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EF4                          2759mm     ENDC
00000EF4                          2760mm 
00000EF4                 FALSE    2761mm     IFNE DEBUG
00000EF4                          2762mm     ENDC
00000EF4                          2763mm 
00000EF4                          2764mm     ENDM
00000EF4                          2765m     ENDC
00000EF4                          2766m     ENDM
00000EF4                          2767m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000EF4  41FA 0E44               2768m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000EF8  0402 0030               2769m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000EFC  C4BC 000000FF           2770m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000F02  1430 2000               2771m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000F06                          2772m     ENDM
00000F06  8002                    2773          OR.B D2,D0
00000F08                          2774      ENDF
00000F08  5241                    2775s     ADD.W   #1,D1
00000F0A                          2776s _2000000F
00000F0A  B27C 0003               2777s     CMP.W   #3,D1
00000F0E  6FB6                    2778s     BLE _2000000E
00000F10                          2779  
00000F10                          2780m     PRINT_CRLF D2,A1
00000F10  43FA 0E53               2781m     LEA CRLF(PC),A1
00000F14                          2782mm     PRINT_STR A1,D2
00000F14                          2783mm LOOP_185
00000F14  0C11 0000               2784mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F18  6700 0016               2785mm     BEQ EXIT_185
00000F1C                          2786mmm     PRINT_CHAR (A1)+,D2
00000F1C                          2787mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F1C                 TRUE     2788mmm     IFEQ DEBUG
00000F1C  1439 00C00003           2789mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F22  0802 0002               2790mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F26  67F4                    2791mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00000F28  13D9 00C00007           2792mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F2E                          2793mmm     ENDC
00000F2E                          2794mmm 
00000F2E                 FALSE    2795mmm     IFNE DEBUG
00000F2E                          2796mmm     ENDC
00000F2E                          2797mmm 
00000F2E                          2798mmm     ENDM
00000F2E  60E4                    2799mm     BRA LOOP_185
00000F30                          2800mm EXIT_185
00000F30                          2801mm     ENDM
00000F30                          2802m     ENDM
00000F30                          2803  
00000F30  2047                    2804      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000F32  7E00                    2805      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000F34                          2806  
00000F34                          2807m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000F34  31FC AAAA 2AAA          2808m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000F3A  4E71                    2809m     NOP
00000F3C  31FC 5555 1554          2810m     MOVE.W #$5555,$1554
00000F42  4E71                    2811m     NOP
00000F44  31FC 8080 2AAA          2812m     MOVE.W #$8080,$2AAA
00000F4A  4E71                    2813m     NOP
00000F4C  31FC AAAA 2AAA          2814m     MOVE.W #$AAAA,$2AAA
00000F52  4E71                    2815m     NOP
00000F54  31FC 5555 1554          2816m     MOVE.W #$5555,$1554
00000F5A  4E71                    2817m     NOP
00000F5C  31FC 2020 2AAA          2818m     MOVE.W #$2020,$2AAA
00000F62                          2819m     ENDM
00000F62                          2820                              
00000F62                          2821      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000F62  3E3C 0000               2822s     MOVE.W  #$0,D7
00000F66  6000 0006               2823s     BRA _20000011
00000F6A                          2824s _20000010
00000F6A  4E71                    2825          NOP
00000F6C                          2826      ENDF
00000F6C  5247                    2827s     ADD.W   #1,D7
00000F6E                          2828s _20000011
00000F6E  BE7C FFFF               2829s     CMP.W   #$FFFFFFFF,D7
00000F72  6FF6                    2830s     BLE _20000010
00000F74                          2831               
00000F74  45FA 0DDB               2832      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000F78                          2833m     PRINT_STR A2,D2
00000F78                          2834m LOOP_188
00000F78  0C12 0000               2835m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F7C  6700 0016               2836m     BEQ EXIT_188
00000F80                          2837mm     PRINT_CHAR (A2)+,D2
00000F80                          2838mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F80                 TRUE     2839mm     IFEQ DEBUG
00000F80  1439 00C00003           2840mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F86  0802 0002               2841mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F8A  67F4                    2842mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
00000F8C  13DA 00C00007           2843mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F92                          2844mm     ENDC
00000F92                          2845mm 
00000F92                 FALSE    2846mm     IFNE DEBUG
00000F92                          2847mm     ENDC
00000F92                          2848mm 
00000F92                          2849mm     ENDM
00000F92  60E4                    2850m     BRA LOOP_188
00000F94                          2851m EXIT_188
00000F94                          2852m     ENDM
00000F94                          2853  
00000F94                          2854m     PRINT_REG D0,D3,D4,D5,A2
00000F94  45FA 0DD5               2855m     LEA OX(PC),A2
00000F98                          2856mm     PRINT_STR A2,D3
00000F98                          2857mm LOOP_191
00000F98  0C12 0000               2858mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F9C  6700 0016               2859mm     BEQ EXIT_191
00000FA0                          2860mmm     PRINT_CHAR (A2)+,D3
00000FA0                          2861mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FA0                 TRUE     2862mmm     IFEQ DEBUG
00000FA0  1639 00C00003           2863mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FA6  0803 0002               2864mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FAA  67F4                    2865mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00000FAC  13DA 00C00007           2866mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FB2                          2867mmm     ENDC
00000FB2                          2868mmm 
00000FB2                 FALSE    2869mmm     IFNE DEBUG
00000FB2                          2870mmm     ENDC
00000FB2                          2871mmm 
00000FB2                          2872mmm     ENDM
00000FB2  60E4                    2873mm     BRA LOOP_191
00000FB4                          2874mm EXIT_191
00000FB4                          2875mm     ENDM
00000FB4  7A07                    2876m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FB6                          2877m LOOP_190
00000FB6                          2878mm     BIN2HEX D0,D4,A2
00000FB6  45FA 0D72               2879mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FBA  E998                    2880mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FBC  1800                    2881mm     MOVE.B D0,D4
00000FBE  0284 0000000F           2882mm     ANDI.L #$F,D4
00000FC4  1832 4000               2883mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FC8                          2884mm     ENDM
00000FC8                          2885mm     PRINT_CHAR D4,D3
00000FC8                          2886mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC8                 TRUE     2887mm     IFEQ DEBUG
00000FC8  1639 00C00003           2888mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FCE  0803 0002               2889mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FD2  67F4                    2890mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00000FD4  13C4 00C00007           2891mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FDA                          2892mm     ENDC
00000FDA                          2893mm 
00000FDA                 FALSE    2894mm     IFNE DEBUG
00000FDA                          2895mm     ENDC
00000FDA                          2896mm 
00000FDA                          2897mm     ENDM
00000FDA  57CD FFDA               2898m     DBEQ D5,LOOP_190
00000FDE                          2899m     ENDM
00000FDE                          2900  
00000FDE  45FA 0D8E               2901      LEA TO(PC),A2
00000FE2                          2902m     PRINT_STR A2,D3
00000FE2                          2903m LOOP_195
00000FE2  0C12 0000               2904m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FE6  6700 0016               2905m     BEQ EXIT_195
00000FEA                          2906mm     PRINT_CHAR (A2)+,D3
00000FEA                          2907mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FEA                 TRUE     2908mm     IFEQ DEBUG
00000FEA  1639 00C00003           2909mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FF0  0803 0002               2910mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FF4  67F4                    2911mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00000FF6  13DA 00C00007           2912mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FFC                          2913mm     ENDC
00000FFC                          2914mm 
00000FFC                 FALSE    2915mm     IFNE DEBUG
00000FFC                          2916mm     ENDC
00000FFC                          2917mm 
00000FFC                          2918mm     ENDM
00000FFC  60E4                    2919m     BRA LOOP_195
00000FFE                          2920m EXIT_195
00000FFE                          2921m     ENDM
00000FFE                          2922  
00000FFE  2408                    2923      MOVE.L A0,D2
00001000                          2924m     PRINT_REG D2,D3,D4,D5,A2
00001000  45FA 0D69               2925m     LEA OX(PC),A2
00001004                          2926mm     PRINT_STR A2,D3
00001004                          2927mm LOOP_198
00001004  0C12 0000               2928mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001008  6700 0016               2929mm     BEQ EXIT_198
0000100C                          2930mmm     PRINT_CHAR (A2)+,D3
0000100C                          2931mmm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000100C                 TRUE     2932mmm     IFEQ DEBUG
0000100C  1639 00C00003           2933mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001012  0803 0002               2934mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001016  67F4                    2935mmm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001018  13DA 00C00007           2936mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000101E                          2937mmm     ENDC
0000101E                          2938mmm 
0000101E                 FALSE    2939mmm     IFNE DEBUG
0000101E                          2940mmm     ENDC
0000101E                          2941mmm 
0000101E                          2942mmm     ENDM
0000101E  60E4                    2943mm     BRA LOOP_198
00001020                          2944mm EXIT_198
00001020                          2945mm     ENDM
00001020  7A07                    2946m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001022                          2947m LOOP_197
00001022                          2948mm     BIN2HEX D2,D4,A2
00001022  45FA 0D06               2949mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001026  E99A                    2950mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001028  1802                    2951mm     MOVE.B D2,D4
0000102A  0284 0000000F           2952mm     ANDI.L #$F,D4
00001030  1832 4000               2953mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001034                          2954mm     ENDM
00001034                          2955mm     PRINT_CHAR D4,D3
00001034                          2956mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001034                 TRUE     2957mm     IFEQ DEBUG
00001034  1639 00C00003           2958mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000103A  0803 0002               2959mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000103E  67F4                    2960mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
00001040  13C4 00C00007           2961mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001046                          2962mm     ENDC
00001046                          2963mm 
00001046                 FALSE    2964mm     IFNE DEBUG
00001046                          2965mm     ENDC
00001046                          2966mm 
00001046                          2967mm     ENDM
00001046  57CD FFDA               2968m     DBEQ D5,LOOP_197
0000104A                          2969m     ENDM
0000104A                          2970  
0000104A                          2971m     PRINT_CRLF D3,A2
0000104A  45FA 0D19               2972m     LEA CRLF(PC),A2
0000104E                          2973mm     PRINT_STR A2,D3
0000104E                          2974mm LOOP_203
0000104E  0C12 0000               2975mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001052  6700 0016               2976mm     BEQ EXIT_203
00001056                          2977mmm     PRINT_CHAR (A2)+,D3
00001056                          2978mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001056                 TRUE     2979mmm     IFEQ DEBUG
00001056  1639 00C00003           2980mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000105C  0803 0002               2981mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001060  67F4                    2982mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001062  13DA 00C00007           2983mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001068                          2984mmm     ENDC
00001068                          2985mmm 
00001068                 FALSE    2986mmm     IFNE DEBUG
00001068                          2987mmm     ENDC
00001068                          2988mmm 
00001068                          2989mmm     ENDM
00001068  60E4                    2990mm     BRA LOOP_203
0000106A                          2991mm EXIT_203
0000106A                          2992mm     ENDM
0000106A                          2993m     ENDM
0000106A                          2994  
0000106A                          2995m     PROGRAM D0,(A0),D2
0000106A  3080                    2996m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000106C                          2997m 
0000106C                          2998m WAIT_FOR_COMPLETE_205
0000106C  3410                    2999m         MOVE.W (A0),D2
0000106E                          3000m 
0000106E                          3001m         IF.W D2 <NE> D0 THEN
0000106E  B440                    3002ms     CMP.W   D0,D2
00001070  6700 0004               3003ms     BEQ _00000013
00001074  60F6                    3004m             BRA WAIT_FOR_COMPLETE_205
00001076                          3005m         ENDI
00001076                          3006ms _00000013
00001076                          3007m         ENDM
00001076                          3008  
00001076                          3009m     PROTECT
00001076  31FC AAAA 2AAA          3010m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000107C  31FC 5555 1554          3011m     MOVE.W #$5555,$1554
00001082  31FC A0A0 2AAA          3012m     MOVE.W #$A0A0,$2AAA
00001088                          3013m     ENDM
00001088                          3014      
00001088  6000 F1B8               3015      BRA MAIN_LOOP
0000108C                          3016      
0000108C                          3017  X
0000108C  45FA 0CF0               3018      LEA STATUS_REGISTER(PC),A2
00001090                          3019m     PRINT_STR A2,D3
00001090                          3020m LOOP_207
00001090  0C12 0000               3021m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001094  6700 0016               3022m     BEQ EXIT_207
00001098                          3023mm     PRINT_CHAR (A2)+,D3
00001098                          3024mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001098                 TRUE     3025mm     IFEQ DEBUG
00001098  1639 00C00003           3026mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000109E  0803 0002               3027mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010A2  67F4                    3028mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
000010A4  13DA 00C00007           3029mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010AA                          3030mm     ENDC
000010AA                          3031mm 
000010AA                 FALSE    3032mm     IFNE DEBUG
000010AA                          3033mm     ENDC
000010AA                          3034mm 
000010AA                          3035mm     ENDM
000010AA  60E4                    3036m     BRA LOOP_207
000010AC                          3037m EXIT_207
000010AC                          3038m     ENDM
000010AC                          3039  
000010AC  40C0                    3040      MOVE SR,D0
000010AE                          3041m     PRINT_REG D0,D3,D4,D5,A2
000010AE  45FA 0CBB               3042m     LEA OX(PC),A2
000010B2                          3043mm     PRINT_STR A2,D3
000010B2                          3044mm LOOP_210
000010B2  0C12 0000               3045mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010B6  6700 0016               3046mm     BEQ EXIT_210
000010BA                          3047mmm     PRINT_CHAR (A2)+,D3
000010BA                          3048mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010BA                 TRUE     3049mmm     IFEQ DEBUG
000010BA  1639 00C00003           3050mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010C0  0803 0002               3051mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010C4  67F4                    3052mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000010C6  13DA 00C00007           3053mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010CC                          3054mmm     ENDC
000010CC                          3055mmm 
000010CC                 FALSE    3056mmm     IFNE DEBUG
000010CC                          3057mmm     ENDC
000010CC                          3058mmm 
000010CC                          3059mmm     ENDM
000010CC  60E4                    3060mm     BRA LOOP_210
000010CE                          3061mm EXIT_210
000010CE                          3062mm     ENDM
000010CE  7A07                    3063m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010D0                          3064m LOOP_209
000010D0                          3065mm     BIN2HEX D0,D4,A2
000010D0  45FA 0C58               3066mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000010D4  E998                    3067mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010D6  1800                    3068mm     MOVE.B D0,D4
000010D8  0284 0000000F           3069mm     ANDI.L #$F,D4
000010DE  1832 4000               3070mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000010E2                          3071mm     ENDM
000010E2                          3072mm     PRINT_CHAR D4,D3
000010E2                          3073mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010E2                 TRUE     3074mm     IFEQ DEBUG
000010E2  1639 00C00003           3075mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010E8  0803 0002               3076mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010EC  67F4                    3077mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
000010EE  13C4 00C00007           3078mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010F4                          3079mm     ENDC
000010F4                          3080mm 
000010F4                 FALSE    3081mm     IFNE DEBUG
000010F4                          3082mm     ENDC
000010F4                          3083mm 
000010F4                          3084mm     ENDM
000010F4  57CD FFDA               3085m     DBEQ D5,LOOP_209
000010F8                          3086m     ENDM
000010F8                          3087m     PRINT_CRLF D3,A2
000010F8  45FA 0C6B               3088m     LEA CRLF(PC),A2
000010FC                          3089mm     PRINT_STR A2,D3
000010FC                          3090mm LOOP_215
000010FC  0C12 0000               3091mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001100  6700 0016               3092mm     BEQ EXIT_215
00001104                          3093mmm     PRINT_CHAR (A2)+,D3
00001104                          3094mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001104                 TRUE     3095mmm     IFEQ DEBUG
00001104  1639 00C00003           3096mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000110A  0803 0002               3097mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000110E  67F4                    3098mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001110  13DA 00C00007           3099mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001116                          3100mmm     ENDC
00001116                          3101mmm 
00001116                 FALSE    3102mmm     IFNE DEBUG
00001116                          3103mmm     ENDC
00001116                          3104mmm 
00001116                          3105mmm     ENDM
00001116  60E4                    3106mm     BRA LOOP_215
00001118                          3107mm EXIT_215
00001118                          3108mm     ENDM
00001118                          3109m     ENDM
00001118                          3110  
00001118  45FA 0C5F               3111      LEA STACK_POINTER(PC),A2
0000111C                          3112m     PRINT_STR A2,D3
0000111C                          3113m LOOP_217
0000111C  0C12 0000               3114m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001120  6700 0016               3115m     BEQ EXIT_217
00001124                          3116mm     PRINT_CHAR (A2)+,D3
00001124                          3117mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001124                 TRUE     3118mm     IFEQ DEBUG
00001124  1639 00C00003           3119mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000112A  0803 0002               3120mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000112E  67F4                    3121mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001130  13DA 00C00007           3122mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001136                          3123mm     ENDC
00001136                          3124mm 
00001136                 FALSE    3125mm     IFNE DEBUG
00001136                          3126mm     ENDC
00001136                          3127mm 
00001136                          3128mm     ENDM
00001136  60E4                    3129m     BRA LOOP_217
00001138                          3130m EXIT_217
00001138                          3131m     ENDM
00001138                          3132  
00001138  200F                    3133      MOVE.L SP,D0
0000113A                          3134m     PRINT_REG D0,D3,D4,D5,A2
0000113A  45FA 0C2F               3135m     LEA OX(PC),A2
0000113E                          3136mm     PRINT_STR A2,D3
0000113E                          3137mm LOOP_220
0000113E  0C12 0000               3138mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001142  6700 0016               3139mm     BEQ EXIT_220
00001146                          3140mmm     PRINT_CHAR (A2)+,D3
00001146                          3141mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001146                 TRUE     3142mmm     IFEQ DEBUG
00001146  1639 00C00003           3143mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000114C  0803 0002               3144mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001150  67F4                    3145mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001152  13DA 00C00007           3146mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001158                          3147mmm     ENDC
00001158                          3148mmm 
00001158                 FALSE    3149mmm     IFNE DEBUG
00001158                          3150mmm     ENDC
00001158                          3151mmm 
00001158                          3152mmm     ENDM
00001158  60E4                    3153mm     BRA LOOP_220
0000115A                          3154mm EXIT_220
0000115A                          3155mm     ENDM
0000115A  7A07                    3156m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000115C                          3157m LOOP_219
0000115C                          3158mm     BIN2HEX D0,D4,A2
0000115C  45FA 0BCC               3159mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001160  E998                    3160mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001162  1800                    3161mm     MOVE.B D0,D4
00001164  0284 0000000F           3162mm     ANDI.L #$F,D4
0000116A  1832 4000               3163mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000116E                          3164mm     ENDM
0000116E                          3165mm     PRINT_CHAR D4,D3
0000116E                          3166mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000116E                 TRUE     3167mm     IFEQ DEBUG
0000116E  1639 00C00003           3168mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001174  0803 0002               3169mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001178  67F4                    3170mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
0000117A  13C4 00C00007           3171mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001180                          3172mm     ENDC
00001180                          3173mm 
00001180                 FALSE    3174mm     IFNE DEBUG
00001180                          3175mm     ENDC
00001180                          3176mm 
00001180                          3177mm     ENDM
00001180  57CD FFDA               3178m     DBEQ D5,LOOP_219
00001184                          3179m     ENDM
00001184                          3180m     PRINT_CRLF D3,A2
00001184  45FA 0BDF               3181m     LEA CRLF(PC),A2
00001188                          3182mm     PRINT_STR A2,D3
00001188                          3183mm LOOP_225
00001188  0C12 0000               3184mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000118C  6700 0016               3185mm     BEQ EXIT_225
00001190                          3186mmm     PRINT_CHAR (A2)+,D3
00001190                          3187mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001190                 TRUE     3188mmm     IFEQ DEBUG
00001190  1639 00C00003           3189mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001196  0803 0002               3190mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000119A  67F4                    3191mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
0000119C  13DA 00C00007           3192mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011A2                          3193mmm     ENDC
000011A2                          3194mmm 
000011A2                 FALSE    3195mmm     IFNE DEBUG
000011A2                          3196mmm     ENDC
000011A2                          3197mmm 
000011A2                          3198mmm     ENDM
000011A2  60E4                    3199mm     BRA LOOP_225
000011A4                          3200mm EXIT_225
000011A4                          3201mm     ENDM
000011A4                          3202m     ENDM
000011A4                          3203  
000011A4  6000 F09C               3204      BRA MAIN_LOOP
000011A8                          3205          
000011A8                          3206  EI
000011A8  13FC 0008 00C0000B      3207      MOVE.B #8,DUART_IMR
000011B0  027C F8FF               3208      AND.W #$F8FF,SR
000011B4  6000 F08C               3209      BRA MAIN_LOOP
000011B8                          3210      
000011B8                          3211  DI
000011B8  13FC 0000 00C0000B      3212      MOVE.B #0,DUART_IMR
000011C0  007C 0700               3213      OR.W #$0700,SR
000011C4  6000 F07C               3214      BRA MAIN_LOOP
000011C8                          3215          
000011C8                          3216  HASH
000011C8                          3217m     PROTECT
000011C8  31FC AAAA 2AAA          3218m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000011CE  31FC 5555 1554          3219m     MOVE.W #$5555,$1554
000011D4  31FC A0A0 2AAA          3220m     MOVE.W #$A0A0,$2AAA
000011DA                          3221m     ENDM
000011DA  6000 F066               3222      BRA MAIN_LOOP
000011DE                          3223  IB
000011DE  13FC 0038 00A00019      3224      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000011E6                          3225      
000011E6                          3226m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
000011E6  13FC 00FF 00A00007      3227m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000011EE  103C 0030               3228m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000011F2  0000 0006               3229m     ORI.B #IDE_DRIVESEL_REGISTER, D0
000011F6  13C0 00A00019           3230m     MOVE.B D0, MC68230_PORT_C_DATA
000011FC  0200 00EF               3231m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001200  13FC 00E0 00A00013      3232m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
00001208  13C0 00A00019           3233m     MOVE.B D0, MC68230_PORT_C_DATA
0000120E  0000 0010               3234m     ORI.B #MC68230_PORT_C_WRITE, D0
00001212  13C0 00A00019           3235m     MOVE.B D0, MC68230_PORT_C_DATA
00001218  13FC 0038 00A00019      3236m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001220                          3237m     ENDM
00001220                          3238m     WAIT_DRIVE_READY D0, D1
00001220                          3239m LOOP_229
00001220                          3240mm     READ_IDE_STATUS D0, D1
00001220                          3241mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001220  13FC 0000 00A00007      3242mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001228  123C 0030               3243mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000122C  0001 0007               3244mmm     ORI.B #IDE_STATUS_REGISTER, D1
00001230  13C1 00A00019           3245mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001236  0201 00DF               3246mmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000123A  13C1 00A00019           3247mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001240  1039 00A00013           3248mmm     MOVE.B MC68230_PORT_B_DATA, D0
00001246  0001 0020               3249mmm     ORI.B #MC68230_PORT_C_READ, D1
0000124A  13C1 00A00019           3250mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001250  13FC 0038 00A00019      3251mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001258                          3252mmm     ENDM
00001258                          3253mm     ENDM
00001258  0800 0006               3254m     BTST #IDE_STATUS_READY, D0
0000125C  67C2                    3255m     BEQ LOOP_229
0000125E                          3256m     ENDM
0000125E                          3257          
0000125E                          3258m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
0000125E                          3259mm     WAIT_DRIVE_NOT_BUSY D0, D1
0000125E                          3260mm LOOP_233
0000125E                          3261mmm     READ_IDE_STATUS D0, D1
0000125E                          3262mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
0000125E  13FC 0000 00A00007      3263mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001266  123C 0030               3264mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000126A  0001 0007               3265mmmm     ORI.B #IDE_STATUS_REGISTER, D1
0000126E  13C1 00A00019           3266mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001274  0201 00DF               3267mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001278  13C1 00A00019           3268mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000127E  1039 00A00013           3269mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001284  0001 0020               3270mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001288  13C1 00A00019           3271mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000128E  13FC 0038 00A00019      3272mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001296                          3273mmmm     ENDM
00001296                          3274mmm     ENDM
00001296  0800 0007               3275mm     BTST #IDE_STATUS_BUSY, D0
0000129A  66C2                    3276mm     BNE LOOP_233
0000129C                          3277mm     ENDM
0000129C                          3278mm     SET_READ_ADDRESS #0, D0, D1, D2
0000129C                          3279mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
0000129C  13FC 00FF 00A00007      3280mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000012A4  103C 0030               3281mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000012A8  0000 0002               3282mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
000012AC  13C0 00A00019           3283mmm     MOVE.B D0, MC68230_PORT_C_DATA
000012B2  0200 00EF               3284mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000012B6  13FC 0001 00A00013      3285mmm     MOVE.B #1, MC68230_PORT_B_DATA
000012BE  13C0 00A00019           3286mmm     MOVE.B D0, MC68230_PORT_C_DATA
000012C4  0000 0010               3287mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000012C8  13C0 00A00019           3288mmm     MOVE.B D0, MC68230_PORT_C_DATA
000012CE  13FC 0038 00A00019      3289mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000012D6                          3290mmm     ENDM
000012D6  7200                    3291mm     MOVE.L #0,D1
000012D8                          3292mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
000012D8  13FC 00FF 00A00007      3293mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000012E0  103C 0030               3294mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000012E4  0000 0003               3295mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
000012E8  13C0 00A00019           3296mmm     MOVE.B D0, MC68230_PORT_C_DATA
000012EE  0200 00EF               3297mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000012F2  13C1 00A00013           3298mmm     MOVE.B D1, MC68230_PORT_B_DATA
000012F8  13C0 00A00019           3299mmm     MOVE.B D0, MC68230_PORT_C_DATA
000012FE  0000 0010               3300mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001302  13C0 00A00019           3301mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001308  13FC 0038 00A00019      3302mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001310                          3303mmm     ENDM
00001310  E089                    3304mm     LSR.L #8, D1
00001312                          3305mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001312  13FC 00FF 00A00007      3306mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000131A  103C 0030               3307mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000131E  0000 0004               3308mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
00001322  13C0 00A00019           3309mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001328  0200 00EF               3310mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000132C  13C1 00A00013           3311mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001332  13C0 00A00019           3312mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001338  0000 0010               3313mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000133C  13C0 00A00019           3314mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001342  13FC 0038 00A00019      3315mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000134A                          3316mmm     ENDM
0000134A  E089                    3317mm     LSR.L #8, D1                                
0000134C                          3318mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
0000134C  13FC 00FF 00A00007      3319mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001354  103C 0030               3320mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001358  0000 0005               3321mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
0000135C  13C0 00A00019           3322mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001362  0200 00EF               3323mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001366  13C1 00A00013           3324mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000136C  13C0 00A00019           3325mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001372  0000 0010               3326mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001376  13C0 00A00019           3327mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000137C  13FC 0038 00A00019      3328mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001384                          3329mmm     ENDM
00001384  E089                    3330mm     LSR.L #8, D1
00001386                          3331mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
00001386  13FC 0000 00A00007      3332mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000138E  103C 0030               3333mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001392  0000 0006               3334mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001396  13C0 00A00019           3335mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000139C  0200 00DF               3336mmm     ANDI.B #~MC68230_PORT_C_READ, D0
000013A0  13C0 00A00019           3337mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013A6  1439 00A00013           3338mmm     MOVE.B MC68230_PORT_B_DATA, D2
000013AC  0000 0020               3339mmm     ORI.B #MC68230_PORT_C_READ, D0
000013B0  13C0 00A00019           3340mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013B6  13FC 0038 00A00019      3341mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013BE                          3342mmm     ENDM
000013BE  0201 000F               3343mm     ANDI.B #$0F,D1
000013C2  8401                    3344mm     OR.B D1,D2
000013C4                          3345mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
000013C4  13FC 00FF 00A00007      3346mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000013CC  103C 0030               3347mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000013D0  0000 0006               3348mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000013D4  13C0 00A00019           3349mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013DA  0200 00EF               3350mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000013DE  13C2 00A00013           3351mmm     MOVE.B D2, MC68230_PORT_B_DATA
000013E4  13C0 00A00019           3352mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013EA  0000 0010               3353mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000013EE  13C0 00A00019           3354mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013F4  13FC 0038 00A00019      3355mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013FC                          3356mmm     ENDM
000013FC                          3357mm     ENDM
000013FC                          3358mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
000013FC                          3359mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
000013FC  13FC 00FF 00A00007      3360mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001404  103C 0030               3361mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001408  0000 0007               3362mmm     ORI.B #IDE_COMMAND_REGISTER, D0
0000140C  13C0 00A00019           3363mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001412  0200 00EF               3364mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001416  13FC 0020 00A00013      3365mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
0000141E  13C0 00A00019           3366mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001424  0000 0010               3367mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001428  13C0 00A00019           3368mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000142E  13FC 0038 00A00019      3369mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001436                          3370mmm     ENDM
00001436                          3371mm     ENDM
00001436                          3372mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001436                          3373mm LOOP_245
00001436                          3374mmm     READ_IDE_STATUS D0, D1
00001436                          3375mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001436  13FC 0000 00A00007      3376mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000143E  123C 0030               3377mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001442  0001 0007               3378mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001446  13C1 00A00019           3379mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000144C  0201 00DF               3380mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001450  13C1 00A00019           3381mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001456  1039 00A00013           3382mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000145C  0001 0020               3383mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001460  13C1 00A00019           3384mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001466  13FC 0038 00A00019      3385mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000146E                          3386mmmm     ENDM
0000146E                          3387mmm     ENDM
0000146E  0800 0007               3388mm     BTST #IDE_STATUS_BUSY, D0
00001472  66C2                    3389mm     BNE LOOP_245
00001474                          3390mm     ENDM
00001474                          3391mm     WAIT_DRIVE_DRQ D0, D1
00001474                          3392mm LOOP_248
00001474                          3393mmm     READ_IDE_STATUS D0, D1
00001474                          3394mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001474  13FC 0000 00A00007      3395mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000147C  123C 0030               3396mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001480  0001 0007               3397mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001484  13C1 00A00019           3398mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000148A  0201 00DF               3399mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000148E  13C1 00A00019           3400mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001494  1039 00A00013           3401mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000149A  0001 0020               3402mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000149E  13C1 00A00019           3403mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000014A4  13FC 0038 00A00019      3404mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014AC                          3405mmmm     ENDM
000014AC                          3406mmm     ENDM
000014AC  0800 0003               3407mm     BTST #IDE_STATUS_DRQ, D0
000014B0  67C2                    3408mm     BEQ LOOP_248
000014B2                          3409mm     ENDM
000014B2                          3410m     ENDM
000014B2                          3411      
000014B2                          3412      FOR D1 = #0 to #7 DO
000014B2  323C 0000               3413s     MOVE.W  #0,D1
000014B6  6000 0098               3414s     BRA _20000013
000014BA                          3415s _20000012
000014BA                          3416m         READ_32 #IDE_DATA_REGISTER, D0, D6      ; num entries in boot table -> D0 (it's written 8 times to fill the block up)
000014BA                          3417mm     READ_16 #IDE_DATA_REGISTER, D0, D6
000014BA  13FC 0000 00A00007      3418mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014C2  13FC 0000 00A00005      3419mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000014CA                          3420mm     
000014CA  1C3C 0030               3421mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
000014CE  0006 0000               3422mm     ORI.B #IDE_DATA_REGISTER, D6
000014D2  13C6 00A00019           3423mm     MOVE.B D6, MC68230_PORT_C_DATA
000014D8  0206 00DF               3424mm     ANDI.B #~MC68230_PORT_C_READ, D6
000014DC  13C6 00A00019           3425mm     MOVE.B D6, MC68230_PORT_C_DATA
000014E2  1039 00A00011           3426mm     MOVE.B MC68230_PORT_A_DATA, D0
000014E8  E148                    3427mm     LSL.W #8, D0
000014EA  1039 00A00013           3428mm     MOVE.B MC68230_PORT_B_DATA, D0
000014F0  0006 0020               3429mm     ORI.B #MC68230_PORT_C_READ, D6
000014F4  13C6 00A00019           3430mm     MOVE.B D6, MC68230_PORT_C_DATA
000014FA  13FC 0038 00A00019      3431mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001502                          3432mm     ENDM
00001502  E188                    3433m     LSL.L #8, D0
00001504  E188                    3434m     LSL.L #8, D0
00001506                          3435mm     READ_16 #IDE_DATA_REGISTER, D0, D6
00001506  13FC 0000 00A00007      3436mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000150E  13FC 0000 00A00005      3437mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001516                          3438mm     
00001516  1C3C 0030               3439mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
0000151A  0006 0000               3440mm     ORI.B #IDE_DATA_REGISTER, D6
0000151E  13C6 00A00019           3441mm     MOVE.B D6, MC68230_PORT_C_DATA
00001524  0206 00DF               3442mm     ANDI.B #~MC68230_PORT_C_READ, D6
00001528  13C6 00A00019           3443mm     MOVE.B D6, MC68230_PORT_C_DATA
0000152E  1039 00A00011           3444mm     MOVE.B MC68230_PORT_A_DATA, D0
00001534  E148                    3445mm     LSL.W #8, D0
00001536  1039 00A00013           3446mm     MOVE.B MC68230_PORT_B_DATA, D0
0000153C  0006 0020               3447mm     ORI.B #MC68230_PORT_C_READ, D6
00001540  13C6 00A00019           3448mm     MOVE.B D6, MC68230_PORT_C_DATA
00001546  13FC 0038 00A00019      3449mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000154E                          3450mm     ENDM
0000154E                          3451m     ENDM
0000154E                          3452      ENDF
0000154E  5241                    3453s     ADD.W   #1,D1
00001550                          3454s _20000013
00001550  B27C 0007               3455s     CMP.W   #7,D1
00001554  6F00 FF64               3456s     BLE _20000012
00001558  7200                    3457      MOVE.L #0, D1                               ; current boot table index -> D1
0000155A                          3458                          
0000155A                          3459      IF A5 <EQ> #1 THEN                          ; if we are booting...
0000155A  BAFC 0001               3460s     CMP.W   #1,A5
0000155E  6600 0018               3461s     BNE _00000014
00001562  CEBC 0000000F           3462          AND.L #$F,D7                            ; consider bottom 4 bits of address accumulator only
00001568                          3463          IF D7 <GE> D0 THEN                      ; don't boot if off the end of the boot table
00001568  BE40                    3464s     CMP.W   D0,D7
0000156A  6D00 0008               3465s     BLT _00000015
0000156E  2A7C 00000002           3466              MOVE.L #2, A5
00001574                          3467          ENDI
00001574                          3468s _00000015
00001574                          3469  
00001574  2007                    3470          MOVE.L D7, D0                           ; then shorten the boot table to the selected entry 
00001576  5280                    3471          ADD.L #1, D0
00001578                          3472      ENDI
00001578                          3473s _00000014
00001578                          3474      
00001578  227C 00000000           3475      MOVE.L #0, A1
0000157E                          3476      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
0000157E  143C 0000               3477s     MOVE.B  #0,D2
00001582  6000 0236               3478s     BRA _20000015
00001586                          3479s _20000014
00001586  1A3C 0001               3480          MOVE.B #1, D5                           ; assume empty
0000158A                          3481          FOR.B D3 = #0 TO #11 DO                 ; words read from this boot table entry -> D2
0000158A  163C 0000               3482s     MOVE.B  #0,D3
0000158E  6000 01EE               3483s     BRA _20000017
00001592                          3484s _20000016
00001592                          3485m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
00001592                          3486mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001592  13FC 0000 00A00007      3487mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000159A  13FC 0000 00A00005      3488mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000015A2                          3489mm     
000015A2  1E3C 0030               3490mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000015A6  0007 0000               3491mm     ORI.B #IDE_DATA_REGISTER, D7
000015AA  13C7 00A00019           3492mm     MOVE.B D7, MC68230_PORT_C_DATA
000015B0  0207 00DF               3493mm     ANDI.B #~MC68230_PORT_C_READ, D7
000015B4  13C7 00A00019           3494mm     MOVE.B D7, MC68230_PORT_C_DATA
000015BA  1839 00A00011           3495mm     MOVE.B MC68230_PORT_A_DATA, D4
000015C0  E14C                    3496mm     LSL.W #8, D4
000015C2  1839 00A00013           3497mm     MOVE.B MC68230_PORT_B_DATA, D4
000015C8  0007 0020               3498mm     ORI.B #MC68230_PORT_C_READ, D7
000015CC  13C7 00A00019           3499mm     MOVE.B D7, MC68230_PORT_C_DATA
000015D2  13FC 0038 00A00019      3500mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015DA                          3501mm     ENDM
000015DA  E18C                    3502m     LSL.L #8, D4
000015DC  E18C                    3503m     LSL.L #8, D4
000015DE                          3504mm     READ_16 #IDE_DATA_REGISTER, D4, D7
000015DE  13FC 0000 00A00007      3505mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015E6  13FC 0000 00A00005      3506mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000015EE                          3507mm     
000015EE  1E3C 0030               3508mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000015F2  0007 0000               3509mm     ORI.B #IDE_DATA_REGISTER, D7
000015F6  13C7 00A00019           3510mm     MOVE.B D7, MC68230_PORT_C_DATA
000015FC  0207 00DF               3511mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001600  13C7 00A00019           3512mm     MOVE.B D7, MC68230_PORT_C_DATA
00001606  1839 00A00011           3513mm     MOVE.B MC68230_PORT_A_DATA, D4
0000160C  E14C                    3514mm     LSL.W #8, D4
0000160E  1839 00A00013           3515mm     MOVE.B MC68230_PORT_B_DATA, D4
00001614  0007 0020               3516mm     ORI.B #MC68230_PORT_C_READ, D7
00001618  13C7 00A00019           3517mm     MOVE.B D7, MC68230_PORT_C_DATA
0000161E  13FC 0038 00A00019      3518mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001626                          3519mm     ENDM
00001626                          3520m     ENDM
00001626                          3521              IF.B D1 <LT> D0 THEN                ; still in the boot table?
00001626  B200                    3522s     CMP.B   D0,D1
00001628  6C00 0152               3523s     BGE _00000016
0000162C                          3524                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
0000162C  B63C 0000               3525s     CMP.B   #0,D3
00001630  6600 0004               3526s     BNE _00000017
00001634  1A04                    3527                      MOVE.B D4, D5               ; empty flag -> D5
00001636                          3528                  ENDI
00001636                          3529s _00000017
00001636                          3530                  
00001636                          3531                  IF.B D5 <NE> #1 THEN            ; not empty         
00001636  BA3C 0001               3532s     CMP.B   #1,D5
0000163A  6700 013A               3533s     BEQ _00000018
0000163E                          3534                      IF A5 <EQ> #0 THEN          ; not booting, so print
0000163E  BAFC 0000               3535s     CMP.W   #0,A5
00001642  6600 00FE               3536s     BNE _00000019
00001646                          3537                          IF.B D3 <EQ> #0 THEN    ; first word in boot table, print the index
00001646  B63C 0000               3538s     CMP.B   #0,D3
0000164A  6600 0044               3539s     BNE _0000001A
0000164E                          3540m                             PRINT_REG_4BIT D1, D6, D7, A0   
0000164E  41FA 06DA               3541m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001652  1E01                    3542m     MOVE.B D1,D7
00001654  0287 0000000F           3543m     ANDI.L #$F,D7
0000165A  1E30 7000               3544m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
0000165E                          3545mm     PRINT_CHAR D7,D6
0000165E                          3546mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000165E                 TRUE     3547mm     IFEQ DEBUG
0000165E  1C39 00C00003           3548mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00001664  0806 0002               3549mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00001668  67F4                    3550mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
0000166A  13C7 00C00007           3551mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001670                          3552mm     ENDC
00001670                          3553mm 
00001670                 FALSE    3554mm     IFNE DEBUG
00001670                          3555mm     ENDC
00001670                          3556mm 
00001670                          3557mm     ENDM
00001670                          3558m     ENDM
00001670  41FA 0711               3559                              LEA INDEX_SEP(PC), A0
00001674                          3560m                             PRINT_STR A0, D7
00001674                          3561m LOOP_259
00001674  0C10 0000               3562m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001678  6700 0016               3563m     BEQ EXIT_259
0000167C                          3564mm     PRINT_CHAR (A0)+,D7
0000167C                          3565mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000167C                 TRUE     3566mm     IFEQ DEBUG
0000167C  1E39 00C00003           3567mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001682  0807 0002               3568mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001686  67F4                    3569mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
00001688  13D8 00C00007           3570mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000168E                          3571mm     ENDC
0000168E                          3572mm 
0000168E                 FALSE    3573mm     IFNE DEBUG
0000168E                          3574mm     ENDC
0000168E                          3575mm 
0000168E                          3576mm     ENDM
0000168E  60E4                    3577m     BRA LOOP_259
00001690                          3578m EXIT_259
00001690                          3579m     ENDM
00001690                          3580                          ENDI
00001690                          3581s _0000001A
00001690                          3582  
00001690                          3583                          IF.B D3 <GT> #1 AND.B D3 <LT> #7 THEN   ; str, print it
00001690  B63C 0001               3584s     CMP.B   #1,D3
00001694  6F00 002E               3585s     BLE _0000001B
00001698  B63C 0007               3586s     CMP.B   #7,D3
0000169C  6C00 0026               3587s     BGE _0000001B
000016A0                          3588                              FOR.B D6 = #0 TO #3 DO
000016A0  1C3C 0000               3589s     MOVE.B  #0,D6
000016A4  6000 0018               3590s     BRA _20000019
000016A8                          3591s _20000018
000016A8  E19C                    3592                                  ROL.L #8, D4                    
000016AA                          3593m                                 PRINT_CHAR D4, D7
000016AA                          3594m WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016AA                 TRUE     3595m     IFEQ DEBUG
000016AA  1E39 00C00003           3596m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000016B0  0807 0002               3597m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000016B4  67F4                    3598m         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000016B6  13C4 00C00007           3599m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000016BC                          3600m     ENDC
000016BC                          3601m 
000016BC                 FALSE    3602m     IFNE DEBUG
000016BC                          3603m     ENDC
000016BC                          3604m 
000016BC                          3605m     ENDM
000016BC                          3606                              ENDF
000016BC  5206                    3607s     ADD.B   #1,D6
000016BE                          3608s _20000019
000016BE  BC3C 0003               3609s     CMP.B   #3,D6
000016C2  6FE4                    3610s     BLE _20000018
000016C4                          3611                          ENDI
000016C4                          3612s _0000001B
000016C4                          3613                      
000016C4                          3614                          IF.B D3 <GT> #7 AND.B D3 <LT> #12 THEN
000016C4  B63C 0007               3615s     CMP.B   #7,D3
000016C8  6F00 0078               3616s     BLE _0000001C
000016CC  B63C 000C               3617s     CMP.B   #12,D3
000016D0  6C00 0070               3618s     BGE _0000001C
000016D4  2C45                    3619                              MOVE.L D5, A6       ; preserve the empty flag, we're gonna use D5
000016D6  41FA 06AB               3620                              LEA INDEX_SEP(PC), A0
000016DA                          3621m                             PRINT_STR A0, D7
000016DA                          3622m LOOP_262
000016DA  0C10 0000               3623m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000016DE  6700 0016               3624m     BEQ EXIT_262
000016E2                          3625mm     PRINT_CHAR (A0)+,D7
000016E2                          3626mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016E2                 TRUE     3627mm     IFEQ DEBUG
000016E2  1E39 00C00003           3628mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000016E8  0807 0002               3629mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000016EC  67F4                    3630mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
000016EE  13D8 00C00007           3631mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016F4                          3632mm     ENDC
000016F4                          3633mm 
000016F4                 FALSE    3634mm     IFNE DEBUG
000016F4                          3635mm     ENDC
000016F4                          3636mm 
000016F4                          3637mm     ENDM
000016F4  60E4                    3638m     BRA LOOP_262
000016F6                          3639m EXIT_262
000016F6                          3640m     ENDM
000016F6                          3641m                             PRINT_REG D4, D5, D6, D7, A0
000016F6  41FA 0673               3642m     LEA OX(PC),A0
000016FA                          3643mm     PRINT_STR A0,D5
000016FA                          3644mm LOOP_265
000016FA  0C10 0000               3645mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000016FE  6700 0016               3646mm     BEQ EXIT_265
00001702                          3647mmm     PRINT_CHAR (A0)+,D5
00001702                          3648mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001702                 TRUE     3649mmm     IFEQ DEBUG
00001702  1A39 00C00003           3650mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00001708  0805 0002               3651mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000170C  67F4                    3652mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
0000170E  13D8 00C00007           3653mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001714                          3654mmm     ENDC
00001714                          3655mmm 
00001714                 FALSE    3656mmm     IFNE DEBUG
00001714                          3657mmm     ENDC
00001714                          3658mmm 
00001714                          3659mmm     ENDM
00001714  60E4                    3660mm     BRA LOOP_265
00001716                          3661mm EXIT_265
00001716                          3662mm     ENDM
00001716  7E07                    3663m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001718                          3664m LOOP_264
00001718                          3665mm     BIN2HEX D4,D6,A0
00001718  41FA 0610               3666mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000171C  E99C                    3667mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000171E  1C04                    3668mm     MOVE.B D4,D6
00001720  0286 0000000F           3669mm     ANDI.L #$F,D6
00001726  1C30 6000               3670mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
0000172A                          3671mm     ENDM
0000172A                          3672mm     PRINT_CHAR D6,D5
0000172A                          3673mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000172A                 TRUE     3674mm     IFEQ DEBUG
0000172A  1A39 00C00003           3675mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00001730  0805 0002               3676mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001734  67F4                    3677mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
00001736  13C6 00C00007           3678mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000173C                          3679mm     ENDC
0000173C                          3680mm 
0000173C                 FALSE    3681mm     IFNE DEBUG
0000173C                          3682mm     ENDC
0000173C                          3683mm 
0000173C                          3684mm     ENDM
0000173C  57CF FFDA               3685m     DBEQ D7,LOOP_264
00001740                          3686m     ENDM
00001740  2A0E                    3687                              MOVE.L A6, D5       ; restore the empty flag into D5
00001742                          3688                          ENDI
00001742                          3689s _0000001C
00001742                          3690                      ENDI
00001742                          3691s _00000019
00001742                          3692                      
00001742                          3693                      IF A5 <EQ> #1 THEN          ; save the params if we are booting
00001742  BAFC 0001               3694s     CMP.W   #1,A5
00001746  6600 002A               3695s     BNE _0000001D
0000174A                          3696                          IF.B D3 <EQ> #8 THEN                        
0000174A  B63C 0008               3697s     CMP.B   #8,D3
0000174E  6600 0004               3698s     BNE _0000001E
00001752  2244                    3699                              MOVE.L D4, A1       ; length -> A1
00001754                          3700                          ENDI
00001754                          3701s _0000001E
00001754                          3702              
00001754                          3703                          IF.B D3 <EQ> #9 THEN
00001754  B63C 0009               3704s     CMP.B   #9,D3
00001758  6600 0004               3705s     BNE _0000001F
0000175C  2444                    3706                              MOVE.L D4, A2       ; start address -> A2
0000175E                          3707                          ENDI
0000175E                          3708s _0000001F
0000175E                          3709  
0000175E                          3710                          IF.B D3 <EQ> #10 THEN
0000175E  B63C 000A               3711s     CMP.B   #10,D3
00001762  6600 0004               3712s     BNE _00000020
00001766  2644                    3713                              MOVE.L D4, A3       ; go address -> A3
00001768                          3714                          ENDI
00001768                          3715s _00000020
00001768                          3716  
00001768                          3717                          IF.B D3 <EQ> #11 THEN
00001768  B63C 000B               3718s     CMP.B   #11,D3
0000176C  6600 0004               3719s     BNE _00000021
00001770  2844                    3720                              MOVE.L D4, A4       ; start block -> A4
00001772                          3721                          ENDI                    
00001772                          3722s _00000021
00001772                          3723                      ENDI
00001772                          3724s _0000001D
00001772                          3725                  ELSE
00001772  6000 0008               3726s     BRA _00000022
00001776                          3727s _00000018
00001776  227C 00000000           3728                      MOVE.L #0, A1
0000177C                          3729                  ENDI
0000177C                          3730s _00000022
0000177C                          3731              ENDI            
0000177C                          3732s _00000016
0000177C                          3733          ENDF
0000177C  5203                    3734s     ADD.B   #1,D3
0000177E                          3735s _20000017
0000177E  B63C 000B               3736s     CMP.B   #11,D3
00001782  6F00 FE0E               3737s     BLE _20000016
00001786                          3738  
00001786                          3739          IF A5 <EQ> #0 THEN                  ; not booting?          
00001786  BAFC 0000               3740s     CMP.W   #0,A5
0000178A  6600 002A               3741s     BNE _00000023
0000178E                          3742              IF.B D5 <NE> #1 THEN            ; not booting and not empty, so print crlf
0000178E  BA3C 0001               3743s     CMP.B   #1,D5
00001792  6700 0022               3744s     BEQ _00000024
00001796                          3745m                 PRINT_CRLF D7, A0
00001796  41FA 05CD               3746m     LEA CRLF(PC),A0
0000179A                          3747mm     PRINT_STR A0,D7
0000179A                          3748mm LOOP_270
0000179A  0C10 0000               3749mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000179E  6700 0016               3750mm     BEQ EXIT_270
000017A2                          3751mmm     PRINT_CHAR (A0)+,D7
000017A2                          3752mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017A2                 TRUE     3753mmm     IFEQ DEBUG
000017A2  1E39 00C00003           3754mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017A8  0807 0002               3755mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017AC  67F4                    3756mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
000017AE  13D8 00C00007           3757mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017B4                          3758mmm     ENDC
000017B4                          3759mmm 
000017B4                 FALSE    3760mmm     IFNE DEBUG
000017B4                          3761mmm     ENDC
000017B4                          3762mmm 
000017B4                          3763mmm     ENDM
000017B4  60E4                    3764mm     BRA LOOP_270
000017B6                          3765mm EXIT_270
000017B6                          3766mm     ENDM
000017B6                          3767m     ENDM
000017B6                          3768              ENDI
000017B6                          3769s _00000024
000017B6                          3770          ENDI
000017B6                          3771s _00000023
000017B6                          3772          
000017B6  5281                    3773          ADD.L #1,D1                         ; next boot table index
000017B8                          3774      ENDF
000017B8  5202                    3775s     ADD.B   #1,D2
000017BA                          3776s _20000015
000017BA  B43C 0009               3777s     CMP.B   #9,D2
000017BE  6F00 FDC6               3778s     BLE _20000014
000017C2                          3779                          
000017C2                          3780      IF A5 <NE> #0 THEN                      ; check for boot from empty slot
000017C2  BAFC 0000               3781s     CMP.W   #0,A5
000017C6  6700 0034               3782s     BEQ _00000025
000017CA                          3783          IF A5 <EQ> #2 OR A1 <EQ> #0  THEN 
000017CA  BAFC 0002               3784s     CMP.W   #2,A5
000017CE  6708                    3785s     BEQ.S   _00000026
000017D0  B2FC 0000               3786s     CMP.W   #0,A1
000017D4  6600 0026               3787s     BNE _00000027
000017D8                          3788s _00000026
000017D8  41FA 05B5               3789              LEA NOT_FOUND(PC), A0
000017DC                          3790m             PRINT_STR A0, D7
000017DC                          3791m LOOP_272
000017DC  0C10 0000               3792m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017E0  6700 0016               3793m     BEQ EXIT_272
000017E4                          3794mm     PRINT_CHAR (A0)+,D7
000017E4                          3795mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017E4                 TRUE     3796mm     IFEQ DEBUG
000017E4  1E39 00C00003           3797mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017EA  0807 0002               3798mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017EE  67F4                    3799mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000017F0  13D8 00C00007           3800mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017F6                          3801mm     ENDC
000017F6                          3802mm 
000017F6                 FALSE    3803mm     IFNE DEBUG
000017F6                          3804mm     ENDC
000017F6                          3805mm 
000017F6                          3806mm     ENDM
000017F6  60E4                    3807m     BRA LOOP_272
000017F8                          3808m EXIT_272
000017F8                          3809m     ENDM
000017F8  6000 EA48               3810              BRA MAIN_LOOP
000017FC                          3811          ENDI
000017FC                          3812s _00000027
000017FC                          3813      ENDI
000017FC                          3814s _00000025
000017FC                          3815      
000017FC                          3816      IF A5 <EQ> #1 THEN                      ; booting?
000017FC  BAFC 0001               3817s     CMP.W   #1,A5
00001800  6600 031C               3818s     BNE _00000028
00001804  41FA 0581               3819          LEA BOOT(PC), A0
00001808                          3820m         PRINT_STR A0, D7
00001808                          3821m LOOP_274
00001808  0C10 0000               3822m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000180C  6700 0016               3823m     BEQ EXIT_274
00001810                          3824mm     PRINT_CHAR (A0)+,D7
00001810                          3825mm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001810                 TRUE     3826mm     IFEQ DEBUG
00001810  1E39 00C00003           3827mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001816  0807 0002               3828mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000181A  67F4                    3829mm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
0000181C  13D8 00C00007           3830mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001822                          3831mm     ENDC
00001822                          3832mm 
00001822                 FALSE    3833mm     IFNE DEBUG
00001822                          3834mm     ENDC
00001822                          3835mm 
00001822                          3836mm     ENDM
00001822  60E4                    3837m     BRA LOOP_274
00001824                          3838m EXIT_274
00001824                          3839m     ENDM
00001824                          3840      
00001824  2009                    3841          MOVE.L A1, D0                       ; length -> D0              
00001826  220C                    3842          MOVE.L A4, D1                       ; start block -> D1
00001828                          3843          
00001828                          3844          WHILE.L D0 <GT> #0 DO
00001828                          3845s _10000016
00001828  B0BC 00000000           3846s     CMP.L   #0,D0
0000182E  6F00 02CC               3847s     BLE _10000017
00001832                          3848m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
00001832                          3849mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001832                          3850mm LOOP_277
00001832                          3851mmm     READ_IDE_STATUS D5, D6
00001832                          3852mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001832  13FC 0000 00A00007      3853mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000183A  1C3C 0030               3854mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
0000183E  0006 0007               3855mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001842  13C6 00A00019           3856mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001848  0206 00DF               3857mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
0000184C  13C6 00A00019           3858mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001852  1A39 00A00013           3859mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001858  0006 0020               3860mmmm     ORI.B #MC68230_PORT_C_READ, D6
0000185C  13C6 00A00019           3861mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001862  13FC 0038 00A00019      3862mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000186A                          3863mmmm     ENDM
0000186A                          3864mmm     ENDM
0000186A  0805 0007               3865mm     BTST #IDE_STATUS_BUSY, D5
0000186E  66C2                    3866mm     BNE LOOP_277
00001870                          3867mm     ENDM
00001870                          3868mm     SET_READ_ADDRESS D1, D5, D6, D7
00001870                          3869mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D5
00001870  13FC 00FF 00A00007      3870mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001878  1A3C 0030               3871mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
0000187C  0005 0002               3872mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D5
00001880  13C5 00A00019           3873mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001886  0205 00EF               3874mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
0000188A  13FC 0001 00A00013      3875mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001892  13C5 00A00019           3876mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001898  0005 0010               3877mmm     ORI.B #MC68230_PORT_C_WRITE, D5
0000189C  13C5 00A00019           3878mmm     MOVE.B D5, MC68230_PORT_C_DATA
000018A2  13FC 0038 00A00019      3879mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000018AA                          3880mmm     ENDM
000018AA  2C01                    3881mm     MOVE.L D1,D6
000018AC                          3882mmm     WRITE_8 D6, #IDE_LBA_0_7_REGISTER, D5
000018AC  13FC 00FF 00A00007      3883mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000018B4  1A3C 0030               3884mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000018B8  0005 0003               3885mmm     ORI.B #IDE_LBA_0_7_REGISTER, D5
000018BC  13C5 00A00019           3886mmm     MOVE.B D5, MC68230_PORT_C_DATA
000018C2  0205 00EF               3887mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000018C6  13C6 00A00013           3888mmm     MOVE.B D6, MC68230_PORT_B_DATA
000018CC  13C5 00A00019           3889mmm     MOVE.B D5, MC68230_PORT_C_DATA
000018D2  0005 0010               3890mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000018D6  13C5 00A00019           3891mmm     MOVE.B D5, MC68230_PORT_C_DATA
000018DC  13FC 0038 00A00019      3892mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000018E4                          3893mmm     ENDM
000018E4  E08E                    3894mm     LSR.L #8, D6
000018E6                          3895mmm     WRITE_8 D6, #IDE_LBA_8_15_REGISTER, D5
000018E6  13FC 00FF 00A00007      3896mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000018EE  1A3C 0030               3897mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000018F2  0005 0004               3898mmm     ORI.B #IDE_LBA_8_15_REGISTER, D5
000018F6  13C5 00A00019           3899mmm     MOVE.B D5, MC68230_PORT_C_DATA
000018FC  0205 00EF               3900mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001900  13C6 00A00013           3901mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001906  13C5 00A00019           3902mmm     MOVE.B D5, MC68230_PORT_C_DATA
0000190C  0005 0010               3903mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001910  13C5 00A00019           3904mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001916  13FC 0038 00A00019      3905mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000191E                          3906mmm     ENDM
0000191E  E08E                    3907mm     LSR.L #8, D6                                
00001920                          3908mmm     WRITE_8 D6, #IDE_LBA_16_23_REGISTER, D5
00001920  13FC 00FF 00A00007      3909mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001928  1A3C 0030               3910mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
0000192C  0005 0005               3911mmm     ORI.B #IDE_LBA_16_23_REGISTER, D5
00001930  13C5 00A00019           3912mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001936  0205 00EF               3913mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
0000193A  13C6 00A00013           3914mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001940  13C5 00A00019           3915mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001946  0005 0010               3916mmm     ORI.B #MC68230_PORT_C_WRITE, D5
0000194A  13C5 00A00019           3917mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001950  13FC 0038 00A00019      3918mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001958                          3919mmm     ENDM
00001958  E08E                    3920mm     LSR.L #8, D6
0000195A                          3921mmm     READ_8 #IDE_DRIVESEL_REGISTER, D7, D5
0000195A  13FC 0000 00A00007      3922mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001962  1A3C 0030               3923mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001966  0005 0006               3924mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
0000196A  13C5 00A00019           3925mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001970  0205 00DF               3926mmm     ANDI.B #~MC68230_PORT_C_READ, D5
00001974  13C5 00A00019           3927mmm     MOVE.B D5, MC68230_PORT_C_DATA
0000197A  1E39 00A00013           3928mmm     MOVE.B MC68230_PORT_B_DATA, D7
00001980  0005 0020               3929mmm     ORI.B #MC68230_PORT_C_READ, D5
00001984  13C5 00A00019           3930mmm     MOVE.B D5, MC68230_PORT_C_DATA
0000198A  13FC 0038 00A00019      3931mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001992                          3932mmm     ENDM
00001992  0206 000F               3933mm     ANDI.B #$0F,D6
00001996  8E06                    3934mm     OR.B D6,D7
00001998                          3935mmm     WRITE_8 D7, #IDE_DRIVESEL_REGISTER, D5
00001998  13FC 00FF 00A00007      3936mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019A0  1A3C 0030               3937mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019A4  0005 0006               3938mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
000019A8  13C5 00A00019           3939mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019AE  0205 00EF               3940mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019B2  13C7 00A00013           3941mmm     MOVE.B D7, MC68230_PORT_B_DATA
000019B8  13C5 00A00019           3942mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019BE  0005 0010               3943mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019C2  13C5 00A00019           3944mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019C8  13FC 0038 00A00019      3945mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019D0                          3946mmm     ENDM
000019D0                          3947mm     ENDM
000019D0                          3948mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D5
000019D0                          3949mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D5
000019D0  13FC 00FF 00A00007      3950mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019D8  1A3C 0030               3951mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019DC  0005 0007               3952mmm     ORI.B #IDE_COMMAND_REGISTER, D5
000019E0  13C5 00A00019           3953mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019E6  0205 00EF               3954mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019EA  13FC 0020 00A00013      3955mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
000019F2  13C5 00A00019           3956mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019F8  0005 0010               3957mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019FC  13C5 00A00019           3958mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A02  13FC 0038 00A00019      3959mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A0A                          3960mmm     ENDM
00001A0A                          3961mm     ENDM
00001A0A                          3962mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001A0A                          3963mm LOOP_289
00001A0A                          3964mmm     READ_IDE_STATUS D5, D6
00001A0A                          3965mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001A0A  13FC 0000 00A00007      3966mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001A12  1C3C 0030               3967mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001A16  0006 0007               3968mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001A1A  13C6 00A00019           3969mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001A20  0206 00DF               3970mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001A24  13C6 00A00019           3971mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001A2A  1A39 00A00013           3972mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001A30  0006 0020               3973mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001A34  13C6 00A00019           3974mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001A3A  13FC 0038 00A00019      3975mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A42                          3976mmmm     ENDM
00001A42                          3977mmm     ENDM
00001A42  0805 0007               3978mm     BTST #IDE_STATUS_BUSY, D5
00001A46  66C2                    3979mm     BNE LOOP_289
00001A48                          3980mm     ENDM
00001A48                          3981mm     WAIT_DRIVE_DRQ D5, D6
00001A48                          3982mm LOOP_292
00001A48                          3983mmm     READ_IDE_STATUS D5, D6
00001A48                          3984mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001A48  13FC 0000 00A00007      3985mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001A50  1C3C 0030               3986mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001A54  0006 0007               3987mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001A58  13C6 00A00019           3988mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001A5E  0206 00DF               3989mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001A62  13C6 00A00019           3990mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001A68  1A39 00A00013           3991mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001A6E  0006 0020               3992mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001A72  13C6 00A00019           3993mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001A78  13FC 0038 00A00019      3994mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A80                          3995mmmm     ENDM
00001A80                          3996mmm     ENDM
00001A80  0805 0003               3997mm     BTST #IDE_STATUS_DRQ, D5
00001A84  67C2                    3998mm     BEQ LOOP_292
00001A86                          3999mm     ENDM
00001A86                          4000m     ENDM
00001A86                          4001m             PRINT_CHAR #'.', D7
00001A86                          4002m WAIT_FOR_READY_295                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A86                 TRUE     4003m     IFEQ DEBUG
00001A86  1E39 00C00003           4004m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001A8C  0807 0002               4005m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001A90  67F4                    4006m         BEQ WAIT_FOR_READY_295                      ; NO SPACE, CHECK AGAIN
00001A92  13FC 002E 00C00007      4007m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001A9A                          4008m     ENDC
00001A9A                          4009m 
00001A9A                 FALSE    4010m     IFNE DEBUG
00001A9A                          4011m     ENDC
00001A9A                          4012m 
00001A9A                          4013m     ENDM
00001A9A                          4014              
00001A9A                          4015              FOR.L D3 = #0 TO #255 DO
00001A9A  7600                    4016s     MOVE.L  #0,D3
00001A9C  6000 0050               4017s     BRA _2000001B
00001AA0                          4018s _2000001A
00001AA0                          4019m                 READ_16 #IDE_DATA_REGISTER, D4, D7
00001AA0  13FC 0000 00A00007      4020m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001AA8  13FC 0000 00A00005      4021m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001AB0                          4022m     
00001AB0  1E3C 0030               4023m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001AB4  0007 0000               4024m     ORI.B #IDE_DATA_REGISTER, D7
00001AB8  13C7 00A00019           4025m     MOVE.B D7, MC68230_PORT_C_DATA
00001ABE  0207 00DF               4026m     ANDI.B #~MC68230_PORT_C_READ, D7
00001AC2  13C7 00A00019           4027m     MOVE.B D7, MC68230_PORT_C_DATA
00001AC8  1839 00A00011           4028m     MOVE.B MC68230_PORT_A_DATA, D4
00001ACE  E14C                    4029m     LSL.W #8, D4
00001AD0  1839 00A00013           4030m     MOVE.B MC68230_PORT_B_DATA, D4
00001AD6  0007 0020               4031m     ORI.B #MC68230_PORT_C_READ, D7
00001ADA  13C7 00A00019           4032m     MOVE.B D7, MC68230_PORT_C_DATA
00001AE0  13FC 0038 00A00019      4033m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AE8                          4034m     ENDM
00001AE8  34C4                    4035                  MOVE.W D4,(A2)+
00001AEA  5580                    4036                  SUB.L #2, D0
00001AEC                          4037              ENDF
00001AEC  5283                    4038s     ADD.L   #1,D3
00001AEE                          4039s _2000001B
00001AEE  B6BC 000000FF           4040s     CMP.L   #255,D3
00001AF4  6FAA                    4041s     BLE _2000001A
00001AF6                          4042          
00001AF6  5281                    4043              ADD.L #1, D1                    ; next block
00001AF8                          4044          ENDW
00001AF8  6000 FD2E               4045s     BRA _10000016
00001AFC                          4046s _10000017
00001AFC                          4047  
00001AFC                          4048m         PRINT_CRLF D3, A6   
00001AFC  4DFA 0267               4049m     LEA CRLF(PC),A6
00001B00                          4050mm     PRINT_STR A6,D3
00001B00                          4051mm LOOP_298
00001B00  0C16 0000               4052mm     CMP.B #NULL,(A6)                                ; 0 -> DONE
00001B04  6700 0016               4053mm     BEQ EXIT_298
00001B08                          4054mmm     PRINT_CHAR (A6)+,D3
00001B08                          4055mmm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B08                 TRUE     4056mmm     IFEQ DEBUG
00001B08  1639 00C00003           4057mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001B0E  0803 0002               4058mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001B12  67F4                    4059mmm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001B14  13DE 00C00007           4060mmm         MOVE.B (A6)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001B1A                          4061mmm     ENDC
00001B1A                          4062mmm 
00001B1A                 FALSE    4063mmm     IFNE DEBUG
00001B1A                          4064mmm     ENDC
00001B1A                          4065mmm 
00001B1A                          4066mmm     ENDM
00001B1A  60E4                    4067mm     BRA LOOP_298
00001B1C                          4068mm EXIT_298
00001B1C                          4069mm     ENDM
00001B1C                          4070m     ENDM
00001B1C                          4071      
00001B1C  2E0B                    4072          MOVE.L A3, D7                           ; set go address
00001B1E                          4073      ENDI
00001B1E                          4074s _00000028
00001B1E                          4075  
00001B1E  6000 E722               4076      BRA MAIN_LOOP
00001B22                          4077  
00001B22                          4078  HEX_DIGIT
00001B22  E98F                    4079      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001B24                          4080m     HEX2BIN D2,D2,A0
00001B24  41FA 0214               4081m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001B28  0402 0030               4082m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001B2C  C4BC 000000FF           4083m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001B32  1430 2000               4084m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001B36                          4085m     ENDM
00001B36  8E02                    4086      OR.B D2,D7  
00001B38  6000 E728               4087      BRA GET_INPUT
00001B3C                          4088      
00001B3C  FFFF FFFF               4089      SIMHALT                                             ; halt simulator
00001B40                          4090  ; strings
00001B40= 50 72 65 73 73 20 ...   4091  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001B53= 5B 3F 5D 09 09 09 ...   4092  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001B5F= 5B 76 5D 09 09 09 ...   4093          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001B6E= 78 78 78 78 78 78 ...   4094          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001B86= 78 78 78 78 78 78 ...   4095          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001BA6= 78 78 78 78 78 78 ...   4096          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001BC7= 78 78 78 78 78 78 ...   4097          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001BD8= 5B 7A 5D 09 09 09 ...   4098          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001BEA= 78 78 78 78 78 78 ...   4099          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001C0E= 78 78 78 78 78 78 ...   4100          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001C30= 23 09 09 09 77 72 ...   4101          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001C4A= 5B 78 5D 09 09 09 ...   4102          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001C61= 5B 49 5D 09 09 09 ...   4103          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001C7A= 5B 6F 5D 09 09 09 ...   4104          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001C94= 5B 69 5D 09 09 09 ...   4105          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001CAA= 78 78 78 78 78 78 ...   4106          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001CC8= 48 75 68 3F 0D 0A 00    4107  HUH  DC.B 'Huh?',CR,LF,NULL
00001CCF= 20 53 20 72 65 63 ...   4108  READ    DC.B ' S records read, start address = ',NULL
00001CF1= 57 3A 20 55 6E 6B ...   4109  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001D08= 21 20 43 53 20 66 ...   4110  CS_FAILURE  DC.B '! CS failure at ',NULL
00001D19= 21 20 52 41 4D 20 ...   4111  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001D2A= 30 31 32 33 34 35 ...   4112  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001D3A= 00 01 02 03 04 05 ...   4113  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001D51= 4C 6F 61 64 69 6E ...   4114  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001D65= 0D 0A 00                4115  CRLF    DC.B CR,LF,NULL
00001D68= 3E 20 00                4116  PROMPT  DC.B '> ',NULL
00001D6B= 30 78 00                4117  ox      DC.B '0x',NULL
00001D6E= 20 2D 3E 20 00          4118  to      DC.B ' -> ',NULL
00001D73= 20 66 6F 72 20 00       4119  for     DC.B ' for ',NULL
00001D79= 53 50 3A 20 00          4120  STACK_POINTER DC.B 'SP: ',NULL
00001D7E= 53 52 3A 20 00          4121  STATUS_REGISTER DC.B 'SR: ',NULL
00001D83= 20 3A 20 00             4122  INDEX_SEP DC.B ' : ',NULL
00001D87= 42 6F 6F 74 69 6E ...   4123  BOOT DC.B 'Booting',NULL
00001D8F= 4E 6F 74 20 66 6F ...   4124  NOT_FOUND DC.B 'Not found',CR,LF,NULL
00001D9B= 4D 44 46 2D 6D 6F ...   4125  VERSION DC.B 'MDF-mon V1.159 (18/12/2022)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001DB9= 00                      4126  END     DC.B 0
00001DBA                          4127      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1D2A
BOOT                1D87
CR                  D
CRLF                1D65
CS_FAILURE          1D08
DEBUG               0
DI                  11B8
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       986
DOWNLOAD_DONE       9A2
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  11A8
END                 1DB9
EXIT_10             186
EXIT_104            992
EXIT_107            9C2
EXIT_110            9E2
EXIT_114            A2C
EXIT_117            A4E
EXIT_122            A98
EXIT_124            B14
EXIT_127            B38
EXIT_132            B82
EXIT_139            C10
EXIT_142            C7C
EXIT_144            C9C
EXIT_146            CBC
EXIT_148            CDC
EXIT_15             1D0
EXIT_151            CFE
EXIT_155            D48
EXIT_158            D6A
EXIT_162            DB4
EXIT_165            DD4
EXIT_17             1F0
EXIT_170            E1E
EXIT_185            F30
EXIT_188            F94
EXIT_191            FB4
EXIT_195            FFE
EXIT_198            1020
EXIT_20             210
EXIT_203            106A
EXIT_207            10AC
EXIT_210            10CE
EXIT_215            1118
EXIT_217            1138
EXIT_22             262
EXIT_220            115A
EXIT_225            11A4
EXIT_259            1690
EXIT_262            16F6
EXIT_265            1716
EXIT_270            17B6
EXIT_272            17F8
EXIT_274            1824
EXIT_28             2EE
EXIT_298            1B1C
EXIT_30             37A
EXIT_32             3A6
EXIT_35             3D0
EXIT_45             47E
EXIT_5              13E
EXIT_52             4F4
EXIT_7              15E
EXIT_82             83E
EXIT_84             85E
EXIT_88             890
EXIT_94             908
EXIT_96             928
EXIT_99             948
FOR                 1D73
G                   A9C
GET_INPUT           262
H                   37E
HASH                11C8
HELP                1B53
HELPPROMPT          1B40
HEX2BIN             10B
HEX2BIN_LUT         1D3A
HEX_DIGIT           1B22
HUH                 1CC8
IB                  11DE
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
INDEX_SEP           1D83
L                   B92
LF                  A
LOADING             1D51
LOOP_10             16A
LOOP_104            976
LOOP_107            9A6
LOOP_109            9E4
LOOP_110            9C6
LOOP_114            A10
LOOP_116            A50
LOOP_117            A32
LOOP_122            A7C
LOOP_124            AF8
LOOP_126            B3A
LOOP_127            B1C
LOOP_132            B66
LOOP_139            BF4
LOOP_142            C60
LOOP_144            C80
LOOP_146            CA0
LOOP_148            CC0
LOOP_15             1B4
LOOP_150            D00
LOOP_151            CE2
LOOP_155            D2C
LOOP_157            D6C
LOOP_158            D4E
LOOP_162            D98
LOOP_164            DD6
LOOP_165            DB8
LOOP_17             1D4
LOOP_170            E02
LOOP_185            F14
LOOP_188            F78
LOOP_190            FB6
LOOP_191            F98
LOOP_195            FE2
LOOP_197            1022
LOOP_198            1004
LOOP_20             1F4
LOOP_203            104E
LOOP_207            1090
LOOP_209            10D0
LOOP_210            10B2
LOOP_215            10FC
LOOP_217            111C
LOOP_219            115C
LOOP_22             246
LOOP_220            113E
LOOP_225            1188
LOOP_229            1220
LOOP_233            125E
LOOP_245            1436
LOOP_248            1474
LOOP_259            1674
LOOP_262            16DA
LOOP_264            1718
LOOP_265            16FA
LOOP_270            179A
LOOP_272            17DC
LOOP_274            1808
LOOP_277            1832
LOOP_28             2D2
LOOP_289            1A0A
LOOP_292            1A48
LOOP_298            1B00
LOOP_30             35E
LOOP_32             38A
LOOP_34             3D2
LOOP_35             3B4
LOOP_45             462
LOOP_5              122
LOOP_52             4D8
LOOP_7              142
LOOP_82             822
LOOP_84             842
LOOP_88             874
LOOP_9              188
LOOP_94             8EC
LOOP_96             90C
LOOP_98             94A
LOOP_99             92C
MAIN_LOOP           242
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           1D8F
NULL                0
OX                  1D6B
P                   EBC
PRINTIT             38A
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             C5B
PROGRAM_VECTOR      CF2
PROMPT              1D68
PROTECT             BF7
R                   3AA
RAM                 200000
RAM_ERROR           1D19
READ                1CCF
READ_16             10E5
READ_32             1312
READ_8              D70
READ_CHAR           6DD
READ_IDE_STATUS     1361
RESET               4
ROM                 0
S                   4FC
SEND_COMMAND        15E3
SEND_READ_COMMAND_AND_WAIT  1612
SET_READ_ADDRESS    1481
STACK               0
STACK_POINTER       1D79
START               8
STATUS_REGISTER     1D7E
TAB                 9
TO                  1D6E
UNPROTECT           B30
UNREC               1CF1
V                   386
VERSION             1D9B
W                   482
WAIT_CHAR           599
WAIT_DRIVE_DRQ      1431
WAIT_DRIVE_NOT_BUSY  13E0
WAIT_DRIVE_READY    138E
WAIT_FOR_COMPLETE_172  E36
WAIT_FOR_COMPLETE_174  E58
WAIT_FOR_COMPLETE_175  E6A
WAIT_FOR_COMPLETE_177  E8A
WAIT_FOR_COMPLETE_178  E9C
WAIT_FOR_COMPLETE_205  106C
WAIT_FOR_READY_1    CC
WAIT_FOR_READY_100  934
WAIT_FOR_READY_102  95C
WAIT_FOR_READY_105  97E
WAIT_FOR_READY_108  9AE
WAIT_FOR_READY_11   172
WAIT_FOR_READY_111  9CE
WAIT_FOR_READY_113  9F6
WAIT_FOR_READY_115  A18
WAIT_FOR_READY_118  A3A
WAIT_FOR_READY_120  A62
WAIT_FOR_READY_123  A84
WAIT_FOR_READY_125  B00
WAIT_FOR_READY_128  B24
WAIT_FOR_READY_13   19A
WAIT_FOR_READY_130  B4C
WAIT_FOR_READY_133  B6E
WAIT_FOR_READY_134  BA0
WAIT_FOR_READY_136  BBA
WAIT_FOR_READY_140  BFC
WAIT_FOR_READY_143  C68
WAIT_FOR_READY_145  C88
WAIT_FOR_READY_147  CA8
WAIT_FOR_READY_149  CC8
WAIT_FOR_READY_152  CEA
WAIT_FOR_READY_154  D12
WAIT_FOR_READY_156  D34
WAIT_FOR_READY_159  D56
WAIT_FOR_READY_16   1BC
WAIT_FOR_READY_161  D7E
WAIT_FOR_READY_163  DA0
WAIT_FOR_READY_166  DC0
WAIT_FOR_READY_168  DE8
WAIT_FOR_READY_171  E0A
WAIT_FOR_READY_18   1DC
WAIT_FOR_READY_180  EC8
WAIT_FOR_READY_182  EE2
WAIT_FOR_READY_186  F1C
WAIT_FOR_READY_189  F80
WAIT_FOR_READY_192  FA0
WAIT_FOR_READY_194  FC8
WAIT_FOR_READY_196  FEA
WAIT_FOR_READY_199  100C
WAIT_FOR_READY_2    E0
WAIT_FOR_READY_201  1034
WAIT_FOR_READY_204  1056
WAIT_FOR_READY_208  1098
WAIT_FOR_READY_21   1FC
WAIT_FOR_READY_211  10BA
WAIT_FOR_READY_213  10E2
WAIT_FOR_READY_216  1104
WAIT_FOR_READY_218  1124
WAIT_FOR_READY_221  1146
WAIT_FOR_READY_223  116E
WAIT_FOR_READY_226  1190
WAIT_FOR_READY_23   24E
WAIT_FOR_READY_24   262
WAIT_FOR_READY_258  165E
WAIT_FOR_READY_26   27C
WAIT_FOR_READY_260  167C
WAIT_FOR_READY_261  16AA
WAIT_FOR_READY_263  16E2
WAIT_FOR_READY_266  1702
WAIT_FOR_READY_268  172A
WAIT_FOR_READY_271  17A2
WAIT_FOR_READY_273  17E4
WAIT_FOR_READY_275  1810
WAIT_FOR_READY_29   2DA
WAIT_FOR_READY_295  1A86
WAIT_FOR_READY_299  1B08
WAIT_FOR_READY_3    F4
WAIT_FOR_READY_31   366
WAIT_FOR_READY_33   392
WAIT_FOR_READY_36   3BC
WAIT_FOR_READY_38   3E4
WAIT_FOR_READY_39   3FA
WAIT_FOR_READY_40   410
WAIT_FOR_READY_41   424
WAIT_FOR_READY_42   438
WAIT_FOR_READY_43   44C
WAIT_FOR_READY_46   46A
WAIT_FOR_READY_47   48C
WAIT_FOR_READY_49   4A6
WAIT_FOR_READY_53   4E0
WAIT_FOR_READY_54   506
WAIT_FOR_READY_55   52C
WAIT_FOR_READY_56   542
WAIT_FOR_READY_58   574
WAIT_FOR_READY_6    12A
WAIT_FOR_READY_61   5E2
WAIT_FOR_READY_64   62E
WAIT_FOR_READY_67   684
WAIT_FOR_READY_70   6DC
WAIT_FOR_READY_73   73E
WAIT_FOR_READY_76   78A
WAIT_FOR_READY_79   7D6
WAIT_FOR_READY_8    14A
WAIT_FOR_READY_83   82A
WAIT_FOR_READY_85   84A
WAIT_FOR_READY_86   85E
WAIT_FOR_READY_89   87C
WAIT_FOR_READY_91   8A2
WAIT_FOR_READY_95   8F4
WAIT_FOR_READY_97   914
WAIT_FOR_SRECORD    506
WRITE_8             F29
X                   108C
Z                   AA2
_00000000           116
_00000001           2A2
_00000002           2B6
_00000003           5C2
_00000004           894
_00000005           5D0
_00000006           726
_00000007           6C2
_00000008           894
_00000009           81E
_0000000A           894
_0000000B           996
_0000000C           9A2
_0000000D           B82
_0000000E           E40
_0000000F           E62
_00000010           E74
_00000011           E94
_00000012           EA6
_00000013           1076
_00000014           1578
_00000015           1574
_00000016           177C
_00000017           1636
_00000018           1776
_00000019           1742
_0000001A           1690
_0000001B           16C4
_0000001C           1742
_0000001D           1772
_0000001E           1754
_0000001F           175E
_00000020           1768
_00000021           1772
_00000022           177C
_00000023           17B6
_00000024           17B6
_00000025           17FC
_00000026           17D8
_00000027           17FC
_00000028           1B1E
_10000000           56A
_10000001           5AC
_10000002           5D8
_10000003           61A
_10000004           624
_10000005           666
_10000006           67A
_10000007           6BC
_10000008           6C6
_10000009           720
_1000000A           6D2
_1000000B           714
_1000000C           734
_1000000D           776
_1000000E           780
_1000000F           7C2
_10000010           7CC
_10000011           80E
_10000012           898
_10000013           8DA
_10000014           E1E
_10000015           E46
_10000016           1828
_10000017           1AFC
_20000000           30
_20000001           3C
_20000002           4A
_20000003           56
_20000004           48A
_20000005           4CE
_20000006           AB4
_20000007           AC4
_20000008           ADE
_20000009           B84
_2000000A           B9E
_2000000B           BE2
_2000000C           C52
_2000000D           C56
_2000000E           EC6
_2000000F           F0A
_20000010           F6A
_20000011           F6E
_20000012           14BA
_20000013           1550
_20000014           1586
_20000015           17BA
_20000016           1592
_20000017           177E
_20000018           16A8
_20000019           16BE
_2000001A           1AA0
_2000001B           1AEE
