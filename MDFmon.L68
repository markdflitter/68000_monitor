00000008 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 18/04/2021 18:08:19

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          ;PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 00000000                 270  STACK   DC.L 0                                      ; STACK
00000004= 00000008                 271  RESET   DC.L START                                  ; RESET
00000008                           272  
00000008                           273  ; start of program  
00000008                           274  START
00000008  13FC 0000 00E00001       275      MOVE.B #0,DISPLAY
00000010                           276  
00000010                           277  ; reset the UART in case of warm start
00000010  13FC 000A 00C00005       278      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000018  13FC 000A 00C00015       279      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000020                           280      
00000020                           281      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000020  323C 0050                282s     MOVE.W  #$50,D1
00000024  6000 000E                283s     BRA _20000001
00000028                           284s _20000000
00000028  13C1 00C00005            285          MOVE.B D1,DUART_CRA                         ; reset everyting
0000002E  4E71                     286          NOP
00000030                           287      ENDF
00000030  0441 0010                288s     SUB.W   #$10,D1
00000034                           289s _20000001
00000034  B27C 0010                290s     CMP.W   #$10,D1
00000038  6CEE                     291s     BGE _20000000
0000003A                           292  
0000003A                           293      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000003A  323C 0050                294s     MOVE.W  #$50,D1
0000003E  6000 000E                295s     BRA _20000003
00000042                           296s _20000002
00000042  13C1 00C00015            297          MOVE.B D1,DUART_CRB                         ; reset everyting
00000048  4E71                     298          NOP
0000004A                           299      ENDF
0000004A  0441 0010                300s     SUB.W   #$10,D1
0000004E                           301s _20000003
0000004E  B27C 0010                302s     CMP.W   #$10,D1
00000052  6CEE                     303s     BGE _20000002
00000054                           304      
00000054                           305  ;initialise UART
00000054  13FC 0000 00C00009       306      MOVE.B #$0,DUART_ACR
0000005C  13FC 0000 00C0000B       307      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000064  13FC 0000 00C0001B       308      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000006C                           309  
0000006C                           310  ; channel A
0000006C  13FC 0013 00C00001       311      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000074  13FC 0007 00C00001       312      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000007C  13FC 00CC 00C00003       313      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000084  13FC 0005 00C00005       314      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000008C                           315  
0000008C                           316  ; channel B
0000008C  13FC 0013 00C00011       317      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000094  13FC 0007 00C00011       318      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000009C  13FC 00CC 00C00013       319      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000A4  13FC 0005 00C00015       320      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000AC                           321  
000000AC                           322m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000AC                           323m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000AC                 TRUE      324m     IFEQ DEBUG
000000AC  1239 00C00003            325m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000B2  0801 0002                326m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000B6  67F4                     327m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000B8  13FC 0000 00C00007       328m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000C0                           329m     ENDC
000000C0                           330m 
000000C0                 FALSE     331m     IFNE DEBUG
000000C0                           332m     ENDC
000000C0                           333m 
000000C0                           334m     ENDM
000000C0                           335m     PRINT_CHAR #0,D1
000000C0                           336m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000C0                 TRUE      337m     IFEQ DEBUG
000000C0  1239 00C00003            338m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C6  0801 0002                339m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000CA  67F4                     340m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000CC  13FC 0000 00C00007       341m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000D4                           342m     ENDC
000000D4                           343m 
000000D4                 FALSE     344m     IFNE DEBUG
000000D4                           345m     ENDC
000000D4                           346m 
000000D4                           347m     ENDM
000000D4                           348m     PRINT_CHAR #0,D1
000000D4                           349m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000D4                 TRUE      350m     IFEQ DEBUG
000000D4  1239 00C00003            351m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000DA  0801 0002                352m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000DE  67F4                     353m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000E0  13FC 0000 00C00007       354m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E8                           355m     ENDC
000000E8                           356m 
000000E8                 FALSE     357m     IFNE DEBUG
000000E8                           358m     ENDC
000000E8                           359m 
000000E8                           360m     ENDM
000000E8                           361  
000000E8  13FC 0001 00E00001       362      MOVE.B #1,DISPLAY
000000F0                           363  
000000F0                           364m     PRINT_CRLF D1,A0
000000F0  41FA 1091                365m     LEA CRLF(PC),A0
000000F4                           366mm     PRINT_STR A0,D1
000000F4                           367mm LOOP_5
000000F4  0C10 0000                368mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000000F8  6700 0016                369mm     BEQ EXIT_5
000000FC                           370mmm     PRINT_CHAR (A0)+,D1
000000FC                           371mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000FC                 TRUE      372mmm     IFEQ DEBUG
000000FC  1239 00C00003            373mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000102  0801 0002                374mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000106  67F4                     375mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000108  13D8 00C00007            376mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000010E                           377mmm     ENDC
0000010E                           378mmm 
0000010E                 FALSE     379mmm     IFNE DEBUG
0000010E                           380mmm     ENDC
0000010E                           381mmm 
0000010E                           382mmm     ENDM
0000010E  60E4                     383mm     BRA LOOP_5
00000110                           384mm EXIT_5
00000110                           385mm     ENDM
00000110                           386m     ENDM
00000110  41FA 1095                387      LEA VERSION(PC),A0
00000114                           388m     PRINT_STR A0,D3
00000114                           389m LOOP_7
00000114  0C10 0000                390m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000118  6700 0016                391m     BEQ EXIT_7
0000011C                           392mm     PRINT_CHAR (A0)+,D3
0000011C                           393mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000011C                 TRUE      394mm     IFEQ DEBUG
0000011C  1639 00C00003            395mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000122  0803 0002                396mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000126  67F4                     397mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000128  13D8 00C00007            398mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000012E                           399mm     ENDC
0000012E                           400mm 
0000012E                 FALSE     401mm     IFNE DEBUG
0000012E                           402mm     ENDC
0000012E                           403mm 
0000012E                           404mm     ENDM
0000012E  60E4                     405m     BRA LOOP_7
00000130                           406m EXIT_7
00000130                           407m     ENDM
00000130                           408  
00000130  41FA 0EA4                409      LEA HELPPROMPT(PC),A0
00000134                           410m     PRINT_STR A0,D3
00000134                           411m LOOP_9
00000134  0C10 0000                412m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000138  6700 0016                413m     BEQ EXIT_9
0000013C                           414mm     PRINT_CHAR (A0)+,D3
0000013C                           415mm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000013C                 TRUE      416mm     IFEQ DEBUG
0000013C  1639 00C00003            417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000142  0803 0002                418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000146  67F4                     419mm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000148  13D8 00C00007            420mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000014E                           421mm     ENDC
0000014E                           422mm 
0000014E                 FALSE     423mm     IFNE DEBUG
0000014E                           424mm     ENDC
0000014E                           425mm 
0000014E                           426mm     ENDM
0000014E  60E4                     427m     BRA LOOP_9
00000150                           428m EXIT_9
00000150                           429m     ENDM
00000150                           430  
00000150                           431m     PRINT_CRLF D3,A0
00000150  41FA 1031                432m     LEA CRLF(PC),A0
00000154                           433mm     PRINT_STR A0,D3
00000154                           434mm LOOP_12
00000154  0C10 0000                435mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000158  6700 0016                436mm     BEQ EXIT_12
0000015C                           437mmm     PRINT_CHAR (A0)+,D3
0000015C                           438mmm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000015C                 TRUE      439mmm     IFEQ DEBUG
0000015C  1639 00C00003            440mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000162  0803 0002                441mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000166  67F4                     442mmm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000168  13D8 00C00007            443mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000016E                           444mmm     ENDC
0000016E                           445mmm 
0000016E                 FALSE     446mmm     IFNE DEBUG
0000016E                           447mmm     ENDC
0000016E                           448mmm 
0000016E                           449mmm     ENDM
0000016E  60E4                     450mm     BRA LOOP_12
00000170                           451mm EXIT_12
00000170                           452mm     ENDM
00000170                           453m     ENDM
00000170                           454  
00000170  7E00                     455      MOVE.L #0,D7                                    ; address accumulator
00000172                           456  
00000172  13FC 0002 00E00001       457      MOVE.B #2,DISPLAY
0000017A                           458  MAIN_LOOP
0000017A  41FA 100A                459      LEA PROMPT(PC),A0
0000017E                           460m     PRINT_STR A0,D3
0000017E                           461m LOOP_14
0000017E  0C10 0000                462m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000182  6700 0016                463m     BEQ EXIT_14
00000186                           464mm     PRINT_CHAR (A0)+,D3
00000186                           465mm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000186                 TRUE      466mm     IFEQ DEBUG
00000186  1639 00C00003            467mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000018C  0803 0002                468mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000190  67F4                     469mm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
00000192  13D8 00C00007            470mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000198                           471mm     ENDC
00000198                           472mm 
00000198                 FALSE     473mm     IFNE DEBUG
00000198                           474mm     ENDC
00000198                           475mm 
00000198                           476mm     ENDM
00000198  60E4                     477m     BRA LOOP_14
0000019A                           478m EXIT_14
0000019A                           479m     ENDM
0000019A                           480  
0000019A                           481  GET_INPUT
0000019A                           482m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000019A                           483m WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019A                 TRUE      484m     IFEQ DEBUG
0000019A  1639 00C00003            485m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001A0  0803 0000                486m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000001A4  67F4                     487m         BEQ WAIT_FOR_READY_16                       ; NOTHING, CHECK AGAIN
000001A6                           488m     ENDC
000001A6                           489m 
000001A6                           490mm     READ_CHAR D2
000001A6                 TRUE      491mm     IFEQ DEBUG
000001A6  1439 00C00007            492mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000001AC                           493mm     ENDC
000001AC                 FALSE     494mm     IFNE DEBUG
000001AC                           495mm     ENDC
000001AC                           496mm 
000001AC  B43C 001B                497mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000001B0  6700 FE56                498mm     BEQ START
000001B4                           499mm     ENDM
000001B4                           500m 
000001B4                 TRUE      501m     IFEQ DEBUG
000001B4                           502mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000001B4                           503mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001B4                 TRUE      504mm     IFEQ DEBUG
000001B4  1639 00C00003            505mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001BA  0803 0002                506mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001BE  67F4                     507mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C0  13C2 00C00007            508mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001C6                           509mm     ENDC
000001C6                           510mm 
000001C6                 FALSE     511mm     IFNE DEBUG
000001C6                           512mm     ENDC
000001C6                           513mm 
000001C6                           514mm     ENDM
000001C6                           515m     ENDC
000001C6                           516m     ENDM
000001C6                           517  
000001C6                           518      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000001C6  B43C 0030                519s     CMP.B   #'0',D2
000001CA  6D00 000E                520s     BLT _00000000
000001CE  B43C 0039                521s     CMP.B   #'9',D2
000001D2  6E00 0006                522s     BGT _00000000
000001D6  6000 0DE0                523          BRA HEX_DIGIT
000001DA                           524      ENDI
000001DA                           525s _00000000
000001DA                           526      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000001DA  B43C 0041                527s     CMP.B   #'A',D2
000001DE  6D00 000E                528s     BLT _00000001
000001E2  B43C 0046                529s     CMP.B   #'F',D2
000001E6  6E00 0006                530s     BGT _00000001
000001EA  6000 0DCC                531          BRA HEX_DIGIT
000001EE                           532      ENDI
000001EE                           533s _00000001
000001EE                           534  
000001EE  B43C 0077                535      CMP.B #'w',D2
000001F2  6700 0192                536      BEQ W
000001F6                           537  
000001F6  B43C 006C                538      CMP.B #'l',D2
000001FA  6700 0922                539      BEQ L 
000001FE                           540  
000001FE  B43C 0070                541      CMP.B #'p',D2
00000202  6700 0B4A                542      BEQ P
00000206                           543  
00000206  B43C 006D                544      CMP.B #'m',D2
0000020A  6700 0D14                545      BEQ M
0000020E                           546  
0000020E                           547m     PRINT_CRLF D3,A0
0000020E  41FA 0F73                548m     LEA CRLF(PC),A0
00000212                           549mm     PRINT_STR A0,D3
00000212                           550mm LOOP_20
00000212  0C10 0000                551mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000216  6700 0016                552mm     BEQ EXIT_20
0000021A                           553mmm     PRINT_CHAR (A0)+,D3
0000021A                           554mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      555mmm     IFEQ DEBUG
0000021A  1639 00C00003            556mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0002                557mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000224  67F4                     558mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
00000226  13D8 00C00007            559mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000022C                           560mmm     ENDC
0000022C                           561mmm 
0000022C                 FALSE     562mmm     IFNE DEBUG
0000022C                           563mmm     ENDC
0000022C                           564mmm 
0000022C                           565mmm     ENDM
0000022C  60E4                     566mm     BRA LOOP_20
0000022E                           567mm EXIT_20
0000022E                           568mm     ENDM
0000022E                           569m     ENDM
0000022E                           570   
0000022E  B43C 003F                571      CMP.B #'?',D2
00000232  6700 004E                572      BEQ H
00000236                           573   
00000236  B43C 0076                574      CMP.B #'v',D2
0000023A  6700 004E                575      BEQ V
0000023E                           576      
0000023E  B43C 0072                577      CMP.B #'r',D2
00000242  6700 006A                578      BEQ R
00000246                           579  
00000246  B43C 0073                580      CMP.B #'s',D2
0000024A  6700 01AE                581      BEQ S
0000024E                           582  
0000024E  B43C 0067                583      CMP.B #'g',D2
00000252  6700 07AA                584      BEQ G   
00000256                           585  
00000256  B43C 007A                586      CMP.B #'z',D2
0000025A  6700 07D2                587      BEQ Z   
0000025E                           588  
0000025E  41FA 0E84                589      LEA HUH(PC),A0
00000262                           590m     PRINT_STR A0,D3
00000262                           591m LOOP_22
00000262  0C10 0000                592m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000266  6700 0016                593m     BEQ EXIT_22
0000026A                           594mm     PRINT_CHAR (A0)+,D3
0000026A                           595mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000026A                 TRUE      596mm     IFEQ DEBUG
0000026A  1639 00C00003            597mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000270  0803 0002                598mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000274  67F4                     599mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000276  13D8 00C00007            600mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000027C                           601mm     ENDC
0000027C                           602mm 
0000027C                 FALSE     603mm     IFNE DEBUG
0000027C                           604mm     ENDC
0000027C                           605mm 
0000027C                           606mm     ENDM
0000027C  60E4                     607m     BRA LOOP_22
0000027E                           608m EXIT_22
0000027E                           609m     ENDM
0000027E                           610  
0000027E  6000 FEFA                611      BRA MAIN_LOOP
00000282                           612  
00000282                           613  ; commands
00000282                           614  H
00000282  41FA 0D65                615      LEA HELP(PC),A0
00000286  6000 0006                616      BRA PRINTSTR
0000028A                           617  
0000028A                           618  V
0000028A  41FA 0F1B                619      LEA VERSION(PC),A0
0000028E                           620  PRINTSTR
0000028E                           621m     PRINT_STR A0,D3    
0000028E                           622m LOOP_24
0000028E  0C10 0000                623m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000292  6700 0016                624m     BEQ EXIT_24
00000296                           625mm     PRINT_CHAR (A0)+,D3
00000296                           626mm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000296                 TRUE      627mm     IFEQ DEBUG
00000296  1639 00C00003            628mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000029C  0803 0002                629mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A0  67F4                     630mm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
000002A2  13D8 00C00007            631mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002A8                           632mm     ENDC
000002A8                           633mm 
000002A8                 FALSE     634mm     IFNE DEBUG
000002A8                           635mm     ENDC
000002A8                           636mm 
000002A8                           637mm     ENDM
000002A8  60E4                     638m     BRA LOOP_24
000002AA                           639m EXIT_24
000002AA                           640m     ENDM
000002AA  6000 FECE                641      BRA MAIN_LOOP
000002AE                           642  
000002AE                           643  R
000002AE  2047                     644      MOVE.L D7,A0                                    ; address accumulator -> address register
000002B0  7E00                     645      MOVE.L #0,D7                                    ;clear the now used address accumulator
000002B2  2410                     646      MOVE.L (A0),D2                                  ; read the memory and print it
000002B4                           647m     PRINT_REG D2,D3,D4,D5,A0
000002B4  41FA 0ED3                648m     LEA OX(PC),A0
000002B8                           649mm     PRINT_STR A0,D3
000002B8                           650mm LOOP_27
000002B8  0C10 0000                651mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BC  6700 0016                652mm     BEQ EXIT_27
000002C0                           653mmm     PRINT_CHAR (A0)+,D3
000002C0                           654mmm WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002C0                 TRUE      655mmm     IFEQ DEBUG
000002C0  1639 00C00003            656mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002C6  0803 0002                657mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002CA  67F4                     658mmm         BEQ WAIT_FOR_READY_28                       ; NO SPACE, CHECK AGAIN
000002CC  13D8 00C00007            659mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D2                           660mmm     ENDC
000002D2                           661mmm 
000002D2                 FALSE     662mmm     IFNE DEBUG
000002D2                           663mmm     ENDC
000002D2                           664mmm 
000002D2                           665mmm     ENDM
000002D2  60E4                     666mm     BRA LOOP_27
000002D4                           667mm EXIT_27
000002D4                           668mm     ENDM
000002D4  7A07                     669m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000002D6                           670m LOOP_26
000002D6                           671mm     BIN2HEX D2,D4,A0
000002D6  41FA 0E70                672mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000002DA  E99A                     673mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000002DC  1802                     674mm     MOVE.B D2,D4
000002DE  0284 0000000F            675mm     ANDI.L #$F,D4
000002E4  1830 4000                676mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000002E8                           677mm     ENDM
000002E8                           678mm     PRINT_CHAR D4,D3
000002E8                           679mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002E8                 TRUE      680mm     IFEQ DEBUG
000002E8  1639 00C00003            681mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002EE  0803 0002                682mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002F2  67F4                     683mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000002F4  13C4 00C00007            684mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002FA                           685mm     ENDC
000002FA                           686mm 
000002FA                 FALSE     687mm     IFNE DEBUG
000002FA                           688mm     ENDC
000002FA                           689mm 
000002FA                           690mm     ENDM
000002FA  57CD FFDA                691m     DBEQ D5,LOOP_26
000002FE                           692m     ENDM
000002FE                           693      
000002FE                           694m     PRINT_CHAR #32,D3
000002FE                           695m WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      696m     IFEQ DEBUG
000002FE  1639 00C00003            697m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                698m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     699m         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
0000030A  13FC 0020 00C00007       700m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000312                           701m     ENDC
00000312                           702m 
00000312                 FALSE     703m     IFNE DEBUG
00000312                           704m     ENDC
00000312                           705m 
00000312                           706m     ENDM
00000312                           707  
00000312  E19A                     708      ROL.L #8,D2
00000314                           709m     PRINT_CHAR D2,D3
00000314                           710m WAIT_FOR_READY_32                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000314                 TRUE      711m     IFEQ DEBUG
00000314  1639 00C00003            712m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000031A  0803 0002                713m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000031E  67F4                     714m         BEQ WAIT_FOR_READY_32                       ; NO SPACE, CHECK AGAIN
00000320  13C2 00C00007            715m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000326                           716m     ENDC
00000326                           717m 
00000326                 FALSE     718m     IFNE DEBUG
00000326                           719m     ENDC
00000326                           720m 
00000326                           721m     ENDM
00000326  E19A                     722      ROL.L #8,D2
00000328                           723m     PRINT_CHAR D2,D3
00000328                           724m WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      725m     IFEQ DEBUG
00000328  1639 00C00003            726m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0002                727m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000332  67F4                     728m         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000334  13C2 00C00007            729m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000033A                           730m     ENDC
0000033A                           731m 
0000033A                 FALSE     732m     IFNE DEBUG
0000033A                           733m     ENDC
0000033A                           734m 
0000033A                           735m     ENDM
0000033A  E19A                     736      ROL.L #8,D2
0000033C                           737m     PRINT_CHAR D2,D3
0000033C                           738m WAIT_FOR_READY_34                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033C                 TRUE      739m     IFEQ DEBUG
0000033C  1639 00C00003            740m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000342  0803 0002                741m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000346  67F4                     742m         BEQ WAIT_FOR_READY_34                       ; NO SPACE, CHECK AGAIN
00000348  13C2 00C00007            743m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000034E                           744m     ENDC
0000034E                           745m 
0000034E                 FALSE     746m     IFNE DEBUG
0000034E                           747m     ENDC
0000034E                           748m 
0000034E                           749m     ENDM
0000034E  E19A                     750      ROL.L #8,D2
00000350                           751m     PRINT_CHAR D2,D3
00000350                           752m WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      753m     IFEQ DEBUG
00000350  1639 00C00003            754m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                755m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     756m         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
0000035C  13C2 00C00007            757m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000362                           758m     ENDC
00000362                           759m 
00000362                 FALSE     760m     IFNE DEBUG
00000362                           761m     ENDC
00000362                           762m 
00000362                           763m     ENDM
00000362                           764  
00000362                           765m     PRINT_CRLF D3,A0
00000362  41FA 0E1F                766m     LEA CRLF(PC),A0
00000366                           767mm     PRINT_STR A0,D3
00000366                           768mm LOOP_37
00000366  0C10 0000                769mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000036A  6700 0016                770mm     BEQ EXIT_37
0000036E                           771mmm     PRINT_CHAR (A0)+,D3
0000036E                           772mmm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000036E                 TRUE      773mmm     IFEQ DEBUG
0000036E  1639 00C00003            774mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000374  0803 0002                775mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000378  67F4                     776mmm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
0000037A  13D8 00C00007            777mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000380                           778mmm     ENDC
00000380                           779mmm 
00000380                 FALSE     780mmm     IFNE DEBUG
00000380                           781mmm     ENDC
00000380                           782mmm 
00000380                           783mmm     ENDM
00000380  60E4                     784mm     BRA LOOP_37
00000382                           785mm EXIT_37
00000382                           786mm     ENDM
00000382                           787m     ENDM
00000382                           788      
00000382  6000 FDF6                789      BRA MAIN_LOOP
00000386                           790  
00000386                           791  W
00000386  3C3C 0007                792      MOVE #7,D6                                      ; 7 bytes left to read
0000038A                           793      
0000038A                           794  READ_DATA_TO_POKE
0000038A  E98D                     795      LSL.L #4,D5                                     ; make what we have so far more significant
0000038C                           796m     WAIT_CHAR D2,D3                                 ; next character -> D2
0000038C                           797m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000038C                 TRUE      798m     IFEQ DEBUG
0000038C  1639 00C00003            799m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000392  0803 0000                800m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000396  67F4                     801m         BEQ WAIT_FOR_READY_39                       ; NOTHING, CHECK AGAIN
00000398                           802m     ENDC
00000398                           803m 
00000398                           804mm     READ_CHAR D2
00000398                 TRUE      805mm     IFEQ DEBUG
00000398  1439 00C00007            806mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000039E                           807mm     ENDC
0000039E                 FALSE     808mm     IFNE DEBUG
0000039E                           809mm     ENDC
0000039E                           810mm 
0000039E  B43C 001B                811mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000003A2  6700 FC64                812mm     BEQ START
000003A6                           813mm     ENDM
000003A6                           814m 
000003A6                 TRUE      815m     IFEQ DEBUG
000003A6                           816mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000003A6                           817mm WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003A6                 TRUE      818mm     IFEQ DEBUG
000003A6  1639 00C00003            819mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003AC  0803 0002                820mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003B0  67F4                     821mm         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003B2  13C2 00C00007            822mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003B8                           823mm     ENDC
000003B8                           824mm 
000003B8                 FALSE     825mm     IFNE DEBUG
000003B8                           826mm     ENDC
000003B8                           827mm 
000003B8                           828mm     ENDM
000003B8                           829m     ENDC
000003B8                           830m     ENDM
000003B8                           831m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000003B8  41FA 0D9E                832m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000003BC  0402 0030                833m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000003C0  C4BC 000000FF            834m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000003C6  1430 2000                835m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000003CA                           836m     ENDM
000003CA  8A02                     837      OR.B D2,D5
000003CC  57CE FFBC                838      DBEQ D6,READ_DATA_TO_POKE
000003D0                           839      
000003D0  2047                     840      MOVE.L D7,A0                                    ; address accumulator -> address register
000003D2  7E00                     841      MOVE.L #0,D7                                    ; clear the now used address accumulator
000003D4                           842      
000003D4  2085                     843      MOVE.L D5,(A0)                                  ; write the data
000003D6                           844  
000003D6                           845m     PRINT_CRLF D3,A0
000003D6  41FA 0DAB                846m     LEA CRLF(PC),A0
000003DA                           847mm     PRINT_STR A0,D3
000003DA                           848mm LOOP_44
000003DA  0C10 0000                849mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003DE  6700 0016                850mm     BEQ EXIT_44
000003E2                           851mmm     PRINT_CHAR (A0)+,D3
000003E2                           852mmm WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003E2                 TRUE      853mmm     IFEQ DEBUG
000003E2  1639 00C00003            854mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E8  0803 0002                855mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003EC  67F4                     856mmm         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
000003EE  13D8 00C00007            857mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003F4                           858mmm     ENDC
000003F4                           859mmm 
000003F4                 FALSE     860mmm     IFNE DEBUG
000003F4                           861mmm     ENDC
000003F4                           862mmm 
000003F4                           863mmm     ENDM
000003F4  60E4                     864mm     BRA LOOP_44
000003F6                           865mm EXIT_44
000003F6                           866mm     ENDM
000003F6                           867m     ENDM
000003F6  6000 FD82                868      BRA MAIN_LOOP
000003FA                           869  
000003FA                           870  ; register map for S
000003FA                           871  ; A0 - start address
000003FA                           872  ; A1 - offset
000003FA                           873  ; A2 - next address to write
000003FA                           874  ; A3 - next location (jmp)
000003FA                           875  ; A4 - Working Address Register
000003FA                           876  ; D0 - record count
000003FA                           877  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000003FA                           878  ; D2 - checksum
000003FA                           879  ; D3 - data byte count
000003FA                           880  ; D4 - read address, moved into A2
000003FA                           881  ; D5 - temp
000003FA                           882  ; D6 - temp
000003FA                           883  ; D7 - temp
000003FA                           884  S
000003FA  2078 0000                885      MOVE.L 0,A0                                     ; start address -> A0
000003FE  2247                     886      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000400                           887      
00000400  7000                     888      MOVE.L #0,D0                                    ; count of records read -> D0
00000402                           889          
00000402                           890  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000402                           891m     DOWNLOAD D1
00000402                           892m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000402                           893m 
00000402  1239 00C00003            894m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000408  0801 0000                895m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000040C  6700 0010                896m     BEQ CONTINUE_46                                 ; NOTHING, CONTINUE
00000410                           897m 
00000410                           898mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000410                 TRUE      899mm     IFEQ DEBUG
00000410  1239 00C00007            900mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000416                           901mm     ENDC
00000416                 FALSE     902mm     IFNE DEBUG
00000416                           903mm     ENDC
00000416                           904mm 
00000416  B23C 001B                905mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000041A  6700 FBEC                906mm     BEQ START
0000041E                           907mm     ENDM
0000041E                           908m CONTINUE_46
0000041E  1239 00C00013            909m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000424  0801 0000                910m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000428  67D8                     911m     BEQ WAIT_FOR_READY_46                           ; NOTHING, CHECK AGAIN
0000042A                           912m     
0000042A  1239 00C00017            913m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000430  13C1 00E00001            914m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000436                           915m 
00000436                           916m     ENDM
00000436  B23C 0053                917      CMP.B #'S',D1                                   ; found S?
0000043A  66C6                     918      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000043C                           919      
0000043C                           920      ;PRINT_CHAR #'S',D5                             ; print the S
0000043C  5280                     921      ADD.L #1,D0                                     ; read another S record, increment count
0000043E                           922      
0000043E                           923m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000043E                           924m WAIT_FOR_READY_48                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000043E                           925m 
0000043E  1239 00C00003            926m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000444  0801 0000                927m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000448  6700 0010                928m     BEQ CONTINUE_48                                 ; NOTHING, CONTINUE
0000044C                           929m 
0000044C                           930mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000044C                 TRUE      931mm     IFEQ DEBUG
0000044C  1239 00C00007            932mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000452                           933mm     ENDC
00000452                 FALSE     934mm     IFNE DEBUG
00000452                           935mm     ENDC
00000452                           936mm 
00000452  B23C 001B                937mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000456  6700 FBB0                938mm     BEQ START
0000045A                           939mm     ENDM
0000045A                           940m CONTINUE_48
0000045A  1239 00C00013            941m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000460  0801 0000                942m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000464  67D8                     943m     BEQ WAIT_FOR_READY_48                           ; NOTHING, CHECK AGAIN
00000466                           944m     
00000466  1239 00C00017            945m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000046C  13C1 00E00001            946m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000472                           947m 
00000472                           948m     ENDM
00000472                           949      ;PRINT_CHAR D1,D5
00000472                           950  
00000472  7400                     951      MOVE.L #0,D2                                    ; clear the checksum
00000474                           952  
00000474                           953m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000474  1E3C 0002                954m     MOVE.B #2,D7
00000478                           955m     WHILE.B D7 <GT> 0 DO
00000478                           956ms _10000000
00000478  BE38 0000                957ms     CMP.B   0,D7
0000047C  6F00 0050                958ms     BLE _10000001
00000480  E98B                     959m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000482                           960mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000482                           961mm WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000482                           962mm 
00000482  1A39 00C00003            963mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000488  0805 0000                964mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000048C  6700 0010                965mm     BEQ CONTINUE_51                                 ; NOTHING, CONTINUE
00000490                           966mm 
00000490                           967mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000490                 TRUE      968mmm     IFEQ DEBUG
00000490  1A39 00C00007            969mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000496                           970mmm     ENDC
00000496                 FALSE     971mmm     IFNE DEBUG
00000496                           972mmm     ENDC
00000496                           973mmm 
00000496  BA3C 001B                974mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000049A  6700 FB6C                975mmm     BEQ START
0000049E                           976mmm     ENDM
0000049E                           977mm CONTINUE_51
0000049E  1A39 00C00013            978mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000004A4  0805 0000                979mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000004A8  67D8                     980mm     BEQ WAIT_FOR_READY_51                           ; NOTHING, CHECK AGAIN
000004AA                           981mm     
000004AA  1A39 00C00017            982mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000004B0  13C5 00E00001            983mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000004B6                           984mm 
000004B6                           985mm     ENDM
000004B6                           986m         ;PRINT_CHAR D5,D6
000004B6                           987mm         HEX2BIN D5,D5,A4
000004B6  49FA 0CA0                988mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000004BA  0405 0030                989mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000004BE  CABC 000000FF            990mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000004C4  1A34 5000                991mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000004C8                           992mm     ENDM
000004C8  8605                     993m         OR.B D5,D3
000004CA  5307                     994m         SUB.B #1,D7
000004CC                           995m     ENDW
000004CC  60AA                     996ms     BRA _10000000
000004CE                           997ms _10000001
000004CE                           998m 
000004CE  7A00                     999m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000004D0  1A03                    1000m     MOVE.B D3,D5
000004D2  D483                    1001m     ADD.L D3,D2
000004D4                          1002m 
000004D4                          1003m     ENDM
000004D4                          1004  
000004D4                          1005      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000004D4  B23C 0030               1006s     CMP.B   #'0',D1
000004D8  6600 000A               1007s     BNE.L   _00000002
000004DC                          1008          ;PRINT_CRLF D5,A4
000004DC  6000 FF24               1009          BRA WAIT_FOR_SRECORD
000004E0                          1010      ELSE
000004E0  6000 0340               1011s     BRA _00000003
000004E4                          1012s _00000002
000004E4                          1013          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000004E4  B23C 0031               1014s     CMP.B   #'1',D1
000004E8  6708                    1015s     BEQ.S   _00000004
000004EA  B23C 0032               1016s     CMP.B   #'2',D1
000004EE  6600 01A8               1017s     BNE.L   _00000005
000004F2                          1018s _00000004
000004F2  5783                    1019              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000004F4                          1020  
000004F4  7800                    1021              MOVE.L #0,D4                            ; read two bytes of address
000004F6                          1022m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000004F6  1E3C 0002               1023m     MOVE.B #2,D7
000004FA                          1024m     WHILE.B D7 <GT> 0 DO
000004FA                          1025ms _10000002
000004FA  BE38 0000               1026ms     CMP.B   0,D7
000004FE  6F00 0050               1027ms     BLE _10000003
00000502  E98C                    1028m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000504                          1029mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000504                          1030mm WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000504                          1031mm 
00000504  1A39 00C00003           1032mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000050A  0805 0000               1033mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000050E  6700 0010               1034mm     BEQ CONTINUE_55                                 ; NOTHING, CONTINUE
00000512                          1035mm 
00000512                          1036mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000512                 TRUE     1037mmm     IFEQ DEBUG
00000512  1A39 00C00007           1038mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000518                          1039mmm     ENDC
00000518                 FALSE    1040mmm     IFNE DEBUG
00000518                          1041mmm     ENDC
00000518                          1042mmm 
00000518  BA3C 001B               1043mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000051C  6700 FAEA               1044mmm     BEQ START
00000520                          1045mmm     ENDM
00000520                          1046mm CONTINUE_55
00000520  1A39 00C00013           1047mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000526  0805 0000               1048mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000052A  67D8                    1049mm     BEQ WAIT_FOR_READY_55                           ; NOTHING, CHECK AGAIN
0000052C                          1050mm     
0000052C  1A39 00C00017           1051mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000532  13C5 00E00001           1052mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000538                          1053mm 
00000538                          1054mm     ENDM
00000538                          1055m         ;PRINT_CHAR D5,D6
00000538                          1056mm         HEX2BIN D5,D5,A4
00000538  49FA 0C1E               1057mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000053C  0405 0030               1058mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000540  CABC 000000FF           1059mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000546  1A34 5000               1060mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000054A                          1061mm     ENDM
0000054A  8805                    1062m         OR.B D5,D4
0000054C  5307                    1063m         SUB.B #1,D7
0000054E                          1064m     ENDW
0000054E  60AA                    1065ms     BRA _10000002
00000550                          1066ms _10000003
00000550                          1067m 
00000550  7A00                    1068m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000552  1A04                    1069m     MOVE.B D4,D5
00000554  D484                    1070m     ADD.L D4,D2
00000556                          1071m 
00000556                          1072m     ENDM
00000556                          1073m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000556  1E3C 0002               1074m     MOVE.B #2,D7
0000055A                          1075m     WHILE.B D7 <GT> 0 DO
0000055A                          1076ms _10000004
0000055A  BE38 0000               1077ms     CMP.B   0,D7
0000055E  6F00 0050               1078ms     BLE _10000005
00000562  E98C                    1079m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000564                          1080mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000564                          1081mm WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                          1082mm 
00000564  1A39 00C00003           1083mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000056A  0805 0000               1084mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000056E  6700 0010               1085mm     BEQ CONTINUE_59                                 ; NOTHING, CONTINUE
00000572                          1086mm 
00000572                          1087mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000572                 TRUE     1088mmm     IFEQ DEBUG
00000572  1A39 00C00007           1089mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000578                          1090mmm     ENDC
00000578                 FALSE    1091mmm     IFNE DEBUG
00000578                          1092mmm     ENDC
00000578                          1093mmm 
00000578  BA3C 001B               1094mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000057C  6700 FA8A               1095mmm     BEQ START
00000580                          1096mmm     ENDM
00000580                          1097mm CONTINUE_59
00000580  1A39 00C00013           1098mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000586  0805 0000               1099mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000058A  67D8                    1100mm     BEQ WAIT_FOR_READY_59                           ; NOTHING, CHECK AGAIN
0000058C                          1101mm     
0000058C  1A39 00C00017           1102mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000592  13C5 00E00001           1103mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000598                          1104mm 
00000598                          1105mm     ENDM
00000598                          1106m         ;PRINT_CHAR D5,D6
00000598                          1107mm         HEX2BIN D5,D5,A4
00000598  49FA 0BBE               1108mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000059C  0405 0030               1109mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005A0  CABC 000000FF           1110mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000005A6  1A34 5000               1111mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000005AA                          1112mm     ENDM
000005AA  8805                    1113m         OR.B D5,D4
000005AC  5307                    1114m         SUB.B #1,D7
000005AE                          1115m     ENDW
000005AE  60AA                    1116ms     BRA _10000004
000005B0                          1117ms _10000005
000005B0                          1118m 
000005B0  7A00                    1119m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000005B2  1A04                    1120m     MOVE.B D4,D5
000005B4  D484                    1121m     ADD.L D4,D2
000005B6                          1122m 
000005B6                          1123m     ENDM
000005B6                          1124  
000005B6                          1125              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000005B6  B23C 0032               1126s     CMP.B   #'2',D1
000005BA  6600 0064               1127s     BNE.L   _00000006
000005BE  5383                    1128                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000005C0                          1129m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000005C0  1E3C 0002               1130m     MOVE.B #2,D7
000005C4                          1131m     WHILE.B D7 <GT> 0 DO
000005C4                          1132ms _10000006
000005C4  BE38 0000               1133ms     CMP.B   0,D7
000005C8  6F00 0050               1134ms     BLE _10000007
000005CC  E98C                    1135m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005CE                          1136mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005CE                          1137mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                          1138mm 
000005CE  1A39 00C00003           1139mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005D4  0805 0000               1140mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005D8  6700 0010               1141mm     BEQ CONTINUE_63                                 ; NOTHING, CONTINUE
000005DC                          1142mm 
000005DC                          1143mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005DC                 TRUE     1144mmm     IFEQ DEBUG
000005DC  1A39 00C00007           1145mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005E2                          1146mmm     ENDC
000005E2                 FALSE    1147mmm     IFNE DEBUG
000005E2                          1148mmm     ENDC
000005E2                          1149mmm 
000005E2  BA3C 001B               1150mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005E6  6700 FA20               1151mmm     BEQ START
000005EA                          1152mmm     ENDM
000005EA                          1153mm CONTINUE_63
000005EA  1A39 00C00013           1154mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000005F0  0805 0000               1155mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005F4  67D8                    1156mm     BEQ WAIT_FOR_READY_63                           ; NOTHING, CHECK AGAIN
000005F6                          1157mm     
000005F6  1A39 00C00017           1158mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000005FC  13C5 00E00001           1159mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000602                          1160mm 
00000602                          1161mm     ENDM
00000602                          1162m         ;PRINT_CHAR D5,D6
00000602                          1163mm         HEX2BIN D5,D5,A4
00000602  49FA 0B54               1164mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000606  0405 0030               1165mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000060A  CABC 000000FF           1166mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000610  1A34 5000               1167mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000614                          1168mm     ENDM
00000614  8805                    1169m         OR.B D5,D4
00000616  5307                    1170m         SUB.B #1,D7
00000618                          1171m     ENDW
00000618  60AA                    1172ms     BRA _10000006
0000061A                          1173ms _10000007
0000061A                          1174m 
0000061A  7A00                    1175m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000061C  1A04                    1176m     MOVE.B D4,D5
0000061E  D484                    1177m     ADD.L D4,D2
00000620                          1178m 
00000620                          1179m     ENDM
00000620                          1180              ENDI
00000620                          1181s _00000006
00000620                          1182  
00000620  2444                    1183              MOVE.L D4,A2                            ; put the address in an address register
00000622  D5C9                    1184              ADD.L A1,A2                             ; add in the offset
00000624                          1185  
00000624                          1186              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000624                          1187s _10000008
00000624  B63C 0000               1188s     CMP.B   #0,D3
00000628  6F00 0068               1189s     BLE _10000009
0000062C                          1190m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
0000062C  1E3C 0002               1191m     MOVE.B #2,D7
00000630                          1192m     WHILE.B D7 <GT> 0 DO
00000630                          1193ms _1000000A
00000630  BE38 0000               1194ms     CMP.B   0,D7
00000634  6F00 0050               1195ms     BLE _1000000B
00000638  E989                    1196m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
0000063A                          1197mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000063A                          1198mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063A                          1199mm 
0000063A  1A39 00C00003           1200mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000640  0805 0000               1201mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000644  6700 0010               1202mm     BEQ CONTINUE_67                                 ; NOTHING, CONTINUE
00000648                          1203mm 
00000648                          1204mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000648                 TRUE     1205mmm     IFEQ DEBUG
00000648  1A39 00C00007           1206mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000064E                          1207mmm     ENDC
0000064E                 FALSE    1208mmm     IFNE DEBUG
0000064E                          1209mmm     ENDC
0000064E                          1210mmm 
0000064E  BA3C 001B               1211mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000652  6700 F9B4               1212mmm     BEQ START
00000656                          1213mmm     ENDM
00000656                          1214mm CONTINUE_67
00000656  1A39 00C00013           1215mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000065C  0805 0000               1216mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000660  67D8                    1217mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000662                          1218mm     
00000662  1A39 00C00017           1219mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000668  13C5 00E00001           1220mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000066E                          1221mm 
0000066E                          1222mm     ENDM
0000066E                          1223m         ;PRINT_CHAR D5,D6
0000066E                          1224mm         HEX2BIN D5,D5,A4
0000066E  49FA 0AE8               1225mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000672  0405 0030               1226mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000676  CABC 000000FF           1227mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000067C  1A34 5000               1228mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000680                          1229mm     ENDM
00000680  8205                    1230m         OR.B D5,D1
00000682  5307                    1231m         SUB.B #1,D7
00000684                          1232m     ENDW
00000684  60AA                    1233ms     BRA _1000000A
00000686                          1234ms _1000000B
00000686                          1235m 
00000686  7A00                    1236m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000688  1A01                    1237m     MOVE.B D1,D5
0000068A  D481                    1238m     ADD.L D1,D2
0000068C                          1239m 
0000068C                          1240m     ENDM
0000068C                          1241   
0000068C  14C1                    1242                  MOVE.B D1,(A2)+                     ; store it!
0000068E                          1243  
0000068E  5303                    1244                  SUB.B #1,D3                         ; 1 less byte to go
00000690                          1245              ENDW
00000690  6092                    1246s     BRA _10000008
00000692                          1247s _10000009
00000692                          1248  
00000692  7200                    1249              MOVE.L #0,D1                            ; not done yet
00000694                          1250          ELSE
00000694  6000 018C               1251s     BRA _00000007
00000698                          1252s _00000005
00000698                          1253              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000698  B23C 0038               1254s     CMP.B   #'8',D1
0000069C  6600 012E               1255s     BNE.L   _00000008
000006A0  7800                    1256                  MOVE.L #0,D4                        ; read the 24 bit start address
000006A2                          1257m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000006A2  1E3C 0002               1258m     MOVE.B #2,D7
000006A6                          1259m     WHILE.B D7 <GT> 0 DO
000006A6                          1260ms _1000000C
000006A6  BE38 0000               1261ms     CMP.B   0,D7
000006AA  6F00 0050               1262ms     BLE _1000000D
000006AE  E98C                    1263m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006B0                          1264mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006B0                          1265mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006B0                          1266mm 
000006B0  1A39 00C00003           1267mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006B6  0805 0000               1268mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006BA  6700 0010               1269mm     BEQ CONTINUE_71                                 ; NOTHING, CONTINUE
000006BE                          1270mm 
000006BE                          1271mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006BE                 TRUE     1272mmm     IFEQ DEBUG
000006BE  1A39 00C00007           1273mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006C4                          1274mmm     ENDC
000006C4                 FALSE    1275mmm     IFNE DEBUG
000006C4                          1276mmm     ENDC
000006C4                          1277mmm 
000006C4  BA3C 001B               1278mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006C8  6700 F93E               1279mmm     BEQ START
000006CC                          1280mmm     ENDM
000006CC                          1281mm CONTINUE_71
000006CC  1A39 00C00013           1282mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006D2  0805 0000               1283mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006D6  67D8                    1284mm     BEQ WAIT_FOR_READY_71                           ; NOTHING, CHECK AGAIN
000006D8                          1285mm     
000006D8  1A39 00C00017           1286mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006DE  13C5 00E00001           1287mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006E4                          1288mm 
000006E4                          1289mm     ENDM
000006E4                          1290m         ;PRINT_CHAR D5,D6
000006E4                          1291mm         HEX2BIN D5,D5,A4
000006E4  49FA 0A72               1292mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006E8  0405 0030               1293mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006EC  CABC 000000FF           1294mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006F2  1A34 5000               1295mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006F6                          1296mm     ENDM
000006F6  8805                    1297m         OR.B D5,D4
000006F8  5307                    1298m         SUB.B #1,D7
000006FA                          1299m     ENDW
000006FA  60AA                    1300ms     BRA _1000000C
000006FC                          1301ms _1000000D
000006FC                          1302m 
000006FC  7A00                    1303m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006FE  1A04                    1304m     MOVE.B D4,D5
00000700  D484                    1305m     ADD.L D4,D2
00000702                          1306m 
00000702                          1307m     ENDM
00000702                          1308m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000702  1E3C 0002               1309m     MOVE.B #2,D7
00000706                          1310m     WHILE.B D7 <GT> 0 DO
00000706                          1311ms _1000000E
00000706  BE38 0000               1312ms     CMP.B   0,D7
0000070A  6F00 0050               1313ms     BLE _1000000F
0000070E  E98C                    1314m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000710                          1315mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000710                          1316mm WAIT_FOR_READY_75                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000710                          1317mm 
00000710  1A39 00C00003           1318mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000716  0805 0000               1319mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000071A  6700 0010               1320mm     BEQ CONTINUE_75                                 ; NOTHING, CONTINUE
0000071E                          1321mm 
0000071E                          1322mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000071E                 TRUE     1323mmm     IFEQ DEBUG
0000071E  1A39 00C00007           1324mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000724                          1325mmm     ENDC
00000724                 FALSE    1326mmm     IFNE DEBUG
00000724                          1327mmm     ENDC
00000724                          1328mmm 
00000724  BA3C 001B               1329mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000728  6700 F8DE               1330mmm     BEQ START
0000072C                          1331mmm     ENDM
0000072C                          1332mm CONTINUE_75
0000072C  1A39 00C00013           1333mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000732  0805 0000               1334mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000736  67D8                    1335mm     BEQ WAIT_FOR_READY_75                           ; NOTHING, CHECK AGAIN
00000738                          1336mm     
00000738  1A39 00C00017           1337mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000073E  13C5 00E00001           1338mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000744                          1339mm 
00000744                          1340mm     ENDM
00000744                          1341m         ;PRINT_CHAR D5,D6
00000744                          1342mm         HEX2BIN D5,D5,A4
00000744  49FA 0A12               1343mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000748  0405 0030               1344mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000074C  CABC 000000FF           1345mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000752  1A34 5000               1346mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000756                          1347mm     ENDM
00000756  8805                    1348m         OR.B D5,D4
00000758  5307                    1349m         SUB.B #1,D7
0000075A                          1350m     ENDW
0000075A  60AA                    1351ms     BRA _1000000E
0000075C                          1352ms _1000000F
0000075C                          1353m 
0000075C  7A00                    1354m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000075E  1A04                    1355m     MOVE.B D4,D5
00000760  D484                    1356m     ADD.L D4,D2
00000762                          1357m 
00000762                          1358m     ENDM
00000762                          1359m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000762  1E3C 0002               1360m     MOVE.B #2,D7
00000766                          1361m     WHILE.B D7 <GT> 0 DO
00000766                          1362ms _10000010
00000766  BE38 0000               1363ms     CMP.B   0,D7
0000076A  6F00 0050               1364ms     BLE _10000011
0000076E  E98C                    1365m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000770                          1366mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000770                          1367mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000770                          1368mm 
00000770  1A39 00C00003           1369mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000776  0805 0000               1370mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000077A  6700 0010               1371mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000077E                          1372mm 
0000077E                          1373mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000077E                 TRUE     1374mmm     IFEQ DEBUG
0000077E  1A39 00C00007           1375mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000784                          1376mmm     ENDC
00000784                 FALSE    1377mmm     IFNE DEBUG
00000784                          1378mmm     ENDC
00000784                          1379mmm 
00000784  BA3C 001B               1380mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000788  6700 F87E               1381mmm     BEQ START
0000078C                          1382mmm     ENDM
0000078C                          1383mm CONTINUE_79
0000078C  1A39 00C00013           1384mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000792  0805 0000               1385mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000796  67D8                    1386mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000798                          1387mm     
00000798  1A39 00C00017           1388mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000079E  13C5 00E00001           1389mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007A4                          1390mm 
000007A4                          1391mm     ENDM
000007A4                          1392m         ;PRINT_CHAR D5,D6
000007A4                          1393mm         HEX2BIN D5,D5,A4
000007A4  49FA 09B2               1394mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A8  0405 0030               1395mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007AC  CABC 000000FF           1396mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007B2  1A34 5000               1397mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B6                          1398mm     ENDM
000007B6  8805                    1399m         OR.B D5,D4
000007B8  5307                    1400m         SUB.B #1,D7
000007BA                          1401m     ENDW
000007BA  60AA                    1402ms     BRA _10000010
000007BC                          1403ms _10000011
000007BC                          1404m 
000007BC  7A00                    1405m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007BE  1A04                    1406m     MOVE.B D4,D5
000007C0  D484                    1407m     ADD.L D4,D2
000007C2                          1408m 
000007C2                          1409m     ENDM
000007C2                          1410  
000007C2  2044                    1411                  MOVE.L D4,A0                        ; start address -> A0
000007C4  D1C9                    1412                  ADD.L A1,A0                         ; add in the offset
000007C6                          1413  
000007C6  72FF                    1414                  MOVE.L #$FFFFFFFF,D1                ; done
000007C8                          1415              ELSE
000007C8  6000 0058               1416s     BRA _00000009
000007CC                          1417s _00000008
000007CC                          1418                  ;PRINT_CRLF D5,A4
000007CC                          1419  
000007CC  49FA 093F               1420                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000007D0                          1421m                 PRINT_STR A4,D5
000007D0                          1422m LOOP_82
000007D0  0C14 0000               1423m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000007D4  6700 0016               1424m     BEQ EXIT_82
000007D8                          1425mm     PRINT_CHAR (A4)+,D5
000007D8                          1426mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007D8                 TRUE     1427mm     IFEQ DEBUG
000007D8  1A39 00C00003           1428mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000007DE  0805 0002               1429mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000007E2  67F4                    1430mm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
000007E4  13DC 00C00007           1431mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007EA                          1432mm     ENDC
000007EA                          1433mm 
000007EA                 FALSE    1434mm     IFNE DEBUG
000007EA                          1435mm     ENDC
000007EA                          1436mm 
000007EA                          1437mm     ENDM
000007EA  60E4                    1438m     BRA LOOP_82
000007EC                          1439m EXIT_82
000007EC                          1440m     ENDM
000007EC                          1441m                 PRINT_CHAR D1,D5
000007EC                          1442m WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007EC                 TRUE     1443m     IFEQ DEBUG
000007EC  1A39 00C00003           1444m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000007F2  0805 0002               1445m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000007F6  67F4                    1446m         BEQ WAIT_FOR_READY_84                       ; NO SPACE, CHECK AGAIN
000007F8  13C1 00C00007           1447m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007FE                          1448m     ENDC
000007FE                          1449m 
000007FE                 FALSE    1450m     IFNE DEBUG
000007FE                          1451m     ENDC
000007FE                          1452m 
000007FE                          1453m     ENDM
000007FE                          1454m                 PRINT_CRLF D5,A4
000007FE  49FA 0983               1455m     LEA CRLF(PC),A4
00000802                          1456mm     PRINT_STR A4,D5
00000802                          1457mm LOOP_86
00000802  0C14 0000               1458mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000806  6700 0016               1459mm     BEQ EXIT_86
0000080A                          1460mmm     PRINT_CHAR (A4)+,D5
0000080A                          1461mmm WAIT_FOR_READY_87                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080A                 TRUE     1462mmm     IFEQ DEBUG
0000080A  1A39 00C00003           1463mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000810  0805 0002               1464mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000814  67F4                    1465mmm         BEQ WAIT_FOR_READY_87                       ; NO SPACE, CHECK AGAIN
00000816  13DC 00C00007           1466mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000081C                          1467mmm     ENDC
0000081C                          1468mmm 
0000081C                 FALSE    1469mmm     IFNE DEBUG
0000081C                          1470mmm     ENDC
0000081C                          1471mmm 
0000081C                          1472mmm     ENDM
0000081C  60E4                    1473mm     BRA LOOP_86
0000081E                          1474mm EXIT_86
0000081E                          1475mm     ENDM
0000081E                          1476m     ENDM
0000081E                          1477  
0000081E  6000 FBE2               1478                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000822                          1479              ENDI
00000822                          1480s _00000009
00000822                          1481          ENDI
00000822                          1482s _00000007
00000822                          1483      ENDI
00000822                          1484s _00000003
00000822                          1485  
00000822                          1486m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000822  1E3C 0002               1487m     MOVE.B #2,D7
00000826                          1488m     WHILE.B D7 <GT> 0 DO
00000826                          1489ms _10000012
00000826  BE38 0000               1490ms     CMP.B   0,D7
0000082A  6F00 0050               1491ms     BLE _10000013
0000082E  E98C                    1492m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000830                          1493mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000830                          1494mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000830                          1495mm 
00000830  1A39 00C00003           1496mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000836  0805 0000               1497mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000083A  6700 0010               1498mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
0000083E                          1499mm 
0000083E                          1500mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000083E                 TRUE     1501mmm     IFEQ DEBUG
0000083E  1A39 00C00007           1502mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000844                          1503mmm     ENDC
00000844                 FALSE    1504mmm     IFNE DEBUG
00000844                          1505mmm     ENDC
00000844                          1506mmm 
00000844  BA3C 001B               1507mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000848  6700 F7BE               1508mmm     BEQ START
0000084C                          1509mmm     ENDM
0000084C                          1510mm CONTINUE_89
0000084C  1A39 00C00013           1511mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000852  0805 0000               1512mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000856  67D8                    1513mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
00000858                          1514mm     
00000858  1A39 00C00017           1515mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000085E  13C5 00E00001           1516mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000864                          1517mm 
00000864                          1518mm     ENDM
00000864                          1519m         ;PRINT_CHAR D5,D6
00000864                          1520mm         HEX2BIN D5,D5,A4
00000864  49FA 08F2               1521mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000868  0405 0030               1522mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000086C  CABC 000000FF           1523mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000872  1A34 5000               1524mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000876                          1525mm     ENDM
00000876  8805                    1526m         OR.B D5,D4
00000878  5307                    1527m         SUB.B #1,D7
0000087A                          1528m     ENDW
0000087A  60AA                    1529ms     BRA _10000012
0000087C                          1530ms _10000013
0000087C                          1531m 
0000087C  7A00                    1532m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000087E  1A04                    1533m     MOVE.B D4,D5
00000880  D484                    1534m     ADD.L D4,D2
00000882                          1535m 
00000882                          1536m     ENDM
00000882                          1537      ;PRINT_CRLF D5,A4
00000882                          1538  
00000882                          1539      IF.B D2 <NE> #$FF THEN.L
00000882  B43C 00FF               1540s     CMP.B   #$FF,D2
00000886  6700 0090               1541s     BEQ.L   _0000000A
0000088A  49FA 0898               1542          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
0000088E                          1543m         PRINT_STR A4,D5
0000088E                          1544m LOOP_92
0000088E  0C14 0000               1545m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000892  6700 0016               1546m     BEQ EXIT_92
00000896                          1547mm     PRINT_CHAR (A4)+,D5
00000896                          1548mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000896                 TRUE     1549mm     IFEQ DEBUG
00000896  1A39 00C00003           1550mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000089C  0805 0002               1551mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008A0  67F4                    1552mm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
000008A2  13DC 00C00007           1553mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008A8                          1554mm     ENDC
000008A8                          1555mm 
000008A8                 FALSE    1556mm     IFNE DEBUG
000008A8                          1557mm     ENDC
000008A8                          1558mm 
000008A8                          1559mm     ENDM
000008A8  60E4                    1560m     BRA LOOP_92
000008AA                          1561m EXIT_92
000008AA                          1562m     ENDM
000008AA                          1563m         PRINT_REG D0,D5,D2,D6,A4
000008AA  49FA 08DD               1564m     LEA OX(PC),A4
000008AE                          1565mm     PRINT_STR A4,D5
000008AE                          1566mm LOOP_95
000008AE  0C14 0000               1567mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008B2  6700 0016               1568mm     BEQ EXIT_95
000008B6                          1569mmm     PRINT_CHAR (A4)+,D5
000008B6                          1570mmm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B6                 TRUE     1571mmm     IFEQ DEBUG
000008B6  1A39 00C00003           1572mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008BC  0805 0002               1573mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008C0  67F4                    1574mmm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000008C2  13DC 00C00007           1575mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008C8                          1576mmm     ENDC
000008C8                          1577mmm 
000008C8                 FALSE    1578mmm     IFNE DEBUG
000008C8                          1579mmm     ENDC
000008C8                          1580mmm 
000008C8                          1581mmm     ENDM
000008C8  60E4                    1582mm     BRA LOOP_95
000008CA                          1583mm EXIT_95
000008CA                          1584mm     ENDM
000008CA  7C07                    1585m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000008CC                          1586m LOOP_94
000008CC                          1587mm     BIN2HEX D0,D2,A4
000008CC  49FA 087A               1588mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008D0  E998                    1589mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000008D2  1400                    1590mm     MOVE.B D0,D2
000008D4  0282 0000000F           1591mm     ANDI.L #$F,D2
000008DA  1434 2000               1592mm     MOVE.B 0(A4,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000008DE                          1593mm     ENDM
000008DE                          1594mm     PRINT_CHAR D2,D5
000008DE                          1595mm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008DE                 TRUE     1596mm     IFEQ DEBUG
000008DE  1A39 00C00003           1597mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008E4  0805 0002               1598mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008E8  67F4                    1599mm         BEQ WAIT_FOR_READY_98                       ; NO SPACE, CHECK AGAIN
000008EA  13C2 00C00007           1600mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008F0                          1601mm     ENDC
000008F0                          1602mm 
000008F0                 FALSE    1603mm     IFNE DEBUG
000008F0                          1604mm     ENDC
000008F0                          1605mm 
000008F0                          1606mm     ENDM
000008F0  57CE FFDA               1607m     DBEQ D6,LOOP_94
000008F4                          1608m     ENDM
000008F4                          1609m         PRINT_CRLF D5,A4
000008F4  49FA 088D               1610m     LEA CRLF(PC),A4
000008F8                          1611mm     PRINT_STR A4,D5
000008F8                          1612mm LOOP_100
000008F8  0C14 0000               1613mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008FC  6700 0016               1614mm     BEQ EXIT_100
00000900                          1615mmm     PRINT_CHAR (A4)+,D5
00000900                          1616mmm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000900                 TRUE     1617mmm     IFEQ DEBUG
00000900  1A39 00C00003           1618mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000906  0805 0002               1619mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000090A  67F4                    1620mmm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
0000090C  13DC 00C00007           1621mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000912                          1622mmm     ENDC
00000912                          1623mmm 
00000912                 FALSE    1624mmm     IFNE DEBUG
00000912                          1625mmm     ENDC
00000912                          1626mmm 
00000912                          1627mmm     ENDM
00000912  60E4                    1628mm     BRA LOOP_100
00000914                          1629mm EXIT_100
00000914                          1630mm     ENDM
00000914                          1631m     ENDM
00000914  6000 F864               1632          BRA MAIN_LOOP
00000918                          1633      ENDI
00000918                          1634s _0000000A
00000918                          1635  
00000918                          1636      IF D1 <EQ> #0 THEN
00000918  B27C 0000               1637s     CMP.W   #0,D1
0000091C  6600 0006               1638s     BNE _0000000B
00000920  6000 FAE0               1639        BRA WAIT_FOR_SRECORD
00000924                          1640      ENDI
00000924                          1641s _0000000B
00000924                          1642  DOWNLOAD_DONE
00000924                          1643m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000924  43FA 0863               1644m     LEA OX(PC),A1
00000928                          1645mm     PRINT_STR A1,D5
00000928                          1646mm LOOP_103
00000928  0C11 0000               1647mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000092C  6700 0016               1648mm     BEQ EXIT_103
00000930                          1649mmm     PRINT_CHAR (A1)+,D5
00000930                          1650mmm WAIT_FOR_READY_104                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000930                 TRUE     1651mmm     IFEQ DEBUG
00000930  1A39 00C00003           1652mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000936  0805 0002               1653mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000093A  67F4                    1654mmm         BEQ WAIT_FOR_READY_104                      ; NO SPACE, CHECK AGAIN
0000093C  13D9 00C00007           1655mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000942                          1656mmm     ENDC
00000942                          1657mmm 
00000942                 FALSE    1658mmm     IFNE DEBUG
00000942                          1659mmm     ENDC
00000942                          1660mmm 
00000942                          1661mmm     ENDM
00000942  60E4                    1662mm     BRA LOOP_103
00000944                          1663mm EXIT_103
00000944                          1664mm     ENDM
00000944  7407                    1665m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000946                          1666m LOOP_102
00000946                          1667mm     BIN2HEX D0,D6,A1
00000946  43FA 0800               1668mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
0000094A  E998                    1669mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000094C  1C00                    1670mm     MOVE.B D0,D6
0000094E  0286 0000000F           1671mm     ANDI.L #$F,D6
00000954  1C31 6000               1672mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000958                          1673mm     ENDM
00000958                          1674mm     PRINT_CHAR D6,D5
00000958                          1675mm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000958                 TRUE     1676mm     IFEQ DEBUG
00000958  1A39 00C00003           1677mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000095E  0805 0002               1678mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000962  67F4                    1679mm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000964  13C6 00C00007           1680mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000096A                          1681mm     ENDC
0000096A                          1682mm 
0000096A                 FALSE    1683mm     IFNE DEBUG
0000096A                          1684mm     ENDC
0000096A                          1685mm 
0000096A                          1686mm     ENDM
0000096A  57CA FFDA               1687m     DBEQ D2,LOOP_102
0000096E                          1688m     ENDM
0000096E  43FA 077B               1689      LEA READ(PC),A1
00000972                          1690m     PRINT_STR A1,D5
00000972                          1691m LOOP_107
00000972  0C11 0000               1692m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000976  6700 0016               1693m     BEQ EXIT_107
0000097A                          1694mm     PRINT_CHAR (A1)+,D5
0000097A                          1695mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000097A                 TRUE     1696mm     IFEQ DEBUG
0000097A  1A39 00C00003           1697mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000980  0805 0002               1698mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000984  67F4                    1699mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000986  13D9 00C00007           1700mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000098C                          1701mm     ENDC
0000098C                          1702mm 
0000098C                 FALSE    1703mm     IFNE DEBUG
0000098C                          1704mm     ENDC
0000098C                          1705mm 
0000098C                          1706mm     ENDM
0000098C  60E4                    1707m     BRA LOOP_107
0000098E                          1708m EXIT_107
0000098E                          1709m     ENDM
0000098E  2E08                    1710      MOVE.L A0,D7                                    ; set address accumulator to start address
00000990                          1711m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000990  43FA 07F7               1712m     LEA OX(PC),A1
00000994                          1713mm     PRINT_STR A1,D5
00000994                          1714mm LOOP_110
00000994  0C11 0000               1715mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000998  6700 0016               1716mm     BEQ EXIT_110
0000099C                          1717mmm     PRINT_CHAR (A1)+,D5
0000099C                          1718mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099C                 TRUE     1719mmm     IFEQ DEBUG
0000099C  1A39 00C00003           1720mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A2  0805 0002               1721mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A6  67F4                    1722mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
000009A8  13D9 00C00007           1723mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009AE                          1724mmm     ENDC
000009AE                          1725mmm 
000009AE                 FALSE    1726mmm     IFNE DEBUG
000009AE                          1727mmm     ENDC
000009AE                          1728mmm 
000009AE                          1729mmm     ENDM
000009AE  60E4                    1730mm     BRA LOOP_110
000009B0                          1731mm EXIT_110
000009B0                          1732mm     ENDM
000009B0  7407                    1733m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009B2                          1734m LOOP_109
000009B2                          1735mm     BIN2HEX D7,D6,A1
000009B2  43FA 0794               1736mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
000009B6  E99F                    1737mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009B8  1C07                    1738mm     MOVE.B D7,D6
000009BA  0286 0000000F           1739mm     ANDI.L #$F,D6
000009C0  1C31 6000               1740mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
000009C4                          1741mm     ENDM
000009C4                          1742mm     PRINT_CHAR D6,D5
000009C4                          1743mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C4                 TRUE     1744mm     IFEQ DEBUG
000009C4  1A39 00C00003           1745mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009CA  0805 0002               1746mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009CE  67F4                    1747mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
000009D0  13C6 00C00007           1748mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009D6                          1749mm     ENDC
000009D6                          1750mm 
000009D6                 FALSE    1751mm     IFNE DEBUG
000009D6                          1752mm     ENDC
000009D6                          1753mm 
000009D6                          1754mm     ENDM
000009D6  57CA FFDA               1755m     DBEQ D2,LOOP_109
000009DA                          1756m     ENDM
000009DA                          1757m     PRINT_CRLF D5,A4
000009DA  49FA 07A7               1758m     LEA CRLF(PC),A4
000009DE                          1759mm     PRINT_STR A4,D5
000009DE                          1760mm LOOP_115
000009DE  0C14 0000               1761mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009E2  6700 0016               1762mm     BEQ EXIT_115
000009E6                          1763mmm     PRINT_CHAR (A4)+,D5
000009E6                          1764mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1765mmm     IFEQ DEBUG
000009E6  1A39 00C00003           1766mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009EC  0805 0002               1767mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1768mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
000009F2  13DC 00C00007           1769mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009F8                          1770mmm     ENDC
000009F8                          1771mmm 
000009F8                 FALSE    1772mmm     IFNE DEBUG
000009F8                          1773mmm     ENDC
000009F8                          1774mmm 
000009F8                          1775mmm     ENDM
000009F8  60E4                    1776mm     BRA LOOP_115
000009FA                          1777mm EXIT_115
000009FA                          1778mm     ENDM
000009FA                          1779m     ENDM
000009FA                          1780  
000009FA  6000 F77E               1781      BRA MAIN_LOOP
000009FE                          1782  
000009FE                          1783  G
000009FE  2047                    1784      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000A00  7E00                    1785      MOVE.L #0,D7
00000A02  2E7C 002FFFFC           1786      MOVE.L #$2FFFFC,A7                                  ; set up the stack pointer 
00000A08                          1787  
00000A08  4E90                    1788      JSR (A0)
00000A0A                          1789      
00000A0A  41FA 0785               1790      LEA BACK(PC),A0
00000A0E                          1791m     PRINT_STR A0,D0
00000A0E                          1792m LOOP_117
00000A0E  0C10 0000               1793m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000A12  6700 0016               1794m     BEQ EXIT_117
00000A16                          1795mm     PRINT_CHAR (A0)+,D0
00000A16                          1796mm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A16                 TRUE     1797mm     IFEQ DEBUG
00000A16  1039 00C00003           1798mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00000A1C  0800 0002               1799mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00000A20  67F4                    1800mm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000A22  13D8 00C00007           1801mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A28                          1802mm     ENDC
00000A28                          1803mm 
00000A28                 FALSE    1804mm     IFNE DEBUG
00000A28                          1805mm     ENDC
00000A28                          1806mm 
00000A28                          1807mm     ENDM
00000A28  60E4                    1808m     BRA LOOP_117
00000A2A                          1809m EXIT_117
00000A2A                          1810m     ENDM
00000A2A                          1811      
00000A2A  6000 F74E               1812      BRA MAIN_LOOP
00000A2E                          1813  Z
00000A2E  207C 00200000           1814      MOVE.L #RAM,A0                                  ; address of RAM
00000A34  D1FC 00100000           1815      ADD.L #$100000,A0
00000A3A                          1816  
00000A3A                          1817      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000A3A  7000                    1818s     MOVE.L  #0,D0
00000A3C  6000 0012               1819s     BRA _20000005
00000A40                          1820s _20000004
00000A40  2200                    1821          MOVE.L D0,D1                                ; progress update
00000A42  E089                    1822          LSR.L #8,D1 
00000A44  E089                    1823          LSR.L #8,D1
00000A46  13C1 00E00001           1824          MOVE.B D1,DISPLAY
00000A4C                          1825          
00000A4C  2108                    1826          MOVE.L A0,-(A0)
00000A4E                          1827      ENDF
00000A4E  5880                    1828s     ADD.L   #4,D0
00000A50                          1829s _20000005
00000A50  B0BC 000FFFFC           1830s     CMP.L   #$FFFFC,D0
00000A56  6FE8                    1831s     BLE _20000004
00000A58                          1832  
00000A58  207C 00200000           1833      MOVE.L #RAM,A0                                  ; address of RAM
00000A5E  D1FC 00100000           1834      ADD.L #$100000,A0
00000A64                          1835  
00000A64                          1836      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000A64  7000                    1837s     MOVE.L  #0,D0
00000A66  6000 00A8               1838s     BRA _20000007
00000A6A                          1839s _20000006
00000A6A  2200                    1840          MOVE.L D0,D1                                ; progress update
00000A6C  E089                    1841          LSR.L #8,D1
00000A6E  E089                    1842          LSR.L #8,D1
00000A70  13C1 00E00001           1843          MOVE.B D1,DISPLAY
00000A76                          1844  
00000A76  2408                    1845          MOVE.L A0,D2
00000A78  2220                    1846          MOVE.L -(A0),D1
00000A7A                          1847  
00000A7A                          1848          IF.L D2 <NE> D1 THEN
00000A7A  B481                    1849s     CMP.L   D1,D2
00000A7C  6700 0090               1850s     BEQ _0000000C
00000A80  43FA 06B4               1851              LEA RAM_ERROR(PC),A1
00000A84                          1852m             PRINT_STR A1,D1
00000A84                          1853m LOOP_119
00000A84  0C11 0000               1854m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A88  6700 0016               1855m     BEQ EXIT_119
00000A8C                          1856mm     PRINT_CHAR (A1)+,D1
00000A8C                          1857mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A8C                 TRUE     1858mm     IFEQ DEBUG
00000A8C  1239 00C00003           1859mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000A92  0801 0002               1860mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000A96  67F4                    1861mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000A98  13D9 00C00007           1862mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A9E                          1863mm     ENDC
00000A9E                          1864mm 
00000A9E                 FALSE    1865mm     IFNE DEBUG
00000A9E                          1866mm     ENDC
00000A9E                          1867mm 
00000A9E                          1868mm     ENDM
00000A9E  60E4                    1869m     BRA LOOP_119
00000AA0                          1870m EXIT_119
00000AA0                          1871m     ENDM
00000AA0  2208                    1872              MOVE.L A0,D1
00000AA2  5981                    1873              SUB.L #4,D1
00000AA4                          1874m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000AA4  43FA 06E3               1875m     LEA OX(PC),A1
00000AA8                          1876mm     PRINT_STR A1,D3
00000AA8                          1877mm LOOP_122
00000AA8  0C11 0000               1878mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AAC  6700 0016               1879mm     BEQ EXIT_122
00000AB0                          1880mmm     PRINT_CHAR (A1)+,D3
00000AB0                          1881mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB0                 TRUE     1882mmm     IFEQ DEBUG
00000AB0  1639 00C00003           1883mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000AB6  0803 0002               1884mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ABA  67F4                    1885mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000ABC  13D9 00C00007           1886mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AC2                          1887mmm     ENDC
00000AC2                          1888mmm 
00000AC2                 FALSE    1889mmm     IFNE DEBUG
00000AC2                          1890mmm     ENDC
00000AC2                          1891mmm 
00000AC2                          1892mmm     ENDM
00000AC2  60E4                    1893mm     BRA LOOP_122
00000AC4                          1894mm EXIT_122
00000AC4                          1895mm     ENDM
00000AC4  7C07                    1896m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AC6                          1897m LOOP_121
00000AC6                          1898mm     BIN2HEX D1,D2,A1
00000AC6  43FA 0680               1899mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000ACA  E999                    1900mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000ACC  1401                    1901mm     MOVE.B D1,D2
00000ACE  0282 0000000F           1902mm     ANDI.L #$F,D2
00000AD4  1431 2000               1903mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000AD8                          1904mm     ENDM
00000AD8                          1905mm     PRINT_CHAR D2,D3
00000AD8                          1906mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                 TRUE     1907mm     IFEQ DEBUG
00000AD8  1639 00C00003           1908mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ADE  0803 0002               1909mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000AE2  67F4                    1910mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000AE4  13C2 00C00007           1911mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AEA                          1912mm     ENDC
00000AEA                          1913mm 
00000AEA                 FALSE    1914mm     IFNE DEBUG
00000AEA                          1915mm     ENDC
00000AEA                          1916mm 
00000AEA                          1917mm     ENDM
00000AEA  57CE FFDA               1918m     DBEQ D6,LOOP_121
00000AEE                          1919m     ENDM
00000AEE                          1920m             PRINT_CRLF D3,A1
00000AEE  43FA 0693               1921m     LEA CRLF(PC),A1
00000AF2                          1922mm     PRINT_STR A1,D3
00000AF2                          1923mm LOOP_127
00000AF2  0C11 0000               1924mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000AF6  6700 0016               1925mm     BEQ EXIT_127
00000AFA                          1926mmm     PRINT_CHAR (A1)+,D3
00000AFA                          1927mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AFA                 TRUE     1928mmm     IFEQ DEBUG
00000AFA  1639 00C00003           1929mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000B00  0803 0002               1930mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000B04  67F4                    1931mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000B06  13D9 00C00007           1932mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B0C                          1933mmm     ENDC
00000B0C                          1934mmm 
00000B0C                 FALSE    1935mmm     IFNE DEBUG
00000B0C                          1936mmm     ENDC
00000B0C                          1937mmm 
00000B0C                          1938mmm     ENDM
00000B0C  60E4                    1939mm     BRA LOOP_127
00000B0E                          1940mm EXIT_127
00000B0E                          1941mm     ENDM
00000B0E                          1942m     ENDM
00000B0E                          1943          ENDI 
00000B0E                          1944s _0000000C
00000B0E                          1945      ENDF
00000B0E  5880                    1946s     ADD.L   #4,D0
00000B10                          1947s _20000007
00000B10  B0BC 000FFFFC           1948s     CMP.L   #$FFFFC,D0
00000B16  6F00 FF52               1949s     BLE _20000006
00000B1A                          1950  
00000B1A  6000 F65E               1951      BRA MAIN_LOOP
00000B1E                          1952  
00000B1E                          1953  L
00000B1E  7000                    1954      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000B20  7200                    1955      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000B22                          1956  
00000B22                          1957      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000B22  343C 0000               1958s     MOVE.W  #0,D2
00000B26  6000 0046               1959s     BRA _20000009
00000B2A                          1960s _20000008
00000B2A  E989                    1961          LSL.L #4,D1                                 ; make what we have so far more significant
00000B2C                          1962m         WAIT_CHAR D3,D4                             ; next character -> D2
00000B2C                          1963m WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B2C                 TRUE     1964m     IFEQ DEBUG
00000B2C  1839 00C00003           1965m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B32  0804 0000               1966m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000B36  67F4                    1967m         BEQ WAIT_FOR_READY_129                      ; NOTHING, CHECK AGAIN
00000B38                          1968m     ENDC
00000B38                          1969m 
00000B38                          1970mm     READ_CHAR D3
00000B38                 TRUE     1971mm     IFEQ DEBUG
00000B38  1639 00C00007           1972mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000B3E                          1973mm     ENDC
00000B3E                 FALSE    1974mm     IFNE DEBUG
00000B3E                          1975mm     ENDC
00000B3E                          1976mm 
00000B3E  B63C 001B               1977mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000B42  6700 F4C4               1978mm     BEQ START
00000B46                          1979mm     ENDM
00000B46                          1980m 
00000B46                 TRUE     1981m     IFEQ DEBUG
00000B46                          1982mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000B46                          1983mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B46                 TRUE     1984mm     IFEQ DEBUG
00000B46  1839 00C00003           1985mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000B4C  0804 0002               1986mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000B50  67F4                    1987mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000B52  13C3 00C00007           1988mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B58                          1989mm     ENDC
00000B58                          1990mm 
00000B58                 FALSE    1991mm     IFNE DEBUG
00000B58                          1992mm     ENDC
00000B58                          1993mm 
00000B58                          1994mm     ENDM
00000B58                          1995m     ENDC
00000B58                          1996m     ENDM
00000B58                          1997m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000B58  41FA 05FE               1998m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000B5C  0403 0030               1999m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B60  C6BC 000000FF           2000m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000B66  1630 3000               2001m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B6A                          2002m     ENDM
00000B6A  8203                    2003          OR.B D3,D1
00000B6C                          2004      ENDF
00000B6C  5242                    2005s     ADD.W   #1,D2
00000B6E                          2006s _20000009
00000B6E  B47C 0007               2007s     CMP.W   #7,D2
00000B72  6FB6                    2008s     BLE _20000008
00000B74                          2009  
00000B74  3001                    2010      MOVE.W D1,D0                                    ; extract the LSword for the length
00000B76  E089                    2011      LSR.L #8,D1                                     ; extract the MSword for the address
00000B78  E089                    2012      LSR.L #8,D1
00000B7A                          2013  
00000B7A                          2014m     PRINT_CRLF D2,A1
00000B7A  43FA 0607               2015m     LEA CRLF(PC),A1
00000B7E                          2016mm     PRINT_STR A1,D2
00000B7E                          2017mm LOOP_134
00000B7E  0C11 0000               2018mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B82  6700 0016               2019mm     BEQ EXIT_134
00000B86                          2020mmm     PRINT_CHAR (A1)+,D2
00000B86                          2021mmm WAIT_FOR_READY_135                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B86                 TRUE     2022mmm     IFEQ DEBUG
00000B86  1439 00C00003           2023mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000B8C  0802 0002               2024mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000B90  67F4                    2025mmm         BEQ WAIT_FOR_READY_135                      ; NO SPACE, CHECK AGAIN
00000B92  13D9 00C00007           2026mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B98                          2027mmm     ENDC
00000B98                          2028mmm 
00000B98                 FALSE    2029mmm     IFNE DEBUG
00000B98                          2030mmm     ENDC
00000B98                          2031mmm 
00000B98                          2032mmm     ENDM
00000B98  60E4                    2033mm     BRA LOOP_134
00000B9A                          2034mm EXIT_134
00000B9A                          2035mm     ENDM
00000B9A                          2036m     ENDM
00000B9A                          2037  
00000B9A  2041                    2038      MOVE.L D1,A0                                    ; target address
00000B9C                          2039  
00000B9C  2247                    2040      MOVE.L D7,A1                                    ; address accumulator -> address register
00000B9E  7E00                    2041      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000BA0                          2042  
00000BA0  5089                    2043      ADD.L #8,A1                                     ; skip the initial stack pointer and reset vector for now
00000BA2  5180                    2044      SUB.L #8,D0
00000BA4                          2045  
00000BA4                          2046m     UNPROTECT
00000BA4  31FC AAAA 2AAA          2047m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000BAA  4E71                    2048m     NOP
00000BAC  31FC 5555 1554          2049m     MOVE.W #$5555,$1554
00000BB2  4E71                    2050m     NOP
00000BB4  31FC 8080 2AAA          2051m     MOVE.W #$8080,$2AAA
00000BBA  4E71                    2052m     NOP
00000BBC  31FC AAAA 2AAA          2053m     MOVE.W #$AAAA,$2AAA
00000BC2  4E71                    2054m     NOP
00000BC4  31FC 5555 1554          2055m     MOVE.W #$5555,$1554
00000BCA  4E71                    2056m     NOP
00000BCC  31FC 2020 2AAA          2057m     MOVE.W #$2020,$2AAA
00000BD2                          2058m     ENDM
00000BD2                          2059  
00000BD2  45FA 059B               2060      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000BD6                          2061m     PRINT_STR A2,D2
00000BD6                          2062m LOOP_137
00000BD6  0C12 0000               2063m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000BDA  6700 0016               2064m     BEQ EXIT_137
00000BDE                          2065mm     PRINT_CHAR (A2)+,D2
00000BDE                          2066mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BDE                 TRUE     2067mm     IFEQ DEBUG
00000BDE  1439 00C00003           2068mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000BE4  0802 0002               2069mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000BE8  67F4                    2070mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000BEA  13DA 00C00007           2071mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BF0                          2072mm     ENDC
00000BF0                          2073mm 
00000BF0                 FALSE    2074mm     IFNE DEBUG
00000BF0                          2075mm     ENDC
00000BF0                          2076mm 
00000BF0                          2077mm     ENDM
00000BF0  60E4                    2078m     BRA LOOP_137
00000BF2                          2079m EXIT_137
00000BF2                          2080m     ENDM
00000BF2                          2081  
00000BF2  2409                    2082      MOVE.L A1,D2
00000BF4                          2083m     PRINT_REG D2,D3,D4,D5,A2
00000BF4  45FA 0593               2084m     LEA OX(PC),A2
00000BF8                          2085mm     PRINT_STR A2,D3
00000BF8                          2086mm LOOP_140
00000BF8  0C12 0000               2087mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000BFC  6700 0016               2088mm     BEQ EXIT_140
00000C00                          2089mmm     PRINT_CHAR (A2)+,D3
00000C00                          2090mmm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C00                 TRUE     2091mmm     IFEQ DEBUG
00000C00  1639 00C00003           2092mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C06  0803 0002               2093mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C0A  67F4                    2094mmm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000C0C  13DA 00C00007           2095mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C12                          2096mmm     ENDC
00000C12                          2097mmm 
00000C12                 FALSE    2098mmm     IFNE DEBUG
00000C12                          2099mmm     ENDC
00000C12                          2100mmm 
00000C12                          2101mmm     ENDM
00000C12  60E4                    2102mm     BRA LOOP_140
00000C14                          2103mm EXIT_140
00000C14                          2104mm     ENDM
00000C14  7A07                    2105m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C16                          2106m LOOP_139
00000C16                          2107mm     BIN2HEX D2,D4,A2
00000C16  45FA 0530               2108mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000C1A  E99A                    2109mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C1C  1802                    2110mm     MOVE.B D2,D4
00000C1E  0284 0000000F           2111mm     ANDI.L #$F,D4
00000C24  1832 4000               2112mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000C28                          2113mm     ENDM
00000C28                          2114mm     PRINT_CHAR D4,D3
00000C28                          2115mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C28                 TRUE     2116mm     IFEQ DEBUG
00000C28  1639 00C00003           2117mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C2E  0803 0002               2118mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C32  67F4                    2119mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000C34  13C4 00C00007           2120mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C3A                          2121mm     ENDC
00000C3A                          2122mm 
00000C3A                 FALSE    2123mm     IFNE DEBUG
00000C3A                          2124mm     ENDC
00000C3A                          2125mm 
00000C3A                          2126mm     ENDM
00000C3A  57CD FFDA               2127m     DBEQ D5,LOOP_139
00000C3E                          2128m     ENDM
00000C3E                          2129  
00000C3E  45FA 054C               2130      LEA TO(PC),A2
00000C42                          2131m     PRINT_STR A2,D3
00000C42                          2132m LOOP_144
00000C42  0C12 0000               2133m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C46  6700 0016               2134m     BEQ EXIT_144
00000C4A                          2135mm     PRINT_CHAR (A2)+,D3
00000C4A                          2136mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2137mm     IFEQ DEBUG
00000C4A  1639 00C00003           2138mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C50  0803 0002               2139mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2140mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000C56  13DA 00C00007           2141mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C5C                          2142mm     ENDC
00000C5C                          2143mm 
00000C5C                 FALSE    2144mm     IFNE DEBUG
00000C5C                          2145mm     ENDC
00000C5C                          2146mm 
00000C5C                          2147mm     ENDM
00000C5C  60E4                    2148m     BRA LOOP_144
00000C5E                          2149m EXIT_144
00000C5E                          2150m     ENDM
00000C5E                          2151  
00000C5E  2408                    2152      MOVE.L A0,D2
00000C60                          2153m     PRINT_REG D2,D3,D4,D5,A2
00000C60  45FA 0527               2154m     LEA OX(PC),A2
00000C64                          2155mm     PRINT_STR A2,D3
00000C64                          2156mm LOOP_147
00000C64  0C12 0000               2157mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000C68  6700 0016               2158mm     BEQ EXIT_147
00000C6C                          2159mmm     PRINT_CHAR (A2)+,D3
00000C6C                          2160mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C6C                 TRUE     2161mmm     IFEQ DEBUG
00000C6C  1639 00C00003           2162mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C72  0803 0002               2163mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C76  67F4                    2164mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00000C78  13DA 00C00007           2165mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C7E                          2166mmm     ENDC
00000C7E                          2167mmm 
00000C7E                 FALSE    2168mmm     IFNE DEBUG
00000C7E                          2169mmm     ENDC
00000C7E                          2170mmm 
00000C7E                          2171mmm     ENDM
00000C7E  60E4                    2172mm     BRA LOOP_147
00000C80                          2173mm EXIT_147
00000C80                          2174mm     ENDM
00000C80  7A07                    2175m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C82                          2176m LOOP_146
00000C82                          2177mm     BIN2HEX D2,D4,A2
00000C82  45FA 04C4               2178mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000C86  E99A                    2179mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C88  1802                    2180mm     MOVE.B D2,D4
00000C8A  0284 0000000F           2181mm     ANDI.L #$F,D4
00000C90  1832 4000               2182mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000C94                          2183mm     ENDM
00000C94                          2184mm     PRINT_CHAR D4,D3
00000C94                          2185mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C94                 TRUE     2186mm     IFEQ DEBUG
00000C94  1639 00C00003           2187mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C9A  0803 0002               2188mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C9E  67F4                    2189mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
00000CA0  13C4 00C00007           2190mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CA6                          2191mm     ENDC
00000CA6                          2192mm 
00000CA6                 FALSE    2193mm     IFNE DEBUG
00000CA6                          2194mm     ENDC
00000CA6                          2195mm 
00000CA6                          2196mm     ENDM
00000CA6  57CD FFDA               2197m     DBEQ D5,LOOP_146
00000CAA                          2198m     ENDM
00000CAA                          2199  
00000CAA                          2200m     PRINT_CRLF D3,A2
00000CAA  45FA 04D7               2201m     LEA CRLF(PC),A2
00000CAE                          2202mm     PRINT_STR A2,D3
00000CAE                          2203mm LOOP_152
00000CAE  0C12 0000               2204mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000CB2  6700 0016               2205mm     BEQ EXIT_152
00000CB6                          2206mmm     PRINT_CHAR (A2)+,D3
00000CB6                          2207mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2208mmm     IFEQ DEBUG
00000CB6  1639 00C00003           2209mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CBC  0803 0002               2210mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2211mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
00000CC2  13DA 00C00007           2212mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CC8                          2213mmm     ENDC
00000CC8                          2214mmm 
00000CC8                 FALSE    2215mmm     IFNE DEBUG
00000CC8                          2216mmm     ENDC
00000CC8                          2217mmm 
00000CC8                          2218mmm     ENDM
00000CC8  60E4                    2219mm     BRA LOOP_152
00000CCA                          2220mm EXIT_152
00000CCA                          2221mm     ENDM
00000CCA                          2222m     ENDM
00000CCA                          2223  
00000CCA                          2224      WHILE D0 <GT> #0 DO
00000CCA                          2225s _10000014
00000CCA  B07C 0000               2226s     CMP.W   #0,D0
00000CCE  6F00 001C               2227s     BLE _10000015
00000CD2  5580                    2228          SUB.L #2,D0
00000CD4                          2229  
00000CD4  13D1 00E00001           2230          MOVE.B (A1),DISPLAY
00000CDA                          2231m         PROGRAM (A1),(A0),D2
00000CDA  3091                    2232m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000CDC                          2233m 
00000CDC                          2234m WAIT_FOR_COMPLETE_154
00000CDC  3410                    2235m         MOVE.W (A0),D2
00000CDE                          2236m 
00000CDE                          2237m         IF.W D2 <NE> (A1) THEN
00000CDE  B451                    2238ms     CMP.W   (A1),D2
00000CE0  6700 0004               2239ms     BEQ _0000000D
00000CE4  60F6                    2240m             BRA WAIT_FOR_COMPLETE_154
00000CE6                          2241m         ENDI
00000CE6                          2242ms _0000000D
00000CE6                          2243m         ENDM
00000CE6                          2244  
00000CE6  5488                    2245          ADD.L #2,A0
00000CE8  5489                    2246          ADD.L #2,A1
00000CEA                          2247      ENDW
00000CEA  60DE                    2248s     BRA _10000014
00000CEC                          2249s _10000015
00000CEC                          2250  
00000CEC                          2251m     PROGRAM #0, $0, D2                              ; we're done, can now update the SP and start vector
00000CEC  31FC 0000 0000          2252m   MOVE.W #0,$0                                      ; WRITE THE DATA
00000CF2                          2253m 
00000CF2                          2254m WAIT_FOR_COMPLETE_155
00000CF2  3438 0000               2255m         MOVE.W $0,D2
00000CF6                          2256m 
00000CF6                          2257m         IF.W D2 <NE> #0 THEN
00000CF6  B47C 0000               2258ms     CMP.W   #0,D2
00000CFA  6700 0004               2259ms     BEQ _0000000E
00000CFE  60F2                    2260m             BRA WAIT_FOR_COMPLETE_155
00000D00                          2261m         ENDI
00000D00                          2262ms _0000000E
00000D00                          2263m         ENDM
00000D00                          2264m     PROGRAM #0, $2, D2                              ; setting this seems to break the download code, I guess the stack is being used somehow!!!
00000D00  31FC 0000 0002          2265m   MOVE.W #0,$2                                      ; WRITE THE DATA
00000D06                          2266m 
00000D06                          2267m WAIT_FOR_COMPLETE_156
00000D06  3438 0002               2268m         MOVE.W $2,D2
00000D0A                          2269m 
00000D0A                          2270m         IF.W D2 <NE> #0 THEN
00000D0A  B47C 0000               2271ms     CMP.W   #0,D2
00000D0E  6700 0004               2272ms     BEQ _0000000F
00000D12  60F2                    2273m             BRA WAIT_FOR_COMPLETE_156
00000D14                          2274m         ENDI
00000D14                          2275ms _0000000F
00000D14                          2276m         ENDM
00000D14                          2277  
00000D14                          2278m     PROGRAM D1, $6, D2
00000D14  31C1 0006               2279m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000D18                          2280m 
00000D18                          2281m WAIT_FOR_COMPLETE_157
00000D18  3438 0006               2282m         MOVE.W $6,D2
00000D1C                          2283m 
00000D1C                          2284m         IF.W D2 <NE> D1 THEN
00000D1C  B441                    2285ms     CMP.W   D1,D2
00000D1E  6700 0004               2286ms     BEQ _00000010
00000D22  60F4                    2287m             BRA WAIT_FOR_COMPLETE_157
00000D24                          2288m         ENDI
00000D24                          2289ms _00000010
00000D24                          2290m         ENDM
00000D24  E089                    2291      LSR.L #8,D1
00000D26  E089                    2292      LSR.L #8,D1
00000D28                          2293m     PROGRAM D1, $4, D2
00000D28  31C1 0004               2294m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000D2C                          2295m 
00000D2C                          2296m WAIT_FOR_COMPLETE_158
00000D2C  3438 0004               2297m         MOVE.W $4,D2
00000D30                          2298m 
00000D30                          2299m         IF.W D2 <NE> D1 THEN
00000D30  B441                    2300ms     CMP.W   D1,D2
00000D32  6700 0004               2301ms     BEQ _00000011
00000D36  60F4                    2302m             BRA WAIT_FOR_COMPLETE_158
00000D38                          2303m         ENDI
00000D38                          2304ms _00000011
00000D38                          2305m         ENDM
00000D38                          2306  
00000D38                          2307m     PROTECT
00000D38  31FC AAAA 2AAA          2308m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000D3E  31FC 5555 1554          2309m     MOVE.W #$5555,$1554
00000D44  31FC A0A0 2AAA          2310m     MOVE.W #$A0A0,$2AAA
00000D4A                          2311m     ENDM
00000D4A                          2312  
00000D4A  6000 F42E               2313      BRA MAIN_LOOP
00000D4E                          2314  
00000D4E                          2315  P
00000D4E  7000                    2316      MOVE.L #0,D0                                    ; D0 will be the data to write
00000D50                          2317  
00000D50                          2318      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000D50  323C 0000               2319s     MOVE.W  #0,D1
00000D54  6000 0046               2320s     BRA _2000000B
00000D58                          2321s _2000000A
00000D58  E988                    2322          LSL.L #4,D0                                 ; make what we have so far more significant
00000D5A                          2323m         WAIT_CHAR D2,D3                             ; next character -> D2
00000D5A                          2324m WAIT_FOR_READY_160                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D5A                 TRUE     2325m     IFEQ DEBUG
00000D5A  1639 00C00003           2326m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D60  0803 0000               2327m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000D64  67F4                    2328m         BEQ WAIT_FOR_READY_160                      ; NOTHING, CHECK AGAIN
00000D66                          2329m     ENDC
00000D66                          2330m 
00000D66                          2331mm     READ_CHAR D2
00000D66                 TRUE     2332mm     IFEQ DEBUG
00000D66  1439 00C00007           2333mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000D6C                          2334mm     ENDC
00000D6C                 FALSE    2335mm     IFNE DEBUG
00000D6C                          2336mm     ENDC
00000D6C                          2337mm 
00000D6C  B43C 001B               2338mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000D70  6700 F296               2339mm     BEQ START
00000D74                          2340mm     ENDM
00000D74                          2341m 
00000D74                 TRUE     2342m     IFEQ DEBUG
00000D74                          2343mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000D74                          2344mm WAIT_FOR_READY_162                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D74                 TRUE     2345mm     IFEQ DEBUG
00000D74  1639 00C00003           2346mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D7A  0803 0002               2347mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D7E  67F4                    2348mm         BEQ WAIT_FOR_READY_162                      ; NO SPACE, CHECK AGAIN
00000D80  13C2 00C00007           2349mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D86                          2350mm     ENDC
00000D86                          2351mm 
00000D86                 FALSE    2352mm     IFNE DEBUG
00000D86                          2353mm     ENDC
00000D86                          2354mm 
00000D86                          2355mm     ENDM
00000D86                          2356m     ENDC
00000D86                          2357m     ENDM
00000D86                          2358m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000D86  41FA 03D0               2359m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000D8A  0402 0030               2360m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D8E  C4BC 000000FF           2361m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000D94  1430 2000               2362m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D98                          2363m     ENDM
00000D98  8002                    2364          OR.B D2,D0
00000D9A                          2365      ENDF
00000D9A  5241                    2366s     ADD.W   #1,D1
00000D9C                          2367s _2000000B
00000D9C  B27C 0003               2368s     CMP.W   #3,D1
00000DA0  6FB6                    2369s     BLE _2000000A
00000DA2                          2370  
00000DA2                          2371m     PRINT_CRLF D2,A1
00000DA2  43FA 03DF               2372m     LEA CRLF(PC),A1
00000DA6                          2373mm     PRINT_STR A1,D2
00000DA6                          2374mm LOOP_165
00000DA6  0C11 0000               2375mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DAA  6700 0016               2376mm     BEQ EXIT_165
00000DAE                          2377mmm     PRINT_CHAR (A1)+,D2
00000DAE                          2378mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DAE                 TRUE     2379mmm     IFEQ DEBUG
00000DAE  1439 00C00003           2380mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DB4  0802 0002               2381mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DB8  67F4                    2382mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000DBA  13D9 00C00007           2383mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DC0                          2384mmm     ENDC
00000DC0                          2385mmm 
00000DC0                 FALSE    2386mmm     IFNE DEBUG
00000DC0                          2387mmm     ENDC
00000DC0                          2388mmm 
00000DC0                          2389mmm     ENDM
00000DC0  60E4                    2390mm     BRA LOOP_165
00000DC2                          2391mm EXIT_165
00000DC2                          2392mm     ENDM
00000DC2                          2393m     ENDM
00000DC2                          2394  
00000DC2  2047                    2395      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000DC4  7E00                    2396      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000DC6                          2397  
00000DC6                          2398m     UNPROTECT
00000DC6  31FC AAAA 2AAA          2399m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000DCC  4E71                    2400m     NOP
00000DCE  31FC 5555 1554          2401m     MOVE.W #$5555,$1554
00000DD4  4E71                    2402m     NOP
00000DD6  31FC 8080 2AAA          2403m     MOVE.W #$8080,$2AAA
00000DDC  4E71                    2404m     NOP
00000DDE  31FC AAAA 2AAA          2405m     MOVE.W #$AAAA,$2AAA
00000DE4  4E71                    2406m     NOP
00000DE6  31FC 5555 1554          2407m     MOVE.W #$5555,$1554
00000DEC  4E71                    2408m     NOP
00000DEE  31FC 2020 2AAA          2409m     MOVE.W #$2020,$2AAA
00000DF4                          2410m     ENDM
00000DF4                          2411               
00000DF4  45FA 0379               2412      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000DF8                          2413m     PRINT_STR A2,D2
00000DF8                          2414m LOOP_168
00000DF8  0C12 0000               2415m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DFC  6700 0016               2416m     BEQ EXIT_168
00000E00                          2417mm     PRINT_CHAR (A2)+,D2
00000E00                          2418mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E00                 TRUE     2419mm     IFEQ DEBUG
00000E00  1439 00C00003           2420mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E06  0802 0002               2421mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E0A  67F4                    2422mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000E0C  13DA 00C00007           2423mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E12                          2424mm     ENDC
00000E12                          2425mm 
00000E12                 FALSE    2426mm     IFNE DEBUG
00000E12                          2427mm     ENDC
00000E12                          2428mm 
00000E12                          2429mm     ENDM
00000E12  60E4                    2430m     BRA LOOP_168
00000E14                          2431m EXIT_168
00000E14                          2432m     ENDM
00000E14                          2433  
00000E14                          2434m     PRINT_CHAR '#',D3
00000E14                          2435m WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E14                 TRUE     2436m     IFEQ DEBUG
00000E14  1639 00C00003           2437m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E1A  0803 0002               2438m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E1E  67F4                    2439m         BEQ WAIT_FOR_READY_170                      ; NO SPACE, CHECK AGAIN
00000E20  13F8 0023 00C00007      2440m         MOVE.B '#',DUART_TXA                            ; SEND THE NEXT CHARACTER
00000E28                          2441m     ENDC
00000E28                          2442m 
00000E28                 FALSE    2443m     IFNE DEBUG
00000E28                          2444m     ENDC
00000E28                          2445m 
00000E28                          2446m     ENDM
00000E28                          2447m     PRINT_REG D0,D3,D4,D5,A2
00000E28  45FA 035F               2448m     LEA OX(PC),A2
00000E2C                          2449mm     PRINT_STR A2,D3
00000E2C                          2450mm LOOP_172
00000E2C  0C12 0000               2451mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E30  6700 0016               2452mm     BEQ EXIT_172
00000E34                          2453mmm     PRINT_CHAR (A2)+,D3
00000E34                          2454mmm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E34                 TRUE     2455mmm     IFEQ DEBUG
00000E34  1639 00C00003           2456mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E3A  0803 0002               2457mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E3E  67F4                    2458mmm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000E40  13DA 00C00007           2459mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E46                          2460mmm     ENDC
00000E46                          2461mmm 
00000E46                 FALSE    2462mmm     IFNE DEBUG
00000E46                          2463mmm     ENDC
00000E46                          2464mmm 
00000E46                          2465mmm     ENDM
00000E46  60E4                    2466mm     BRA LOOP_172
00000E48                          2467mm EXIT_172
00000E48                          2468mm     ENDM
00000E48  7A07                    2469m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E4A                          2470m LOOP_171
00000E4A                          2471mm     BIN2HEX D0,D4,A2
00000E4A  45FA 02FC               2472mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E4E  E998                    2473mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E50  1800                    2474mm     MOVE.B D0,D4
00000E52  0284 0000000F           2475mm     ANDI.L #$F,D4
00000E58  1832 4000               2476mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E5C                          2477mm     ENDM
00000E5C                          2478mm     PRINT_CHAR D4,D3
00000E5C                          2479mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E5C                 TRUE     2480mm     IFEQ DEBUG
00000E5C  1639 00C00003           2481mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E62  0803 0002               2482mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E66  67F4                    2483mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00000E68  13C4 00C00007           2484mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E6E                          2485mm     ENDC
00000E6E                          2486mm 
00000E6E                 FALSE    2487mm     IFNE DEBUG
00000E6E                          2488mm     ENDC
00000E6E                          2489mm 
00000E6E                          2490mm     ENDM
00000E6E  57CD FFDA               2491m     DBEQ D5,LOOP_171
00000E72                          2492m     ENDM
00000E72                          2493  
00000E72  45FA 0318               2494      LEA TO(PC),A2
00000E76                          2495m     PRINT_STR A2,D3
00000E76                          2496m LOOP_176
00000E76  0C12 0000               2497m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E7A  6700 0016               2498m     BEQ EXIT_176
00000E7E                          2499mm     PRINT_CHAR (A2)+,D3
00000E7E                          2500mm WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E7E                 TRUE     2501mm     IFEQ DEBUG
00000E7E  1639 00C00003           2502mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E84  0803 0002               2503mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E88  67F4                    2504mm         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
00000E8A  13DA 00C00007           2505mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E90                          2506mm     ENDC
00000E90                          2507mm 
00000E90                 FALSE    2508mm     IFNE DEBUG
00000E90                          2509mm     ENDC
00000E90                          2510mm 
00000E90                          2511mm     ENDM
00000E90  60E4                    2512m     BRA LOOP_176
00000E92                          2513m EXIT_176
00000E92                          2514m     ENDM
00000E92                          2515  
00000E92  2408                    2516      MOVE.L A0,D2
00000E94                          2517m     PRINT_REG D2,D3,D4,D5,A2
00000E94  45FA 02F3               2518m     LEA OX(PC),A2
00000E98                          2519mm     PRINT_STR A2,D3
00000E98                          2520mm LOOP_179
00000E98  0C12 0000               2521mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E9C  6700 0016               2522mm     BEQ EXIT_179
00000EA0                          2523mmm     PRINT_CHAR (A2)+,D3
00000EA0                          2524mmm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA0                 TRUE     2525mmm     IFEQ DEBUG
00000EA0  1639 00C00003           2526mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EA6  0803 0002               2527mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EAA  67F4                    2528mmm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000EAC  13DA 00C00007           2529mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB2                          2530mmm     ENDC
00000EB2                          2531mmm 
00000EB2                 FALSE    2532mmm     IFNE DEBUG
00000EB2                          2533mmm     ENDC
00000EB2                          2534mmm 
00000EB2                          2535mmm     ENDM
00000EB2  60E4                    2536mm     BRA LOOP_179
00000EB4                          2537mm EXIT_179
00000EB4                          2538mm     ENDM
00000EB4  7A07                    2539m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EB6                          2540m LOOP_178
00000EB6                          2541mm     BIN2HEX D2,D4,A2
00000EB6  45FA 0290               2542mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EBA  E99A                    2543mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EBC  1802                    2544mm     MOVE.B D2,D4
00000EBE  0284 0000000F           2545mm     ANDI.L #$F,D4
00000EC4  1832 4000               2546mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EC8                          2547mm     ENDM
00000EC8                          2548mm     PRINT_CHAR D4,D3
00000EC8                          2549mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2550mm     IFEQ DEBUG
00000EC8  1639 00C00003           2551mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ECE  0803 0002               2552mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ED2  67F4                    2553mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000ED4  13C4 00C00007           2554mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EDA                          2555mm     ENDC
00000EDA                          2556mm 
00000EDA                 FALSE    2557mm     IFNE DEBUG
00000EDA                          2558mm     ENDC
00000EDA                          2559mm 
00000EDA                          2560mm     ENDM
00000EDA  57CD FFDA               2561m     DBEQ D5,LOOP_178
00000EDE                          2562m     ENDM
00000EDE                          2563  
00000EDE                          2564m     PRINT_CRLF D3,A2
00000EDE  45FA 02A3               2565m     LEA CRLF(PC),A2
00000EE2                          2566mm     PRINT_STR A2,D3
00000EE2                          2567mm LOOP_184
00000EE2  0C12 0000               2568mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EE6  6700 0016               2569mm     BEQ EXIT_184
00000EEA                          2570mmm     PRINT_CHAR (A2)+,D3
00000EEA                          2571mmm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEA                 TRUE     2572mmm     IFEQ DEBUG
00000EEA  1639 00C00003           2573mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EF0  0803 0002               2574mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EF4  67F4                    2575mmm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00000EF6  13DA 00C00007           2576mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFC                          2577mmm     ENDC
00000EFC                          2578mmm 
00000EFC                 FALSE    2579mmm     IFNE DEBUG
00000EFC                          2580mmm     ENDC
00000EFC                          2581mmm 
00000EFC                          2582mmm     ENDM
00000EFC  60E4                    2583mm     BRA LOOP_184
00000EFE                          2584mm EXIT_184
00000EFE                          2585mm     ENDM
00000EFE                          2586m     ENDM
00000EFE                          2587  
00000EFE                          2588m     PROGRAM D0,(A0),D2
00000EFE  3080                    2589m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F00                          2590m 
00000F00                          2591m WAIT_FOR_COMPLETE_186
00000F00  3410                    2592m         MOVE.W (A0),D2
00000F02                          2593m 
00000F02                          2594m         IF.W D2 <NE> D0 THEN
00000F02  B440                    2595ms     CMP.W   D0,D2
00000F04  6700 0004               2596ms     BEQ _00000012
00000F08  60F6                    2597m             BRA WAIT_FOR_COMPLETE_186
00000F0A                          2598m         ENDI
00000F0A                          2599ms _00000012
00000F0A                          2600m         ENDM
00000F0A                          2601  
00000F0A                          2602m     PROTECT
00000F0A  31FC AAAA 2AAA          2603m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F10  31FC 5555 1554          2604m     MOVE.W #$5555,$1554
00000F16  31FC A0A0 2AAA          2605m     MOVE.W #$A0A0,$2AAA
00000F1C                          2606m     ENDM
00000F1C                          2607  
00000F1C  6000 F25C               2608      BRA MAIN_LOOP
00000F20                          2609      
00000F20                          2610  M
00000F20  7000                    2611      MOVE.L #0,D0                                        ; D0 will be the length to read            
00000F22  7200                    2612      MOVE.L #0,D1                                        ; D1 will be the address to read 
00000F24                          2613  
00000F24                          2614      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000F24  343C 0000               2615s     MOVE.W  #0,D2
00000F28  6000 0046               2616s     BRA _2000000D
00000F2C                          2617s _2000000C
00000F2C  E989                    2618          LSL.L #4,D1                                     ; make what we have so far more significant
00000F2E                          2619m         WAIT_CHAR D3,D4                                 ; next character -> D2
00000F2E                          2620m WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F2E                 TRUE     2621m     IFEQ DEBUG
00000F2E  1839 00C00003           2622m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000F34  0804 0000               2623m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000F38  67F4                    2624m         BEQ WAIT_FOR_READY_188                      ; NOTHING, CHECK AGAIN
00000F3A                          2625m     ENDC
00000F3A                          2626m 
00000F3A                          2627mm     READ_CHAR D3
00000F3A                 TRUE     2628mm     IFEQ DEBUG
00000F3A  1639 00C00007           2629mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000F40                          2630mm     ENDC
00000F40                 FALSE    2631mm     IFNE DEBUG
00000F40                          2632mm     ENDC
00000F40                          2633mm 
00000F40  B63C 001B               2634mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000F44  6700 F0C2               2635mm     BEQ START
00000F48                          2636mm     ENDM
00000F48                          2637m 
00000F48                 TRUE     2638m     IFEQ DEBUG
00000F48                          2639mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000F48                          2640mm WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F48                 TRUE     2641mm     IFEQ DEBUG
00000F48  1839 00C00003           2642mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000F4E  0804 0002               2643mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000F52  67F4                    2644mm         BEQ WAIT_FOR_READY_190                      ; NO SPACE, CHECK AGAIN
00000F54  13C3 00C00007           2645mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F5A                          2646mm     ENDC
00000F5A                          2647mm 
00000F5A                 FALSE    2648mm     IFNE DEBUG
00000F5A                          2649mm     ENDC
00000F5A                          2650mm 
00000F5A                          2651mm     ENDM
00000F5A                          2652m     ENDC
00000F5A                          2653m     ENDM
00000F5A                          2654m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
00000F5A  41FA 01FC               2655m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000F5E  0403 0030               2656m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F62  C6BC 000000FF           2657m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000F68  1630 3000               2658m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000F6C                          2659m     ENDM
00000F6C  8203                    2660          OR.B D3,D1
00000F6E                          2661      ENDF
00000F6E  5242                    2662s     ADD.W   #1,D2
00000F70                          2663s _2000000D
00000F70  B47C 0007               2664s     CMP.W   #7,D2
00000F74  6FB6                    2665s     BLE _2000000C
00000F76                          2666m     PRINT_CRLF D2,A1
00000F76  43FA 020B               2667m     LEA CRLF(PC),A1
00000F7A                          2668mm     PRINT_STR A1,D2
00000F7A                          2669mm LOOP_193
00000F7A  0C11 0000               2670mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F7E  6700 0016               2671mm     BEQ EXIT_193
00000F82                          2672mmm     PRINT_CHAR (A1)+,D2
00000F82                          2673mmm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F82                 TRUE     2674mmm     IFEQ DEBUG
00000F82  1439 00C00003           2675mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F88  0802 0002               2676mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F8C  67F4                    2677mmm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00000F8E  13D9 00C00007           2678mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F94                          2679mmm     ENDC
00000F94                          2680mmm 
00000F94                 FALSE    2681mmm     IFNE DEBUG
00000F94                          2682mmm     ENDC
00000F94                          2683mmm 
00000F94                          2684mmm     ENDM
00000F94  60E4                    2685mm     BRA LOOP_193
00000F96                          2686mm EXIT_193
00000F96                          2687mm     ENDM
00000F96                          2688m     ENDM
00000F96                          2689  
00000F96  3001                    2690      MOVE.W D1,D0                                        ; extract the LSword for the length
00000F98  E089                    2691      LSR.L #8,D1                                         ; extract the MSword for the address
00000F9A  E089                    2692      LSR.L #8,D1
00000F9C                          2693  
00000F9C  2241                    2694      MOVE.L D1,A1
00000F9E                          2695      
00000F9E  2047                    2696      MOVE.L D7,A0                                        ; address accumulator -> target address register
00000FA0                          2697      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00000FA0                          2698  
00000FA0                          2699      WHILE D0 <GT> #0 DO
00000FA0                          2700s _10000016
00000FA0  B07C 0000               2701s     CMP.W   #0,D0
00000FA4  6F00 000E               2702s     BLE _10000017
00000FA8  5580                    2703          SUB.L #2,D0
00000FAA                          2704  
00000FAA  13D1 00E00001           2705          MOVE.B (A1),DISPLAY
00000FB0  30D9                    2706          MOVE.W (A1)+,(A0)+
00000FB2                          2707      ENDW
00000FB2  60EC                    2708s     BRA _10000016
00000FB4                          2709s _10000017
00000FB4                          2710      
00000FB4  6000 F1C4               2711      BRA MAIN_LOOP
00000FB8                          2712      
00000FB8                          2713  HEX_DIGIT
00000FB8  E98F                    2714      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
00000FBA                          2715m     HEX2BIN D2,D2,A0
00000FBA  41FA 019C               2716m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000FBE  0402 0030               2717m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FC2  C4BC 000000FF           2718m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000FC8  1430 2000               2719m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000FCC                          2720m     ENDM
00000FCC  8E02                    2721      OR.B D2,D7  
00000FCE  6000 F1CA               2722      BRA GET_INPUT
00000FD2                          2723  
00000FD2  FFFF FFFF               2724      SIMHALT                                             ; halt simulator
00000FD6                          2725  
00000FD6                          2726  ; strings
00000FD6= 50 72 65 73 73 20 ...   2727  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000FE9= 5B 3F 5D 09 09 09 ...   2728  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00000FF5= 5B 76 5D 09 09 09 ...   2729          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001004= 78 78 78 78 78 78 ...   2730          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
0000101C= 78 78 78 78 78 78 ...   2731          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000103C= 78 78 78 78 78 78 ...   2732          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
0000105D= 78 78 78 78 78 78 ...   2733          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
0000106E= 5B 7A 5D 09 09 09 ...   2734          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001080= 78 78 78 78 78 78 ...   2735          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000010A1= 78 78 78 78 78 78 ...   2736          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000010C0= 78 78 78 78 78 78 ...   2737          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
000010E4= 48 75 68 3F 0D 0A 00    2738  HUH  DC.B 'Huh?',CR,LF,NULL
000010EB= 20 53 20 72 65 63 ...   2739  READ    DC.B ' S records read, start address = ',NULL
0000110D= 57 3A 20 55 6E 6B ...   2740  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001124= 57 3A 20 43 53 20 ...   2741  CS_FAILURE  DC.B 'W: CS failure at ',NULL
00001136= 57 3A 20 52 41 4D ...   2742  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
00001148= 30 31 32 33 34 35 ...   2743  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001158= 00 01 02 03 04 05 ...   2744  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000116F= 4C 6F 61 64 69 6E ...   2745  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001183= 0D 0A 00                2746  CRLF    DC.B CR,LF,NULL
00001186= 3E 20 00                2747  PROMPT  DC.B '> ',NULL
00001189= 30 78 00                2748  ox      DC.B '0x',NULL
0000118C= 20 2D 3E 20 00          2749  to      DC.B ' -> ',NULL
00001191= 62 61 63 6B 20 66 ...   2750  BACK    DC.B 'back from the dead!',CR,LF,NULL
000011A7= 4D 44 46 2D 6D 6F ...   2751  VERSION DC.B 'MDF-mon V1.85 (18/04/2021)',CR,LF,NULL    ; this is the last line on purpose, so if it prints, we can be sure we got it all
000011C4                          2752  
000011C4                          2753      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BACK                1191
BIN2HEX             0
BIN2HEX_LUT         1148
CONTINUE_46         41E
CONTINUE_48         45A
CONTINUE_51         49E
CONTINUE_55         520
CONTINUE_59         580
CONTINUE_63         5EA
CONTINUE_67         656
CONTINUE_71         6CC
CONTINUE_75         72C
CONTINUE_79         78C
CONTINUE_89         84C
CR                  D
CRLF                1183
CS_FAILURE          1124
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       924
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EXIT_100            914
EXIT_103            944
EXIT_107            98E
EXIT_110            9B0
EXIT_115            9FA
EXIT_117            A2A
EXIT_119            AA0
EXIT_12             170
EXIT_122            AC4
EXIT_127            B0E
EXIT_134            B9A
EXIT_137            BF2
EXIT_14             19A
EXIT_140            C14
EXIT_144            C5E
EXIT_147            C80
EXIT_152            CCA
EXIT_165            DC2
EXIT_168            E14
EXIT_172            E48
EXIT_176            E92
EXIT_179            EB4
EXIT_184            EFE
EXIT_193            F96
EXIT_20             22E
EXIT_22             27E
EXIT_24             2AA
EXIT_27             2D4
EXIT_37             382
EXIT_44             3F6
EXIT_5              110
EXIT_7              130
EXIT_82             7EC
EXIT_86             81E
EXIT_9              150
EXIT_92             8AA
EXIT_95             8CA
G                   9FE
GET_INPUT           19A
H                   282
HELP                FE9
HELPPROMPT          FD6
HEX2BIN             10B
HEX2BIN_LUT         1158
HEX_DIGIT           FB8
HUH                 10E4
L                   B1E
LF                  A
LOADING             116F
LOOP_100            8F8
LOOP_102            946
LOOP_103            928
LOOP_107            972
LOOP_109            9B2
LOOP_110            994
LOOP_115            9DE
LOOP_117            A0E
LOOP_119            A84
LOOP_12             154
LOOP_121            AC6
LOOP_122            AA8
LOOP_127            AF2
LOOP_134            B7E
LOOP_137            BD6
LOOP_139            C16
LOOP_14             17E
LOOP_140            BF8
LOOP_144            C42
LOOP_146            C82
LOOP_147            C64
LOOP_152            CAE
LOOP_165            DA6
LOOP_168            DF8
LOOP_171            E4A
LOOP_172            E2C
LOOP_176            E76
LOOP_178            EB6
LOOP_179            E98
LOOP_184            EE2
LOOP_193            F7A
LOOP_20             212
LOOP_22             262
LOOP_24             28E
LOOP_26             2D6
LOOP_27             2B8
LOOP_37             366
LOOP_44             3DA
LOOP_5              F4
LOOP_7              114
LOOP_82             7D0
LOOP_86             802
LOOP_9              134
LOOP_92             88E
LOOP_94             8CC
LOOP_95             8AE
M                   F20
MAIN_LOOP           17A
NULL                0
OX                  1189
P                   D4E
PRINTSTR            28E
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4E
PROMPT              1186
PROTECT             A40
R                   2AE
RAM                 200000
RAM_ERROR           1136
READ                10EB
READ_CHAR           62D
READ_DATA_TO_POKE   38A
RESET               4
ROM                 0
S                   3FA
STACK               0
START               8
TAB                 9
TO                  118C
UNPROTECT           979
UNREC               110D
V                   28A
VERSION             11A7
W                   386
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_154  CDC
WAIT_FOR_COMPLETE_155  CF2
WAIT_FOR_COMPLETE_156  D06
WAIT_FOR_COMPLETE_157  D18
WAIT_FOR_COMPLETE_158  D2C
WAIT_FOR_COMPLETE_186  F00
WAIT_FOR_READY_1    AC
WAIT_FOR_READY_10   13C
WAIT_FOR_READY_101  900
WAIT_FOR_READY_104  930
WAIT_FOR_READY_106  958
WAIT_FOR_READY_108  97A
WAIT_FOR_READY_111  99C
WAIT_FOR_READY_113  9C4
WAIT_FOR_READY_116  9E6
WAIT_FOR_READY_118  A16
WAIT_FOR_READY_120  A8C
WAIT_FOR_READY_123  AB0
WAIT_FOR_READY_125  AD8
WAIT_FOR_READY_128  AFA
WAIT_FOR_READY_129  B2C
WAIT_FOR_READY_13   15C
WAIT_FOR_READY_131  B46
WAIT_FOR_READY_135  B86
WAIT_FOR_READY_138  BDE
WAIT_FOR_READY_141  C00
WAIT_FOR_READY_143  C28
WAIT_FOR_READY_145  C4A
WAIT_FOR_READY_148  C6C
WAIT_FOR_READY_15   186
WAIT_FOR_READY_150  C94
WAIT_FOR_READY_153  CB6
WAIT_FOR_READY_16   19A
WAIT_FOR_READY_160  D5A
WAIT_FOR_READY_162  D74
WAIT_FOR_READY_166  DAE
WAIT_FOR_READY_169  E00
WAIT_FOR_READY_170  E14
WAIT_FOR_READY_173  E34
WAIT_FOR_READY_175  E5C
WAIT_FOR_READY_177  E7E
WAIT_FOR_READY_18   1B4
WAIT_FOR_READY_180  EA0
WAIT_FOR_READY_182  EC8
WAIT_FOR_READY_185  EEA
WAIT_FOR_READY_188  F2E
WAIT_FOR_READY_190  F48
WAIT_FOR_READY_194  F82
WAIT_FOR_READY_2    C0
WAIT_FOR_READY_21   21A
WAIT_FOR_READY_23   26A
WAIT_FOR_READY_25   296
WAIT_FOR_READY_28   2C0
WAIT_FOR_READY_3    D4
WAIT_FOR_READY_30   2E8
WAIT_FOR_READY_31   2FE
WAIT_FOR_READY_32   314
WAIT_FOR_READY_33   328
WAIT_FOR_READY_34   33C
WAIT_FOR_READY_35   350
WAIT_FOR_READY_38   36E
WAIT_FOR_READY_39   38C
WAIT_FOR_READY_41   3A6
WAIT_FOR_READY_45   3E2
WAIT_FOR_READY_46   402
WAIT_FOR_READY_48   43E
WAIT_FOR_READY_51   482
WAIT_FOR_READY_55   504
WAIT_FOR_READY_59   564
WAIT_FOR_READY_6    FC
WAIT_FOR_READY_63   5CE
WAIT_FOR_READY_67   63A
WAIT_FOR_READY_71   6B0
WAIT_FOR_READY_75   710
WAIT_FOR_READY_79   770
WAIT_FOR_READY_8    11C
WAIT_FOR_READY_83   7D8
WAIT_FOR_READY_84   7EC
WAIT_FOR_READY_87   80A
WAIT_FOR_READY_89   830
WAIT_FOR_READY_93   896
WAIT_FOR_READY_96   8B6
WAIT_FOR_READY_98   8DE
WAIT_FOR_SRECORD    402
Z                   A2E
_00000000           1DA
_00000001           1EE
_00000002           4E4
_00000003           822
_00000004           4F2
_00000005           698
_00000006           620
_00000007           822
_00000008           7CC
_00000009           822
_0000000A           918
_0000000B           924
_0000000C           B0E
_0000000D           CE6
_0000000E           D00
_0000000F           D14
_00000010           D24
_00000011           D38
_00000012           F0A
_10000000           478
_10000001           4CE
_10000002           4FA
_10000003           550
_10000004           55A
_10000005           5B0
_10000006           5C4
_10000007           61A
_10000008           624
_10000009           692
_1000000A           630
_1000000B           686
_1000000C           6A6
_1000000D           6FC
_1000000E           706
_1000000F           75C
_10000010           766
_10000011           7BC
_10000012           826
_10000013           87C
_10000014           CCA
_10000015           CEC
_10000016           FA0
_10000017           FB4
_20000000           28
_20000001           34
_20000002           42
_20000003           4E
_20000004           A40
_20000005           A50
_20000006           A6A
_20000007           B10
_20000008           B2A
_20000009           B6E
_2000000A           D58
_2000000B           D9C
_2000000C           F2C
_2000000D           F70
