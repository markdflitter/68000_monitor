00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/09/2021 19:42:46

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor 
00000000                             6  
00000000                             7  *-----------------------------------------------------------
00000000                             8  
00000000                             9      ORG  $0
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00000000                 14  NULL                EQU 0
00000000  =00000009                 15  TAB                 EQU 9
00000000  =0000000D                 16  CR                  EQU 13
00000000  =0000000A                 17  LF                  EQU 10
00000000                            18  
00000000  =00000000                 19  ROM                 EQU $0
00000000  =00200000                 20  RAM                 EQU $200000
00000000  =002E0000                 21  STACK_ADDRESS       EQU $2E0000
00000000                            22  
00000000  =00A00000                 23  MC68230_BASE        EQU $A00000
00000000  =00000000                 24  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 25  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 26  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 27  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 28  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 29  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 30  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 31  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 32  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 33  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 34  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 35  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 36  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 37  MC68230_STATUS_             EQU $D
00000000                            38  
00000000  =00A00001                 39  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 40  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 41  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 42  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 43  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 44  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 45  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            46  
00000000  =00A0000B                 47  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 48  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 49  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 50  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 51  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 52  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 53  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 54  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 55  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 56  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 57  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 58  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            59  
00000000  =00000020                 60  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 61  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 62  MC68230_PORT_C_CS           EQU $08
00000000                            63  
00000000  =00000000                 64  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 65  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 66  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 67  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 68  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 69  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 70  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            71  
00000000  =00000007                 72  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 73  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            74  
00000000  =00000007                 75  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 76  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 77  IDE_STATUS_READY            EQU 6
00000000  =00000003                 78  IDE_STATUS_DRQ              EQU 3
00000000                            79  
00000000  =00C00000                 80  DUART_BASE          EQU $C00000
00000000  =00000000                 81  DUART_MRA_          EQU $0
00000000  =00000001                 82  DUART_CSRA_         EQU $1
00000000  =00000001                 83  DUART_SRA_          EQU $1
00000000  =00000002                 84  DUART_CRA_          EQU $2
00000000  =00000003                 85  DUART_TXA_          EQU $3
00000000  =00000003                 86  DUART_RXA_          EQU $3
00000000  =00000004                 87  DUART_ACR_          EQU $4
00000000  =00000005                 88  DUART_IMR_          EQU $5
00000000  =00000006                 89  DUART_CTUR_         EQU $6
00000000  =00000007                 90  DUART_CTLR_         EQU $7
00000000  =00000008                 91  DUART_MRB_          EQU $8
00000000  =00000009                 92  DUART_CSRB_         EQU $9
00000000  =00000009                 93  DUART_SRB_          EQU $9
00000000  =0000000A                 94  DUART_CRB_          EQU $A
00000000  =0000000B                 95  DUART_TXB_          EQU $B
00000000  =0000000B                 96  DUART_RXB_          EQU $B
00000000  =0000000C                 97  DUART_IVR_          EQU $C
00000000  =0000000D                 98  DUART_OPCR_         EQU $D
00000000  =0000000E                 99  DUART_SET_OPR_      EQU $E
00000000  =0000000F                100  DUART_RESET_OPR_    EQU $F
00000000                           101  
00000000  =00C00001                102  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                103  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                104  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                105  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                106  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                107  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           108  
00000000  =00C00011                109  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                110  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                111  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                112  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                113  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                114  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           115  
00000000  =00C00009                116  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                117  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                118  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                119  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                120  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                121  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                122  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                123  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           124  
00000000  =00E00000                125  DISPLAY_BASE        EQU $E00000
00000000  =00000000                126  DISPLAY_            EQU $0
00000000  =00E00001                127  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           128  
00000000                           129  ; macros
00000000                           130  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           131  ; the input register is changed during the process
00000000                           132  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           133  BIN2HEX MACRO
00000000                           134      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           135      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           136      MOVE.B \1,\2
00000000                           137      ANDI.L #$F,\2
00000000                           138      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           139      ENDM
00000000                           140  
00000000                           141  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           142  ; the input register is changed during the process
00000000                           143  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           144  HEX2BIN MACRO
00000000                           145      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           146      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           147      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           148      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           149      ENDM
00000000                           150  
00000000                           151  ; send a single char to the serial port
00000000                           152  ; \1 = char to send, \2 = data register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  PRINT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #2,\2                                  ; check for space to send
00000000                           159          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           160          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           161      ENDC
00000000                           162  
00000000                           163      IFNE DEBUG
00000000                           164          MOVE.B \1,D1
00000000                           165          MOVE.L #6,D0   
00000000                           166          TRAP #15                                    ; write to terminal in simulator
00000000                           167      ENDC
00000000                           168  
00000000                           169      ENDM
00000000                           170  
00000000                           171  ; send CR,LF to the serial port
00000000                           172  ; \1 = data register to use for status poll, /2 = working address register
00000000                           173  PRINT_CRLF MACRO
00000000                           174      LEA CRLF(PC),\2
00000000                           175      PRINT_STR \2,\1
00000000                           176      ENDM
00000000                           177  
00000000                           178  ; send C-style, zero terminated string to the serial port
00000000                           179  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           180  PRINT_STR MACRO
00000000                           181  LOOP\@
00000000                           182      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           183      BEQ EXIT\@
00000000                           184      PRINT_CHAR (\1)+,\2
00000000                           185      BRA LOOP\@
00000000                           186  EXIT\@
00000000                           187      ENDM
00000000                           188    
00000000                           189  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           190  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           191  PRINT_REG_4BIT MACRO
00000000                           192      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           193      MOVE.B \1,\3
00000000                           194      ANDI.L #$F,\3
00000000                           195      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           196      PRINT_CHAR \3,\2
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           200  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           201  PRINT_REG MACRO
00000000                           202      LEA ox(PC),\5
00000000                           203      PRINT_STR \5,\2
00000000                           204      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           205  LOOP\@
00000000                           206      BIN2HEX \1,\3,\5
00000000                           207      PRINT_CHAR \3,\2
00000000                           208      DBEQ \4,LOOP\@
00000000                           209      ENDM
00000000                           210  
00000000                           211  ; wait for a char from the serial port
00000000                           212  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           213  ; will stamp on D0 and D1 in debug mode
00000000                           214  WAIT_CHAR MACRO
00000000                           215  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           216      IFEQ DEBUG
00000000                           217          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           218          BTST #0,\2                                  ; check for character
00000000                           219          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           220      ENDC
00000000                           221  
00000000                           222      READ_CHAR \1
00000000                           223  
00000000                           224      IFEQ DEBUG
00000000                           225          PRINT_CHAR \1,\2                            ; echo it back
00000000                           226      ENDC
00000000                           227      ENDM
00000000                           228  
00000000                           229  ; read a char from the serial port - assumes that there is one!
00000000                           230  ; \ 1= data register for read char
00000000                           231  ; will stamp on D0 and D1 in debug mode
00000000                           232  READ_CHAR MACRO
00000000                           233      IFEQ DEBUG
00000000                           234          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           235      ENDC
00000000                           236      IFNE DEBUG
00000000                           237          MOVE.L #5,D0    
00000000                           238          TRAP #15                                    ; read from keyboard in simulator
00000000                           239          MOVE.L D1,\1
00000000                           240      ENDC
00000000                           241  
00000000                           242      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           243      BEQ START
00000000                           244      ENDM
00000000                           245  
00000000                           246  
00000000                           247  ; read data from the download serial port
00000000                           248  ; \ 1= data register for read char
00000000                           249  DOWNLOAD MACRO
00000000                           250  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           251  
00000000                           252      MOVE.B DUART_SRA,\1                             ; read download status register
00000000                           253      BTST #0,\1                                      ; check for character
00000000                           254      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           255      
00000000                           256      MOVE.B DUART_RXA,\1                             ; got a character, read it
00000000                           257      
00000000                           258      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           259      BEQ START
00000000                           260  
00000000                           261      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           262  
00000000                           263      ENDM
00000000                           264  
00000000                           265  ; read two hex digits from the download serial port and convert to a byte
00000000                           266  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           267  DOWNLOAD_BYTE MACRO
00000000                           268      MOVE.B #2,\4
00000000                           269      WHILE.B \4 <GT> 0 DO
00000000                           270          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           271          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           272          ;PRINT_CHAR \2,\3
00000000                           273          HEX2BIN \2,\2,\6
00000000                           274          OR.B \2,\1
00000000                           275          SUB.B #1,\4
00000000                           276      ENDW
00000000                           277  
00000000                           278      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           279      MOVE.B \1,\2
00000000                           280      ADD.L \1,\5
00000000                           281  
00000000                           282      ENDM
00000000                           283  
00000000                           284  ; unprotect the EEPROM
00000000                           285  UNPROTECT MACRO
00000000                           286      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           287      NOP
00000000                           288      MOVE.W #$5555,$1554
00000000                           289      NOP
00000000                           290      MOVE.W #$8080,$2AAA
00000000                           291      NOP
00000000                           292      MOVE.W #$AAAA,$2AAA
00000000                           293      NOP
00000000                           294      MOVE.W #$5555,$1554
00000000                           295      NOP
00000000                           296      MOVE.W #$2020,$2AAA
00000000                           297      ENDM
00000000                           298      
00000000                           299  ; protect the EEPROM
00000000                           300  PROTECT MACRO
00000000                           301      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           302      MOVE.W #$5555,$1554
00000000                           303      MOVE.W #$A0A0,$2AAA
00000000                           304      ENDM
00000000                           305  ; write word to EEPROM
00000000                           306  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           307  PROGRAM MACRO
00000000                           308    MOVE.W \1,\2                                      ; write the data
00000000                           309  
00000000                           310  WAIT_FOR_COMPLETE\@
00000000                           311          MOVE.W \2,\3
00000000                           312  
00000000                           313          IF.W \3 <NE> \1 THEN
00000000                           314              BRA WAIT_FOR_COMPLETE\@
00000000                           315          ENDI
00000000                           316          ENDM
00000000                           317          
00000000                           318  ; program vector to EEPROM
00000000                           319  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           320  PROGRAM_VECTOR MACRO
00000000                           321      ADD.L #2,\2
00000000                           322      PROGRAM \1, (\2), \3                            ; write it
00000000                           323      LSR.L #8,\1
00000000                           324      LSR.L #8,\1
00000000                           325      SUB.L #2,\2
00000000                           326      PROGRAM \1, (\2), \3
00000000                           327      ENDM
00000000                           328  
00000000                           329  ; read an ide register
00000000                           330  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           331  READ_8 MACRO
00000000                           332      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           333      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           334      ORI.B \1, \3
00000000                           335      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           336      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           337      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           338      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           339      ORI.B #MC68230_PORT_C_READ, \3
00000000                           340      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           341      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           342      ENDM
00000000                           343      
00000000                           344  ; write an ide register
00000000                           345  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           346  WRITE_8 MACRO
00000000                           347      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           348      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           349      ORI.B \2, \3
00000000                           350      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           351      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           352      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           353      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           354      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           355      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           356      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           357      ENDM
00000000                           358  
00000000                           359  ; read ide data
00000000                           360  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           361  READ_16 MACRO
00000000                           362      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           363      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           364      
00000000                           365      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           366      ORI.B \1, \3
00000000                           367      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           368      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           369      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           370      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           371      LSL.W #8, \2
00000000                           372      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           373      ORI.B #MC68230_PORT_C_READ, \3
00000000                           374      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           375      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           376      ENDM
00000000                           377      
00000000                           378  ; read ide data
00000000                           379  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           380  READ_32 MACRO
00000000                           381      READ_16 \1, \2, \3
00000000                           382      LSL.L #8, \2
00000000                           383      LSL.L #8, \2
00000000                           384      READ_16 \1, \2, \3
00000000                           385      ENDM
00000000                           386          
00000000                           387  ; read ide status
00000000                           388  ;\1 = data register for result, \2 = working data register 
00000000                           389  READ_IDE_STATUS MACRO   
00000000                           390      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           391      ENDM
00000000                           392      
00000000                           393  ; wait for ide drive to be ready
00000000                           394  ;\1 = working data register 1, \2 = working data register 2
00000000                           395  WAIT_DRIVE_READY MACRO
00000000                           396  LOOP\@
00000000                           397      READ_IDE_STATUS \1, \2
00000000                           398      BTST #IDE_STATUS_READY, \1
00000000                           399      BEQ LOOP\@
00000000                           400      ENDM
00000000                           401      
00000000                           402  ; wait for ide drive to be not busy
00000000                           403  ;\1 = working data register 1, \2 = working data register 2
00000000                           404  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           405  LOOP\@
00000000                           406      READ_IDE_STATUS \1, \2
00000000                           407      BTST #IDE_STATUS_BUSY, \1
00000000                           408      BNE LOOP\@
00000000                           409      ENDM
00000000                           410      
00000000                           411  ; wait for ide drive to have data for us
00000000                           412  ;\1 = working data register 1, \2 = working data register 2
00000000                           413  WAIT_DRIVE_DRQ MACRO
00000000                           414  LOOP\@
00000000                           415      READ_IDE_STATUS \1, \2
00000000                           416      BTST #IDE_STATUS_DRQ, \1
00000000                           417      BEQ LOOP\@
00000000                           418      ENDM
00000000                           419      
00000000                           420  ; prepare to send a read command
00000000                           421  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           422  SET_READ_ADDRESS MACRO
00000000                           423      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           424      MOVE.L \1,\3
00000000                           425      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           426      LSR.L #8, \3
00000000                           427      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           428      LSR.L #8, \3                                
00000000                           429      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           430      LSR.L #8, \3
00000000                           431      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           432      ANDI.B #$0F,\3
00000000                           433      OR.B \3,\4
00000000                           434      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           435      ENDM
00000000                           436  
00000000                           437  ; send command
00000000                           438  ; \1 = command, \2 = working data register 1,
00000000                           439  SEND_COMMAND MACRO
00000000                           440      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           441      ENDM
00000000                           442      
00000000                           443  ; send read command and wait
00000000                           444  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           445  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           446      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           447      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           448      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           449      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           450      WAIT_DRIVE_DRQ \2, \3
00000000                           451      ENDM
00000000                           452  
00000000                           453  ; register catalogue
00000000                           454  ; D0 - used for simulator I/O
00000000                           455  ; D1 - used for simulator I/O
00000000                           456  ; D2 - read character
00000000                           457  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           458  ; D6 - working register used in R/W
00000000                           459  ; D7 - address accumulator, reset by download
00000000                           460  ; A0 - address of string to print 
00000000                           461  
00000000                           462  ; start vector
00000000= 002E0000                 463  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 464  RESET   DC.L START                              ; RESET
00000008= 00001C5C                 465  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001C5C                 466          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001DB0                 467          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001DC0                 468          DC.L UNHANDLED_HANDLER
00000018= 00001DC0                 469          DC.L UNHANDLED_HANDLER
0000001C= 00001DC0                 470          DC.L UNHANDLED_HANDLER
00000020= 00001DC0                 471          DC.L UNHANDLED_HANDLER
00000024= 00001DC0                 472          DC.L UNHANDLED_HANDLER
00000028= 00001DC0                 473          DC.L UNHANDLED_HANDLER
0000002C= 00001DC0                 474          DC.L UNHANDLED_HANDLER
00000030= 00001DC0                 475          DC.L UNHANDLED_HANDLER
00000034= 00001DC0                 476          DC.L UNHANDLED_HANDLER
00000038= 00001DC0                 477          DC.L UNHANDLED_HANDLER
0000003C= 00001DC0                 478          DC.L UNHANDLED_HANDLER
00000040= 00001DC0                 479          DC.L UNHANDLED_HANDLER
00000044= 00001DC0                 480          DC.L UNHANDLED_HANDLER
00000048= 00001DC0                 481          DC.L UNHANDLED_HANDLER
0000004C= 00001DC0                 482          DC.L UNHANDLED_HANDLER
00000050= 00001DC0                 483          DC.L UNHANDLED_HANDLER
00000054= 00001DC0                 484          DC.L UNHANDLED_HANDLER
00000058= 00001DC0                 485          DC.L UNHANDLED_HANDLER
0000005C= 00001DC0                 486          DC.L UNHANDLED_HANDLER
00000060= 00001DE4                 487          DC.L SPURIOUS_HANDLER
00000064= 00001DC0                 488          DC.L UNHANDLED_HANDLER
00000068= 00001DC0                 489          DC.L UNHANDLED_HANDLER
0000006C= 00001DC0                 490          DC.L UNHANDLED_HANDLER
00000070= 00001DC0                 491          DC.L UNHANDLED_HANDLER
00000074= 00001DC0                 492          DC.L UNHANDLED_HANDLER
00000078= 00001DC0                 493          DC.L UNHANDLED_HANDLER
0000007C= 00001DC0                 494          DC.L UNHANDLED_HANDLER
00000080= 00001DC0                 495          DC.L UNHANDLED_HANDLER
00000084= 00001DC0                 496          DC.L UNHANDLED_HANDLER
00000088= 00001DC0                 497          DC.L UNHANDLED_HANDLER
0000008C= 00001DC0                 498          DC.L UNHANDLED_HANDLER
00000090= 00001DC0                 499          DC.L UNHANDLED_HANDLER
00000094= 00001DC0                 500          DC.L UNHANDLED_HANDLER
00000098= 00001DC0                 501          DC.L UNHANDLED_HANDLER
0000009C= 00001DC0                 502          DC.L UNHANDLED_HANDLER
000000A0= 00001DC0                 503          DC.L UNHANDLED_HANDLER
000000A4= 00001DC0                 504          DC.L UNHANDLED_HANDLER
000000A8= 00001DC0                 505          DC.L UNHANDLED_HANDLER
000000AC= 00001DC0                 506          DC.L UNHANDLED_HANDLER
000000B0= 00001DC0                 507          DC.L UNHANDLED_HANDLER
000000B4= 00001DC0                 508          DC.L UNHANDLED_HANDLER
000000B8= 00001DC0                 509          DC.L UNHANDLED_HANDLER
000000BC= 00001DC0                 510          DC.L UNHANDLED_HANDLER
000000C0= 00001DC0                 511          DC.L UNHANDLED_HANDLER
000000C4= 00001DC0                 512          DC.L UNHANDLED_HANDLER
000000C8= 00001DC0                 513          DC.L UNHANDLED_HANDLER
000000CC= 00001DC0                 514          DC.L UNHANDLED_HANDLER
000000D0= 00001DC0                 515          DC.L UNHANDLED_HANDLER
000000D4= 00001DC0                 516          DC.L UNHANDLED_HANDLER
000000D8= 00001DC0                 517          DC.L UNHANDLED_HANDLER 
000000DC= 00001DC0                 518          DC.L UNHANDLED_HANDLER
000000E0= 00001DC0                 519          DC.L UNHANDLED_HANDLER
000000E4= 00001DC0                 520          DC.L UNHANDLED_HANDLER 
000000E8= 00001DC0                 521          DC.L UNHANDLED_HANDLER 
000000EC= 00001DC0                 522          DC.L UNHANDLED_HANDLER
000000F0= 00001DC0                 523          DC.L UNHANDLED_HANDLER 
000000F4= 00001DC0                 524          DC.L UNHANDLED_HANDLER 
000000F8= 00001DC0                 525          DC.L UNHANDLED_HANDLER 
000000FC= 00001DC0                 526          DC.L UNHANDLED_HANDLER
00000100= 00001DD4                 527  USER    DC.L TICK_HANDLER
00000104                           528      ; start of program  
00000104                           529  START
00000104  2E7C 002E0000            530      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       531      MOVE.B #0,DISPLAY
00000112                           532  
00000112  7000                     533      MOVE.L #0,D0
00000114  1039 00C00019            534      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           535  
0000011A                           536  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       537      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       538      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           539      
0000012A                           540      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                541s     MOVE.W  #$50,D1
0000012E  6000 000E                542s     BRA _20000001
00000132                           543s _20000000
00000132  13C1 00C00005            544          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     545          NOP
0000013A                           546      ENDF
0000013A  0441 0010                547s     SUB.W   #$10,D1
0000013E                           548s _20000001
0000013E  B27C 0010                549s     CMP.W   #$10,D1
00000142  6CEE                     550s     BGE _20000000
00000144                           551  
00000144                           552      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                553s     MOVE.W  #$50,D1
00000148  6000 000E                554s     BRA _20000003
0000014C                           555s _20000002
0000014C  13C1 00C00015            556          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     557          NOP
00000154                           558      ENDF
00000154  0441 0010                559s     SUB.W   #$10,D1
00000158                           560s _20000003
00000158  B27C 0010                561s     CMP.W   #$10,D1
0000015C  6CEE                     562s     BGE _20000002
0000015E                           563      
0000015E                           564  ;initialise UART
0000015E  13FC 0000 00C0000B       565      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       566      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       567      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       568      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       569      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           570  
00000186                           571  ; channel A
00000186  13FC 0013 00C00001       572      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       573      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       574      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       575      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           576  
000001A6                           577  ; channel B
000001A6  13FC 0013 00C00011       578      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       579      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       580      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       581      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       582      MOVE.B #64,DUART_IVR
000001CE                           583  
000001CE                           584m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           585m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      586m     IFEQ DEBUG
000001CE  1239 00C00003            587m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                588m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     589m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       590m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           591m     ENDC
000001E2                           592m 
000001E2                 FALSE     593m     IFNE DEBUG
000001E2                           594m     ENDC
000001E2                           595m 
000001E2                           596m     ENDM
000001E2                           597m     PRINT_CHAR #0,D1
000001E2                           598m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      599m     IFEQ DEBUG
000001E2  1239 00C00003            600m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                601m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     602m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       603m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           604m     ENDC
000001F6                           605m 
000001F6                 FALSE     606m     IFNE DEBUG
000001F6                           607m     ENDC
000001F6                           608m 
000001F6                           609m     ENDM
000001F6                           610m     PRINT_CHAR #0,D1
000001F6                           611m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      612m     IFEQ DEBUG
000001F6  1239 00C00003            613m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                614m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     615m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       616m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           617m     ENDC
0000020A                           618m 
0000020A                 FALSE     619m     IFNE DEBUG
0000020A                           620m     ENDC
0000020A                           621m 
0000020A                           622m     ENDM
0000020A                           623      
0000020A                           624      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                625s     CMP.W   #$0F,D0
0000020E  6600 0008                626s     BNE _00000000
00000212  1039 00C00005            627          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           628      ENDI
00000218                           629s _00000000
00000218                           630  
00000218  13FC 0001 00E00001       631      MOVE.B #1,DISPLAY
00000220                           632      
00000220                           633m     PRINT_CRLF D1,A0
00000220  41FA 1E0D                634m     LEA CRLF(PC),A0
00000224                           635mm     PRINT_STR A0,D1
00000224                           636mm LOOP_5
00000224  0C10 0000                637mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                638mm     BEQ EXIT_5
0000022C                           639mmm     PRINT_CHAR (A0)+,D1
0000022C                           640mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      641mmm     IFEQ DEBUG
0000022C  1239 00C00003            642mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                643mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     644mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            645mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           646mmm     ENDC
0000023E                           647mmm 
0000023E                 FALSE     648mmm     IFNE DEBUG
0000023E                           649mmm     ENDC
0000023E                           650mmm 
0000023E                           651mmm     ENDM
0000023E  60E4                     652mm     BRA LOOP_5
00000240                           653mm EXIT_5
00000240                           654mm     ENDM
00000240                           655m     ENDM
00000240  41FA 1EA2                656      LEA VERSION(PC),A0
00000244                           657m     PRINT_STR A0,D3
00000244                           658m LOOP_7
00000244  0C10 0000                659m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                660m     BEQ EXIT_7
0000024C                           661mm     PRINT_CHAR (A0)+,D3
0000024C                           662mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      663mm     IFEQ DEBUG
0000024C  1639 00C00003            664mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                665mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     666mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            667mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           668mm     ENDC
0000025E                           669mm 
0000025E                 FALSE     670mm     IFNE DEBUG
0000025E                           671mm     ENDC
0000025E                           672mm 
0000025E                           673mm     ENDM
0000025E  60E4                     674m     BRA LOOP_7
00000260                           675m EXIT_7
00000260                           676m     ENDM
00000260                           677  
00000260  41F9 00002102            678      LEA END,A0
00000266  2008                     679      MOVE.L A0,D0
00000268                           680m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1DCB                681m     LEA OX(PC),A0
0000026C                           682mm     PRINT_STR A0,D1
0000026C                           683mm LOOP_10
0000026C  0C10 0000                684mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                685mm     BEQ EXIT_10
00000274                           686mmm     PRINT_CHAR (A0)+,D1
00000274                           687mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      688mmm     IFEQ DEBUG
00000274  1239 00C00003            689mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                690mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     691mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            692mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           693mmm     ENDC
00000286                           694mmm 
00000286                 FALSE     695mmm     IFNE DEBUG
00000286                           696mmm     ENDC
00000286                           697mmm 
00000286                           698mmm     ENDM
00000286  60E4                     699mm     BRA LOOP_10
00000288                           700mm EXIT_10
00000288                           701mm     ENDM
00000288  7607                     702m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           703m LOOP_9
0000028A                           704mm     BIN2HEX D0,D2,A0
0000028A  41FA 1D68                705mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     706mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     707mm     MOVE.B D0,D2
00000292  0282 0000000F            708mm     ANDI.L #$F,D2
00000298  1430 2000                709mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           710mm     ENDM
0000029C                           711mm     PRINT_CHAR D2,D1
0000029C                           712mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      713mm     IFEQ DEBUG
0000029C  1239 00C00003            714mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                715mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     716mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            717mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           718mm     ENDC
000002AE                           719mm 
000002AE                 FALSE     720mm     IFNE DEBUG
000002AE                           721mm     ENDC
000002AE                           722mm 
000002AE                           723mm     ENDM
000002AE  57CB FFDA                724m     DBEQ D3,LOOP_9
000002B2                           725m     ENDM
000002B2                           726m     PRINT_CRLF D1,A0
000002B2  41FA 1D7B                727m     LEA CRLF(PC),A0
000002B6                           728mm     PRINT_STR A0,D1
000002B6                           729mm LOOP_15
000002B6  0C10 0000                730mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                731mm     BEQ EXIT_15
000002BE                           732mmm     PRINT_CHAR (A0)+,D1
000002BE                           733mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      734mmm     IFEQ DEBUG
000002BE  1239 00C00003            735mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                736mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     737mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            738mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           739mmm     ENDC
000002D0                           740mmm 
000002D0                 FALSE     741mmm     IFNE DEBUG
000002D0                           742mmm     ENDC
000002D0                           743mmm 
000002D0                           744mmm     ENDM
000002D0  60E4                     745mm     BRA LOOP_15
000002D2                           746mm EXIT_15
000002D2                           747mm     ENDM
000002D2                           748m     ENDM
000002D2                           749  
000002D2  41FA 1B36                750      LEA HELPPROMPT(PC),A0
000002D6                           751m     PRINT_STR A0,D3
000002D6                           752m LOOP_17
000002D6  0C10 0000                753m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                754m     BEQ EXIT_17
000002DE                           755mm     PRINT_CHAR (A0)+,D3
000002DE                           756mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      757mm     IFEQ DEBUG
000002DE  1639 00C00003            758mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                759mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     760mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            761mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           762mm     ENDC
000002F0                           763mm 
000002F0                 FALSE     764mm     IFNE DEBUG
000002F0                           765mm     ENDC
000002F0                           766mm 
000002F0                           767mm     ENDM
000002F0  60E4                     768m     BRA LOOP_17
000002F2                           769m EXIT_17
000002F2                           770m     ENDM
000002F2                           771  
000002F2                           772m     PRINT_CRLF D3,A0
000002F2  41FA 1D3B                773m     LEA CRLF(PC),A0
000002F6                           774mm     PRINT_STR A0,D3
000002F6                           775mm LOOP_20
000002F6  0C10 0000                776mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                777mm     BEQ EXIT_20
000002FE                           778mmm     PRINT_CHAR (A0)+,D3
000002FE                           779mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      780mmm     IFEQ DEBUG
000002FE  1639 00C00003            781mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                782mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     783mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            784mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           785mmm     ENDC
00000310                           786mmm 
00000310                 FALSE     787mmm     IFNE DEBUG
00000310                           788mmm     ENDC
00000310                           789mmm 
00000310                           790mmm     ENDM
00000310  60E4                     791mm     BRA LOOP_20
00000312                           792mm EXIT_20
00000312                           793mm     ENDM
00000312                           794m     ENDM
00000312                           795  
00000312  7E00                     796      MOVE.L #0,D7                                    ; address accumulator
00000314                           797  
00000314  13FC 0002 00E00001       798      MOVE.B #2,DISPLAY
0000031C                           799      
0000031C  13FC 0000 00A00001       800      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       801      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       802      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       803      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           804      
0000033C  13FC 0003 00E00001       805      MOVE.B #3,DISPLAY
00000344                           806      
00000344                           807      
00000344                           808  MAIN_LOOP
00000344  41FA 1CEC                809      LEA PROMPT(PC),A0
00000348                           810m     PRINT_STR A0,D3
00000348                           811m LOOP_22
00000348  0C10 0000                812m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                813m     BEQ EXIT_22
00000350                           814mm     PRINT_CHAR (A0)+,D3
00000350                           815mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      816mm     IFEQ DEBUG
00000350  1639 00C00003            817mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                818mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     819mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            820mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           821mm     ENDC
00000362                           822mm 
00000362                 FALSE     823mm     IFNE DEBUG
00000362                           824mm     ENDC
00000362                           825mm 
00000362                           826mm     ENDM
00000362  60E4                     827m     BRA LOOP_22
00000364                           828m EXIT_22
00000364                           829m     ENDM
00000364                           830  
00000364                           831  GET_INPUT
00000364                           832m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           833m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      834m     IFEQ DEBUG
00000364  1639 00C00003            835m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                836m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     837m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           838m     ENDC
00000370                           839m 
00000370                           840mm     READ_CHAR D2
00000370                 TRUE      841mm     IFEQ DEBUG
00000370  1439 00C00007            842mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           843mm     ENDC
00000376                 FALSE     844mm     IFNE DEBUG
00000376                           845mm     ENDC
00000376                           846mm 
00000376  B43C 001B                847mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                848mm     BEQ START
0000037E                           849mm     ENDM
0000037E                           850m 
0000037E                 TRUE      851m     IFEQ DEBUG
0000037E                           852mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           853mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      854mm     IFEQ DEBUG
0000037E  1639 00C00003            855mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                856mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     857mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            858mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           859mm     ENDC
00000390                           860mm 
00000390                 FALSE     861mm     IFNE DEBUG
00000390                           862mm     ENDC
00000390                           863mm 
00000390                           864mm     ENDM
00000390                           865m     ENDC
00000390                           866m     ENDM
00000390                           867  
00000390                           868      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                869s     CMP.B   #'0',D2
00000394  6D00 000E                870s     BLT _00000001
00000398  B43C 0039                871s     CMP.B   #'9',D2
0000039C  6E00 0006                872s     BGT _00000001
000003A0  6000 18A0                873          BRA HEX_DIGIT
000003A4                           874      ENDI
000003A4                           875s _00000001
000003A4                           876      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                877s     CMP.B   #'A',D2
000003A8  6D00 000E                878s     BLT _00000002
000003AC  B43C 0046                879s     CMP.B   #'F',D2
000003B0  6E00 0006                880s     BGT _00000002
000003B4  6000 188C                881          BRA HEX_DIGIT
000003B8                           882      ENDI
000003B8                           883s _00000002
000003B8                           884  
000003B8  B43C 0077                885      CMP.B #'w',D2
000003BC  6700 01C6                886      BEQ W
000003C0                           887  
000003C0  B43C 006C                888      CMP.B #'l',D2
000003C4  6700 08CC                889      BEQ L 
000003C8                           890  
000003C8  B43C 0070                891      CMP.B #'p',D2
000003CC  6700 0C0E                892      BEQ P
000003D0                           893  
000003D0                           894m     PRINT_CRLF D3,A0
000003D0  41FA 1C5D                895m     LEA CRLF(PC),A0
000003D4                           896mm     PRINT_STR A0,D3
000003D4                           897mm LOOP_28
000003D4  0C10 0000                898mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                899mm     BEQ EXIT_28
000003DC                           900mmm     PRINT_CHAR (A0)+,D3
000003DC                           901mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      902mmm     IFEQ DEBUG
000003DC  1639 00C00003            903mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                904mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     905mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            906mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           907mmm     ENDC
000003EE                           908mmm 
000003EE                 FALSE     909mmm     IFNE DEBUG
000003EE                           910mmm     ENDC
000003EE                           911mmm 
000003EE                           912mmm     ENDM
000003EE  60E4                     913mm     BRA LOOP_28
000003F0                           914mm EXIT_28
000003F0                           915mm     ENDM
000003F0                           916m     ENDM
000003F0                           917   
000003F0  B43C 003F                918      CMP.B #'?',D2
000003F4  6700 008A                919      BEQ H
000003F8                           920   
000003F8  B43C 0076                921      CMP.B #'v',D2
000003FC  6700 008A                922      BEQ V
00000400                           923      
00000400  B43C 0072                924      CMP.B #'r',D2
00000404  6700 00A6                925      BEQ R
00000408                           926  
00000408  B43C 0073                927      CMP.B #'s',D2
0000040C  6700 01F0                928      BEQ S
00000410                           929  
00000410  B43C 0067                930      CMP.B #'g',D2
00000414  6700 0786                931      BEQ G   
00000418                           932  
00000418  B43C 007A                933      CMP.B #'z',D2
0000041C  6700 0784                934      BEQ Z   
00000420                           935  
00000420  B43C 0078                936      CMP.B #'x',D2
00000424  6700 0D86                937      BEQ X
00000428                           938  
00000428  B43C 0049                939      CMP.B #'I',D2
0000042C  6700 0E9A                940      BEQ EI
00000430                           941  
00000430  B43C 006F                942      CMP.B #'o',D2
00000434  6700 0EA2                943      BEQ DI
00000438                           944  
00000438  B43C 0023                945      CMP.B #'#',D2
0000043C  6700 0EAA                946      BEQ HASH
00000440                           947  
00000440  B43C 0069                948      CMP.B #'i',D2
00000444  2A7C 00000000            949      MOVE.L #0, A5               ; not boot
0000044A  6700 0EB2                950      BEQ IB
0000044E                           951  
0000044E  B43C 0062                952      CMP.B #'b',D2
00000452  2A7C 00000001            953      MOVE.L #1, A5               ; boot
00000458  6700 0EA4                954      BEQ IB
0000045C                           955  
0000045C  41FA 1B34                956      LEA HUH(PC),A0
00000460                           957m     PRINT_STR A0,D3
00000460                           958m LOOP_30
00000460  0C10 0000                959m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000464  6700 0016                960m     BEQ EXIT_30
00000468                           961mm     PRINT_CHAR (A0)+,D3
00000468                           962mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      963mm     IFEQ DEBUG
00000468  1639 00C00003            964mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000046E  0803 0002                965mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000472  67F4                     966mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000474  13D8 00C00007            967mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047A                           968mm     ENDC
0000047A                           969mm 
0000047A                 FALSE     970mm     IFNE DEBUG
0000047A                           971mm     ENDC
0000047A                           972mm 
0000047A                           973mm     ENDM
0000047A  60E4                     974m     BRA LOOP_30
0000047C                           975m EXIT_30
0000047C                           976m     ENDM
0000047C                           977  
0000047C  6000 FEC6                978      BRA MAIN_LOOP
00000480                           979  
00000480                           980  ; commands
00000480                           981  H
00000480  41FA 199B                982      LEA HELP(PC),A0
00000484  6000 0006                983      BRA PRINTIT
00000488                           984  
00000488                           985  V
00000488  41FA 1C5A                986      LEA VERSION(PC),A0
0000048C                           987  PRINTIT
0000048C                           988m     PRINT_STR A0,D3    
0000048C                           989m LOOP_32
0000048C  0C10 0000                990m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000490  6700 0016                991m     BEQ EXIT_32
00000494                           992mm     PRINT_CHAR (A0)+,D3
00000494                           993mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000494                 TRUE      994mm     IFEQ DEBUG
00000494  1639 00C00003            995mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000049A  0803 0002                996mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000049E  67F4                     997mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
000004A0  13D8 00C00007            998mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004A6                           999mm     ENDC
000004A6                          1000mm 
000004A6                 FALSE    1001mm     IFNE DEBUG
000004A6                          1002mm     ENDC
000004A6                          1003mm 
000004A6                          1004mm     ENDM
000004A6  60E4                    1005m     BRA LOOP_32
000004A8                          1006m EXIT_32
000004A8                          1007m     ENDM
000004A8  6000 FE9A               1008      BRA MAIN_LOOP
000004AC                          1009  
000004AC                          1010  R
000004AC  2047                    1011      MOVE.L D7,A0                                    ; address accumulator -> address register
000004AE  7E00                    1012      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B0  2410                    1013      MOVE.L (A0),D2                                  ; read the memory and print it
000004B2                          1014m     PRINT_REG D2,D3,D4,D5,A0
000004B2  41FA 1B81               1015m     LEA OX(PC),A0
000004B6                          1016mm     PRINT_STR A0,D3
000004B6                          1017mm LOOP_35
000004B6  0C10 0000               1018mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004BA  6700 0016               1019mm     BEQ EXIT_35
000004BE                          1020mmm     PRINT_CHAR (A0)+,D3
000004BE                          1021mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                 TRUE     1022mmm     IFEQ DEBUG
000004BE  1639 00C00003           1023mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004C4  0803 0002               1024mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C8  67F4                    1025mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004CA  13D8 00C00007           1026mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004D0                          1027mmm     ENDC
000004D0                          1028mmm 
000004D0                 FALSE    1029mmm     IFNE DEBUG
000004D0                          1030mmm     ENDC
000004D0                          1031mmm 
000004D0                          1032mmm     ENDM
000004D0  60E4                    1033mm     BRA LOOP_35
000004D2                          1034mm EXIT_35
000004D2                          1035mm     ENDM
000004D2  7A07                    1036m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004D4                          1037m LOOP_34
000004D4                          1038mm     BIN2HEX D2,D4,A0
000004D4  41FA 1B1E               1039mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004D8  E99A                    1040mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004DA  1802                    1041mm     MOVE.B D2,D4
000004DC  0284 0000000F           1042mm     ANDI.L #$F,D4
000004E2  1830 4000               1043mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004E6                          1044mm     ENDM
000004E6                          1045mm     PRINT_CHAR D4,D3
000004E6                          1046mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E6                 TRUE     1047mm     IFEQ DEBUG
000004E6  1639 00C00003           1048mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EC  0803 0002               1049mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F0  67F4                    1050mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004F2  13C4 00C00007           1051mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F8                          1052mm     ENDC
000004F8                          1053mm 
000004F8                 FALSE    1054mm     IFNE DEBUG
000004F8                          1055mm     ENDC
000004F8                          1056mm 
000004F8                          1057mm     ENDM
000004F8  57CD FFDA               1058m     DBEQ D5,LOOP_34
000004FC                          1059m     ENDM
000004FC                          1060      
000004FC                          1061m     PRINT_CHAR #32,D3
000004FC                          1062m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FC                 TRUE     1063m     IFEQ DEBUG
000004FC  1639 00C00003           1064m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000502  0803 0002               1065m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000506  67F4                    1066m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000508  13FC 0020 00C00007      1067m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000510                          1068m     ENDC
00000510                          1069m 
00000510                 FALSE    1070m     IFNE DEBUG
00000510                          1071m     ENDC
00000510                          1072m 
00000510                          1073m     ENDM
00000510                          1074  
00000510  E19A                    1075      ROL.L #8,D2
00000512                          1076m     PRINT_CHAR D2,D3
00000512                          1077m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1078m     IFEQ DEBUG
00000512  1639 00C00003           1079m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1080m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1081m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1082m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1083m     ENDC
00000524                          1084m 
00000524                 FALSE    1085m     IFNE DEBUG
00000524                          1086m     ENDC
00000524                          1087m 
00000524                          1088m     ENDM
00000524  E19A                    1089      ROL.L #8,D2
00000526                          1090m     PRINT_CHAR D2,D3
00000526                          1091m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1092m     IFEQ DEBUG
00000526  1639 00C00003           1093m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1094m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1095m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1096m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1097m     ENDC
00000538                          1098m 
00000538                 FALSE    1099m     IFNE DEBUG
00000538                          1100m     ENDC
00000538                          1101m 
00000538                          1102m     ENDM
00000538  E19A                    1103      ROL.L #8,D2
0000053A                          1104m     PRINT_CHAR D2,D3
0000053A                          1105m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1106m     IFEQ DEBUG
0000053A  1639 00C00003           1107m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1108m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1109m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1110m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1111m     ENDC
0000054C                          1112m 
0000054C                 FALSE    1113m     IFNE DEBUG
0000054C                          1114m     ENDC
0000054C                          1115m 
0000054C                          1116m     ENDM
0000054C  E19A                    1117      ROL.L #8,D2
0000054E                          1118m     PRINT_CHAR D2,D3
0000054E                          1119m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054E                 TRUE     1120m     IFEQ DEBUG
0000054E  1639 00C00003           1121m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000554  0803 0002               1122m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000558  67F4                    1123m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000055A  13C2 00C00007           1124m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000560                          1125m     ENDC
00000560                          1126m 
00000560                 FALSE    1127m     IFNE DEBUG
00000560                          1128m     ENDC
00000560                          1129m 
00000560                          1130m     ENDM
00000560                          1131  
00000560                          1132m     PRINT_CRLF D3,A0
00000560  41FA 1ACD               1133m     LEA CRLF(PC),A0
00000564                          1134mm     PRINT_STR A0,D3
00000564                          1135mm LOOP_45
00000564  0C10 0000               1136mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016               1137mm     BEQ EXIT_45
0000056C                          1138mmm     PRINT_CHAR (A0)+,D3
0000056C                          1139mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE     1140mmm     IFEQ DEBUG
0000056C  1639 00C00003           1141mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000572  0803 0002               1142mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                    1143mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007           1144mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                          1145mmm     ENDC
0000057E                          1146mmm 
0000057E                 FALSE    1147mmm     IFNE DEBUG
0000057E                          1148mmm     ENDC
0000057E                          1149mmm 
0000057E                          1150mmm     ENDM
0000057E  60E4                    1151mm     BRA LOOP_45
00000580                          1152mm EXIT_45
00000580                          1153mm     ENDM
00000580                          1154m     ENDM
00000580                          1155      
00000580  6000 FDC2               1156      BRA MAIN_LOOP
00000584                          1157  
00000584                          1158  W
00000584                          1159      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000584  3C3C 0000               1160s     MOVE.W  #0,D6
00000588  6000 0046               1161s     BRA _20000005
0000058C                          1162s _20000004
0000058C  E98D                    1163          LSL.L #4,D5                                     ; make what we have so far more significant
0000058E                          1164m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000058E                          1165m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058E                 TRUE     1166m     IFEQ DEBUG
0000058E  1639 00C00003           1167m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000594  0803 0000               1168m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000598  67F4                    1169m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
0000059A                          1170m     ENDC
0000059A                          1171m 
0000059A                          1172mm     READ_CHAR D2
0000059A                 TRUE     1173mm     IFEQ DEBUG
0000059A  1439 00C00007           1174mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000005A0                          1175mm     ENDC
000005A0                 FALSE    1176mm     IFNE DEBUG
000005A0                          1177mm     ENDC
000005A0                          1178mm 
000005A0  B43C 001B               1179mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000005A4  6700 FB5E               1180mm     BEQ START
000005A8                          1181mm     ENDM
000005A8                          1182m 
000005A8                 TRUE     1183m     IFEQ DEBUG
000005A8                          1184mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000005A8                          1185mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A8                 TRUE     1186mm     IFEQ DEBUG
000005A8  1639 00C00003           1187mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005AE  0803 0002               1188mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B2  67F4                    1189mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005B4  13C2 00C00007           1190mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005BA                          1191mm     ENDC
000005BA                          1192mm 
000005BA                 FALSE    1193mm     IFNE DEBUG
000005BA                          1194mm     ENDC
000005BA                          1195mm 
000005BA                          1196mm     ENDM
000005BA                          1197m     ENDC
000005BA                          1198m     ENDM
000005BA                          1199m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005BA  41FA 1A48               1200m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005BE  0402 0030               1201m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005C2  C4BC 000000FF           1202m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005C8  1430 2000               1203m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005CC                          1204m     ENDM
000005CC  8A02                    1205          OR.B D2,D5
000005CE                          1206      ENDF
000005CE  5246                    1207s     ADD.W   #1,D6
000005D0                          1208s _20000005
000005D0  BC7C 0007               1209s     CMP.W   #7,D6
000005D4  6FB6                    1210s     BLE _20000004
000005D6                          1211  
000005D6                          1212m     PRINT_CRLF D3,A0
000005D6  41FA 1A57               1213m     LEA CRLF(PC),A0
000005DA                          1214mm     PRINT_STR A0,D3
000005DA                          1215mm LOOP_52
000005DA  0C10 0000               1216mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005DE  6700 0016               1217mm     BEQ EXIT_52
000005E2                          1218mmm     PRINT_CHAR (A0)+,D3
000005E2                          1219mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                 TRUE     1220mmm     IFEQ DEBUG
000005E2  1639 00C00003           1221mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005E8  0803 0002               1222mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005EC  67F4                    1223mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005EE  13D8 00C00007           1224mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005F4                          1225mmm     ENDC
000005F4                          1226mmm 
000005F4                 FALSE    1227mmm     IFNE DEBUG
000005F4                          1228mmm     ENDC
000005F4                          1229mmm 
000005F4                          1230mmm     ENDM
000005F4  60E4                    1231mm     BRA LOOP_52
000005F6                          1232mm EXIT_52
000005F6                          1233mm     ENDM
000005F6                          1234m     ENDM
000005F6                          1235  
000005F6  2047                    1236      MOVE.L D7,A0                                    ; address accumulator -> address register
000005F8                          1237  
000005F8  2085                    1238      MOVE.L D5,(A0)                                  ; write the data
000005FA                          1239  
000005FA  6000 FD48               1240      BRA MAIN_LOOP
000005FE                          1241  
000005FE                          1242  ; register map for S
000005FE                          1243  ; A0 - start address
000005FE                          1244  ; A1 - offset
000005FE                          1245  ; A2 - next address to write
000005FE                          1246  ; A3 - next location (jmp)
000005FE                          1247  ; A4 - Working Address Register
000005FE                          1248  ; D0 - record count
000005FE                          1249  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005FE                          1250  ; D2 - checksum
000005FE                          1251  ; D3 - data byte count
000005FE                          1252  ; D4 - read address, moved into A2
000005FE                          1253  ; D5 - temp
000005FE                          1254  ; D6 - temp
000005FE                          1255  ; D7 - temp
000005FE                          1256  S
000005FE  2078 0000               1257      MOVE.L 0,A0                                     ; start address -> A0
00000602  2247                    1258      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000604  7E00                    1259      MOVE.L #0,D7
00000606  7000                    1260      MOVE.L #0,D0                                    ; count of records read -> D0
00000608                          1261          
00000608                          1262  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000608                          1263m     DOWNLOAD D1
00000608                          1264m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1265m 
00000608  1239 00C00003           1266m     MOVE.B DUART_SRA,D1                             ; READ DOWNLOAD STATUS REGISTER
0000060E  0801 0000               1267m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000612  67F4                    1268m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
00000614                          1269m     
00000614  1239 00C00007           1270m     MOVE.B DUART_RXA,D1                             ; GOT A CHARACTER, READ IT
0000061A                          1271m     
0000061A  B23C 001B               1272m     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000061E  6700 FAE4               1273m     BEQ START
00000622                          1274m 
00000622  13C1 00E00001           1275m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000628                          1276m 
00000628                          1277m     ENDM
00000628  B23C 0053               1278      CMP.B #'S',D1                                   ; found S?
0000062C  66DA                    1279      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000062E                          1280      
0000062E                          1281m     PRINT_CHAR #'.',D5                              ; print a progress indicator
0000062E                          1282m WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                 TRUE     1283m     IFEQ DEBUG
0000062E  1A39 00C00003           1284m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000634  0805 0002               1285m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000638  67F4                    1286m         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
0000063A  13FC 002E 00C00007      1287m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000642                          1288m     ENDC
00000642                          1289m 
00000642                 FALSE    1290m     IFNE DEBUG
00000642                          1291m     ENDC
00000642                          1292m 
00000642                          1293m     ENDM
00000642                          1294      ;PRINT_CHAR #'S',D5                             ; print the S
00000642  5280                    1295      ADD.L #1,D0                                     ; read another S record, increment count
00000644                          1296      
00000644                          1297m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000644                          1298m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000644                          1299m 
00000644  1239 00C00003           1300m     MOVE.B DUART_SRA,D1                             ; READ DOWNLOAD STATUS REGISTER
0000064A  0801 0000               1301m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000064E  67F4                    1302m     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
00000650                          1303m     
00000650  1239 00C00007           1304m     MOVE.B DUART_RXA,D1                             ; GOT A CHARACTER, READ IT
00000656                          1305m     
00000656  B23C 001B               1306m     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000065A  6700 FAA8               1307m     BEQ START
0000065E                          1308m 
0000065E  13C1 00E00001           1309m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000664                          1310m 
00000664                          1311m     ENDM
00000664                          1312      ;PRINT_CHAR D1,D5
00000664                          1313  
00000664  7400                    1314      MOVE.L #0,D2                                    ; clear the checksum
00000666                          1315  
00000666                          1316m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000666  1E3C 0002               1317m     MOVE.B #2,D7
0000066A                          1318m     WHILE.B D7 <GT> 0 DO
0000066A                          1319ms _10000000
0000066A  BE38 0000               1320ms     CMP.B   0,D7
0000066E  6F00 003C               1321ms     BLE _10000001
00000672  E98B                    1322m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000674                          1323mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000674                          1324mm WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000674                          1325mm 
00000674  1A39 00C00003           1326mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
0000067A  0805 0000               1327mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000067E  67F4                    1328mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000680                          1329mm     
00000680  1A39 00C00007           1330mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000686                          1331mm     
00000686  BA3C 001B               1332mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000068A  6700 FA78               1333mm     BEQ START
0000068E                          1334mm 
0000068E  13C5 00E00001           1335mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000694                          1336mm 
00000694                          1337mm     ENDM
00000694                          1338m         ;PRINT_CHAR D5,D6
00000694                          1339mm         HEX2BIN D5,D5,A4
00000694  49FA 196E               1340mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000698  0405 0030               1341mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000069C  CABC 000000FF           1342mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006A2  1A34 5000               1343mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006A6                          1344mm     ENDM
000006A6  8605                    1345m         OR.B D5,D3
000006A8  5307                    1346m         SUB.B #1,D7
000006AA                          1347m     ENDW
000006AA  60BE                    1348ms     BRA _10000000
000006AC                          1349ms _10000001
000006AC                          1350m 
000006AC  7A00                    1351m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006AE  1A03                    1352m     MOVE.B D3,D5
000006B0  D483                    1353m     ADD.L D3,D2
000006B2                          1354m 
000006B2                          1355m     ENDM
000006B2                          1356  
000006B2                          1357      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006B2  B23C 0030               1358s     CMP.B   #'0',D1
000006B6  6600 000A               1359s     BNE.L   _00000003
000006BA                          1360          ;PRINT_CRLF D5,A4
000006BA  6000 FF4C               1361          BRA WAIT_FOR_SRECORD
000006BE                          1362      ELSE
000006BE  6000 02D4               1363s     BRA _00000004
000006C2                          1364s _00000003
000006C2                          1365          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006C2  B23C 0031               1366s     CMP.B   #'1',D1
000006C6  6708                    1367s     BEQ.S   _00000005
000006C8  B23C 0032               1368s     CMP.B   #'2',D1
000006CC  6600 0158               1369s     BNE.L   _00000006
000006D0                          1370s _00000005
000006D0  5783                    1371              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000006D2                          1372  
000006D2  7800                    1373              MOVE.L #0,D4                            ; read two bytes of address
000006D4                          1374m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000006D4  1E3C 0002               1375m     MOVE.B #2,D7
000006D8                          1376m     WHILE.B D7 <GT> 0 DO
000006D8                          1377ms _10000002
000006D8  BE38 0000               1378ms     CMP.B   0,D7
000006DC  6F00 003C               1379ms     BLE _10000003
000006E0  E98C                    1380m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006E2                          1381mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006E2                          1382mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E2                          1383mm 
000006E2  1A39 00C00003           1384mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000006E8  0805 0000               1385mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006EC  67F4                    1386mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000006EE                          1387mm     
000006EE  1A39 00C00007           1388mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000006F4                          1389mm     
000006F4  BA3C 001B               1390mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006F8  6700 FA0A               1391mm     BEQ START
000006FC                          1392mm 
000006FC  13C5 00E00001           1393mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000702                          1394mm 
00000702                          1395mm     ENDM
00000702                          1396m         ;PRINT_CHAR D5,D6
00000702                          1397mm         HEX2BIN D5,D5,A4
00000702  49FA 1900               1398mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000706  0405 0030               1399mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000070A  CABC 000000FF           1400mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000710  1A34 5000               1401mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000714                          1402mm     ENDM
00000714  8805                    1403m         OR.B D5,D4
00000716  5307                    1404m         SUB.B #1,D7
00000718                          1405m     ENDW
00000718  60BE                    1406ms     BRA _10000002
0000071A                          1407ms _10000003
0000071A                          1408m 
0000071A  7A00                    1409m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000071C  1A04                    1410m     MOVE.B D4,D5
0000071E  D484                    1411m     ADD.L D4,D2
00000720                          1412m 
00000720                          1413m     ENDM
00000720                          1414m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000720  1E3C 0002               1415m     MOVE.B #2,D7
00000724                          1416m     WHILE.B D7 <GT> 0 DO
00000724                          1417ms _10000004
00000724  BE38 0000               1418ms     CMP.B   0,D7
00000728  6F00 003C               1419ms     BLE _10000005
0000072C  E98C                    1420m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000072E                          1421mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000072E                          1422mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000072E                          1423mm 
0000072E  1A39 00C00003           1424mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000734  0805 0000               1425mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000738  67F4                    1426mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
0000073A                          1427mm     
0000073A  1A39 00C00007           1428mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000740                          1429mm     
00000740  BA3C 001B               1430mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000744  6700 F9BE               1431mm     BEQ START
00000748                          1432mm 
00000748  13C5 00E00001           1433mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000074E                          1434mm 
0000074E                          1435mm     ENDM
0000074E                          1436m         ;PRINT_CHAR D5,D6
0000074E                          1437mm         HEX2BIN D5,D5,A4
0000074E  49FA 18B4               1438mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000752  0405 0030               1439mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000756  CABC 000000FF           1440mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000075C  1A34 5000               1441mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000760                          1442mm     ENDM
00000760  8805                    1443m         OR.B D5,D4
00000762  5307                    1444m         SUB.B #1,D7
00000764                          1445m     ENDW
00000764  60BE                    1446ms     BRA _10000004
00000766                          1447ms _10000005
00000766                          1448m 
00000766  7A00                    1449m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000768  1A04                    1450m     MOVE.B D4,D5
0000076A  D484                    1451m     ADD.L D4,D2
0000076C                          1452m 
0000076C                          1453m     ENDM
0000076C                          1454  
0000076C                          1455              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
0000076C  B23C 0032               1456s     CMP.B   #'2',D1
00000770  6600 0050               1457s     BNE.L   _00000007
00000774  5383                    1458                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000776                          1459m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000776  1E3C 0002               1460m     MOVE.B #2,D7
0000077A                          1461m     WHILE.B D7 <GT> 0 DO
0000077A                          1462ms _10000006
0000077A  BE38 0000               1463ms     CMP.B   0,D7
0000077E  6F00 003C               1464ms     BLE _10000007
00000782  E98C                    1465m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000784                          1466mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000784                          1467mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000784                          1468mm 
00000784  1A39 00C00003           1469mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
0000078A  0805 0000               1470mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000078E  67F4                    1471mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000790                          1472mm     
00000790  1A39 00C00007           1473mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000796                          1474mm     
00000796  BA3C 001B               1475mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000079A  6700 F968               1476mm     BEQ START
0000079E                          1477mm 
0000079E  13C5 00E00001           1478mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007A4                          1479mm 
000007A4                          1480mm     ENDM
000007A4                          1481m         ;PRINT_CHAR D5,D6
000007A4                          1482mm         HEX2BIN D5,D5,A4
000007A4  49FA 185E               1483mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A8  0405 0030               1484mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007AC  CABC 000000FF           1485mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007B2  1A34 5000               1486mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B6                          1487mm     ENDM
000007B6  8805                    1488m         OR.B D5,D4
000007B8  5307                    1489m         SUB.B #1,D7
000007BA                          1490m     ENDW
000007BA  60BE                    1491ms     BRA _10000006
000007BC                          1492ms _10000007
000007BC                          1493m 
000007BC  7A00                    1494m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007BE  1A04                    1495m     MOVE.B D4,D5
000007C0  D484                    1496m     ADD.L D4,D2
000007C2                          1497m 
000007C2                          1498m     ENDM
000007C2                          1499              ENDI
000007C2                          1500s _00000007
000007C2                          1501  
000007C2  2444                    1502              MOVE.L D4,A2                            ; put the address in an address register
000007C4  D5C9                    1503              ADD.L A1,A2                             ; add in the offset
000007C6                          1504  
000007C6                          1505              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000007C6                          1506s _10000008
000007C6  B63C 0000               1507s     CMP.B   #0,D3
000007CA  6F00 0054               1508s     BLE _10000009
000007CE                          1509m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000007CE  1E3C 0002               1510m     MOVE.B #2,D7
000007D2                          1511m     WHILE.B D7 <GT> 0 DO
000007D2                          1512ms _1000000A
000007D2  BE38 0000               1513ms     CMP.B   0,D7
000007D6  6F00 003C               1514ms     BLE _1000000B
000007DA  E989                    1515m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000007DC                          1516mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007DC                          1517mm WAIT_FOR_READY_70                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007DC                          1518mm 
000007DC  1A39 00C00003           1519mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E2  0805 0000               1520mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E6  67F4                    1521mm     BEQ WAIT_FOR_READY_70                           ; NOTHING, CHECK AGAIN
000007E8                          1522mm     
000007E8  1A39 00C00007           1523mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000007EE                          1524mm     
000007EE  BA3C 001B               1525mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007F2  6700 F910               1526mm     BEQ START
000007F6                          1527mm 
000007F6  13C5 00E00001           1528mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007FC                          1529mm 
000007FC                          1530mm     ENDM
000007FC                          1531m         ;PRINT_CHAR D5,D6
000007FC                          1532mm         HEX2BIN D5,D5,A4
000007FC  49FA 1806               1533mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000800  0405 0030               1534mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000804  CABC 000000FF           1535mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000080A  1A34 5000               1536mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000080E                          1537mm     ENDM
0000080E  8205                    1538m         OR.B D5,D1
00000810  5307                    1539m         SUB.B #1,D7
00000812                          1540m     ENDW
00000812  60BE                    1541ms     BRA _1000000A
00000814                          1542ms _1000000B
00000814                          1543m 
00000814  7A00                    1544m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000816  1A01                    1545m     MOVE.B D1,D5
00000818  D481                    1546m     ADD.L D1,D2
0000081A                          1547m 
0000081A                          1548m     ENDM
0000081A                          1549   
0000081A  14C1                    1550                  MOVE.B D1,(A2)+                     ; store it!
0000081C                          1551  
0000081C  5303                    1552                  SUB.B #1,D3                         ; 1 less byte to go
0000081E                          1553              ENDW
0000081E  60A6                    1554s     BRA _10000008
00000820                          1555s _10000009
00000820                          1556  
00000820  7200                    1557              MOVE.L #0,D1                            ; not done yet
00000822                          1558          ELSE
00000822  6000 0170               1559s     BRA _00000008
00000826                          1560s _00000006
00000826                          1561              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000826  B23C 0038               1562s     CMP.B   #'8',D1
0000082A  6600 00F2               1563s     BNE.L   _00000009
0000082E  7800                    1564                  MOVE.L #0,D4                        ; read the 24 bit start address
00000830                          1565m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000830  1E3C 0002               1566m     MOVE.B #2,D7
00000834                          1567m     WHILE.B D7 <GT> 0 DO
00000834                          1568ms _1000000C
00000834  BE38 0000               1569ms     CMP.B   0,D7
00000838  6F00 003C               1570ms     BLE _1000000D
0000083C  E98C                    1571m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000083E                          1572mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000083E                          1573mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083E                          1574mm 
0000083E  1A39 00C00003           1575mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000844  0805 0000               1576mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000848  67F4                    1577mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
0000084A                          1578mm     
0000084A  1A39 00C00007           1579mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000850                          1580mm     
00000850  BA3C 001B               1581mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000854  6700 F8AE               1582mm     BEQ START
00000858                          1583mm 
00000858  13C5 00E00001           1584mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000085E                          1585mm 
0000085E                          1586mm     ENDM
0000085E                          1587m         ;PRINT_CHAR D5,D6
0000085E                          1588mm         HEX2BIN D5,D5,A4
0000085E  49FA 17A4               1589mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000862  0405 0030               1590mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000866  CABC 000000FF           1591mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000086C  1A34 5000               1592mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000870                          1593mm     ENDM
00000870  8805                    1594m         OR.B D5,D4
00000872  5307                    1595m         SUB.B #1,D7
00000874                          1596m     ENDW
00000874  60BE                    1597ms     BRA _1000000C
00000876                          1598ms _1000000D
00000876                          1599m 
00000876  7A00                    1600m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000878  1A04                    1601m     MOVE.B D4,D5
0000087A  D484                    1602m     ADD.L D4,D2
0000087C                          1603m 
0000087C                          1604m     ENDM
0000087C                          1605m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000087C  1E3C 0002               1606m     MOVE.B #2,D7
00000880                          1607m     WHILE.B D7 <GT> 0 DO
00000880                          1608ms _1000000E
00000880  BE38 0000               1609ms     CMP.B   0,D7
00000884  6F00 003C               1610ms     BLE _1000000F
00000888  E98C                    1611m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000088A                          1612mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000088A                          1613mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088A                          1614mm 
0000088A  1A39 00C00003           1615mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000890  0805 0000               1616mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000894  67F4                    1617mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00000896                          1618mm     
00000896  1A39 00C00007           1619mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
0000089C                          1620mm     
0000089C  BA3C 001B               1621mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008A0  6700 F862               1622mm     BEQ START
000008A4                          1623mm 
000008A4  13C5 00E00001           1624mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008AA                          1625mm 
000008AA                          1626mm     ENDM
000008AA                          1627m         ;PRINT_CHAR D5,D6
000008AA                          1628mm         HEX2BIN D5,D5,A4
000008AA  49FA 1758               1629mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008AE  0405 0030               1630mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008B2  CABC 000000FF           1631mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008B8  1A34 5000               1632mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008BC                          1633mm     ENDM
000008BC  8805                    1634m         OR.B D5,D4
000008BE  5307                    1635m         SUB.B #1,D7
000008C0                          1636m     ENDW
000008C0  60BE                    1637ms     BRA _1000000E
000008C2                          1638ms _1000000F
000008C2                          1639m 
000008C2  7A00                    1640m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008C4  1A04                    1641m     MOVE.B D4,D5
000008C6  D484                    1642m     ADD.L D4,D2
000008C8                          1643m 
000008C8                          1644m     ENDM
000008C8                          1645m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000008C8  1E3C 0002               1646m     MOVE.B #2,D7
000008CC                          1647m     WHILE.B D7 <GT> 0 DO
000008CC                          1648ms _10000010
000008CC  BE38 0000               1649ms     CMP.B   0,D7
000008D0  6F00 003C               1650ms     BLE _10000011
000008D4  E98C                    1651m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008D6                          1652mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008D6                          1653mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D6                          1654mm 
000008D6  1A39 00C00003           1655mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DC  0805 0000               1656mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E0  67F4                    1657mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
000008E2                          1658mm     
000008E2  1A39 00C00007           1659mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000008E8                          1660mm     
000008E8  BA3C 001B               1661mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008EC  6700 F816               1662mm     BEQ START
000008F0                          1663mm 
000008F0  13C5 00E00001           1664mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008F6                          1665mm 
000008F6                          1666mm     ENDM
000008F6                          1667m         ;PRINT_CHAR D5,D6
000008F6                          1668mm         HEX2BIN D5,D5,A4
000008F6  49FA 170C               1669mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008FA  0405 0030               1670mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008FE  CABC 000000FF           1671mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000904  1A34 5000               1672mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000908                          1673mm     ENDM
00000908  8805                    1674m         OR.B D5,D4
0000090A  5307                    1675m         SUB.B #1,D7
0000090C                          1676m     ENDW
0000090C  60BE                    1677ms     BRA _10000010
0000090E                          1678ms _10000011
0000090E                          1679m 
0000090E  7A00                    1680m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000910  1A04                    1681m     MOVE.B D4,D5
00000912  D484                    1682m     ADD.L D4,D2
00000914                          1683m 
00000914                          1684m     ENDM
00000914                          1685  
00000914  2044                    1686                  MOVE.L D4,A0                        ; start address -> A0
00000916  D1C9                    1687                  ADD.L A1,A0                         ; add in the offset
00000918                          1688  
00000918  72FF                    1689                  MOVE.L #$FFFFFFFF,D1                ; done
0000091A                          1690              ELSE
0000091A  6000 0078               1691s     BRA _0000000A
0000091E                          1692s _00000009
0000091E                          1693m                 PRINT_CRLF D5,A4
0000091E  49FA 170F               1694m     LEA CRLF(PC),A4
00000922                          1695mm     PRINT_STR A4,D5
00000922                          1696mm LOOP_82
00000922  0C14 0000               1697mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000926  6700 0016               1698mm     BEQ EXIT_82
0000092A                          1699mmm     PRINT_CHAR (A4)+,D5
0000092A                          1700mmm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092A                 TRUE     1701mmm     IFEQ DEBUG
0000092A  1A39 00C00003           1702mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000930  0805 0002               1703mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000934  67F4                    1704mmm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
00000936  13DC 00C00007           1705mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000093C                          1706mmm     ENDC
0000093C                          1707mmm 
0000093C                 FALSE    1708mmm     IFNE DEBUG
0000093C                          1709mmm     ENDC
0000093C                          1710mmm 
0000093C                          1711mmm     ENDM
0000093C  60E4                    1712mm     BRA LOOP_82
0000093E                          1713mm EXIT_82
0000093E                          1714mm     ENDM
0000093E                          1715m     ENDM
0000093E                          1716  
0000093E  49FA 167B               1717                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000942                          1718m                 PRINT_STR A4,D5
00000942                          1719m LOOP_84
00000942  0C14 0000               1720m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000946  6700 0016               1721m     BEQ EXIT_84
0000094A                          1722mm     PRINT_CHAR (A4)+,D5
0000094A                          1723mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094A                 TRUE     1724mm     IFEQ DEBUG
0000094A  1A39 00C00003           1725mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000950  0805 0002               1726mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000954  67F4                    1727mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000956  13DC 00C00007           1728mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000095C                          1729mm     ENDC
0000095C                          1730mm 
0000095C                 FALSE    1731mm     IFNE DEBUG
0000095C                          1732mm     ENDC
0000095C                          1733mm 
0000095C                          1734mm     ENDM
0000095C  60E4                    1735m     BRA LOOP_84
0000095E                          1736m EXIT_84
0000095E                          1737m     ENDM
0000095E                          1738m                 PRINT_CHAR D1,D5
0000095E                          1739m WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095E                 TRUE     1740m     IFEQ DEBUG
0000095E  1A39 00C00003           1741m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000964  0805 0002               1742m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000968  67F4                    1743m         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
0000096A  13C1 00C00007           1744m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000970                          1745m     ENDC
00000970                          1746m 
00000970                 FALSE    1747m     IFNE DEBUG
00000970                          1748m     ENDC
00000970                          1749m 
00000970                          1750m     ENDM
00000970                          1751m                 PRINT_CRLF D5,A4
00000970  49FA 16BD               1752m     LEA CRLF(PC),A4
00000974                          1753mm     PRINT_STR A4,D5
00000974                          1754mm LOOP_88
00000974  0C14 0000               1755mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000978  6700 0016               1756mm     BEQ EXIT_88
0000097C                          1757mmm     PRINT_CHAR (A4)+,D5
0000097C                          1758mmm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000097C                 TRUE     1759mmm     IFEQ DEBUG
0000097C  1A39 00C00003           1760mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000982  0805 0002               1761mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000986  67F4                    1762mmm         BEQ WAIT_FOR_READY_89                       ; NO SPACE, CHECK AGAIN
00000988  13DC 00C00007           1763mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000098E                          1764mmm     ENDC
0000098E                          1765mmm 
0000098E                 FALSE    1766mmm     IFNE DEBUG
0000098E                          1767mmm     ENDC
0000098E                          1768mmm 
0000098E                          1769mmm     ENDM
0000098E  60E4                    1770mm     BRA LOOP_88
00000990                          1771mm EXIT_88
00000990                          1772mm     ENDM
00000990                          1773m     ENDM
00000990                          1774  
00000990  6000 FC76               1775                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000994                          1776              ENDI
00000994                          1777s _0000000A
00000994                          1778          ENDI
00000994                          1779s _00000008
00000994                          1780      ENDI
00000994                          1781s _00000004
00000994                          1782  
00000994                          1783m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000994  1E3C 0002               1784m     MOVE.B #2,D7
00000998                          1785m     WHILE.B D7 <GT> 0 DO
00000998                          1786ms _10000012
00000998  BE38 0000               1787ms     CMP.B   0,D7
0000099C  6F00 003C               1788ms     BLE _10000013
000009A0  E98C                    1789m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009A2                          1790mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009A2                          1791mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A2                          1792mm 
000009A2  1A39 00C00003           1793mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000009A8  0805 0000               1794mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009AC  67F4                    1795mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
000009AE                          1796mm     
000009AE  1A39 00C00007           1797mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000009B4                          1798mm     
000009B4  BA3C 001B               1799mm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009B8  6700 F74A               1800mm     BEQ START
000009BC                          1801mm 
000009BC  13C5 00E00001           1802mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009C2                          1803mm 
000009C2                          1804mm     ENDM
000009C2                          1805m         ;PRINT_CHAR D5,D6
000009C2                          1806mm         HEX2BIN D5,D5,A4
000009C2  49FA 1640               1807mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009C6  0405 0030               1808mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009CA  CABC 000000FF           1809mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009D0  1A34 5000               1810mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009D4                          1811mm     ENDM
000009D4  8805                    1812m         OR.B D5,D4
000009D6  5307                    1813m         SUB.B #1,D7
000009D8                          1814m     ENDW
000009D8  60BE                    1815ms     BRA _10000012
000009DA                          1816ms _10000013
000009DA                          1817m 
000009DA  7A00                    1818m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009DC  1A04                    1819m     MOVE.B D4,D5
000009DE  D484                    1820m     ADD.L D4,D2
000009E0                          1821m 
000009E0                          1822m     ENDM
000009E0                          1823  
000009E0                          1824      IF.B D2 <NE> #$FF THEN.L
000009E0  B43C 00FF               1825s     CMP.B   #$FF,D2
000009E4  6700 00B0               1826s     BEQ.L   _0000000B
000009E8                          1827m         PRINT_CRLF D5,A4
000009E8  49FA 1645               1828m     LEA CRLF(PC),A4
000009EC                          1829mm     PRINT_STR A4,D5
000009EC                          1830mm LOOP_94
000009EC  0C14 0000               1831mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009F0  6700 0016               1832mm     BEQ EXIT_94
000009F4                          1833mmm     PRINT_CHAR (A4)+,D5
000009F4                          1834mmm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F4                 TRUE     1835mmm     IFEQ DEBUG
000009F4  1A39 00C00003           1836mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009FA  0805 0002               1837mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009FE  67F4                    1838mmm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000A00  13DC 00C00007           1839mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A06                          1840mmm     ENDC
00000A06                          1841mmm 
00000A06                 FALSE    1842mmm     IFNE DEBUG
00000A06                          1843mmm     ENDC
00000A06                          1844mmm 
00000A06                          1845mmm     ENDM
00000A06  60E4                    1846mm     BRA LOOP_94
00000A08                          1847mm EXIT_94
00000A08                          1848mm     ENDM
00000A08                          1849m     ENDM
00000A08  49FA 15C8               1850          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000A0C                          1851m         PRINT_STR A4,D5
00000A0C                          1852m LOOP_96
00000A0C  0C14 0000               1853m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A10  6700 0016               1854m     BEQ EXIT_96
00000A14                          1855mm     PRINT_CHAR (A4)+,D5
00000A14                          1856mm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A14                 TRUE     1857mm     IFEQ DEBUG
00000A14  1A39 00C00003           1858mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A1A  0805 0002               1859mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A1E  67F4                    1860mm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
00000A20  13DC 00C00007           1861mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A26                          1862mm     ENDC
00000A26                          1863mm 
00000A26                 FALSE    1864mm     IFNE DEBUG
00000A26                          1865mm     ENDC
00000A26                          1866mm 
00000A26                          1867mm     ENDM
00000A26  60E4                    1868m     BRA LOOP_96
00000A28                          1869m EXIT_96
00000A28                          1870m     ENDM
00000A28                          1871m         PRINT_REG D0,D5,D3,D6,A4
00000A28  49FA 160B               1872m     LEA OX(PC),A4
00000A2C                          1873mm     PRINT_STR A4,D5
00000A2C                          1874mm LOOP_99
00000A2C  0C14 0000               1875mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A30  6700 0016               1876mm     BEQ EXIT_99
00000A34                          1877mmm     PRINT_CHAR (A4)+,D5
00000A34                          1878mmm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A34                 TRUE     1879mmm     IFEQ DEBUG
00000A34  1A39 00C00003           1880mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A3A  0805 0002               1881mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A3E  67F4                    1882mmm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000A40  13DC 00C00007           1883mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A46                          1884mmm     ENDC
00000A46                          1885mmm 
00000A46                 FALSE    1886mmm     IFNE DEBUG
00000A46                          1887mmm     ENDC
00000A46                          1888mmm 
00000A46                          1889mmm     ENDM
00000A46  60E4                    1890mm     BRA LOOP_99
00000A48                          1891mm EXIT_99
00000A48                          1892mm     ENDM
00000A48  7C07                    1893m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A4A                          1894m LOOP_98
00000A4A                          1895mm     BIN2HEX D0,D3,A4
00000A4A  49FA 15A8               1896mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A4E  E998                    1897mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A50  1600                    1898mm     MOVE.B D0,D3
00000A52  0283 0000000F           1899mm     ANDI.L #$F,D3
00000A58  1634 3000               1900mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000A5C                          1901mm     ENDM
00000A5C                          1902mm     PRINT_CHAR D3,D5
00000A5C                          1903mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5C                 TRUE     1904mm     IFEQ DEBUG
00000A5C  1A39 00C00003           1905mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A62  0805 0002               1906mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A66  67F4                    1907mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000A68  13C3 00C00007           1908mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A6E                          1909mm     ENDC
00000A6E                          1910mm 
00000A6E                 FALSE    1911mm     IFNE DEBUG
00000A6E                          1912mm     ENDC
00000A6E                          1913mm 
00000A6E                          1914mm     ENDM
00000A6E  57CE FFDA               1915m     DBEQ D6,LOOP_98
00000A72                          1916m     ENDM
00000A72                          1917m         PRINT_CRLF D5,A4
00000A72  49FA 15BB               1918m     LEA CRLF(PC),A4
00000A76                          1919mm     PRINT_STR A4,D5
00000A76                          1920mm LOOP_104
00000A76  0C14 0000               1921mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A7A  6700 0016               1922mm     BEQ EXIT_104
00000A7E                          1923mmm     PRINT_CHAR (A4)+,D5
00000A7E                          1924mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A7E                 TRUE     1925mmm     IFEQ DEBUG
00000A7E  1A39 00C00003           1926mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A84  0805 0002               1927mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A88  67F4                    1928mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A8A  13DC 00C00007           1929mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A90                          1930mmm     ENDC
00000A90                          1931mmm 
00000A90                 FALSE    1932mmm     IFNE DEBUG
00000A90                          1933mmm     ENDC
00000A90                          1934mmm 
00000A90                          1935mmm     ENDM
00000A90  60E4                    1936mm     BRA LOOP_104
00000A92                          1937mm EXIT_104
00000A92                          1938mm     ENDM
00000A92                          1939m     ENDM
00000A92                          1940          
00000A92  6000 F8B0               1941          BRA MAIN_LOOP
00000A96                          1942      ENDI
00000A96                          1943s _0000000B
00000A96                          1944  
00000A96                          1945      IF D1 <EQ> #0 THEN
00000A96  B27C 0000               1946s     CMP.W   #0,D1
00000A9A  6600 0006               1947s     BNE _0000000C
00000A9E  6000 FB68               1948        BRA WAIT_FOR_SRECORD
00000AA2                          1949      ENDI
00000AA2                          1950s _0000000C
00000AA2                          1951  DOWNLOAD_DONE
00000AA2                          1952m     PRINT_CRLF D5,A4
00000AA2  49FA 158B               1953m     LEA CRLF(PC),A4
00000AA6                          1954mm     PRINT_STR A4,D5
00000AA6                          1955mm LOOP_107
00000AA6  0C14 0000               1956mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AAA  6700 0016               1957mm     BEQ EXIT_107
00000AAE                          1958mmm     PRINT_CHAR (A4)+,D5
00000AAE                          1959mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAE                 TRUE     1960mmm     IFEQ DEBUG
00000AAE  1A39 00C00003           1961mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB4  0805 0002               1962mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AB8  67F4                    1963mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000ABA  13DC 00C00007           1964mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AC0                          1965mmm     ENDC
00000AC0                          1966mmm 
00000AC0                 FALSE    1967mmm     IFNE DEBUG
00000AC0                          1968mmm     ENDC
00000AC0                          1969mmm 
00000AC0                          1970mmm     ENDM
00000AC0  60E4                    1971mm     BRA LOOP_107
00000AC2                          1972mm EXIT_107
00000AC2                          1973mm     ENDM
00000AC2                          1974m     ENDM
00000AC2                          1975m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000AC2  43FA 1571               1976m     LEA OX(PC),A1
00000AC6                          1977mm     PRINT_STR A1,D5
00000AC6                          1978mm LOOP_110
00000AC6  0C11 0000               1979mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000ACA  6700 0016               1980mm     BEQ EXIT_110
00000ACE                          1981mmm     PRINT_CHAR (A1)+,D5
00000ACE                          1982mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACE                 TRUE     1983mmm     IFEQ DEBUG
00000ACE  1A39 00C00003           1984mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD4  0805 0002               1985mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AD8  67F4                    1986mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000ADA  13D9 00C00007           1987mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AE0                          1988mmm     ENDC
00000AE0                          1989mmm 
00000AE0                 FALSE    1990mmm     IFNE DEBUG
00000AE0                          1991mmm     ENDC
00000AE0                          1992mmm 
00000AE0                          1993mmm     ENDM
00000AE0  60E4                    1994mm     BRA LOOP_110
00000AE2                          1995mm EXIT_110
00000AE2                          1996mm     ENDM
00000AE2  7407                    1997m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AE4                          1998m LOOP_109
00000AE4                          1999mm     BIN2HEX D0,D6,A1
00000AE4  43FA 150E               2000mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AE8  E998                    2001mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AEA  1C00                    2002mm     MOVE.B D0,D6
00000AEC  0286 0000000F           2003mm     ANDI.L #$F,D6
00000AF2  1C31 6000               2004mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000AF6                          2005mm     ENDM
00000AF6                          2006mm     PRINT_CHAR D6,D5
00000AF6                          2007mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF6                 TRUE     2008mm     IFEQ DEBUG
00000AF6  1A39 00C00003           2009mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AFC  0805 0002               2010mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B00  67F4                    2011mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000B02  13C6 00C00007           2012mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B08                          2013mm     ENDC
00000B08                          2014mm 
00000B08                 FALSE    2015mm     IFNE DEBUG
00000B08                          2016mm     ENDC
00000B08                          2017mm 
00000B08                          2018mm     ENDM
00000B08  57CA FFDA               2019m     DBEQ D2,LOOP_109
00000B0C                          2020m     ENDM
00000B0C  43FA 148B               2021      LEA READ(PC),A1
00000B10                          2022m     PRINT_STR A1,D5
00000B10                          2023m LOOP_114
00000B10  0C11 0000               2024m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B14  6700 0016               2025m     BEQ EXIT_114
00000B18                          2026mm     PRINT_CHAR (A1)+,D5
00000B18                          2027mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B18                 TRUE     2028mm     IFEQ DEBUG
00000B18  1A39 00C00003           2029mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B1E  0805 0002               2030mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B22  67F4                    2031mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B24  13D9 00C00007           2032mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B2A                          2033mm     ENDC
00000B2A                          2034mm 
00000B2A                 FALSE    2035mm     IFNE DEBUG
00000B2A                          2036mm     ENDC
00000B2A                          2037mm 
00000B2A                          2038mm     ENDM
00000B2A  60E4                    2039m     BRA LOOP_114
00000B2C                          2040m EXIT_114
00000B2C                          2041m     ENDM
00000B2C  2E08                    2042      MOVE.L A0,D7                                    ; set address accumulator to start address
00000B2E                          2043m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000B2E  43FA 1505               2044m     LEA OX(PC),A1
00000B32                          2045mm     PRINT_STR A1,D5
00000B32                          2046mm LOOP_117
00000B32  0C11 0000               2047mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B36  6700 0016               2048mm     BEQ EXIT_117
00000B3A                          2049mmm     PRINT_CHAR (A1)+,D5
00000B3A                          2050mmm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B3A                 TRUE     2051mmm     IFEQ DEBUG
00000B3A  1A39 00C00003           2052mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B40  0805 0002               2053mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B44  67F4                    2054mmm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000B46  13D9 00C00007           2055mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B4C                          2056mmm     ENDC
00000B4C                          2057mmm 
00000B4C                 FALSE    2058mmm     IFNE DEBUG
00000B4C                          2059mmm     ENDC
00000B4C                          2060mmm 
00000B4C                          2061mmm     ENDM
00000B4C  60E4                    2062mm     BRA LOOP_117
00000B4E                          2063mm EXIT_117
00000B4E                          2064mm     ENDM
00000B4E  7407                    2065m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B50                          2066m LOOP_116
00000B50                          2067mm     BIN2HEX D7,D6,A1
00000B50  43FA 14A2               2068mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B54  E99F                    2069mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B56  1C07                    2070mm     MOVE.B D7,D6
00000B58  0286 0000000F           2071mm     ANDI.L #$F,D6
00000B5E  1C31 6000               2072mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B62                          2073mm     ENDM
00000B62                          2074mm     PRINT_CHAR D6,D5
00000B62                          2075mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B62                 TRUE     2076mm     IFEQ DEBUG
00000B62  1A39 00C00003           2077mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B68  0805 0002               2078mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B6C  67F4                    2079mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000B6E  13C6 00C00007           2080mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B74                          2081mm     ENDC
00000B74                          2082mm 
00000B74                 FALSE    2083mm     IFNE DEBUG
00000B74                          2084mm     ENDC
00000B74                          2085mm 
00000B74                          2086mm     ENDM
00000B74  57CA FFDA               2087m     DBEQ D2,LOOP_116
00000B78                          2088m     ENDM
00000B78                          2089m     PRINT_CRLF D5,A4
00000B78  49FA 14B5               2090m     LEA CRLF(PC),A4
00000B7C                          2091mm     PRINT_STR A4,D5
00000B7C                          2092mm LOOP_122
00000B7C  0C14 0000               2093mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B80  6700 0016               2094mm     BEQ EXIT_122
00000B84                          2095mmm     PRINT_CHAR (A4)+,D5
00000B84                          2096mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B84                 TRUE     2097mmm     IFEQ DEBUG
00000B84  1A39 00C00003           2098mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B8A  0805 0002               2099mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B8E  67F4                    2100mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000B90  13DC 00C00007           2101mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B96                          2102mmm     ENDC
00000B96                          2103mmm 
00000B96                 FALSE    2104mmm     IFNE DEBUG
00000B96                          2105mmm     ENDC
00000B96                          2106mmm 
00000B96                          2107mmm     ENDM
00000B96  60E4                    2108mm     BRA LOOP_122
00000B98                          2109mm EXIT_122
00000B98                          2110mm     ENDM
00000B98                          2111m     ENDM
00000B98                          2112  
00000B98  6000 F7AA               2113      BRA MAIN_LOOP
00000B9C                          2114  
00000B9C                          2115  G
00000B9C  2047                    2116      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000B9E  7E00                    2117      MOVE.L #0,D7
00000BA0                          2118  
00000BA0  4ED0                    2119      JMP (A0)
00000BA2                          2120          
00000BA2                          2121  Z
00000BA2  207C 00200000           2122      MOVE.L #RAM,A0                                  ; address of RAM
00000BA8  D1FC 00100000           2123      ADD.L #$100000,A0
00000BAE                          2124  
00000BAE                          2125      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000BAE  7000                    2126s     MOVE.L  #0,D0
00000BB0  6000 0012               2127s     BRA _20000007
00000BB4                          2128s _20000006
00000BB4  2200                    2129          MOVE.L D0,D1                                ; progress update
00000BB6  E089                    2130          LSR.L #8,D1 
00000BB8  E089                    2131          LSR.L #8,D1
00000BBA  13C1 00E00001           2132          MOVE.B D1,DISPLAY
00000BC0                          2133          
00000BC0  2108                    2134          MOVE.L A0,-(A0)
00000BC2                          2135      ENDF
00000BC2  5880                    2136s     ADD.L   #4,D0
00000BC4                          2137s _20000007
00000BC4  B0BC 000FFFFC           2138s     CMP.L   #$FFFFC,D0
00000BCA  6FE8                    2139s     BLE _20000006
00000BCC                          2140  
00000BCC  207C 00200000           2141      MOVE.L #RAM,A0                                  ; address of RAM
00000BD2  D1FC 00100000           2142      ADD.L #$100000,A0
00000BD8                          2143  
00000BD8                          2144      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000BD8  7000                    2145s     MOVE.L  #0,D0
00000BDA  6000 00A8               2146s     BRA _20000009
00000BDE                          2147s _20000008
00000BDE  2200                    2148          MOVE.L D0,D1                                ; progress update
00000BE0  E089                    2149          LSR.L #8,D1
00000BE2  E089                    2150          LSR.L #8,D1
00000BE4  13C1 00E00001           2151          MOVE.B D1,DISPLAY
00000BEA                          2152  
00000BEA  2408                    2153          MOVE.L A0,D2
00000BEC  2220                    2154          MOVE.L -(A0),D1
00000BEE                          2155  
00000BEE                          2156          IF.L D2 <NE> D1 THEN
00000BEE  B481                    2157s     CMP.L   D1,D2
00000BF0  6700 0090               2158s     BEQ _0000000D
00000BF4  43FA 13ED               2159              LEA RAM_ERROR(PC),A1
00000BF8                          2160m             PRINT_STR A1,D1
00000BF8                          2161m LOOP_124
00000BF8  0C11 0000               2162m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BFC  6700 0016               2163m     BEQ EXIT_124
00000C00                          2164mm     PRINT_CHAR (A1)+,D1
00000C00                          2165mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C00                 TRUE     2166mm     IFEQ DEBUG
00000C00  1239 00C00003           2167mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000C06  0801 0002               2168mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000C0A  67F4                    2169mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000C0C  13D9 00C00007           2170mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C12                          2171mm     ENDC
00000C12                          2172mm 
00000C12                 FALSE    2173mm     IFNE DEBUG
00000C12                          2174mm     ENDC
00000C12                          2175mm 
00000C12                          2176mm     ENDM
00000C12  60E4                    2177m     BRA LOOP_124
00000C14                          2178m EXIT_124
00000C14                          2179m     ENDM
00000C14  2208                    2180              MOVE.L A0,D1
00000C16  5981                    2181              SUB.L #4,D1
00000C18                          2182m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C18  43FA 141B               2183m     LEA OX(PC),A1
00000C1C                          2184mm     PRINT_STR A1,D3
00000C1C                          2185mm LOOP_127
00000C1C  0C11 0000               2186mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C20  6700 0016               2187mm     BEQ EXIT_127
00000C24                          2188mmm     PRINT_CHAR (A1)+,D3
00000C24                          2189mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C24                 TRUE     2190mmm     IFEQ DEBUG
00000C24  1639 00C00003           2191mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C2A  0803 0002               2192mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C2E  67F4                    2193mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000C30  13D9 00C00007           2194mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C36                          2195mmm     ENDC
00000C36                          2196mmm 
00000C36                 FALSE    2197mmm     IFNE DEBUG
00000C36                          2198mmm     ENDC
00000C36                          2199mmm 
00000C36                          2200mmm     ENDM
00000C36  60E4                    2201mm     BRA LOOP_127
00000C38                          2202mm EXIT_127
00000C38                          2203mm     ENDM
00000C38  7C07                    2204m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C3A                          2205m LOOP_126
00000C3A                          2206mm     BIN2HEX D1,D2,A1
00000C3A  43FA 13B8               2207mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C3E  E999                    2208mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C40  1401                    2209mm     MOVE.B D1,D2
00000C42  0282 0000000F           2210mm     ANDI.L #$F,D2
00000C48  1431 2000               2211mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000C4C                          2212mm     ENDM
00000C4C                          2213mm     PRINT_CHAR D2,D3
00000C4C                          2214mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4C                 TRUE     2215mm     IFEQ DEBUG
00000C4C  1639 00C00003           2216mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C52  0803 0002               2217mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C56  67F4                    2218mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000C58  13C2 00C00007           2219mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C5E                          2220mm     ENDC
00000C5E                          2221mm 
00000C5E                 FALSE    2222mm     IFNE DEBUG
00000C5E                          2223mm     ENDC
00000C5E                          2224mm 
00000C5E                          2225mm     ENDM
00000C5E  57CE FFDA               2226m     DBEQ D6,LOOP_126
00000C62                          2227m     ENDM
00000C62                          2228m             PRINT_CRLF D3,A1
00000C62  43FA 13CB               2229m     LEA CRLF(PC),A1
00000C66                          2230mm     PRINT_STR A1,D3
00000C66                          2231mm LOOP_132
00000C66  0C11 0000               2232mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C6A  6700 0016               2233mm     BEQ EXIT_132
00000C6E                          2234mmm     PRINT_CHAR (A1)+,D3
00000C6E                          2235mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C6E                 TRUE     2236mmm     IFEQ DEBUG
00000C6E  1639 00C00003           2237mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C74  0803 0002               2238mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C78  67F4                    2239mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000C7A  13D9 00C00007           2240mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C80                          2241mmm     ENDC
00000C80                          2242mmm 
00000C80                 FALSE    2243mmm     IFNE DEBUG
00000C80                          2244mmm     ENDC
00000C80                          2245mmm 
00000C80                          2246mmm     ENDM
00000C80  60E4                    2247mm     BRA LOOP_132
00000C82                          2248mm EXIT_132
00000C82                          2249mm     ENDM
00000C82                          2250m     ENDM
00000C82                          2251          ENDI 
00000C82                          2252s _0000000D
00000C82                          2253      ENDF
00000C82  5880                    2254s     ADD.L   #4,D0
00000C84                          2255s _20000009
00000C84  B0BC 000FFFFC           2256s     CMP.L   #$FFFFC,D0
00000C8A  6F00 FF52               2257s     BLE _20000008
00000C8E                          2258  
00000C8E  6000 F6B4               2259      BRA MAIN_LOOP
00000C92                          2260  
00000C92                          2261  L
00000C92  7000                    2262      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C94  7200                    2263      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C96                          2264  
00000C96                          2265      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C96  343C 0000               2266s     MOVE.W  #0,D2
00000C9A  6000 0046               2267s     BRA _2000000B
00000C9E                          2268s _2000000A
00000C9E  E989                    2269          LSL.L #4,D1                                 ; make what we have so far more significant
00000CA0                          2270m         WAIT_CHAR D3,D4                             ; next character -> D2
00000CA0                          2271m WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA0                 TRUE     2272m     IFEQ DEBUG
00000CA0  1839 00C00003           2273m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CA6  0804 0000               2274m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000CAA  67F4                    2275m         BEQ WAIT_FOR_READY_134                      ; NOTHING, CHECK AGAIN
00000CAC                          2276m     ENDC
00000CAC                          2277m 
00000CAC                          2278mm     READ_CHAR D3
00000CAC                 TRUE     2279mm     IFEQ DEBUG
00000CAC  1639 00C00007           2280mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000CB2                          2281mm     ENDC
00000CB2                 FALSE    2282mm     IFNE DEBUG
00000CB2                          2283mm     ENDC
00000CB2                          2284mm 
00000CB2  B63C 001B               2285mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000CB6  6700 F44C               2286mm     BEQ START
00000CBA                          2287mm     ENDM
00000CBA                          2288m 
00000CBA                 TRUE     2289m     IFEQ DEBUG
00000CBA                          2290mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000CBA                          2291mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CBA                 TRUE     2292mm     IFEQ DEBUG
00000CBA  1839 00C00003           2293mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CC0  0804 0002               2294mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000CC4  67F4                    2295mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CC6  13C3 00C00007           2296mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CCC                          2297mm     ENDC
00000CCC                          2298mm 
00000CCC                 FALSE    2299mm     IFNE DEBUG
00000CCC                          2300mm     ENDC
00000CCC                          2301mm 
00000CCC                          2302mm     ENDM
00000CCC                          2303m     ENDC
00000CCC                          2304m     ENDM
00000CCC                          2305m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000CCC  41FA 1336               2306m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000CD0  0403 0030               2307m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CD4  C6BC 000000FF           2308m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000CDA  1630 3000               2309m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CDE                          2310m     ENDM
00000CDE  8203                    2311          OR.B D3,D1
00000CE0                          2312      ENDF
00000CE0  5242                    2313s     ADD.W   #1,D2
00000CE2                          2314s _2000000B
00000CE2  B47C 0007               2315s     CMP.W   #7,D2
00000CE6  6FB6                    2316s     BLE _2000000A
00000CE8                          2317  
00000CE8  3001                    2318      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000CEA  0480 00000104           2319      SUB.L #START,D0                                 ; remove the vector table from the length
00000CF0  E089                    2320      LSR.L #8,D1                                     ; extract the MSword for the address
00000CF2  E089                    2321      LSR.L #8,D1
00000CF4                          2322  
00000CF4                          2323m     PRINT_CRLF D2,A1
00000CF4  43FA 1339               2324m     LEA CRLF(PC),A1
00000CF8                          2325mm     PRINT_STR A1,D2
00000CF8                          2326mm LOOP_139
00000CF8  0C11 0000               2327mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CFC  6700 0016               2328mm     BEQ EXIT_139
00000D00                          2329mmm     PRINT_CHAR (A1)+,D2
00000D00                          2330mmm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2331mmm     IFEQ DEBUG
00000D00  1439 00C00003           2332mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D06  0802 0002               2333mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2334mmm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000D0C  13D9 00C00007           2335mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D12                          2336mmm     ENDC
00000D12                          2337mmm 
00000D12                 FALSE    2338mmm     IFNE DEBUG
00000D12                          2339mmm     ENDC
00000D12                          2340mmm 
00000D12                          2341mmm     ENDM
00000D12  60E4                    2342mm     BRA LOOP_139
00000D14                          2343mm EXIT_139
00000D14                          2344mm     ENDM
00000D14                          2345m     ENDM
00000D14                          2346  
00000D14  2041                    2347      MOVE.L D1,A0                                    ; target address
00000D16  2641                    2348      MOVE.L D1,A3                                    ; keep a copy for later
00000D18                          2349  
00000D18  2247                    2350      MOVE.L D7,A1                                    ; address accumulator -> address register
00000D1A  D3FC 00000104           2351      ADD.L #START,A1                                 ; skip the vectors
00000D20  2847                    2352      MOVE.L D7,A4                                    ; keep a clean copy for later
00000D22  7E00                    2353      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000D24                          2354  
00000D24                          2355m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000D24  31FC AAAA 2AAA          2356m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000D2A  4E71                    2357m     NOP
00000D2C  31FC 5555 1554          2358m     MOVE.W #$5555,$1554
00000D32  4E71                    2359m     NOP
00000D34  31FC 8080 2AAA          2360m     MOVE.W #$8080,$2AAA
00000D3A  4E71                    2361m     NOP
00000D3C  31FC AAAA 2AAA          2362m     MOVE.W #$AAAA,$2AAA
00000D42  4E71                    2363m     NOP
00000D44  31FC 5555 1554          2364m     MOVE.W #$5555,$1554
00000D4A  4E71                    2365m     NOP
00000D4C  31FC 2020 2AAA          2366m     MOVE.W #$2020,$2AAA
00000D52                          2367m     ENDM
00000D52                          2368                      
00000D52                          2369      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000D52  3E3C 0000               2370s     MOVE.W  #$0,D7
00000D56  6000 0006               2371s     BRA _2000000D
00000D5A                          2372s _2000000C
00000D5A  4E71                    2373          NOP
00000D5C                          2374      ENDF
00000D5C  5247                    2375s     ADD.W   #1,D7
00000D5E                          2376s _2000000D
00000D5E  BE7C FFFF               2377s     CMP.W   #$FFFFFFFF,D7
00000D62  6FF6                    2378s     BLE _2000000C
00000D64                          2379                  
00000D64  45FA 12B5               2380      LEA LOADING(PC),A2
00000D68                          2381m     PRINT_STR A2,D2
00000D68                          2382m LOOP_142
00000D68  0C12 0000               2383m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D6C  6700 0016               2384m     BEQ EXIT_142
00000D70                          2385mm     PRINT_CHAR (A2)+,D2
00000D70                          2386mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D70                 TRUE     2387mm     IFEQ DEBUG
00000D70  1439 00C00003           2388mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D76  0802 0002               2389mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D7A  67F4                    2390mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000D7C  13DA 00C00007           2391mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D82                          2392mm     ENDC
00000D82                          2393mm 
00000D82                 FALSE    2394mm     IFNE DEBUG
00000D82                          2395mm     ENDC
00000D82                          2396mm 
00000D82                          2397mm     ENDM
00000D82  60E4                    2398m     BRA LOOP_142
00000D84                          2399m EXIT_142
00000D84                          2400m     ENDM
00000D84  45FA 1295               2401      LEA LOADING(PC),A2
00000D88                          2402m     PRINT_STR A2,D2
00000D88                          2403m LOOP_144
00000D88  0C12 0000               2404m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D8C  6700 0016               2405m     BEQ EXIT_144
00000D90                          2406mm     PRINT_CHAR (A2)+,D2
00000D90                          2407mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D90                 TRUE     2408mm     IFEQ DEBUG
00000D90  1439 00C00003           2409mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D96  0802 0002               2410mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D9A  67F4                    2411mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000D9C  13DA 00C00007           2412mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DA2                          2413mm     ENDC
00000DA2                          2414mm 
00000DA2                 FALSE    2415mm     IFNE DEBUG
00000DA2                          2416mm     ENDC
00000DA2                          2417mm 
00000DA2                          2418mm     ENDM
00000DA2  60E4                    2419m     BRA LOOP_144
00000DA4                          2420m EXIT_144
00000DA4                          2421m     ENDM
00000DA4  45FA 1275               2422      LEA LOADING(PC),A2
00000DA8                          2423m     PRINT_STR A2,D2
00000DA8                          2424m LOOP_146
00000DA8  0C12 0000               2425m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DAC  6700 0016               2426m     BEQ EXIT_146
00000DB0                          2427mm     PRINT_CHAR (A2)+,D2
00000DB0                          2428mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB0                 TRUE     2429mm     IFEQ DEBUG
00000DB0  1439 00C00003           2430mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DB6  0802 0002               2431mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DBA  67F4                    2432mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000DBC  13DA 00C00007           2433mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DC2                          2434mm     ENDC
00000DC2                          2435mm 
00000DC2                 FALSE    2436mm     IFNE DEBUG
00000DC2                          2437mm     ENDC
00000DC2                          2438mm 
00000DC2                          2439mm     ENDM
00000DC2  60E4                    2440m     BRA LOOP_146
00000DC4                          2441m EXIT_146
00000DC4                          2442m     ENDM
00000DC4  45FA 1255               2443      LEA LOADING(PC),A2
00000DC8                          2444m     PRINT_STR A2,D2
00000DC8                          2445m LOOP_148
00000DC8  0C12 0000               2446m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DCC  6700 0016               2447m     BEQ EXIT_148
00000DD0                          2448mm     PRINT_CHAR (A2)+,D2
00000DD0                          2449mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD0                 TRUE     2450mm     IFEQ DEBUG
00000DD0  1439 00C00003           2451mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DD6  0802 0002               2452mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DDA  67F4                    2453mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000DDC  13DA 00C00007           2454mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DE2                          2455mm     ENDC
00000DE2                          2456mm 
00000DE2                 FALSE    2457mm     IFNE DEBUG
00000DE2                          2458mm     ENDC
00000DE2                          2459mm 
00000DE2                          2460mm     ENDM
00000DE2  60E4                    2461m     BRA LOOP_148
00000DE4                          2462m EXIT_148
00000DE4                          2463m     ENDM
00000DE4                          2464          
00000DE4  2409                    2465      MOVE.L A1,D2
00000DE6                          2466m     PRINT_REG D2,D3,D4,D5,A2
00000DE6  45FA 124D               2467m     LEA OX(PC),A2
00000DEA                          2468mm     PRINT_STR A2,D3
00000DEA                          2469mm LOOP_151
00000DEA  0C12 0000               2470mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DEE  6700 0016               2471mm     BEQ EXIT_151
00000DF2                          2472mmm     PRINT_CHAR (A2)+,D3
00000DF2                          2473mmm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF2                 TRUE     2474mmm     IFEQ DEBUG
00000DF2  1639 00C00003           2475mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DF8  0803 0002               2476mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DFC  67F4                    2477mmm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000DFE  13DA 00C00007           2478mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E04                          2479mmm     ENDC
00000E04                          2480mmm 
00000E04                 FALSE    2481mmm     IFNE DEBUG
00000E04                          2482mmm     ENDC
00000E04                          2483mmm 
00000E04                          2484mmm     ENDM
00000E04  60E4                    2485mm     BRA LOOP_151
00000E06                          2486mm EXIT_151
00000E06                          2487mm     ENDM
00000E06  7A07                    2488m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E08                          2489m LOOP_150
00000E08                          2490mm     BIN2HEX D2,D4,A2
00000E08  45FA 11EA               2491mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E0C  E99A                    2492mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E0E  1802                    2493mm     MOVE.B D2,D4
00000E10  0284 0000000F           2494mm     ANDI.L #$F,D4
00000E16  1832 4000               2495mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E1A                          2496mm     ENDM
00000E1A                          2497mm     PRINT_CHAR D4,D3
00000E1A                          2498mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E1A                 TRUE     2499mm     IFEQ DEBUG
00000E1A  1639 00C00003           2500mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E20  0803 0002               2501mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E24  67F4                    2502mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000E26  13C4 00C00007           2503mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E2C                          2504mm     ENDC
00000E2C                          2505mm 
00000E2C                 FALSE    2506mm     IFNE DEBUG
00000E2C                          2507mm     ENDC
00000E2C                          2508mm 
00000E2C                          2509mm     ENDM
00000E2C  57CD FFDA               2510m     DBEQ D5,LOOP_150
00000E30                          2511m     ENDM
00000E30                          2512  
00000E30  45FA 1206               2513      LEA TO(PC),A2
00000E34                          2514m     PRINT_STR A2,D3
00000E34                          2515m LOOP_155
00000E34  0C12 0000               2516m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E38  6700 0016               2517m     BEQ EXIT_155
00000E3C                          2518mm     PRINT_CHAR (A2)+,D3
00000E3C                          2519mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3C                 TRUE     2520mm     IFEQ DEBUG
00000E3C  1639 00C00003           2521mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E42  0803 0002               2522mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E46  67F4                    2523mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000E48  13DA 00C00007           2524mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E4E                          2525mm     ENDC
00000E4E                          2526mm 
00000E4E                 FALSE    2527mm     IFNE DEBUG
00000E4E                          2528mm     ENDC
00000E4E                          2529mm 
00000E4E                          2530mm     ENDM
00000E4E  60E4                    2531m     BRA LOOP_155
00000E50                          2532m EXIT_155
00000E50                          2533m     ENDM
00000E50                          2534  
00000E50  2408                    2535      MOVE.L A0,D2
00000E52                          2536m     PRINT_REG D2,D3,D4,D5,A2
00000E52  45FA 11E1               2537m     LEA OX(PC),A2
00000E56                          2538mm     PRINT_STR A2,D3
00000E56                          2539mm LOOP_158
00000E56  0C12 0000               2540mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E5A  6700 0016               2541mm     BEQ EXIT_158
00000E5E                          2542mmm     PRINT_CHAR (A2)+,D3
00000E5E                          2543mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E5E                 TRUE     2544mmm     IFEQ DEBUG
00000E5E  1639 00C00003           2545mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E64  0803 0002               2546mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E68  67F4                    2547mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000E6A  13DA 00C00007           2548mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E70                          2549mmm     ENDC
00000E70                          2550mmm 
00000E70                 FALSE    2551mmm     IFNE DEBUG
00000E70                          2552mmm     ENDC
00000E70                          2553mmm 
00000E70                          2554mmm     ENDM
00000E70  60E4                    2555mm     BRA LOOP_158
00000E72                          2556mm EXIT_158
00000E72                          2557mm     ENDM
00000E72  7A07                    2558m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E74                          2559m LOOP_157
00000E74                          2560mm     BIN2HEX D2,D4,A2
00000E74  45FA 117E               2561mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E78  E99A                    2562mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E7A  1802                    2563mm     MOVE.B D2,D4
00000E7C  0284 0000000F           2564mm     ANDI.L #$F,D4
00000E82  1832 4000               2565mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E86                          2566mm     ENDM
00000E86                          2567mm     PRINT_CHAR D4,D3
00000E86                          2568mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E86                 TRUE     2569mm     IFEQ DEBUG
00000E86  1639 00C00003           2570mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E8C  0803 0002               2571mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E90  67F4                    2572mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E92  13C4 00C00007           2573mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E98                          2574mm     ENDC
00000E98                          2575mm 
00000E98                 FALSE    2576mm     IFNE DEBUG
00000E98                          2577mm     ENDC
00000E98                          2578mm 
00000E98                          2579mm     ENDM
00000E98  57CD FFDA               2580m     DBEQ D5,LOOP_157
00000E9C                          2581m     ENDM
00000E9C                          2582  
00000E9C  45FA 119F               2583      LEA FOR(PC),A2
00000EA0                          2584m     PRINT_STR A2,D3
00000EA0                          2585m LOOP_162
00000EA0  0C12 0000               2586m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EA4  6700 0016               2587m     BEQ EXIT_162
00000EA8                          2588mm     PRINT_CHAR (A2)+,D3
00000EA8                          2589mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA8                 TRUE     2590mm     IFEQ DEBUG
00000EA8  1639 00C00003           2591mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EAE  0803 0002               2592mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EB2  67F4                    2593mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000EB4  13DA 00C00007           2594mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EBA                          2595mm     ENDC
00000EBA                          2596mm 
00000EBA                 FALSE    2597mm     IFNE DEBUG
00000EBA                          2598mm     ENDC
00000EBA                          2599mm 
00000EBA                          2600mm     ENDM
00000EBA  60E4                    2601m     BRA LOOP_162
00000EBC                          2602m EXIT_162
00000EBC                          2603m     ENDM
00000EBC                          2604m     PRINT_REG D0,D3,D4,D5,A2
00000EBC  45FA 1177               2605m     LEA OX(PC),A2
00000EC0                          2606mm     PRINT_STR A2,D3
00000EC0                          2607mm LOOP_165
00000EC0  0C12 0000               2608mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EC4  6700 0016               2609mm     BEQ EXIT_165
00000EC8                          2610mmm     PRINT_CHAR (A2)+,D3
00000EC8                          2611mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2612mmm     IFEQ DEBUG
00000EC8  1639 00C00003           2613mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ECE  0803 0002               2614mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ED2  67F4                    2615mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000ED4  13DA 00C00007           2616mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EDA                          2617mmm     ENDC
00000EDA                          2618mmm 
00000EDA                 FALSE    2619mmm     IFNE DEBUG
00000EDA                          2620mmm     ENDC
00000EDA                          2621mmm 
00000EDA                          2622mmm     ENDM
00000EDA  60E4                    2623mm     BRA LOOP_165
00000EDC                          2624mm EXIT_165
00000EDC                          2625mm     ENDM
00000EDC  7A07                    2626m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EDE                          2627m LOOP_164
00000EDE                          2628mm     BIN2HEX D0,D4,A2
00000EDE  45FA 1114               2629mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EE2  E998                    2630mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EE4  1800                    2631mm     MOVE.B D0,D4
00000EE6  0284 0000000F           2632mm     ANDI.L #$F,D4
00000EEC  1832 4000               2633mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EF0                          2634mm     ENDM
00000EF0                          2635mm     PRINT_CHAR D4,D3
00000EF0                          2636mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EF0                 TRUE     2637mm     IFEQ DEBUG
00000EF0  1639 00C00003           2638mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EF6  0803 0002               2639mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EFA  67F4                    2640mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000EFC  13C4 00C00007           2641mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F02                          2642mm     ENDC
00000F02                          2643mm 
00000F02                 FALSE    2644mm     IFNE DEBUG
00000F02                          2645mm     ENDC
00000F02                          2646mm 
00000F02                          2647mm     ENDM
00000F02  57CD FFDA               2648m     DBEQ D5,LOOP_164
00000F06                          2649m     ENDM
00000F06                          2650  
00000F06                          2651m     PRINT_CRLF D3,A2
00000F06  45FA 1127               2652m     LEA CRLF(PC),A2
00000F0A                          2653mm     PRINT_STR A2,D3
00000F0A                          2654mm LOOP_170
00000F0A  0C12 0000               2655mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F0E  6700 0016               2656mm     BEQ EXIT_170
00000F12                          2657mmm     PRINT_CHAR (A2)+,D3
00000F12                          2658mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F12                 TRUE     2659mmm     IFEQ DEBUG
00000F12  1639 00C00003           2660mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F18  0803 0002               2661mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F1C  67F4                    2662mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F1E  13DA 00C00007           2663mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F24                          2664mmm     ENDC
00000F24                          2665mmm 
00000F24                 FALSE    2666mmm     IFNE DEBUG
00000F24                          2667mmm     ENDC
00000F24                          2668mmm 
00000F24                          2669mmm     ENDM
00000F24  60E4                    2670mm     BRA LOOP_170
00000F26                          2671mm EXIT_170
00000F26                          2672mm     ENDM
00000F26                          2673m     ENDM
00000F26                          2674  
00000F26                          2675      WHILE D0 <GT> #0 DO
00000F26                          2676s _10000014
00000F26  B07C 0000               2677s     CMP.W   #0,D0
00000F2A  6F00 0022               2678s     BLE _10000015
00000F2E  5580                    2679          SUB.L #2,D0
00000F30                          2680  
00000F30  2408                    2681          MOVE.L A0,D2
00000F32  0202 0007               2682          ANDI.B #$7,D2
00000F36  13C2 00E00001           2683          MOVE.B D2,DISPLAY
00000F3C                          2684m         PROGRAM (A1),(A0),D2
00000F3C  3091                    2685m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000F3E                          2686m 
00000F3E                          2687m WAIT_FOR_COMPLETE_172
00000F3E  3410                    2688m         MOVE.W (A0),D2
00000F40                          2689m 
00000F40                          2690m         IF.W D2 <NE> (A1) THEN
00000F40  B451                    2691ms     CMP.W   (A1),D2
00000F42  6700 0004               2692ms     BEQ _0000000E
00000F46  60F6                    2693m             BRA WAIT_FOR_COMPLETE_172
00000F48                          2694m         ENDI
00000F48                          2695ms _0000000E
00000F48                          2696m         ENDM
00000F48                          2697                  
00000F48  5488                    2698          ADD.L #2,A0
00000F4A  5489                    2699          ADD.L #2,A1
00000F4C                          2700      ENDW
00000F4C  60D8                    2701s     BRA _10000014
00000F4E                          2702s _10000015
00000F4E                          2703      
00000F4E  41F8 0000               2704      LEA STACK,A0
00000F52  D1CC                    2705      ADD.L A4,A0
00000F54  2010                    2706      MOVE.L (A0),D0
00000F56                          2707      
00000F56  207C 00000000           2708      MOVE.L #0,A0
00000F5C                          2709m     PROGRAM_VECTOR D0,A0,D2
00000F5C  5488                    2710m     ADD.L #2,A0
00000F5E                          2711mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000F5E  3080                    2712mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F60                          2713mm 
00000F60                          2714mm WAIT_FOR_COMPLETE_174
00000F60  3410                    2715mm         MOVE.W (A0),D2
00000F62                          2716mm 
00000F62                          2717mm         IF.W D2 <NE> D0 THEN
00000F62  B440                    2718mms     CMP.W   D0,D2
00000F64  6700 0004               2719mms     BEQ _0000000F
00000F68  60F6                    2720mm             BRA WAIT_FOR_COMPLETE_174
00000F6A                          2721mm         ENDI
00000F6A                          2722mms _0000000F
00000F6A                          2723mm         ENDM
00000F6A  E088                    2724m     LSR.L #8,D0
00000F6C  E088                    2725m     LSR.L #8,D0
00000F6E  5588                    2726m     SUB.L #2,A0
00000F70                          2727mm     PROGRAM D0, (A0), D2
00000F70  3080                    2728mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F72                          2729mm 
00000F72                          2730mm WAIT_FOR_COMPLETE_175
00000F72  3410                    2731mm         MOVE.W (A0),D2
00000F74                          2732mm 
00000F74                          2733mm         IF.W D2 <NE> D0 THEN
00000F74  B440                    2734mms     CMP.W   D0,D2
00000F76  6700 0004               2735mms     BEQ _00000010
00000F7A  60F6                    2736mm             BRA WAIT_FOR_COMPLETE_175
00000F7C                          2737mm         ENDI
00000F7C                          2738mms _00000010
00000F7C                          2739mm         ENDM
00000F7C                          2740m     ENDM
00000F7C                          2741      
00000F7C                          2742      FOR A0 = #RESET TO #START-4 BY #4 DO
00000F7C  307C 0004               2743s     MOVE.W  #RESET,A0
00000F80  6000 003E               2744s     BRA _2000000F
00000F84                          2745s _2000000E
00000F84                          2746  
00000F84  2248                    2747          MOVE.L A0,A1
00000F86  D3CC                    2748          ADD.L A4,A1
00000F88                          2749              
00000F88  2011                    2750          MOVE.L (A1),D0  
00000F8A  D081                    2751          ADD.L D1,D0
00000F8C  0480 00000104           2752          SUB.L #START,D0
00000F92                          2753      
00000F92  2408                    2754          MOVE.L A0,D2
00000F94  0202 0007               2755          ANDI.B #$7,D2
00000F98  13C2 00E00001           2756          MOVE.B D2,DISPLAY
00000F9E                          2757m         PROGRAM_VECTOR D0,A0,D2
00000F9E  5488                    2758m     ADD.L #2,A0
00000FA0                          2759mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000FA0  3080                    2760mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FA2                          2761mm 
00000FA2                          2762mm WAIT_FOR_COMPLETE_177
00000FA2  3410                    2763mm         MOVE.W (A0),D2
00000FA4                          2764mm 
00000FA4                          2765mm         IF.W D2 <NE> D0 THEN
00000FA4  B440                    2766mms     CMP.W   D0,D2
00000FA6  6700 0004               2767mms     BEQ _00000011
00000FAA  60F6                    2768mm             BRA WAIT_FOR_COMPLETE_177
00000FAC                          2769mm         ENDI
00000FAC                          2770mms _00000011
00000FAC                          2771mm         ENDM
00000FAC  E088                    2772m     LSR.L #8,D0
00000FAE  E088                    2773m     LSR.L #8,D0
00000FB0  5588                    2774m     SUB.L #2,A0
00000FB2                          2775mm     PROGRAM D0, (A0), D2
00000FB2  3080                    2776mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FB4                          2777mm 
00000FB4                          2778mm WAIT_FOR_COMPLETE_178
00000FB4  3410                    2779mm         MOVE.W (A0),D2
00000FB6                          2780mm 
00000FB6                          2781mm         IF.W D2 <NE> D0 THEN
00000FB6  B440                    2782mms     CMP.W   D0,D2
00000FB8  6700 0004               2783mms     BEQ _00000012
00000FBC  60F6                    2784mm             BRA WAIT_FOR_COMPLETE_178
00000FBE                          2785mm         ENDI
00000FBE                          2786mms _00000012
00000FBE                          2787mm         ENDM
00000FBE                          2788m     ENDM
00000FBE                          2789      ENDF
00000FBE  5848                    2790s     ADD.W   #4,A0
00000FC0                          2791s _2000000F
00000FC0  B0FC 0100               2792s     CMP.W   #START-4,A0
00000FC4  6FBE                    2793s     BLE _2000000E
00000FC6                          2794                                          
00000FC6                          2795m     PROTECT
00000FC6  31FC AAAA 2AAA          2796m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000FCC  31FC 5555 1554          2797m     MOVE.W #$5555,$1554
00000FD2  31FC A0A0 2AAA          2798m     MOVE.W #$A0A0,$2AAA
00000FD8                          2799m     ENDM
00000FD8                          2800  
00000FD8  6000 F36A               2801      BRA MAIN_LOOP
00000FDC                          2802      
00000FDC                          2803  P
00000FDC  7000                    2804      MOVE.L #0,D0                                    ; D0 will be the data to write
00000FDE                          2805  
00000FDE                          2806      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000FDE  323C 0000               2807s     MOVE.W  #0,D1
00000FE2  6000 0046               2808s     BRA _20000011
00000FE6                          2809s _20000010
00000FE6  E988                    2810          LSL.L #4,D0                                 ; make what we have so far more significant
00000FE8                          2811m         WAIT_CHAR D2,D3                             ; next character -> D2
00000FE8                          2812m WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FE8                 TRUE     2813m     IFEQ DEBUG
00000FE8  1639 00C00003           2814m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FEE  0803 0000               2815m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000FF2  67F4                    2816m         BEQ WAIT_FOR_READY_180                      ; NOTHING, CHECK AGAIN
00000FF4                          2817m     ENDC
00000FF4                          2818m 
00000FF4                          2819mm     READ_CHAR D2
00000FF4                 TRUE     2820mm     IFEQ DEBUG
00000FF4  1439 00C00007           2821mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000FFA                          2822mm     ENDC
00000FFA                 FALSE    2823mm     IFNE DEBUG
00000FFA                          2824mm     ENDC
00000FFA                          2825mm 
00000FFA  B43C 001B               2826mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000FFE  6700 F104               2827mm     BEQ START
00001002                          2828mm     ENDM
00001002                          2829m 
00001002                 TRUE     2830m     IFEQ DEBUG
00001002                          2831mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001002                          2832mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001002                 TRUE     2833mm     IFEQ DEBUG
00001002  1639 00C00003           2834mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001008  0803 0002               2835mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000100C  67F4                    2836mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
0000100E  13C2 00C00007           2837mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001014                          2838mm     ENDC
00001014                          2839mm 
00001014                 FALSE    2840mm     IFNE DEBUG
00001014                          2841mm     ENDC
00001014                          2842mm 
00001014                          2843mm     ENDM
00001014                          2844m     ENDC
00001014                          2845m     ENDM
00001014                          2846m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001014  41FA 0FEE               2847m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001018  0402 0030               2848m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000101C  C4BC 000000FF           2849m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001022  1430 2000               2850m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001026                          2851m     ENDM
00001026  8002                    2852          OR.B D2,D0
00001028                          2853      ENDF
00001028  5241                    2854s     ADD.W   #1,D1
0000102A                          2855s _20000011
0000102A  B27C 0003               2856s     CMP.W   #3,D1
0000102E  6FB6                    2857s     BLE _20000010
00001030                          2858  
00001030                          2859m     PRINT_CRLF D2,A1
00001030  43FA 0FFD               2860m     LEA CRLF(PC),A1
00001034                          2861mm     PRINT_STR A1,D2
00001034                          2862mm LOOP_185
00001034  0C11 0000               2863mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001038  6700 0016               2864mm     BEQ EXIT_185
0000103C                          2865mmm     PRINT_CHAR (A1)+,D2
0000103C                          2866mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000103C                 TRUE     2867mmm     IFEQ DEBUG
0000103C  1439 00C00003           2868mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001042  0802 0002               2869mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001046  67F4                    2870mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00001048  13D9 00C00007           2871mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000104E                          2872mmm     ENDC
0000104E                          2873mmm 
0000104E                 FALSE    2874mmm     IFNE DEBUG
0000104E                          2875mmm     ENDC
0000104E                          2876mmm 
0000104E                          2877mmm     ENDM
0000104E  60E4                    2878mm     BRA LOOP_185
00001050                          2879mm EXIT_185
00001050                          2880mm     ENDM
00001050                          2881m     ENDM
00001050                          2882  
00001050  2047                    2883      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001052  7E00                    2884      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001054                          2885  
00001054                          2886m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001054  31FC AAAA 2AAA          2887m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000105A  4E71                    2888m     NOP
0000105C  31FC 5555 1554          2889m     MOVE.W #$5555,$1554
00001062  4E71                    2890m     NOP
00001064  31FC 8080 2AAA          2891m     MOVE.W #$8080,$2AAA
0000106A  4E71                    2892m     NOP
0000106C  31FC AAAA 2AAA          2893m     MOVE.W #$AAAA,$2AAA
00001072  4E71                    2894m     NOP
00001074  31FC 5555 1554          2895m     MOVE.W #$5555,$1554
0000107A  4E71                    2896m     NOP
0000107C  31FC 2020 2AAA          2897m     MOVE.W #$2020,$2AAA
00001082                          2898m     ENDM
00001082                          2899                              
00001082                          2900      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001082  3E3C 0000               2901s     MOVE.W  #$0,D7
00001086  6000 0006               2902s     BRA _20000013
0000108A                          2903s _20000012
0000108A  4E71                    2904          NOP
0000108C                          2905      ENDF
0000108C  5247                    2906s     ADD.W   #1,D7
0000108E                          2907s _20000013
0000108E  BE7C FFFF               2908s     CMP.W   #$FFFFFFFF,D7
00001092  6FF6                    2909s     BLE _20000012
00001094                          2910               
00001094  45FA 0F85               2911      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00001098                          2912m     PRINT_STR A2,D2
00001098                          2913m LOOP_188
00001098  0C12 0000               2914m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000109C  6700 0016               2915m     BEQ EXIT_188
000010A0                          2916mm     PRINT_CHAR (A2)+,D2
000010A0                          2917mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010A0                 TRUE     2918mm     IFEQ DEBUG
000010A0  1439 00C00003           2919mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010A6  0802 0002               2920mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010AA  67F4                    2921mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
000010AC  13DA 00C00007           2922mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010B2                          2923mm     ENDC
000010B2                          2924mm 
000010B2                 FALSE    2925mm     IFNE DEBUG
000010B2                          2926mm     ENDC
000010B2                          2927mm 
000010B2                          2928mm     ENDM
000010B2  60E4                    2929m     BRA LOOP_188
000010B4                          2930m EXIT_188
000010B4                          2931m     ENDM
000010B4                          2932  
000010B4                          2933m     PRINT_REG D0,D3,D4,D5,A2
000010B4  45FA 0F7F               2934m     LEA OX(PC),A2
000010B8                          2935mm     PRINT_STR A2,D3
000010B8                          2936mm LOOP_191
000010B8  0C12 0000               2937mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010BC  6700 0016               2938mm     BEQ EXIT_191
000010C0                          2939mmm     PRINT_CHAR (A2)+,D3
000010C0                          2940mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010C0                 TRUE     2941mmm     IFEQ DEBUG
000010C0  1639 00C00003           2942mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010C6  0803 0002               2943mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010CA  67F4                    2944mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
000010CC  13DA 00C00007           2945mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010D2                          2946mmm     ENDC
000010D2                          2947mmm 
000010D2                 FALSE    2948mmm     IFNE DEBUG
000010D2                          2949mmm     ENDC
000010D2                          2950mmm 
000010D2                          2951mmm     ENDM
000010D2  60E4                    2952mm     BRA LOOP_191
000010D4                          2953mm EXIT_191
000010D4                          2954mm     ENDM
000010D4  7A07                    2955m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010D6                          2956m LOOP_190
000010D6                          2957mm     BIN2HEX D0,D4,A2
000010D6  45FA 0F1C               2958mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000010DA  E998                    2959mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010DC  1800                    2960mm     MOVE.B D0,D4
000010DE  0284 0000000F           2961mm     ANDI.L #$F,D4
000010E4  1832 4000               2962mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000010E8                          2963mm     ENDM
000010E8                          2964mm     PRINT_CHAR D4,D3
000010E8                          2965mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010E8                 TRUE     2966mm     IFEQ DEBUG
000010E8  1639 00C00003           2967mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010EE  0803 0002               2968mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010F2  67F4                    2969mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
000010F4  13C4 00C00007           2970mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010FA                          2971mm     ENDC
000010FA                          2972mm 
000010FA                 FALSE    2973mm     IFNE DEBUG
000010FA                          2974mm     ENDC
000010FA                          2975mm 
000010FA                          2976mm     ENDM
000010FA  57CD FFDA               2977m     DBEQ D5,LOOP_190
000010FE                          2978m     ENDM
000010FE                          2979  
000010FE  45FA 0F38               2980      LEA TO(PC),A2
00001102                          2981m     PRINT_STR A2,D3
00001102                          2982m LOOP_195
00001102  0C12 0000               2983m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001106  6700 0016               2984m     BEQ EXIT_195
0000110A                          2985mm     PRINT_CHAR (A2)+,D3
0000110A                          2986mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000110A                 TRUE     2987mm     IFEQ DEBUG
0000110A  1639 00C00003           2988mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001110  0803 0002               2989mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001114  67F4                    2990mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00001116  13DA 00C00007           2991mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000111C                          2992mm     ENDC
0000111C                          2993mm 
0000111C                 FALSE    2994mm     IFNE DEBUG
0000111C                          2995mm     ENDC
0000111C                          2996mm 
0000111C                          2997mm     ENDM
0000111C  60E4                    2998m     BRA LOOP_195
0000111E                          2999m EXIT_195
0000111E                          3000m     ENDM
0000111E                          3001  
0000111E  2408                    3002      MOVE.L A0,D2
00001120                          3003m     PRINT_REG D2,D3,D4,D5,A2
00001120  45FA 0F13               3004m     LEA OX(PC),A2
00001124                          3005mm     PRINT_STR A2,D3
00001124                          3006mm LOOP_198
00001124  0C12 0000               3007mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001128  6700 0016               3008mm     BEQ EXIT_198
0000112C                          3009mmm     PRINT_CHAR (A2)+,D3
0000112C                          3010mmm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000112C                 TRUE     3011mmm     IFEQ DEBUG
0000112C  1639 00C00003           3012mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001132  0803 0002               3013mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001136  67F4                    3014mmm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001138  13DA 00C00007           3015mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000113E                          3016mmm     ENDC
0000113E                          3017mmm 
0000113E                 FALSE    3018mmm     IFNE DEBUG
0000113E                          3019mmm     ENDC
0000113E                          3020mmm 
0000113E                          3021mmm     ENDM
0000113E  60E4                    3022mm     BRA LOOP_198
00001140                          3023mm EXIT_198
00001140                          3024mm     ENDM
00001140  7A07                    3025m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001142                          3026m LOOP_197
00001142                          3027mm     BIN2HEX D2,D4,A2
00001142  45FA 0EB0               3028mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001146  E99A                    3029mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001148  1802                    3030mm     MOVE.B D2,D4
0000114A  0284 0000000F           3031mm     ANDI.L #$F,D4
00001150  1832 4000               3032mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001154                          3033mm     ENDM
00001154                          3034mm     PRINT_CHAR D4,D3
00001154                          3035mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001154                 TRUE     3036mm     IFEQ DEBUG
00001154  1639 00C00003           3037mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000115A  0803 0002               3038mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000115E  67F4                    3039mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
00001160  13C4 00C00007           3040mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001166                          3041mm     ENDC
00001166                          3042mm 
00001166                 FALSE    3043mm     IFNE DEBUG
00001166                          3044mm     ENDC
00001166                          3045mm 
00001166                          3046mm     ENDM
00001166  57CD FFDA               3047m     DBEQ D5,LOOP_197
0000116A                          3048m     ENDM
0000116A                          3049  
0000116A                          3050m     PRINT_CRLF D3,A2
0000116A  45FA 0EC3               3051m     LEA CRLF(PC),A2
0000116E                          3052mm     PRINT_STR A2,D3
0000116E                          3053mm LOOP_203
0000116E  0C12 0000               3054mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001172  6700 0016               3055mm     BEQ EXIT_203
00001176                          3056mmm     PRINT_CHAR (A2)+,D3
00001176                          3057mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001176                 TRUE     3058mmm     IFEQ DEBUG
00001176  1639 00C00003           3059mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000117C  0803 0002               3060mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001180  67F4                    3061mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001182  13DA 00C00007           3062mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001188                          3063mmm     ENDC
00001188                          3064mmm 
00001188                 FALSE    3065mmm     IFNE DEBUG
00001188                          3066mmm     ENDC
00001188                          3067mmm 
00001188                          3068mmm     ENDM
00001188  60E4                    3069mm     BRA LOOP_203
0000118A                          3070mm EXIT_203
0000118A                          3071mm     ENDM
0000118A                          3072m     ENDM
0000118A                          3073  
0000118A                          3074m     PROGRAM D0,(A0),D2
0000118A  3080                    3075m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000118C                          3076m 
0000118C                          3077m WAIT_FOR_COMPLETE_205
0000118C  3410                    3078m         MOVE.W (A0),D2
0000118E                          3079m 
0000118E                          3080m         IF.W D2 <NE> D0 THEN
0000118E  B440                    3081ms     CMP.W   D0,D2
00001190  6700 0004               3082ms     BEQ _00000013
00001194  60F6                    3083m             BRA WAIT_FOR_COMPLETE_205
00001196                          3084m         ENDI
00001196                          3085ms _00000013
00001196                          3086m         ENDM
00001196                          3087  
00001196                          3088m     PROTECT
00001196  31FC AAAA 2AAA          3089m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000119C  31FC 5555 1554          3090m     MOVE.W #$5555,$1554
000011A2  31FC A0A0 2AAA          3091m     MOVE.W #$A0A0,$2AAA
000011A8                          3092m     ENDM
000011A8                          3093      
000011A8  6000 F19A               3094      BRA MAIN_LOOP
000011AC                          3095      
000011AC                          3096  X
000011AC  45FA 0E9A               3097      LEA STATUS_REGISTER(PC),A2
000011B0                          3098m     PRINT_STR A2,D3
000011B0                          3099m LOOP_207
000011B0  0C12 0000               3100m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011B4  6700 0016               3101m     BEQ EXIT_207
000011B8                          3102mm     PRINT_CHAR (A2)+,D3
000011B8                          3103mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011B8                 TRUE     3104mm     IFEQ DEBUG
000011B8  1639 00C00003           3105mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011BE  0803 0002               3106mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011C2  67F4                    3107mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
000011C4  13DA 00C00007           3108mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011CA                          3109mm     ENDC
000011CA                          3110mm 
000011CA                 FALSE    3111mm     IFNE DEBUG
000011CA                          3112mm     ENDC
000011CA                          3113mm 
000011CA                          3114mm     ENDM
000011CA  60E4                    3115m     BRA LOOP_207
000011CC                          3116m EXIT_207
000011CC                          3117m     ENDM
000011CC                          3118  
000011CC  40C0                    3119      MOVE SR,D0
000011CE                          3120m     PRINT_REG D0,D3,D4,D5,A2
000011CE  45FA 0E65               3121m     LEA OX(PC),A2
000011D2                          3122mm     PRINT_STR A2,D3
000011D2                          3123mm LOOP_210
000011D2  0C12 0000               3124mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D6  6700 0016               3125mm     BEQ EXIT_210
000011DA                          3126mmm     PRINT_CHAR (A2)+,D3
000011DA                          3127mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011DA                 TRUE     3128mmm     IFEQ DEBUG
000011DA  1639 00C00003           3129mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011E0  0803 0002               3130mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011E4  67F4                    3131mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000011E6  13DA 00C00007           3132mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011EC                          3133mmm     ENDC
000011EC                          3134mmm 
000011EC                 FALSE    3135mmm     IFNE DEBUG
000011EC                          3136mmm     ENDC
000011EC                          3137mmm 
000011EC                          3138mmm     ENDM
000011EC  60E4                    3139mm     BRA LOOP_210
000011EE                          3140mm EXIT_210
000011EE                          3141mm     ENDM
000011EE  7A07                    3142m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011F0                          3143m LOOP_209
000011F0                          3144mm     BIN2HEX D0,D4,A2
000011F0  45FA 0E02               3145mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011F4  E998                    3146mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011F6  1800                    3147mm     MOVE.B D0,D4
000011F8  0284 0000000F           3148mm     ANDI.L #$F,D4
000011FE  1832 4000               3149mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001202                          3150mm     ENDM
00001202                          3151mm     PRINT_CHAR D4,D3
00001202                          3152mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001202                 TRUE     3153mm     IFEQ DEBUG
00001202  1639 00C00003           3154mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001208  0803 0002               3155mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000120C  67F4                    3156mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
0000120E  13C4 00C00007           3157mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001214                          3158mm     ENDC
00001214                          3159mm 
00001214                 FALSE    3160mm     IFNE DEBUG
00001214                          3161mm     ENDC
00001214                          3162mm 
00001214                          3163mm     ENDM
00001214  57CD FFDA               3164m     DBEQ D5,LOOP_209
00001218                          3165m     ENDM
00001218                          3166m     PRINT_CRLF D3,A2
00001218  45FA 0E15               3167m     LEA CRLF(PC),A2
0000121C                          3168mm     PRINT_STR A2,D3
0000121C                          3169mm LOOP_215
0000121C  0C12 0000               3170mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001220  6700 0016               3171mm     BEQ EXIT_215
00001224                          3172mmm     PRINT_CHAR (A2)+,D3
00001224                          3173mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001224                 TRUE     3174mmm     IFEQ DEBUG
00001224  1639 00C00003           3175mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000122A  0803 0002               3176mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000122E  67F4                    3177mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001230  13DA 00C00007           3178mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001236                          3179mmm     ENDC
00001236                          3180mmm 
00001236                 FALSE    3181mmm     IFNE DEBUG
00001236                          3182mmm     ENDC
00001236                          3183mmm 
00001236                          3184mmm     ENDM
00001236  60E4                    3185mm     BRA LOOP_215
00001238                          3186mm EXIT_215
00001238                          3187mm     ENDM
00001238                          3188m     ENDM
00001238                          3189  
00001238  45FA 0E09               3190      LEA STACK_POINTER(PC),A2
0000123C                          3191m     PRINT_STR A2,D3
0000123C                          3192m LOOP_217
0000123C  0C12 0000               3193m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001240  6700 0016               3194m     BEQ EXIT_217
00001244                          3195mm     PRINT_CHAR (A2)+,D3
00001244                          3196mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001244                 TRUE     3197mm     IFEQ DEBUG
00001244  1639 00C00003           3198mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000124A  0803 0002               3199mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000124E  67F4                    3200mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001250  13DA 00C00007           3201mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001256                          3202mm     ENDC
00001256                          3203mm 
00001256                 FALSE    3204mm     IFNE DEBUG
00001256                          3205mm     ENDC
00001256                          3206mm 
00001256                          3207mm     ENDM
00001256  60E4                    3208m     BRA LOOP_217
00001258                          3209m EXIT_217
00001258                          3210m     ENDM
00001258                          3211  
00001258  200F                    3212      MOVE.L SP,D0
0000125A                          3213m     PRINT_REG D0,D3,D4,D5,A2
0000125A  45FA 0DD9               3214m     LEA OX(PC),A2
0000125E                          3215mm     PRINT_STR A2,D3
0000125E                          3216mm LOOP_220
0000125E  0C12 0000               3217mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001262  6700 0016               3218mm     BEQ EXIT_220
00001266                          3219mmm     PRINT_CHAR (A2)+,D3
00001266                          3220mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001266                 TRUE     3221mmm     IFEQ DEBUG
00001266  1639 00C00003           3222mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126C  0803 0002               3223mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001270  67F4                    3224mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001272  13DA 00C00007           3225mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001278                          3226mmm     ENDC
00001278                          3227mmm 
00001278                 FALSE    3228mmm     IFNE DEBUG
00001278                          3229mmm     ENDC
00001278                          3230mmm 
00001278                          3231mmm     ENDM
00001278  60E4                    3232mm     BRA LOOP_220
0000127A                          3233mm EXIT_220
0000127A                          3234mm     ENDM
0000127A  7A07                    3235m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000127C                          3236m LOOP_219
0000127C                          3237mm     BIN2HEX D0,D4,A2
0000127C  45FA 0D76               3238mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001280  E998                    3239mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001282  1800                    3240mm     MOVE.B D0,D4
00001284  0284 0000000F           3241mm     ANDI.L #$F,D4
0000128A  1832 4000               3242mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000128E                          3243mm     ENDM
0000128E                          3244mm     PRINT_CHAR D4,D3
0000128E                          3245mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000128E                 TRUE     3246mm     IFEQ DEBUG
0000128E  1639 00C00003           3247mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001294  0803 0002               3248mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001298  67F4                    3249mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
0000129A  13C4 00C00007           3250mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012A0                          3251mm     ENDC
000012A0                          3252mm 
000012A0                 FALSE    3253mm     IFNE DEBUG
000012A0                          3254mm     ENDC
000012A0                          3255mm 
000012A0                          3256mm     ENDM
000012A0  57CD FFDA               3257m     DBEQ D5,LOOP_219
000012A4                          3258m     ENDM
000012A4                          3259m     PRINT_CRLF D3,A2
000012A4  45FA 0D89               3260m     LEA CRLF(PC),A2
000012A8                          3261mm     PRINT_STR A2,D3
000012A8                          3262mm LOOP_225
000012A8  0C12 0000               3263mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012AC  6700 0016               3264mm     BEQ EXIT_225
000012B0                          3265mmm     PRINT_CHAR (A2)+,D3
000012B0                          3266mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B0                 TRUE     3267mmm     IFEQ DEBUG
000012B0  1639 00C00003           3268mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B6  0803 0002               3269mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012BA  67F4                    3270mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012BC  13DA 00C00007           3271mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012C2                          3272mmm     ENDC
000012C2                          3273mmm 
000012C2                 FALSE    3274mmm     IFNE DEBUG
000012C2                          3275mmm     ENDC
000012C2                          3276mmm 
000012C2                          3277mmm     ENDM
000012C2  60E4                    3278mm     BRA LOOP_225
000012C4                          3279mm EXIT_225
000012C4                          3280mm     ENDM
000012C4                          3281m     ENDM
000012C4                          3282  
000012C4  6000 F07E               3283      BRA MAIN_LOOP
000012C8                          3284          
000012C8                          3285  EI
000012C8  13FC 0008 00C0000B      3286      MOVE.B #8,DUART_IMR
000012D0  027C F8FF               3287      AND.W #$F8FF,SR
000012D4  6000 F06E               3288      BRA MAIN_LOOP
000012D8                          3289      
000012D8                          3290  DI
000012D8  13FC 0000 00C0000B      3291      MOVE.B #0,DUART_IMR
000012E0  007C 0700               3292      OR.W #$0700,SR
000012E4  6000 F05E               3293      BRA MAIN_LOOP
000012E8                          3294          
000012E8                          3295  HASH
000012E8                          3296m     PROTECT
000012E8  31FC AAAA 2AAA          3297m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000012EE  31FC 5555 1554          3298m     MOVE.W #$5555,$1554
000012F4  31FC A0A0 2AAA          3299m     MOVE.W #$A0A0,$2AAA
000012FA                          3300m     ENDM
000012FA  6000 F048               3301      BRA MAIN_LOOP
000012FE                          3302  IB
000012FE  13FC 0038 00A00019      3303      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001306                          3304      
00001306                          3305m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
00001306  13FC 00FF 00A00007      3306m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000130E  103C 0030               3307m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001312  0000 0006               3308m     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001316  13C0 00A00019           3309m     MOVE.B D0, MC68230_PORT_C_DATA
0000131C  0200 00EF               3310m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001320  13FC 00E0 00A00013      3311m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
00001328  13C0 00A00019           3312m     MOVE.B D0, MC68230_PORT_C_DATA
0000132E  0000 0010               3313m     ORI.B #MC68230_PORT_C_WRITE, D0
00001332  13C0 00A00019           3314m     MOVE.B D0, MC68230_PORT_C_DATA
00001338  13FC 0038 00A00019      3315m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001340                          3316m     ENDM
00001340                          3317m     WAIT_DRIVE_READY D0, D1
00001340                          3318m LOOP_229
00001340                          3319mm     READ_IDE_STATUS D0, D1
00001340                          3320mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001340  13FC 0000 00A00007      3321mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001348  123C 0030               3322mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000134C  0001 0007               3323mmm     ORI.B #IDE_STATUS_REGISTER, D1
00001350  13C1 00A00019           3324mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001356  0201 00DF               3325mmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000135A  13C1 00A00019           3326mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001360  1039 00A00013           3327mmm     MOVE.B MC68230_PORT_B_DATA, D0
00001366  0001 0020               3328mmm     ORI.B #MC68230_PORT_C_READ, D1
0000136A  13C1 00A00019           3329mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001370  13FC 0038 00A00019      3330mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001378                          3331mmm     ENDM
00001378                          3332mm     ENDM
00001378  0800 0006               3333m     BTST #IDE_STATUS_READY, D0
0000137C  67C2                    3334m     BEQ LOOP_229
0000137E                          3335m     ENDM
0000137E                          3336          
0000137E                          3337m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
0000137E                          3338mm     WAIT_DRIVE_NOT_BUSY D0, D1
0000137E                          3339mm LOOP_233
0000137E                          3340mmm     READ_IDE_STATUS D0, D1
0000137E                          3341mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
0000137E  13FC 0000 00A00007      3342mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001386  123C 0030               3343mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000138A  0001 0007               3344mmmm     ORI.B #IDE_STATUS_REGISTER, D1
0000138E  13C1 00A00019           3345mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001394  0201 00DF               3346mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001398  13C1 00A00019           3347mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000139E  1039 00A00013           3348mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000013A4  0001 0020               3349mmmm     ORI.B #MC68230_PORT_C_READ, D1
000013A8  13C1 00A00019           3350mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000013AE  13FC 0038 00A00019      3351mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013B6                          3352mmmm     ENDM
000013B6                          3353mmm     ENDM
000013B6  0800 0007               3354mm     BTST #IDE_STATUS_BUSY, D0
000013BA  66C2                    3355mm     BNE LOOP_233
000013BC                          3356mm     ENDM
000013BC                          3357mm     SET_READ_ADDRESS #0, D0, D1, D2
000013BC                          3358mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
000013BC  13FC 00FF 00A00007      3359mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000013C4  103C 0030               3360mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000013C8  0000 0002               3361mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
000013CC  13C0 00A00019           3362mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013D2  0200 00EF               3363mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000013D6  13FC 0001 00A00013      3364mmm     MOVE.B #1, MC68230_PORT_B_DATA
000013DE  13C0 00A00019           3365mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013E4  0000 0010               3366mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000013E8  13C0 00A00019           3367mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013EE  13FC 0038 00A00019      3368mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013F6                          3369mmm     ENDM
000013F6  7200                    3370mm     MOVE.L #0,D1
000013F8                          3371mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
000013F8  13FC 00FF 00A00007      3372mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001400  103C 0030               3373mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001404  0000 0003               3374mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
00001408  13C0 00A00019           3375mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000140E  0200 00EF               3376mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001412  13C1 00A00013           3377mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001418  13C0 00A00019           3378mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000141E  0000 0010               3379mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001422  13C0 00A00019           3380mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001428  13FC 0038 00A00019      3381mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001430                          3382mmm     ENDM
00001430  E089                    3383mm     LSR.L #8, D1
00001432                          3384mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001432  13FC 00FF 00A00007      3385mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000143A  103C 0030               3386mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000143E  0000 0004               3387mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
00001442  13C0 00A00019           3388mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001448  0200 00EF               3389mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000144C  13C1 00A00013           3390mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001452  13C0 00A00019           3391mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001458  0000 0010               3392mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000145C  13C0 00A00019           3393mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001462  13FC 0038 00A00019      3394mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000146A                          3395mmm     ENDM
0000146A  E089                    3396mm     LSR.L #8, D1                                
0000146C                          3397mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
0000146C  13FC 00FF 00A00007      3398mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001474  103C 0030               3399mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001478  0000 0005               3400mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
0000147C  13C0 00A00019           3401mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001482  0200 00EF               3402mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001486  13C1 00A00013           3403mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000148C  13C0 00A00019           3404mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001492  0000 0010               3405mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001496  13C0 00A00019           3406mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000149C  13FC 0038 00A00019      3407mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014A4                          3408mmm     ENDM
000014A4  E089                    3409mm     LSR.L #8, D1
000014A6                          3410mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
000014A6  13FC 0000 00A00007      3411mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014AE  103C 0030               3412mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014B2  0000 0006               3413mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000014B6  13C0 00A00019           3414mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014BC  0200 00DF               3415mmm     ANDI.B #~MC68230_PORT_C_READ, D0
000014C0  13C0 00A00019           3416mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014C6  1439 00A00013           3417mmm     MOVE.B MC68230_PORT_B_DATA, D2
000014CC  0000 0020               3418mmm     ORI.B #MC68230_PORT_C_READ, D0
000014D0  13C0 00A00019           3419mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014D6  13FC 0038 00A00019      3420mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014DE                          3421mmm     ENDM
000014DE  0201 000F               3422mm     ANDI.B #$0F,D1
000014E2  8401                    3423mm     OR.B D1,D2
000014E4                          3424mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
000014E4  13FC 00FF 00A00007      3425mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014EC  103C 0030               3426mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014F0  0000 0006               3427mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
000014F4  13C0 00A00019           3428mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014FA  0200 00EF               3429mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014FE  13C2 00A00013           3430mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001504  13C0 00A00019           3431mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000150A  0000 0010               3432mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000150E  13C0 00A00019           3433mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001514  13FC 0038 00A00019      3434mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000151C                          3435mmm     ENDM
0000151C                          3436mm     ENDM
0000151C                          3437mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
0000151C                          3438mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
0000151C  13FC 00FF 00A00007      3439mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001524  103C 0030               3440mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001528  0000 0007               3441mmm     ORI.B #IDE_COMMAND_REGISTER, D0
0000152C  13C0 00A00019           3442mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001532  0200 00EF               3443mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001536  13FC 0020 00A00013      3444mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
0000153E  13C0 00A00019           3445mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001544  0000 0010               3446mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001548  13C0 00A00019           3447mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000154E  13FC 0038 00A00019      3448mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001556                          3449mmm     ENDM
00001556                          3450mm     ENDM
00001556                          3451mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001556                          3452mm LOOP_245
00001556                          3453mmm     READ_IDE_STATUS D0, D1
00001556                          3454mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001556  13FC 0000 00A00007      3455mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000155E  123C 0030               3456mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001562  0001 0007               3457mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001566  13C1 00A00019           3458mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000156C  0201 00DF               3459mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001570  13C1 00A00019           3460mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001576  1039 00A00013           3461mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000157C  0001 0020               3462mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001580  13C1 00A00019           3463mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001586  13FC 0038 00A00019      3464mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000158E                          3465mmmm     ENDM
0000158E                          3466mmm     ENDM
0000158E  0800 0007               3467mm     BTST #IDE_STATUS_BUSY, D0
00001592  66C2                    3468mm     BNE LOOP_245
00001594                          3469mm     ENDM
00001594                          3470mm     WAIT_DRIVE_DRQ D0, D1
00001594                          3471mm LOOP_248
00001594                          3472mmm     READ_IDE_STATUS D0, D1
00001594                          3473mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001594  13FC 0000 00A00007      3474mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000159C  123C 0030               3475mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000015A0  0001 0007               3476mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000015A4  13C1 00A00019           3477mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015AA  0201 00DF               3478mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000015AE  13C1 00A00019           3479mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015B4  1039 00A00013           3480mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000015BA  0001 0020               3481mmmm     ORI.B #MC68230_PORT_C_READ, D1
000015BE  13C1 00A00019           3482mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015C4  13FC 0038 00A00019      3483mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015CC                          3484mmmm     ENDM
000015CC                          3485mmm     ENDM
000015CC  0800 0003               3486mm     BTST #IDE_STATUS_DRQ, D0
000015D0  67C2                    3487mm     BEQ LOOP_248
000015D2                          3488mm     ENDM
000015D2                          3489m     ENDM
000015D2                          3490      
000015D2                          3491      FOR D1 = #0 to #7 DO
000015D2  323C 0000               3492s     MOVE.W  #0,D1
000015D6  6000 0098               3493s     BRA _20000015
000015DA                          3494s _20000014
000015DA                          3495m         READ_32 #IDE_DATA_REGISTER, D0, D6      ; num entries in boot table -> D0 (it's written 8 times to fill the block up)
000015DA                          3496mm     READ_16 #IDE_DATA_REGISTER, D0, D6
000015DA  13FC 0000 00A00007      3497mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015E2  13FC 0000 00A00005      3498mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000015EA                          3499mm     
000015EA  1C3C 0030               3500mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
000015EE  0006 0000               3501mm     ORI.B #IDE_DATA_REGISTER, D6
000015F2  13C6 00A00019           3502mm     MOVE.B D6, MC68230_PORT_C_DATA
000015F8  0206 00DF               3503mm     ANDI.B #~MC68230_PORT_C_READ, D6
000015FC  13C6 00A00019           3504mm     MOVE.B D6, MC68230_PORT_C_DATA
00001602  1039 00A00011           3505mm     MOVE.B MC68230_PORT_A_DATA, D0
00001608  E148                    3506mm     LSL.W #8, D0
0000160A  1039 00A00013           3507mm     MOVE.B MC68230_PORT_B_DATA, D0
00001610  0006 0020               3508mm     ORI.B #MC68230_PORT_C_READ, D6
00001614  13C6 00A00019           3509mm     MOVE.B D6, MC68230_PORT_C_DATA
0000161A  13FC 0038 00A00019      3510mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001622                          3511mm     ENDM
00001622  E188                    3512m     LSL.L #8, D0
00001624  E188                    3513m     LSL.L #8, D0
00001626                          3514mm     READ_16 #IDE_DATA_REGISTER, D0, D6
00001626  13FC 0000 00A00007      3515mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000162E  13FC 0000 00A00005      3516mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001636                          3517mm     
00001636  1C3C 0030               3518mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
0000163A  0006 0000               3519mm     ORI.B #IDE_DATA_REGISTER, D6
0000163E  13C6 00A00019           3520mm     MOVE.B D6, MC68230_PORT_C_DATA
00001644  0206 00DF               3521mm     ANDI.B #~MC68230_PORT_C_READ, D6
00001648  13C6 00A00019           3522mm     MOVE.B D6, MC68230_PORT_C_DATA
0000164E  1039 00A00011           3523mm     MOVE.B MC68230_PORT_A_DATA, D0
00001654  E148                    3524mm     LSL.W #8, D0
00001656  1039 00A00013           3525mm     MOVE.B MC68230_PORT_B_DATA, D0
0000165C  0006 0020               3526mm     ORI.B #MC68230_PORT_C_READ, D6
00001660  13C6 00A00019           3527mm     MOVE.B D6, MC68230_PORT_C_DATA
00001666  13FC 0038 00A00019      3528mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000166E                          3529mm     ENDM
0000166E                          3530m     ENDM
0000166E                          3531      ENDF
0000166E  5241                    3532s     ADD.W   #1,D1
00001670                          3533s _20000015
00001670  B27C 0007               3534s     CMP.W   #7,D1
00001674  6F00 FF64               3535s     BLE _20000014
00001678  7200                    3536      MOVE.L #0, D1                               ; current boot table index -> D1
0000167A                          3537                          
0000167A                          3538      IF A5 <EQ> #1 THEN                          ; if we are booting...
0000167A  BAFC 0001               3539s     CMP.W   #1,A5
0000167E  6600 0018               3540s     BNE _00000014
00001682  CEBC 0000000F           3541          AND.L #$F,D7                            ; consider bottom 4 bits of address accumulator only
00001688                          3542          IF D7 <GE> D0 THEN                      ; don't boot if off the end of the boot table
00001688  BE40                    3543s     CMP.W   D0,D7
0000168A  6D00 0008               3544s     BLT _00000015
0000168E  2A7C 00000002           3545              MOVE.L #2, A5
00001694                          3546          ENDI
00001694                          3547s _00000015
00001694                          3548  
00001694  2007                    3549          MOVE.L D7, D0                           ; then shorten the boot table to the selected entry 
00001696  5280                    3550          ADD.L #1, D0
00001698                          3551      ENDI
00001698                          3552s _00000014
00001698                          3553      
00001698  227C 00000000           3554      MOVE.L #0, A1
0000169E                          3555      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
0000169E  143C 0000               3556s     MOVE.B  #0,D2
000016A2  6000 0236               3557s     BRA _20000017
000016A6                          3558s _20000016
000016A6  1A3C 0001               3559          MOVE.B #1, D5                           ; assume empty
000016AA                          3560          FOR.B D3 = #0 TO #11 DO                 ; words read from this boot table entry -> D2
000016AA  163C 0000               3561s     MOVE.B  #0,D3
000016AE  6000 01EE               3562s     BRA _20000019
000016B2                          3563s _20000018
000016B2                          3564m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
000016B2                          3565mm     READ_16 #IDE_DATA_REGISTER, D4, D7
000016B2  13FC 0000 00A00007      3566mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016BA  13FC 0000 00A00005      3567mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000016C2                          3568mm     
000016C2  1E3C 0030               3569mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000016C6  0007 0000               3570mm     ORI.B #IDE_DATA_REGISTER, D7
000016CA  13C7 00A00019           3571mm     MOVE.B D7, MC68230_PORT_C_DATA
000016D0  0207 00DF               3572mm     ANDI.B #~MC68230_PORT_C_READ, D7
000016D4  13C7 00A00019           3573mm     MOVE.B D7, MC68230_PORT_C_DATA
000016DA  1839 00A00011           3574mm     MOVE.B MC68230_PORT_A_DATA, D4
000016E0  E14C                    3575mm     LSL.W #8, D4
000016E2  1839 00A00013           3576mm     MOVE.B MC68230_PORT_B_DATA, D4
000016E8  0007 0020               3577mm     ORI.B #MC68230_PORT_C_READ, D7
000016EC  13C7 00A00019           3578mm     MOVE.B D7, MC68230_PORT_C_DATA
000016F2  13FC 0038 00A00019      3579mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016FA                          3580mm     ENDM
000016FA  E18C                    3581m     LSL.L #8, D4
000016FC  E18C                    3582m     LSL.L #8, D4
000016FE                          3583mm     READ_16 #IDE_DATA_REGISTER, D4, D7
000016FE  13FC 0000 00A00007      3584mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001706  13FC 0000 00A00005      3585mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000170E                          3586mm     
0000170E  1E3C 0030               3587mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001712  0007 0000               3588mm     ORI.B #IDE_DATA_REGISTER, D7
00001716  13C7 00A00019           3589mm     MOVE.B D7, MC68230_PORT_C_DATA
0000171C  0207 00DF               3590mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001720  13C7 00A00019           3591mm     MOVE.B D7, MC68230_PORT_C_DATA
00001726  1839 00A00011           3592mm     MOVE.B MC68230_PORT_A_DATA, D4
0000172C  E14C                    3593mm     LSL.W #8, D4
0000172E  1839 00A00013           3594mm     MOVE.B MC68230_PORT_B_DATA, D4
00001734  0007 0020               3595mm     ORI.B #MC68230_PORT_C_READ, D7
00001738  13C7 00A00019           3596mm     MOVE.B D7, MC68230_PORT_C_DATA
0000173E  13FC 0038 00A00019      3597mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001746                          3598mm     ENDM
00001746                          3599m     ENDM
00001746                          3600              IF.B D1 <LT> D0 THEN                ; still in the boot table?
00001746  B200                    3601s     CMP.B   D0,D1
00001748  6C00 0152               3602s     BGE _00000016
0000174C                          3603                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
0000174C  B63C 0000               3604s     CMP.B   #0,D3
00001750  6600 0004               3605s     BNE _00000017
00001754  1A04                    3606                      MOVE.B D4, D5               ; empty flag -> D5
00001756                          3607                  ENDI
00001756                          3608s _00000017
00001756                          3609                  
00001756                          3610                  IF.B D5 <NE> #1 THEN            ; not empty         
00001756  BA3C 0001               3611s     CMP.B   #1,D5
0000175A  6700 013A               3612s     BEQ _00000018
0000175E                          3613                      IF A5 <EQ> #0 THEN          ; not booting, so print
0000175E  BAFC 0000               3614s     CMP.W   #0,A5
00001762  6600 00FE               3615s     BNE _00000019
00001766                          3616                          IF.B D3 <EQ> #0 THEN    ; first word in boot table, print the index
00001766  B63C 0000               3617s     CMP.B   #0,D3
0000176A  6600 0044               3618s     BNE _0000001A
0000176E                          3619m                             PRINT_REG_4BIT D1, D6, D7, A0   
0000176E  41FA 0884               3620m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001772  1E01                    3621m     MOVE.B D1,D7
00001774  0287 0000000F           3622m     ANDI.L #$F,D7
0000177A  1E30 7000               3623m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
0000177E                          3624mm     PRINT_CHAR D7,D6
0000177E                          3625mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000177E                 TRUE     3626mm     IFEQ DEBUG
0000177E  1C39 00C00003           3627mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00001784  0806 0002               3628mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00001788  67F4                    3629mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
0000178A  13C7 00C00007           3630mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001790                          3631mm     ENDC
00001790                          3632mm 
00001790                 FALSE    3633mm     IFNE DEBUG
00001790                          3634mm     ENDC
00001790                          3635mm 
00001790                          3636mm     ENDM
00001790                          3637m     ENDM
00001790  41FA 08BB               3638                              LEA INDEX_SEP(PC), A0
00001794                          3639m                             PRINT_STR A0, D7
00001794                          3640m LOOP_259
00001794  0C10 0000               3641m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001798  6700 0016               3642m     BEQ EXIT_259
0000179C                          3643mm     PRINT_CHAR (A0)+,D7
0000179C                          3644mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000179C                 TRUE     3645mm     IFEQ DEBUG
0000179C  1E39 00C00003           3646mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017A2  0807 0002               3647mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017A6  67F4                    3648mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
000017A8  13D8 00C00007           3649mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017AE                          3650mm     ENDC
000017AE                          3651mm 
000017AE                 FALSE    3652mm     IFNE DEBUG
000017AE                          3653mm     ENDC
000017AE                          3654mm 
000017AE                          3655mm     ENDM
000017AE  60E4                    3656m     BRA LOOP_259
000017B0                          3657m EXIT_259
000017B0                          3658m     ENDM
000017B0                          3659                          ENDI
000017B0                          3660s _0000001A
000017B0                          3661  
000017B0                          3662                          IF.B D3 <GT> #1 AND.B D3 <LT> #7 THEN   ; str, print it
000017B0  B63C 0001               3663s     CMP.B   #1,D3
000017B4  6F00 002E               3664s     BLE _0000001B
000017B8  B63C 0007               3665s     CMP.B   #7,D3
000017BC  6C00 0026               3666s     BGE _0000001B
000017C0                          3667                              FOR.B D6 = #0 TO #3 DO
000017C0  1C3C 0000               3668s     MOVE.B  #0,D6
000017C4  6000 0018               3669s     BRA _2000001B
000017C8                          3670s _2000001A
000017C8  E19C                    3671                                  ROL.L #8, D4                    
000017CA                          3672m                                 PRINT_CHAR D4, D7
000017CA                          3673m WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017CA                 TRUE     3674m     IFEQ DEBUG
000017CA  1E39 00C00003           3675m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017D0  0807 0002               3676m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017D4  67F4                    3677m         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000017D6  13C4 00C00007           3678m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017DC                          3679m     ENDC
000017DC                          3680m 
000017DC                 FALSE    3681m     IFNE DEBUG
000017DC                          3682m     ENDC
000017DC                          3683m 
000017DC                          3684m     ENDM
000017DC                          3685                              ENDF
000017DC  5206                    3686s     ADD.B   #1,D6
000017DE                          3687s _2000001B
000017DE  BC3C 0003               3688s     CMP.B   #3,D6
000017E2  6FE4                    3689s     BLE _2000001A
000017E4                          3690                          ENDI
000017E4                          3691s _0000001B
000017E4                          3692                      
000017E4                          3693                          IF.B D3 <GT> #7 AND.B D3 <LT> #12 THEN
000017E4  B63C 0007               3694s     CMP.B   #7,D3
000017E8  6F00 0078               3695s     BLE _0000001C
000017EC  B63C 000C               3696s     CMP.B   #12,D3
000017F0  6C00 0070               3697s     BGE _0000001C
000017F4  2C45                    3698                              MOVE.L D5, A6       ; preserve the empty flag, we're gonna use D5
000017F6  41FA 0855               3699                              LEA INDEX_SEP(PC), A0
000017FA                          3700m                             PRINT_STR A0, D7
000017FA                          3701m LOOP_262
000017FA  0C10 0000               3702m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017FE  6700 0016               3703m     BEQ EXIT_262
00001802                          3704mm     PRINT_CHAR (A0)+,D7
00001802                          3705mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001802                 TRUE     3706mm     IFEQ DEBUG
00001802  1E39 00C00003           3707mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001808  0807 0002               3708mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000180C  67F4                    3709mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
0000180E  13D8 00C00007           3710mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001814                          3711mm     ENDC
00001814                          3712mm 
00001814                 FALSE    3713mm     IFNE DEBUG
00001814                          3714mm     ENDC
00001814                          3715mm 
00001814                          3716mm     ENDM
00001814  60E4                    3717m     BRA LOOP_262
00001816                          3718m EXIT_262
00001816                          3719m     ENDM
00001816                          3720m                             PRINT_REG D4, D5, D6, D7, A0
00001816  41FA 081D               3721m     LEA OX(PC),A0
0000181A                          3722mm     PRINT_STR A0,D5
0000181A                          3723mm LOOP_265
0000181A  0C10 0000               3724mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000181E  6700 0016               3725mm     BEQ EXIT_265
00001822                          3726mmm     PRINT_CHAR (A0)+,D5
00001822                          3727mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001822                 TRUE     3728mmm     IFEQ DEBUG
00001822  1A39 00C00003           3729mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00001828  0805 0002               3730mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000182C  67F4                    3731mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
0000182E  13D8 00C00007           3732mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001834                          3733mmm     ENDC
00001834                          3734mmm 
00001834                 FALSE    3735mmm     IFNE DEBUG
00001834                          3736mmm     ENDC
00001834                          3737mmm 
00001834                          3738mmm     ENDM
00001834  60E4                    3739mm     BRA LOOP_265
00001836                          3740mm EXIT_265
00001836                          3741mm     ENDM
00001836  7E07                    3742m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001838                          3743m LOOP_264
00001838                          3744mm     BIN2HEX D4,D6,A0
00001838  41FA 07BA               3745mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000183C  E99C                    3746mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000183E  1C04                    3747mm     MOVE.B D4,D6
00001840  0286 0000000F           3748mm     ANDI.L #$F,D6
00001846  1C30 6000               3749mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
0000184A                          3750mm     ENDM
0000184A                          3751mm     PRINT_CHAR D6,D5
0000184A                          3752mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000184A                 TRUE     3753mm     IFEQ DEBUG
0000184A  1A39 00C00003           3754mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00001850  0805 0002               3755mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001854  67F4                    3756mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
00001856  13C6 00C00007           3757mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000185C                          3758mm     ENDC
0000185C                          3759mm 
0000185C                 FALSE    3760mm     IFNE DEBUG
0000185C                          3761mm     ENDC
0000185C                          3762mm 
0000185C                          3763mm     ENDM
0000185C  57CF FFDA               3764m     DBEQ D7,LOOP_264
00001860                          3765m     ENDM
00001860  2A0E                    3766                              MOVE.L A6, D5       ; restore the empty flag into D5
00001862                          3767                          ENDI
00001862                          3768s _0000001C
00001862                          3769                      ENDI
00001862                          3770s _00000019
00001862                          3771                      
00001862                          3772                      IF A5 <EQ> #1 THEN          ; save the params if we are booting
00001862  BAFC 0001               3773s     CMP.W   #1,A5
00001866  6600 002A               3774s     BNE _0000001D
0000186A                          3775                          IF.B D3 <EQ> #8 THEN                        
0000186A  B63C 0008               3776s     CMP.B   #8,D3
0000186E  6600 0004               3777s     BNE _0000001E
00001872  2244                    3778                              MOVE.L D4, A1       ; length -> A1
00001874                          3779                          ENDI
00001874                          3780s _0000001E
00001874                          3781              
00001874                          3782                          IF.B D3 <EQ> #9 THEN
00001874  B63C 0009               3783s     CMP.B   #9,D3
00001878  6600 0004               3784s     BNE _0000001F
0000187C  2444                    3785                              MOVE.L D4, A2       ; start address -> A2
0000187E                          3786                          ENDI
0000187E                          3787s _0000001F
0000187E                          3788  
0000187E                          3789                          IF.B D3 <EQ> #10 THEN
0000187E  B63C 000A               3790s     CMP.B   #10,D3
00001882  6600 0004               3791s     BNE _00000020
00001886  2644                    3792                              MOVE.L D4, A3       ; go address -> A3
00001888                          3793                          ENDI
00001888                          3794s _00000020
00001888                          3795  
00001888                          3796                          IF.B D3 <EQ> #11 THEN
00001888  B63C 000B               3797s     CMP.B   #11,D3
0000188C  6600 0004               3798s     BNE _00000021
00001890  2844                    3799                              MOVE.L D4, A4       ; start block -> A4
00001892                          3800                          ENDI                    
00001892                          3801s _00000021
00001892                          3802                      ENDI
00001892                          3803s _0000001D
00001892                          3804                  ELSE
00001892  6000 0008               3805s     BRA _00000022
00001896                          3806s _00000018
00001896  227C 00000000           3807                      MOVE.L #0, A1
0000189C                          3808                  ENDI
0000189C                          3809s _00000022
0000189C                          3810              ENDI            
0000189C                          3811s _00000016
0000189C                          3812          ENDF
0000189C  5203                    3813s     ADD.B   #1,D3
0000189E                          3814s _20000019
0000189E  B63C 000B               3815s     CMP.B   #11,D3
000018A2  6F00 FE0E               3816s     BLE _20000018
000018A6                          3817  
000018A6                          3818          IF A5 <EQ> #0 THEN                  ; not booting?          
000018A6  BAFC 0000               3819s     CMP.W   #0,A5
000018AA  6600 002A               3820s     BNE _00000023
000018AE                          3821              IF.B D5 <NE> #1 THEN            ; not booting and not empty, so print crlf
000018AE  BA3C 0001               3822s     CMP.B   #1,D5
000018B2  6700 0022               3823s     BEQ _00000024
000018B6                          3824m                 PRINT_CRLF D7, A0
000018B6  41FA 0777               3825m     LEA CRLF(PC),A0
000018BA                          3826mm     PRINT_STR A0,D7
000018BA                          3827mm LOOP_270
000018BA  0C10 0000               3828mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000018BE  6700 0016               3829mm     BEQ EXIT_270
000018C2                          3830mmm     PRINT_CHAR (A0)+,D7
000018C2                          3831mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018C2                 TRUE     3832mmm     IFEQ DEBUG
000018C2  1E39 00C00003           3833mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000018C8  0807 0002               3834mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000018CC  67F4                    3835mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
000018CE  13D8 00C00007           3836mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018D4                          3837mmm     ENDC
000018D4                          3838mmm 
000018D4                 FALSE    3839mmm     IFNE DEBUG
000018D4                          3840mmm     ENDC
000018D4                          3841mmm 
000018D4                          3842mmm     ENDM
000018D4  60E4                    3843mm     BRA LOOP_270
000018D6                          3844mm EXIT_270
000018D6                          3845mm     ENDM
000018D6                          3846m     ENDM
000018D6                          3847              ENDI
000018D6                          3848s _00000024
000018D6                          3849          ENDI
000018D6                          3850s _00000023
000018D6                          3851          
000018D6  5281                    3852          ADD.L #1,D1                         ; next boot table index
000018D8                          3853      ENDF
000018D8  5202                    3854s     ADD.B   #1,D2
000018DA                          3855s _20000017
000018DA  B43C 0009               3856s     CMP.B   #9,D2
000018DE  6F00 FDC6               3857s     BLE _20000016
000018E2                          3858                          
000018E2                          3859      IF A5 <NE> #0 THEN                      ; check for boot from empty slot
000018E2  BAFC 0000               3860s     CMP.W   #0,A5
000018E6  6700 0034               3861s     BEQ _00000025
000018EA                          3862          IF A5 <EQ> #2 OR A1 <EQ> #0  THEN 
000018EA  BAFC 0002               3863s     CMP.W   #2,A5
000018EE  6708                    3864s     BEQ.S   _00000026
000018F0  B2FC 0000               3865s     CMP.W   #0,A1
000018F4  6600 0026               3866s     BNE _00000027
000018F8                          3867s _00000026
000018F8  41FA 075F               3868              LEA NOT_FOUND(PC), A0
000018FC                          3869m             PRINT_STR A0, D7
000018FC                          3870m LOOP_272
000018FC  0C10 0000               3871m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001900  6700 0016               3872m     BEQ EXIT_272
00001904                          3873mm     PRINT_CHAR (A0)+,D7
00001904                          3874mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001904                 TRUE     3875mm     IFEQ DEBUG
00001904  1E39 00C00003           3876mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000190A  0807 0002               3877mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000190E  67F4                    3878mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
00001910  13D8 00C00007           3879mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001916                          3880mm     ENDC
00001916                          3881mm 
00001916                 FALSE    3882mm     IFNE DEBUG
00001916                          3883mm     ENDC
00001916                          3884mm 
00001916                          3885mm     ENDM
00001916  60E4                    3886m     BRA LOOP_272
00001918                          3887m EXIT_272
00001918                          3888m     ENDM
00001918  6000 EA2A               3889              BRA MAIN_LOOP
0000191C                          3890          ENDI
0000191C                          3891s _00000027
0000191C                          3892      ENDI
0000191C                          3893s _00000025
0000191C                          3894      
0000191C                          3895      IF A5 <EQ> #1 THEN                      ; booting?
0000191C  BAFC 0001               3896s     CMP.W   #1,A5
00001920  6600 031C               3897s     BNE _00000028
00001924  41FA 072B               3898          LEA BOOT(PC), A0
00001928                          3899m         PRINT_STR A0, D7
00001928                          3900m LOOP_274
00001928  0C10 0000               3901m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000192C  6700 0016               3902m     BEQ EXIT_274
00001930                          3903mm     PRINT_CHAR (A0)+,D7
00001930                          3904mm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001930                 TRUE     3905mm     IFEQ DEBUG
00001930  1E39 00C00003           3906mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001936  0807 0002               3907mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000193A  67F4                    3908mm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
0000193C  13D8 00C00007           3909mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001942                          3910mm     ENDC
00001942                          3911mm 
00001942                 FALSE    3912mm     IFNE DEBUG
00001942                          3913mm     ENDC
00001942                          3914mm 
00001942                          3915mm     ENDM
00001942  60E4                    3916m     BRA LOOP_274
00001944                          3917m EXIT_274
00001944                          3918m     ENDM
00001944                          3919      
00001944  2009                    3920          MOVE.L A1, D0                       ; length -> D0              
00001946  220C                    3921          MOVE.L A4, D1                       ; start block -> D1
00001948                          3922          
00001948                          3923          WHILE.L D0 <GT> #0 DO
00001948                          3924s _10000016
00001948  B0BC 00000000           3925s     CMP.L   #0,D0
0000194E  6F00 02CC               3926s     BLE _10000017
00001952                          3927m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
00001952                          3928mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001952                          3929mm LOOP_277
00001952                          3930mmm     READ_IDE_STATUS D5, D6
00001952                          3931mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001952  13FC 0000 00A00007      3932mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000195A  1C3C 0030               3933mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
0000195E  0006 0007               3934mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001962  13C6 00A00019           3935mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001968  0206 00DF               3936mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
0000196C  13C6 00A00019           3937mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001972  1A39 00A00013           3938mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001978  0006 0020               3939mmmm     ORI.B #MC68230_PORT_C_READ, D6
0000197C  13C6 00A00019           3940mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001982  13FC 0038 00A00019      3941mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000198A                          3942mmmm     ENDM
0000198A                          3943mmm     ENDM
0000198A  0805 0007               3944mm     BTST #IDE_STATUS_BUSY, D5
0000198E  66C2                    3945mm     BNE LOOP_277
00001990                          3946mm     ENDM
00001990                          3947mm     SET_READ_ADDRESS D1, D5, D6, D7
00001990                          3948mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D5
00001990  13FC 00FF 00A00007      3949mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001998  1A3C 0030               3950mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
0000199C  0005 0002               3951mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D5
000019A0  13C5 00A00019           3952mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019A6  0205 00EF               3953mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019AA  13FC 0001 00A00013      3954mmm     MOVE.B #1, MC68230_PORT_B_DATA
000019B2  13C5 00A00019           3955mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019B8  0005 0010               3956mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019BC  13C5 00A00019           3957mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019C2  13FC 0038 00A00019      3958mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019CA                          3959mmm     ENDM
000019CA  2C01                    3960mm     MOVE.L D1,D6
000019CC                          3961mmm     WRITE_8 D6, #IDE_LBA_0_7_REGISTER, D5
000019CC  13FC 00FF 00A00007      3962mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019D4  1A3C 0030               3963mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019D8  0005 0003               3964mmm     ORI.B #IDE_LBA_0_7_REGISTER, D5
000019DC  13C5 00A00019           3965mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019E2  0205 00EF               3966mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019E6  13C6 00A00013           3967mmm     MOVE.B D6, MC68230_PORT_B_DATA
000019EC  13C5 00A00019           3968mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019F2  0005 0010               3969mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019F6  13C5 00A00019           3970mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019FC  13FC 0038 00A00019      3971mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A04                          3972mmm     ENDM
00001A04  E08E                    3973mm     LSR.L #8, D6
00001A06                          3974mmm     WRITE_8 D6, #IDE_LBA_8_15_REGISTER, D5
00001A06  13FC 00FF 00A00007      3975mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A0E  1A3C 0030               3976mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A12  0005 0004               3977mmm     ORI.B #IDE_LBA_8_15_REGISTER, D5
00001A16  13C5 00A00019           3978mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A1C  0205 00EF               3979mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A20  13C6 00A00013           3980mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A26  13C5 00A00019           3981mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A2C  0005 0010               3982mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A30  13C5 00A00019           3983mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A36  13FC 0038 00A00019      3984mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A3E                          3985mmm     ENDM
00001A3E  E08E                    3986mm     LSR.L #8, D6                                
00001A40                          3987mmm     WRITE_8 D6, #IDE_LBA_16_23_REGISTER, D5
00001A40  13FC 00FF 00A00007      3988mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A48  1A3C 0030               3989mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A4C  0005 0005               3990mmm     ORI.B #IDE_LBA_16_23_REGISTER, D5
00001A50  13C5 00A00019           3991mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A56  0205 00EF               3992mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A5A  13C6 00A00013           3993mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A60  13C5 00A00019           3994mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A66  0005 0010               3995mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A6A  13C5 00A00019           3996mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A70  13FC 0038 00A00019      3997mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A78                          3998mmm     ENDM
00001A78  E08E                    3999mm     LSR.L #8, D6
00001A7A                          4000mmm     READ_8 #IDE_DRIVESEL_REGISTER, D7, D5
00001A7A  13FC 0000 00A00007      4001mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001A82  1A3C 0030               4002mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A86  0005 0006               4003mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001A8A  13C5 00A00019           4004mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A90  0205 00DF               4005mmm     ANDI.B #~MC68230_PORT_C_READ, D5
00001A94  13C5 00A00019           4006mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A9A  1E39 00A00013           4007mmm     MOVE.B MC68230_PORT_B_DATA, D7
00001AA0  0005 0020               4008mmm     ORI.B #MC68230_PORT_C_READ, D5
00001AA4  13C5 00A00019           4009mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AAA  13FC 0038 00A00019      4010mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AB2                          4011mmm     ENDM
00001AB2  0206 000F               4012mm     ANDI.B #$0F,D6
00001AB6  8E06                    4013mm     OR.B D6,D7
00001AB8                          4014mmm     WRITE_8 D7, #IDE_DRIVESEL_REGISTER, D5
00001AB8  13FC 00FF 00A00007      4015mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001AC0  1A3C 0030               4016mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AC4  0005 0006               4017mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001AC8  13C5 00A00019           4018mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001ACE  0205 00EF               4019mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001AD2  13C7 00A00013           4020mmm     MOVE.B D7, MC68230_PORT_B_DATA
00001AD8  13C5 00A00019           4021mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001ADE  0005 0010               4022mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001AE2  13C5 00A00019           4023mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AE8  13FC 0038 00A00019      4024mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AF0                          4025mmm     ENDM
00001AF0                          4026mm     ENDM
00001AF0                          4027mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D5
00001AF0                          4028mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D5
00001AF0  13FC 00FF 00A00007      4029mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001AF8  1A3C 0030               4030mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AFC  0005 0007               4031mmm     ORI.B #IDE_COMMAND_REGISTER, D5
00001B00  13C5 00A00019           4032mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B06  0205 00EF               4033mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001B0A  13FC 0020 00A00013      4034mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001B12  13C5 00A00019           4035mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B18  0005 0010               4036mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001B1C  13C5 00A00019           4037mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B22  13FC 0038 00A00019      4038mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B2A                          4039mmm     ENDM
00001B2A                          4040mm     ENDM
00001B2A                          4041mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001B2A                          4042mm LOOP_289
00001B2A                          4043mmm     READ_IDE_STATUS D5, D6
00001B2A                          4044mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001B2A  13FC 0000 00A00007      4045mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B32  1C3C 0030               4046mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001B36  0006 0007               4047mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001B3A  13C6 00A00019           4048mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B40  0206 00DF               4049mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001B44  13C6 00A00019           4050mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B4A  1A39 00A00013           4051mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001B50  0006 0020               4052mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001B54  13C6 00A00019           4053mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B5A  13FC 0038 00A00019      4054mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B62                          4055mmmm     ENDM
00001B62                          4056mmm     ENDM
00001B62  0805 0007               4057mm     BTST #IDE_STATUS_BUSY, D5
00001B66  66C2                    4058mm     BNE LOOP_289
00001B68                          4059mm     ENDM
00001B68                          4060mm     WAIT_DRIVE_DRQ D5, D6
00001B68                          4061mm LOOP_292
00001B68                          4062mmm     READ_IDE_STATUS D5, D6
00001B68                          4063mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001B68  13FC 0000 00A00007      4064mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B70  1C3C 0030               4065mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001B74  0006 0007               4066mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001B78  13C6 00A00019           4067mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B7E  0206 00DF               4068mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001B82  13C6 00A00019           4069mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B88  1A39 00A00013           4070mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001B8E  0006 0020               4071mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001B92  13C6 00A00019           4072mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B98  13FC 0038 00A00019      4073mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001BA0                          4074mmmm     ENDM
00001BA0                          4075mmm     ENDM
00001BA0  0805 0003               4076mm     BTST #IDE_STATUS_DRQ, D5
00001BA4  67C2                    4077mm     BEQ LOOP_292
00001BA6                          4078mm     ENDM
00001BA6                          4079m     ENDM
00001BA6                          4080m             PRINT_CHAR #'.', D7
00001BA6                          4081m WAIT_FOR_READY_295                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001BA6                 TRUE     4082m     IFEQ DEBUG
00001BA6  1E39 00C00003           4083m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001BAC  0807 0002               4084m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001BB0  67F4                    4085m         BEQ WAIT_FOR_READY_295                      ; NO SPACE, CHECK AGAIN
00001BB2  13FC 002E 00C00007      4086m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001BBA                          4087m     ENDC
00001BBA                          4088m 
00001BBA                 FALSE    4089m     IFNE DEBUG
00001BBA                          4090m     ENDC
00001BBA                          4091m 
00001BBA                          4092m     ENDM
00001BBA                          4093              
00001BBA                          4094              FOR.L D3 = #0 TO #255 DO
00001BBA  7600                    4095s     MOVE.L  #0,D3
00001BBC  6000 0050               4096s     BRA _2000001D
00001BC0                          4097s _2000001C
00001BC0                          4098m                 READ_16 #IDE_DATA_REGISTER, D4, D7
00001BC0  13FC 0000 00A00007      4099m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BC8  13FC 0000 00A00005      4100m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001BD0                          4101m     
00001BD0  1E3C 0030               4102m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001BD4  0007 0000               4103m     ORI.B #IDE_DATA_REGISTER, D7
00001BD8  13C7 00A00019           4104m     MOVE.B D7, MC68230_PORT_C_DATA
00001BDE  0207 00DF               4105m     ANDI.B #~MC68230_PORT_C_READ, D7
00001BE2  13C7 00A00019           4106m     MOVE.B D7, MC68230_PORT_C_DATA
00001BE8  1839 00A00011           4107m     MOVE.B MC68230_PORT_A_DATA, D4
00001BEE  E14C                    4108m     LSL.W #8, D4
00001BF0  1839 00A00013           4109m     MOVE.B MC68230_PORT_B_DATA, D4
00001BF6  0007 0020               4110m     ORI.B #MC68230_PORT_C_READ, D7
00001BFA  13C7 00A00019           4111m     MOVE.B D7, MC68230_PORT_C_DATA
00001C00  13FC 0038 00A00019      4112m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001C08                          4113m     ENDM
00001C08  34C4                    4114                  MOVE.W D4,(A2)+
00001C0A  5580                    4115                  SUB.L #2, D0
00001C0C                          4116              ENDF
00001C0C  5283                    4117s     ADD.L   #1,D3
00001C0E                          4118s _2000001D
00001C0E  B6BC 000000FF           4119s     CMP.L   #255,D3
00001C14  6FAA                    4120s     BLE _2000001C
00001C16                          4121          
00001C16  5281                    4122              ADD.L #1, D1                    ; next block
00001C18                          4123          ENDW
00001C18  6000 FD2E               4124s     BRA _10000016
00001C1C                          4125s _10000017
00001C1C                          4126  
00001C1C                          4127m         PRINT_CRLF D3, A6   
00001C1C  4DFA 0411               4128m     LEA CRLF(PC),A6
00001C20                          4129mm     PRINT_STR A6,D3
00001C20                          4130mm LOOP_298
00001C20  0C16 0000               4131mm     CMP.B #NULL,(A6)                                ; 0 -> DONE
00001C24  6700 0016               4132mm     BEQ EXIT_298
00001C28                          4133mmm     PRINT_CHAR (A6)+,D3
00001C28                          4134mmm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C28                 TRUE     4135mmm     IFEQ DEBUG
00001C28  1639 00C00003           4136mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001C2E  0803 0002               4137mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001C32  67F4                    4138mmm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001C34  13DE 00C00007           4139mmm         MOVE.B (A6)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C3A                          4140mmm     ENDC
00001C3A                          4141mmm 
00001C3A                 FALSE    4142mmm     IFNE DEBUG
00001C3A                          4143mmm     ENDC
00001C3A                          4144mmm 
00001C3A                          4145mmm     ENDM
00001C3A  60E4                    4146mm     BRA LOOP_298
00001C3C                          4147mm EXIT_298
00001C3C                          4148mm     ENDM
00001C3C                          4149m     ENDM
00001C3C                          4150      
00001C3C  2E0B                    4151          MOVE.L A3, D7                           ; set go address
00001C3E                          4152      ENDI
00001C3E                          4153s _00000028
00001C3E                          4154  
00001C3E  6000 E704               4155      BRA MAIN_LOOP
00001C42                          4156  
00001C42                          4157  HEX_DIGIT
00001C42  E98F                    4158      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001C44                          4159m     HEX2BIN D2,D2,A0
00001C44  41FA 03BE               4160m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001C48  0402 0030               4161m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001C4C  C4BC 000000FF           4162m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001C52  1430 2000               4163m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001C56                          4164m     ENDM
00001C56  8E02                    4165      OR.B D2,D7  
00001C58  6000 E70A               4166      BRA GET_INPUT
00001C5C                          4167  
00001C5C                          4168  ; exceptions    
00001C5C                          4169  BUS_ERROR_HANDLER
00001C5C                          4170  
00001C5C  41FA 040E               4171      LEA BUS_ERROR(PC),A0
00001C60                          4172m     PRINT_STR A0,D1
00001C60                          4173m LOOP_301
00001C60  0C10 0000               4174m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C64  6700 0016               4175m     BEQ EXIT_301
00001C68                          4176mm     PRINT_CHAR (A0)+,D1
00001C68                          4177mm WAIT_FOR_READY_302                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C68                 TRUE     4178mm     IFEQ DEBUG
00001C68  1239 00C00003           4179mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C6E  0801 0002               4180mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001C72  67F4                    4181mm         BEQ WAIT_FOR_READY_302                      ; NO SPACE, CHECK AGAIN
00001C74  13D8 00C00007           4182mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C7A                          4183mm     ENDC
00001C7A                          4184mm 
00001C7A                 FALSE    4185mm     IFNE DEBUG
00001C7A                          4186mm     ENDC
00001C7A                          4187mm 
00001C7A                          4188mm     ENDM
00001C7A  60E4                    4189m     BRA LOOP_301
00001C7C                          4190m EXIT_301
00001C7C                          4191m     ENDM
00001C7C                          4192  
00001C7C  7000                    4193      MOVE.L #0,D0
00001C7E  3017                    4194      MOVE.W (SP),D0
00001C80                          4195  
00001C80  0800 0004               4196      BTST #4,D0
00001C84  6700 0026               4197      BEQ WRITE
00001C88                          4198      
00001C88  41FA 03F7               4199      LEA READING(PC),A0
00001C8C                          4200m     PRINT_STR A0,D1
00001C8C                          4201m LOOP_303
00001C8C  0C10 0000               4202m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C90  6700 0016               4203m     BEQ EXIT_303
00001C94                          4204mm     PRINT_CHAR (A0)+,D1
00001C94                          4205mm WAIT_FOR_READY_304                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C94                 TRUE     4206mm     IFEQ DEBUG
00001C94  1239 00C00003           4207mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C9A  0801 0002               4208mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001C9E  67F4                    4209mm         BEQ WAIT_FOR_READY_304                      ; NO SPACE, CHECK AGAIN
00001CA0  13D8 00C00007           4210mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CA6                          4211mm     ENDC
00001CA6                          4212mm 
00001CA6                 FALSE    4213mm     IFNE DEBUG
00001CA6                          4214mm     ENDC
00001CA6                          4215mm 
00001CA6                          4216mm     ENDM
00001CA6  60E4                    4217m     BRA LOOP_303
00001CA8                          4218m EXIT_303
00001CA8                          4219m     ENDM
00001CA8                          4220  
00001CA8  6000 0022               4221      BRA CONTINUE    
00001CAC                          4222  WRITE
00001CAC  41FA 03DC               4223      LEA WRITING(PC),A0
00001CB0                          4224m     PRINT_STR A0,D1
00001CB0                          4225m LOOP_305
00001CB0  0C10 0000               4226m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CB4  6700 0016               4227m     BEQ EXIT_305
00001CB8                          4228mm     PRINT_CHAR (A0)+,D1
00001CB8                          4229mm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CB8                 TRUE     4230mm     IFEQ DEBUG
00001CB8  1239 00C00003           4231mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CBE  0801 0002               4232mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CC2  67F4                    4233mm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
00001CC4  13D8 00C00007           4234mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CCA                          4235mm     ENDC
00001CCA                          4236mm 
00001CCA                 FALSE    4237mm     IFNE DEBUG
00001CCA                          4238mm     ENDC
00001CCA                          4239mm 
00001CCA                          4240mm     ENDM
00001CCA  60E4                    4241m     BRA LOOP_305
00001CCC                          4242m EXIT_305
00001CCC                          4243m     ENDM
00001CCC                          4244  
00001CCC                          4245  CONTINUE
00001CCC  222F 0002               4246      MOVE.L 2(SP),D1
00001CD0                          4247m     PRINT_REG D1,D2,D3,D4,A0
00001CD0  41FA 0363               4248m     LEA OX(PC),A0
00001CD4                          4249mm     PRINT_STR A0,D2
00001CD4                          4250mm LOOP_308
00001CD4  0C10 0000               4251mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CD8  6700 0016               4252mm     BEQ EXIT_308
00001CDC                          4253mmm     PRINT_CHAR (A0)+,D2
00001CDC                          4254mmm WAIT_FOR_READY_309                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CDC                 TRUE     4255mmm     IFEQ DEBUG
00001CDC  1439 00C00003           4256mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001CE2  0802 0002               4257mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001CE6  67F4                    4258mmm         BEQ WAIT_FOR_READY_309                      ; NO SPACE, CHECK AGAIN
00001CE8  13D8 00C00007           4259mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CEE                          4260mmm     ENDC
00001CEE                          4261mmm 
00001CEE                 FALSE    4262mmm     IFNE DEBUG
00001CEE                          4263mmm     ENDC
00001CEE                          4264mmm 
00001CEE                          4265mmm     ENDM
00001CEE  60E4                    4266mm     BRA LOOP_308
00001CF0                          4267mm EXIT_308
00001CF0                          4268mm     ENDM
00001CF0  7807                    4269m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001CF2                          4270m LOOP_307
00001CF2                          4271mm     BIN2HEX D1,D3,A0
00001CF2  41FA 0300               4272mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001CF6  E999                    4273mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001CF8  1601                    4274mm     MOVE.B D1,D3
00001CFA  0283 0000000F           4275mm     ANDI.L #$F,D3
00001D00  1630 3000               4276mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D04                          4277mm     ENDM
00001D04                          4278mm     PRINT_CHAR D3,D2
00001D04                          4279mm WAIT_FOR_READY_311                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D04                 TRUE     4280mm     IFEQ DEBUG
00001D04  1439 00C00003           4281mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D0A  0802 0002               4282mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D0E  67F4                    4283mm         BEQ WAIT_FOR_READY_311                      ; NO SPACE, CHECK AGAIN
00001D10  13C3 00C00007           4284mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D16                          4285mm     ENDC
00001D16                          4286mm 
00001D16                 FALSE    4287mm     IFNE DEBUG
00001D16                          4288mm     ENDC
00001D16                          4289mm 
00001D16                          4290mm     ENDM
00001D16  57CC FFDA               4291m     DBEQ D4,LOOP_307
00001D1A                          4292m     ENDM
00001D1A                          4293  
00001D1A  41FA 0377               4294      LEA FROM(PC),A0
00001D1E                          4295m     PRINT_STR A0,D0
00001D1E                          4296m LOOP_312
00001D1E  0C10 0000               4297m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D22  6700 0016               4298m     BEQ EXIT_312
00001D26                          4299mm     PRINT_CHAR (A0)+,D0
00001D26                          4300mm WAIT_FOR_READY_313                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D26                 TRUE     4301mm     IFEQ DEBUG
00001D26  1039 00C00003           4302mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D2C  0800 0002               4303mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001D30  67F4                    4304mm         BEQ WAIT_FOR_READY_313                      ; NO SPACE, CHECK AGAIN
00001D32  13D8 00C00007           4305mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D38                          4306mm     ENDC
00001D38                          4307mm 
00001D38                 FALSE    4308mm     IFNE DEBUG
00001D38                          4309mm     ENDC
00001D38                          4310mm 
00001D38                          4311mm     ENDM
00001D38  60E4                    4312m     BRA LOOP_312
00001D3A                          4313m EXIT_312
00001D3A                          4314m     ENDM
00001D3A                          4315  
00001D3A  222F 000A               4316      MOVE.L 10(SP),D1
00001D3E                          4317m     PRINT_REG D1,D2,D3,D4,A0
00001D3E  41FA 02F5               4318m     LEA OX(PC),A0
00001D42                          4319mm     PRINT_STR A0,D2
00001D42                          4320mm LOOP_315
00001D42  0C10 0000               4321mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D46  6700 0016               4322mm     BEQ EXIT_315
00001D4A                          4323mmm     PRINT_CHAR (A0)+,D2
00001D4A                          4324mmm WAIT_FOR_READY_316                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D4A                 TRUE     4325mmm     IFEQ DEBUG
00001D4A  1439 00C00003           4326mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D50  0802 0002               4327mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D54  67F4                    4328mmm         BEQ WAIT_FOR_READY_316                      ; NO SPACE, CHECK AGAIN
00001D56  13D8 00C00007           4329mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D5C                          4330mmm     ENDC
00001D5C                          4331mmm 
00001D5C                 FALSE    4332mmm     IFNE DEBUG
00001D5C                          4333mmm     ENDC
00001D5C                          4334mmm 
00001D5C                          4335mmm     ENDM
00001D5C  60E4                    4336mm     BRA LOOP_315
00001D5E                          4337mm EXIT_315
00001D5E                          4338mm     ENDM
00001D5E  7807                    4339m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001D60                          4340m LOOP_314
00001D60                          4341mm     BIN2HEX D1,D3,A0
00001D60  41FA 0292               4342mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001D64  E999                    4343mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001D66  1601                    4344mm     MOVE.B D1,D3
00001D68  0283 0000000F           4345mm     ANDI.L #$F,D3
00001D6E  1630 3000               4346mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D72                          4347mm     ENDM
00001D72                          4348mm     PRINT_CHAR D3,D2
00001D72                          4349mm WAIT_FOR_READY_318                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D72                 TRUE     4350mm     IFEQ DEBUG
00001D72  1439 00C00003           4351mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D78  0802 0002               4352mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D7C  67F4                    4353mm         BEQ WAIT_FOR_READY_318                      ; NO SPACE, CHECK AGAIN
00001D7E  13C3 00C00007           4354mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D84                          4355mm     ENDC
00001D84                          4356mm 
00001D84                 FALSE    4357mm     IFNE DEBUG
00001D84                          4358mm     ENDC
00001D84                          4359mm 
00001D84                          4360mm     ENDM
00001D84  57CC FFDA               4361m     DBEQ D4,LOOP_314
00001D88                          4362m     ENDM
00001D88                          4363m     PRINT_CRLF D0,A0
00001D88  41FA 02A5               4364m     LEA CRLF(PC),A0
00001D8C                          4365mm     PRINT_STR A0,D0
00001D8C                          4366mm LOOP_320
00001D8C  0C10 0000               4367mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D90  6700 0016               4368mm     BEQ EXIT_320
00001D94                          4369mmm     PRINT_CHAR (A0)+,D0
00001D94                          4370mmm WAIT_FOR_READY_321                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D94                 TRUE     4371mmm     IFEQ DEBUG
00001D94  1039 00C00003           4372mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D9A  0800 0002               4373mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001D9E  67F4                    4374mmm         BEQ WAIT_FOR_READY_321                      ; NO SPACE, CHECK AGAIN
00001DA0  13D8 00C00007           4375mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DA6                          4376mmm     ENDC
00001DA6                          4377mmm 
00001DA6                 FALSE    4378mmm     IFNE DEBUG
00001DA6                          4379mmm     ENDC
00001DA6                          4380mmm 
00001DA6                          4381mmm     ENDM
00001DA6  60E4                    4382mm     BRA LOOP_320
00001DA8                          4383mm EXIT_320
00001DA8                          4384mm     ENDM
00001DA8                          4385m     ENDM
00001DA8                          4386      
00001DA8  207C 00000004           4387      MOVE.L #4,A0
00001DAE  4ED0                    4388      JMP (A0)
00001DB0                          4389          
00001DB0                          4390  ILLEGAL_HANDLER
00001DB0  13FC 0007 00E00001      4391      MOVE.B #7,DISPLAY   
00001DB8  207C 00000004           4392      MOVE.L #4,A0
00001DBE  4ED0                    4393      JMP (A0)
00001DC0                          4394          
00001DC0                          4395  UNHANDLED_HANDLER
00001DC0  41FA 02D8               4396      LEA UNHANDLED(PC),A0
00001DC4  4EF9 00001DE8           4397      JMP PRINTIT_RTE
00001DCA                          4398      
00001DCA                          4399  UNINITIALISED_HANDLER
00001DCA  41FA 02E4               4400      LEA UNINITIALISED(PC),A0
00001DCE  4EF9 00001DE8           4401      JMP PRINTIT_RTE
00001DD4                          4402  
00001DD4                          4403  TICK_HANDLER
00001DD4  1039 00C0001F           4404      MOVE.B DUART_RESET_OPR,D0
00001DDA  41FA 0289               4405      LEA TICK(PC),A0
00001DDE  4EF9 00001DE8           4406      JMP PRINTIT_RTE
00001DE4                          4407  
00001DE4                          4408  SPURIOUS_HANDLER
00001DE4  41FA 02E9               4409      LEA SPURIOUS(PC),A0
00001DE8                          4410  PRINTIT_RTE
00001DE8                          4411m     PRINT_STR A0,D1
00001DE8                          4412m LOOP_322
00001DE8  0C10 0000               4413m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001DEC  6700 0016               4414m     BEQ EXIT_322
00001DF0                          4415mm     PRINT_CHAR (A0)+,D1
00001DF0                          4416mm WAIT_FOR_READY_323                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DF0                 TRUE     4417mm     IFEQ DEBUG
00001DF0  1239 00C00003           4418mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001DF6  0801 0002               4419mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001DFA  67F4                    4420mm         BEQ WAIT_FOR_READY_323                      ; NO SPACE, CHECK AGAIN
00001DFC  13D8 00C00007           4421mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001E02                          4422mm     ENDC
00001E02                          4423mm 
00001E02                 FALSE    4424mm     IFNE DEBUG
00001E02                          4425mm     ENDC
00001E02                          4426mm 
00001E02                          4427mm     ENDM
00001E02  60E4                    4428m     BRA LOOP_322
00001E04                          4429m EXIT_322
00001E04                          4430m     ENDM
00001E04  4E73                    4431      RTE 
00001E06                          4432      
00001E06  FFFF FFFF               4433      SIMHALT                                             ; halt simulator
00001E0A                          4434  
00001E0A                          4435  ; strings
00001E0A= 50 72 65 73 73 20 ...   4436  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001E1D= 5B 3F 5D 09 09 09 ...   4437  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001E29= 5B 76 5D 09 09 09 ...   4438          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001E38= 78 78 78 78 78 78 ...   4439          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001E50= 78 78 78 78 78 78 ...   4440          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001E70= 78 78 78 78 78 78 ...   4441          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001E91= 78 78 78 78 78 78 ...   4442          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001EA2= 5B 7A 5D 09 09 09 ...   4443          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001EB4= 78 78 78 78 78 78 ...   4444          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001ED8= 78 78 78 78 78 78 ...   4445          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001EFA= 23 09 09 09 77 72 ...   4446          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001F14= 5B 78 5D 09 09 09 ...   4447          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001F2B= 5B 49 5D 09 09 09 ...   4448          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001F44= 5B 6F 5D 09 09 09 ...   4449          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001F5E= 5B 69 5D 09 09 09 ...   4450          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001F74= 78 78 78 78 78 78 ...   4451          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001F92= 48 75 68 3F 0D 0A 00    4452  HUH  DC.B 'Huh?',CR,LF,NULL
00001F99= 20 53 20 72 65 63 ...   4453  READ    DC.B ' S records read, start address = ',NULL
00001FBB= 57 3A 20 55 6E 6B ...   4454  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001FD2= 21 20 43 53 20 66 ...   4455  CS_FAILURE  DC.B '! CS failure at ',NULL
00001FE3= 21 20 52 41 4D 20 ...   4456  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001FF4= 30 31 32 33 34 35 ...   4457  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00002004= 00 01 02 03 04 05 ...   4458  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000201B= 4C 6F 61 64 69 6E ...   4459  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
0000202F= 0D 0A 00                4460  CRLF    DC.B CR,LF,NULL
00002032= 3E 20 00                4461  PROMPT  DC.B '> ',NULL
00002035= 30 78 00                4462  ox      DC.B '0x',NULL
00002038= 20 2D 3E 20 00          4463  to      DC.B ' -> ',NULL
0000203D= 20 66 6F 72 20 00       4464  for     DC.B ' for ',NULL
00002043= 53 50 3A 20 00          4465  STACK_POINTER DC.B 'SP: ',NULL
00002048= 53 52 3A 20 00          4466  STATUS_REGISTER DC.B 'SR: ',NULL
0000204D= 20 3A 20 00             4467  INDEX_SEP DC.B ' : ',NULL
00002051= 42 6F 6F 74 69 6E ...   4468  BOOT DC.B 'Booting',NULL
00002059= 4E 6F 74 20 66 6F ...   4469  NOT_FOUND DC.B 'Not found',CR,LF,NULL
00002065= 74 69 63 6B 0D 0A 00    4470  TICK DC.B 'tick',CR,LF,NULL
0000206C= 2A 20 42 75 73 2F ...   4471  BUS_ERROR DC.B '* Bus/address error ',NULL
00002081= 72 65 61 64 69 6E ...   4472  READING DC.B 'reading ',NULL
0000208A= 77 72 69 74 69 6E ...   4473  WRITING DC.B 'writing ',NULL
00002093= 20 66 72 6F 6D 20 00    4474  FROM DC.B ' from ',NULL
0000209A= 2A 20 55 6E 68 61 ...   4475  UNHANDLED DC.B '* Unhandled interrupt',NULL
000020B0= 2A 20 55 6E 69 74 ...   4476  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
000020CF= 2A 20 53 70 75 72 ...   4477  SPURIOUS DC.B '* Spurious interrupt',NULL
000020E4= 4D 44 46 2D 6D 6F ...   4478  VERSION DC.B 'MDF-mon V1.153 (12/09/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00002102= 00                      4479  END     DC.B 0
00002103                          4480      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1FF4
BOOT                2051
BUS_ERROR           206C
BUS_ERROR_HANDLER   1C5C
CONTINUE            1CCC
CR                  D
CRLF                202F
CS_FAILURE          1FD2
DEBUG               0
DI                  12D8
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       986
DOWNLOAD_DONE       AA2
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  12C8
END                 2102
EXIT_10             288
EXIT_104            A92
EXIT_107            AC2
EXIT_110            AE2
EXIT_114            B2C
EXIT_117            B4E
EXIT_122            B98
EXIT_124            C14
EXIT_127            C38
EXIT_132            C82
EXIT_139            D14
EXIT_142            D84
EXIT_144            DA4
EXIT_146            DC4
EXIT_148            DE4
EXIT_15             2D2
EXIT_151            E06
EXIT_155            E50
EXIT_158            E72
EXIT_162            EBC
EXIT_165            EDC
EXIT_17             2F2
EXIT_170            F26
EXIT_185            1050
EXIT_188            10B4
EXIT_191            10D4
EXIT_195            111E
EXIT_198            1140
EXIT_20             312
EXIT_203            118A
EXIT_207            11CC
EXIT_210            11EE
EXIT_215            1238
EXIT_217            1258
EXIT_22             364
EXIT_220            127A
EXIT_225            12C4
EXIT_259            17B0
EXIT_262            1816
EXIT_265            1836
EXIT_270            18D6
EXIT_272            1918
EXIT_274            1944
EXIT_28             3F0
EXIT_298            1C3C
EXIT_30             47C
EXIT_301            1C7C
EXIT_303            1CA8
EXIT_305            1CCC
EXIT_308            1CF0
EXIT_312            1D3A
EXIT_315            1D5E
EXIT_32             4A8
EXIT_320            1DA8
EXIT_322            1E04
EXIT_35             4D2
EXIT_45             580
EXIT_5              240
EXIT_52             5F6
EXIT_7              260
EXIT_82             93E
EXIT_84             95E
EXIT_88             990
EXIT_94             A08
EXIT_96             A28
EXIT_99             A48
FOR                 203D
FROM                2093
G                   B9C
GET_INPUT           364
H                   480
HASH                12E8
HELP                1E1D
HELPPROMPT          1E0A
HEX2BIN             10B
HEX2BIN_LUT         2004
HEX_DIGIT           1C42
HUH                 1F92
IB                  12FE
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1DB0
INDEX_SEP           204D
L                   C92
LF                  A
LOADING             201B
LOOP_10             26C
LOOP_104            A76
LOOP_107            AA6
LOOP_109            AE4
LOOP_110            AC6
LOOP_114            B10
LOOP_116            B50
LOOP_117            B32
LOOP_122            B7C
LOOP_124            BF8
LOOP_126            C3A
LOOP_127            C1C
LOOP_132            C66
LOOP_139            CF8
LOOP_142            D68
LOOP_144            D88
LOOP_146            DA8
LOOP_148            DC8
LOOP_15             2B6
LOOP_150            E08
LOOP_151            DEA
LOOP_155            E34
LOOP_157            E74
LOOP_158            E56
LOOP_162            EA0
LOOP_164            EDE
LOOP_165            EC0
LOOP_17             2D6
LOOP_170            F0A
LOOP_185            1034
LOOP_188            1098
LOOP_190            10D6
LOOP_191            10B8
LOOP_195            1102
LOOP_197            1142
LOOP_198            1124
LOOP_20             2F6
LOOP_203            116E
LOOP_207            11B0
LOOP_209            11F0
LOOP_210            11D2
LOOP_215            121C
LOOP_217            123C
LOOP_219            127C
LOOP_22             348
LOOP_220            125E
LOOP_225            12A8
LOOP_229            1340
LOOP_233            137E
LOOP_245            1556
LOOP_248            1594
LOOP_259            1794
LOOP_262            17FA
LOOP_264            1838
LOOP_265            181A
LOOP_270            18BA
LOOP_272            18FC
LOOP_274            1928
LOOP_277            1952
LOOP_28             3D4
LOOP_289            1B2A
LOOP_292            1B68
LOOP_298            1C20
LOOP_30             460
LOOP_301            1C60
LOOP_303            1C8C
LOOP_305            1CB0
LOOP_307            1CF2
LOOP_308            1CD4
LOOP_312            1D1E
LOOP_314            1D60
LOOP_315            1D42
LOOP_32             48C
LOOP_320            1D8C
LOOP_322            1DE8
LOOP_34             4D4
LOOP_35             4B6
LOOP_45             564
LOOP_5              224
LOOP_52             5DA
LOOP_7              244
LOOP_82             922
LOOP_84             942
LOOP_88             974
LOOP_9              28A
LOOP_94             9EC
LOOP_96             A0C
LOOP_98             A4A
LOOP_99             A2C
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           2059
NULL                0
OX                  2035
P                   FDC
PRINTIT             48C
PRINTIT_RTE         1DE8
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             C5B
PROGRAM_VECTOR      CF2
PROMPT              2032
PROTECT             BF7
R                   4AC
RAM                 200000
RAM_ERROR           1FE3
READ                1F99
READING             2081
READ_16             10E5
READ_32             1312
READ_8              D70
READ_CHAR           6DD
READ_IDE_STATUS     1361
RESET               4
ROM                 0
S                   5FE
SEND_COMMAND        15E3
SEND_READ_COMMAND_AND_WAIT  1612
SET_READ_ADDRESS    1481
SPURIOUS            20CF
SPURIOUS_HANDLER    1DE4
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       2043
START               104
STATUS_REGISTER     2048
TAB                 9
TICK                2065
TICK_HANDLER        1DD4
TO                  2038
UNHANDLED           209A
UNHANDLED_HANDLER   1DC0
UNINITIALISED       20B0
UNINITIALISED_HANDLER  1DCA
UNPROTECT           B30
UNREC               1FBB
USER                100
V                   488
VECS                8
VERSION             20E4
W                   584
WAIT_CHAR           599
WAIT_DRIVE_DRQ      1431
WAIT_DRIVE_NOT_BUSY  13E0
WAIT_DRIVE_READY    138E
WAIT_FOR_COMPLETE_172  F3E
WAIT_FOR_COMPLETE_174  F60
WAIT_FOR_COMPLETE_175  F72
WAIT_FOR_COMPLETE_177  FA2
WAIT_FOR_COMPLETE_178  FB4
WAIT_FOR_COMPLETE_205  118C
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_100  A34
WAIT_FOR_READY_102  A5C
WAIT_FOR_READY_105  A7E
WAIT_FOR_READY_108  AAE
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  ACE
WAIT_FOR_READY_113  AF6
WAIT_FOR_READY_115  B18
WAIT_FOR_READY_118  B3A
WAIT_FOR_READY_120  B62
WAIT_FOR_READY_123  B84
WAIT_FOR_READY_125  C00
WAIT_FOR_READY_128  C24
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_130  C4C
WAIT_FOR_READY_133  C6E
WAIT_FOR_READY_134  CA0
WAIT_FOR_READY_136  CBA
WAIT_FOR_READY_140  D00
WAIT_FOR_READY_143  D70
WAIT_FOR_READY_145  D90
WAIT_FOR_READY_147  DB0
WAIT_FOR_READY_149  DD0
WAIT_FOR_READY_152  DF2
WAIT_FOR_READY_154  E1A
WAIT_FOR_READY_156  E3C
WAIT_FOR_READY_159  E5E
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E86
WAIT_FOR_READY_163  EA8
WAIT_FOR_READY_166  EC8
WAIT_FOR_READY_168  EF0
WAIT_FOR_READY_171  F12
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  FE8
WAIT_FOR_READY_182  1002
WAIT_FOR_READY_186  103C
WAIT_FOR_READY_189  10A0
WAIT_FOR_READY_192  10C0
WAIT_FOR_READY_194  10E8
WAIT_FOR_READY_196  110A
WAIT_FOR_READY_199  112C
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  1154
WAIT_FOR_READY_204  1176
WAIT_FOR_READY_208  11B8
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  11DA
WAIT_FOR_READY_213  1202
WAIT_FOR_READY_216  1224
WAIT_FOR_READY_218  1244
WAIT_FOR_READY_221  1266
WAIT_FOR_READY_223  128E
WAIT_FOR_READY_226  12B0
WAIT_FOR_READY_23   350
WAIT_FOR_READY_24   364
WAIT_FOR_READY_258  177E
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_260  179C
WAIT_FOR_READY_261  17CA
WAIT_FOR_READY_263  1802
WAIT_FOR_READY_266  1822
WAIT_FOR_READY_268  184A
WAIT_FOR_READY_271  18C2
WAIT_FOR_READY_273  1904
WAIT_FOR_READY_275  1930
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_295  1BA6
WAIT_FOR_READY_299  1C28
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_302  1C68
WAIT_FOR_READY_304  1C94
WAIT_FOR_READY_306  1CB8
WAIT_FOR_READY_309  1CDC
WAIT_FOR_READY_31   468
WAIT_FOR_READY_311  1D04
WAIT_FOR_READY_313  1D26
WAIT_FOR_READY_316  1D4A
WAIT_FOR_READY_318  1D72
WAIT_FOR_READY_321  1D94
WAIT_FOR_READY_323  1DF0
WAIT_FOR_READY_33   494
WAIT_FOR_READY_36   4BE
WAIT_FOR_READY_38   4E6
WAIT_FOR_READY_39   4FC
WAIT_FOR_READY_40   512
WAIT_FOR_READY_41   526
WAIT_FOR_READY_42   53A
WAIT_FOR_READY_43   54E
WAIT_FOR_READY_46   56C
WAIT_FOR_READY_47   58E
WAIT_FOR_READY_49   5A8
WAIT_FOR_READY_53   5E2
WAIT_FOR_READY_54   608
WAIT_FOR_READY_55   62E
WAIT_FOR_READY_56   644
WAIT_FOR_READY_58   674
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   6E2
WAIT_FOR_READY_64   72E
WAIT_FOR_READY_67   784
WAIT_FOR_READY_70   7DC
WAIT_FOR_READY_73   83E
WAIT_FOR_READY_76   88A
WAIT_FOR_READY_79   8D6
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_83   92A
WAIT_FOR_READY_85   94A
WAIT_FOR_READY_86   95E
WAIT_FOR_READY_89   97C
WAIT_FOR_READY_91   9A2
WAIT_FOR_READY_95   9F4
WAIT_FOR_READY_97   A14
WAIT_FOR_SRECORD    608
WRITE               1CAC
WRITE_8             F29
WRITING             208A
X                   11AC
Z                   BA2
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6C2
_00000004           994
_00000005           6D0
_00000006           826
_00000007           7C2
_00000008           994
_00000009           91E
_0000000A           994
_0000000B           A96
_0000000C           AA2
_0000000D           C82
_0000000E           F48
_0000000F           F6A
_00000010           F7C
_00000011           FAC
_00000012           FBE
_00000013           1196
_00000014           1698
_00000015           1694
_00000016           189C
_00000017           1756
_00000018           1896
_00000019           1862
_0000001A           17B0
_0000001B           17E4
_0000001C           1862
_0000001D           1892
_0000001E           1874
_0000001F           187E
_00000020           1888
_00000021           1892
_00000022           189C
_00000023           18D6
_00000024           18D6
_00000025           191C
_00000026           18F8
_00000027           191C
_00000028           1C3E
_10000000           66A
_10000001           6AC
_10000002           6D8
_10000003           71A
_10000004           724
_10000005           766
_10000006           77A
_10000007           7BC
_10000008           7C6
_10000009           820
_1000000A           7D2
_1000000B           814
_1000000C           834
_1000000D           876
_1000000E           880
_1000000F           8C2
_10000010           8CC
_10000011           90E
_10000012           998
_10000013           9DA
_10000014           F26
_10000015           F4E
_10000016           1948
_10000017           1C1C
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           58C
_20000005           5D0
_20000006           BB4
_20000007           BC4
_20000008           BDE
_20000009           C84
_2000000A           C9E
_2000000B           CE2
_2000000C           D5A
_2000000D           D5E
_2000000E           F84
_2000000F           FC0
_20000010           FE6
_20000011           102A
_20000012           108A
_20000013           108E
_20000014           15DA
_20000015           1670
_20000016           16A6
_20000017           18DA
_20000018           16B2
_20000019           189E
_2000001A           17C8
_2000001B           17DE
_2000001C           1BC0
_2000001D           1C0E
