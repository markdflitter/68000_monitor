00000400 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 28/04/2021 18:46:57

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000                             9  ; other ideas
00000000                            10  ;------------
00000000                            11  ; use DBLoop?
00000000                            12  ; keep track of highest address hit during srec download
00000000                            13  ; implement backspace
00000000                            14  ; fix being able to enter random chars when W'ing
00000000                            15  ; ram check at startup?  Not sure if this is a good idea!
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  
00000000                            18      ORG  $0
00000000                            19  
00000000  =00000000                 20  DEBUG               EQU 0
00000000                            21  
00000000                            22  ; constants
00000000  =00000000                 23  NULL                EQU 0
00000000  =00000009                 24  TAB                 EQU 9
00000000  =0000000D                 25  CR                  EQU 13
00000000  =0000000A                 26  LF                  EQU 10
00000000                            27  
00000000  =00000000                 28  ROM                 EQU $0
00000000  =00200000                 29  RAM                 EQU $200000
00000000  =002E0000                 30  STACK_ADDRESS       EQU $2E0000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000006                 41  DUART_CTUR_         EQU $6
00000000  =00000007                 42  DUART_CTLR_         EQU $7
00000000  =00000008                 43  DUART_MRB_          EQU $8
00000000  =00000009                 44  DUART_CSRB_         EQU $9
00000000  =00000009                 45  DUART_SRB_          EQU $9
00000000  =0000000A                 46  DUART_CRB_          EQU $A
00000000  =0000000B                 47  DUART_TXB_          EQU $B
00000000  =0000000B                 48  DUART_RXB_          EQU $B
00000000  =0000000C                 49  DUART_IVR_          EQU $C
00000000  =0000000D                 50  DUART_OPCR_         EQU $D
00000000  =0000000E                 51  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 52  DUART_RESET_OPR_    EQU $F
00000000                            53  
00000000  =00C00001                 54  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 55  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 56  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 57  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 58  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 59  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            60  
00000000  =00C00011                 61  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 62  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 63  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 64  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 65  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 66  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            67  
00000000  =00C00009                 68  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 69  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 70  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 71  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 72  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 73  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 74  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 75  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            76  
00000000  =00E00000                 77  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 78  DISPLAY_            EQU $0
00000000  =00E00001                 79  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            80  
00000000                            81  ; macros
00000000                            82  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            83  ; the input register is changed during the process
00000000                            84  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            85  BIN2HEX MACRO
00000000                            86      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            87      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            88      MOVE.B \1,\2
00000000                            89      ANDI.L #$F,\2
00000000                            90      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            94  ; the input register is changed during the process
00000000                            95  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            96  HEX2BIN MACRO
00000000                            97      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            98      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            99      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           100      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           101      ENDM
00000000                           102  
00000000                           103  ; send a single char to the serial port
00000000                           104  ; \1 = char to send, \2 = data register to use for status poll
00000000                           105  ; will stamp on D0 and D1 in debug mode
00000000                           106  PRINT_CHAR MACRO
00000000                           107  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           108      IFEQ DEBUG
00000000                           109          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           110          BTST #2,\2                                  ; check for space to send
00000000                           111          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           112          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           113      ENDC
00000000                           114  
00000000                           115      IFNE DEBUG
00000000                           116          MOVE.B \1,D1
00000000                           117          MOVE.L #6,D0   
00000000                           118          TRAP #15                                    ; write to terminal in simulator
00000000                           119      ENDC
00000000                           120  
00000000                           121      ENDM
00000000                           122  
00000000                           123  ; send CR,LF to the serial port
00000000                           124  ; \1 = data register to use for status poll, /2 = working address register
00000000                           125  PRINT_CRLF MACRO
00000000                           126      LEA CRLF(PC),\2
00000000                           127      PRINT_STR \2,\1
00000000                           128      ENDM
00000000                           129  
00000000                           130  ; send C-style, zero terminated string to the serial port
00000000                           131  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           132  PRINT_STR MACRO
00000000                           133  LOOP\@
00000000                           134      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           135      BEQ EXIT\@
00000000                           136      PRINT_CHAR (\1)+,\2
00000000                           137      BRA LOOP\@
00000000                           138  EXIT\@
00000000                           139      ENDM
00000000                           140    
00000000                           141  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           142  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           143  PRINT_REG MACRO
00000000                           144      LEA ox(PC),\5
00000000                           145      PRINT_STR \5,\2
00000000                           146      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           147  LOOP\@
00000000                           148      BIN2HEX \1,\3,\5
00000000                           149      PRINT_CHAR \3,\2
00000000                           150      DBEQ \4,LOOP\@
00000000                           151      ENDM
00000000                           152  
00000000                           153  ; wait for a char from the serial port
00000000                           154  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           155  ; will stamp on D0 and D1 in debug mode
00000000                           156  WAIT_CHAR MACRO
00000000                           157  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           158      IFEQ DEBUG
00000000                           159          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           160          BTST #0,\2                                  ; check for character
00000000                           161          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           162      ENDC
00000000                           163  
00000000                           164      READ_CHAR \1
00000000                           165  
00000000                           166      IFEQ DEBUG
00000000                           167          PRINT_CHAR \1,\2                            ; echo it back
00000000                           168      ENDC
00000000                           169      ENDM
00000000                           170  
00000000                           171  ; read a char from the serial port - assumes that there is one!
00000000                           172  ; \ 1= data register for read char
00000000                           173  ; will stamp on D0 and D1 in debug mode
00000000                           174  READ_CHAR MACRO
00000000                           175      IFEQ DEBUG
00000000                           176          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           177      ENDC
00000000                           178      IFNE DEBUG
00000000                           179          MOVE.L #5,D0    
00000000                           180          TRAP #15                                    ; read from keyboard in simulator
00000000                           181          MOVE.L D1,\1
00000000                           182      ENDC
00000000                           183  
00000000                           184      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           185      BEQ START
00000000                           186      ENDM
00000000                           187  
00000000                           188  
00000000                           189  ; read data from the download serial port
00000000                           190  ; \ 1= data register for read char
00000000                           191  DOWNLOAD MACRO
00000000                           192  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           193  
00000000                           194      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           195      BTST #0,\1                                      ; check for character
00000000                           196      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           197  
00000000                           198      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           199  CONTINUE\@
00000000                           200      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           201      BTST #0,\1                                      ; check for character
00000000                           202      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           203      
00000000                           204      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           205      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           206  
00000000                           207      ENDM
00000000                           208  
00000000                           209  ; unprotect the EEPROM
00000000                           210  UNPROTECT MACRO
00000000                           211      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           212      NOP
00000000                           213      MOVE.W #$5555,$1554
00000000                           214      NOP
00000000                           215      MOVE.W #$8080,$2AAA
00000000                           216      NOP
00000000                           217      MOVE.W #$AAAA,$2AAA
00000000                           218      NOP
00000000                           219      MOVE.W #$5555,$1554
00000000                           220      NOP
00000000                           221      MOVE.W #$2020,$2AAA
00000000                           222      ENDM
00000000                           223      
00000000                           224  ; protect the EEPROM
00000000                           225  PROTECT MACRO
00000000                           226      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           227      MOVE.W #$5555,$1554
00000000                           228      MOVE.W #$A0A0,$2AAA
00000000                           229      ENDM
00000000                           230  
00000000                           231  
00000000                           232  ; read two hex digits from the download serial port and convert to a byte
00000000                           233  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           234  DOWNLOAD_BYTE MACRO
00000000                           235      MOVE.B #2,\4
00000000                           236      WHILE.B \4 <GT> 0 DO
00000000                           237          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           238          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           239          PRINT_CHAR \2,\3
00000000                           240          HEX2BIN \2,\2,\6
00000000                           241          OR.B \2,\1
00000000                           242          SUB.B #1,\4
00000000                           243      ENDW
00000000                           244  
00000000                           245      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           246      MOVE.B \1,\2
00000000                           247      ADD.L \1,\5
00000000                           248  
00000000                           249      ENDM
00000000                           250  
00000000                           251  ; write word to EEPROM
00000000                           252  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           253  PROGRAM MACRO
00000000                           254    MOVE.W \1,\2                                      ; write the data
00000000                           255  
00000000                           256  WAIT_FOR_COMPLETE\@
00000000                           257          MOVE.W \2,\3
00000000                           258  
00000000                           259          IF.W \3 <NE> \1 THEN
00000000                           260              BRA WAIT_FOR_COMPLETE\@
00000000                           261          ENDI
00000000                           262          ENDM
00000000                           263          
00000000                           264  ; program vector to EEPROM
00000000                           265  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           266  PROGRAM_VECTOR MACRO
00000000                           267      ADD.L #2,\2
00000000                           268      PROGRAM \1, (\2), \3                                ; write it
00000000                           269      LSR.L #8,\1
00000000                           270      LSR.L #8,\1
00000000                           271      SUB.L #2,\2
00000000                           272      PROGRAM \1, (\2), \3
00000000                           273      ENDM
00000000                           274  
00000000                           275  
00000000                           276  ; register catalogue
00000000                           277  ; D0 - used for simulator I/O
00000000                           278  ; D1 - used for simulator I/O
00000000                           279  ; D2 - read character
00000000                           280  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           281  ; D6 - working register used in R/W
00000000                           282  ; D7 - address accumulator, reset by download
00000000                           283  ; A0 - address of string to print 
00000000                           284  
00000000                           285  ; start vector
00000000= 002E0000                 286  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000400                 287  RESET   DC.L START                              ; RESET
00000008= 000018F8                 288  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 000018F8                 289          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001A4C                 290          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 00001A5C                 291          DC.L UNHANDLED_HANDLER
00000018= 00001A5C                 292          DC.L UNHANDLED_HANDLER
0000001C= 00001A5C                 293          DC.L UNHANDLED_HANDLER
00000020= 00001A5C                 294          DC.L UNHANDLED_HANDLER
00000024= 00001A5C                 295          DC.L UNHANDLED_HANDLER
00000028= 00001A5C                 296          DC.L UNHANDLED_HANDLER
0000002C= 00001A5C                 297          DC.L UNHANDLED_HANDLER
00000030= 00001A5C                 298          DC.L UNHANDLED_HANDLER
00000034= 00001A5C                 299          DC.L UNHANDLED_HANDLER
00000038= 00001A5C                 300          DC.L UNHANDLED_HANDLER
0000003C= 00001A5C                 301          DC.L UNHANDLED_HANDLER
00000040= 00001A5C                 302          DC.L UNHANDLED_HANDLER
00000044= 00001A5C                 303          DC.L UNHANDLED_HANDLER
00000048= 00001A5C                 304          DC.L UNHANDLED_HANDLER
0000004C= 00001A5C                 305          DC.L UNHANDLED_HANDLER
00000050= 00001A5C                 306          DC.L UNHANDLED_HANDLER
00000054= 00001A5C                 307          DC.L UNHANDLED_HANDLER
00000058= 00001A5C                 308          DC.L UNHANDLED_HANDLER
0000005C= 00001A5C                 309          DC.L UNHANDLED_HANDLER
00000060= 00001AA0                 310          DC.L SPURIOUS_HANDLER
00000064= 00001A5C                 311          DC.L UNHANDLED_HANDLER
00000068= 00001A5C                 312          DC.L UNHANDLED_HANDLER
0000006C= 00001A5C                 313          DC.L UNHANDLED_HANDLER
00000070= 00001A5C                 314          DC.L UNHANDLED_HANDLER
00000074= 00001A5C                 315          DC.L UNHANDLED_HANDLER
00000078= 00001A5C                 316          DC.L UNHANDLED_HANDLER
0000007C= 00001A5C                 317          DC.L UNHANDLED_HANDLER
00000080= 00001A5C                 318          DC.L UNHANDLED_HANDLER
00000084= 00001A5C                 319          DC.L UNHANDLED_HANDLER
00000088= 00001A5C                 320          DC.L UNHANDLED_HANDLER
0000008C= 00001A5C                 321          DC.L UNHANDLED_HANDLER
00000090= 00001A5C                 322          DC.L UNHANDLED_HANDLER
00000094= 00001A5C                 323          DC.L UNHANDLED_HANDLER
00000098= 00001A5C                 324          DC.L UNHANDLED_HANDLER
0000009C= 00001A5C                 325          DC.L UNHANDLED_HANDLER
000000A0= 00001A5C                 326          DC.L UNHANDLED_HANDLER
000000A4= 00001A5C                 327          DC.L UNHANDLED_HANDLER
000000A8= 00001A5C                 328          DC.L UNHANDLED_HANDLER
000000AC= 00001A5C                 329          DC.L UNHANDLED_HANDLER
000000B0= 00001A5C                 330          DC.L UNHANDLED_HANDLER
000000B4= 00001A5C                 331          DC.L UNHANDLED_HANDLER
000000B8= 00001A5C                 332          DC.L UNHANDLED_HANDLER
000000BC= 00001A5C                 333          DC.L UNHANDLED_HANDLER
000000C0= 00001A5C                 334          DC.L UNHANDLED_HANDLER
000000C4= 00001A5C                 335          DC.L UNHANDLED_HANDLER
000000C8= 00001A5C                 336          DC.L UNHANDLED_HANDLER
000000CC= 00001A5C                 337          DC.L UNHANDLED_HANDLER
000000D0= 00001A5C                 338          DC.L UNHANDLED_HANDLER
000000D4= 00001A5C                 339          DC.L UNHANDLED_HANDLER
000000D8= 00001A5C                 340          DC.L UNHANDLED_HANDLER 
000000DC= 00001A5C                 341          DC.L UNHANDLED_HANDLER
000000E0= 00001A5C                 342          DC.L UNHANDLED_HANDLER
000000E4= 00001A5C                 343          DC.L UNHANDLED_HANDLER 
000000E8= 00001A5C                 344          DC.L UNHANDLED_HANDLER 
000000EC= 00001A5C                 345          DC.L UNHANDLED_HANDLER
000000F0= 00001A5C                 346          DC.L UNHANDLED_HANDLER 
000000F4= 00001A5C                 347          DC.L UNHANDLED_HANDLER 
000000F8= 00001A5C                 348          DC.L UNHANDLED_HANDLER 
000000FC= 00001A5C                 349          DC.L UNHANDLED_HANDLER
00000100= 00001AC2                 350  USER    DC.L TICK_HANDLER
00000104= 00001A5C                 351          DC.L UNHANDLED_HANDLER 
00000108= 00001A5C                 352          DC.L UNHANDLED_HANDLER 
0000010C= 00001A5C                 353          DC.L UNHANDLED_HANDLER 
00000110= 00001A5C                 354          DC.L UNHANDLED_HANDLER 
00000114= 00001A5C                 355          DC.L UNHANDLED_HANDLER 
00000118= 00001A5C                 356          DC.L UNHANDLED_HANDLER 
0000011C= 00001A5C                 357          DC.L UNHANDLED_HANDLER
00000120= 00001A5C                 358          DC.L UNHANDLED_HANDLER
00000124= 00001A5C                 359          DC.L UNHANDLED_HANDLER
00000128= 00001A5C                 360          DC.L UNHANDLED_HANDLER
0000012C= 00001A5C                 361          DC.L UNHANDLED_HANDLER
00000130= 00001A5C                 362          DC.L UNHANDLED_HANDLER
00000134= 00001A5C                 363          DC.L UNHANDLED_HANDLER
00000138= 00001A5C                 364          DC.L UNHANDLED_HANDLER
0000013C= 00001A5C                 365          DC.L UNHANDLED_HANDLER
00000140= 00001A5C                 366          DC.L UNHANDLED_HANDLER
00000144= 00001A5C                 367          DC.L UNHANDLED_HANDLER
00000148= 00001A5C                 368          DC.L UNHANDLED_HANDLER
0000014C= 00001A5C                 369          DC.L UNHANDLED_HANDLER
00000150= 00001A5C                 370          DC.L UNHANDLED_HANDLER
00000154= 00001A5C                 371          DC.L UNHANDLED_HANDLER
00000158= 00001A5C                 372          DC.L UNHANDLED_HANDLER
0000015C= 00001A5C                 373          DC.L UNHANDLED_HANDLER
00000160= 00001A5C                 374          DC.L UNHANDLED_HANDLER
00000164= 00001A5C                 375          DC.L UNHANDLED_HANDLER
00000168= 00001A5C                 376          DC.L UNHANDLED_HANDLER
0000016C= 00001A5C                 377          DC.L UNHANDLED_HANDLER
00000170= 00001A5C                 378          DC.L UNHANDLED_HANDLER
00000174= 00001A5C                 379          DC.L UNHANDLED_HANDLER
00000178= 00001A5C                 380          DC.L UNHANDLED_HANDLER
0000017C= 00001A5C                 381          DC.L UNHANDLED_HANDLER
00000180= 00001A5C                 382          DC.L UNHANDLED_HANDLER
00000184= 00001A5C                 383          DC.L UNHANDLED_HANDLER
00000188= 00001A5C                 384          DC.L UNHANDLED_HANDLER
0000018C= 00001A5C                 385          DC.L UNHANDLED_HANDLER
00000190= 00001A5C                 386          DC.L UNHANDLED_HANDLER
00000194= 00001A5C                 387          DC.L UNHANDLED_HANDLER
00000198= 00001A5C                 388          DC.L UNHANDLED_HANDLER
0000019C= 00001A5C                 389          DC.L UNHANDLED_HANDLER
000001A0= 00001A5C                 390          DC.L UNHANDLED_HANDLER
000001A4= 00001A5C                 391          DC.L UNHANDLED_HANDLER
000001A8= 00001A5C                 392          DC.L UNHANDLED_HANDLER
000001AC= 00001A5C                 393          DC.L UNHANDLED_HANDLER
000001B0= 00001A5C                 394          DC.L UNHANDLED_HANDLER
000001B4= 00001A5C                 395          DC.L UNHANDLED_HANDLER
000001B8= 00001A5C                 396          DC.L UNHANDLED_HANDLER
000001BC= 00001A5C                 397          DC.L UNHANDLED_HANDLER
000001C0= 00001A5C                 398          DC.L UNHANDLED_HANDLER
000001C4= 00001A5C                 399          DC.L UNHANDLED_HANDLER
000001C8= 00001A5C                 400          DC.L UNHANDLED_HANDLER
000001CC= 00001A5C                 401          DC.L UNHANDLED_HANDLER
000001D0= 00001A5C                 402          DC.L UNHANDLED_HANDLER
000001D4= 00001A5C                 403          DC.L UNHANDLED_HANDLER
000001D8= 00001A5C                 404          DC.L UNHANDLED_HANDLER
000001DC= 00001A5C                 405          DC.L UNHANDLED_HANDLER
000001E0= 00001A5C                 406          DC.L UNHANDLED_HANDLER
000001E4= 00001A5C                 407          DC.L UNHANDLED_HANDLER
000001E8= 00001A5C                 408          DC.L UNHANDLED_HANDLER
000001EC= 00001A5C                 409          DC.L UNHANDLED_HANDLER
000001F0= 00001A5C                 410          DC.L UNHANDLED_HANDLER
000001F4= 00001A5C                 411          DC.L UNHANDLED_HANDLER
000001F8= 00001A5C                 412          DC.L UNHANDLED_HANDLER
000001FC= 00001A5C                 413          DC.L UNHANDLED_HANDLER
00000200= 00001A5C                 414          DC.L UNHANDLED_HANDLER
00000204= 00001A5C                 415          DC.L UNHANDLED_HANDLER
00000208= 00001A5C                 416          DC.L UNHANDLED_HANDLER
0000020C= 00001A5C                 417          DC.L UNHANDLED_HANDLER
00000210= 00001A5C                 418          DC.L UNHANDLED_HANDLER
00000214= 00001A5C                 419          DC.L UNHANDLED_HANDLER
00000218= 00001A5C                 420          DC.L UNHANDLED_HANDLER
0000021C= 00001A5C                 421          DC.L UNHANDLED_HANDLER
00000220= 00001A5C                 422          DC.L UNHANDLED_HANDLER
00000224= 00001A5C                 423          DC.L UNHANDLED_HANDLER
00000228= 00001A5C                 424          DC.L UNHANDLED_HANDLER
0000022C= 00001A5C                 425          DC.L UNHANDLED_HANDLER
00000230= 00001A5C                 426          DC.L UNHANDLED_HANDLER
00000234= 00001A5C                 427          DC.L UNHANDLED_HANDLER
00000238= 00001A5C                 428          DC.L UNHANDLED_HANDLER
0000023C= 00001A5C                 429          DC.L UNHANDLED_HANDLER
00000240= 00001A5C                 430          DC.L UNHANDLED_HANDLER
00000244= 00001A5C                 431          DC.L UNHANDLED_HANDLER
00000248= 00001A5C                 432          DC.L UNHANDLED_HANDLER
0000024C= 00001A5C                 433          DC.L UNHANDLED_HANDLER
00000250= 00001A5C                 434          DC.L UNHANDLED_HANDLER
00000254= 00001A5C                 435          DC.L UNHANDLED_HANDLER
00000258= 00001A5C                 436          DC.L UNHANDLED_HANDLER
0000025C= 00001A5C                 437          DC.L UNHANDLED_HANDLER
00000260= 00001A5C                 438          DC.L UNHANDLED_HANDLER
00000264= 00001A5C                 439          DC.L UNHANDLED_HANDLER
00000268= 00001A5C                 440          DC.L UNHANDLED_HANDLER
0000026C= 00001A5C                 441          DC.L UNHANDLED_HANDLER
00000270= 00001A5C                 442          DC.L UNHANDLED_HANDLER
00000274= 00001A5C                 443          DC.L UNHANDLED_HANDLER
00000278= 00001A5C                 444          DC.L UNHANDLED_HANDLER
0000027C= 00001A5C                 445          DC.L UNHANDLED_HANDLER
00000280= 00001A5C                 446          DC.L UNHANDLED_HANDLER
00000284= 00001A5C                 447          DC.L UNHANDLED_HANDLER
00000288= 00001A5C                 448          DC.L UNHANDLED_HANDLER
0000028C= 00001A5C                 449          DC.L UNHANDLED_HANDLER
00000290= 00001A5C                 450          DC.L UNHANDLED_HANDLER
00000294= 00001A5C                 451          DC.L UNHANDLED_HANDLER
00000298= 00001A5C                 452          DC.L UNHANDLED_HANDLER
0000029C= 00001A5C                 453          DC.L UNHANDLED_HANDLER
000002A0= 00001A5C                 454          DC.L UNHANDLED_HANDLER
000002A4= 00001A5C                 455          DC.L UNHANDLED_HANDLER
000002A8= 00001A5C                 456          DC.L UNHANDLED_HANDLER
000002AC= 00001A5C                 457          DC.L UNHANDLED_HANDLER
000002B0= 00001A5C                 458          DC.L UNHANDLED_HANDLER
000002B4= 00001A5C                 459          DC.L UNHANDLED_HANDLER
000002B8= 00001A5C                 460          DC.L UNHANDLED_HANDLER
000002BC= 00001A5C                 461          DC.L UNHANDLED_HANDLER
000002C0= 00001A5C                 462          DC.L UNHANDLED_HANDLER
000002C4= 00001A5C                 463          DC.L UNHANDLED_HANDLER
000002C8= 00001A5C                 464          DC.L UNHANDLED_HANDLER
000002CC= 00001A5C                 465          DC.L UNHANDLED_HANDLER
000002D0= 00001A5C                 466          DC.L UNHANDLED_HANDLER
000002D4= 00001A5C                 467          DC.L UNHANDLED_HANDLER
000002D8= 00001A5C                 468          DC.L UNHANDLED_HANDLER
000002DC= 00001A5C                 469          DC.L UNHANDLED_HANDLER
000002E0= 00001A5C                 470          DC.L UNHANDLED_HANDLER
000002E4= 00001A5C                 471          DC.L UNHANDLED_HANDLER
000002E8= 00001A5C                 472          DC.L UNHANDLED_HANDLER
000002EC= 00001A5C                 473          DC.L UNHANDLED_HANDLER
000002F0= 00001A5C                 474          DC.L UNHANDLED_HANDLER
000002F4= 00001A5C                 475          DC.L UNHANDLED_HANDLER
000002F8= 00001A5C                 476          DC.L UNHANDLED_HANDLER
000002FC= 00001A5C                 477          DC.L UNHANDLED_HANDLER
00000300= 00001A5C                 478          DC.L UNHANDLED_HANDLER
00000304= 00001A5C                 479          DC.L UNHANDLED_HANDLER
00000308= 00001A5C                 480          DC.L UNHANDLED_HANDLER
0000030C= 00001A5C                 481          DC.L UNHANDLED_HANDLER
00000310= 00001A5C                 482          DC.L UNHANDLED_HANDLER
00000314= 00001A5C                 483          DC.L UNHANDLED_HANDLER
00000318= 00001A5C                 484          DC.L UNHANDLED_HANDLER
0000031C= 00001A5C                 485          DC.L UNHANDLED_HANDLER
00000320= 00001A5C                 486          DC.L UNHANDLED_HANDLER
00000324= 00001A5C                 487          DC.L UNHANDLED_HANDLER
00000328= 00001A5C                 488          DC.L UNHANDLED_HANDLER
0000032C= 00001A5C                 489          DC.L UNHANDLED_HANDLER
00000330= 00001A5C                 490          DC.L UNHANDLED_HANDLER
00000334= 00001A5C                 491          DC.L UNHANDLED_HANDLER
00000338= 00001A5C                 492          DC.L UNHANDLED_HANDLER
0000033C= 00001A5C                 493          DC.L UNHANDLED_HANDLER
00000340= 00001A5C                 494          DC.L UNHANDLED_HANDLER
00000344= 00001A5C                 495          DC.L UNHANDLED_HANDLER
00000348= 00001A5C                 496          DC.L UNHANDLED_HANDLER
0000034C= 00001A5C                 497          DC.L UNHANDLED_HANDLER
00000350= 00001A5C                 498          DC.L UNHANDLED_HANDLER
00000354= 00001A5C                 499          DC.L UNHANDLED_HANDLER
00000358= 00001A5C                 500          DC.L UNHANDLED_HANDLER
0000035C= 00001A5C                 501          DC.L UNHANDLED_HANDLER
00000360= 00001A5C                 502          DC.L UNHANDLED_HANDLER
00000364= 00001A5C                 503          DC.L UNHANDLED_HANDLER
00000368= 00001A5C                 504          DC.L UNHANDLED_HANDLER
0000036C= 00001A5C                 505          DC.L UNHANDLED_HANDLER
00000370= 00001A5C                 506          DC.L UNHANDLED_HANDLER
00000374= 00001A5C                 507          DC.L UNHANDLED_HANDLER
00000378= 00001A5C                 508          DC.L UNHANDLED_HANDLER
0000037C= 00001A5C                 509          DC.L UNHANDLED_HANDLER
00000380= 00001A5C                 510          DC.L UNHANDLED_HANDLER
00000384= 00001A5C                 511          DC.L UNHANDLED_HANDLER
00000388= 00001A5C                 512          DC.L UNHANDLED_HANDLER
0000038C= 00001A5C                 513          DC.L UNHANDLED_HANDLER
00000390= 00001A5C                 514          DC.L UNHANDLED_HANDLER
00000394= 00001A5C                 515          DC.L UNHANDLED_HANDLER
00000398= 00001A5C                 516          DC.L UNHANDLED_HANDLER
0000039C= 00001A5C                 517          DC.L UNHANDLED_HANDLER
000003A0= 00001A5C                 518          DC.L UNHANDLED_HANDLER
000003A4= 00001A5C                 519          DC.L UNHANDLED_HANDLER
000003A8= 00001A5C                 520          DC.L UNHANDLED_HANDLER
000003AC= 00001A5C                 521          DC.L UNHANDLED_HANDLER
000003B0= 00001A5C                 522          DC.L UNHANDLED_HANDLER
000003B4= 00001A5C                 523          DC.L UNHANDLED_HANDLER
000003B8= 00001A5C                 524          DC.L UNHANDLED_HANDLER
000003BC= 00001A5C                 525          DC.L UNHANDLED_HANDLER
000003C0= 00001A5C                 526          DC.L UNHANDLED_HANDLER
000003C4= 00001A5C                 527          DC.L UNHANDLED_HANDLER
000003C8= 00001A5C                 528          DC.L UNHANDLED_HANDLER
000003CC= 00001A5C                 529          DC.L UNHANDLED_HANDLER
000003D0= 00001A5C                 530          DC.L UNHANDLED_HANDLER
000003D4= 00001A5C                 531          DC.L UNHANDLED_HANDLER
000003D8= 00001A5C                 532          DC.L UNHANDLED_HANDLER
000003DC= 00001A5C                 533          DC.L UNHANDLED_HANDLER
000003E0= 00001A5C                 534          DC.L UNHANDLED_HANDLER
000003E4= 00001A5C                 535          DC.L UNHANDLED_HANDLER
000003E8= 00001A5C                 536          DC.L UNHANDLED_HANDLER
000003EC= 00001A5C                 537          DC.L UNHANDLED_HANDLER
000003F0= 00001A5C                 538          DC.L UNHANDLED_HANDLER
000003F4= 00001A5C                 539          DC.L UNHANDLED_HANDLER
000003F8= 00001A5C                 540          DC.L UNHANDLED_HANDLER
000003FC= 00001A5C                 541          DC.L UNHANDLED_HANDLER
00000400                           542  ; start of program  
00000400                           543  START
00000400  2E7C 002E0000            544      MOVE.L #STACK_ADDRESS,A7
00000406  13FC 0000 00E00001       545      MOVE.B #0,DISPLAY
0000040E                           546  
0000040E  7000                     547      MOVE.L #0,D0
00000410  1039 00C00019            548      MOVE.B DUART_IVR,D0                             ; warm start?
00000416                           549  
00000416                           550  ; reset the UART in case of warm start
00000416  13FC 000A 00C00005       551      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
0000041E  13FC 000A 00C00015       552      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000426                           553      
00000426                           554      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000426  323C 0050                555s     MOVE.W  #$50,D1
0000042A  6000 000E                556s     BRA _20000001
0000042E                           557s _20000000
0000042E  13C1 00C00005            558          MOVE.B D1,DUART_CRA                         ; reset everyting
00000434  4E71                     559          NOP
00000436                           560      ENDF
00000436  0441 0010                561s     SUB.W   #$10,D1
0000043A                           562s _20000001
0000043A  B27C 0010                563s     CMP.W   #$10,D1
0000043E  6CEE                     564s     BGE _20000000
00000440                           565  
00000440                           566      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000440  323C 0050                567s     MOVE.W  #$50,D1
00000444  6000 000E                568s     BRA _20000003
00000448                           569s _20000002
00000448  13C1 00C00015            570          MOVE.B D1,DUART_CRB                         ; reset everyting
0000044E  4E71                     571          NOP
00000450                           572      ENDF
00000450  0441 0010                573s     SUB.W   #$10,D1
00000454                           574s _20000003
00000454  B27C 0010                575s     CMP.W   #$10,D1
00000458  6CEE                     576s     BGE _20000002
0000045A                           577      
0000045A                           578  ;initialise UART
0000045A                           579  ;   MOVE.B #$0,DUART_IMR                            ; no interrupts, please
0000045A  13FC 00FF 00C0000D       580      MOVE.B #$FF,DUART_CTUR
00000462  13FC 00FF 00C0000F       581      MOVE.B #$FF,DUART_CTLR
0000046A  13FC 0070 00C00009       582      MOVE.B #$70,DUART_ACR
00000472  13FC 0004 00C0001B       583      MOVE.B #$4,DUART_OPCR                           ; enable counter
0000047A                           584  
0000047A                           585  ; channel A
0000047A  13FC 0013 00C00001       586      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000482  13FC 0007 00C00001       587      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000048A  13FC 0066 00C00003       588      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
00000492  13FC 0005 00C00005       589      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000049A                           590  
0000049A                           591  ; channel B
0000049A  13FC 0013 00C00011       592      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000004A2  13FC 0007 00C00011       593      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000004AA  13FC 0066 00C00013       594      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000004B2  13FC 0005 00C00015       595      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000004BA  13FC 0040 00C00019       596      MOVE.B #64,DUART_IVR
000004C2  13FC 0008 00C0000B       597      MOVE.B #8,DUART_IMR
000004CA                           598  
000004CA                           599m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000004CA                           600m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CA                 TRUE      601m     IFEQ DEBUG
000004CA  1239 00C00003            602m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004D0  0801 0002                603m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004D4  67F4                     604m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000004D6  13FC 0000 00C00007       605m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004DE                           606m     ENDC
000004DE                           607m 
000004DE                 FALSE     608m     IFNE DEBUG
000004DE                           609m     ENDC
000004DE                           610m 
000004DE                           611m     ENDM
000004DE                           612m     PRINT_CHAR #0,D1
000004DE                           613m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DE                 TRUE      614m     IFEQ DEBUG
000004DE  1239 00C00003            615m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004E4  0801 0002                616m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004E8  67F4                     617m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000004EA  13FC 0000 00C00007       618m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F2                           619m     ENDC
000004F2                           620m 
000004F2                 FALSE     621m     IFNE DEBUG
000004F2                           622m     ENDC
000004F2                           623m 
000004F2                           624m     ENDM
000004F2                           625m     PRINT_CHAR #0,D1
000004F2                           626m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F2                 TRUE      627m     IFEQ DEBUG
000004F2  1239 00C00003            628m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004F8  0801 0002                629m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004FC  67F4                     630m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000004FE  13FC 0000 00C00007       631m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000506                           632m     ENDC
00000506                           633m 
00000506                 FALSE     634m     IFNE DEBUG
00000506                           635m     ENDC
00000506                           636m 
00000506                           637m     ENDM
00000506                           638      
00000506                           639      IF D0 <EQ> #$0F THEN
00000506  B07C 000F                640s     CMP.W   #$0F,D0
0000050A  6600 002C                641s     BNE _00000000
0000050E  1039 00C00005            642          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000514                           643  
00000514  41FA 18BF                644          LEA COLD_START(PC),A0
00000518                           645m         PRINT_STR A0,D0
00000518                           646m LOOP_4
00000518  0C10 0000                647m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000051C  6700 0016                648m     BEQ EXIT_4
00000520                           649mm     PRINT_CHAR (A0)+,D0
00000520                           650mm WAIT_FOR_READY_5                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000520                 TRUE      651mm     IFEQ DEBUG
00000520  1039 00C00003            652mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00000526  0800 0002                653mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000052A  67F4                     654mm         BEQ WAIT_FOR_READY_5                        ; NO SPACE, CHECK AGAIN
0000052C  13D8 00C00007            655mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000532                           656mm     ENDC
00000532                           657mm 
00000532                 FALSE     658mm     IFNE DEBUG
00000532                           659mm     ENDC
00000532                           660mm 
00000532                           661mm     ENDM
00000532  60E4                     662m     BRA LOOP_4
00000534                           663m EXIT_4
00000534                           664m     ENDM
00000534                           665      ELSE
00000534  6000 0022                666s     BRA _00000001
00000538                           667s _00000000
00000538  41FA 18AF                668          LEA WARM_START(PC),A0
0000053C                           669m         PRINT_STR A0,D0
0000053C                           670m LOOP_6
0000053C  0C10 0000                671m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000540  6700 0016                672m     BEQ EXIT_6
00000544                           673mm     PRINT_CHAR (A0)+,D0
00000544                           674mm WAIT_FOR_READY_7                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000544                 TRUE      675mm     IFEQ DEBUG
00000544  1039 00C00003            676mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000054A  0800 0002                677mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000054E  67F4                     678mm         BEQ WAIT_FOR_READY_7                        ; NO SPACE, CHECK AGAIN
00000550  13D8 00C00007            679mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000556                           680mm     ENDC
00000556                           681mm 
00000556                 FALSE     682mm     IFNE DEBUG
00000556                           683mm     ENDC
00000556                           684mm 
00000556                           685mm     ENDM
00000556  60E4                     686m     BRA LOOP_6
00000558                           687m EXIT_6
00000558                           688m     ENDM
00000558                           689      ENDI
00000558                           690s _00000001
00000558                           691  
00000558  13FC 0001 00E00001       692      MOVE.B #1,DISPLAY
00000560                           693      
00000560                           694m     PRINT_CRLF D1,A0
00000560  41FA 17DB                695m     LEA CRLF(PC),A0
00000564                           696mm     PRINT_STR A0,D1
00000564                           697mm LOOP_9
00000564  0C10 0000                698mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016                699mm     BEQ EXIT_9
0000056C                           700mmm     PRINT_CHAR (A0)+,D1
0000056C                           701mmm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE      702mmm     IFEQ DEBUG
0000056C  1239 00C00003            703mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000572  0801 0002                704mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                     705mmm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007            706mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                           707mmm     ENDC
0000057E                           708mmm 
0000057E                 FALSE     709mmm     IFNE DEBUG
0000057E                           710mmm     ENDC
0000057E                           711mmm 
0000057E                           712mmm     ENDM
0000057E  60E4                     713mm     BRA LOOP_9
00000580                           714mm EXIT_9
00000580                           715mm     ENDM
00000580                           716m     ENDM
00000580  41FA 187B                717      LEA VERSION(PC),A0
00000584                           718m     PRINT_STR A0,D3
00000584                           719m LOOP_11
00000584  0C10 0000                720m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000588  6700 0016                721m     BEQ EXIT_11
0000058C                           722mm     PRINT_CHAR (A0)+,D3
0000058C                           723mm WAIT_FOR_READY_12                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058C                 TRUE      724mm     IFEQ DEBUG
0000058C  1639 00C00003            725mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000592  0803 0002                726mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000596  67F4                     727mm         BEQ WAIT_FOR_READY_12                       ; NO SPACE, CHECK AGAIN
00000598  13D8 00C00007            728mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000059E                           729mm     ENDC
0000059E                           730mm 
0000059E                 FALSE     731mm     IFNE DEBUG
0000059E                           732mm     ENDC
0000059E                           733mm 
0000059E                           734mm     ENDM
0000059E  60E4                     735m     BRA LOOP_11
000005A0                           736m EXIT_11
000005A0                           737m     ENDM
000005A0                           738  
000005A0  41F9 00001E1B            739      LEA END,A0
000005A6  2008                     740      MOVE.L A0,D0
000005A8                           741m     PRINT_REG D0,D1,D2,D3,A0
000005A8  41FA 1799                742m     LEA OX(PC),A0
000005AC                           743mm     PRINT_STR A0,D1
000005AC                           744mm LOOP_14
000005AC  0C10 0000                745mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005B0  6700 0016                746mm     BEQ EXIT_14
000005B4                           747mmm     PRINT_CHAR (A0)+,D1
000005B4                           748mmm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B4                 TRUE      749mmm     IFEQ DEBUG
000005B4  1239 00C00003            750mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000005BA  0801 0002                751mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000005BE  67F4                     752mmm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
000005C0  13D8 00C00007            753mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005C6                           754mmm     ENDC
000005C6                           755mmm 
000005C6                 FALSE     756mmm     IFNE DEBUG
000005C6                           757mmm     ENDC
000005C6                           758mmm 
000005C6                           759mmm     ENDM
000005C6  60E4                     760mm     BRA LOOP_14
000005C8                           761mm EXIT_14
000005C8                           762mm     ENDM
000005C8  7607                     763m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000005CA                           764m LOOP_13
000005CA                           765mm     BIN2HEX D0,D2,A0
000005CA  41FA 16F3                766mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005CE  E998                     767mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000005D0  1400                     768mm     MOVE.B D0,D2
000005D2  0282 0000000F            769mm     ANDI.L #$F,D2
000005D8  1430 2000                770mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000005DC                           771mm     ENDM
000005DC                           772mm     PRINT_CHAR D2,D1
000005DC                           773mm WAIT_FOR_READY_17                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005DC                 TRUE      774mm     IFEQ DEBUG
000005DC  1239 00C00003            775mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000005E2  0801 0002                776mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000005E6  67F4                     777mm         BEQ WAIT_FOR_READY_17                       ; NO SPACE, CHECK AGAIN
000005E8  13C2 00C00007            778mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005EE                           779mm     ENDC
000005EE                           780mm 
000005EE                 FALSE     781mm     IFNE DEBUG
000005EE                           782mm     ENDC
000005EE                           783mm 
000005EE                           784mm     ENDM
000005EE  57CB FFDA                785m     DBEQ D3,LOOP_13
000005F2                           786m     ENDM
000005F2                           787m     PRINT_CRLF D1,A0
000005F2  41FA 1749                788m     LEA CRLF(PC),A0
000005F6                           789mm     PRINT_STR A0,D1
000005F6                           790mm LOOP_19
000005F6  0C10 0000                791mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005FA  6700 0016                792mm     BEQ EXIT_19
000005FE                           793mmm     PRINT_CHAR (A0)+,D1
000005FE                           794mmm WAIT_FOR_READY_20                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005FE                 TRUE      795mmm     IFEQ DEBUG
000005FE  1239 00C00003            796mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000604  0801 0002                797mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000608  67F4                     798mmm         BEQ WAIT_FOR_READY_20                       ; NO SPACE, CHECK AGAIN
0000060A  13D8 00C00007            799mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000610                           800mmm     ENDC
00000610                           801mmm 
00000610                 FALSE     802mmm     IFNE DEBUG
00000610                           803mmm     ENDC
00000610                           804mmm 
00000610                           805mmm     ENDM
00000610  60E4                     806mm     BRA LOOP_19
00000612                           807mm EXIT_19
00000612                           808mm     ENDM
00000612                           809m     ENDM
00000612                           810  
00000612  41FA 14D6                811      LEA HELPPROMPT(PC),A0
00000616                           812m     PRINT_STR A0,D3
00000616                           813m LOOP_21
00000616  0C10 0000                814m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000061A  6700 0016                815m     BEQ EXIT_21
0000061E                           816mm     PRINT_CHAR (A0)+,D3
0000061E                           817mm WAIT_FOR_READY_22                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000061E                 TRUE      818mm     IFEQ DEBUG
0000061E  1639 00C00003            819mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000624  0803 0002                820mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000628  67F4                     821mm         BEQ WAIT_FOR_READY_22                       ; NO SPACE, CHECK AGAIN
0000062A  13D8 00C00007            822mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000630                           823mm     ENDC
00000630                           824mm 
00000630                 FALSE     825mm     IFNE DEBUG
00000630                           826mm     ENDC
00000630                           827mm 
00000630                           828mm     ENDM
00000630  60E4                     829m     BRA LOOP_21
00000632                           830m EXIT_21
00000632                           831m     ENDM
00000632                           832  
00000632                           833m     PRINT_CRLF D3,A0
00000632  41FA 1709                834m     LEA CRLF(PC),A0
00000636                           835mm     PRINT_STR A0,D3
00000636                           836mm LOOP_24
00000636  0C10 0000                837mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000063A  6700 0016                838mm     BEQ EXIT_24
0000063E                           839mmm     PRINT_CHAR (A0)+,D3
0000063E                           840mmm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063E                 TRUE      841mmm     IFEQ DEBUG
0000063E  1639 00C00003            842mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000644  0803 0002                843mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000648  67F4                     844mmm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
0000064A  13D8 00C00007            845mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000650                           846mmm     ENDC
00000650                           847mmm 
00000650                 FALSE     848mmm     IFNE DEBUG
00000650                           849mmm     ENDC
00000650                           850mmm 
00000650                           851mmm     ENDM
00000650  60E4                     852mm     BRA LOOP_24
00000652                           853mm EXIT_24
00000652                           854mm     ENDM
00000652                           855m     ENDM
00000652                           856  
00000652  7E00                     857      MOVE.L #0,D7                                    ; address accumulator
00000654                           858  
00000654  13FC 0002 00E00001       859      MOVE.B #2,DISPLAY
0000065C                           860      
0000065C                           861  MAIN_LOOP
0000065C  41FA 16E2                862      LEA PROMPT(PC),A0
00000660                           863m     PRINT_STR A0,D3
00000660                           864m LOOP_26
00000660  0C10 0000                865m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000664  6700 0016                866m     BEQ EXIT_26
00000668                           867mm     PRINT_CHAR (A0)+,D3
00000668                           868mm WAIT_FOR_READY_27                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000668                 TRUE      869mm     IFEQ DEBUG
00000668  1639 00C00003            870mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000066E  0803 0002                871mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000672  67F4                     872mm         BEQ WAIT_FOR_READY_27                       ; NO SPACE, CHECK AGAIN
00000674  13D8 00C00007            873mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000067A                           874mm     ENDC
0000067A                           875mm 
0000067A                 FALSE     876mm     IFNE DEBUG
0000067A                           877mm     ENDC
0000067A                           878mm 
0000067A                           879mm     ENDM
0000067A  60E4                     880m     BRA LOOP_26
0000067C                           881m EXIT_26
0000067C                           882m     ENDM
0000067C                           883  
0000067C                           884  GET_INPUT
0000067C                           885m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000067C                           886m WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000067C                 TRUE      887m     IFEQ DEBUG
0000067C  1639 00C00003            888m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000682  0803 0000                889m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000686  67F4                     890m         BEQ WAIT_FOR_READY_28                       ; NOTHING, CHECK AGAIN
00000688                           891m     ENDC
00000688                           892m 
00000688                           893mm     READ_CHAR D2
00000688                 TRUE      894mm     IFEQ DEBUG
00000688  1439 00C00007            895mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000068E                           896mm     ENDC
0000068E                 FALSE     897mm     IFNE DEBUG
0000068E                           898mm     ENDC
0000068E                           899mm 
0000068E  B43C 001B                900mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000692  6700 FD6C                901mm     BEQ START
00000696                           902mm     ENDM
00000696                           903m 
00000696                 TRUE      904m     IFEQ DEBUG
00000696                           905mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000696                           906mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000696                 TRUE      907mm     IFEQ DEBUG
00000696  1639 00C00003            908mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000069C  0803 0002                909mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000006A0  67F4                     910mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000006A2  13C2 00C00007            911mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006A8                           912mm     ENDC
000006A8                           913mm 
000006A8                 FALSE     914mm     IFNE DEBUG
000006A8                           915mm     ENDC
000006A8                           916mm 
000006A8                           917mm     ENDM
000006A8                           918m     ENDC
000006A8                           919m     ENDM
000006A8                           920  
000006A8                           921      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000006A8  B43C 0030                922s     CMP.B   #'0',D2
000006AC  6D00 000E                923s     BLT _00000002
000006B0  B43C 0039                924s     CMP.B   #'9',D2
000006B4  6E00 0006                925s     BGT _00000002
000006B8  6000 1220                926          BRA HEX_DIGIT
000006BC                           927      ENDI
000006BC                           928s _00000002
000006BC                           929      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000006BC  B43C 0041                930s     CMP.B   #'A',D2
000006C0  6D00 000E                931s     BLT _00000003
000006C4  B43C 0046                932s     CMP.B   #'F',D2
000006C8  6E00 0006                933s     BGT _00000003
000006CC  6000 120C                934          BRA HEX_DIGIT
000006D0                           935      ENDI
000006D0                           936s _00000003
000006D0                           937  
000006D0  B43C 0077                938      CMP.B #'w',D2
000006D4  6700 01B2                939      BEQ W
000006D8                           940  
000006D8  B43C 006C                941      CMP.B #'l',D2
000006DC  6700 0A48                942      BEQ L 
000006E0                           943  
000006E0  B43C 0070                944      CMP.B #'p',D2
000006E4  6700 0E4A                945      BEQ P
000006E8                           946  
000006E8  B43C 006D                947      CMP.B #'m',D2
000006EC  6700 1012                948      BEQ M
000006F0                           949  
000006F0                           950m     PRINT_CRLF D3,A0
000006F0  41FA 164B                951m     LEA CRLF(PC),A0
000006F4                           952mm     PRINT_STR A0,D3
000006F4                           953mm LOOP_32
000006F4  0C10 0000                954mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000006F8  6700 0016                955mm     BEQ EXIT_32
000006FC                           956mmm     PRINT_CHAR (A0)+,D3
000006FC                           957mmm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006FC                 TRUE      958mmm     IFEQ DEBUG
000006FC  1639 00C00003            959mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000702  0803 0002                960mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000706  67F4                     961mmm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000708  13D8 00C00007            962mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000070E                           963mmm     ENDC
0000070E                           964mmm 
0000070E                 FALSE     965mmm     IFNE DEBUG
0000070E                           966mmm     ENDC
0000070E                           967mmm 
0000070E                           968mmm     ENDM
0000070E  60E4                     969mm     BRA LOOP_32
00000710                           970mm EXIT_32
00000710                           971mm     ENDM
00000710                           972m     ENDM
00000710                           973   
00000710  B43C 003F                974      CMP.B #'?',D2
00000714  6700 006E                975      BEQ H
00000718                           976   
00000718  B43C 0076                977      CMP.B #'v',D2
0000071C  6700 006E                978      BEQ V
00000720                           979      
00000720  B43C 0072                980      CMP.B #'r',D2
00000724  6700 008A                981      BEQ R
00000728                           982  
00000728  B43C 0073                983      CMP.B #'s',D2
0000072C  6700 01D6                984      BEQ S
00000730                           985  
00000730  B43C 0067                986      CMP.B #'g',D2
00000734  6700 08FA                987      BEQ G   
00000738                           988  
00000738  B43C 007A                989      CMP.B #'z',D2
0000073C  6700 08F8                990      BEQ Z   
00000740                           991  
00000740  B43C 0078                992      CMP.B #'x',D2
00000744  6700 1052                993      BEQ X
00000748                           994  
00000748  B43C 0069                995      CMP.B #'i',D2
0000074C  6700 1166                996      BEQ I
00000750                           997  
00000750  B43C 006F                998      CMP.B #'o',D2
00000754  6700 1166                999      BEQ O
00000758                          1000  
00000758  B43C 0023               1001      CMP.B #'#',D2
0000075C  6700 1166               1002      BEQ HASH
00000760                          1003  
00000760  41FA 14FB               1004      LEA HUH(PC),A0
00000764                          1005m     PRINT_STR A0,D3
00000764                          1006m LOOP_34
00000764  0C10 0000               1007m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000768  6700 0016               1008m     BEQ EXIT_34
0000076C                          1009mm     PRINT_CHAR (A0)+,D3
0000076C                          1010mm WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076C                 TRUE     1011mm     IFEQ DEBUG
0000076C  1639 00C00003           1012mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000772  0803 0002               1013mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000776  67F4                    1014mm         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
00000778  13D8 00C00007           1015mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000077E                          1016mm     ENDC
0000077E                          1017mm 
0000077E                 FALSE    1018mm     IFNE DEBUG
0000077E                          1019mm     ENDC
0000077E                          1020mm 
0000077E                          1021mm     ENDM
0000077E  60E4                    1022m     BRA LOOP_34
00000780                          1023m EXIT_34
00000780                          1024m     ENDM
00000780                          1025  
00000780  6000 FEDA               1026      BRA MAIN_LOOP
00000784                          1027  
00000784                          1028  ; commands
00000784                          1029  H
00000784  41FA 1377               1030      LEA HELP(PC),A0
00000788  6000 0006               1031      BRA PRINTSTR
0000078C                          1032  
0000078C                          1033  V
0000078C  41FA 166F               1034      LEA VERSION(PC),A0
00000790                          1035  PRINTSTR
00000790                          1036m     PRINT_STR A0,D3    
00000790                          1037m LOOP_36
00000790  0C10 0000               1038m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000794  6700 0016               1039m     BEQ EXIT_36
00000798                          1040mm     PRINT_CHAR (A0)+,D3
00000798                          1041mm WAIT_FOR_READY_37                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                 TRUE     1042mm     IFEQ DEBUG
00000798  1639 00C00003           1043mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000079E  0803 0002               1044mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007A2  67F4                    1045mm         BEQ WAIT_FOR_READY_37                       ; NO SPACE, CHECK AGAIN
000007A4  13D8 00C00007           1046mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007AA                          1047mm     ENDC
000007AA                          1048mm 
000007AA                 FALSE    1049mm     IFNE DEBUG
000007AA                          1050mm     ENDC
000007AA                          1051mm 
000007AA                          1052mm     ENDM
000007AA  60E4                    1053m     BRA LOOP_36
000007AC                          1054m EXIT_36
000007AC                          1055m     ENDM
000007AC  6000 FEAE               1056      BRA MAIN_LOOP
000007B0                          1057  
000007B0                          1058  R
000007B0  2047                    1059      MOVE.L D7,A0                                    ; address accumulator -> address register
000007B2  7E00                    1060      MOVE.L #0,D7                                    ;clear the now used address accumulator
000007B4  2410                    1061      MOVE.L (A0),D2                                  ; read the memory and print it
000007B6                          1062m     PRINT_REG D2,D3,D4,D5,A0
000007B6  41FA 158B               1063m     LEA OX(PC),A0
000007BA                          1064mm     PRINT_STR A0,D3
000007BA                          1065mm LOOP_39
000007BA  0C10 0000               1066mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000007BE  6700 0016               1067mm     BEQ EXIT_39
000007C2                          1068mmm     PRINT_CHAR (A0)+,D3
000007C2                          1069mmm WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C2                 TRUE     1070mmm     IFEQ DEBUG
000007C2  1639 00C00003           1071mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007C8  0803 0002               1072mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007CC  67F4                    1073mmm         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000007CE  13D8 00C00007           1074mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007D4                          1075mmm     ENDC
000007D4                          1076mmm 
000007D4                 FALSE    1077mmm     IFNE DEBUG
000007D4                          1078mmm     ENDC
000007D4                          1079mmm 
000007D4                          1080mmm     ENDM
000007D4  60E4                    1081mm     BRA LOOP_39
000007D6                          1082mm EXIT_39
000007D6                          1083mm     ENDM
000007D6  7A07                    1084m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000007D8                          1085m LOOP_38
000007D8                          1086mm     BIN2HEX D2,D4,A0
000007D8  41FA 14E5               1087mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000007DC  E99A                    1088mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000007DE  1802                    1089mm     MOVE.B D2,D4
000007E0  0284 0000000F           1090mm     ANDI.L #$F,D4
000007E6  1830 4000               1091mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000007EA                          1092mm     ENDM
000007EA                          1093mm     PRINT_CHAR D4,D3
000007EA                          1094mm WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007EA                 TRUE     1095mm     IFEQ DEBUG
000007EA  1639 00C00003           1096mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007F0  0803 0002               1097mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007F4  67F4                    1098mm         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000007F6  13C4 00C00007           1099mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007FC                          1100mm     ENDC
000007FC                          1101mm 
000007FC                 FALSE    1102mm     IFNE DEBUG
000007FC                          1103mm     ENDC
000007FC                          1104mm 
000007FC                          1105mm     ENDM
000007FC  57CD FFDA               1106m     DBEQ D5,LOOP_38
00000800                          1107m     ENDM
00000800                          1108      
00000800                          1109m     PRINT_CHAR #32,D3
00000800                          1110m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000800                 TRUE     1111m     IFEQ DEBUG
00000800  1639 00C00003           1112m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000806  0803 0002               1113m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000080A  67F4                    1114m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000080C  13FC 0020 00C00007      1115m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000814                          1116m     ENDC
00000814                          1117m 
00000814                 FALSE    1118m     IFNE DEBUG
00000814                          1119m     ENDC
00000814                          1120m 
00000814                          1121m     ENDM
00000814                          1122  
00000814  E19A                    1123      ROL.L #8,D2
00000816                          1124m     PRINT_CHAR D2,D3
00000816                          1125m WAIT_FOR_READY_44                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000816                 TRUE     1126m     IFEQ DEBUG
00000816  1639 00C00003           1127m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000081C  0803 0002               1128m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000820  67F4                    1129m         BEQ WAIT_FOR_READY_44                       ; NO SPACE, CHECK AGAIN
00000822  13C2 00C00007           1130m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000828                          1131m     ENDC
00000828                          1132m 
00000828                 FALSE    1133m     IFNE DEBUG
00000828                          1134m     ENDC
00000828                          1135m 
00000828                          1136m     ENDM
00000828  E19A                    1137      ROL.L #8,D2
0000082A                          1138m     PRINT_CHAR D2,D3
0000082A                          1139m WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082A                 TRUE     1140m     IFEQ DEBUG
0000082A  1639 00C00003           1141m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000830  0803 0002               1142m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000834  67F4                    1143m         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
00000836  13C2 00C00007           1144m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000083C                          1145m     ENDC
0000083C                          1146m 
0000083C                 FALSE    1147m     IFNE DEBUG
0000083C                          1148m     ENDC
0000083C                          1149m 
0000083C                          1150m     ENDM
0000083C  E19A                    1151      ROL.L #8,D2
0000083E                          1152m     PRINT_CHAR D2,D3
0000083E                          1153m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083E                 TRUE     1154m     IFEQ DEBUG
0000083E  1639 00C00003           1155m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000844  0803 0002               1156m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000848  67F4                    1157m         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
0000084A  13C2 00C00007           1158m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000850                          1159m     ENDC
00000850                          1160m 
00000850                 FALSE    1161m     IFNE DEBUG
00000850                          1162m     ENDC
00000850                          1163m 
00000850                          1164m     ENDM
00000850  E19A                    1165      ROL.L #8,D2
00000852                          1166m     PRINT_CHAR D2,D3
00000852                          1167m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000852                 TRUE     1168m     IFEQ DEBUG
00000852  1639 00C00003           1169m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000858  0803 0002               1170m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000085C  67F4                    1171m         BEQ WAIT_FOR_READY_47                       ; NO SPACE, CHECK AGAIN
0000085E  13C2 00C00007           1172m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000864                          1173m     ENDC
00000864                          1174m 
00000864                 FALSE    1175m     IFNE DEBUG
00000864                          1176m     ENDC
00000864                          1177m 
00000864                          1178m     ENDM
00000864                          1179  
00000864                          1180m     PRINT_CRLF D3,A0
00000864  41FA 14D7               1181m     LEA CRLF(PC),A0
00000868                          1182mm     PRINT_STR A0,D3
00000868                          1183mm LOOP_49
00000868  0C10 0000               1184mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000086C  6700 0016               1185mm     BEQ EXIT_49
00000870                          1186mmm     PRINT_CHAR (A0)+,D3
00000870                          1187mmm WAIT_FOR_READY_50                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1188mmm     IFEQ DEBUG
00000870  1639 00C00003           1189mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000876  0803 0002               1190mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1191mmm         BEQ WAIT_FOR_READY_50                       ; NO SPACE, CHECK AGAIN
0000087C  13D8 00C00007           1192mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000882                          1193mmm     ENDC
00000882                          1194mmm 
00000882                 FALSE    1195mmm     IFNE DEBUG
00000882                          1196mmm     ENDC
00000882                          1197mmm 
00000882                          1198mmm     ENDM
00000882  60E4                    1199mm     BRA LOOP_49
00000884                          1200mm EXIT_49
00000884                          1201mm     ENDM
00000884                          1202m     ENDM
00000884                          1203      
00000884  6000 FDD6               1204      BRA MAIN_LOOP
00000888                          1205  
00000888                          1206  W
00000888                          1207      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000888  3C3C 0000               1208s     MOVE.W  #0,D6
0000088C  6000 0046               1209s     BRA _20000005
00000890                          1210s _20000004
00000890  E98D                    1211          LSL.L #4,D5                                     ; make what we have so far more significant
00000892                          1212m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000892                          1213m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000892                 TRUE     1214m     IFEQ DEBUG
00000892  1639 00C00003           1215m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000898  0803 0000               1216m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000089C  67F4                    1217m         BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
0000089E                          1218m     ENDC
0000089E                          1219m 
0000089E                          1220mm     READ_CHAR D2
0000089E                 TRUE     1221mm     IFEQ DEBUG
0000089E  1439 00C00007           1222mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000008A4                          1223mm     ENDC
000008A4                 FALSE    1224mm     IFNE DEBUG
000008A4                          1225mm     ENDC
000008A4                          1226mm 
000008A4  B43C 001B               1227mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000008A8  6700 FB56               1228mm     BEQ START
000008AC                          1229mm     ENDM
000008AC                          1230m 
000008AC                 TRUE     1231m     IFEQ DEBUG
000008AC                          1232mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000008AC                          1233mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AC                 TRUE     1234mm     IFEQ DEBUG
000008AC  1639 00C00003           1235mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000008B2  0803 0002               1236mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000008B6  67F4                    1237mm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000008B8  13C2 00C00007           1238mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008BE                          1239mm     ENDC
000008BE                          1240mm 
000008BE                 FALSE    1241mm     IFNE DEBUG
000008BE                          1242mm     ENDC
000008BE                          1243mm 
000008BE                          1244mm     ENDM
000008BE                          1245m     ENDC
000008BE                          1246m     ENDM
000008BE                          1247m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000008BE  41FA 140F               1248m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000008C2  0402 0030               1249m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008C6  C4BC 000000FF           1250m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000008CC  1430 2000               1251m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000008D0                          1252m     ENDM
000008D0  8A02                    1253          OR.B D2,D5
000008D2                          1254      ENDF
000008D2  5246                    1255s     ADD.W   #1,D6
000008D4                          1256s _20000005
000008D4  BC7C 0007               1257s     CMP.W   #7,D6
000008D8  6FB6                    1258s     BLE _20000004
000008DA                          1259  
000008DA                          1260m     PRINT_CRLF D3,A0
000008DA  41FA 1461               1261m     LEA CRLF(PC),A0
000008DE                          1262mm     PRINT_STR A0,D3
000008DE                          1263mm LOOP_56
000008DE  0C10 0000               1264mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000008E2  6700 0016               1265mm     BEQ EXIT_56
000008E6                          1266mmm     PRINT_CHAR (A0)+,D3
000008E6                          1267mmm WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                 TRUE     1268mmm     IFEQ DEBUG
000008E6  1639 00C00003           1269mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000008EC  0803 0002               1270mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000008F0  67F4                    1271mmm         BEQ WAIT_FOR_READY_57                       ; NO SPACE, CHECK AGAIN
000008F2  13D8 00C00007           1272mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008F8                          1273mmm     ENDC
000008F8                          1274mmm 
000008F8                 FALSE    1275mmm     IFNE DEBUG
000008F8                          1276mmm     ENDC
000008F8                          1277mmm 
000008F8                          1278mmm     ENDM
000008F8  60E4                    1279mm     BRA LOOP_56
000008FA                          1280mm EXIT_56
000008FA                          1281mm     ENDM
000008FA                          1282m     ENDM
000008FA                          1283  
000008FA  2047                    1284      MOVE.L D7,A0                                    ; address accumulator -> address register
000008FC  7E00                    1285      MOVE.L #0,D7                                    ; clear the now used address accumulator
000008FE                          1286  
000008FE  2085                    1287      MOVE.L D5,(A0)                                  ; write the data
00000900                          1288  
00000900  6000 FD5A               1289      BRA MAIN_LOOP
00000904                          1290  
00000904                          1291  ; register map for S
00000904                          1292  ; A0 - start address
00000904                          1293  ; A1 - offset
00000904                          1294  ; A2 - next address to write
00000904                          1295  ; A3 - next location (jmp)
00000904                          1296  ; A4 - Working Address Register
00000904                          1297  ; D0 - record count
00000904                          1298  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000904                          1299  ; D2 - checksum
00000904                          1300  ; D3 - data byte count
00000904                          1301  ; D4 - read address, moved into A2
00000904                          1302  ; D5 - temp
00000904                          1303  ; D6 - temp
00000904                          1304  ; D7 - temp
00000904                          1305  S
00000904  2078 0000               1306      MOVE.L 0,A0                                     ; start address -> A0
00000908  2247                    1307      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000090A                          1308      
0000090A  7000                    1309      MOVE.L #0,D0                                    ; count of records read -> D0
0000090C                          1310          
0000090C                          1311  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000090C                          1312m     DOWNLOAD D1
0000090C                          1313m WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090C                          1314m 
0000090C  1239 00C00003           1315m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000912  0801 0000               1316m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000916  6700 0010               1317m     BEQ CONTINUE_58                                 ; NOTHING, CONTINUE
0000091A                          1318m 
0000091A                          1319mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000091A                 TRUE     1320mm     IFEQ DEBUG
0000091A  1239 00C00007           1321mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000920                          1322mm     ENDC
00000920                 FALSE    1323mm     IFNE DEBUG
00000920                          1324mm     ENDC
00000920                          1325mm 
00000920  B23C 001B               1326mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000924  6700 FADA               1327mm     BEQ START
00000928                          1328mm     ENDM
00000928                          1329m CONTINUE_58
00000928  1239 00C00013           1330m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000092E  0801 0000               1331m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000932  67D8                    1332m     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000934                          1333m     
00000934  1239 00C00017           1334m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000093A  13C1 00E00001           1335m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000940                          1336m 
00000940                          1337m     ENDM
00000940  B23C 0053               1338      CMP.B #'S',D1                                   ; found S?
00000944  66C6                    1339      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000946                          1340      
00000946                          1341m     PRINT_CHAR #'S',D5                              ; print the S
00000946                          1342m WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000946                 TRUE     1343m     IFEQ DEBUG
00000946  1A39 00C00003           1344m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000094C  0805 0002               1345m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000950  67F4                    1346m         BEQ WAIT_FOR_READY_60                       ; NO SPACE, CHECK AGAIN
00000952  13FC 0053 00C00007      1347m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000095A                          1348m     ENDC
0000095A                          1349m 
0000095A                 FALSE    1350m     IFNE DEBUG
0000095A                          1351m     ENDC
0000095A                          1352m 
0000095A                          1353m     ENDM
0000095A  5280                    1354      ADD.L #1,D0                                     ; read another S record, increment count
0000095C                          1355      
0000095C                          1356m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000095C                          1357m WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                          1358m 
0000095C  1239 00C00003           1359m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000962  0801 0000               1360m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000966  6700 0010               1361m     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000096A                          1362m 
0000096A                          1363mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000096A                 TRUE     1364mm     IFEQ DEBUG
0000096A  1239 00C00007           1365mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000970                          1366mm     ENDC
00000970                 FALSE    1367mm     IFNE DEBUG
00000970                          1368mm     ENDC
00000970                          1369mm 
00000970  B23C 001B               1370mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000974  6700 FA8A               1371mm     BEQ START
00000978                          1372mm     ENDM
00000978                          1373m CONTINUE_61
00000978  1239 00C00013           1374m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000097E  0801 0000               1375m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000982  67D8                    1376m     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000984                          1377m     
00000984  1239 00C00017           1378m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000098A  13C1 00E00001           1379m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000990                          1380m 
00000990                          1381m     ENDM
00000990                          1382m     PRINT_CHAR D1,D5
00000990                          1383m WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000990                 TRUE     1384m     IFEQ DEBUG
00000990  1A39 00C00003           1385m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000996  0805 0002               1386m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000099A  67F4                    1387m         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
0000099C  13C1 00C00007           1388m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009A2                          1389m     ENDC
000009A2                          1390m 
000009A2                 FALSE    1391m     IFNE DEBUG
000009A2                          1392m     ENDC
000009A2                          1393m 
000009A2                          1394m     ENDM
000009A2                          1395  
000009A2  7400                    1396      MOVE.L #0,D2                                    ; clear the checksum
000009A4                          1397  
000009A4                          1398m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
000009A4  1E3C 0002               1399m     MOVE.B #2,D7
000009A8                          1400m     WHILE.B D7 <GT> 0 DO
000009A8                          1401ms _10000000
000009A8  BE38 0000               1402ms     CMP.B   0,D7
000009AC  6F00 0062               1403ms     BLE _10000001
000009B0  E98B                    1404m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B2                          1405mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B2                          1406mm WAIT_FOR_READY_65                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B2                          1407mm 
000009B2  1A39 00C00003           1408mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009B8  0805 0000               1409mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009BC  6700 0010               1410mm     BEQ CONTINUE_65                                 ; NOTHING, CONTINUE
000009C0                          1411mm 
000009C0                          1412mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C0                 TRUE     1413mmm     IFEQ DEBUG
000009C0  1A39 00C00007           1414mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C6                          1415mmm     ENDC
000009C6                 FALSE    1416mmm     IFNE DEBUG
000009C6                          1417mmm     ENDC
000009C6                          1418mmm 
000009C6  BA3C 001B               1419mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CA  6700 FA34               1420mmm     BEQ START
000009CE                          1421mmm     ENDM
000009CE                          1422mm CONTINUE_65
000009CE  1A39 00C00013           1423mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D4  0805 0000               1424mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009D8  67D8                    1425mm     BEQ WAIT_FOR_READY_65                           ; NOTHING, CHECK AGAIN
000009DA                          1426mm     
000009DA  1A39 00C00017           1427mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E0  13C5 00E00001           1428mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E6                          1429mm 
000009E6                          1430mm     ENDM
000009E6                          1431mm         PRINT_CHAR D5,D6
000009E6                          1432mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1433mm     IFEQ DEBUG
000009E6  1C39 00C00003           1434mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009EC  0806 0002               1435mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1436mm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000009F2  13C5 00C00007           1437mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009F8                          1438mm     ENDC
000009F8                          1439mm 
000009F8                 FALSE    1440mm     IFNE DEBUG
000009F8                          1441mm     ENDC
000009F8                          1442mm 
000009F8                          1443mm     ENDM
000009F8                          1444mm         HEX2BIN D5,D5,A4
000009F8  49FA 12D5               1445mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009FC  0405 0030               1446mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A00  CABC 000000FF           1447mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A06  1A34 5000               1448mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0A                          1449mm     ENDM
00000A0A  8605                    1450m         OR.B D5,D3
00000A0C  5307                    1451m         SUB.B #1,D7
00000A0E                          1452m     ENDW
00000A0E  6098                    1453ms     BRA _10000000
00000A10                          1454ms _10000001
00000A10                          1455m 
00000A10  7A00                    1456m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A12  1A03                    1457m     MOVE.B D3,D5
00000A14  D483                    1458m     ADD.L D3,D2
00000A16                          1459m 
00000A16                          1460m     ENDM
00000A16                          1461  
00000A16                          1462      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000A16  B23C 0030               1463s     CMP.B   #'0',D1
00000A1A  6600 002A               1464s     BNE.L   _00000004
00000A1E                          1465m         PRINT_CRLF D5,A4
00000A1E  49FA 131D               1466m     LEA CRLF(PC),A4
00000A22                          1467mm     PRINT_STR A4,D5
00000A22                          1468mm LOOP_70
00000A22  0C14 0000               1469mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A26  6700 0016               1470mm     BEQ EXIT_70
00000A2A                          1471mmm     PRINT_CHAR (A4)+,D5
00000A2A                          1472mmm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2A                 TRUE     1473mmm     IFEQ DEBUG
00000A2A  1A39 00C00003           1474mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A30  0805 0002               1475mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A34  67F4                    1476mmm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
00000A36  13DC 00C00007           1477mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A3C                          1478mmm     ENDC
00000A3C                          1479mmm 
00000A3C                 FALSE    1480mmm     IFNE DEBUG
00000A3C                          1481mmm     ENDC
00000A3C                          1482mmm 
00000A3C                          1483mmm     ENDM
00000A3C  60E4                    1484mm     BRA LOOP_70
00000A3E                          1485mm EXIT_70
00000A3E                          1486mm     ENDM
00000A3E                          1487m     ENDM
00000A3E  6000 FECC               1488          BRA WAIT_FOR_SRECORD
00000A42                          1489      ELSE
00000A42  6000 03DE               1490s     BRA _00000005
00000A46                          1491s _00000004
00000A46                          1492          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
00000A46  B23C 0031               1493s     CMP.B   #'1',D1
00000A4A  6708                    1494s     BEQ.S   _00000006
00000A4C  B23C 0032               1495s     CMP.B   #'2',D1
00000A50  6600 01F0               1496s     BNE.L   _00000007
00000A54                          1497s _00000006
00000A54  5783                    1498              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000A56                          1499  
00000A56  7800                    1500              MOVE.L #0,D4                            ; read two bytes of address
00000A58                          1501m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000A58  1E3C 0002               1502m     MOVE.B #2,D7
00000A5C                          1503m     WHILE.B D7 <GT> 0 DO
00000A5C                          1504ms _10000002
00000A5C  BE38 0000               1505ms     CMP.B   0,D7
00000A60  6F00 0062               1506ms     BLE _10000003
00000A64  E98C                    1507m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A66                          1508mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A66                          1509mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                          1510mm 
00000A66  1A39 00C00003           1511mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A6C  0805 0000               1512mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A70  6700 0010               1513mm     BEQ CONTINUE_73                                 ; NOTHING, CONTINUE
00000A74                          1514mm 
00000A74                          1515mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A74                 TRUE     1516mmm     IFEQ DEBUG
00000A74  1A39 00C00007           1517mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A7A                          1518mmm     ENDC
00000A7A                 FALSE    1519mmm     IFNE DEBUG
00000A7A                          1520mmm     ENDC
00000A7A                          1521mmm 
00000A7A  BA3C 001B               1522mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A7E  6700 F980               1523mmm     BEQ START
00000A82                          1524mmm     ENDM
00000A82                          1525mm CONTINUE_73
00000A82  1A39 00C00013           1526mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A88  0805 0000               1527mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A8C  67D8                    1528mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
00000A8E                          1529mm     
00000A8E  1A39 00C00017           1530mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A94  13C5 00E00001           1531mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A9A                          1532mm 
00000A9A                          1533mm     ENDM
00000A9A                          1534mm         PRINT_CHAR D5,D6
00000A9A                          1535mm WAIT_FOR_READY_75                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9A                 TRUE     1536mm     IFEQ DEBUG
00000A9A  1C39 00C00003           1537mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000AA0  0806 0002               1538mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000AA4  67F4                    1539mm         BEQ WAIT_FOR_READY_75                       ; NO SPACE, CHECK AGAIN
00000AA6  13C5 00C00007           1540mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AAC                          1541mm     ENDC
00000AAC                          1542mm 
00000AAC                 FALSE    1543mm     IFNE DEBUG
00000AAC                          1544mm     ENDC
00000AAC                          1545mm 
00000AAC                          1546mm     ENDM
00000AAC                          1547mm         HEX2BIN D5,D5,A4
00000AAC  49FA 1221               1548mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000AB0  0405 0030               1549mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AB4  CABC 000000FF           1550mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000ABA  1A34 5000               1551mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000ABE                          1552mm     ENDM
00000ABE  8805                    1553m         OR.B D5,D4
00000AC0  5307                    1554m         SUB.B #1,D7
00000AC2                          1555m     ENDW
00000AC2  6098                    1556ms     BRA _10000002
00000AC4                          1557ms _10000003
00000AC4                          1558m 
00000AC4  7A00                    1559m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AC6  1A04                    1560m     MOVE.B D4,D5
00000AC8  D484                    1561m     ADD.L D4,D2
00000ACA                          1562m 
00000ACA                          1563m     ENDM
00000ACA                          1564m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000ACA  1E3C 0002               1565m     MOVE.B #2,D7
00000ACE                          1566m     WHILE.B D7 <GT> 0 DO
00000ACE                          1567ms _10000004
00000ACE  BE38 0000               1568ms     CMP.B   0,D7
00000AD2  6F00 0062               1569ms     BLE _10000005
00000AD6  E98C                    1570m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000AD8                          1571mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000AD8                          1572mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                          1573mm 
00000AD8  1A39 00C00003           1574mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000ADE  0805 0000               1575mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AE2  6700 0010               1576mm     BEQ CONTINUE_78                                 ; NOTHING, CONTINUE
00000AE6                          1577mm 
00000AE6                          1578mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AE6                 TRUE     1579mmm     IFEQ DEBUG
00000AE6  1A39 00C00007           1580mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000AEC                          1581mmm     ENDC
00000AEC                 FALSE    1582mmm     IFNE DEBUG
00000AEC                          1583mmm     ENDC
00000AEC                          1584mmm 
00000AEC  BA3C 001B               1585mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000AF0  6700 F90E               1586mmm     BEQ START
00000AF4                          1587mmm     ENDM
00000AF4                          1588mm CONTINUE_78
00000AF4  1A39 00C00013           1589mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000AFA  0805 0000               1590mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AFE  67D8                    1591mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
00000B00                          1592mm     
00000B00  1A39 00C00017           1593mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B06  13C5 00E00001           1594mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B0C                          1595mm 
00000B0C                          1596mm     ENDM
00000B0C                          1597mm         PRINT_CHAR D5,D6
00000B0C                          1598mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0C                 TRUE     1599mm     IFEQ DEBUG
00000B0C  1C39 00C00003           1600mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B12  0806 0002               1601mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B16  67F4                    1602mm         BEQ WAIT_FOR_READY_80                       ; NO SPACE, CHECK AGAIN
00000B18  13C5 00C00007           1603mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B1E                          1604mm     ENDC
00000B1E                          1605mm 
00000B1E                 FALSE    1606mm     IFNE DEBUG
00000B1E                          1607mm     ENDC
00000B1E                          1608mm 
00000B1E                          1609mm     ENDM
00000B1E                          1610mm         HEX2BIN D5,D5,A4
00000B1E  49FA 11AF               1611mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B22  0405 0030               1612mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B26  CABC 000000FF           1613mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B2C  1A34 5000               1614mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B30                          1615mm     ENDM
00000B30  8805                    1616m         OR.B D5,D4
00000B32  5307                    1617m         SUB.B #1,D7
00000B34                          1618m     ENDW
00000B34  6098                    1619ms     BRA _10000004
00000B36                          1620ms _10000005
00000B36                          1621m 
00000B36  7A00                    1622m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B38  1A04                    1623m     MOVE.B D4,D5
00000B3A  D484                    1624m     ADD.L D4,D2
00000B3C                          1625m 
00000B3C                          1626m     ENDM
00000B3C                          1627  
00000B3C                          1628              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000B3C  B23C 0032               1629s     CMP.B   #'2',D1
00000B40  6600 0076               1630s     BNE.L   _00000008
00000B44  5383                    1631                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000B46                          1632m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000B46  1E3C 0002               1633m     MOVE.B #2,D7
00000B4A                          1634m     WHILE.B D7 <GT> 0 DO
00000B4A                          1635ms _10000006
00000B4A  BE38 0000               1636ms     CMP.B   0,D7
00000B4E  6F00 0062               1637ms     BLE _10000007
00000B52  E98C                    1638m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B54                          1639mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B54                          1640mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B54                          1641mm 
00000B54  1A39 00C00003           1642mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B5A  0805 0000               1643mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B5E  6700 0010               1644mm     BEQ CONTINUE_83                                 ; NOTHING, CONTINUE
00000B62                          1645mm 
00000B62                          1646mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B62                 TRUE     1647mmm     IFEQ DEBUG
00000B62  1A39 00C00007           1648mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B68                          1649mmm     ENDC
00000B68                 FALSE    1650mmm     IFNE DEBUG
00000B68                          1651mmm     ENDC
00000B68                          1652mmm 
00000B68  BA3C 001B               1653mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B6C  6700 F892               1654mmm     BEQ START
00000B70                          1655mmm     ENDM
00000B70                          1656mm CONTINUE_83
00000B70  1A39 00C00013           1657mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B76  0805 0000               1658mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B7A  67D8                    1659mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
00000B7C                          1660mm     
00000B7C  1A39 00C00017           1661mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B82  13C5 00E00001           1662mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B88                          1663mm 
00000B88                          1664mm     ENDM
00000B88                          1665mm         PRINT_CHAR D5,D6
00000B88                          1666mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     1667mm     IFEQ DEBUG
00000B88  1C39 00C00003           1668mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B8E  0806 0002               1669mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    1670mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000B94  13C5 00C00007           1671mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B9A                          1672mm     ENDC
00000B9A                          1673mm 
00000B9A                 FALSE    1674mm     IFNE DEBUG
00000B9A                          1675mm     ENDC
00000B9A                          1676mm 
00000B9A                          1677mm     ENDM
00000B9A                          1678mm         HEX2BIN D5,D5,A4
00000B9A  49FA 1133               1679mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B9E  0405 0030               1680mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BA2  CABC 000000FF           1681mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000BA8  1A34 5000               1682mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BAC                          1683mm     ENDM
00000BAC  8805                    1684m         OR.B D5,D4
00000BAE  5307                    1685m         SUB.B #1,D7
00000BB0                          1686m     ENDW
00000BB0  6098                    1687ms     BRA _10000006
00000BB2                          1688ms _10000007
00000BB2                          1689m 
00000BB2  7A00                    1690m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000BB4  1A04                    1691m     MOVE.B D4,D5
00000BB6  D484                    1692m     ADD.L D4,D2
00000BB8                          1693m 
00000BB8                          1694m     ENDM
00000BB8                          1695              ENDI
00000BB8                          1696s _00000008
00000BB8                          1697  
00000BB8  2444                    1698              MOVE.L D4,A2                            ; put the address in an address register
00000BBA  D5C9                    1699              ADD.L A1,A2                             ; add in the offset
00000BBC                          1700  
00000BBC                          1701              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000BBC                          1702s _10000008
00000BBC  B63C 0000               1703s     CMP.B   #0,D3
00000BC0  6F00 007A               1704s     BLE _10000009
00000BC4                          1705m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000BC4  1E3C 0002               1706m     MOVE.B #2,D7
00000BC8                          1707m     WHILE.B D7 <GT> 0 DO
00000BC8                          1708ms _1000000A
00000BC8  BE38 0000               1709ms     CMP.B   0,D7
00000BCC  6F00 0062               1710ms     BLE _1000000B
00000BD0  E989                    1711m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000BD2                          1712mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000BD2                          1713mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                          1714mm 
00000BD2  1A39 00C00003           1715mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000BD8  0805 0000               1716mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BDC  6700 0010               1717mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
00000BE0                          1718mm 
00000BE0                          1719mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000BE0                 TRUE     1720mmm     IFEQ DEBUG
00000BE0  1A39 00C00007           1721mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000BE6                          1722mmm     ENDC
00000BE6                 FALSE    1723mmm     IFNE DEBUG
00000BE6                          1724mmm     ENDC
00000BE6                          1725mmm 
00000BE6  BA3C 001B               1726mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000BEA  6700 F814               1727mmm     BEQ START
00000BEE                          1728mmm     ENDM
00000BEE                          1729mm CONTINUE_88
00000BEE  1A39 00C00013           1730mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000BF4  0805 0000               1731mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BF8  67D8                    1732mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
00000BFA                          1733mm     
00000BFA  1A39 00C00017           1734mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C00  13C5 00E00001           1735mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C06                          1736mm 
00000C06                          1737mm     ENDM
00000C06                          1738mm         PRINT_CHAR D5,D6
00000C06                          1739mm WAIT_FOR_READY_90                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C06                 TRUE     1740mm     IFEQ DEBUG
00000C06  1C39 00C00003           1741mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C0C  0806 0002               1742mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C10  67F4                    1743mm         BEQ WAIT_FOR_READY_90                       ; NO SPACE, CHECK AGAIN
00000C12  13C5 00C00007           1744mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C18                          1745mm     ENDC
00000C18                          1746mm 
00000C18                 FALSE    1747mm     IFNE DEBUG
00000C18                          1748mm     ENDC
00000C18                          1749mm 
00000C18                          1750mm     ENDM
00000C18                          1751mm         HEX2BIN D5,D5,A4
00000C18  49FA 10B5               1752mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000C1C  0405 0030               1753mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C20  CABC 000000FF           1754mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000C26  1A34 5000               1755mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C2A                          1756mm     ENDM
00000C2A  8205                    1757m         OR.B D5,D1
00000C2C  5307                    1758m         SUB.B #1,D7
00000C2E                          1759m     ENDW
00000C2E  6098                    1760ms     BRA _1000000A
00000C30                          1761ms _1000000B
00000C30                          1762m 
00000C30  7A00                    1763m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000C32  1A01                    1764m     MOVE.B D1,D5
00000C34  D481                    1765m     ADD.L D1,D2
00000C36                          1766m 
00000C36                          1767m     ENDM
00000C36                          1768   
00000C36  14C1                    1769                  MOVE.B D1,(A2)+                     ; store it!
00000C38                          1770  
00000C38  5303                    1771                  SUB.B #1,D3                         ; 1 less byte to go
00000C3A                          1772              ENDW
00000C3A  6080                    1773s     BRA _10000008
00000C3C                          1774s _10000009
00000C3C                          1775  
00000C3C  7200                    1776              MOVE.L #0,D1                            ; not done yet
00000C3E                          1777          ELSE
00000C3E  6000 01E2               1778s     BRA _00000009
00000C42                          1779s _00000007
00000C42                          1780              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000C42  B23C 0038               1781s     CMP.B   #'8',D1
00000C46  6600 0164               1782s     BNE.L   _0000000A
00000C4A  7800                    1783                  MOVE.L #0,D4                        ; read the 24 bit start address
00000C4C                          1784m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000C4C  1E3C 0002               1785m     MOVE.B #2,D7
00000C50                          1786m     WHILE.B D7 <GT> 0 DO
00000C50                          1787ms _1000000C
00000C50  BE38 0000               1788ms     CMP.B   0,D7
00000C54  6F00 0062               1789ms     BLE _1000000D
00000C58  E98C                    1790m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000C5A                          1791mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000C5A                          1792mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C5A                          1793mm 
00000C5A  1A39 00C00003           1794mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000C60  0805 0000               1795mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C64  6700 0010               1796mm     BEQ CONTINUE_93                                 ; NOTHING, CONTINUE
00000C68                          1797mm 
00000C68                          1798mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000C68                 TRUE     1799mmm     IFEQ DEBUG
00000C68  1A39 00C00007           1800mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000C6E                          1801mmm     ENDC
00000C6E                 FALSE    1802mmm     IFNE DEBUG
00000C6E                          1803mmm     ENDC
00000C6E                          1804mmm 
00000C6E  BA3C 001B               1805mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000C72  6700 F78C               1806mmm     BEQ START
00000C76                          1807mmm     ENDM
00000C76                          1808mm CONTINUE_93
00000C76  1A39 00C00013           1809mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000C7C  0805 0000               1810mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C80  67D8                    1811mm     BEQ WAIT_FOR_READY_93                           ; NOTHING, CHECK AGAIN
00000C82                          1812mm     
00000C82  1A39 00C00017           1813mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C88  13C5 00E00001           1814mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C8E                          1815mm 
00000C8E                          1816mm     ENDM
00000C8E                          1817mm         PRINT_CHAR D5,D6
00000C8E                          1818mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     1819mm     IFEQ DEBUG
00000C8E  1C39 00C00003           1820mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C94  0806 0002               1821mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    1822mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000C9A  13C5 00C00007           1823mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CA0                          1824mm     ENDC
00000CA0                          1825mm 
00000CA0                 FALSE    1826mm     IFNE DEBUG
00000CA0                          1827mm     ENDC
00000CA0                          1828mm 
00000CA0                          1829mm     ENDM
00000CA0                          1830mm         HEX2BIN D5,D5,A4
00000CA0  49FA 102D               1831mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000CA4  0405 0030               1832mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CA8  CABC 000000FF           1833mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000CAE  1A34 5000               1834mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CB2                          1835mm     ENDM
00000CB2  8805                    1836m         OR.B D5,D4
00000CB4  5307                    1837m         SUB.B #1,D7
00000CB6                          1838m     ENDW
00000CB6  6098                    1839ms     BRA _1000000C
00000CB8                          1840ms _1000000D
00000CB8                          1841m 
00000CB8  7A00                    1842m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000CBA  1A04                    1843m     MOVE.B D4,D5
00000CBC  D484                    1844m     ADD.L D4,D2
00000CBE                          1845m 
00000CBE                          1846m     ENDM
00000CBE                          1847m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000CBE  1E3C 0002               1848m     MOVE.B #2,D7
00000CC2                          1849m     WHILE.B D7 <GT> 0 DO
00000CC2                          1850ms _1000000E
00000CC2  BE38 0000               1851ms     CMP.B   0,D7
00000CC6  6F00 0062               1852ms     BLE _1000000F
00000CCA  E98C                    1853m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000CCC                          1854mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000CCC                          1855mm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                          1856mm 
00000CCC  1A39 00C00003           1857mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000CD2  0805 0000               1858mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CD6  6700 0010               1859mm     BEQ CONTINUE_98                                 ; NOTHING, CONTINUE
00000CDA                          1860mm 
00000CDA                          1861mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000CDA                 TRUE     1862mmm     IFEQ DEBUG
00000CDA  1A39 00C00007           1863mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000CE0                          1864mmm     ENDC
00000CE0                 FALSE    1865mmm     IFNE DEBUG
00000CE0                          1866mmm     ENDC
00000CE0                          1867mmm 
00000CE0  BA3C 001B               1868mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000CE4  6700 F71A               1869mmm     BEQ START
00000CE8                          1870mmm     ENDM
00000CE8                          1871mm CONTINUE_98
00000CE8  1A39 00C00013           1872mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000CEE  0805 0000               1873mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CF2  67D8                    1874mm     BEQ WAIT_FOR_READY_98                           ; NOTHING, CHECK AGAIN
00000CF4                          1875mm     
00000CF4  1A39 00C00017           1876mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000CFA  13C5 00E00001           1877mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000D00                          1878mm 
00000D00                          1879mm     ENDM
00000D00                          1880mm         PRINT_CHAR D5,D6
00000D00                          1881mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     1882mm     IFEQ DEBUG
00000D00  1C39 00C00003           1883mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000D06  0806 0002               1884mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    1885mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000D0C  13C5 00C00007           1886mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D12                          1887mm     ENDC
00000D12                          1888mm 
00000D12                 FALSE    1889mm     IFNE DEBUG
00000D12                          1890mm     ENDC
00000D12                          1891mm 
00000D12                          1892mm     ENDM
00000D12                          1893mm         HEX2BIN D5,D5,A4
00000D12  49FA 0FBB               1894mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000D16  0405 0030               1895mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D1A  CABC 000000FF           1896mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D20  1A34 5000               1897mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D24                          1898mm     ENDM
00000D24  8805                    1899m         OR.B D5,D4
00000D26  5307                    1900m         SUB.B #1,D7
00000D28                          1901m     ENDW
00000D28  6098                    1902ms     BRA _1000000E
00000D2A                          1903ms _1000000F
00000D2A                          1904m 
00000D2A  7A00                    1905m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D2C  1A04                    1906m     MOVE.B D4,D5
00000D2E  D484                    1907m     ADD.L D4,D2
00000D30                          1908m 
00000D30                          1909m     ENDM
00000D30                          1910m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000D30  1E3C 0002               1911m     MOVE.B #2,D7
00000D34                          1912m     WHILE.B D7 <GT> 0 DO
00000D34                          1913ms _10000010
00000D34  BE38 0000               1914ms     CMP.B   0,D7
00000D38  6F00 0062               1915ms     BLE _10000011
00000D3C  E98C                    1916m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000D3E                          1917mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000D3E                          1918mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                          1919mm 
00000D3E  1A39 00C00003           1920mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000D44  0805 0000               1921mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000D48  6700 0010               1922mm     BEQ CONTINUE_103                                    ; NOTHING, CONTINUE
00000D4C                          1923mm 
00000D4C                          1924mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000D4C                 TRUE     1925mmm     IFEQ DEBUG
00000D4C  1A39 00C00007           1926mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000D52                          1927mmm     ENDC
00000D52                 FALSE    1928mmm     IFNE DEBUG
00000D52                          1929mmm     ENDC
00000D52                          1930mmm 
00000D52  BA3C 001B               1931mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000D56  6700 F6A8               1932mmm     BEQ START
00000D5A                          1933mmm     ENDM
00000D5A                          1934mm CONTINUE_103
00000D5A  1A39 00C00013           1935mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000D60  0805 0000               1936mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000D64  67D8                    1937mm     BEQ WAIT_FOR_READY_103                          ; NOTHING, CHECK AGAIN
00000D66                          1938mm     
00000D66  1A39 00C00017           1939mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000D6C  13C5 00E00001           1940mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000D72                          1941mm 
00000D72                          1942mm     ENDM
00000D72                          1943mm         PRINT_CHAR D5,D6
00000D72                          1944mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     1945mm     IFEQ DEBUG
00000D72  1C39 00C00003           1946mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000D78  0806 0002               1947mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    1948mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000D7E  13C5 00C00007           1949mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D84                          1950mm     ENDC
00000D84                          1951mm 
00000D84                 FALSE    1952mm     IFNE DEBUG
00000D84                          1953mm     ENDC
00000D84                          1954mm 
00000D84                          1955mm     ENDM
00000D84                          1956mm         HEX2BIN D5,D5,A4
00000D84  49FA 0F49               1957mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000D88  0405 0030               1958mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D8C  CABC 000000FF           1959mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D92  1A34 5000               1960mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D96                          1961mm     ENDM
00000D96  8805                    1962m         OR.B D5,D4
00000D98  5307                    1963m         SUB.B #1,D7
00000D9A                          1964m     ENDW
00000D9A  6098                    1965ms     BRA _10000010
00000D9C                          1966ms _10000011
00000D9C                          1967m 
00000D9C  7A00                    1968m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D9E  1A04                    1969m     MOVE.B D4,D5
00000DA0  D484                    1970m     ADD.L D4,D2
00000DA2                          1971m 
00000DA2                          1972m     ENDM
00000DA2                          1973  
00000DA2  2044                    1974                  MOVE.L D4,A0                        ; start address -> A0
00000DA4  D1C9                    1975                  ADD.L A1,A0                         ; add in the offset
00000DA6                          1976  
00000DA6  72FF                    1977                  MOVE.L #$FFFFFFFF,D1                ; done
00000DA8                          1978              ELSE
00000DA8  6000 0078               1979s     BRA _0000000B
00000DAC                          1980s _0000000A
00000DAC                          1981m                 PRINT_CRLF D5,A4
00000DAC  49FA 0F8F               1982m     LEA CRLF(PC),A4
00000DB0                          1983mm     PRINT_STR A4,D5
00000DB0                          1984mm LOOP_108
00000DB0  0C14 0000               1985mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000DB4  6700 0016               1986mm     BEQ EXIT_108
00000DB8                          1987mmm     PRINT_CHAR (A4)+,D5
00000DB8                          1988mmm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB8                 TRUE     1989mmm     IFEQ DEBUG
00000DB8  1A39 00C00003           1990mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DBE  0805 0002               1991mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DC2  67F4                    1992mmm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000DC4  13DC 00C00007           1993mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DCA                          1994mmm     ENDC
00000DCA                          1995mmm 
00000DCA                 FALSE    1996mmm     IFNE DEBUG
00000DCA                          1997mmm     ENDC
00000DCA                          1998mmm 
00000DCA                          1999mmm     ENDM
00000DCA  60E4                    2000mm     BRA LOOP_108
00000DCC                          2001mm EXIT_108
00000DCC                          2002mm     ENDM
00000DCC                          2003m     ENDM
00000DCC                          2004  
00000DCC  49FA 0EB8               2005                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000DD0                          2006m                 PRINT_STR A4,D5
00000DD0                          2007m LOOP_110
00000DD0  0C14 0000               2008m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000DD4  6700 0016               2009m     BEQ EXIT_110
00000DD8                          2010mm     PRINT_CHAR (A4)+,D5
00000DD8                          2011mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD8                 TRUE     2012mm     IFEQ DEBUG
00000DD8  1A39 00C00003           2013mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DDE  0805 0002               2014mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DE2  67F4                    2015mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000DE4  13DC 00C00007           2016mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DEA                          2017mm     ENDC
00000DEA                          2018mm 
00000DEA                 FALSE    2019mm     IFNE DEBUG
00000DEA                          2020mm     ENDC
00000DEA                          2021mm 
00000DEA                          2022mm     ENDM
00000DEA  60E4                    2023m     BRA LOOP_110
00000DEC                          2024m EXIT_110
00000DEC                          2025m     ENDM
00000DEC                          2026m                 PRINT_CHAR D1,D5
00000DEC                          2027m WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEC                 TRUE     2028m     IFEQ DEBUG
00000DEC  1A39 00C00003           2029m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DF2  0805 0002               2030m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DF6  67F4                    2031m         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000DF8  13C1 00C00007           2032m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DFE                          2033m     ENDC
00000DFE                          2034m 
00000DFE                 FALSE    2035m     IFNE DEBUG
00000DFE                          2036m     ENDC
00000DFE                          2037m 
00000DFE                          2038m     ENDM
00000DFE                          2039m                 PRINT_CRLF D5,A4
00000DFE  49FA 0F3D               2040m     LEA CRLF(PC),A4
00000E02                          2041mm     PRINT_STR A4,D5
00000E02                          2042mm LOOP_114
00000E02  0C14 0000               2043mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E06  6700 0016               2044mm     BEQ EXIT_114
00000E0A                          2045mmm     PRINT_CHAR (A4)+,D5
00000E0A                          2046mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E0A                 TRUE     2047mmm     IFEQ DEBUG
00000E0A  1A39 00C00003           2048mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E10  0805 0002               2049mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E14  67F4                    2050mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000E16  13DC 00C00007           2051mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E1C                          2052mmm     ENDC
00000E1C                          2053mmm 
00000E1C                 FALSE    2054mmm     IFNE DEBUG
00000E1C                          2055mmm     ENDC
00000E1C                          2056mmm 
00000E1C                          2057mmm     ENDM
00000E1C  60E4                    2058mm     BRA LOOP_114
00000E1E                          2059mm EXIT_114
00000E1E                          2060mm     ENDM
00000E1E                          2061m     ENDM
00000E1E                          2062  
00000E1E  6000 FAEC               2063                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000E22                          2064              ENDI
00000E22                          2065s _0000000B
00000E22                          2066          ENDI
00000E22                          2067s _00000009
00000E22                          2068      ENDI
00000E22                          2069s _00000005
00000E22                          2070  
00000E22                          2071m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000E22  1E3C 0002               2072m     MOVE.B #2,D7
00000E26                          2073m     WHILE.B D7 <GT> 0 DO
00000E26                          2074ms _10000012
00000E26  BE38 0000               2075ms     CMP.B   0,D7
00000E2A  6F00 0062               2076ms     BLE _10000013
00000E2E  E98C                    2077m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000E30                          2078mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000E30                          2079mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E30                          2080mm 
00000E30  1A39 00C00003           2081mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000E36  0805 0000               2082mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000E3A  6700 0010               2083mm     BEQ CONTINUE_117                                    ; NOTHING, CONTINUE
00000E3E                          2084mm 
00000E3E                          2085mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000E3E                 TRUE     2086mmm     IFEQ DEBUG
00000E3E  1A39 00C00007           2087mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000E44                          2088mmm     ENDC
00000E44                 FALSE    2089mmm     IFNE DEBUG
00000E44                          2090mmm     ENDC
00000E44                          2091mmm 
00000E44  BA3C 001B               2092mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000E48  6700 F5B6               2093mmm     BEQ START
00000E4C                          2094mmm     ENDM
00000E4C                          2095mm CONTINUE_117
00000E4C  1A39 00C00013           2096mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000E52  0805 0000               2097mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000E56  67D8                    2098mm     BEQ WAIT_FOR_READY_117                          ; NOTHING, CHECK AGAIN
00000E58                          2099mm     
00000E58  1A39 00C00017           2100mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000E5E  13C5 00E00001           2101mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000E64                          2102mm 
00000E64                          2103mm     ENDM
00000E64                          2104mm         PRINT_CHAR D5,D6
00000E64                          2105mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E64                 TRUE     2106mm     IFEQ DEBUG
00000E64  1C39 00C00003           2107mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000E6A  0806 0002               2108mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000E6E  67F4                    2109mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000E70  13C5 00C00007           2110mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E76                          2111mm     ENDC
00000E76                          2112mm 
00000E76                 FALSE    2113mm     IFNE DEBUG
00000E76                          2114mm     ENDC
00000E76                          2115mm 
00000E76                          2116mm     ENDM
00000E76                          2117mm         HEX2BIN D5,D5,A4
00000E76  49FA 0E57               2118mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000E7A  0405 0030               2119mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E7E  CABC 000000FF           2120mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000E84  1A34 5000               2121mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E88                          2122mm     ENDM
00000E88  8805                    2123m         OR.B D5,D4
00000E8A  5307                    2124m         SUB.B #1,D7
00000E8C                          2125m     ENDW
00000E8C  6098                    2126ms     BRA _10000012
00000E8E                          2127ms _10000013
00000E8E                          2128m 
00000E8E  7A00                    2129m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000E90  1A04                    2130m     MOVE.B D4,D5
00000E92  D484                    2131m     ADD.L D4,D2
00000E94                          2132m 
00000E94                          2133m     ENDM
00000E94                          2134m     PRINT_CRLF D5,A4
00000E94  49FA 0EA7               2135m     LEA CRLF(PC),A4
00000E98                          2136mm     PRINT_STR A4,D5
00000E98                          2137mm LOOP_122
00000E98  0C14 0000               2138mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E9C  6700 0016               2139mm     BEQ EXIT_122
00000EA0                          2140mmm     PRINT_CHAR (A4)+,D5
00000EA0                          2141mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA0                 TRUE     2142mmm     IFEQ DEBUG
00000EA0  1A39 00C00003           2143mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EA6  0805 0002               2144mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EAA  67F4                    2145mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000EAC  13DC 00C00007           2146mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB2                          2147mmm     ENDC
00000EB2                          2148mmm 
00000EB2                 FALSE    2149mmm     IFNE DEBUG
00000EB2                          2150mmm     ENDC
00000EB2                          2151mmm 
00000EB2                          2152mmm     ENDM
00000EB2  60E4                    2153mm     BRA LOOP_122
00000EB4                          2154mm EXIT_122
00000EB4                          2155mm     ENDM
00000EB4                          2156m     ENDM
00000EB4                          2157  
00000EB4                          2158      IF.B D2 <NE> #$FF THEN.L
00000EB4  B43C 00FF               2159s     CMP.B   #$FF,D2
00000EB8  6700 0090               2160s     BEQ.L   _0000000C
00000EBC  49FA 0DDF               2161          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000EC0                          2162m         PRINT_STR A4,D5
00000EC0                          2163m LOOP_124
00000EC0  0C14 0000               2164m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EC4  6700 0016               2165m     BEQ EXIT_124
00000EC8                          2166mm     PRINT_CHAR (A4)+,D5
00000EC8                          2167mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2168mm     IFEQ DEBUG
00000EC8  1A39 00C00003           2169mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ECE  0805 0002               2170mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ED2  67F4                    2171mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000ED4  13DC 00C00007           2172mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EDA                          2173mm     ENDC
00000EDA                          2174mm 
00000EDA                 FALSE    2175mm     IFNE DEBUG
00000EDA                          2176mm     ENDC
00000EDA                          2177mm 
00000EDA                          2178mm     ENDM
00000EDA  60E4                    2179m     BRA LOOP_124
00000EDC                          2180m EXIT_124
00000EDC                          2181m     ENDM
00000EDC                          2182m         PRINT_REG D0,D5,D3,D6,A4
00000EDC  49FA 0E65               2183m     LEA OX(PC),A4
00000EE0                          2184mm     PRINT_STR A4,D5
00000EE0                          2185mm LOOP_127
00000EE0  0C14 0000               2186mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EE4  6700 0016               2187mm     BEQ EXIT_127
00000EE8                          2188mmm     PRINT_CHAR (A4)+,D5
00000EE8                          2189mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EE8                 TRUE     2190mmm     IFEQ DEBUG
00000EE8  1A39 00C00003           2191mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EEE  0805 0002               2192mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EF2  67F4                    2193mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000EF4  13DC 00C00007           2194mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFA                          2195mmm     ENDC
00000EFA                          2196mmm 
00000EFA                 FALSE    2197mmm     IFNE DEBUG
00000EFA                          2198mmm     ENDC
00000EFA                          2199mmm 
00000EFA                          2200mmm     ENDM
00000EFA  60E4                    2201mm     BRA LOOP_127
00000EFC                          2202mm EXIT_127
00000EFC                          2203mm     ENDM
00000EFC  7C07                    2204m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EFE                          2205m LOOP_126
00000EFE                          2206mm     BIN2HEX D0,D3,A4
00000EFE  49FA 0DBF               2207mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000F02  E998                    2208mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F04  1600                    2209mm     MOVE.B D0,D3
00000F06  0283 0000000F           2210mm     ANDI.L #$F,D3
00000F0C  1634 3000               2211mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000F10                          2212mm     ENDM
00000F10                          2213mm     PRINT_CHAR D3,D5
00000F10                          2214mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F10                 TRUE     2215mm     IFEQ DEBUG
00000F10  1A39 00C00003           2216mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F16  0805 0002               2217mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F1A  67F4                    2218mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000F1C  13C3 00C00007           2219mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F22                          2220mm     ENDC
00000F22                          2221mm 
00000F22                 FALSE    2222mm     IFNE DEBUG
00000F22                          2223mm     ENDC
00000F22                          2224mm 
00000F22                          2225mm     ENDM
00000F22  57CE FFDA               2226m     DBEQ D6,LOOP_126
00000F26                          2227m     ENDM
00000F26                          2228m         PRINT_CRLF D5,A4
00000F26  49FA 0E15               2229m     LEA CRLF(PC),A4
00000F2A                          2230mm     PRINT_STR A4,D5
00000F2A                          2231mm LOOP_132
00000F2A  0C14 0000               2232mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000F2E  6700 0016               2233mm     BEQ EXIT_132
00000F32                          2234mmm     PRINT_CHAR (A4)+,D5
00000F32                          2235mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F32                 TRUE     2236mmm     IFEQ DEBUG
00000F32  1A39 00C00003           2237mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F38  0805 0002               2238mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F3C  67F4                    2239mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000F3E  13DC 00C00007           2240mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F44                          2241mmm     ENDC
00000F44                          2242mmm 
00000F44                 FALSE    2243mmm     IFNE DEBUG
00000F44                          2244mmm     ENDC
00000F44                          2245mmm 
00000F44                          2246mmm     ENDM
00000F44  60E4                    2247mm     BRA LOOP_132
00000F46                          2248mm EXIT_132
00000F46                          2249mm     ENDM
00000F46                          2250m     ENDM
00000F46                          2251          
00000F46  6000 F714               2252          BRA MAIN_LOOP
00000F4A                          2253      ENDI
00000F4A                          2254s _0000000C
00000F4A                          2255  
00000F4A                          2256      IF D1 <EQ> #0 THEN
00000F4A  B27C 0000               2257s     CMP.W   #0,D1
00000F4E  6600 0006               2258s     BNE _0000000D
00000F52  6000 F9B8               2259        BRA WAIT_FOR_SRECORD
00000F56                          2260      ENDI
00000F56                          2261s _0000000D
00000F56                          2262  DOWNLOAD_DONE
00000F56                          2263m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000F56  43FA 0DEB               2264m     LEA OX(PC),A1
00000F5A                          2265mm     PRINT_STR A1,D5
00000F5A                          2266mm LOOP_135
00000F5A  0C11 0000               2267mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F5E  6700 0016               2268mm     BEQ EXIT_135
00000F62                          2269mmm     PRINT_CHAR (A1)+,D5
00000F62                          2270mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F62                 TRUE     2271mmm     IFEQ DEBUG
00000F62  1A39 00C00003           2272mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F68  0805 0002               2273mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F6C  67F4                    2274mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000F6E  13D9 00C00007           2275mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F74                          2276mmm     ENDC
00000F74                          2277mmm 
00000F74                 FALSE    2278mmm     IFNE DEBUG
00000F74                          2279mmm     ENDC
00000F74                          2280mmm 
00000F74                          2281mmm     ENDM
00000F74  60E4                    2282mm     BRA LOOP_135
00000F76                          2283mm EXIT_135
00000F76                          2284mm     ENDM
00000F76  7407                    2285m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F78                          2286m LOOP_134
00000F78                          2287mm     BIN2HEX D0,D6,A1
00000F78  43FA 0D45               2288mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000F7C  E998                    2289mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F7E  1C00                    2290mm     MOVE.B D0,D6
00000F80  0286 0000000F           2291mm     ANDI.L #$F,D6
00000F86  1C31 6000               2292mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000F8A                          2293mm     ENDM
00000F8A                          2294mm     PRINT_CHAR D6,D5
00000F8A                          2295mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F8A                 TRUE     2296mm     IFEQ DEBUG
00000F8A  1A39 00C00003           2297mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F90  0805 0002               2298mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F94  67F4                    2299mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000F96  13C6 00C00007           2300mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F9C                          2301mm     ENDC
00000F9C                          2302mm 
00000F9C                 FALSE    2303mm     IFNE DEBUG
00000F9C                          2304mm     ENDC
00000F9C                          2305mm 
00000F9C                          2306mm     ENDM
00000F9C  57CA FFDA               2307m     DBEQ D2,LOOP_134
00000FA0                          2308m     ENDM
00000FA0  43FA 0CC2               2309      LEA READ(PC),A1
00000FA4                          2310m     PRINT_STR A1,D5
00000FA4                          2311m LOOP_139
00000FA4  0C11 0000               2312m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FA8  6700 0016               2313m     BEQ EXIT_139
00000FAC                          2314mm     PRINT_CHAR (A1)+,D5
00000FAC                          2315mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FAC                 TRUE     2316mm     IFEQ DEBUG
00000FAC  1A39 00C00003           2317mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FB2  0805 0002               2318mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000FB6  67F4                    2319mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000FB8  13D9 00C00007           2320mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FBE                          2321mm     ENDC
00000FBE                          2322mm 
00000FBE                 FALSE    2323mm     IFNE DEBUG
00000FBE                          2324mm     ENDC
00000FBE                          2325mm 
00000FBE                          2326mm     ENDM
00000FBE  60E4                    2327m     BRA LOOP_139
00000FC0                          2328m EXIT_139
00000FC0                          2329m     ENDM
00000FC0  2E08                    2330      MOVE.L A0,D7                                    ; set address accumulator to start address
00000FC2                          2331m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000FC2  43FA 0D7F               2332m     LEA OX(PC),A1
00000FC6                          2333mm     PRINT_STR A1,D5
00000FC6                          2334mm LOOP_142
00000FC6  0C11 0000               2335mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FCA  6700 0016               2336mm     BEQ EXIT_142
00000FCE                          2337mmm     PRINT_CHAR (A1)+,D5
00000FCE                          2338mmm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FCE                 TRUE     2339mmm     IFEQ DEBUG
00000FCE  1A39 00C00003           2340mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FD4  0805 0002               2341mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000FD8  67F4                    2342mmm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000FDA  13D9 00C00007           2343mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FE0                          2344mmm     ENDC
00000FE0                          2345mmm 
00000FE0                 FALSE    2346mmm     IFNE DEBUG
00000FE0                          2347mmm     ENDC
00000FE0                          2348mmm 
00000FE0                          2349mmm     ENDM
00000FE0  60E4                    2350mm     BRA LOOP_142
00000FE2                          2351mm EXIT_142
00000FE2                          2352mm     ENDM
00000FE2  7407                    2353m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FE4                          2354m LOOP_141
00000FE4                          2355mm     BIN2HEX D7,D6,A1
00000FE4  43FA 0CD9               2356mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000FE8  E99F                    2357mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FEA  1C07                    2358mm     MOVE.B D7,D6
00000FEC  0286 0000000F           2359mm     ANDI.L #$F,D6
00000FF2  1C31 6000               2360mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000FF6                          2361mm     ENDM
00000FF6                          2362mm     PRINT_CHAR D6,D5
00000FF6                          2363mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FF6                 TRUE     2364mm     IFEQ DEBUG
00000FF6  1A39 00C00003           2365mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FFC  0805 0002               2366mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001000  67F4                    2367mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00001002  13C6 00C00007           2368mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001008                          2369mm     ENDC
00001008                          2370mm 
00001008                 FALSE    2371mm     IFNE DEBUG
00001008                          2372mm     ENDC
00001008                          2373mm 
00001008                          2374mm     ENDM
00001008  57CA FFDA               2375m     DBEQ D2,LOOP_141
0000100C                          2376m     ENDM
0000100C                          2377m     PRINT_CRLF D5,A4
0000100C  49FA 0D2F               2378m     LEA CRLF(PC),A4
00001010                          2379mm     PRINT_STR A4,D5
00001010                          2380mm LOOP_147
00001010  0C14 0000               2381mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00001014  6700 0016               2382mm     BEQ EXIT_147
00001018                          2383mmm     PRINT_CHAR (A4)+,D5
00001018                          2384mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001018                 TRUE     2385mmm     IFEQ DEBUG
00001018  1A39 00C00003           2386mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000101E  0805 0002               2387mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001022  67F4                    2388mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00001024  13DC 00C00007           2389mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000102A                          2390mmm     ENDC
0000102A                          2391mmm 
0000102A                 FALSE    2392mmm     IFNE DEBUG
0000102A                          2393mmm     ENDC
0000102A                          2394mmm 
0000102A                          2395mmm     ENDM
0000102A  60E4                    2396mm     BRA LOOP_147
0000102C                          2397mm EXIT_147
0000102C                          2398mm     ENDM
0000102C                          2399m     ENDM
0000102C                          2400  
0000102C  6000 F62E               2401      BRA MAIN_LOOP
00001030                          2402  
00001030                          2403  G
00001030  2047                    2404      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00001032  7E00                    2405      MOVE.L #0,D7
00001034                          2406  
00001034  4ED0                    2407      JMP (A0)
00001036                          2408          
00001036                          2409  Z
00001036  207C 00200000           2410      MOVE.L #RAM,A0                                  ; address of RAM
0000103C  D1FC 00100000           2411      ADD.L #$100000,A0
00001042                          2412  
00001042                          2413      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00001042  7000                    2414s     MOVE.L  #0,D0
00001044  6000 0012               2415s     BRA _20000007
00001048                          2416s _20000006
00001048  2200                    2417          MOVE.L D0,D1                                ; progress update
0000104A  E089                    2418          LSR.L #8,D1 
0000104C  E089                    2419          LSR.L #8,D1
0000104E  13C1 00E00001           2420          MOVE.B D1,DISPLAY
00001054                          2421          
00001054  2108                    2422          MOVE.L A0,-(A0)
00001056                          2423      ENDF
00001056  5880                    2424s     ADD.L   #4,D0
00001058                          2425s _20000007
00001058  B0BC 000FFFFC           2426s     CMP.L   #$FFFFC,D0
0000105E  6FE8                    2427s     BLE _20000006
00001060                          2428  
00001060  207C 00200000           2429      MOVE.L #RAM,A0                                  ; address of RAM
00001066  D1FC 00100000           2430      ADD.L #$100000,A0
0000106C                          2431  
0000106C                          2432      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
0000106C  7000                    2433s     MOVE.L  #0,D0
0000106E  6000 00A8               2434s     BRA _20000009
00001072                          2435s _20000008
00001072  2200                    2436          MOVE.L D0,D1                                ; progress update
00001074  E089                    2437          LSR.L #8,D1
00001076  E089                    2438          LSR.L #8,D1
00001078  13C1 00E00001           2439          MOVE.B D1,DISPLAY
0000107E                          2440  
0000107E  2408                    2441          MOVE.L A0,D2
00001080  2220                    2442          MOVE.L -(A0),D1
00001082                          2443  
00001082                          2444          IF.L D2 <NE> D1 THEN
00001082  B481                    2445s     CMP.L   D1,D2
00001084  6700 0090               2446s     BEQ _0000000E
00001088  43FA 0C24               2447              LEA RAM_ERROR(PC),A1
0000108C                          2448m             PRINT_STR A1,D1
0000108C                          2449m LOOP_149
0000108C  0C11 0000               2450m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001090  6700 0016               2451m     BEQ EXIT_149
00001094                          2452mm     PRINT_CHAR (A1)+,D1
00001094                          2453mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001094                 TRUE     2454mm     IFEQ DEBUG
00001094  1239 00C00003           2455mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000109A  0801 0002               2456mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000109E  67F4                    2457mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
000010A0  13D9 00C00007           2458mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010A6                          2459mm     ENDC
000010A6                          2460mm 
000010A6                 FALSE    2461mm     IFNE DEBUG
000010A6                          2462mm     ENDC
000010A6                          2463mm 
000010A6                          2464mm     ENDM
000010A6  60E4                    2465m     BRA LOOP_149
000010A8                          2466m EXIT_149
000010A8                          2467m     ENDM
000010A8  2208                    2468              MOVE.L A0,D1
000010AA  5981                    2469              SUB.L #4,D1
000010AC                          2470m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
000010AC  43FA 0C95               2471m     LEA OX(PC),A1
000010B0                          2472mm     PRINT_STR A1,D3
000010B0                          2473mm LOOP_152
000010B0  0C11 0000               2474mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010B4  6700 0016               2475mm     BEQ EXIT_152
000010B8                          2476mmm     PRINT_CHAR (A1)+,D3
000010B8                          2477mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010B8                 TRUE     2478mmm     IFEQ DEBUG
000010B8  1639 00C00003           2479mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010BE  0803 0002               2480mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010C2  67F4                    2481mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
000010C4  13D9 00C00007           2482mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010CA                          2483mmm     ENDC
000010CA                          2484mmm 
000010CA                 FALSE    2485mmm     IFNE DEBUG
000010CA                          2486mmm     ENDC
000010CA                          2487mmm 
000010CA                          2488mmm     ENDM
000010CA  60E4                    2489mm     BRA LOOP_152
000010CC                          2490mm EXIT_152
000010CC                          2491mm     ENDM
000010CC  7C07                    2492m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010CE                          2493m LOOP_151
000010CE                          2494mm     BIN2HEX D1,D2,A1
000010CE  43FA 0BEF               2495mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
000010D2  E999                    2496mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010D4  1401                    2497mm     MOVE.B D1,D2
000010D6  0282 0000000F           2498mm     ANDI.L #$F,D2
000010DC  1431 2000               2499mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000010E0                          2500mm     ENDM
000010E0                          2501mm     PRINT_CHAR D2,D3
000010E0                          2502mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010E0                 TRUE     2503mm     IFEQ DEBUG
000010E0  1639 00C00003           2504mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010E6  0803 0002               2505mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010EA  67F4                    2506mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
000010EC  13C2 00C00007           2507mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010F2                          2508mm     ENDC
000010F2                          2509mm 
000010F2                 FALSE    2510mm     IFNE DEBUG
000010F2                          2511mm     ENDC
000010F2                          2512mm 
000010F2                          2513mm     ENDM
000010F2  57CE FFDA               2514m     DBEQ D6,LOOP_151
000010F6                          2515m     ENDM
000010F6                          2516m             PRINT_CRLF D3,A1
000010F6  43FA 0C45               2517m     LEA CRLF(PC),A1
000010FA                          2518mm     PRINT_STR A1,D3
000010FA                          2519mm LOOP_157
000010FA  0C11 0000               2520mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010FE  6700 0016               2521mm     BEQ EXIT_157
00001102                          2522mmm     PRINT_CHAR (A1)+,D3
00001102                          2523mmm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001102                 TRUE     2524mmm     IFEQ DEBUG
00001102  1639 00C00003           2525mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001108  0803 0002               2526mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000110C  67F4                    2527mmm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
0000110E  13D9 00C00007           2528mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001114                          2529mmm     ENDC
00001114                          2530mmm 
00001114                 FALSE    2531mmm     IFNE DEBUG
00001114                          2532mmm     ENDC
00001114                          2533mmm 
00001114                          2534mmm     ENDM
00001114  60E4                    2535mm     BRA LOOP_157
00001116                          2536mm EXIT_157
00001116                          2537mm     ENDM
00001116                          2538m     ENDM
00001116                          2539          ENDI 
00001116                          2540s _0000000E
00001116                          2541      ENDF
00001116  5880                    2542s     ADD.L   #4,D0
00001118                          2543s _20000009
00001118  B0BC 000FFFFC           2544s     CMP.L   #$FFFFC,D0
0000111E  6F00 FF52               2545s     BLE _20000008
00001122                          2546  
00001122  6000 F538               2547      BRA MAIN_LOOP
00001126                          2548  
00001126                          2549  L
00001126  7000                    2550      MOVE.L #0,D0                                    ; D0 will be the length to write               
00001128  7200                    2551      MOVE.L #0,D1                                    ; D1 will be the address to write 
0000112A                          2552  
0000112A                          2553      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
0000112A  343C 0000               2554s     MOVE.W  #0,D2
0000112E  6000 0046               2555s     BRA _2000000B
00001132                          2556s _2000000A
00001132  E989                    2557          LSL.L #4,D1                                 ; make what we have so far more significant
00001134                          2558m         WAIT_CHAR D3,D4                             ; next character -> D2
00001134                          2559m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001134                 TRUE     2560m     IFEQ DEBUG
00001134  1839 00C00003           2561m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000113A  0804 0000               2562m         BTST #0,D4                                  ; CHECK FOR CHARACTER
0000113E  67F4                    2563m         BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00001140                          2564m     ENDC
00001140                          2565m 
00001140                          2566mm     READ_CHAR D3
00001140                 TRUE     2567mm     IFEQ DEBUG
00001140  1639 00C00007           2568mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001146                          2569mm     ENDC
00001146                 FALSE    2570mm     IFNE DEBUG
00001146                          2571mm     ENDC
00001146                          2572mm 
00001146  B63C 001B               2573mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
0000114A  6700 F2B4               2574mm     BEQ START
0000114E                          2575mm     ENDM
0000114E                          2576m 
0000114E                 TRUE     2577m     IFEQ DEBUG
0000114E                          2578mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
0000114E                          2579mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000114E                 TRUE     2580mm     IFEQ DEBUG
0000114E  1839 00C00003           2581mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001154  0804 0002               2582mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001158  67F4                    2583mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
0000115A  13C3 00C00007           2584mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001160                          2585mm     ENDC
00001160                          2586mm 
00001160                 FALSE    2587mm     IFNE DEBUG
00001160                          2588mm     ENDC
00001160                          2589mm 
00001160                          2590mm     ENDM
00001160                          2591m     ENDC
00001160                          2592m     ENDM
00001160                          2593m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00001160  41FA 0B6D               2594m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001164  0403 0030               2595m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001168  C6BC 000000FF           2596m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
0000116E  1630 3000               2597m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001172                          2598m     ENDM
00001172  8203                    2599          OR.B D3,D1
00001174                          2600      ENDF
00001174  5242                    2601s     ADD.W   #1,D2
00001176                          2602s _2000000B
00001176  B47C 0007               2603s     CMP.W   #7,D2
0000117A  6FB6                    2604s     BLE _2000000A
0000117C                          2605  
0000117C  3001                    2606      MOVE.W D1,D0                                    ; extract the LSword for the length
0000117E  E089                    2607      LSR.L #8,D1                                     ; extract the MSword for the address
00001180  E089                    2608      LSR.L #8,D1
00001182                          2609  
00001182                          2610m     PRINT_CRLF D2,A1
00001182  43FA 0BB9               2611m     LEA CRLF(PC),A1
00001186                          2612mm     PRINT_STR A1,D2
00001186                          2613mm LOOP_164
00001186  0C11 0000               2614mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000118A  6700 0016               2615mm     BEQ EXIT_164
0000118E                          2616mmm     PRINT_CHAR (A1)+,D2
0000118E                          2617mmm WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000118E                 TRUE     2618mmm     IFEQ DEBUG
0000118E  1439 00C00003           2619mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001194  0802 0002               2620mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001198  67F4                    2621mmm         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
0000119A  13D9 00C00007           2622mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011A0                          2623mmm     ENDC
000011A0                          2624mmm 
000011A0                 FALSE    2625mmm     IFNE DEBUG
000011A0                          2626mmm     ENDC
000011A0                          2627mmm 
000011A0                          2628mmm     ENDM
000011A0  60E4                    2629mm     BRA LOOP_164
000011A2                          2630mm EXIT_164
000011A2                          2631mm     ENDM
000011A2                          2632m     ENDM
000011A2                          2633  
000011A2  2041                    2634      MOVE.L D1,A0                                    ; target address
000011A4  2641                    2635      MOVE.L D1,A3                                    ; keep a copy for later
000011A6                          2636  
000011A6  2247                    2637      MOVE.L D7,A1                                    ; address accumulator -> address register
000011A8  D3FC 00000400           2638      ADD.L #START,A1                                 ; skip the vectors
000011AE  2847                    2639      MOVE.L D7,A4                                    ; keep a clean copy for later
000011B0  7E00                    2640      MOVE.L #0,D7                                    ; clear the now used address accumulator
000011B2                          2641  
000011B2                          2642m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000011B2  31FC AAAA 2AAA          2643m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000011B8  4E71                    2644m     NOP
000011BA  31FC 5555 1554          2645m     MOVE.W #$5555,$1554
000011C0  4E71                    2646m     NOP
000011C2  31FC 8080 2AAA          2647m     MOVE.W #$8080,$2AAA
000011C8  4E71                    2648m     NOP
000011CA  31FC AAAA 2AAA          2649m     MOVE.W #$AAAA,$2AAA
000011D0  4E71                    2650m     NOP
000011D2  31FC 5555 1554          2651m     MOVE.W #$5555,$1554
000011D8  4E71                    2652m     NOP
000011DA  31FC 2020 2AAA          2653m     MOVE.W #$2020,$2AAA
000011E0                          2654m     ENDM
000011E0                          2655                              
000011E0                          2656      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000011E0  3E3C 0000               2657s     MOVE.W  #$0,D7
000011E4  6000 0006               2658s     BRA _2000000D
000011E8                          2659s _2000000C
000011E8  4E71                    2660          NOP
000011EA                          2661      ENDF
000011EA  5247                    2662s     ADD.W   #1,D7
000011EC                          2663s _2000000D
000011EC  BE7C FFFF               2664s     CMP.W   #$FFFFFFFF,D7
000011F0  6FF6                    2665s     BLE _2000000C
000011F2                          2666  
000011F2  45FA 0AF2               2667      LEA LOADING(PC),A2
000011F6                          2668m     PRINT_STR A2,D2
000011F6                          2669m LOOP_167
000011F6  0C12 0000               2670m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011FA  6700 0016               2671m     BEQ EXIT_167
000011FE                          2672mm     PRINT_CHAR (A2)+,D2
000011FE                          2673mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011FE                 TRUE     2674mm     IFEQ DEBUG
000011FE  1439 00C00003           2675mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001204  0802 0002               2676mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001208  67F4                    2677mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
0000120A  13DA 00C00007           2678mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001210                          2679mm     ENDC
00001210                          2680mm 
00001210                 FALSE    2681mm     IFNE DEBUG
00001210                          2682mm     ENDC
00001210                          2683mm 
00001210                          2684mm     ENDM
00001210  60E4                    2685m     BRA LOOP_167
00001212                          2686m EXIT_167
00001212                          2687m     ENDM
00001212                          2688      
00001212                          2689  
00001212  45FA 0AE6               2690      LEA CODE(PC),A2
00001216                          2691m     PRINT_STR A2,D2
00001216                          2692m LOOP_169
00001216  0C12 0000               2693m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000121A  6700 0016               2694m     BEQ EXIT_169
0000121E                          2695mm     PRINT_CHAR (A2)+,D2
0000121E                          2696mm WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121E                 TRUE     2697mm     IFEQ DEBUG
0000121E  1439 00C00003           2698mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001224  0802 0002               2699mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001228  67F4                    2700mm         BEQ WAIT_FOR_READY_170                      ; NO SPACE, CHECK AGAIN
0000122A  13DA 00C00007           2701mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001230                          2702mm     ENDC
00001230                          2703mm 
00001230                 FALSE    2704mm     IFNE DEBUG
00001230                          2705mm     ENDC
00001230                          2706mm 
00001230                          2707mm     ENDM
00001230  60E4                    2708m     BRA LOOP_169
00001232                          2709m EXIT_169
00001232                          2710m     ENDM
00001232                          2711      
00001232  2409                    2712      MOVE.L A1,D2
00001234                          2713m     PRINT_REG D2,D3,D4,D5,A2
00001234  45FA 0B0D               2714m     LEA OX(PC),A2
00001238                          2715mm     PRINT_STR A2,D3
00001238                          2716mm LOOP_172
00001238  0C12 0000               2717mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000123C  6700 0016               2718mm     BEQ EXIT_172
00001240                          2719mmm     PRINT_CHAR (A2)+,D3
00001240                          2720mmm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001240                 TRUE     2721mmm     IFEQ DEBUG
00001240  1639 00C00003           2722mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001246  0803 0002               2723mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000124A  67F4                    2724mmm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
0000124C  13DA 00C00007           2725mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001252                          2726mmm     ENDC
00001252                          2727mmm 
00001252                 FALSE    2728mmm     IFNE DEBUG
00001252                          2729mmm     ENDC
00001252                          2730mmm 
00001252                          2731mmm     ENDM
00001252  60E4                    2732mm     BRA LOOP_172
00001254                          2733mm EXIT_172
00001254                          2734mm     ENDM
00001254  7A07                    2735m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001256                          2736m LOOP_171
00001256                          2737mm     BIN2HEX D2,D4,A2
00001256  45FA 0A67               2738mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000125A  E99A                    2739mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000125C  1802                    2740mm     MOVE.B D2,D4
0000125E  0284 0000000F           2741mm     ANDI.L #$F,D4
00001264  1832 4000               2742mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001268                          2743mm     ENDM
00001268                          2744mm     PRINT_CHAR D4,D3
00001268                          2745mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001268                 TRUE     2746mm     IFEQ DEBUG
00001268  1639 00C00003           2747mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126E  0803 0002               2748mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001272  67F4                    2749mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00001274  13C4 00C00007           2750mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000127A                          2751mm     ENDC
0000127A                          2752mm 
0000127A                 FALSE    2753mm     IFNE DEBUG
0000127A                          2754mm     ENDC
0000127A                          2755mm 
0000127A                          2756mm     ENDM
0000127A  57CD FFDA               2757m     DBEQ D5,LOOP_171
0000127E                          2758m     ENDM
0000127E                          2759  
0000127E  45FA 0AC6               2760      LEA TO(PC),A2
00001282                          2761m     PRINT_STR A2,D3
00001282                          2762m LOOP_176
00001282  0C12 0000               2763m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001286  6700 0016               2764m     BEQ EXIT_176
0000128A                          2765mm     PRINT_CHAR (A2)+,D3
0000128A                          2766mm WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000128A                 TRUE     2767mm     IFEQ DEBUG
0000128A  1639 00C00003           2768mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001290  0803 0002               2769mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001294  67F4                    2770mm         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
00001296  13DA 00C00007           2771mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000129C                          2772mm     ENDC
0000129C                          2773mm 
0000129C                 FALSE    2774mm     IFNE DEBUG
0000129C                          2775mm     ENDC
0000129C                          2776mm 
0000129C                          2777mm     ENDM
0000129C  60E4                    2778m     BRA LOOP_176
0000129E                          2779m EXIT_176
0000129E                          2780m     ENDM
0000129E                          2781  
0000129E  2408                    2782      MOVE.L A0,D2
000012A0                          2783m     PRINT_REG D2,D3,D4,D5,A2
000012A0  45FA 0AA1               2784m     LEA OX(PC),A2
000012A4                          2785mm     PRINT_STR A2,D3
000012A4                          2786mm LOOP_179
000012A4  0C12 0000               2787mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012A8  6700 0016               2788mm     BEQ EXIT_179
000012AC                          2789mmm     PRINT_CHAR (A2)+,D3
000012AC                          2790mmm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012AC                 TRUE     2791mmm     IFEQ DEBUG
000012AC  1639 00C00003           2792mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B2  0803 0002               2793mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012B6  67F4                    2794mmm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
000012B8  13DA 00C00007           2795mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012BE                          2796mmm     ENDC
000012BE                          2797mmm 
000012BE                 FALSE    2798mmm     IFNE DEBUG
000012BE                          2799mmm     ENDC
000012BE                          2800mmm 
000012BE                          2801mmm     ENDM
000012BE  60E4                    2802mm     BRA LOOP_179
000012C0                          2803mm EXIT_179
000012C0                          2804mm     ENDM
000012C0  7A07                    2805m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012C2                          2806m LOOP_178
000012C2                          2807mm     BIN2HEX D2,D4,A2
000012C2  45FA 09FB               2808mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012C6  E99A                    2809mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012C8  1802                    2810mm     MOVE.B D2,D4
000012CA  0284 0000000F           2811mm     ANDI.L #$F,D4
000012D0  1832 4000               2812mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000012D4                          2813mm     ENDM
000012D4                          2814mm     PRINT_CHAR D4,D3
000012D4                          2815mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012D4                 TRUE     2816mm     IFEQ DEBUG
000012D4  1639 00C00003           2817mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012DA  0803 0002               2818mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012DE  67F4                    2819mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
000012E0  13C4 00C00007           2820mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012E6                          2821mm     ENDC
000012E6                          2822mm 
000012E6                 FALSE    2823mm     IFNE DEBUG
000012E6                          2824mm     ENDC
000012E6                          2825mm 
000012E6                          2826mm     ENDM
000012E6  57CD FFDA               2827m     DBEQ D5,LOOP_178
000012EA                          2828m     ENDM
000012EA                          2829  
000012EA                          2830m     PRINT_CRLF D3,A2
000012EA  45FA 0A51               2831m     LEA CRLF(PC),A2
000012EE                          2832mm     PRINT_STR A2,D3
000012EE                          2833mm LOOP_184
000012EE  0C12 0000               2834mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012F2  6700 0016               2835mm     BEQ EXIT_184
000012F6                          2836mmm     PRINT_CHAR (A2)+,D3
000012F6                          2837mmm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012F6                 TRUE     2838mmm     IFEQ DEBUG
000012F6  1639 00C00003           2839mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012FC  0803 0002               2840mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001300  67F4                    2841mmm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00001302  13DA 00C00007           2842mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001308                          2843mmm     ENDC
00001308                          2844mmm 
00001308                 FALSE    2845mmm     IFNE DEBUG
00001308                          2846mmm     ENDC
00001308                          2847mmm 
00001308                          2848mmm     ENDM
00001308  60E4                    2849mm     BRA LOOP_184
0000130A                          2850mm EXIT_184
0000130A                          2851mm     ENDM
0000130A                          2852m     ENDM
0000130A                          2853  
0000130A                          2854      WHILE D0 <GT> #0 DO
0000130A                          2855s _10000014
0000130A  B07C 0000               2856s     CMP.W   #0,D0
0000130E  6F00 001C               2857s     BLE _10000015
00001312  5580                    2858          SUB.L #2,D0
00001314                          2859  
00001314  13D1 00E00001           2860          MOVE.B (A1),DISPLAY
0000131A                          2861m         PROGRAM (A1),(A0),D2
0000131A  3091                    2862m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
0000131C                          2863m 
0000131C                          2864m WAIT_FOR_COMPLETE_186
0000131C  3410                    2865m         MOVE.W (A0),D2
0000131E                          2866m 
0000131E                          2867m         IF.W D2 <NE> (A1) THEN
0000131E  B451                    2868ms     CMP.W   (A1),D2
00001320  6700 0004               2869ms     BEQ _0000000F
00001324  60F6                    2870m             BRA WAIT_FOR_COMPLETE_186
00001326                          2871m         ENDI
00001326                          2872ms _0000000F
00001326                          2873m         ENDM
00001326                          2874          
00001326                          2875          ;PRINT_CHAR #'.',D7
00001326                          2876          
00001326  5488                    2877          ADD.L #2,A0
00001328  5489                    2878          ADD.L #2,A1
0000132A                          2879      ENDW
0000132A  60DE                    2880s     BRA _10000014
0000132C                          2881s _10000015
0000132C                          2882  
0000132C  45FA 09DB               2883      LEA SP(PC),A2
00001330                          2884m     PRINT_STR A2,D2
00001330                          2885m LOOP_187
00001330  0C12 0000               2886m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001334  6700 0016               2887m     BEQ EXIT_187
00001338                          2888mm     PRINT_CHAR (A2)+,D2
00001338                          2889mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001338                 TRUE     2890mm     IFEQ DEBUG
00001338  1439 00C00003           2891mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000133E  0802 0002               2892mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001342  67F4                    2893mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00001344  13DA 00C00007           2894mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000134A                          2895mm     ENDC
0000134A                          2896mm 
0000134A                 FALSE    2897mm     IFNE DEBUG
0000134A                          2898mm     ENDC
0000134A                          2899mm 
0000134A                          2900mm     ENDM
0000134A  60E4                    2901m     BRA LOOP_187
0000134C                          2902m EXIT_187
0000134C                          2903m     ENDM
0000134C                          2904      
0000134C  41F8 0000               2905      LEA STACK,A0
00001350  D1CC                    2906      ADD.L A4,A0
00001352  2010                    2907      MOVE.L (A0),D0
00001354                          2908m     PRINT_REG D0,D2,D3,D4,A3
00001354  47FA 09ED               2909m     LEA OX(PC),A3
00001358                          2910mm     PRINT_STR A3,D2
00001358                          2911mm LOOP_190
00001358  0C13 0000               2912mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000135C  6700 0016               2913mm     BEQ EXIT_190
00001360                          2914mmm     PRINT_CHAR (A3)+,D2
00001360                          2915mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001360                 TRUE     2916mmm     IFEQ DEBUG
00001360  1439 00C00003           2917mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001366  0802 0002               2918mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000136A  67F4                    2919mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
0000136C  13DB 00C00007           2920mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001372                          2921mmm     ENDC
00001372                          2922mmm 
00001372                 FALSE    2923mmm     IFNE DEBUG
00001372                          2924mmm     ENDC
00001372                          2925mmm 
00001372                          2926mmm     ENDM
00001372  60E4                    2927mm     BRA LOOP_190
00001374                          2928mm EXIT_190
00001374                          2929mm     ENDM
00001374  7807                    2930m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001376                          2931m LOOP_189
00001376                          2932mm     BIN2HEX D0,D3,A3
00001376  47FA 0947               2933mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
0000137A  E998                    2934mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000137C  1600                    2935mm     MOVE.B D0,D3
0000137E  0283 0000000F           2936mm     ANDI.L #$F,D3
00001384  1633 3000               2937mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001388                          2938mm     ENDM
00001388                          2939mm     PRINT_CHAR D3,D2
00001388                          2940mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001388                 TRUE     2941mm     IFEQ DEBUG
00001388  1439 00C00003           2942mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000138E  0802 0002               2943mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001392  67F4                    2944mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00001394  13C3 00C00007           2945mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000139A                          2946mm     ENDC
0000139A                          2947mm 
0000139A                 FALSE    2948mm     IFNE DEBUG
0000139A                          2949mm     ENDC
0000139A                          2950mm 
0000139A                          2951mm     ENDM
0000139A  57CC FFDA               2952m     DBEQ D4,LOOP_189
0000139E                          2953m     ENDM
0000139E                          2954m     PRINT_CRLF D2,A2
0000139E  45FA 099D               2955m     LEA CRLF(PC),A2
000013A2                          2956mm     PRINT_STR A2,D2
000013A2                          2957mm LOOP_195
000013A2  0C12 0000               2958mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013A6  6700 0016               2959mm     BEQ EXIT_195
000013AA                          2960mmm     PRINT_CHAR (A2)+,D2
000013AA                          2961mmm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013AA                 TRUE     2962mmm     IFEQ DEBUG
000013AA  1439 00C00003           2963mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013B0  0802 0002               2964mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013B4  67F4                    2965mmm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
000013B6  13DA 00C00007           2966mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013BC                          2967mmm     ENDC
000013BC                          2968mmm 
000013BC                 FALSE    2969mmm     IFNE DEBUG
000013BC                          2970mmm     ENDC
000013BC                          2971mmm 
000013BC                          2972mmm     ENDM
000013BC  60E4                    2973mm     BRA LOOP_195
000013BE                          2974mm EXIT_195
000013BE                          2975mm     ENDM
000013BE                          2976m     ENDM
000013BE                          2977      
000013BE  207C 00000000           2978      MOVE.L #0,A0
000013C4                          2979m     PROGRAM_VECTOR D0,A0,D2
000013C4  5488                    2980m     ADD.L #2,A0
000013C6                          2981mm     PROGRAM D0, (A0), D2                                ; WRITE IT
000013C6  3080                    2982mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000013C8                          2983mm 
000013C8                          2984mm WAIT_FOR_COMPLETE_198
000013C8  3410                    2985mm         MOVE.W (A0),D2
000013CA                          2986mm 
000013CA                          2987mm         IF.W D2 <NE> D0 THEN
000013CA  B440                    2988mms     CMP.W   D0,D2
000013CC  6700 0004               2989mms     BEQ _00000010
000013D0  60F6                    2990mm             BRA WAIT_FOR_COMPLETE_198
000013D2                          2991mm         ENDI
000013D2                          2992mms _00000010
000013D2                          2993mm         ENDM
000013D2  E088                    2994m     LSR.L #8,D0
000013D4  E088                    2995m     LSR.L #8,D0
000013D6  5588                    2996m     SUB.L #2,A0
000013D8                          2997mm     PROGRAM D0, (A0), D2
000013D8  3080                    2998mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000013DA                          2999mm 
000013DA                          3000mm WAIT_FOR_COMPLETE_199
000013DA  3410                    3001mm         MOVE.W (A0),D2
000013DC                          3002mm 
000013DC                          3003mm         IF.W D2 <NE> D0 THEN
000013DC  B440                    3004mms     CMP.W   D0,D2
000013DE  6700 0004               3005mms     BEQ _00000011
000013E2  60F6                    3006mm             BRA WAIT_FOR_COMPLETE_199
000013E4                          3007mm         ENDI
000013E4                          3008mms _00000011
000013E4                          3009mm         ENDM
000013E4                          3010m     ENDM
000013E4                          3011      
000013E4  45FA 0945               3012      LEA VECTORS(PC),A2
000013E8                          3013m     PRINT_STR A2,D2
000013E8                          3014m LOOP_200
000013E8  0C12 0000               3015m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013EC  6700 0016               3016m     BEQ EXIT_200
000013F0                          3017mm     PRINT_CHAR (A2)+,D2
000013F0                          3018mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013F0                 TRUE     3019mm     IFEQ DEBUG
000013F0  1439 00C00003           3020mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013F6  0802 0002               3021mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013FA  67F4                    3022mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
000013FC  13DA 00C00007           3023mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001402                          3024mm     ENDC
00001402                          3025mm 
00001402                 FALSE    3026mm     IFNE DEBUG
00001402                          3027mm     ENDC
00001402                          3028mm 
00001402                          3029mm     ENDM
00001402  60E4                    3030m     BRA LOOP_200
00001404                          3031m EXIT_200
00001404                          3032m     ENDM
00001404                          3033  
00001404                          3034      FOR A0 = #RESET TO #START-4 BY #4 DO
00001404  307C 0004               3035s     MOVE.W  #RESET,A0
00001408  6000 0108               3036s     BRA _2000000F
0000140C                          3037s _2000000E
0000140C                          3038  
0000140C  2248                    3039          MOVE.L A0,A1
0000140E  D3CC                    3040          ADD.L A4,A1
00001410                          3041              
00001410  2011                    3042          MOVE.L (A1),D0  
00001412  D081                    3043          ADD.L D1,D0
00001414  0480 00000400           3044          SUB.L #START,D0
0000141A                          3045m         PRINT_REG D0,D2,D3,D4,A3
0000141A  47FA 0927               3046m     LEA OX(PC),A3
0000141E                          3047mm     PRINT_STR A3,D2
0000141E                          3048mm LOOP_203
0000141E  0C13 0000               3049mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001422  6700 0016               3050mm     BEQ EXIT_203
00001426                          3051mmm     PRINT_CHAR (A3)+,D2
00001426                          3052mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001426                 TRUE     3053mmm     IFEQ DEBUG
00001426  1439 00C00003           3054mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000142C  0802 0002               3055mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001430  67F4                    3056mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001432  13DB 00C00007           3057mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001438                          3058mmm     ENDC
00001438                          3059mmm 
00001438                 FALSE    3060mmm     IFNE DEBUG
00001438                          3061mmm     ENDC
00001438                          3062mmm 
00001438                          3063mmm     ENDM
00001438  60E4                    3064mm     BRA LOOP_203
0000143A                          3065mm EXIT_203
0000143A                          3066mm     ENDM
0000143A  7807                    3067m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000143C                          3068m LOOP_202
0000143C                          3069mm     BIN2HEX D0,D3,A3
0000143C  47FA 0881               3070mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
00001440  E998                    3071mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001442  1600                    3072mm     MOVE.B D0,D3
00001444  0283 0000000F           3073mm     ANDI.L #$F,D3
0000144A  1633 3000               3074mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000144E                          3075mm     ENDM
0000144E                          3076mm     PRINT_CHAR D3,D2
0000144E                          3077mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000144E                 TRUE     3078mm     IFEQ DEBUG
0000144E  1439 00C00003           3079mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001454  0802 0002               3080mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001458  67F4                    3081mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
0000145A  13C3 00C00007           3082mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001460                          3083mm     ENDC
00001460                          3084mm 
00001460                 FALSE    3085mm     IFNE DEBUG
00001460                          3086mm     ENDC
00001460                          3087mm 
00001460                          3088mm     ENDM
00001460  57CC FFDA               3089m     DBEQ D4,LOOP_202
00001464                          3090m     ENDM
00001464                          3091  
00001464  47FA 08E0               3092          LEA TO(PC),A3
00001468                          3093m         PRINT_STR A3,D3
00001468                          3094m LOOP_207
00001468  0C13 0000               3095m     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000146C  6700 0016               3096m     BEQ EXIT_207
00001470                          3097mm     PRINT_CHAR (A3)+,D3
00001470                          3098mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001470                 TRUE     3099mm     IFEQ DEBUG
00001470  1639 00C00003           3100mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001476  0803 0002               3101mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000147A  67F4                    3102mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
0000147C  13DB 00C00007           3103mm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001482                          3104mm     ENDC
00001482                          3105mm 
00001482                 FALSE    3106mm     IFNE DEBUG
00001482                          3107mm     ENDC
00001482                          3108mm 
00001482                          3109mm     ENDM
00001482  60E4                    3110m     BRA LOOP_207
00001484                          3111m EXIT_207
00001484                          3112m     ENDM
00001484                          3113  
00001484  2408                    3114          MOVE.L A0,D2
00001486                          3115m         PRINT_REG D2,D3,D4,D5,A3
00001486  47FA 08BB               3116m     LEA OX(PC),A3
0000148A                          3117mm     PRINT_STR A3,D3
0000148A                          3118mm LOOP_210
0000148A  0C13 0000               3119mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000148E  6700 0016               3120mm     BEQ EXIT_210
00001492                          3121mmm     PRINT_CHAR (A3)+,D3
00001492                          3122mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001492                 TRUE     3123mmm     IFEQ DEBUG
00001492  1639 00C00003           3124mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001498  0803 0002               3125mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000149C  67F4                    3126mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0000149E  13DB 00C00007           3127mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014A4                          3128mmm     ENDC
000014A4                          3129mmm 
000014A4                 FALSE    3130mmm     IFNE DEBUG
000014A4                          3131mmm     ENDC
000014A4                          3132mmm 
000014A4                          3133mmm     ENDM
000014A4  60E4                    3134mm     BRA LOOP_210
000014A6                          3135mm EXIT_210
000014A6                          3136mm     ENDM
000014A6  7A07                    3137m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014A8                          3138m LOOP_209
000014A8                          3139mm     BIN2HEX D2,D4,A3
000014A8  47FA 0815               3140mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000014AC  E99A                    3141mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014AE  1802                    3142mm     MOVE.B D2,D4
000014B0  0284 0000000F           3143mm     ANDI.L #$F,D4
000014B6  1833 4000               3144mm     MOVE.B 0(A3,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000014BA                          3145mm     ENDM
000014BA                          3146mm     PRINT_CHAR D4,D3
000014BA                          3147mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014BA                 TRUE     3148mm     IFEQ DEBUG
000014BA  1639 00C00003           3149mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000014C0  0803 0002               3150mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000014C4  67F4                    3151mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
000014C6  13C4 00C00007           3152mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014CC                          3153mm     ENDC
000014CC                          3154mm 
000014CC                 FALSE    3155mm     IFNE DEBUG
000014CC                          3156mm     ENDC
000014CC                          3157mm 
000014CC                          3158mm     ENDM
000014CC  57CD FFDA               3159m     DBEQ D5,LOOP_209
000014D0                          3160m     ENDM
000014D0                          3161          
000014D0                          3162m         PRINT_CRLF D2,A3
000014D0  47FA 086B               3163m     LEA CRLF(PC),A3
000014D4                          3164mm     PRINT_STR A3,D2
000014D4                          3165mm LOOP_215
000014D4  0C13 0000               3166mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000014D8  6700 0016               3167mm     BEQ EXIT_215
000014DC                          3168mmm     PRINT_CHAR (A3)+,D2
000014DC                          3169mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014DC                 TRUE     3170mmm     IFEQ DEBUG
000014DC  1439 00C00003           3171mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014E2  0802 0002               3172mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014E6  67F4                    3173mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
000014E8  13DB 00C00007           3174mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014EE                          3175mmm     ENDC
000014EE                          3176mmm 
000014EE                 FALSE    3177mmm     IFNE DEBUG
000014EE                          3178mmm     ENDC
000014EE                          3179mmm 
000014EE                          3180mmm     ENDM
000014EE  60E4                    3181mm     BRA LOOP_215
000014F0                          3182mm EXIT_215
000014F0                          3183mm     ENDM
000014F0                          3184m     ENDM
000014F0                          3185          
000014F0                          3186m         PROGRAM_VECTOR D0,A0,D2
000014F0  5488                    3187m     ADD.L #2,A0
000014F2                          3188mm     PROGRAM D0, (A0), D2                                ; WRITE IT
000014F2  3080                    3189mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000014F4                          3190mm 
000014F4                          3191mm WAIT_FOR_COMPLETE_218
000014F4  3410                    3192mm         MOVE.W (A0),D2
000014F6                          3193mm 
000014F6                          3194mm         IF.W D2 <NE> D0 THEN
000014F6  B440                    3195mms     CMP.W   D0,D2
000014F8  6700 0004               3196mms     BEQ _00000012
000014FC  60F6                    3197mm             BRA WAIT_FOR_COMPLETE_218
000014FE                          3198mm         ENDI
000014FE                          3199mms _00000012
000014FE                          3200mm         ENDM
000014FE  E088                    3201m     LSR.L #8,D0
00001500  E088                    3202m     LSR.L #8,D0
00001502  5588                    3203m     SUB.L #2,A0
00001504                          3204mm     PROGRAM D0, (A0), D2
00001504  3080                    3205mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001506                          3206mm 
00001506                          3207mm WAIT_FOR_COMPLETE_219
00001506  3410                    3208mm         MOVE.W (A0),D2
00001508                          3209mm 
00001508                          3210mm         IF.W D2 <NE> D0 THEN
00001508  B440                    3211mms     CMP.W   D0,D2
0000150A  6700 0004               3212mms     BEQ _00000013
0000150E  60F6                    3213mm             BRA WAIT_FOR_COMPLETE_219
00001510                          3214mm         ENDI
00001510                          3215mms _00000013
00001510                          3216mm         ENDM
00001510                          3217m     ENDM
00001510                          3218      ENDF
00001510  5848                    3219s     ADD.W   #4,A0
00001512                          3220s _2000000F
00001512  B0FC 03FC               3221s     CMP.W   #START-4,A0
00001516  6F00 FEF4               3222s     BLE _2000000E
0000151A                          3223                                          
0000151A                          3224m     PROTECT
0000151A  31FC AAAA 2AAA          3225m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001520  31FC 5555 1554          3226m     MOVE.W #$5555,$1554
00001526  31FC A0A0 2AAA          3227m     MOVE.W #$A0A0,$2AAA
0000152C                          3228m     ENDM
0000152C                          3229  
0000152C  6000 F12E               3230      BRA MAIN_LOOP
00001530                          3231      
00001530                          3232  P
00001530  7000                    3233      MOVE.L #0,D0                                    ; D0 will be the data to write
00001532                          3234  
00001532                          3235      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00001532  323C 0000               3236s     MOVE.W  #0,D1
00001536  6000 0046               3237s     BRA _20000011
0000153A                          3238s _20000010
0000153A  E988                    3239          LSL.L #4,D0                                 ; make what we have so far more significant
0000153C                          3240m         WAIT_CHAR D2,D3                             ; next character -> D2
0000153C                          3241m WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000153C                 TRUE     3242m     IFEQ DEBUG
0000153C  1639 00C00003           3243m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001542  0803 0000               3244m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001546  67F4                    3245m         BEQ WAIT_FOR_READY_221                      ; NOTHING, CHECK AGAIN
00001548                          3246m     ENDC
00001548                          3247m 
00001548                          3248mm     READ_CHAR D2
00001548                 TRUE     3249mm     IFEQ DEBUG
00001548  1439 00C00007           3250mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000154E                          3251mm     ENDC
0000154E                 FALSE    3252mm     IFNE DEBUG
0000154E                          3253mm     ENDC
0000154E                          3254mm 
0000154E  B43C 001B               3255mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001552  6700 EEAC               3256mm     BEQ START
00001556                          3257mm     ENDM
00001556                          3258m 
00001556                 TRUE     3259m     IFEQ DEBUG
00001556                          3260mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001556                          3261mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001556                 TRUE     3262mm     IFEQ DEBUG
00001556  1639 00C00003           3263mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000155C  0803 0002               3264mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001560  67F4                    3265mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
00001562  13C2 00C00007           3266mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001568                          3267mm     ENDC
00001568                          3268mm 
00001568                 FALSE    3269mm     IFNE DEBUG
00001568                          3270mm     ENDC
00001568                          3271mm 
00001568                          3272mm     ENDM
00001568                          3273m     ENDC
00001568                          3274m     ENDM
00001568                          3275m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001568  41FA 0765               3276m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000156C  0402 0030               3277m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001570  C4BC 000000FF           3278m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001576  1430 2000               3279m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000157A                          3280m     ENDM
0000157A  8002                    3281          OR.B D2,D0
0000157C                          3282      ENDF
0000157C  5241                    3283s     ADD.W   #1,D1
0000157E                          3284s _20000011
0000157E  B27C 0003               3285s     CMP.W   #3,D1
00001582  6FB6                    3286s     BLE _20000010
00001584                          3287  
00001584                          3288m     PRINT_CRLF D2,A1
00001584  43FA 07B7               3289m     LEA CRLF(PC),A1
00001588                          3290mm     PRINT_STR A1,D2
00001588                          3291mm LOOP_226
00001588  0C11 0000               3292mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000158C  6700 0016               3293mm     BEQ EXIT_226
00001590                          3294mmm     PRINT_CHAR (A1)+,D2
00001590                          3295mmm WAIT_FOR_READY_227                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001590                 TRUE     3296mmm     IFEQ DEBUG
00001590  1439 00C00003           3297mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001596  0802 0002               3298mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000159A  67F4                    3299mmm         BEQ WAIT_FOR_READY_227                      ; NO SPACE, CHECK AGAIN
0000159C  13D9 00C00007           3300mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015A2                          3301mmm     ENDC
000015A2                          3302mmm 
000015A2                 FALSE    3303mmm     IFNE DEBUG
000015A2                          3304mmm     ENDC
000015A2                          3305mmm 
000015A2                          3306mmm     ENDM
000015A2  60E4                    3307mm     BRA LOOP_226
000015A4                          3308mm EXIT_226
000015A4                          3309mm     ENDM
000015A4                          3310m     ENDM
000015A4                          3311  
000015A4  2047                    3312      MOVE.L D7,A0                                    ; address accumulator -> target address register
000015A6  7E00                    3313      MOVE.L #0,D7                                    ; clear the now used address accumulator
000015A8                          3314  
000015A8                          3315m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000015A8  31FC AAAA 2AAA          3316m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000015AE  4E71                    3317m     NOP
000015B0  31FC 5555 1554          3318m     MOVE.W #$5555,$1554
000015B6  4E71                    3319m     NOP
000015B8  31FC 8080 2AAA          3320m     MOVE.W #$8080,$2AAA
000015BE  4E71                    3321m     NOP
000015C0  31FC AAAA 2AAA          3322m     MOVE.W #$AAAA,$2AAA
000015C6  4E71                    3323m     NOP
000015C8  31FC 5555 1554          3324m     MOVE.W #$5555,$1554
000015CE  4E71                    3325m     NOP
000015D0  31FC 2020 2AAA          3326m     MOVE.W #$2020,$2AAA
000015D6                          3327m     ENDM
000015D6                          3328                              
000015D6                          3329      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000015D6  3E3C 0000               3330s     MOVE.W  #$0,D7
000015DA  6000 0006               3331s     BRA _20000013
000015DE                          3332s _20000012
000015DE  4E71                    3333          NOP
000015E0                          3334      ENDF
000015E0  5247                    3335s     ADD.W   #1,D7
000015E2                          3336s _20000013
000015E2  BE7C FFFF               3337s     CMP.W   #$FFFFFFFF,D7
000015E6  6FF6                    3338s     BLE _20000012
000015E8                          3339               
000015E8  45FA 06FC               3340      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
000015EC                          3341m     PRINT_STR A2,D2
000015EC                          3342m LOOP_229
000015EC  0C12 0000               3343m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000015F0  6700 0016               3344m     BEQ EXIT_229
000015F4                          3345mm     PRINT_CHAR (A2)+,D2
000015F4                          3346mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015F4                 TRUE     3347mm     IFEQ DEBUG
000015F4  1439 00C00003           3348mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000015FA  0802 0002               3349mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000015FE  67F4                    3350mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
00001600  13DA 00C00007           3351mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001606                          3352mm     ENDC
00001606                          3353mm 
00001606                 FALSE    3354mm     IFNE DEBUG
00001606                          3355mm     ENDC
00001606                          3356mm 
00001606                          3357mm     ENDM
00001606  60E4                    3358m     BRA LOOP_229
00001608                          3359m EXIT_229
00001608                          3360m     ENDM
00001608                          3361  
00001608                          3362m     PRINT_REG D0,D3,D4,D5,A2
00001608  45FA 0739               3363m     LEA OX(PC),A2
0000160C                          3364mm     PRINT_STR A2,D3
0000160C                          3365mm LOOP_232
0000160C  0C12 0000               3366mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001610  6700 0016               3367mm     BEQ EXIT_232
00001614                          3368mmm     PRINT_CHAR (A2)+,D3
00001614                          3369mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001614                 TRUE     3370mmm     IFEQ DEBUG
00001614  1639 00C00003           3371mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000161A  0803 0002               3372mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000161E  67F4                    3373mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001620  13DA 00C00007           3374mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001626                          3375mmm     ENDC
00001626                          3376mmm 
00001626                 FALSE    3377mmm     IFNE DEBUG
00001626                          3378mmm     ENDC
00001626                          3379mmm 
00001626                          3380mmm     ENDM
00001626  60E4                    3381mm     BRA LOOP_232
00001628                          3382mm EXIT_232
00001628                          3383mm     ENDM
00001628  7A07                    3384m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000162A                          3385m LOOP_231
0000162A                          3386mm     BIN2HEX D0,D4,A2
0000162A  45FA 0693               3387mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000162E  E998                    3388mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001630  1800                    3389mm     MOVE.B D0,D4
00001632  0284 0000000F           3390mm     ANDI.L #$F,D4
00001638  1832 4000               3391mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000163C                          3392mm     ENDM
0000163C                          3393mm     PRINT_CHAR D4,D3
0000163C                          3394mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000163C                 TRUE     3395mm     IFEQ DEBUG
0000163C  1639 00C00003           3396mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001642  0803 0002               3397mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001646  67F4                    3398mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
00001648  13C4 00C00007           3399mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000164E                          3400mm     ENDC
0000164E                          3401mm 
0000164E                 FALSE    3402mm     IFNE DEBUG
0000164E                          3403mm     ENDC
0000164E                          3404mm 
0000164E                          3405mm     ENDM
0000164E  57CD FFDA               3406m     DBEQ D5,LOOP_231
00001652                          3407m     ENDM
00001652                          3408  
00001652  45FA 06F2               3409      LEA TO(PC),A2
00001656                          3410m     PRINT_STR A2,D3
00001656                          3411m LOOP_236
00001656  0C12 0000               3412m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000165A  6700 0016               3413m     BEQ EXIT_236
0000165E                          3414mm     PRINT_CHAR (A2)+,D3
0000165E                          3415mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000165E                 TRUE     3416mm     IFEQ DEBUG
0000165E  1639 00C00003           3417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001664  0803 0002               3418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001668  67F4                    3419mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
0000166A  13DA 00C00007           3420mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001670                          3421mm     ENDC
00001670                          3422mm 
00001670                 FALSE    3423mm     IFNE DEBUG
00001670                          3424mm     ENDC
00001670                          3425mm 
00001670                          3426mm     ENDM
00001670  60E4                    3427m     BRA LOOP_236
00001672                          3428m EXIT_236
00001672                          3429m     ENDM
00001672                          3430  
00001672  2408                    3431      MOVE.L A0,D2
00001674                          3432m     PRINT_REG D2,D3,D4,D5,A2
00001674  45FA 06CD               3433m     LEA OX(PC),A2
00001678                          3434mm     PRINT_STR A2,D3
00001678                          3435mm LOOP_239
00001678  0C12 0000               3436mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000167C  6700 0016               3437mm     BEQ EXIT_239
00001680                          3438mmm     PRINT_CHAR (A2)+,D3
00001680                          3439mmm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001680                 TRUE     3440mmm     IFEQ DEBUG
00001680  1639 00C00003           3441mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001686  0803 0002               3442mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000168A  67F4                    3443mmm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
0000168C  13DA 00C00007           3444mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001692                          3445mmm     ENDC
00001692                          3446mmm 
00001692                 FALSE    3447mmm     IFNE DEBUG
00001692                          3448mmm     ENDC
00001692                          3449mmm 
00001692                          3450mmm     ENDM
00001692  60E4                    3451mm     BRA LOOP_239
00001694                          3452mm EXIT_239
00001694                          3453mm     ENDM
00001694  7A07                    3454m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001696                          3455m LOOP_238
00001696                          3456mm     BIN2HEX D2,D4,A2
00001696  45FA 0627               3457mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000169A  E99A                    3458mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000169C  1802                    3459mm     MOVE.B D2,D4
0000169E  0284 0000000F           3460mm     ANDI.L #$F,D4
000016A4  1832 4000               3461mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000016A8                          3462mm     ENDM
000016A8                          3463mm     PRINT_CHAR D4,D3
000016A8                          3464mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016A8                 TRUE     3465mm     IFEQ DEBUG
000016A8  1639 00C00003           3466mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016AE  0803 0002               3467mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016B2  67F4                    3468mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
000016B4  13C4 00C00007           3469mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000016BA                          3470mm     ENDC
000016BA                          3471mm 
000016BA                 FALSE    3472mm     IFNE DEBUG
000016BA                          3473mm     ENDC
000016BA                          3474mm 
000016BA                          3475mm     ENDM
000016BA  57CD FFDA               3476m     DBEQ D5,LOOP_238
000016BE                          3477m     ENDM
000016BE                          3478  
000016BE                          3479m     PRINT_CRLF D3,A2
000016BE  45FA 067D               3480m     LEA CRLF(PC),A2
000016C2                          3481mm     PRINT_STR A2,D3
000016C2                          3482mm LOOP_244
000016C2  0C12 0000               3483mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016C6  6700 0016               3484mm     BEQ EXIT_244
000016CA                          3485mmm     PRINT_CHAR (A2)+,D3
000016CA                          3486mmm WAIT_FOR_READY_245                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016CA                 TRUE     3487mmm     IFEQ DEBUG
000016CA  1639 00C00003           3488mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016D0  0803 0002               3489mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016D4  67F4                    3490mmm         BEQ WAIT_FOR_READY_245                      ; NO SPACE, CHECK AGAIN
000016D6  13DA 00C00007           3491mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016DC                          3492mmm     ENDC
000016DC                          3493mmm 
000016DC                 FALSE    3494mmm     IFNE DEBUG
000016DC                          3495mmm     ENDC
000016DC                          3496mmm 
000016DC                          3497mmm     ENDM
000016DC  60E4                    3498mm     BRA LOOP_244
000016DE                          3499mm EXIT_244
000016DE                          3500mm     ENDM
000016DE                          3501m     ENDM
000016DE                          3502  
000016DE                          3503m     PROGRAM D0,(A0),D2
000016DE  3080                    3504m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000016E0                          3505m 
000016E0                          3506m WAIT_FOR_COMPLETE_246
000016E0  3410                    3507m         MOVE.W (A0),D2
000016E2                          3508m 
000016E2                          3509m         IF.W D2 <NE> D0 THEN
000016E2  B440                    3510ms     CMP.W   D0,D2
000016E4  6700 0004               3511ms     BEQ _00000014
000016E8  60F6                    3512m             BRA WAIT_FOR_COMPLETE_246
000016EA                          3513m         ENDI
000016EA                          3514ms _00000014
000016EA                          3515m         ENDM
000016EA                          3516  
000016EA                          3517m     PROTECT
000016EA  31FC AAAA 2AAA          3518m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000016F0  31FC 5555 1554          3519m     MOVE.W #$5555,$1554
000016F6  31FC A0A0 2AAA          3520m     MOVE.W #$A0A0,$2AAA
000016FC                          3521m     ENDM
000016FC                          3522  
000016FC  6000 EF5E               3523      BRA MAIN_LOOP
00001700                          3524      
00001700                          3525  M
00001700  7000                    3526      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001702  7200                    3527      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001704                          3528  
00001704                          3529      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001704  343C 0000               3530s     MOVE.W  #0,D2
00001708  6000 0046               3531s     BRA _20000015
0000170C                          3532s _20000014
0000170C  E989                    3533          LSL.L #4,D1                                     ; make what we have so far more significant
0000170E                          3534m         WAIT_CHAR D3,D4                                 ; next character -> D2
0000170E                          3535m WAIT_FOR_READY_248                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000170E                 TRUE     3536m     IFEQ DEBUG
0000170E  1839 00C00003           3537m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001714  0804 0000               3538m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001718  67F4                    3539m         BEQ WAIT_FOR_READY_248                      ; NOTHING, CHECK AGAIN
0000171A                          3540m     ENDC
0000171A                          3541m 
0000171A                          3542mm     READ_CHAR D3
0000171A                 TRUE     3543mm     IFEQ DEBUG
0000171A  1639 00C00007           3544mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001720                          3545mm     ENDC
00001720                 FALSE    3546mm     IFNE DEBUG
00001720                          3547mm     ENDC
00001720                          3548mm 
00001720  B63C 001B               3549mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001724  6700 ECDA               3550mm     BEQ START
00001728                          3551mm     ENDM
00001728                          3552m 
00001728                 TRUE     3553m     IFEQ DEBUG
00001728                          3554mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001728                          3555mm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001728                 TRUE     3556mm     IFEQ DEBUG
00001728  1839 00C00003           3557mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000172E  0804 0002               3558mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001732  67F4                    3559mm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
00001734  13C3 00C00007           3560mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000173A                          3561mm     ENDC
0000173A                          3562mm 
0000173A                 FALSE    3563mm     IFNE DEBUG
0000173A                          3564mm     ENDC
0000173A                          3565mm 
0000173A                          3566mm     ENDM
0000173A                          3567m     ENDC
0000173A                          3568m     ENDM
0000173A                          3569m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
0000173A  41FA 0593               3570m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000173E  0403 0030               3571m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001742  C6BC 000000FF           3572m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00001748  1630 3000               3573m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
0000174C                          3574m     ENDM
0000174C  8203                    3575          OR.B D3,D1
0000174E                          3576      ENDF
0000174E  5242                    3577s     ADD.W   #1,D2
00001750                          3578s _20000015
00001750  B47C 0007               3579s     CMP.W   #7,D2
00001754  6FB6                    3580s     BLE _20000014
00001756                          3581m     PRINT_CRLF D2,A1
00001756  43FA 05E5               3582m     LEA CRLF(PC),A1
0000175A                          3583mm     PRINT_STR A1,D2
0000175A                          3584mm LOOP_253
0000175A  0C11 0000               3585mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000175E  6700 0016               3586mm     BEQ EXIT_253
00001762                          3587mmm     PRINT_CHAR (A1)+,D2
00001762                          3588mmm WAIT_FOR_READY_254                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001762                 TRUE     3589mmm     IFEQ DEBUG
00001762  1439 00C00003           3590mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001768  0802 0002               3591mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000176C  67F4                    3592mmm         BEQ WAIT_FOR_READY_254                      ; NO SPACE, CHECK AGAIN
0000176E  13D9 00C00007           3593mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001774                          3594mmm     ENDC
00001774                          3595mmm 
00001774                 FALSE    3596mmm     IFNE DEBUG
00001774                          3597mmm     ENDC
00001774                          3598mmm 
00001774                          3599mmm     ENDM
00001774  60E4                    3600mm     BRA LOOP_253
00001776                          3601mm EXIT_253
00001776                          3602mm     ENDM
00001776                          3603m     ENDM
00001776                          3604  
00001776  3001                    3605      MOVE.W D1,D0                                        ; extract the LSword for the length
00001778  E089                    3606      LSR.L #8,D1                                         ; extract the MSword for the address
0000177A  E089                    3607      LSR.L #8,D1
0000177C                          3608  
0000177C  2241                    3609      MOVE.L D1,A1
0000177E                          3610      
0000177E  2047                    3611      MOVE.L D7,A0                                        ; address accumulator -> target address register
00001780                          3612      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00001780                          3613  
00001780                          3614      WHILE D0 <GT> #0 DO
00001780                          3615s _10000016
00001780  B07C 0000               3616s     CMP.W   #0,D0
00001784  6F00 000E               3617s     BLE _10000017
00001788  5580                    3618          SUB.L #2,D0
0000178A                          3619  
0000178A  13D1 00E00001           3620          MOVE.B (A1),DISPLAY
00001790  30D9                    3621          MOVE.W (A1)+,(A0)+
00001792                          3622      ENDW
00001792  60EC                    3623s     BRA _10000016
00001794                          3624s _10000017
00001794                          3625      
00001794  6000 EEC6               3626      BRA MAIN_LOOP
00001798                          3627  
00001798                          3628  X
00001798  45FA 05B6               3629      LEA STATUS_REGISTER(PC),A2
0000179C                          3630m     PRINT_STR A2,D3
0000179C                          3631m LOOP_255
0000179C  0C12 0000               3632m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000017A0  6700 0016               3633m     BEQ EXIT_255
000017A4                          3634mm     PRINT_CHAR (A2)+,D3
000017A4                          3635mm WAIT_FOR_READY_256                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017A4                 TRUE     3636mm     IFEQ DEBUG
000017A4  1639 00C00003           3637mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000017AA  0803 0002               3638mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000017AE  67F4                    3639mm         BEQ WAIT_FOR_READY_256                      ; NO SPACE, CHECK AGAIN
000017B0  13DA 00C00007           3640mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017B6                          3641mm     ENDC
000017B6                          3642mm 
000017B6                 FALSE    3643mm     IFNE DEBUG
000017B6                          3644mm     ENDC
000017B6                          3645mm 
000017B6                          3646mm     ENDM
000017B6  60E4                    3647m     BRA LOOP_255
000017B8                          3648m EXIT_255
000017B8                          3649m     ENDM
000017B8                          3650  
000017B8  40C0                    3651      MOVE SR,D0
000017BA                          3652m     PRINT_REG D0,D3,D4,D5,A2
000017BA  45FA 0587               3653m     LEA OX(PC),A2
000017BE                          3654mm     PRINT_STR A2,D3
000017BE                          3655mm LOOP_258
000017BE  0C12 0000               3656mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000017C2  6700 0016               3657mm     BEQ EXIT_258
000017C6                          3658mmm     PRINT_CHAR (A2)+,D3
000017C6                          3659mmm WAIT_FOR_READY_259                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017C6                 TRUE     3660mmm     IFEQ DEBUG
000017C6  1639 00C00003           3661mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000017CC  0803 0002               3662mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000017D0  67F4                    3663mmm         BEQ WAIT_FOR_READY_259                      ; NO SPACE, CHECK AGAIN
000017D2  13DA 00C00007           3664mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017D8                          3665mmm     ENDC
000017D8                          3666mmm 
000017D8                 FALSE    3667mmm     IFNE DEBUG
000017D8                          3668mmm     ENDC
000017D8                          3669mmm 
000017D8                          3670mmm     ENDM
000017D8  60E4                    3671mm     BRA LOOP_258
000017DA                          3672mm EXIT_258
000017DA                          3673mm     ENDM
000017DA  7A07                    3674m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000017DC                          3675m LOOP_257
000017DC                          3676mm     BIN2HEX D0,D4,A2
000017DC  45FA 04E1               3677mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000017E0  E998                    3678mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000017E2  1800                    3679mm     MOVE.B D0,D4
000017E4  0284 0000000F           3680mm     ANDI.L #$F,D4
000017EA  1832 4000               3681mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000017EE                          3682mm     ENDM
000017EE                          3683mm     PRINT_CHAR D4,D3
000017EE                          3684mm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017EE                 TRUE     3685mm     IFEQ DEBUG
000017EE  1639 00C00003           3686mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000017F4  0803 0002               3687mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000017F8  67F4                    3688mm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000017FA  13C4 00C00007           3689mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001800                          3690mm     ENDC
00001800                          3691mm 
00001800                 FALSE    3692mm     IFNE DEBUG
00001800                          3693mm     ENDC
00001800                          3694mm 
00001800                          3695mm     ENDM
00001800  57CD FFDA               3696m     DBEQ D5,LOOP_257
00001804                          3697m     ENDM
00001804                          3698m     PRINT_CRLF D3,A2
00001804  45FA 0537               3699m     LEA CRLF(PC),A2
00001808                          3700mm     PRINT_STR A2,D3
00001808                          3701mm LOOP_263
00001808  0C12 0000               3702mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000180C  6700 0016               3703mm     BEQ EXIT_263
00001810                          3704mmm     PRINT_CHAR (A2)+,D3
00001810                          3705mmm WAIT_FOR_READY_264                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001810                 TRUE     3706mmm     IFEQ DEBUG
00001810  1639 00C00003           3707mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001816  0803 0002               3708mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000181A  67F4                    3709mmm         BEQ WAIT_FOR_READY_264                      ; NO SPACE, CHECK AGAIN
0000181C  13DA 00C00007           3710mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001822                          3711mmm     ENDC
00001822                          3712mmm 
00001822                 FALSE    3713mmm     IFNE DEBUG
00001822                          3714mmm     ENDC
00001822                          3715mmm 
00001822                          3716mmm     ENDM
00001822  60E4                    3717mm     BRA LOOP_263
00001824                          3718mm EXIT_263
00001824                          3719mm     ENDM
00001824                          3720m     ENDM
00001824                          3721  
00001824  45FA 0525               3722      LEA STACK_POINTER(PC),A2
00001828                          3723m     PRINT_STR A2,D3
00001828                          3724m LOOP_265
00001828  0C12 0000               3725m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000182C  6700 0016               3726m     BEQ EXIT_265
00001830                          3727mm     PRINT_CHAR (A2)+,D3
00001830                          3728mm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001830                 TRUE     3729mm     IFEQ DEBUG
00001830  1639 00C00003           3730mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001836  0803 0002               3731mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000183A  67F4                    3732mm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
0000183C  13DA 00C00007           3733mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001842                          3734mm     ENDC
00001842                          3735mm 
00001842                 FALSE    3736mm     IFNE DEBUG
00001842                          3737mm     ENDC
00001842                          3738mm 
00001842                          3739mm     ENDM
00001842  60E4                    3740m     BRA LOOP_265
00001844                          3741m EXIT_265
00001844                          3742m     ENDM
00001844                          3743  
00001844  200F                    3744      MOVE.L SP,D0
00001846                          3745m     PRINT_REG D0,D3,D4,D5,A2
00001846  45FA 04FB               3746m     LEA OX(PC),A2
0000184A                          3747mm     PRINT_STR A2,D3
0000184A                          3748mm LOOP_268
0000184A  0C12 0000               3749mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000184E  6700 0016               3750mm     BEQ EXIT_268
00001852                          3751mmm     PRINT_CHAR (A2)+,D3
00001852                          3752mmm WAIT_FOR_READY_269                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001852                 TRUE     3753mmm     IFEQ DEBUG
00001852  1639 00C00003           3754mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001858  0803 0002               3755mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000185C  67F4                    3756mmm         BEQ WAIT_FOR_READY_269                      ; NO SPACE, CHECK AGAIN
0000185E  13DA 00C00007           3757mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001864                          3758mmm     ENDC
00001864                          3759mmm 
00001864                 FALSE    3760mmm     IFNE DEBUG
00001864                          3761mmm     ENDC
00001864                          3762mmm 
00001864                          3763mmm     ENDM
00001864  60E4                    3764mm     BRA LOOP_268
00001866                          3765mm EXIT_268
00001866                          3766mm     ENDM
00001866  7A07                    3767m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001868                          3768m LOOP_267
00001868                          3769mm     BIN2HEX D0,D4,A2
00001868  45FA 0455               3770mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000186C  E998                    3771mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000186E  1800                    3772mm     MOVE.B D0,D4
00001870  0284 0000000F           3773mm     ANDI.L #$F,D4
00001876  1832 4000               3774mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000187A                          3775mm     ENDM
0000187A                          3776mm     PRINT_CHAR D4,D3
0000187A                          3777mm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000187A                 TRUE     3778mm     IFEQ DEBUG
0000187A  1639 00C00003           3779mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001880  0803 0002               3780mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001884  67F4                    3781mm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
00001886  13C4 00C00007           3782mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000188C                          3783mm     ENDC
0000188C                          3784mm 
0000188C                 FALSE    3785mm     IFNE DEBUG
0000188C                          3786mm     ENDC
0000188C                          3787mm 
0000188C                          3788mm     ENDM
0000188C  57CD FFDA               3789m     DBEQ D5,LOOP_267
00001890                          3790m     ENDM
00001890                          3791m     PRINT_CRLF D3,A2
00001890  45FA 04AB               3792m     LEA CRLF(PC),A2
00001894                          3793mm     PRINT_STR A2,D3
00001894                          3794mm LOOP_273
00001894  0C12 0000               3795mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001898  6700 0016               3796mm     BEQ EXIT_273
0000189C                          3797mmm     PRINT_CHAR (A2)+,D3
0000189C                          3798mmm WAIT_FOR_READY_274                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000189C                 TRUE     3799mmm     IFEQ DEBUG
0000189C  1639 00C00003           3800mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000018A2  0803 0002               3801mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000018A6  67F4                    3802mmm         BEQ WAIT_FOR_READY_274                      ; NO SPACE, CHECK AGAIN
000018A8  13DA 00C00007           3803mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018AE                          3804mmm     ENDC
000018AE                          3805mmm 
000018AE                 FALSE    3806mmm     IFNE DEBUG
000018AE                          3807mmm     ENDC
000018AE                          3808mmm 
000018AE                          3809mmm     ENDM
000018AE  60E4                    3810mm     BRA LOOP_273
000018B0                          3811mm EXIT_273
000018B0                          3812mm     ENDM
000018B0                          3813m     ENDM
000018B0                          3814  
000018B0  6000 EDAA               3815      BRA MAIN_LOOP
000018B4                          3816  
000018B4                          3817          
000018B4                          3818  I
000018B4  027C F8FF               3819      AND.W #$F8FF,SR
000018B8  6000 EDA2               3820      BRA MAIN_LOOP
000018BC                          3821      
000018BC                          3822  O
000018BC  007C 0700               3823      OR.W #$0700,SR
000018C0  6000 ED9A               3824      BRA MAIN_LOOP
000018C4                          3825          
000018C4                          3826  HASH
000018C4                          3827m     PROTECT
000018C4  31FC AAAA 2AAA          3828m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000018CA  31FC 5555 1554          3829m     MOVE.W #$5555,$1554
000018D0  31FC A0A0 2AAA          3830m     MOVE.W #$A0A0,$2AAA
000018D6                          3831m     ENDM
000018D6  6000 ED84               3832      BRA MAIN_LOOP
000018DA                          3833  
000018DA                          3834  
000018DA                          3835  
000018DA                          3836  HEX_DIGIT
000018DA  E98F                    3837      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000018DC                          3838m     HEX2BIN D2,D2,A0
000018DC  41FA 03F1               3839m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000018E0  0402 0030               3840m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000018E4  C4BC 000000FF           3841m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000018EA  1430 2000               3842m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000018EE                          3843m     ENDM
000018EE  8E02                    3844      OR.B D2,D7  
000018F0  6000 ED8A               3845      BRA GET_INPUT
000018F4                          3846  
000018F4  FFFF FFFF               3847      SIMHALT                                             ; halt simulator
000018F8                          3848  
000018F8                          3849  ; exceptions    
000018F8                          3850  BUS_ERROR_HANDLER
000018F8                          3851  
000018F8  41FA 0462               3852      LEA BUS_ERROR(PC),A0
000018FC                          3853m     PRINT_STR A0,D1
000018FC                          3854m LOOP_277
000018FC  0C10 0000               3855m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001900  6700 0016               3856m     BEQ EXIT_277
00001904                          3857mm     PRINT_CHAR (A0)+,D1
00001904                          3858mm WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001904                 TRUE     3859mm     IFEQ DEBUG
00001904  1239 00C00003           3860mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000190A  0801 0002               3861mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000190E  67F4                    3862mm         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
00001910  13D8 00C00007           3863mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001916                          3864mm     ENDC
00001916                          3865mm 
00001916                 FALSE    3866mm     IFNE DEBUG
00001916                          3867mm     ENDC
00001916                          3868mm 
00001916                          3869mm     ENDM
00001916  60E4                    3870m     BRA LOOP_277
00001918                          3871m EXIT_277
00001918                          3872m     ENDM
00001918                          3873  
00001918  7000                    3874      MOVE.L #0,D0
0000191A  3017                    3875      MOVE.W (SP),D0
0000191C                          3876  
0000191C  0800 0004               3877      BTST #4,D0
00001920  6700 0026               3878      BEQ WRITE
00001924                          3879      
00001924  41FA 044B               3880      LEA READING(PC),A0
00001928                          3881m     PRINT_STR A0,D1
00001928                          3882m LOOP_279
00001928  0C10 0000               3883m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000192C  6700 0016               3884m     BEQ EXIT_279
00001930                          3885mm     PRINT_CHAR (A0)+,D1
00001930                          3886mm WAIT_FOR_READY_280                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001930                 TRUE     3887mm     IFEQ DEBUG
00001930  1239 00C00003           3888mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001936  0801 0002               3889mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000193A  67F4                    3890mm         BEQ WAIT_FOR_READY_280                      ; NO SPACE, CHECK AGAIN
0000193C  13D8 00C00007           3891mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001942                          3892mm     ENDC
00001942                          3893mm 
00001942                 FALSE    3894mm     IFNE DEBUG
00001942                          3895mm     ENDC
00001942                          3896mm 
00001942                          3897mm     ENDM
00001942  60E4                    3898m     BRA LOOP_279
00001944                          3899m EXIT_279
00001944                          3900m     ENDM
00001944                          3901  
00001944  6000 0022               3902      BRA CONTINUE    
00001948                          3903  WRITE
00001948  41FA 0430               3904      LEA WRITING(PC),A0
0000194C                          3905m     PRINT_STR A0,D1
0000194C                          3906m LOOP_281
0000194C  0C10 0000               3907m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001950  6700 0016               3908m     BEQ EXIT_281
00001954                          3909mm     PRINT_CHAR (A0)+,D1
00001954                          3910mm WAIT_FOR_READY_282                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001954                 TRUE     3911mm     IFEQ DEBUG
00001954  1239 00C00003           3912mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000195A  0801 0002               3913mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000195E  67F4                    3914mm         BEQ WAIT_FOR_READY_282                      ; NO SPACE, CHECK AGAIN
00001960  13D8 00C00007           3915mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001966                          3916mm     ENDC
00001966                          3917mm 
00001966                 FALSE    3918mm     IFNE DEBUG
00001966                          3919mm     ENDC
00001966                          3920mm 
00001966                          3921mm     ENDM
00001966  60E4                    3922m     BRA LOOP_281
00001968                          3923m EXIT_281
00001968                          3924m     ENDM
00001968                          3925  
00001968                          3926  CONTINUE
00001968  222F 0002               3927      MOVE.L 2(SP),D1
0000196C                          3928m     PRINT_REG D1,D2,D3,D4,A0
0000196C  41FA 03D5               3929m     LEA OX(PC),A0
00001970                          3930mm     PRINT_STR A0,D2
00001970                          3931mm LOOP_284
00001970  0C10 0000               3932mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001974  6700 0016               3933mm     BEQ EXIT_284
00001978                          3934mmm     PRINT_CHAR (A0)+,D2
00001978                          3935mmm WAIT_FOR_READY_285                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001978                 TRUE     3936mmm     IFEQ DEBUG
00001978  1439 00C00003           3937mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000197E  0802 0002               3938mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001982  67F4                    3939mmm         BEQ WAIT_FOR_READY_285                      ; NO SPACE, CHECK AGAIN
00001984  13D8 00C00007           3940mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000198A                          3941mmm     ENDC
0000198A                          3942mmm 
0000198A                 FALSE    3943mmm     IFNE DEBUG
0000198A                          3944mmm     ENDC
0000198A                          3945mmm 
0000198A                          3946mmm     ENDM
0000198A  60E4                    3947mm     BRA LOOP_284
0000198C                          3948mm EXIT_284
0000198C                          3949mm     ENDM
0000198C  7807                    3950m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000198E                          3951m LOOP_283
0000198E                          3952mm     BIN2HEX D1,D3,A0
0000198E  41FA 032F               3953mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001992  E999                    3954mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001994  1601                    3955mm     MOVE.B D1,D3
00001996  0283 0000000F           3956mm     ANDI.L #$F,D3
0000199C  1630 3000               3957mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000019A0                          3958mm     ENDM
000019A0                          3959mm     PRINT_CHAR D3,D2
000019A0                          3960mm WAIT_FOR_READY_287                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019A0                 TRUE     3961mm     IFEQ DEBUG
000019A0  1439 00C00003           3962mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019A6  0802 0002               3963mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000019AA  67F4                    3964mm         BEQ WAIT_FOR_READY_287                      ; NO SPACE, CHECK AGAIN
000019AC  13C3 00C00007           3965mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000019B2                          3966mm     ENDC
000019B2                          3967mm 
000019B2                 FALSE    3968mm     IFNE DEBUG
000019B2                          3969mm     ENDC
000019B2                          3970mm 
000019B2                          3971mm     ENDM
000019B2  57CC FFDA               3972m     DBEQ D4,LOOP_283
000019B6                          3973m     ENDM
000019B6                          3974  
000019B6  41FA 03CB               3975      LEA FROM(PC),A0
000019BA                          3976m     PRINT_STR A0,D0
000019BA                          3977m LOOP_288
000019BA  0C10 0000               3978m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019BE  6700 0016               3979m     BEQ EXIT_288
000019C2                          3980mm     PRINT_CHAR (A0)+,D0
000019C2                          3981mm WAIT_FOR_READY_289                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019C2                 TRUE     3982mm     IFEQ DEBUG
000019C2  1039 00C00003           3983mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000019C8  0800 0002               3984mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000019CC  67F4                    3985mm         BEQ WAIT_FOR_READY_289                      ; NO SPACE, CHECK AGAIN
000019CE  13D8 00C00007           3986mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019D4                          3987mm     ENDC
000019D4                          3988mm 
000019D4                 FALSE    3989mm     IFNE DEBUG
000019D4                          3990mm     ENDC
000019D4                          3991mm 
000019D4                          3992mm     ENDM
000019D4  60E4                    3993m     BRA LOOP_288
000019D6                          3994m EXIT_288
000019D6                          3995m     ENDM
000019D6                          3996  
000019D6  222F 000A               3997      MOVE.L 10(SP),D1
000019DA                          3998m     PRINT_REG D1,D2,D3,D4,A0
000019DA  41FA 0367               3999m     LEA OX(PC),A0
000019DE                          4000mm     PRINT_STR A0,D2
000019DE                          4001mm LOOP_291
000019DE  0C10 0000               4002mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019E2  6700 0016               4003mm     BEQ EXIT_291
000019E6                          4004mmm     PRINT_CHAR (A0)+,D2
000019E6                          4005mmm WAIT_FOR_READY_292                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019E6                 TRUE     4006mmm     IFEQ DEBUG
000019E6  1439 00C00003           4007mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019EC  0802 0002               4008mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000019F0  67F4                    4009mmm         BEQ WAIT_FOR_READY_292                      ; NO SPACE, CHECK AGAIN
000019F2  13D8 00C00007           4010mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019F8                          4011mmm     ENDC
000019F8                          4012mmm 
000019F8                 FALSE    4013mmm     IFNE DEBUG
000019F8                          4014mmm     ENDC
000019F8                          4015mmm 
000019F8                          4016mmm     ENDM
000019F8  60E4                    4017mm     BRA LOOP_291
000019FA                          4018mm EXIT_291
000019FA                          4019mm     ENDM
000019FA  7807                    4020m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000019FC                          4021m LOOP_290
000019FC                          4022mm     BIN2HEX D1,D3,A0
000019FC  41FA 02C1               4023mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A00  E999                    4024mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A02  1601                    4025mm     MOVE.B D1,D3
00001A04  0283 0000000F           4026mm     ANDI.L #$F,D3
00001A0A  1630 3000               4027mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A0E                          4028mm     ENDM
00001A0E                          4029mm     PRINT_CHAR D3,D2
00001A0E                          4030mm WAIT_FOR_READY_294                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A0E                 TRUE     4031mm     IFEQ DEBUG
00001A0E  1439 00C00003           4032mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A14  0802 0002               4033mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A18  67F4                    4034mm         BEQ WAIT_FOR_READY_294                      ; NO SPACE, CHECK AGAIN
00001A1A  13C3 00C00007           4035mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001A20                          4036mm     ENDC
00001A20                          4037mm 
00001A20                 FALSE    4038mm     IFNE DEBUG
00001A20                          4039mm     ENDC
00001A20                          4040mm 
00001A20                          4041mm     ENDM
00001A20  57CC FFDA               4042m     DBEQ D4,LOOP_290
00001A24                          4043m     ENDM
00001A24                          4044m     PRINT_CRLF D0,A0
00001A24  41FA 0317               4045m     LEA CRLF(PC),A0
00001A28                          4046mm     PRINT_STR A0,D0
00001A28                          4047mm LOOP_296
00001A28  0C10 0000               4048mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A2C  6700 0016               4049mm     BEQ EXIT_296
00001A30                          4050mmm     PRINT_CHAR (A0)+,D0
00001A30                          4051mmm WAIT_FOR_READY_297                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A30                 TRUE     4052mmm     IFEQ DEBUG
00001A30  1039 00C00003           4053mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001A36  0800 0002               4054mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001A3A  67F4                    4055mmm         BEQ WAIT_FOR_READY_297                      ; NO SPACE, CHECK AGAIN
00001A3C  13D8 00C00007           4056mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A42                          4057mmm     ENDC
00001A42                          4058mmm 
00001A42                 FALSE    4059mmm     IFNE DEBUG
00001A42                          4060mmm     ENDC
00001A42                          4061mmm 
00001A42                          4062mmm     ENDM
00001A42  60E4                    4063mm     BRA LOOP_296
00001A44                          4064mm EXIT_296
00001A44                          4065mm     ENDM
00001A44                          4066m     ENDM
00001A44                          4067      
00001A44  207C 00000004           4068      MOVE.L #4,A0
00001A4A  4ED0                    4069      JMP (A0)
00001A4C                          4070          
00001A4C                          4071  ILLEGAL_HANDLER
00001A4C  13FC 0007 00E00001      4072      MOVE.B #7,DISPLAY   
00001A54                          4073      
00001A54  207C 00000004           4074      MOVE.L #4,A0
00001A5A  4ED0                    4075      JMP (A0)
00001A5C                          4076          
00001A5C                          4077  UNHANDLED_HANDLER
00001A5C  41FA 032C               4078      LEA UNHANDLED(PC),A0
00001A60                          4079m     PRINT_STR A0,D1
00001A60                          4080m LOOP_298
00001A60  0C10 0000               4081m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A64  6700 0016               4082m     BEQ EXIT_298
00001A68                          4083mm     PRINT_CHAR (A0)+,D1
00001A68                          4084mm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A68                 TRUE     4085mm     IFEQ DEBUG
00001A68  1239 00C00003           4086mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001A6E  0801 0002               4087mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001A72  67F4                    4088mm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001A74  13D8 00C00007           4089mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A7A                          4090mm     ENDC
00001A7A                          4091mm 
00001A7A                 FALSE    4092mm     IFNE DEBUG
00001A7A                          4093mm     ENDC
00001A7A                          4094mm 
00001A7A                          4095mm     ENDM
00001A7A  60E4                    4096m     BRA LOOP_298
00001A7C                          4097m EXIT_298
00001A7C                          4098m     ENDM
00001A7C                          4099  
00001A7C  4E73                    4100      RTE 
00001A7E                          4101      
00001A7E                          4102  UNINITIALISED_HANDLER
00001A7E  41FA 0320               4103      LEA UNINITIALISED(PC),A0
00001A82                          4104m     PRINT_STR A0,D1
00001A82                          4105m LOOP_300
00001A82  0C10 0000               4106m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A86  6700 0016               4107m     BEQ EXIT_300
00001A8A                          4108mm     PRINT_CHAR (A0)+,D1
00001A8A                          4109mm WAIT_FOR_READY_301                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A8A                 TRUE     4110mm     IFEQ DEBUG
00001A8A  1239 00C00003           4111mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001A90  0801 0002               4112mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001A94  67F4                    4113mm         BEQ WAIT_FOR_READY_301                      ; NO SPACE, CHECK AGAIN
00001A96  13D8 00C00007           4114mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A9C                          4115mm     ENDC
00001A9C                          4116mm 
00001A9C                 FALSE    4117mm     IFNE DEBUG
00001A9C                          4118mm     ENDC
00001A9C                          4119mm 
00001A9C                          4120mm     ENDM
00001A9C  60E4                    4121m     BRA LOOP_300
00001A9E                          4122m EXIT_300
00001A9E                          4123m     ENDM
00001A9E                          4124  
00001A9E  4E73                    4125      RTE 
00001AA0                          4126  
00001AA0                          4127  SPURIOUS_HANDLER
00001AA0  41FA 031E               4128      LEA SPURIOUS(PC),A0
00001AA4                          4129m     PRINT_STR A0,D1
00001AA4                          4130m LOOP_302
00001AA4  0C10 0000               4131m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001AA8  6700 0016               4132m     BEQ EXIT_302
00001AAC                          4133mm     PRINT_CHAR (A0)+,D1
00001AAC                          4134mm WAIT_FOR_READY_303                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001AAC                 TRUE     4135mm     IFEQ DEBUG
00001AAC  1239 00C00003           4136mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001AB2  0801 0002               4137mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001AB6  67F4                    4138mm         BEQ WAIT_FOR_READY_303                      ; NO SPACE, CHECK AGAIN
00001AB8  13D8 00C00007           4139mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001ABE                          4140mm     ENDC
00001ABE                          4141mm 
00001ABE                 FALSE    4142mm     IFNE DEBUG
00001ABE                          4143mm     ENDC
00001ABE                          4144mm 
00001ABE                          4145mm     ENDM
00001ABE  60E4                    4146m     BRA LOOP_302
00001AC0                          4147m EXIT_302
00001AC0                          4148m     ENDM
00001AC0                          4149  
00001AC0  4E73                    4150      RTE 
00001AC2                          4151      
00001AC2                          4152  TICK_HANDLER
00001AC2  41FA 0291               4153      LEA TICK(PC),A0
00001AC6                          4154m     PRINT_STR A0,D1
00001AC6                          4155m LOOP_304
00001AC6  0C10 0000               4156m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001ACA  6700 0016               4157m     BEQ EXIT_304
00001ACE                          4158mm     PRINT_CHAR (A0)+,D1
00001ACE                          4159mm WAIT_FOR_READY_305                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001ACE                 TRUE     4160mm     IFEQ DEBUG
00001ACE  1239 00C00003           4161mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001AD4  0801 0002               4162mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001AD8  67F4                    4163mm         BEQ WAIT_FOR_READY_305                      ; NO SPACE, CHECK AGAIN
00001ADA  13D8 00C00007           4164mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AE0                          4165mm     ENDC
00001AE0                          4166mm 
00001AE0                 FALSE    4167mm     IFNE DEBUG
00001AE0                          4168mm     ENDC
00001AE0                          4169mm 
00001AE0                          4170mm     ENDM
00001AE0  60E4                    4171m     BRA LOOP_304
00001AE2                          4172m EXIT_304
00001AE2                          4173m     ENDM
00001AE2                          4174      
00001AE2  1039 00C0001F           4175      MOVE.B DUART_RESET_OPR,D0
00001AE8  4E73                    4176      RTE 
00001AEA                          4177  
00001AEA                          4178  ; strings
00001AEA= 50 72 65 73 73 20 ...   4179  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001AFD= 5B 3F 5D 09 09 09 ...   4180  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001B09= 5B 76 5D 09 09 09 ...   4181          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001B18= 78 78 78 78 78 78 ...   4182          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001B30= 78 78 78 78 78 78 ...   4183          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001B50= 78 78 78 78 78 78 ...   4184          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001B71= 78 78 78 78 78 78 ...   4185          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001B82= 5B 7A 5D 09 09 09 ...   4186          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001B94= 78 78 78 78 78 78 ...   4187          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001BB5= 78 78 78 78 78 78 ...   4188          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
00001BD4= 78 78 78 78 78 78 ...   4189          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001BF8= 23 09 09 09 77 72 ...   4190          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001C12= 5B 78 5D 09 09 09 ...   4191          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001C29= 5B 69 5D 09 09 09 ...   4192          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001C42= 5B 6F 5D 09 09 09 ...   4193          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
00001C5D= 48 75 68 3F 0D 0A 00    4194  HUH  DC.B 'Huh?',CR,LF,NULL
00001C64= 20 53 20 72 65 63 ...   4195  READ    DC.B ' S records read, start address = ',NULL
00001C86= 57 3A 20 55 6E 6B ...   4196  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001C9D= 21 20 43 53 20 66 ...   4197  CS_FAILURE  DC.B '! CS failure at ',NULL
00001CAE= 21 20 52 41 4D 20 ...   4198  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001CBF= 30 31 32 33 34 35 ...   4199  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001CCF= 00 01 02 03 04 05 ...   4200  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001CE6= 4C 6F 61 64 69 6E ...   4201  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001CFA= 57 72 69 74 69 6E ...   4202  CODE        DC.B 'Writing code: ',NULL
00001D09= 53 65 74 74 69 6E ...   4203  SP      DC.B 'Setting initial stack pointer to ',NULL
00001D2B= 57 72 69 74 69 6E ...   4204  VECTORS DC.B 'Writing vectors',CR,LF,NULL
00001D3D= 0D 0A 00                4205  CRLF    DC.B CR,LF,NULL
00001D40= 3E 20 00                4206  PROMPT  DC.B '> ',NULL
00001D43= 30 78 00                4207  ox      DC.B '0x',NULL
00001D46= 20 2D 3E 20 00          4208  to      DC.B ' -> ',NULL
00001D4B= 53 50 3A 20 00          4209  STACK_POINTER DC.B 'SP: ',NULL
00001D50= 53 52 3A 20 00          4210  STATUS_REGISTER DC.B 'SR: ',NULL
00001D55= 74 69 63 6B 0D 0A 00    4211  TICK DC.B 'tick',CR,LF,NULL
00001D5C= 2A 20 42 75 73 2F ...   4212  BUS_ERROR DC.B '* Bus/address error ',NULL
00001D71= 72 65 61 64 69 6E ...   4213  READING DC.B 'reading ',NULL
00001D7A= 77 72 69 74 69 6E ...   4214  WRITING DC.B 'writing ',NULL
00001D83= 20 66 72 6F 6D 20 00    4215  FROM DC.B ' from ',NULL
00001D8A= 2A 20 55 6E 68 61 ...   4216  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001DA0= 2A 20 20 55 6E 69 ...   4217  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
00001DC0= 2A 20 53 70 75 72 ...   4218  SPURIOUS DC.B '* Spurious interrupt',NULL
00001DD5= 43 6F 6C 64 20 73 ...   4219  COLD_START DC.B 'Cold start - brrr',CR,LF,NULL
00001DE9= 57 61 72 6D 20 73 ...   4220  WARM_START DC.B 'Warm start - phew',CR,LF,NULL
00001DFD= 4D 44 46 2D 6D 6F ...   4221  VERSION DC.B 'MDF-mon V1.125 (28/04/2021)',CR,LF,NULL       ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001E1B= 00                      4222  END     DC.B 0
00001E1C                          4223      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1CBF
BUS_ERROR           1D5C
BUS_ERROR_HANDLER   18F8
CODE                1CFA
COLD_START          1DD5
CONTINUE            1968
CONTINUE_103        D5A
CONTINUE_117        E4C
CONTINUE_58         928
CONTINUE_61         978
CONTINUE_65         9CE
CONTINUE_73         A82
CONTINUE_78         AF4
CONTINUE_83         B70
CONTINUE_88         BEE
CONTINUE_93         C76
CONTINUE_98         CE8
CR                  D
CRLF                1D3D
CS_FAILURE          1C9D
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       F56
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1E1B
EXIT_108            DCC
EXIT_11             5A0
EXIT_110            DEC
EXIT_114            E1E
EXIT_122            EB4
EXIT_124            EDC
EXIT_127            EFC
EXIT_132            F46
EXIT_135            F76
EXIT_139            FC0
EXIT_14             5C8
EXIT_142            FE2
EXIT_147            102C
EXIT_149            10A8
EXIT_152            10CC
EXIT_157            1116
EXIT_164            11A2
EXIT_167            1212
EXIT_169            1232
EXIT_172            1254
EXIT_176            129E
EXIT_179            12C0
EXIT_184            130A
EXIT_187            134C
EXIT_19             612
EXIT_190            1374
EXIT_195            13BE
EXIT_200            1404
EXIT_203            143A
EXIT_207            1484
EXIT_21             632
EXIT_210            14A6
EXIT_215            14F0
EXIT_226            15A4
EXIT_229            1608
EXIT_232            1628
EXIT_236            1672
EXIT_239            1694
EXIT_24             652
EXIT_244            16DE
EXIT_253            1776
EXIT_255            17B8
EXIT_258            17DA
EXIT_26             67C
EXIT_263            1824
EXIT_265            1844
EXIT_268            1866
EXIT_273            18B0
EXIT_277            1918
EXIT_279            1944
EXIT_281            1968
EXIT_284            198C
EXIT_288            19D6
EXIT_291            19FA
EXIT_296            1A44
EXIT_298            1A7C
EXIT_300            1A9E
EXIT_302            1AC0
EXIT_304            1AE2
EXIT_32             710
EXIT_34             780
EXIT_36             7AC
EXIT_39             7D6
EXIT_4              534
EXIT_49             884
EXIT_56             8FA
EXIT_6              558
EXIT_70             A3E
EXIT_9              580
FROM                1D83
G                   1030
GET_INPUT           67C
H                   784
HASH                18C4
HELP                1AFD
HELPPROMPT          1AEA
HEX2BIN             10B
HEX2BIN_LUT         1CCF
HEX_DIGIT           18DA
HUH                 1C5D
I                   18B4
ILLEGAL_HANDLER     1A4C
L                   1126
LF                  A
LOADING             1CE6
LOOP_108            DB0
LOOP_11             584
LOOP_110            DD0
LOOP_114            E02
LOOP_122            E98
LOOP_124            EC0
LOOP_126            EFE
LOOP_127            EE0
LOOP_13             5CA
LOOP_132            F2A
LOOP_134            F78
LOOP_135            F5A
LOOP_139            FA4
LOOP_14             5AC
LOOP_141            FE4
LOOP_142            FC6
LOOP_147            1010
LOOP_149            108C
LOOP_151            10CE
LOOP_152            10B0
LOOP_157            10FA
LOOP_164            1186
LOOP_167            11F6
LOOP_169            1216
LOOP_171            1256
LOOP_172            1238
LOOP_176            1282
LOOP_178            12C2
LOOP_179            12A4
LOOP_184            12EE
LOOP_187            1330
LOOP_189            1376
LOOP_19             5F6
LOOP_190            1358
LOOP_195            13A2
LOOP_200            13E8
LOOP_202            143C
LOOP_203            141E
LOOP_207            1468
LOOP_209            14A8
LOOP_21             616
LOOP_210            148A
LOOP_215            14D4
LOOP_226            1588
LOOP_229            15EC
LOOP_231            162A
LOOP_232            160C
LOOP_236            1656
LOOP_238            1696
LOOP_239            1678
LOOP_24             636
LOOP_244            16C2
LOOP_253            175A
LOOP_255            179C
LOOP_257            17DC
LOOP_258            17BE
LOOP_26             660
LOOP_263            1808
LOOP_265            1828
LOOP_267            1868
LOOP_268            184A
LOOP_273            1894
LOOP_277            18FC
LOOP_279            1928
LOOP_281            194C
LOOP_283            198E
LOOP_284            1970
LOOP_288            19BA
LOOP_290            19FC
LOOP_291            19DE
LOOP_296            1A28
LOOP_298            1A60
LOOP_300            1A82
LOOP_302            1AA4
LOOP_304            1AC6
LOOP_32             6F4
LOOP_34             764
LOOP_36             790
LOOP_38             7D8
LOOP_39             7BA
LOOP_4              518
LOOP_49             868
LOOP_56             8DE
LOOP_6              53C
LOOP_70             A22
LOOP_9              564
M                   1700
MAIN_LOOP           65C
NULL                0
O                   18BC
OX                  1D43
P                   1530
PRINTSTR            790
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1D40
PROTECT             A40
R                   7B0
RAM                 200000
RAM_ERROR           1CAE
READ                1C64
READING             1D71
READ_CHAR           62D
RESET               4
ROM                 0
S                   904
SP                  1D09
SPURIOUS            1DC0
SPURIOUS_HANDLER    1AA0
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1D4B
START               400
STATUS_REGISTER     1D50
TAB                 9
TICK                1D55
TICK_HANDLER        1AC2
TO                  1D46
UNHANDLED           1D8A
UNHANDLED_HANDLER   1A5C
UNINITIALISED       1DA0
UNINITIALISED_HANDLER  1A7E
UNPROTECT           979
UNREC               1C86
USER                100
V                   78C
VECS                8
VECTORS             1D2B
VERSION             1DFD
W                   888
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_186  131C
WAIT_FOR_COMPLETE_198  13C8
WAIT_FOR_COMPLETE_199  13DA
WAIT_FOR_COMPLETE_218  14F4
WAIT_FOR_COMPLETE_219  1506
WAIT_FOR_COMPLETE_246  16E0
WAIT_FOR_READY_1    4CA
WAIT_FOR_READY_10   56C
WAIT_FOR_READY_100  D00
WAIT_FOR_READY_103  D3E
WAIT_FOR_READY_105  D72
WAIT_FOR_READY_109  DB8
WAIT_FOR_READY_111  DD8
WAIT_FOR_READY_112  DEC
WAIT_FOR_READY_115  E0A
WAIT_FOR_READY_117  E30
WAIT_FOR_READY_119  E64
WAIT_FOR_READY_12   58C
WAIT_FOR_READY_123  EA0
WAIT_FOR_READY_125  EC8
WAIT_FOR_READY_128  EE8
WAIT_FOR_READY_130  F10
WAIT_FOR_READY_133  F32
WAIT_FOR_READY_136  F62
WAIT_FOR_READY_138  F8A
WAIT_FOR_READY_140  FAC
WAIT_FOR_READY_143  FCE
WAIT_FOR_READY_145  FF6
WAIT_FOR_READY_148  1018
WAIT_FOR_READY_15   5B4
WAIT_FOR_READY_150  1094
WAIT_FOR_READY_153  10B8
WAIT_FOR_READY_155  10E0
WAIT_FOR_READY_158  1102
WAIT_FOR_READY_159  1134
WAIT_FOR_READY_161  114E
WAIT_FOR_READY_165  118E
WAIT_FOR_READY_168  11FE
WAIT_FOR_READY_17   5DC
WAIT_FOR_READY_170  121E
WAIT_FOR_READY_173  1240
WAIT_FOR_READY_175  1268
WAIT_FOR_READY_177  128A
WAIT_FOR_READY_180  12AC
WAIT_FOR_READY_182  12D4
WAIT_FOR_READY_185  12F6
WAIT_FOR_READY_188  1338
WAIT_FOR_READY_191  1360
WAIT_FOR_READY_193  1388
WAIT_FOR_READY_196  13AA
WAIT_FOR_READY_2    4DE
WAIT_FOR_READY_20   5FE
WAIT_FOR_READY_201  13F0
WAIT_FOR_READY_204  1426
WAIT_FOR_READY_206  144E
WAIT_FOR_READY_208  1470
WAIT_FOR_READY_211  1492
WAIT_FOR_READY_213  14BA
WAIT_FOR_READY_216  14DC
WAIT_FOR_READY_22   61E
WAIT_FOR_READY_221  153C
WAIT_FOR_READY_223  1556
WAIT_FOR_READY_227  1590
WAIT_FOR_READY_230  15F4
WAIT_FOR_READY_233  1614
WAIT_FOR_READY_235  163C
WAIT_FOR_READY_237  165E
WAIT_FOR_READY_240  1680
WAIT_FOR_READY_242  16A8
WAIT_FOR_READY_245  16CA
WAIT_FOR_READY_248  170E
WAIT_FOR_READY_25   63E
WAIT_FOR_READY_250  1728
WAIT_FOR_READY_254  1762
WAIT_FOR_READY_256  17A4
WAIT_FOR_READY_259  17C6
WAIT_FOR_READY_261  17EE
WAIT_FOR_READY_264  1810
WAIT_FOR_READY_266  1830
WAIT_FOR_READY_269  1852
WAIT_FOR_READY_27   668
WAIT_FOR_READY_271  187A
WAIT_FOR_READY_274  189C
WAIT_FOR_READY_278  1904
WAIT_FOR_READY_28   67C
WAIT_FOR_READY_280  1930
WAIT_FOR_READY_282  1954
WAIT_FOR_READY_285  1978
WAIT_FOR_READY_287  19A0
WAIT_FOR_READY_289  19C2
WAIT_FOR_READY_292  19E6
WAIT_FOR_READY_294  1A0E
WAIT_FOR_READY_297  1A30
WAIT_FOR_READY_299  1A68
WAIT_FOR_READY_3    4F2
WAIT_FOR_READY_30   696
WAIT_FOR_READY_301  1A8A
WAIT_FOR_READY_303  1AAC
WAIT_FOR_READY_305  1ACE
WAIT_FOR_READY_33   6FC
WAIT_FOR_READY_35   76C
WAIT_FOR_READY_37   798
WAIT_FOR_READY_40   7C2
WAIT_FOR_READY_42   7EA
WAIT_FOR_READY_43   800
WAIT_FOR_READY_44   816
WAIT_FOR_READY_45   82A
WAIT_FOR_READY_46   83E
WAIT_FOR_READY_47   852
WAIT_FOR_READY_5    520
WAIT_FOR_READY_50   870
WAIT_FOR_READY_51   892
WAIT_FOR_READY_53   8AC
WAIT_FOR_READY_57   8E6
WAIT_FOR_READY_58   90C
WAIT_FOR_READY_60   946
WAIT_FOR_READY_61   95C
WAIT_FOR_READY_63   990
WAIT_FOR_READY_65   9B2
WAIT_FOR_READY_67   9E6
WAIT_FOR_READY_7    544
WAIT_FOR_READY_71   A2A
WAIT_FOR_READY_73   A66
WAIT_FOR_READY_75   A9A
WAIT_FOR_READY_78   AD8
WAIT_FOR_READY_80   B0C
WAIT_FOR_READY_83   B54
WAIT_FOR_READY_85   B88
WAIT_FOR_READY_88   BD2
WAIT_FOR_READY_90   C06
WAIT_FOR_READY_93   C5A
WAIT_FOR_READY_95   C8E
WAIT_FOR_READY_98   CCC
WAIT_FOR_SRECORD    90C
WARM_START          1DE9
WRITE               1948
WRITING             1D7A
X                   1798
Z                   1036
_00000000           538
_00000001           558
_00000002           6BC
_00000003           6D0
_00000004           A46
_00000005           E22
_00000006           A54
_00000007           C42
_00000008           BB8
_00000009           E22
_0000000A           DAC
_0000000B           E22
_0000000C           F4A
_0000000D           F56
_0000000E           1116
_0000000F           1326
_00000010           13D2
_00000011           13E4
_00000012           14FE
_00000013           1510
_00000014           16EA
_10000000           9A8
_10000001           A10
_10000002           A5C
_10000003           AC4
_10000004           ACE
_10000005           B36
_10000006           B4A
_10000007           BB2
_10000008           BBC
_10000009           C3C
_1000000A           BC8
_1000000B           C30
_1000000C           C50
_1000000D           CB8
_1000000E           CC2
_1000000F           D2A
_10000010           D34
_10000011           D9C
_10000012           E26
_10000013           E8E
_10000014           130A
_10000015           132C
_10000016           1780
_10000017           1794
_20000000           42E
_20000001           43A
_20000002           448
_20000003           454
_20000004           890
_20000005           8D4
_20000006           1048
_20000007           1058
_20000008           1072
_20000009           1118
_2000000A           1132
_2000000B           1176
_2000000C           11E8
_2000000D           11EC
_2000000E           140C
_2000000F           1512
_20000010           153A
_20000011           157E
_20000012           15DE
_20000013           15E2
_20000014           170C
_20000015           1750
