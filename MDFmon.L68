00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 17/05/2021 18:02:47

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           190  PRINT_REG MACRO
00000000                           191      LEA ox(PC),\5
00000000                           192      PRINT_STR \5,\2
00000000                           193      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           194  LOOP\@
00000000                           195      BIN2HEX \1,\3,\5
00000000                           196      PRINT_CHAR \3,\2
00000000                           197      DBEQ \4,LOOP\@
00000000                           198      ENDM
00000000                           199  
00000000                           200  ; wait for a char from the serial port
00000000                           201  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           202  ; will stamp on D0 and D1 in debug mode
00000000                           203  WAIT_CHAR MACRO
00000000                           204  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           205      IFEQ DEBUG
00000000                           206          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           207          BTST #0,\2                                  ; check for character
00000000                           208          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           209      ENDC
00000000                           210  
00000000                           211      READ_CHAR \1
00000000                           212  
00000000                           213      IFEQ DEBUG
00000000                           214          PRINT_CHAR \1,\2                            ; echo it back
00000000                           215      ENDC
00000000                           216      ENDM
00000000                           217  
00000000                           218  ; read a char from the serial port - assumes that there is one!
00000000                           219  ; \ 1= data register for read char
00000000                           220  ; will stamp on D0 and D1 in debug mode
00000000                           221  READ_CHAR MACRO
00000000                           222      IFEQ DEBUG
00000000                           223          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           224      ENDC
00000000                           225      IFNE DEBUG
00000000                           226          MOVE.L #5,D0    
00000000                           227          TRAP #15                                    ; read from keyboard in simulator
00000000                           228          MOVE.L D1,\1
00000000                           229      ENDC
00000000                           230  
00000000                           231      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           232      BEQ START
00000000                           233      ENDM
00000000                           234  
00000000                           235  
00000000                           236  ; read data from the download serial port
00000000                           237  ; \ 1= data register for read char
00000000                           238  DOWNLOAD MACRO
00000000                           239  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           240  
00000000                           241      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           242      BTST #0,\1                                      ; check for character
00000000                           243      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           244  
00000000                           245      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           246  CONTINUE\@
00000000                           247      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           248      BTST #0,\1                                      ; check for character
00000000                           249      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           250      
00000000                           251      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           252      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           253  
00000000                           254      ENDM
00000000                           255  
00000000                           256  ; unprotect the EEPROM
00000000                           257  UNPROTECT MACRO
00000000                           258      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           259      NOP
00000000                           260      MOVE.W #$5555,$1554
00000000                           261      NOP
00000000                           262      MOVE.W #$8080,$2AAA
00000000                           263      NOP
00000000                           264      MOVE.W #$AAAA,$2AAA
00000000                           265      NOP
00000000                           266      MOVE.W #$5555,$1554
00000000                           267      NOP
00000000                           268      MOVE.W #$2020,$2AAA
00000000                           269      ENDM
00000000                           270      
00000000                           271  ; protect the EEPROM
00000000                           272  PROTECT MACRO
00000000                           273      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           274      MOVE.W #$5555,$1554
00000000                           275      MOVE.W #$A0A0,$2AAA
00000000                           276      ENDM
00000000                           277  
00000000                           278  
00000000                           279  ; read two hex digits from the download serial port and convert to a byte
00000000                           280  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           281  DOWNLOAD_BYTE MACRO
00000000                           282      MOVE.B #2,\4
00000000                           283      WHILE.B \4 <GT> 0 DO
00000000                           284          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           285          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           286          PRINT_CHAR \2,\3
00000000                           287          HEX2BIN \2,\2,\6
00000000                           288          OR.B \2,\1
00000000                           289          SUB.B #1,\4
00000000                           290      ENDW
00000000                           291  
00000000                           292      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           293      MOVE.B \1,\2
00000000                           294      ADD.L \1,\5
00000000                           295  
00000000                           296      ENDM
00000000                           297  
00000000                           298  ; write word to EEPROM
00000000                           299  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           300  PROGRAM MACRO
00000000                           301    MOVE.W \1,\2                                      ; write the data
00000000                           302  
00000000                           303  WAIT_FOR_COMPLETE\@
00000000                           304          MOVE.W \2,\3
00000000                           305  
00000000                           306          IF.W \3 <NE> \1 THEN
00000000                           307              BRA WAIT_FOR_COMPLETE\@
00000000                           308          ENDI
00000000                           309          ENDM
00000000                           310          
00000000                           311  ; program vector to EEPROM
00000000                           312  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           313  PROGRAM_VECTOR MACRO
00000000                           314      ADD.L #2,\2
00000000                           315      PROGRAM \1, (\2), \3                            ; write it
00000000                           316      LSR.L #8,\1
00000000                           317      LSR.L #8,\1
00000000                           318      SUB.L #2,\2
00000000                           319      PROGRAM \1, (\2), \3
00000000                           320      ENDM
00000000                           321  
00000000                           322  ; read an ide register
00000000                           323  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           324  READ_8 MACRO
00000000                           325      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           326      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           327      ORI.B \1, \3
00000000                           328      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           329      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           330      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           331      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           332      ORI.B #MC68230_PORT_C_READ, \3
00000000                           333      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           334      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           335      ENDM
00000000                           336      
00000000                           337  ; write an ide register
00000000                           338  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           339  WRITE_8 MACRO
00000000                           340      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           341      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           342      ORI.B \2, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           345      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           346      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           347      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           348      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           349      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           350      ENDM
00000000                           351  
00000000                           352  ; read ide data
00000000                           353  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           354  READ_16 MACRO
00000000                           355      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           356      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           357      
00000000                           358      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           359      ORI.B \1, \3
00000000                           360      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           361      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           362      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           363      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           364      LSL.W #8, \2
00000000                           365      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           366      ORI.B #MC68230_PORT_C_READ, \3
00000000                           367      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           369      ENDM
00000000                           370      
00000000                           371  ; read ide data
00000000                           372  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           373  READ_32 MACRO
00000000                           374      READ_16 \1, \2, \3
00000000                           375      LSL.L #8, \2
00000000                           376      LSL.L #8, \2
00000000                           377      READ_16 \1, \2, \3
00000000                           378      ENDM
00000000                           379          
00000000                           380  ; read ide status
00000000                           381  ;\1 = data register for result, \2 = working data register 
00000000                           382  READ_IDE_STATUS MACRO   
00000000                           383      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           384      ENDM
00000000                           385      
00000000                           386  ; wait for ide drive to be ready
00000000                           387  ;\1 = working data register 1, \2 = working data register 2
00000000                           388  WAIT_DRIVE_READY MACRO
00000000                           389  LOOP\@
00000000                           390      READ_IDE_STATUS \1, \2
00000000                           391      BTST #IDE_STATUS_READY, \1
00000000                           392      BEQ LOOP\@
00000000                           393      ENDM
00000000                           394      
00000000                           395  ; wait for ide drive to be not busy
00000000                           396  ;\1 = working data register 1, \2 = working data register 2
00000000                           397  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           398  LOOP\@
00000000                           399      READ_IDE_STATUS \1, \2
00000000                           400      BTST #IDE_STATUS_BUSY, \1
00000000                           401      BNE LOOP\@
00000000                           402      ENDM
00000000                           403      
00000000                           404  ; wait for ide drive to have data for us
00000000                           405  ;\1 = working data register 1, \2 = working data register 2
00000000                           406  WAIT_DRIVE_DRQ MACRO
00000000                           407  LOOP\@
00000000                           408      READ_IDE_STATUS \1, \2
00000000                           409      BTST #IDE_STATUS_DRQ, \1
00000000                           410      BEQ LOOP\@
00000000                           411      ENDM
00000000                           412      
00000000                           413  ; prepare to send a read command
00000000                           414  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           415  SET_READ_ADDRESS MACRO
00000000                           416      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           417      MOVE.L \1,\3
00000000                           418      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           419      LSR.L #8, \3
00000000                           420      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           421      LSR.L #8, \3
00000000                           422      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           423      LSR.L #8, \3
00000000                           424      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           425      ANDI.B #$0F,\3
00000000                           426      OR.B \3,\4
00000000                           427      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           428      ENDM
00000000                           429  
00000000                           430  ; send command
00000000                           431  ; \1 = command, \2 = working data register 1,
00000000                           432  SEND_COMMAND MACRO
00000000                           433      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           434      ENDM
00000000                           435      
00000000                           436  ; send read command and wait
00000000                           437  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           438  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           439      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           440      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           441      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           442      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           443      WAIT_DRIVE_DRQ \2, \3
00000000                           444      ENDM
00000000                           445  
00000000                           446  ; register catalogue
00000000                           447  ; D0 - used for simulator I/O
00000000                           448  ; D1 - used for simulator I/O
00000000                           449  ; D2 - read character
00000000                           450  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           451  ; D6 - working register used in R/W
00000000                           452  ; D7 - address accumulator, reset by download
00000000                           453  ; A0 - address of string to print 
00000000                           454  
00000000                           455  ; start vector
00000000= 002E0000                 456  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 457  RESET   DC.L START                              ; RESET
00000008= 00001C94                 458  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001C94                 459          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001DE8                 460          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001DF8                 461          DC.L UNHANDLED_HANDLER
00000018= 00001DF8                 462          DC.L UNHANDLED_HANDLER
0000001C= 00001DF8                 463          DC.L UNHANDLED_HANDLER
00000020= 00001DF8                 464          DC.L UNHANDLED_HANDLER
00000024= 00001DF8                 465          DC.L UNHANDLED_HANDLER
00000028= 00001DF8                 466          DC.L UNHANDLED_HANDLER
0000002C= 00001DF8                 467          DC.L UNHANDLED_HANDLER
00000030= 00001DF8                 468          DC.L UNHANDLED_HANDLER
00000034= 00001DF8                 469          DC.L UNHANDLED_HANDLER
00000038= 00001DF8                 470          DC.L UNHANDLED_HANDLER
0000003C= 00001DF8                 471          DC.L UNHANDLED_HANDLER
00000040= 00001DF8                 472          DC.L UNHANDLED_HANDLER
00000044= 00001DF8                 473          DC.L UNHANDLED_HANDLER
00000048= 00001DF8                 474          DC.L UNHANDLED_HANDLER
0000004C= 00001DF8                 475          DC.L UNHANDLED_HANDLER
00000050= 00001DF8                 476          DC.L UNHANDLED_HANDLER
00000054= 00001DF8                 477          DC.L UNHANDLED_HANDLER
00000058= 00001DF8                 478          DC.L UNHANDLED_HANDLER
0000005C= 00001DF8                 479          DC.L UNHANDLED_HANDLER
00000060= 00001E1C                 480          DC.L SPURIOUS_HANDLER
00000064= 00001DF8                 481          DC.L UNHANDLED_HANDLER
00000068= 00001DF8                 482          DC.L UNHANDLED_HANDLER
0000006C= 00001DF8                 483          DC.L UNHANDLED_HANDLER
00000070= 00001DF8                 484          DC.L UNHANDLED_HANDLER
00000074= 00001DF8                 485          DC.L UNHANDLED_HANDLER
00000078= 00001DF8                 486          DC.L UNHANDLED_HANDLER
0000007C= 00001DF8                 487          DC.L UNHANDLED_HANDLER
00000080= 00001DF8                 488          DC.L UNHANDLED_HANDLER
00000084= 00001DF8                 489          DC.L UNHANDLED_HANDLER
00000088= 00001DF8                 490          DC.L UNHANDLED_HANDLER
0000008C= 00001DF8                 491          DC.L UNHANDLED_HANDLER
00000090= 00001DF8                 492          DC.L UNHANDLED_HANDLER
00000094= 00001DF8                 493          DC.L UNHANDLED_HANDLER
00000098= 00001DF8                 494          DC.L UNHANDLED_HANDLER
0000009C= 00001DF8                 495          DC.L UNHANDLED_HANDLER
000000A0= 00001DF8                 496          DC.L UNHANDLED_HANDLER
000000A4= 00001DF8                 497          DC.L UNHANDLED_HANDLER
000000A8= 00001DF8                 498          DC.L UNHANDLED_HANDLER
000000AC= 00001DF8                 499          DC.L UNHANDLED_HANDLER
000000B0= 00001DF8                 500          DC.L UNHANDLED_HANDLER
000000B4= 00001DF8                 501          DC.L UNHANDLED_HANDLER
000000B8= 00001DF8                 502          DC.L UNHANDLED_HANDLER
000000BC= 00001DF8                 503          DC.L UNHANDLED_HANDLER
000000C0= 00001DF8                 504          DC.L UNHANDLED_HANDLER
000000C4= 00001DF8                 505          DC.L UNHANDLED_HANDLER
000000C8= 00001DF8                 506          DC.L UNHANDLED_HANDLER
000000CC= 00001DF8                 507          DC.L UNHANDLED_HANDLER
000000D0= 00001DF8                 508          DC.L UNHANDLED_HANDLER
000000D4= 00001DF8                 509          DC.L UNHANDLED_HANDLER
000000D8= 00001DF8                 510          DC.L UNHANDLED_HANDLER 
000000DC= 00001DF8                 511          DC.L UNHANDLED_HANDLER
000000E0= 00001DF8                 512          DC.L UNHANDLED_HANDLER
000000E4= 00001DF8                 513          DC.L UNHANDLED_HANDLER 
000000E8= 00001DF8                 514          DC.L UNHANDLED_HANDLER 
000000EC= 00001DF8                 515          DC.L UNHANDLED_HANDLER
000000F0= 00001DF8                 516          DC.L UNHANDLED_HANDLER 
000000F4= 00001DF8                 517          DC.L UNHANDLED_HANDLER 
000000F8= 00001DF8                 518          DC.L UNHANDLED_HANDLER 
000000FC= 00001DF8                 519          DC.L UNHANDLED_HANDLER
00000100= 00001E0C                 520  USER    DC.L TICK_HANDLER
00000104                           521      ; start of program  
00000104                           522  START
00000104  2E7C 002E0000            523      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       524      MOVE.B #0,DISPLAY
00000112                           525  
00000112  7000                     526      MOVE.L #0,D0
00000114  1039 00C00019            527      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           528  
0000011A                           529  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       530      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       531      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           532      
0000012A                           533      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                534s     MOVE.W  #$50,D1
0000012E  6000 000E                535s     BRA _20000001
00000132                           536s _20000000
00000132  13C1 00C00005            537          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     538          NOP
0000013A                           539      ENDF
0000013A  0441 0010                540s     SUB.W   #$10,D1
0000013E                           541s _20000001
0000013E  B27C 0010                542s     CMP.W   #$10,D1
00000142  6CEE                     543s     BGE _20000000
00000144                           544  
00000144                           545      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                546s     MOVE.W  #$50,D1
00000148  6000 000E                547s     BRA _20000003
0000014C                           548s _20000002
0000014C  13C1 00C00015            549          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     550          NOP
00000154                           551      ENDF
00000154  0441 0010                552s     SUB.W   #$10,D1
00000158                           553s _20000003
00000158  B27C 0010                554s     CMP.W   #$10,D1
0000015C  6CEE                     555s     BGE _20000002
0000015E                           556      
0000015E                           557  ;initialise UART
0000015E  13FC 0000 00C0000B       558      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       559      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       560      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       561      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       562      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           563  
00000186                           564  ; channel A
00000186  13FC 0013 00C00001       565      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       566      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       567      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       568      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           569  
000001A6                           570  ; channel B
000001A6  13FC 0013 00C00011       571      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       572      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       573      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       574      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       575      MOVE.B #64,DUART_IVR
000001CE                           576  
000001CE                           577m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           578m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      579m     IFEQ DEBUG
000001CE  1239 00C00003            580m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                581m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     582m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       583m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           584m     ENDC
000001E2                           585m 
000001E2                 FALSE     586m     IFNE DEBUG
000001E2                           587m     ENDC
000001E2                           588m 
000001E2                           589m     ENDM
000001E2                           590m     PRINT_CHAR #0,D1
000001E2                           591m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      592m     IFEQ DEBUG
000001E2  1239 00C00003            593m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                594m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     595m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       596m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           597m     ENDC
000001F6                           598m 
000001F6                 FALSE     599m     IFNE DEBUG
000001F6                           600m     ENDC
000001F6                           601m 
000001F6                           602m     ENDM
000001F6                           603m     PRINT_CHAR #0,D1
000001F6                           604m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      605m     IFEQ DEBUG
000001F6  1239 00C00003            606m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                607m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     608m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       609m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           610m     ENDC
0000020A                           611m 
0000020A                 FALSE     612m     IFNE DEBUG
0000020A                           613m     ENDC
0000020A                           614m 
0000020A                           615m     ENDM
0000020A                           616      
0000020A                           617      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                618s     CMP.W   #$0F,D0
0000020E  6600 0008                619s     BNE _00000000
00000212  1039 00C00005            620          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           621      ENDI
00000218                           622s _00000000
00000218                           623  
00000218  13FC 0001 00E00001       624      MOVE.B #1,DISPLAY
00000220                           625      
00000220                           626m     PRINT_CRLF D1,A0
00000220  41FA 1E28                627m     LEA CRLF(PC),A0
00000224                           628mm     PRINT_STR A0,D1
00000224                           629mm LOOP_5
00000224  0C10 0000                630mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                631mm     BEQ EXIT_5
0000022C                           632mmm     PRINT_CHAR (A0)+,D1
0000022C                           633mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      634mmm     IFEQ DEBUG
0000022C  1239 00C00003            635mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                636mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     637mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            638mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           639mmm     ENDC
0000023E                           640mmm 
0000023E                 FALSE     641mmm     IFNE DEBUG
0000023E                           642mmm     ENDC
0000023E                           643mmm 
0000023E                           644mmm     ENDM
0000023E  60E4                     645mm     BRA LOOP_5
00000240                           646mm EXIT_5
00000240                           647mm     ENDM
00000240                           648m     ENDM
00000240  41FA 1EA6                649      LEA VERSION(PC),A0
00000244                           650m     PRINT_STR A0,D3
00000244                           651m LOOP_7
00000244  0C10 0000                652m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                653m     BEQ EXIT_7
0000024C                           654mm     PRINT_CHAR (A0)+,D3
0000024C                           655mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      656mm     IFEQ DEBUG
0000024C  1639 00C00003            657mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                658mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     659mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            660mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           661mm     ENDC
0000025E                           662mm 
0000025E                 FALSE     663mm     IFNE DEBUG
0000025E                           664mm     ENDC
0000025E                           665mm 
0000025E                           666mm     ENDM
0000025E  60E4                     667m     BRA LOOP_7
00000260                           668m EXIT_7
00000260                           669m     ENDM
00000260                           670  
00000260  41F9 00002106            671      LEA END,A0
00000266  2008                     672      MOVE.L A0,D0
00000268                           673m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1DE6                674m     LEA OX(PC),A0
0000026C                           675mm     PRINT_STR A0,D1
0000026C                           676mm LOOP_10
0000026C  0C10 0000                677mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                678mm     BEQ EXIT_10
00000274                           679mmm     PRINT_CHAR (A0)+,D1
00000274                           680mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      681mmm     IFEQ DEBUG
00000274  1239 00C00003            682mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                683mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     684mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            685mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           686mmm     ENDC
00000286                           687mmm 
00000286                 FALSE     688mmm     IFNE DEBUG
00000286                           689mmm     ENDC
00000286                           690mmm 
00000286                           691mmm     ENDM
00000286  60E4                     692mm     BRA LOOP_10
00000288                           693mm EXIT_10
00000288                           694mm     ENDM
00000288  7607                     695m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           696m LOOP_9
0000028A                           697mm     BIN2HEX D0,D2,A0
0000028A  41FA 1D83                698mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     699mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     700mm     MOVE.B D0,D2
00000292  0282 0000000F            701mm     ANDI.L #$F,D2
00000298  1430 2000                702mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           703mm     ENDM
0000029C                           704mm     PRINT_CHAR D2,D1
0000029C                           705mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      706mm     IFEQ DEBUG
0000029C  1239 00C00003            707mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                708mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     709mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            710mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           711mm     ENDC
000002AE                           712mm 
000002AE                 FALSE     713mm     IFNE DEBUG
000002AE                           714mm     ENDC
000002AE                           715mm 
000002AE                           716mm     ENDM
000002AE  57CB FFDA                717m     DBEQ D3,LOOP_9
000002B2                           718m     ENDM
000002B2                           719m     PRINT_CRLF D1,A0
000002B2  41FA 1D96                720m     LEA CRLF(PC),A0
000002B6                           721mm     PRINT_STR A0,D1
000002B6                           722mm LOOP_15
000002B6  0C10 0000                723mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                724mm     BEQ EXIT_15
000002BE                           725mmm     PRINT_CHAR (A0)+,D1
000002BE                           726mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      727mmm     IFEQ DEBUG
000002BE  1239 00C00003            728mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                729mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     730mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            731mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           732mmm     ENDC
000002D0                           733mmm 
000002D0                 FALSE     734mmm     IFNE DEBUG
000002D0                           735mmm     ENDC
000002D0                           736mmm 
000002D0                           737mmm     ENDM
000002D0  60E4                     738mm     BRA LOOP_15
000002D2                           739mm EXIT_15
000002D2                           740mm     ENDM
000002D2                           741m     ENDM
000002D2                           742  
000002D2  41FA 1B6E                743      LEA HELPPROMPT(PC),A0
000002D6                           744m     PRINT_STR A0,D3
000002D6                           745m LOOP_17
000002D6  0C10 0000                746m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                747m     BEQ EXIT_17
000002DE                           748mm     PRINT_CHAR (A0)+,D3
000002DE                           749mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      750mm     IFEQ DEBUG
000002DE  1639 00C00003            751mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                752mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     753mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            754mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           755mm     ENDC
000002F0                           756mm 
000002F0                 FALSE     757mm     IFNE DEBUG
000002F0                           758mm     ENDC
000002F0                           759mm 
000002F0                           760mm     ENDM
000002F0  60E4                     761m     BRA LOOP_17
000002F2                           762m EXIT_17
000002F2                           763m     ENDM
000002F2                           764  
000002F2                           765m     PRINT_CRLF D3,A0
000002F2  41FA 1D56                766m     LEA CRLF(PC),A0
000002F6                           767mm     PRINT_STR A0,D3
000002F6                           768mm LOOP_20
000002F6  0C10 0000                769mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                770mm     BEQ EXIT_20
000002FE                           771mmm     PRINT_CHAR (A0)+,D3
000002FE                           772mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      773mmm     IFEQ DEBUG
000002FE  1639 00C00003            774mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                775mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     776mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            777mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           778mmm     ENDC
00000310                           779mmm 
00000310                 FALSE     780mmm     IFNE DEBUG
00000310                           781mmm     ENDC
00000310                           782mmm 
00000310                           783mmm     ENDM
00000310  60E4                     784mm     BRA LOOP_20
00000312                           785mm EXIT_20
00000312                           786mm     ENDM
00000312                           787m     ENDM
00000312                           788  
00000312  7E00                     789      MOVE.L #0,D7                                    ; address accumulator
00000314                           790  
00000314  13FC 0002 00E00001       791      MOVE.B #2,DISPLAY
0000031C                           792      
0000031C  13FC 0000 00A00001       793      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       794      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       795      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       796      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           797      
0000033C  13FC 0003 00E00001       798      MOVE.B #3,DISPLAY
00000344                           799      
00000344                           800      
00000344                           801  MAIN_LOOP
00000344  41FA 1D07                802      LEA PROMPT(PC),A0
00000348                           803m     PRINT_STR A0,D3
00000348                           804m LOOP_22
00000348  0C10 0000                805m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                806m     BEQ EXIT_22
00000350                           807mm     PRINT_CHAR (A0)+,D3
00000350                           808mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      809mm     IFEQ DEBUG
00000350  1639 00C00003            810mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                811mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     812mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            813mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           814mm     ENDC
00000362                           815mm 
00000362                 FALSE     816mm     IFNE DEBUG
00000362                           817mm     ENDC
00000362                           818mm 
00000362                           819mm     ENDM
00000362  60E4                     820m     BRA LOOP_22
00000364                           821m EXIT_22
00000364                           822m     ENDM
00000364                           823  
00000364                           824  GET_INPUT
00000364                           825m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           826m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      827m     IFEQ DEBUG
00000364  1639 00C00003            828m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                829m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     830m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           831m     ENDC
00000370                           832m 
00000370                           833mm     READ_CHAR D2
00000370                 TRUE      834mm     IFEQ DEBUG
00000370  1439 00C00007            835mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           836mm     ENDC
00000376                 FALSE     837mm     IFNE DEBUG
00000376                           838mm     ENDC
00000376                           839mm 
00000376  B43C 001B                840mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                841mm     BEQ START
0000037E                           842mm     ENDM
0000037E                           843m 
0000037E                 TRUE      844m     IFEQ DEBUG
0000037E                           845mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           846mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      847mm     IFEQ DEBUG
0000037E  1639 00C00003            848mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                849mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     850mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            851mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           852mm     ENDC
00000390                           853mm 
00000390                 FALSE     854mm     IFNE DEBUG
00000390                           855mm     ENDC
00000390                           856mm 
00000390                           857mm     ENDM
00000390                           858m     ENDC
00000390                           859m     ENDM
00000390                           860  
00000390                           861      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                862s     CMP.B   #'0',D2
00000394  6D00 000E                863s     BLT _00000001
00000398  B43C 0039                864s     CMP.B   #'9',D2
0000039C  6E00 0006                865s     BGT _00000001
000003A0  6000 18D8                866          BRA HEX_DIGIT
000003A4                           867      ENDI
000003A4                           868s _00000001
000003A4                           869      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                870s     CMP.B   #'A',D2
000003A8  6D00 000E                871s     BLT _00000002
000003AC  B43C 0046                872s     CMP.B   #'F',D2
000003B0  6E00 0006                873s     BGT _00000002
000003B4  6000 18C4                874          BRA HEX_DIGIT
000003B8                           875      ENDI
000003B8                           876s _00000002
000003B8                           877  
000003B8  B43C 0077                878      CMP.B #'w',D2
000003BC  6700 01B2                879      BEQ W
000003C0                           880  
000003C0  B43C 006C                881      CMP.B #'l',D2
000003C4  6700 0A48                882      BEQ L 
000003C8                           883  
000003C8  B43C 0070                884      CMP.B #'p',D2
000003CC  6700 0D42                885      BEQ P
000003D0                           886  
000003D0                           887m     PRINT_CRLF D3,A0
000003D0  41FA 1C78                888m     LEA CRLF(PC),A0
000003D4                           889mm     PRINT_STR A0,D3
000003D4                           890mm LOOP_28
000003D4  0C10 0000                891mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                892mm     BEQ EXIT_28
000003DC                           893mmm     PRINT_CHAR (A0)+,D3
000003DC                           894mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      895mmm     IFEQ DEBUG
000003DC  1639 00C00003            896mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                897mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     898mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            899mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           900mmm     ENDC
000003EE                           901mmm 
000003EE                 FALSE     902mmm     IFNE DEBUG
000003EE                           903mmm     ENDC
000003EE                           904mmm 
000003EE                           905mmm     ENDM
000003EE  60E4                     906mm     BRA LOOP_28
000003F0                           907mm EXIT_28
000003F0                           908mm     ENDM
000003F0                           909m     ENDM
000003F0                           910   
000003F0  B43C 003F                911      CMP.B #'?',D2
000003F4  6700 0076                912      BEQ H
000003F8                           913   
000003F8  B43C 0076                914      CMP.B #'v',D2
000003FC  6700 0076                915      BEQ V
00000400                           916      
00000400  B43C 0072                917      CMP.B #'r',D2
00000404  6700 0092                918      BEQ R
00000408                           919  
00000408  B43C 0073                920      CMP.B #'s',D2
0000040C  6700 01DE                921      BEQ S
00000410                           922  
00000410  B43C 0067                923      CMP.B #'g',D2
00000414  6700 0902                924      BEQ G   
00000418                           925  
00000418  B43C 007A                926      CMP.B #'z',D2
0000041C  6700 0900                927      BEQ Z   
00000420                           928  
00000420  B43C 0078                929      CMP.B #'x',D2
00000424  6700 0EBA                930      BEQ X
00000428                           931  
00000428  B43C 0069                932      CMP.B #'i',D2
0000042C  6700 0FCE                933      BEQ I
00000430                           934  
00000430  B43C 006F                935      CMP.B #'o',D2
00000434  6700 0FD6                936      BEQ O
00000438                           937  
00000438  B43C 0023                938      CMP.B #'#',D2
0000043C  6700 0FDE                939      BEQ HASH
00000440                           940  
00000440  B43C 0062                941      CMP.B #'b',D2
00000444  6700 0FEC                942      BEQ B
00000448                           943  
00000448  41FA 1B63                944      LEA HUH(PC),A0
0000044C                           945m     PRINT_STR A0,D3
0000044C                           946m LOOP_30
0000044C  0C10 0000                947m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000450  6700 0016                948m     BEQ EXIT_30
00000454                           949mm     PRINT_CHAR (A0)+,D3
00000454                           950mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000454                 TRUE      951mm     IFEQ DEBUG
00000454  1639 00C00003            952mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000045A  0803 0002                953mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000045E  67F4                     954mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000460  13D8 00C00007            955mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000466                           956mm     ENDC
00000466                           957mm 
00000466                 FALSE     958mm     IFNE DEBUG
00000466                           959mm     ENDC
00000466                           960mm 
00000466                           961mm     ENDM
00000466  60E4                     962m     BRA LOOP_30
00000468                           963m EXIT_30
00000468                           964m     ENDM
00000468                           965  
00000468  6000 FEDA                966      BRA MAIN_LOOP
0000046C                           967  
0000046C                           968  ; commands
0000046C                           969  H
0000046C  41FA 19E7                970      LEA HELP(PC),A0
00000470  6000 0006                971      BRA PRINTIT
00000474                           972  
00000474                           973  V
00000474  41FA 1C72                974      LEA VERSION(PC),A0
00000478                           975  PRINTIT
00000478                           976m     PRINT_STR A0,D3    
00000478                           977m LOOP_32
00000478  0C10 0000                978m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000047C  6700 0016                979m     BEQ EXIT_32
00000480                           980mm     PRINT_CHAR (A0)+,D3
00000480                           981mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000480                 TRUE      982mm     IFEQ DEBUG
00000480  1639 00C00003            983mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000486  0803 0002                984mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000048A  67F4                     985mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000048C  13D8 00C00007            986mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000492                           987mm     ENDC
00000492                           988mm 
00000492                 FALSE     989mm     IFNE DEBUG
00000492                           990mm     ENDC
00000492                           991mm 
00000492                           992mm     ENDM
00000492  60E4                     993m     BRA LOOP_32
00000494                           994m EXIT_32
00000494                           995m     ENDM
00000494  6000 FEAE                996      BRA MAIN_LOOP
00000498                           997  
00000498                           998  R
00000498  2047                     999      MOVE.L D7,A0                                    ; address accumulator -> address register
0000049A  7E00                    1000      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000049C  2410                    1001      MOVE.L (A0),D2                                  ; read the memory and print it
0000049E                          1002m     PRINT_REG D2,D3,D4,D5,A0
0000049E  41FA 1BB0               1003m     LEA OX(PC),A0
000004A2                          1004mm     PRINT_STR A0,D3
000004A2                          1005mm LOOP_35
000004A2  0C10 0000               1006mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004A6  6700 0016               1007mm     BEQ EXIT_35
000004AA                          1008mmm     PRINT_CHAR (A0)+,D3
000004AA                          1009mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AA                 TRUE     1010mmm     IFEQ DEBUG
000004AA  1639 00C00003           1011mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004B0  0803 0002               1012mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004B4  67F4                    1013mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004B6  13D8 00C00007           1014mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004BC                          1015mmm     ENDC
000004BC                          1016mmm 
000004BC                 FALSE    1017mmm     IFNE DEBUG
000004BC                          1018mmm     ENDC
000004BC                          1019mmm 
000004BC                          1020mmm     ENDM
000004BC  60E4                    1021mm     BRA LOOP_35
000004BE                          1022mm EXIT_35
000004BE                          1023mm     ENDM
000004BE  7A07                    1024m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004C0                          1025m LOOP_34
000004C0                          1026mm     BIN2HEX D2,D4,A0
000004C0  41FA 1B4D               1027mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004C4  E99A                    1028mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004C6  1802                    1029mm     MOVE.B D2,D4
000004C8  0284 0000000F           1030mm     ANDI.L #$F,D4
000004CE  1830 4000               1031mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004D2                          1032mm     ENDM
000004D2                          1033mm     PRINT_CHAR D4,D3
000004D2                          1034mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D2                 TRUE     1035mm     IFEQ DEBUG
000004D2  1639 00C00003           1036mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004D8  0803 0002               1037mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004DC  67F4                    1038mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004DE  13C4 00C00007           1039mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E4                          1040mm     ENDC
000004E4                          1041mm 
000004E4                 FALSE    1042mm     IFNE DEBUG
000004E4                          1043mm     ENDC
000004E4                          1044mm 
000004E4                          1045mm     ENDM
000004E4  57CD FFDA               1046m     DBEQ D5,LOOP_34
000004E8                          1047m     ENDM
000004E8                          1048      
000004E8                          1049m     PRINT_CHAR #32,D3
000004E8                          1050m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E8                 TRUE     1051m     IFEQ DEBUG
000004E8  1639 00C00003           1052m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EE  0803 0002               1053m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F2  67F4                    1054m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004F4  13FC 0020 00C00007      1055m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004FC                          1056m     ENDC
000004FC                          1057m 
000004FC                 FALSE    1058m     IFNE DEBUG
000004FC                          1059m     ENDC
000004FC                          1060m 
000004FC                          1061m     ENDM
000004FC                          1062  
000004FC  E19A                    1063      ROL.L #8,D2
000004FE                          1064m     PRINT_CHAR D2,D3
000004FE                          1065m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FE                 TRUE     1066m     IFEQ DEBUG
000004FE  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000504  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000508  67F4                    1069m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000050A  13C2 00C00007           1070m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000510                          1071m     ENDC
00000510                          1072m 
00000510                 FALSE    1073m     IFNE DEBUG
00000510                          1074m     ENDC
00000510                          1075m 
00000510                          1076m     ENDM
00000510  E19A                    1077      ROL.L #8,D2
00000512                          1078m     PRINT_CHAR D2,D3
00000512                          1079m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1080m     IFEQ DEBUG
00000512  1639 00C00003           1081m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1082m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1083m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1084m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1085m     ENDC
00000524                          1086m 
00000524                 FALSE    1087m     IFNE DEBUG
00000524                          1088m     ENDC
00000524                          1089m 
00000524                          1090m     ENDM
00000524  E19A                    1091      ROL.L #8,D2
00000526                          1092m     PRINT_CHAR D2,D3
00000526                          1093m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1094m     IFEQ DEBUG
00000526  1639 00C00003           1095m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1096m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1097m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1098m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1099m     ENDC
00000538                          1100m 
00000538                 FALSE    1101m     IFNE DEBUG
00000538                          1102m     ENDC
00000538                          1103m 
00000538                          1104m     ENDM
00000538  E19A                    1105      ROL.L #8,D2
0000053A                          1106m     PRINT_CHAR D2,D3
0000053A                          1107m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1108m     IFEQ DEBUG
0000053A  1639 00C00003           1109m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1110m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1111m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1112m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1113m     ENDC
0000054C                          1114m 
0000054C                 FALSE    1115m     IFNE DEBUG
0000054C                          1116m     ENDC
0000054C                          1117m 
0000054C                          1118m     ENDM
0000054C                          1119  
0000054C                          1120m     PRINT_CRLF D3,A0
0000054C  41FA 1AFC               1121m     LEA CRLF(PC),A0
00000550                          1122mm     PRINT_STR A0,D3
00000550                          1123mm LOOP_45
00000550  0C10 0000               1124mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000554  6700 0016               1125mm     BEQ EXIT_45
00000558                          1126mmm     PRINT_CHAR (A0)+,D3
00000558                          1127mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000558                 TRUE     1128mmm     IFEQ DEBUG
00000558  1639 00C00003           1129mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000055E  0803 0002               1130mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000562  67F4                    1131mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000564  13D8 00C00007           1132mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000056A                          1133mmm     ENDC
0000056A                          1134mmm 
0000056A                 FALSE    1135mmm     IFNE DEBUG
0000056A                          1136mmm     ENDC
0000056A                          1137mmm 
0000056A                          1138mmm     ENDM
0000056A  60E4                    1139mm     BRA LOOP_45
0000056C                          1140mm EXIT_45
0000056C                          1141mm     ENDM
0000056C                          1142m     ENDM
0000056C                          1143      
0000056C  6000 FDD6               1144      BRA MAIN_LOOP
00000570                          1145  
00000570                          1146  W
00000570                          1147      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000570  3C3C 0000               1148s     MOVE.W  #0,D6
00000574  6000 0046               1149s     BRA _20000005
00000578                          1150s _20000004
00000578  E98D                    1151          LSL.L #4,D5                                     ; make what we have so far more significant
0000057A                          1152m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000057A                          1153m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000057A                 TRUE     1154m     IFEQ DEBUG
0000057A  1639 00C00003           1155m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000580  0803 0000               1156m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000584  67F4                    1157m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000586                          1158m     ENDC
00000586                          1159m 
00000586                          1160mm     READ_CHAR D2
00000586                 TRUE     1161mm     IFEQ DEBUG
00000586  1439 00C00007           1162mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000058C                          1163mm     ENDC
0000058C                 FALSE    1164mm     IFNE DEBUG
0000058C                          1165mm     ENDC
0000058C                          1166mm 
0000058C  B43C 001B               1167mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000590  6700 FB72               1168mm     BEQ START
00000594                          1169mm     ENDM
00000594                          1170m 
00000594                 TRUE     1171m     IFEQ DEBUG
00000594                          1172mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000594                          1173mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                 TRUE     1174mm     IFEQ DEBUG
00000594  1639 00C00003           1175mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000059A  0803 0002               1176mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000059E  67F4                    1177mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005A0  13C2 00C00007           1178mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A6                          1179mm     ENDC
000005A6                          1180mm 
000005A6                 FALSE    1181mm     IFNE DEBUG
000005A6                          1182mm     ENDC
000005A6                          1183mm 
000005A6                          1184mm     ENDM
000005A6                          1185m     ENDC
000005A6                          1186m     ENDM
000005A6                          1187m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005A6  41FA 1A77               1188m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005AA  0402 0030               1189m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005AE  C4BC 000000FF           1190m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005B4  1430 2000               1191m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B8                          1192m     ENDM
000005B8  8A02                    1193          OR.B D2,D5
000005BA                          1194      ENDF
000005BA  5246                    1195s     ADD.W   #1,D6
000005BC                          1196s _20000005
000005BC  BC7C 0007               1197s     CMP.W   #7,D6
000005C0  6FB6                    1198s     BLE _20000004
000005C2                          1199  
000005C2                          1200m     PRINT_CRLF D3,A0
000005C2  41FA 1A86               1201m     LEA CRLF(PC),A0
000005C6                          1202mm     PRINT_STR A0,D3
000005C6                          1203mm LOOP_52
000005C6  0C10 0000               1204mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005CA  6700 0016               1205mm     BEQ EXIT_52
000005CE                          1206mmm     PRINT_CHAR (A0)+,D3
000005CE                          1207mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                 TRUE     1208mmm     IFEQ DEBUG
000005CE  1639 00C00003           1209mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005D4  0803 0002               1210mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005D8  67F4                    1211mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005DA  13D8 00C00007           1212mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005E0                          1213mmm     ENDC
000005E0                          1214mmm 
000005E0                 FALSE    1215mmm     IFNE DEBUG
000005E0                          1216mmm     ENDC
000005E0                          1217mmm 
000005E0                          1218mmm     ENDM
000005E0  60E4                    1219mm     BRA LOOP_52
000005E2                          1220mm EXIT_52
000005E2                          1221mm     ENDM
000005E2                          1222m     ENDM
000005E2                          1223  
000005E2  2047                    1224      MOVE.L D7,A0                                    ; address accumulator -> address register
000005E4  7E00                    1225      MOVE.L #0,D7                                    ; clear the now used address accumulator
000005E6                          1226  
000005E6  2085                    1227      MOVE.L D5,(A0)                                  ; write the data
000005E8                          1228  
000005E8  6000 FD5A               1229      BRA MAIN_LOOP
000005EC                          1230  
000005EC                          1231  ; register map for S
000005EC                          1232  ; A0 - start address
000005EC                          1233  ; A1 - offset
000005EC                          1234  ; A2 - next address to write
000005EC                          1235  ; A3 - next location (jmp)
000005EC                          1236  ; A4 - Working Address Register
000005EC                          1237  ; D0 - record count
000005EC                          1238  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005EC                          1239  ; D2 - checksum
000005EC                          1240  ; D3 - data byte count
000005EC                          1241  ; D4 - read address, moved into A2
000005EC                          1242  ; D5 - temp
000005EC                          1243  ; D6 - temp
000005EC                          1244  ; D7 - temp
000005EC                          1245  S
000005EC  2078 0000               1246      MOVE.L 0,A0                                     ; start address -> A0
000005F0  2247                    1247      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005F2                          1248      
000005F2  7000                    1249      MOVE.L #0,D0                                    ; count of records read -> D0
000005F4                          1250          
000005F4                          1251  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005F4                          1252m     DOWNLOAD D1
000005F4                          1253m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F4                          1254m 
000005F4  1239 00C00003           1255m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005FA  0801 0000               1256m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005FE  6700 0010               1257m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000602                          1258m 
00000602                          1259mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000602                 TRUE     1260mm     IFEQ DEBUG
00000602  1239 00C00007           1261mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000608                          1262mm     ENDC
00000608                 FALSE    1263mm     IFNE DEBUG
00000608                          1264mm     ENDC
00000608                          1265mm 
00000608  B23C 001B               1266mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000060C  6700 FAF6               1267mm     BEQ START
00000610                          1268mm     ENDM
00000610                          1269m CONTINUE_54
00000610  1239 00C00013           1270m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000616  0801 0000               1271m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061A  67D8                    1272m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
0000061C                          1273m     
0000061C  1239 00C00017           1274m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000622  13C1 00E00001           1275m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000628                          1276m 
00000628                          1277m     ENDM
00000628  B23C 0053               1278      CMP.B #'S',D1                                   ; found S?
0000062C  66C6                    1279      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000062E                          1280      
0000062E                          1281m     PRINT_CHAR #'S',D5                              ; print the S
0000062E                          1282m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                 TRUE     1283m     IFEQ DEBUG
0000062E  1A39 00C00003           1284m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000634  0805 0002               1285m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000638  67F4                    1286m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000063A  13FC 0053 00C00007      1287m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000642                          1288m     ENDC
00000642                          1289m 
00000642                 FALSE    1290m     IFNE DEBUG
00000642                          1291m     ENDC
00000642                          1292m 
00000642                          1293m     ENDM
00000642  5280                    1294      ADD.L #1,D0                                     ; read another S record, increment count
00000644                          1295      
00000644                          1296m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000644                          1297m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000644                          1298m 
00000644  1239 00C00003           1299m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000064A  0801 0000               1300m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000064E  6700 0010               1301m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000652                          1302m 
00000652                          1303mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000652                 TRUE     1304mm     IFEQ DEBUG
00000652  1239 00C00007           1305mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000658                          1306mm     ENDC
00000658                 FALSE    1307mm     IFNE DEBUG
00000658                          1308mm     ENDC
00000658                          1309mm 
00000658  B23C 001B               1310mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000065C  6700 FAA6               1311mm     BEQ START
00000660                          1312mm     ENDM
00000660                          1313m CONTINUE_57
00000660  1239 00C00013           1314m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000666  0801 0000               1315m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000066A  67D8                    1316m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000066C                          1317m     
0000066C  1239 00C00017           1318m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000672  13C1 00E00001           1319m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000678                          1320m 
00000678                          1321m     ENDM
00000678                          1322m     PRINT_CHAR D1,D5
00000678                          1323m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000678                 TRUE     1324m     IFEQ DEBUG
00000678  1A39 00C00003           1325m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000067E  0805 0002               1326m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000682  67F4                    1327m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000684  13C1 00C00007           1328m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000068A                          1329m     ENDC
0000068A                          1330m 
0000068A                 FALSE    1331m     IFNE DEBUG
0000068A                          1332m     ENDC
0000068A                          1333m 
0000068A                          1334m     ENDM
0000068A                          1335  
0000068A  7400                    1336      MOVE.L #0,D2                                    ; clear the checksum
0000068C                          1337  
0000068C                          1338m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000068C  1E3C 0002               1339m     MOVE.B #2,D7
00000690                          1340m     WHILE.B D7 <GT> 0 DO
00000690                          1341ms _10000000
00000690  BE38 0000               1342ms     CMP.B   0,D7
00000694  6F00 0062               1343ms     BLE _10000001
00000698  E98B                    1344m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000069A                          1345mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000069A                          1346mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069A                          1347mm 
0000069A  1A39 00C00003           1348mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006A0  0805 0000               1349mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006A4  6700 0010               1350mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
000006A8                          1351mm 
000006A8                          1352mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006A8                 TRUE     1353mmm     IFEQ DEBUG
000006A8  1A39 00C00007           1354mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006AE                          1355mmm     ENDC
000006AE                 FALSE    1356mmm     IFNE DEBUG
000006AE                          1357mmm     ENDC
000006AE                          1358mmm 
000006AE  BA3C 001B               1359mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006B2  6700 FA50               1360mmm     BEQ START
000006B6                          1361mmm     ENDM
000006B6                          1362mm CONTINUE_61
000006B6  1A39 00C00013           1363mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006BC  0805 0000               1364mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C0  67D8                    1365mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000006C2                          1366mm     
000006C2  1A39 00C00017           1367mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006C8  13C5 00E00001           1368mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006CE                          1369mm 
000006CE                          1370mm     ENDM
000006CE                          1371mm         PRINT_CHAR D5,D6
000006CE                          1372mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006CE                 TRUE     1373mm     IFEQ DEBUG
000006CE  1C39 00C00003           1374mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006D4  0806 0002               1375mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006D8  67F4                    1376mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006DA  13C5 00C00007           1377mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006E0                          1378mm     ENDC
000006E0                          1379mm 
000006E0                 FALSE    1380mm     IFNE DEBUG
000006E0                          1381mm     ENDC
000006E0                          1382mm 
000006E0                          1383mm     ENDM
000006E0                          1384mm         HEX2BIN D5,D5,A4
000006E0  49FA 193D               1385mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006E4  0405 0030               1386mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006E8  CABC 000000FF           1387mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006EE  1A34 5000               1388mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006F2                          1389mm     ENDM
000006F2  8605                    1390m         OR.B D5,D3
000006F4  5307                    1391m         SUB.B #1,D7
000006F6                          1392m     ENDW
000006F6  6098                    1393ms     BRA _10000000
000006F8                          1394ms _10000001
000006F8                          1395m 
000006F8  7A00                    1396m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006FA  1A03                    1397m     MOVE.B D3,D5
000006FC  D483                    1398m     ADD.L D3,D2
000006FE                          1399m 
000006FE                          1400m     ENDM
000006FE                          1401  
000006FE                          1402      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006FE  B23C 0030               1403s     CMP.B   #'0',D1
00000702  6600 002A               1404s     BNE.L   _00000003
00000706                          1405m         PRINT_CRLF D5,A4
00000706  49FA 1942               1406m     LEA CRLF(PC),A4
0000070A                          1407mm     PRINT_STR A4,D5
0000070A                          1408mm LOOP_66
0000070A  0C14 0000               1409mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000070E  6700 0016               1410mm     BEQ EXIT_66
00000712                          1411mmm     PRINT_CHAR (A4)+,D5
00000712                          1412mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000712                 TRUE     1413mmm     IFEQ DEBUG
00000712  1A39 00C00003           1414mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000718  0805 0002               1415mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000071C  67F4                    1416mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
0000071E  13DC 00C00007           1417mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000724                          1418mmm     ENDC
00000724                          1419mmm 
00000724                 FALSE    1420mmm     IFNE DEBUG
00000724                          1421mmm     ENDC
00000724                          1422mmm 
00000724                          1423mmm     ENDM
00000724  60E4                    1424mm     BRA LOOP_66
00000726                          1425mm EXIT_66
00000726                          1426mm     ENDM
00000726                          1427m     ENDM
00000726  6000 FECC               1428          BRA WAIT_FOR_SRECORD
0000072A                          1429      ELSE
0000072A  6000 03DE               1430s     BRA _00000004
0000072E                          1431s _00000003
0000072E                          1432          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
0000072E  B23C 0031               1433s     CMP.B   #'1',D1
00000732  6708                    1434s     BEQ.S   _00000005
00000734  B23C 0032               1435s     CMP.B   #'2',D1
00000738  6600 01F0               1436s     BNE.L   _00000006
0000073C                          1437s _00000005
0000073C  5783                    1438              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000073E                          1439  
0000073E  7800                    1440              MOVE.L #0,D4                            ; read two bytes of address
00000740                          1441m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000740  1E3C 0002               1442m     MOVE.B #2,D7
00000744                          1443m     WHILE.B D7 <GT> 0 DO
00000744                          1444ms _10000002
00000744  BE38 0000               1445ms     CMP.B   0,D7
00000748  6F00 0062               1446ms     BLE _10000003
0000074C  E98C                    1447m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000074E                          1448mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000074E                          1449mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000074E                          1450mm 
0000074E  1A39 00C00003           1451mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000754  0805 0000               1452mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000758  6700 0010               1453mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
0000075C                          1454mm 
0000075C                          1455mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075C                 TRUE     1456mmm     IFEQ DEBUG
0000075C  1A39 00C00007           1457mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000762                          1458mmm     ENDC
00000762                 FALSE    1459mmm     IFNE DEBUG
00000762                          1460mmm     ENDC
00000762                          1461mmm 
00000762  BA3C 001B               1462mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000766  6700 F99C               1463mmm     BEQ START
0000076A                          1464mmm     ENDM
0000076A                          1465mm CONTINUE_69
0000076A  1A39 00C00013           1466mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000770  0805 0000               1467mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000774  67D8                    1468mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000776                          1469mm     
00000776  1A39 00C00017           1470mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000077C  13C5 00E00001           1471mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000782                          1472mm 
00000782                          1473mm     ENDM
00000782                          1474mm         PRINT_CHAR D5,D6
00000782                          1475mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000782                 TRUE     1476mm     IFEQ DEBUG
00000782  1C39 00C00003           1477mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000788  0806 0002               1478mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000078C  67F4                    1479mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000078E  13C5 00C00007           1480mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000794                          1481mm     ENDC
00000794                          1482mm 
00000794                 FALSE    1483mm     IFNE DEBUG
00000794                          1484mm     ENDC
00000794                          1485mm 
00000794                          1486mm     ENDM
00000794                          1487mm         HEX2BIN D5,D5,A4
00000794  49FA 1889               1488mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000798  0405 0030               1489mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000079C  CABC 000000FF           1490mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007A2  1A34 5000               1491mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007A6                          1492mm     ENDM
000007A6  8805                    1493m         OR.B D5,D4
000007A8  5307                    1494m         SUB.B #1,D7
000007AA                          1495m     ENDW
000007AA  6098                    1496ms     BRA _10000002
000007AC                          1497ms _10000003
000007AC                          1498m 
000007AC  7A00                    1499m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007AE  1A04                    1500m     MOVE.B D4,D5
000007B0  D484                    1501m     ADD.L D4,D2
000007B2                          1502m 
000007B2                          1503m     ENDM
000007B2                          1504m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
000007B2  1E3C 0002               1505m     MOVE.B #2,D7
000007B6                          1506m     WHILE.B D7 <GT> 0 DO
000007B6                          1507ms _10000004
000007B6  BE38 0000               1508ms     CMP.B   0,D7
000007BA  6F00 0062               1509ms     BLE _10000005
000007BE  E98C                    1510m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007C0                          1511mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007C0                          1512mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C0                          1513mm 
000007C0  1A39 00C00003           1514mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007C6  0805 0000               1515mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007CA  6700 0010               1516mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
000007CE                          1517mm 
000007CE                          1518mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007CE                 TRUE     1519mmm     IFEQ DEBUG
000007CE  1A39 00C00007           1520mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007D4                          1521mmm     ENDC
000007D4                 FALSE    1522mmm     IFNE DEBUG
000007D4                          1523mmm     ENDC
000007D4                          1524mmm 
000007D4  BA3C 001B               1525mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007D8  6700 F92A               1526mmm     BEQ START
000007DC                          1527mmm     ENDM
000007DC                          1528mm CONTINUE_74
000007DC  1A39 00C00013           1529mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007E2  0805 0000               1530mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E6  67D8                    1531mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000007E8                          1532mm     
000007E8  1A39 00C00017           1533mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007EE  13C5 00E00001           1534mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007F4                          1535mm 
000007F4                          1536mm     ENDM
000007F4                          1537mm         PRINT_CHAR D5,D6
000007F4                          1538mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007F4                 TRUE     1539mm     IFEQ DEBUG
000007F4  1C39 00C00003           1540mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007FA  0806 0002               1541mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007FE  67F4                    1542mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
00000800  13C5 00C00007           1543mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000806                          1544mm     ENDC
00000806                          1545mm 
00000806                 FALSE    1546mm     IFNE DEBUG
00000806                          1547mm     ENDC
00000806                          1548mm 
00000806                          1549mm     ENDM
00000806                          1550mm         HEX2BIN D5,D5,A4
00000806  49FA 1817               1551mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000080A  0405 0030               1552mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000080E  CABC 000000FF           1553mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000814  1A34 5000               1554mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000818                          1555mm     ENDM
00000818  8805                    1556m         OR.B D5,D4
0000081A  5307                    1557m         SUB.B #1,D7
0000081C                          1558m     ENDW
0000081C  6098                    1559ms     BRA _10000004
0000081E                          1560ms _10000005
0000081E                          1561m 
0000081E  7A00                    1562m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000820  1A04                    1563m     MOVE.B D4,D5
00000822  D484                    1564m     ADD.L D4,D2
00000824                          1565m 
00000824                          1566m     ENDM
00000824                          1567  
00000824                          1568              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000824  B23C 0032               1569s     CMP.B   #'2',D1
00000828  6600 0076               1570s     BNE.L   _00000007
0000082C  5383                    1571                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000082E                          1572m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000082E  1E3C 0002               1573m     MOVE.B #2,D7
00000832                          1574m     WHILE.B D7 <GT> 0 DO
00000832                          1575ms _10000006
00000832  BE38 0000               1576ms     CMP.B   0,D7
00000836  6F00 0062               1577ms     BLE _10000007
0000083A  E98C                    1578m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000083C                          1579mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000083C                          1580mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083C                          1581mm 
0000083C  1A39 00C00003           1582mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000842  0805 0000               1583mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000846  6700 0010               1584mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000084A                          1585mm 
0000084A                          1586mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                 TRUE     1587mmm     IFEQ DEBUG
0000084A  1A39 00C00007           1588mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000850                          1589mmm     ENDC
00000850                 FALSE    1590mmm     IFNE DEBUG
00000850                          1591mmm     ENDC
00000850                          1592mmm 
00000850  BA3C 001B               1593mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000854  6700 F8AE               1594mmm     BEQ START
00000858                          1595mmm     ENDM
00000858                          1596mm CONTINUE_79
00000858  1A39 00C00013           1597mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000085E  0805 0000               1598mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000862  67D8                    1599mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000864                          1600mm     
00000864  1A39 00C00017           1601mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000086A  13C5 00E00001           1602mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000870                          1603mm 
00000870                          1604mm     ENDM
00000870                          1605mm         PRINT_CHAR D5,D6
00000870                          1606mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1607mm     IFEQ DEBUG
00000870  1C39 00C00003           1608mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000876  0806 0002               1609mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1610mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
0000087C  13C5 00C00007           1611mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000882                          1612mm     ENDC
00000882                          1613mm 
00000882                 FALSE    1614mm     IFNE DEBUG
00000882                          1615mm     ENDC
00000882                          1616mm 
00000882                          1617mm     ENDM
00000882                          1618mm         HEX2BIN D5,D5,A4
00000882  49FA 179B               1619mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000886  0405 0030               1620mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000088A  CABC 000000FF           1621mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000890  1A34 5000               1622mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000894                          1623mm     ENDM
00000894  8805                    1624m         OR.B D5,D4
00000896  5307                    1625m         SUB.B #1,D7
00000898                          1626m     ENDW
00000898  6098                    1627ms     BRA _10000006
0000089A                          1628ms _10000007
0000089A                          1629m 
0000089A  7A00                    1630m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000089C  1A04                    1631m     MOVE.B D4,D5
0000089E  D484                    1632m     ADD.L D4,D2
000008A0                          1633m 
000008A0                          1634m     ENDM
000008A0                          1635              ENDI
000008A0                          1636s _00000007
000008A0                          1637  
000008A0  2444                    1638              MOVE.L D4,A2                            ; put the address in an address register
000008A2  D5C9                    1639              ADD.L A1,A2                             ; add in the offset
000008A4                          1640  
000008A4                          1641              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
000008A4                          1642s _10000008
000008A4  B63C 0000               1643s     CMP.B   #0,D3
000008A8  6F00 007A               1644s     BLE _10000009
000008AC                          1645m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000008AC  1E3C 0002               1646m     MOVE.B #2,D7
000008B0                          1647m     WHILE.B D7 <GT> 0 DO
000008B0                          1648ms _1000000A
000008B0  BE38 0000               1649ms     CMP.B   0,D7
000008B4  6F00 0062               1650ms     BLE _1000000B
000008B8  E989                    1651m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000008BA                          1652mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008BA                          1653mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BA                          1654mm 
000008BA  1A39 00C00003           1655mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008C0  0805 0000               1656mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C4  6700 0010               1657mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
000008C8                          1658mm 
000008C8                          1659mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008C8                 TRUE     1660mmm     IFEQ DEBUG
000008C8  1A39 00C00007           1661mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008CE                          1662mmm     ENDC
000008CE                 FALSE    1663mmm     IFNE DEBUG
000008CE                          1664mmm     ENDC
000008CE                          1665mmm 
000008CE  BA3C 001B               1666mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008D2  6700 F830               1667mmm     BEQ START
000008D6                          1668mmm     ENDM
000008D6                          1669mm CONTINUE_84
000008D6  1A39 00C00013           1670mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DC  0805 0000               1671mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E0  67D8                    1672mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000008E2                          1673mm     
000008E2  1A39 00C00017           1674mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008E8  13C5 00E00001           1675mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008EE                          1676mm 
000008EE                          1677mm     ENDM
000008EE                          1678mm         PRINT_CHAR D5,D6
000008EE                          1679mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008EE                 TRUE     1680mm     IFEQ DEBUG
000008EE  1C39 00C00003           1681mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008F4  0806 0002               1682mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008F8  67F4                    1683mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
000008FA  13C5 00C00007           1684mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000900                          1685mm     ENDC
00000900                          1686mm 
00000900                 FALSE    1687mm     IFNE DEBUG
00000900                          1688mm     ENDC
00000900                          1689mm 
00000900                          1690mm     ENDM
00000900                          1691mm         HEX2BIN D5,D5,A4
00000900  49FA 171D               1692mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000904  0405 0030               1693mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000908  CABC 000000FF           1694mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000090E  1A34 5000               1695mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000912                          1696mm     ENDM
00000912  8205                    1697m         OR.B D5,D1
00000914  5307                    1698m         SUB.B #1,D7
00000916                          1699m     ENDW
00000916  6098                    1700ms     BRA _1000000A
00000918                          1701ms _1000000B
00000918                          1702m 
00000918  7A00                    1703m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000091A  1A01                    1704m     MOVE.B D1,D5
0000091C  D481                    1705m     ADD.L D1,D2
0000091E                          1706m 
0000091E                          1707m     ENDM
0000091E                          1708   
0000091E  14C1                    1709                  MOVE.B D1,(A2)+                     ; store it!
00000920                          1710  
00000920  5303                    1711                  SUB.B #1,D3                         ; 1 less byte to go
00000922                          1712              ENDW
00000922  6080                    1713s     BRA _10000008
00000924                          1714s _10000009
00000924                          1715  
00000924  7200                    1716              MOVE.L #0,D1                            ; not done yet
00000926                          1717          ELSE
00000926  6000 01E2               1718s     BRA _00000008
0000092A                          1719s _00000006
0000092A                          1720              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
0000092A  B23C 0038               1721s     CMP.B   #'8',D1
0000092E  6600 0164               1722s     BNE.L   _00000009
00000932  7800                    1723                  MOVE.L #0,D4                        ; read the 24 bit start address
00000934                          1724m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000934  1E3C 0002               1725m     MOVE.B #2,D7
00000938                          1726m     WHILE.B D7 <GT> 0 DO
00000938                          1727ms _1000000C
00000938  BE38 0000               1728ms     CMP.B   0,D7
0000093C  6F00 0062               1729ms     BLE _1000000D
00000940  E98C                    1730m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000942                          1731mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000942                          1732mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000942                          1733mm 
00000942  1A39 00C00003           1734mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000948  0805 0000               1735mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000094C  6700 0010               1736mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000950                          1737mm 
00000950                          1738mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000950                 TRUE     1739mmm     IFEQ DEBUG
00000950  1A39 00C00007           1740mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000956                          1741mmm     ENDC
00000956                 FALSE    1742mmm     IFNE DEBUG
00000956                          1743mmm     ENDC
00000956                          1744mmm 
00000956  BA3C 001B               1745mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000095A  6700 F7A8               1746mmm     BEQ START
0000095E                          1747mmm     ENDM
0000095E                          1748mm CONTINUE_89
0000095E  1A39 00C00013           1749mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000964  0805 0000               1750mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000968  67D8                    1751mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
0000096A                          1752mm     
0000096A  1A39 00C00017           1753mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000970  13C5 00E00001           1754mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000976                          1755mm 
00000976                          1756mm     ENDM
00000976                          1757mm         PRINT_CHAR D5,D6
00000976                          1758mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000976                 TRUE     1759mm     IFEQ DEBUG
00000976  1C39 00C00003           1760mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000097C  0806 0002               1761mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000980  67F4                    1762mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000982  13C5 00C00007           1763mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000988                          1764mm     ENDC
00000988                          1765mm 
00000988                 FALSE    1766mm     IFNE DEBUG
00000988                          1767mm     ENDC
00000988                          1768mm 
00000988                          1769mm     ENDM
00000988                          1770mm         HEX2BIN D5,D5,A4
00000988  49FA 1695               1771mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000098C  0405 0030               1772mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000990  CABC 000000FF           1773mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000996  1A34 5000               1774mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000099A                          1775mm     ENDM
0000099A  8805                    1776m         OR.B D5,D4
0000099C  5307                    1777m         SUB.B #1,D7
0000099E                          1778m     ENDW
0000099E  6098                    1779ms     BRA _1000000C
000009A0                          1780ms _1000000D
000009A0                          1781m 
000009A0  7A00                    1782m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009A2  1A04                    1783m     MOVE.B D4,D5
000009A4  D484                    1784m     ADD.L D4,D2
000009A6                          1785m 
000009A6                          1786m     ENDM
000009A6                          1787m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
000009A6  1E3C 0002               1788m     MOVE.B #2,D7
000009AA                          1789m     WHILE.B D7 <GT> 0 DO
000009AA                          1790ms _1000000E
000009AA  BE38 0000               1791ms     CMP.B   0,D7
000009AE  6F00 0062               1792ms     BLE _1000000F
000009B2  E98C                    1793m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B4                          1794mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B4                          1795mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B4                          1796mm 
000009B4  1A39 00C00003           1797mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009BA  0805 0000               1798mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009BE  6700 0010               1799mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
000009C2                          1800mm 
000009C2                          1801mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C2                 TRUE     1802mmm     IFEQ DEBUG
000009C2  1A39 00C00007           1803mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C8                          1804mmm     ENDC
000009C8                 FALSE    1805mmm     IFNE DEBUG
000009C8                          1806mmm     ENDC
000009C8                          1807mmm 
000009C8  BA3C 001B               1808mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CC  6700 F736               1809mmm     BEQ START
000009D0                          1810mmm     ENDM
000009D0                          1811mm CONTINUE_94
000009D0  1A39 00C00013           1812mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D6  0805 0000               1813mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009DA  67D8                    1814mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
000009DC                          1815mm     
000009DC  1A39 00C00017           1816mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E2  13C5 00E00001           1817mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E8                          1818mm 
000009E8                          1819mm     ENDM
000009E8                          1820mm         PRINT_CHAR D5,D6
000009E8                          1821mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E8                 TRUE     1822mm     IFEQ DEBUG
000009E8  1C39 00C00003           1823mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009EE  0806 0002               1824mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F2  67F4                    1825mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000009F4  13C5 00C00007           1826mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009FA                          1827mm     ENDC
000009FA                          1828mm 
000009FA                 FALSE    1829mm     IFNE DEBUG
000009FA                          1830mm     ENDC
000009FA                          1831mm 
000009FA                          1832mm     ENDM
000009FA                          1833mm         HEX2BIN D5,D5,A4
000009FA  49FA 1623               1834mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009FE  0405 0030               1835mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A02  CABC 000000FF           1836mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A08  1A34 5000               1837mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0C                          1838mm     ENDM
00000A0C  8805                    1839m         OR.B D5,D4
00000A0E  5307                    1840m         SUB.B #1,D7
00000A10                          1841m     ENDW
00000A10  6098                    1842ms     BRA _1000000E
00000A12                          1843ms _1000000F
00000A12                          1844m 
00000A12  7A00                    1845m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A14  1A04                    1846m     MOVE.B D4,D5
00000A16  D484                    1847m     ADD.L D4,D2
00000A18                          1848m 
00000A18                          1849m     ENDM
00000A18                          1850m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000A18  1E3C 0002               1851m     MOVE.B #2,D7
00000A1C                          1852m     WHILE.B D7 <GT> 0 DO
00000A1C                          1853ms _10000010
00000A1C  BE38 0000               1854ms     CMP.B   0,D7
00000A20  6F00 0062               1855ms     BLE _10000011
00000A24  E98C                    1856m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A26                          1857mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A26                          1858mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                          1859mm 
00000A26  1A39 00C00003           1860mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A2C  0805 0000               1861mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A30  6700 0010               1862mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000A34                          1863mm 
00000A34                          1864mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A34                 TRUE     1865mmm     IFEQ DEBUG
00000A34  1A39 00C00007           1866mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A3A                          1867mmm     ENDC
00000A3A                 FALSE    1868mmm     IFNE DEBUG
00000A3A                          1869mmm     ENDC
00000A3A                          1870mmm 
00000A3A  BA3C 001B               1871mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A3E  6700 F6C4               1872mmm     BEQ START
00000A42                          1873mmm     ENDM
00000A42                          1874mm CONTINUE_99
00000A42  1A39 00C00013           1875mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A48  0805 0000               1876mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A4C  67D8                    1877mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000A4E                          1878mm     
00000A4E  1A39 00C00017           1879mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A54  13C5 00E00001           1880mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A5A                          1881mm 
00000A5A                          1882mm     ENDM
00000A5A                          1883mm         PRINT_CHAR D5,D6
00000A5A                          1884mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A5A                 TRUE     1885mm     IFEQ DEBUG
00000A5A  1C39 00C00003           1886mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A60  0806 0002               1887mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A64  67F4                    1888mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000A66  13C5 00C00007           1889mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A6C                          1890mm     ENDC
00000A6C                          1891mm 
00000A6C                 FALSE    1892mm     IFNE DEBUG
00000A6C                          1893mm     ENDC
00000A6C                          1894mm 
00000A6C                          1895mm     ENDM
00000A6C                          1896mm         HEX2BIN D5,D5,A4
00000A6C  49FA 15B1               1897mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A70  0405 0030               1898mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A74  CABC 000000FF           1899mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A7A  1A34 5000               1900mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A7E                          1901mm     ENDM
00000A7E  8805                    1902m         OR.B D5,D4
00000A80  5307                    1903m         SUB.B #1,D7
00000A82                          1904m     ENDW
00000A82  6098                    1905ms     BRA _10000010
00000A84                          1906ms _10000011
00000A84                          1907m 
00000A84  7A00                    1908m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A86  1A04                    1909m     MOVE.B D4,D5
00000A88  D484                    1910m     ADD.L D4,D2
00000A8A                          1911m 
00000A8A                          1912m     ENDM
00000A8A                          1913  
00000A8A  2044                    1914                  MOVE.L D4,A0                        ; start address -> A0
00000A8C  D1C9                    1915                  ADD.L A1,A0                         ; add in the offset
00000A8E                          1916  
00000A8E  72FF                    1917                  MOVE.L #$FFFFFFFF,D1                ; done
00000A90                          1918              ELSE
00000A90  6000 0078               1919s     BRA _0000000A
00000A94                          1920s _00000009
00000A94                          1921m                 PRINT_CRLF D5,A4
00000A94  49FA 15B4               1922m     LEA CRLF(PC),A4
00000A98                          1923mm     PRINT_STR A4,D5
00000A98                          1924mm LOOP_104
00000A98  0C14 0000               1925mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A9C  6700 0016               1926mm     BEQ EXIT_104
00000AA0                          1927mmm     PRINT_CHAR (A4)+,D5
00000AA0                          1928mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA0                 TRUE     1929mmm     IFEQ DEBUG
00000AA0  1A39 00C00003           1930mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA6  0805 0002               1931mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAA  67F4                    1932mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000AAC  13DC 00C00007           1933mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AB2                          1934mmm     ENDC
00000AB2                          1935mmm 
00000AB2                 FALSE    1936mmm     IFNE DEBUG
00000AB2                          1937mmm     ENDC
00000AB2                          1938mmm 
00000AB2                          1939mmm     ENDM
00000AB2  60E4                    1940mm     BRA LOOP_104
00000AB4                          1941mm EXIT_104
00000AB4                          1942mm     ENDM
00000AB4                          1943m     ENDM
00000AB4                          1944  
00000AB4  49FA 1520               1945                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000AB8                          1946m                 PRINT_STR A4,D5
00000AB8                          1947m LOOP_106
00000AB8  0C14 0000               1948m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ABC  6700 0016               1949m     BEQ EXIT_106
00000AC0                          1950mm     PRINT_CHAR (A4)+,D5
00000AC0                          1951mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC0                 TRUE     1952mm     IFEQ DEBUG
00000AC0  1A39 00C00003           1953mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC6  0805 0002               1954mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACA  67F4                    1955mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000ACC  13DC 00C00007           1956mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD2                          1957mm     ENDC
00000AD2                          1958mm 
00000AD2                 FALSE    1959mm     IFNE DEBUG
00000AD2                          1960mm     ENDC
00000AD2                          1961mm 
00000AD2                          1962mm     ENDM
00000AD2  60E4                    1963m     BRA LOOP_106
00000AD4                          1964m EXIT_106
00000AD4                          1965m     ENDM
00000AD4                          1966m                 PRINT_CHAR D1,D5
00000AD4                          1967m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD4                 TRUE     1968m     IFEQ DEBUG
00000AD4  1A39 00C00003           1969m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ADA  0805 0002               1970m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ADE  67F4                    1971m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AE0  13C1 00C00007           1972m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AE6                          1973m     ENDC
00000AE6                          1974m 
00000AE6                 FALSE    1975m     IFNE DEBUG
00000AE6                          1976m     ENDC
00000AE6                          1977m 
00000AE6                          1978m     ENDM
00000AE6                          1979m                 PRINT_CRLF D5,A4
00000AE6  49FA 1562               1980m     LEA CRLF(PC),A4
00000AEA                          1981mm     PRINT_STR A4,D5
00000AEA                          1982mm LOOP_110
00000AEA  0C14 0000               1983mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AEE  6700 0016               1984mm     BEQ EXIT_110
00000AF2                          1985mmm     PRINT_CHAR (A4)+,D5
00000AF2                          1986mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF2                 TRUE     1987mmm     IFEQ DEBUG
00000AF2  1A39 00C00003           1988mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF8  0805 0002               1989mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFC  67F4                    1990mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000AFE  13DC 00C00007           1991mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B04                          1992mmm     ENDC
00000B04                          1993mmm 
00000B04                 FALSE    1994mmm     IFNE DEBUG
00000B04                          1995mmm     ENDC
00000B04                          1996mmm 
00000B04                          1997mmm     ENDM
00000B04  60E4                    1998mm     BRA LOOP_110
00000B06                          1999mm EXIT_110
00000B06                          2000mm     ENDM
00000B06                          2001m     ENDM
00000B06                          2002  
00000B06  6000 FAEC               2003                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000B0A                          2004              ENDI
00000B0A                          2005s _0000000A
00000B0A                          2006          ENDI
00000B0A                          2007s _00000008
00000B0A                          2008      ENDI
00000B0A                          2009s _00000004
00000B0A                          2010  
00000B0A                          2011m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000B0A  1E3C 0002               2012m     MOVE.B #2,D7
00000B0E                          2013m     WHILE.B D7 <GT> 0 DO
00000B0E                          2014ms _10000012
00000B0E  BE38 0000               2015ms     CMP.B   0,D7
00000B12  6F00 0062               2016ms     BLE _10000013
00000B16  E98C                    2017m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B18                          2018mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B18                          2019mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B18                          2020mm 
00000B18  1A39 00C00003           2021mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B1E  0805 0000               2022mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B22  6700 0010               2023mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000B26                          2024mm 
00000B26                          2025mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B26                 TRUE     2026mmm     IFEQ DEBUG
00000B26  1A39 00C00007           2027mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B2C                          2028mmm     ENDC
00000B2C                 FALSE    2029mmm     IFNE DEBUG
00000B2C                          2030mmm     ENDC
00000B2C                          2031mmm 
00000B2C  BA3C 001B               2032mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B30  6700 F5D2               2033mmm     BEQ START
00000B34                          2034mmm     ENDM
00000B34                          2035mm CONTINUE_113
00000B34  1A39 00C00013           2036mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B3A  0805 0000               2037mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B3E  67D8                    2038mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000B40                          2039mm     
00000B40  1A39 00C00017           2040mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B46  13C5 00E00001           2041mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B4C                          2042mm 
00000B4C                          2043mm     ENDM
00000B4C                          2044mm         PRINT_CHAR D5,D6
00000B4C                          2045mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4C                 TRUE     2046mm     IFEQ DEBUG
00000B4C  1C39 00C00003           2047mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B52  0806 0002               2048mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B56  67F4                    2049mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B58  13C5 00C00007           2050mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B5E                          2051mm     ENDC
00000B5E                          2052mm 
00000B5E                 FALSE    2053mm     IFNE DEBUG
00000B5E                          2054mm     ENDC
00000B5E                          2055mm 
00000B5E                          2056mm     ENDM
00000B5E                          2057mm         HEX2BIN D5,D5,A4
00000B5E  49FA 14BF               2058mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B62  0405 0030               2059mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B66  CABC 000000FF           2060mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B6C  1A34 5000               2061mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B70                          2062mm     ENDM
00000B70  8805                    2063m         OR.B D5,D4
00000B72  5307                    2064m         SUB.B #1,D7
00000B74                          2065m     ENDW
00000B74  6098                    2066ms     BRA _10000012
00000B76                          2067ms _10000013
00000B76                          2068m 
00000B76  7A00                    2069m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B78  1A04                    2070m     MOVE.B D4,D5
00000B7A  D484                    2071m     ADD.L D4,D2
00000B7C                          2072m 
00000B7C                          2073m     ENDM
00000B7C                          2074m     PRINT_CRLF D5,A4
00000B7C  49FA 14CC               2075m     LEA CRLF(PC),A4
00000B80                          2076mm     PRINT_STR A4,D5
00000B80                          2077mm LOOP_118
00000B80  0C14 0000               2078mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B84  6700 0016               2079mm     BEQ EXIT_118
00000B88                          2080mmm     PRINT_CHAR (A4)+,D5
00000B88                          2081mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     2082mmm     IFEQ DEBUG
00000B88  1A39 00C00003           2083mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B8E  0805 0002               2084mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    2085mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B94  13DC 00C00007           2086mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9A                          2087mmm     ENDC
00000B9A                          2088mmm 
00000B9A                 FALSE    2089mmm     IFNE DEBUG
00000B9A                          2090mmm     ENDC
00000B9A                          2091mmm 
00000B9A                          2092mmm     ENDM
00000B9A  60E4                    2093mm     BRA LOOP_118
00000B9C                          2094mm EXIT_118
00000B9C                          2095mm     ENDM
00000B9C                          2096m     ENDM
00000B9C                          2097  
00000B9C                          2098      IF.B D2 <NE> #$FF THEN.L
00000B9C  B43C 00FF               2099s     CMP.B   #$FF,D2
00000BA0  6700 0090               2100s     BEQ.L   _0000000B
00000BA4  49FA 1447               2101          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000BA8                          2102m         PRINT_STR A4,D5
00000BA8                          2103m LOOP_120
00000BA8  0C14 0000               2104m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BAC  6700 0016               2105m     BEQ EXIT_120
00000BB0                          2106mm     PRINT_CHAR (A4)+,D5
00000BB0                          2107mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BB0                 TRUE     2108mm     IFEQ DEBUG
00000BB0  1A39 00C00003           2109mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BB6  0805 0002               2110mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BBA  67F4                    2111mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000BBC  13DC 00C00007           2112mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BC2                          2113mm     ENDC
00000BC2                          2114mm 
00000BC2                 FALSE    2115mm     IFNE DEBUG
00000BC2                          2116mm     ENDC
00000BC2                          2117mm 
00000BC2                          2118mm     ENDM
00000BC2  60E4                    2119m     BRA LOOP_120
00000BC4                          2120m EXIT_120
00000BC4                          2121m     ENDM
00000BC4                          2122m         PRINT_REG D0,D5,D3,D6,A4
00000BC4  49FA 148A               2123m     LEA OX(PC),A4
00000BC8                          2124mm     PRINT_STR A4,D5
00000BC8                          2125mm LOOP_123
00000BC8  0C14 0000               2126mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BCC  6700 0016               2127mm     BEQ EXIT_123
00000BD0                          2128mmm     PRINT_CHAR (A4)+,D5
00000BD0                          2129mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                 TRUE     2130mmm     IFEQ DEBUG
00000BD0  1A39 00C00003           2131mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD6  0805 0002               2132mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BDA  67F4                    2133mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BDC  13DC 00C00007           2134mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BE2                          2135mmm     ENDC
00000BE2                          2136mmm 
00000BE2                 FALSE    2137mmm     IFNE DEBUG
00000BE2                          2138mmm     ENDC
00000BE2                          2139mmm 
00000BE2                          2140mmm     ENDM
00000BE2  60E4                    2141mm     BRA LOOP_123
00000BE4                          2142mm EXIT_123
00000BE4                          2143mm     ENDM
00000BE4  7C07                    2144m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BE6                          2145m LOOP_122
00000BE6                          2146mm     BIN2HEX D0,D3,A4
00000BE6  49FA 1427               2147mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000BEA  E998                    2148mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BEC  1600                    2149mm     MOVE.B D0,D3
00000BEE  0283 0000000F           2150mm     ANDI.L #$F,D3
00000BF4  1634 3000               2151mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000BF8                          2152mm     ENDM
00000BF8                          2153mm     PRINT_CHAR D3,D5
00000BF8                          2154mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF8                 TRUE     2155mm     IFEQ DEBUG
00000BF8  1A39 00C00003           2156mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BFE  0805 0002               2157mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C02  67F4                    2158mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000C04  13C3 00C00007           2159mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C0A                          2160mm     ENDC
00000C0A                          2161mm 
00000C0A                 FALSE    2162mm     IFNE DEBUG
00000C0A                          2163mm     ENDC
00000C0A                          2164mm 
00000C0A                          2165mm     ENDM
00000C0A  57CE FFDA               2166m     DBEQ D6,LOOP_122
00000C0E                          2167m     ENDM
00000C0E                          2168m         PRINT_CRLF D5,A4
00000C0E  49FA 143A               2169m     LEA CRLF(PC),A4
00000C12                          2170mm     PRINT_STR A4,D5
00000C12                          2171mm LOOP_128
00000C12  0C14 0000               2172mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C16  6700 0016               2173mm     BEQ EXIT_128
00000C1A                          2174mmm     PRINT_CHAR (A4)+,D5
00000C1A                          2175mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1A                 TRUE     2176mmm     IFEQ DEBUG
00000C1A  1A39 00C00003           2177mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C20  0805 0002               2178mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C24  67F4                    2179mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000C26  13DC 00C00007           2180mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C2C                          2181mmm     ENDC
00000C2C                          2182mmm 
00000C2C                 FALSE    2183mmm     IFNE DEBUG
00000C2C                          2184mmm     ENDC
00000C2C                          2185mmm 
00000C2C                          2186mmm     ENDM
00000C2C  60E4                    2187mm     BRA LOOP_128
00000C2E                          2188mm EXIT_128
00000C2E                          2189mm     ENDM
00000C2E                          2190m     ENDM
00000C2E                          2191          
00000C2E  6000 F714               2192          BRA MAIN_LOOP
00000C32                          2193      ENDI
00000C32                          2194s _0000000B
00000C32                          2195  
00000C32                          2196      IF D1 <EQ> #0 THEN
00000C32  B27C 0000               2197s     CMP.W   #0,D1
00000C36  6600 0006               2198s     BNE _0000000C
00000C3A  6000 F9B8               2199        BRA WAIT_FOR_SRECORD
00000C3E                          2200      ENDI
00000C3E                          2201s _0000000C
00000C3E                          2202  DOWNLOAD_DONE
00000C3E                          2203m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C3E  43FA 1410               2204m     LEA OX(PC),A1
00000C42                          2205mm     PRINT_STR A1,D5
00000C42                          2206mm LOOP_131
00000C42  0C11 0000               2207mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C46  6700 0016               2208mm     BEQ EXIT_131
00000C4A                          2209mmm     PRINT_CHAR (A1)+,D5
00000C4A                          2210mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2211mmm     IFEQ DEBUG
00000C4A  1A39 00C00003           2212mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C50  0805 0002               2213mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2214mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000C56  13D9 00C00007           2215mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C5C                          2216mmm     ENDC
00000C5C                          2217mmm 
00000C5C                 FALSE    2218mmm     IFNE DEBUG
00000C5C                          2219mmm     ENDC
00000C5C                          2220mmm 
00000C5C                          2221mmm     ENDM
00000C5C  60E4                    2222mm     BRA LOOP_131
00000C5E                          2223mm EXIT_131
00000C5E                          2224mm     ENDM
00000C5E  7407                    2225m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C60                          2226m LOOP_130
00000C60                          2227mm     BIN2HEX D0,D6,A1
00000C60  43FA 13AD               2228mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C64  E998                    2229mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C66  1C00                    2230mm     MOVE.B D0,D6
00000C68  0286 0000000F           2231mm     ANDI.L #$F,D6
00000C6E  1C31 6000               2232mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C72                          2233mm     ENDM
00000C72                          2234mm     PRINT_CHAR D6,D5
00000C72                          2235mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C72                 TRUE     2236mm     IFEQ DEBUG
00000C72  1A39 00C00003           2237mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C78  0805 0002               2238mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C7C  67F4                    2239mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C7E  13C6 00C00007           2240mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C84                          2241mm     ENDC
00000C84                          2242mm 
00000C84                 FALSE    2243mm     IFNE DEBUG
00000C84                          2244mm     ENDC
00000C84                          2245mm 
00000C84                          2246mm     ENDM
00000C84  57CA FFDA               2247m     DBEQ D2,LOOP_130
00000C88                          2248m     ENDM
00000C88  43FA 132A               2249      LEA READ(PC),A1
00000C8C                          2250m     PRINT_STR A1,D5
00000C8C                          2251m LOOP_135
00000C8C  0C11 0000               2252m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C90  6700 0016               2253m     BEQ EXIT_135
00000C94                          2254mm     PRINT_CHAR (A1)+,D5
00000C94                          2255mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C94                 TRUE     2256mm     IFEQ DEBUG
00000C94  1A39 00C00003           2257mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C9A  0805 0002               2258mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C9E  67F4                    2259mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CA0  13D9 00C00007           2260mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA6                          2261mm     ENDC
00000CA6                          2262mm 
00000CA6                 FALSE    2263mm     IFNE DEBUG
00000CA6                          2264mm     ENDC
00000CA6                          2265mm 
00000CA6                          2266mm     ENDM
00000CA6  60E4                    2267m     BRA LOOP_135
00000CA8                          2268m EXIT_135
00000CA8                          2269m     ENDM
00000CA8  2E08                    2270      MOVE.L A0,D7                                    ; set address accumulator to start address
00000CAA                          2271m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000CAA  43FA 13A4               2272m     LEA OX(PC),A1
00000CAE                          2273mm     PRINT_STR A1,D5
00000CAE                          2274mm LOOP_138
00000CAE  0C11 0000               2275mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CB2  6700 0016               2276mm     BEQ EXIT_138
00000CB6                          2277mmm     PRINT_CHAR (A1)+,D5
00000CB6                          2278mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2279mmm     IFEQ DEBUG
00000CB6  1A39 00C00003           2280mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CBC  0805 0002               2281mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2282mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CC2  13D9 00C00007           2283mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CC8                          2284mmm     ENDC
00000CC8                          2285mmm 
00000CC8                 FALSE    2286mmm     IFNE DEBUG
00000CC8                          2287mmm     ENDC
00000CC8                          2288mmm 
00000CC8                          2289mmm     ENDM
00000CC8  60E4                    2290mm     BRA LOOP_138
00000CCA                          2291mm EXIT_138
00000CCA                          2292mm     ENDM
00000CCA  7407                    2293m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CCC                          2294m LOOP_137
00000CCC                          2295mm     BIN2HEX D7,D6,A1
00000CCC  43FA 1341               2296mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CD0  E99F                    2297mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CD2  1C07                    2298mm     MOVE.B D7,D6
00000CD4  0286 0000000F           2299mm     ANDI.L #$F,D6
00000CDA  1C31 6000               2300mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CDE                          2301mm     ENDM
00000CDE                          2302mm     PRINT_CHAR D6,D5
00000CDE                          2303mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDE                 TRUE     2304mm     IFEQ DEBUG
00000CDE  1A39 00C00003           2305mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CE4  0805 0002               2306mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CE8  67F4                    2307mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CEA  13C6 00C00007           2308mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CF0                          2309mm     ENDC
00000CF0                          2310mm 
00000CF0                 FALSE    2311mm     IFNE DEBUG
00000CF0                          2312mm     ENDC
00000CF0                          2313mm 
00000CF0                          2314mm     ENDM
00000CF0  57CA FFDA               2315m     DBEQ D2,LOOP_137
00000CF4                          2316m     ENDM
00000CF4                          2317m     PRINT_CRLF D5,A4
00000CF4  49FA 1354               2318m     LEA CRLF(PC),A4
00000CF8                          2319mm     PRINT_STR A4,D5
00000CF8                          2320mm LOOP_143
00000CF8  0C14 0000               2321mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000CFC  6700 0016               2322mm     BEQ EXIT_143
00000D00                          2323mmm     PRINT_CHAR (A4)+,D5
00000D00                          2324mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2325mmm     IFEQ DEBUG
00000D00  1A39 00C00003           2326mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D06  0805 0002               2327mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2328mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D0C  13DC 00C00007           2329mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D12                          2330mmm     ENDC
00000D12                          2331mmm 
00000D12                 FALSE    2332mmm     IFNE DEBUG
00000D12                          2333mmm     ENDC
00000D12                          2334mmm 
00000D12                          2335mmm     ENDM
00000D12  60E4                    2336mm     BRA LOOP_143
00000D14                          2337mm EXIT_143
00000D14                          2338mm     ENDM
00000D14                          2339m     ENDM
00000D14                          2340  
00000D14  6000 F62E               2341      BRA MAIN_LOOP
00000D18                          2342  
00000D18                          2343  G
00000D18  2047                    2344      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000D1A  7E00                    2345      MOVE.L #0,D7
00000D1C                          2346  
00000D1C  4ED0                    2347      JMP (A0)
00000D1E                          2348          
00000D1E                          2349  Z
00000D1E  207C 00200000           2350      MOVE.L #RAM,A0                                  ; address of RAM
00000D24  D1FC 00100000           2351      ADD.L #$100000,A0
00000D2A                          2352  
00000D2A                          2353      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000D2A  7000                    2354s     MOVE.L  #0,D0
00000D2C  6000 0012               2355s     BRA _20000007
00000D30                          2356s _20000006
00000D30  2200                    2357          MOVE.L D0,D1                                ; progress update
00000D32  E089                    2358          LSR.L #8,D1 
00000D34  E089                    2359          LSR.L #8,D1
00000D36  13C1 00E00001           2360          MOVE.B D1,DISPLAY
00000D3C                          2361          
00000D3C  2108                    2362          MOVE.L A0,-(A0)
00000D3E                          2363      ENDF
00000D3E  5880                    2364s     ADD.L   #4,D0
00000D40                          2365s _20000007
00000D40  B0BC 000FFFFC           2366s     CMP.L   #$FFFFC,D0
00000D46  6FE8                    2367s     BLE _20000006
00000D48                          2368  
00000D48  207C 00200000           2369      MOVE.L #RAM,A0                                  ; address of RAM
00000D4E  D1FC 00100000           2370      ADD.L #$100000,A0
00000D54                          2371  
00000D54                          2372      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D54  7000                    2373s     MOVE.L  #0,D0
00000D56  6000 00A8               2374s     BRA _20000009
00000D5A                          2375s _20000008
00000D5A  2200                    2376          MOVE.L D0,D1                                ; progress update
00000D5C  E089                    2377          LSR.L #8,D1
00000D5E  E089                    2378          LSR.L #8,D1
00000D60  13C1 00E00001           2379          MOVE.B D1,DISPLAY
00000D66                          2380  
00000D66  2408                    2381          MOVE.L A0,D2
00000D68  2220                    2382          MOVE.L -(A0),D1
00000D6A                          2383  
00000D6A                          2384          IF.L D2 <NE> D1 THEN
00000D6A  B481                    2385s     CMP.L   D1,D2
00000D6C  6700 0090               2386s     BEQ _0000000D
00000D70  43FA 128C               2387              LEA RAM_ERROR(PC),A1
00000D74                          2388m             PRINT_STR A1,D1
00000D74                          2389m LOOP_145
00000D74  0C11 0000               2390m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D78  6700 0016               2391m     BEQ EXIT_145
00000D7C                          2392mm     PRINT_CHAR (A1)+,D1
00000D7C                          2393mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7C                 TRUE     2394mm     IFEQ DEBUG
00000D7C  1239 00C00003           2395mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D82  0801 0002               2396mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000D86  67F4                    2397mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000D88  13D9 00C00007           2398mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D8E                          2399mm     ENDC
00000D8E                          2400mm 
00000D8E                 FALSE    2401mm     IFNE DEBUG
00000D8E                          2402mm     ENDC
00000D8E                          2403mm 
00000D8E                          2404mm     ENDM
00000D8E  60E4                    2405m     BRA LOOP_145
00000D90                          2406m EXIT_145
00000D90                          2407m     ENDM
00000D90  2208                    2408              MOVE.L A0,D1
00000D92  5981                    2409              SUB.L #4,D1
00000D94                          2410m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000D94  43FA 12BA               2411m     LEA OX(PC),A1
00000D98                          2412mm     PRINT_STR A1,D3
00000D98                          2413mm LOOP_148
00000D98  0C11 0000               2414mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D9C  6700 0016               2415mm     BEQ EXIT_148
00000DA0                          2416mmm     PRINT_CHAR (A1)+,D3
00000DA0                          2417mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA0                 TRUE     2418mmm     IFEQ DEBUG
00000DA0  1639 00C00003           2419mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DA6  0803 0002               2420mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DAA  67F4                    2421mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000DAC  13D9 00C00007           2422mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DB2                          2423mmm     ENDC
00000DB2                          2424mmm 
00000DB2                 FALSE    2425mmm     IFNE DEBUG
00000DB2                          2426mmm     ENDC
00000DB2                          2427mmm 
00000DB2                          2428mmm     ENDM
00000DB2  60E4                    2429mm     BRA LOOP_148
00000DB4                          2430mm EXIT_148
00000DB4                          2431mm     ENDM
00000DB4  7C07                    2432m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DB6                          2433m LOOP_147
00000DB6                          2434mm     BIN2HEX D1,D2,A1
00000DB6  43FA 1257               2435mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000DBA  E999                    2436mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DBC  1401                    2437mm     MOVE.B D1,D2
00000DBE  0282 0000000F           2438mm     ANDI.L #$F,D2
00000DC4  1431 2000               2439mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000DC8                          2440mm     ENDM
00000DC8                          2441mm     PRINT_CHAR D2,D3
00000DC8                          2442mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC8                 TRUE     2443mm     IFEQ DEBUG
00000DC8  1639 00C00003           2444mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DCE  0803 0002               2445mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DD2  67F4                    2446mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DD4  13C2 00C00007           2447mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DDA                          2448mm     ENDC
00000DDA                          2449mm 
00000DDA                 FALSE    2450mm     IFNE DEBUG
00000DDA                          2451mm     ENDC
00000DDA                          2452mm 
00000DDA                          2453mm     ENDM
00000DDA  57CE FFDA               2454m     DBEQ D6,LOOP_147
00000DDE                          2455m     ENDM
00000DDE                          2456m             PRINT_CRLF D3,A1
00000DDE  43FA 126A               2457m     LEA CRLF(PC),A1
00000DE2                          2458mm     PRINT_STR A1,D3
00000DE2                          2459mm LOOP_153
00000DE2  0C11 0000               2460mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DE6  6700 0016               2461mm     BEQ EXIT_153
00000DEA                          2462mmm     PRINT_CHAR (A1)+,D3
00000DEA                          2463mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEA                 TRUE     2464mmm     IFEQ DEBUG
00000DEA  1639 00C00003           2465mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DF0  0803 0002               2466mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DF4  67F4                    2467mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DF6  13D9 00C00007           2468mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DFC                          2469mmm     ENDC
00000DFC                          2470mmm 
00000DFC                 FALSE    2471mmm     IFNE DEBUG
00000DFC                          2472mmm     ENDC
00000DFC                          2473mmm 
00000DFC                          2474mmm     ENDM
00000DFC  60E4                    2475mm     BRA LOOP_153
00000DFE                          2476mm EXIT_153
00000DFE                          2477mm     ENDM
00000DFE                          2478m     ENDM
00000DFE                          2479          ENDI 
00000DFE                          2480s _0000000D
00000DFE                          2481      ENDF
00000DFE  5880                    2482s     ADD.L   #4,D0
00000E00                          2483s _20000009
00000E00  B0BC 000FFFFC           2484s     CMP.L   #$FFFFC,D0
00000E06  6F00 FF52               2485s     BLE _20000008
00000E0A                          2486  
00000E0A  6000 F538               2487      BRA MAIN_LOOP
00000E0E                          2488  
00000E0E                          2489  L
00000E0E  7000                    2490      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000E10  7200                    2491      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000E12                          2492  
00000E12                          2493      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000E12  343C 0000               2494s     MOVE.W  #0,D2
00000E16  6000 0046               2495s     BRA _2000000B
00000E1A                          2496s _2000000A
00000E1A  E989                    2497          LSL.L #4,D1                                 ; make what we have so far more significant
00000E1C                          2498m         WAIT_CHAR D3,D4                             ; next character -> D2
00000E1C                          2499m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E1C                 TRUE     2500m     IFEQ DEBUG
00000E1C  1839 00C00003           2501m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E22  0804 0000               2502m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000E26  67F4                    2503m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000E28                          2504m     ENDC
00000E28                          2505m 
00000E28                          2506mm     READ_CHAR D3
00000E28                 TRUE     2507mm     IFEQ DEBUG
00000E28  1639 00C00007           2508mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000E2E                          2509mm     ENDC
00000E2E                 FALSE    2510mm     IFNE DEBUG
00000E2E                          2511mm     ENDC
00000E2E                          2512mm 
00000E2E  B63C 001B               2513mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E32  6700 F2D0               2514mm     BEQ START
00000E36                          2515mm     ENDM
00000E36                          2516m 
00000E36                 TRUE     2517m     IFEQ DEBUG
00000E36                          2518mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E36                          2519mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E36                 TRUE     2520mm     IFEQ DEBUG
00000E36  1839 00C00003           2521mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E3C  0804 0002               2522mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E40  67F4                    2523mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E42  13C3 00C00007           2524mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E48                          2525mm     ENDC
00000E48                          2526mm 
00000E48                 FALSE    2527mm     IFNE DEBUG
00000E48                          2528mm     ENDC
00000E48                          2529mm 
00000E48                          2530mm     ENDM
00000E48                          2531m     ENDC
00000E48                          2532m     ENDM
00000E48                          2533m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E48  41FA 11D5               2534m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E4C  0403 0030               2535m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E50  C6BC 000000FF           2536m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E56  1630 3000               2537m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E5A                          2538m     ENDM
00000E5A  8203                    2539          OR.B D3,D1
00000E5C                          2540      ENDF
00000E5C  5242                    2541s     ADD.W   #1,D2
00000E5E                          2542s _2000000B
00000E5E  B47C 0007               2543s     CMP.W   #7,D2
00000E62  6FB6                    2544s     BLE _2000000A
00000E64                          2545  
00000E64  3001                    2546      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E66  0480 00000104           2547      SUB.L #START,D0                                 ; remove the vector table from the length
00000E6C  E089                    2548      LSR.L #8,D1                                     ; extract the MSword for the address
00000E6E  E089                    2549      LSR.L #8,D1
00000E70                          2550  
00000E70                          2551m     PRINT_CRLF D2,A1
00000E70  43FA 11D8               2552m     LEA CRLF(PC),A1
00000E74                          2553mm     PRINT_STR A1,D2
00000E74                          2554mm LOOP_160
00000E74  0C11 0000               2555mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E78  6700 0016               2556mm     BEQ EXIT_160
00000E7C                          2557mmm     PRINT_CHAR (A1)+,D2
00000E7C                          2558mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E7C                 TRUE     2559mmm     IFEQ DEBUG
00000E7C  1439 00C00003           2560mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E82  0802 0002               2561mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E86  67F4                    2562mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E88  13D9 00C00007           2563mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E8E                          2564mmm     ENDC
00000E8E                          2565mmm 
00000E8E                 FALSE    2566mmm     IFNE DEBUG
00000E8E                          2567mmm     ENDC
00000E8E                          2568mmm 
00000E8E                          2569mmm     ENDM
00000E8E  60E4                    2570mm     BRA LOOP_160
00000E90                          2571mm EXIT_160
00000E90                          2572mm     ENDM
00000E90                          2573m     ENDM
00000E90                          2574  
00000E90  2041                    2575      MOVE.L D1,A0                                    ; target address
00000E92  2641                    2576      MOVE.L D1,A3                                    ; keep a copy for later
00000E94                          2577  
00000E94  2247                    2578      MOVE.L D7,A1                                    ; address accumulator -> address register
00000E96  D3FC 00000104           2579      ADD.L #START,A1                                 ; skip the vectors
00000E9C  2847                    2580      MOVE.L D7,A4                                    ; keep a clean copy for later
00000E9E  7E00                    2581      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000EA0                          2582  
00000EA0                          2583m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000EA0  31FC AAAA 2AAA          2584m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000EA6  4E71                    2585m     NOP
00000EA8  31FC 5555 1554          2586m     MOVE.W #$5555,$1554
00000EAE  4E71                    2587m     NOP
00000EB0  31FC 8080 2AAA          2588m     MOVE.W #$8080,$2AAA
00000EB6  4E71                    2589m     NOP
00000EB8  31FC AAAA 2AAA          2590m     MOVE.W #$AAAA,$2AAA
00000EBE  4E71                    2591m     NOP
00000EC0  31FC 5555 1554          2592m     MOVE.W #$5555,$1554
00000EC6  4E71                    2593m     NOP
00000EC8  31FC 2020 2AAA          2594m     MOVE.W #$2020,$2AAA
00000ECE                          2595m     ENDM
00000ECE                          2596                      
00000ECE                          2597      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000ECE  3E3C 0000               2598s     MOVE.W  #$0,D7
00000ED2  6000 0006               2599s     BRA _2000000D
00000ED6                          2600s _2000000C
00000ED6  4E71                    2601          NOP
00000ED8                          2602      ENDF
00000ED8  5247                    2603s     ADD.W   #1,D7
00000EDA                          2604s _2000000D
00000EDA  BE7C FFFF               2605s     CMP.W   #$FFFFFFFF,D7
00000EDE  6FF6                    2606s     BLE _2000000C
00000EE0                          2607                  
00000EE0  45FA 1154               2608      LEA LOADING(PC),A2
00000EE4                          2609m     PRINT_STR A2,D2
00000EE4                          2610m LOOP_163
00000EE4  0C12 0000               2611m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EE8  6700 0016               2612m     BEQ EXIT_163
00000EEC                          2613mm     PRINT_CHAR (A2)+,D2
00000EEC                          2614mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEC                 TRUE     2615mm     IFEQ DEBUG
00000EEC  1439 00C00003           2616mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EF2  0802 0002               2617mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EF6  67F4                    2618mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EF8  13DA 00C00007           2619mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFE                          2620mm     ENDC
00000EFE                          2621mm 
00000EFE                 FALSE    2622mm     IFNE DEBUG
00000EFE                          2623mm     ENDC
00000EFE                          2624mm 
00000EFE                          2625mm     ENDM
00000EFE  60E4                    2626m     BRA LOOP_163
00000F00                          2627m EXIT_163
00000F00                          2628m     ENDM
00000F00  45FA 1134               2629      LEA LOADING(PC),A2
00000F04                          2630m     PRINT_STR A2,D2
00000F04                          2631m LOOP_165
00000F04  0C12 0000               2632m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F08  6700 0016               2633m     BEQ EXIT_165
00000F0C                          2634mm     PRINT_CHAR (A2)+,D2
00000F0C                          2635mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F0C                 TRUE     2636mm     IFEQ DEBUG
00000F0C  1439 00C00003           2637mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000F12  0802 0002               2638mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000F16  67F4                    2639mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000F18  13DA 00C00007           2640mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F1E                          2641mm     ENDC
00000F1E                          2642mm 
00000F1E                 FALSE    2643mm     IFNE DEBUG
00000F1E                          2644mm     ENDC
00000F1E                          2645mm 
00000F1E                          2646mm     ENDM
00000F1E  60E4                    2647m     BRA LOOP_165
00000F20                          2648m EXIT_165
00000F20                          2649m     ENDM
00000F20                          2650          
00000F20  2409                    2651      MOVE.L A1,D2
00000F22                          2652m     PRINT_REG D2,D3,D4,D5,A2
00000F22  45FA 112C               2653m     LEA OX(PC),A2
00000F26                          2654mm     PRINT_STR A2,D3
00000F26                          2655mm LOOP_168
00000F26  0C12 0000               2656mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F2A  6700 0016               2657mm     BEQ EXIT_168
00000F2E                          2658mmm     PRINT_CHAR (A2)+,D3
00000F2E                          2659mmm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F2E                 TRUE     2660mmm     IFEQ DEBUG
00000F2E  1639 00C00003           2661mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F34  0803 0002               2662mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F38  67F4                    2663mmm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F3A  13DA 00C00007           2664mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F40                          2665mmm     ENDC
00000F40                          2666mmm 
00000F40                 FALSE    2667mmm     IFNE DEBUG
00000F40                          2668mmm     ENDC
00000F40                          2669mmm 
00000F40                          2670mmm     ENDM
00000F40  60E4                    2671mm     BRA LOOP_168
00000F42                          2672mm EXIT_168
00000F42                          2673mm     ENDM
00000F42  7A07                    2674m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F44                          2675m LOOP_167
00000F44                          2676mm     BIN2HEX D2,D4,A2
00000F44  45FA 10C9               2677mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F48  E99A                    2678mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F4A  1802                    2679mm     MOVE.B D2,D4
00000F4C  0284 0000000F           2680mm     ANDI.L #$F,D4
00000F52  1832 4000               2681mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F56                          2682mm     ENDM
00000F56                          2683mm     PRINT_CHAR D4,D3
00000F56                          2684mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F56                 TRUE     2685mm     IFEQ DEBUG
00000F56  1639 00C00003           2686mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F5C  0803 0002               2687mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F60  67F4                    2688mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F62  13C4 00C00007           2689mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F68                          2690mm     ENDC
00000F68                          2691mm 
00000F68                 FALSE    2692mm     IFNE DEBUG
00000F68                          2693mm     ENDC
00000F68                          2694mm 
00000F68                          2695mm     ENDM
00000F68  57CD FFDA               2696m     DBEQ D5,LOOP_167
00000F6C                          2697m     ENDM
00000F6C                          2698  
00000F6C  45FA 10E5               2699      LEA TO(PC),A2
00000F70                          2700m     PRINT_STR A2,D3
00000F70                          2701m LOOP_172
00000F70  0C12 0000               2702m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F74  6700 0016               2703m     BEQ EXIT_172
00000F78                          2704mm     PRINT_CHAR (A2)+,D3
00000F78                          2705mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F78                 TRUE     2706mm     IFEQ DEBUG
00000F78  1639 00C00003           2707mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F7E  0803 0002               2708mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F82  67F4                    2709mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F84  13DA 00C00007           2710mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F8A                          2711mm     ENDC
00000F8A                          2712mm 
00000F8A                 FALSE    2713mm     IFNE DEBUG
00000F8A                          2714mm     ENDC
00000F8A                          2715mm 
00000F8A                          2716mm     ENDM
00000F8A  60E4                    2717m     BRA LOOP_172
00000F8C                          2718m EXIT_172
00000F8C                          2719m     ENDM
00000F8C                          2720  
00000F8C  2408                    2721      MOVE.L A0,D2
00000F8E                          2722m     PRINT_REG D2,D3,D4,D5,A2
00000F8E  45FA 10C0               2723m     LEA OX(PC),A2
00000F92                          2724mm     PRINT_STR A2,D3
00000F92                          2725mm LOOP_175
00000F92  0C12 0000               2726mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F96  6700 0016               2727mm     BEQ EXIT_175
00000F9A                          2728mmm     PRINT_CHAR (A2)+,D3
00000F9A                          2729mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F9A                 TRUE     2730mmm     IFEQ DEBUG
00000F9A  1639 00C00003           2731mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FA0  0803 0002               2732mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FA4  67F4                    2733mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000FA6  13DA 00C00007           2734mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FAC                          2735mmm     ENDC
00000FAC                          2736mmm 
00000FAC                 FALSE    2737mmm     IFNE DEBUG
00000FAC                          2738mmm     ENDC
00000FAC                          2739mmm 
00000FAC                          2740mmm     ENDM
00000FAC  60E4                    2741mm     BRA LOOP_175
00000FAE                          2742mm EXIT_175
00000FAE                          2743mm     ENDM
00000FAE  7A07                    2744m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FB0                          2745m LOOP_174
00000FB0                          2746mm     BIN2HEX D2,D4,A2
00000FB0  45FA 105D               2747mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FB4  E99A                    2748mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FB6  1802                    2749mm     MOVE.B D2,D4
00000FB8  0284 0000000F           2750mm     ANDI.L #$F,D4
00000FBE  1832 4000               2751mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FC2                          2752mm     ENDM
00000FC2                          2753mm     PRINT_CHAR D4,D3
00000FC2                          2754mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FC2                 TRUE     2755mm     IFEQ DEBUG
00000FC2  1639 00C00003           2756mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FC8  0803 0002               2757mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FCC  67F4                    2758mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000FCE  13C4 00C00007           2759mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FD4                          2760mm     ENDC
00000FD4                          2761mm 
00000FD4                 FALSE    2762mm     IFNE DEBUG
00000FD4                          2763mm     ENDC
00000FD4                          2764mm 
00000FD4                          2765mm     ENDM
00000FD4  57CD FFDA               2766m     DBEQ D5,LOOP_174
00000FD8                          2767m     ENDM
00000FD8                          2768  
00000FD8  45FA 107E               2769      LEA FOR(PC),A2
00000FDC                          2770m     PRINT_STR A2,D3
00000FDC                          2771m LOOP_179
00000FDC  0C12 0000               2772m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FE0  6700 0016               2773m     BEQ EXIT_179
00000FE4                          2774mm     PRINT_CHAR (A2)+,D3
00000FE4                          2775mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FE4                 TRUE     2776mm     IFEQ DEBUG
00000FE4  1639 00C00003           2777mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FEA  0803 0002               2778mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FEE  67F4                    2779mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000FF0  13DA 00C00007           2780mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FF6                          2781mm     ENDC
00000FF6                          2782mm 
00000FF6                 FALSE    2783mm     IFNE DEBUG
00000FF6                          2784mm     ENDC
00000FF6                          2785mm 
00000FF6                          2786mm     ENDM
00000FF6  60E4                    2787m     BRA LOOP_179
00000FF8                          2788m EXIT_179
00000FF8                          2789m     ENDM
00000FF8                          2790m     PRINT_REG D0,D3,D4,D5,A2
00000FF8  45FA 1056               2791m     LEA OX(PC),A2
00000FFC                          2792mm     PRINT_STR A2,D3
00000FFC                          2793mm LOOP_182
00000FFC  0C12 0000               2794mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001000  6700 0016               2795mm     BEQ EXIT_182
00001004                          2796mmm     PRINT_CHAR (A2)+,D3
00001004                          2797mmm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001004                 TRUE     2798mmm     IFEQ DEBUG
00001004  1639 00C00003           2799mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000100A  0803 0002               2800mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000100E  67F4                    2801mmm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00001010  13DA 00C00007           2802mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001016                          2803mmm     ENDC
00001016                          2804mmm 
00001016                 FALSE    2805mmm     IFNE DEBUG
00001016                          2806mmm     ENDC
00001016                          2807mmm 
00001016                          2808mmm     ENDM
00001016  60E4                    2809mm     BRA LOOP_182
00001018                          2810mm EXIT_182
00001018                          2811mm     ENDM
00001018  7A07                    2812m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000101A                          2813m LOOP_181
0000101A                          2814mm     BIN2HEX D0,D4,A2
0000101A  45FA 0FF3               2815mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000101E  E998                    2816mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001020  1800                    2817mm     MOVE.B D0,D4
00001022  0284 0000000F           2818mm     ANDI.L #$F,D4
00001028  1832 4000               2819mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000102C                          2820mm     ENDM
0000102C                          2821mm     PRINT_CHAR D4,D3
0000102C                          2822mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000102C                 TRUE     2823mm     IFEQ DEBUG
0000102C  1639 00C00003           2824mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001032  0803 0002               2825mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001036  67F4                    2826mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00001038  13C4 00C00007           2827mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000103E                          2828mm     ENDC
0000103E                          2829mm 
0000103E                 FALSE    2830mm     IFNE DEBUG
0000103E                          2831mm     ENDC
0000103E                          2832mm 
0000103E                          2833mm     ENDM
0000103E  57CD FFDA               2834m     DBEQ D5,LOOP_181
00001042                          2835m     ENDM
00001042                          2836  
00001042                          2837m     PRINT_CRLF D3,A2
00001042  45FA 1006               2838m     LEA CRLF(PC),A2
00001046                          2839mm     PRINT_STR A2,D3
00001046                          2840mm LOOP_187
00001046  0C12 0000               2841mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000104A  6700 0016               2842mm     BEQ EXIT_187
0000104E                          2843mmm     PRINT_CHAR (A2)+,D3
0000104E                          2844mmm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000104E                 TRUE     2845mmm     IFEQ DEBUG
0000104E  1639 00C00003           2846mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001054  0803 0002               2847mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001058  67F4                    2848mmm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
0000105A  13DA 00C00007           2849mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001060                          2850mmm     ENDC
00001060                          2851mmm 
00001060                 FALSE    2852mmm     IFNE DEBUG
00001060                          2853mmm     ENDC
00001060                          2854mmm 
00001060                          2855mmm     ENDM
00001060  60E4                    2856mm     BRA LOOP_187
00001062                          2857mm EXIT_187
00001062                          2858mm     ENDM
00001062                          2859m     ENDM
00001062                          2860  
00001062                          2861      WHILE D0 <GT> #0 DO
00001062                          2862s _10000014
00001062  B07C 0000               2863s     CMP.W   #0,D0
00001066  6F00 001C               2864s     BLE _10000015
0000106A  5580                    2865          SUB.L #2,D0
0000106C                          2866  
0000106C  13D1 00E00001           2867          MOVE.B (A1),DISPLAY
00001072                          2868m         PROGRAM (A1),(A0),D2
00001072  3091                    2869m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001074                          2870m 
00001074                          2871m WAIT_FOR_COMPLETE_189
00001074  3410                    2872m         MOVE.W (A0),D2
00001076                          2873m 
00001076                          2874m         IF.W D2 <NE> (A1) THEN
00001076  B451                    2875ms     CMP.W   (A1),D2
00001078  6700 0004               2876ms     BEQ _0000000E
0000107C  60F6                    2877m             BRA WAIT_FOR_COMPLETE_189
0000107E                          2878m         ENDI
0000107E                          2879ms _0000000E
0000107E                          2880m         ENDM
0000107E                          2881                  
0000107E  5488                    2882          ADD.L #2,A0
00001080  5489                    2883          ADD.L #2,A1
00001082                          2884      ENDW
00001082  60DE                    2885s     BRA _10000014
00001084                          2886s _10000015
00001084                          2887      
00001084  41F8 0000               2888      LEA STACK,A0
00001088  D1CC                    2889      ADD.L A4,A0
0000108A  2010                    2890      MOVE.L (A0),D0
0000108C                          2891      
0000108C  207C 00000000           2892      MOVE.L #0,A0
00001092                          2893m     PROGRAM_VECTOR D0,A0,D2
00001092  5488                    2894m     ADD.L #2,A0
00001094                          2895mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00001094  3080                    2896mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001096                          2897mm 
00001096                          2898mm WAIT_FOR_COMPLETE_191
00001096  3410                    2899mm         MOVE.W (A0),D2
00001098                          2900mm 
00001098                          2901mm         IF.W D2 <NE> D0 THEN
00001098  B440                    2902mms     CMP.W   D0,D2
0000109A  6700 0004               2903mms     BEQ _0000000F
0000109E  60F6                    2904mm             BRA WAIT_FOR_COMPLETE_191
000010A0                          2905mm         ENDI
000010A0                          2906mms _0000000F
000010A0                          2907mm         ENDM
000010A0  E088                    2908m     LSR.L #8,D0
000010A2  E088                    2909m     LSR.L #8,D0
000010A4  5588                    2910m     SUB.L #2,A0
000010A6                          2911mm     PROGRAM D0, (A0), D2
000010A6  3080                    2912mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010A8                          2913mm 
000010A8                          2914mm WAIT_FOR_COMPLETE_192
000010A8  3410                    2915mm         MOVE.W (A0),D2
000010AA                          2916mm 
000010AA                          2917mm         IF.W D2 <NE> D0 THEN
000010AA  B440                    2918mms     CMP.W   D0,D2
000010AC  6700 0004               2919mms     BEQ _00000010
000010B0  60F6                    2920mm             BRA WAIT_FOR_COMPLETE_192
000010B2                          2921mm         ENDI
000010B2                          2922mms _00000010
000010B2                          2923mm         ENDM
000010B2                          2924m     ENDM
000010B2                          2925      
000010B2                          2926      FOR A0 = #RESET TO #START-4 BY #4 DO
000010B2  307C 0004               2927s     MOVE.W  #RESET,A0
000010B6  6000 003C               2928s     BRA _2000000F
000010BA                          2929s _2000000E
000010BA                          2930  
000010BA  2248                    2931          MOVE.L A0,A1
000010BC  D3CC                    2932          ADD.L A4,A1
000010BE                          2933              
000010BE  2011                    2934          MOVE.L (A1),D0  
000010C0  D081                    2935          ADD.L D1,D0
000010C2  0480 00000104           2936          SUB.L #START,D0
000010C8                          2937  
000010C8  2408                    2938          MOVE.L A0,D2
000010CA                          2939          
000010CA  2408                    2940          MOVE.L A0,D2
000010CC  13C2 00E00001           2941          MOVE.B D2,DISPLAY
000010D2                          2942m         PROGRAM_VECTOR D0,A0,D2
000010D2  5488                    2943m     ADD.L #2,A0
000010D4                          2944mm     PROGRAM D0, (A0), D2                            ; WRITE IT
000010D4  3080                    2945mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010D6                          2946mm 
000010D6                          2947mm WAIT_FOR_COMPLETE_194
000010D6  3410                    2948mm         MOVE.W (A0),D2
000010D8                          2949mm 
000010D8                          2950mm         IF.W D2 <NE> D0 THEN
000010D8  B440                    2951mms     CMP.W   D0,D2
000010DA  6700 0004               2952mms     BEQ _00000011
000010DE  60F6                    2953mm             BRA WAIT_FOR_COMPLETE_194
000010E0                          2954mm         ENDI
000010E0                          2955mms _00000011
000010E0                          2956mm         ENDM
000010E0  E088                    2957m     LSR.L #8,D0
000010E2  E088                    2958m     LSR.L #8,D0
000010E4  5588                    2959m     SUB.L #2,A0
000010E6                          2960mm     PROGRAM D0, (A0), D2
000010E6  3080                    2961mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010E8                          2962mm 
000010E8                          2963mm WAIT_FOR_COMPLETE_195
000010E8  3410                    2964mm         MOVE.W (A0),D2
000010EA                          2965mm 
000010EA                          2966mm         IF.W D2 <NE> D0 THEN
000010EA  B440                    2967mms     CMP.W   D0,D2
000010EC  6700 0004               2968mms     BEQ _00000012
000010F0  60F6                    2969mm             BRA WAIT_FOR_COMPLETE_195
000010F2                          2970mm         ENDI
000010F2                          2971mms _00000012
000010F2                          2972mm         ENDM
000010F2                          2973m     ENDM
000010F2                          2974      ENDF
000010F2  5848                    2975s     ADD.W   #4,A0
000010F4                          2976s _2000000F
000010F4  B0FC 0100               2977s     CMP.W   #START-4,A0
000010F8  6FC0                    2978s     BLE _2000000E
000010FA                          2979                                          
000010FA                          2980m     PROTECT
000010FA  31FC AAAA 2AAA          2981m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001100  31FC 5555 1554          2982m     MOVE.W #$5555,$1554
00001106  31FC A0A0 2AAA          2983m     MOVE.W #$A0A0,$2AAA
0000110C                          2984m     ENDM
0000110C                          2985  
0000110C  6000 F236               2986      BRA MAIN_LOOP
00001110                          2987      
00001110                          2988  P
00001110  7000                    2989      MOVE.L #0,D0                                    ; D0 will be the data to write
00001112                          2990  
00001112                          2991      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00001112  323C 0000               2992s     MOVE.W  #0,D1
00001116  6000 0046               2993s     BRA _20000011
0000111A                          2994s _20000010
0000111A  E988                    2995          LSL.L #4,D0                                 ; make what we have so far more significant
0000111C                          2996m         WAIT_CHAR D2,D3                             ; next character -> D2
0000111C                          2997m WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000111C                 TRUE     2998m     IFEQ DEBUG
0000111C  1639 00C00003           2999m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001122  0803 0000               3000m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001126  67F4                    3001m         BEQ WAIT_FOR_READY_197                      ; NOTHING, CHECK AGAIN
00001128                          3002m     ENDC
00001128                          3003m 
00001128                          3004mm     READ_CHAR D2
00001128                 TRUE     3005mm     IFEQ DEBUG
00001128  1439 00C00007           3006mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000112E                          3007mm     ENDC
0000112E                 FALSE    3008mm     IFNE DEBUG
0000112E                          3009mm     ENDC
0000112E                          3010mm 
0000112E  B43C 001B               3011mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001132  6700 EFD0               3012mm     BEQ START
00001136                          3013mm     ENDM
00001136                          3014m 
00001136                 TRUE     3015m     IFEQ DEBUG
00001136                          3016mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001136                          3017mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001136                 TRUE     3018mm     IFEQ DEBUG
00001136  1639 00C00003           3019mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000113C  0803 0002               3020mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001140  67F4                    3021mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001142  13C2 00C00007           3022mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001148                          3023mm     ENDC
00001148                          3024mm 
00001148                 FALSE    3025mm     IFNE DEBUG
00001148                          3026mm     ENDC
00001148                          3027mm 
00001148                          3028mm     ENDM
00001148                          3029m     ENDC
00001148                          3030m     ENDM
00001148                          3031m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001148  41FA 0ED5               3032m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000114C  0402 0030               3033m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001150  C4BC 000000FF           3034m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001156  1430 2000               3035m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000115A                          3036m     ENDM
0000115A  8002                    3037          OR.B D2,D0
0000115C                          3038      ENDF
0000115C  5241                    3039s     ADD.W   #1,D1
0000115E                          3040s _20000011
0000115E  B27C 0003               3041s     CMP.W   #3,D1
00001162  6FB6                    3042s     BLE _20000010
00001164                          3043  
00001164                          3044m     PRINT_CRLF D2,A1
00001164  43FA 0EE4               3045m     LEA CRLF(PC),A1
00001168                          3046mm     PRINT_STR A1,D2
00001168                          3047mm LOOP_202
00001168  0C11 0000               3048mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000116C  6700 0016               3049mm     BEQ EXIT_202
00001170                          3050mmm     PRINT_CHAR (A1)+,D2
00001170                          3051mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001170                 TRUE     3052mmm     IFEQ DEBUG
00001170  1439 00C00003           3053mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001176  0802 0002               3054mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000117A  67F4                    3055mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
0000117C  13D9 00C00007           3056mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001182                          3057mmm     ENDC
00001182                          3058mmm 
00001182                 FALSE    3059mmm     IFNE DEBUG
00001182                          3060mmm     ENDC
00001182                          3061mmm 
00001182                          3062mmm     ENDM
00001182  60E4                    3063mm     BRA LOOP_202
00001184                          3064mm EXIT_202
00001184                          3065mm     ENDM
00001184                          3066m     ENDM
00001184                          3067  
00001184  2047                    3068      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001186  7E00                    3069      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001188                          3070  
00001188                          3071m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001188  31FC AAAA 2AAA          3072m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000118E  4E71                    3073m     NOP
00001190  31FC 5555 1554          3074m     MOVE.W #$5555,$1554
00001196  4E71                    3075m     NOP
00001198  31FC 8080 2AAA          3076m     MOVE.W #$8080,$2AAA
0000119E  4E71                    3077m     NOP
000011A0  31FC AAAA 2AAA          3078m     MOVE.W #$AAAA,$2AAA
000011A6  4E71                    3079m     NOP
000011A8  31FC 5555 1554          3080m     MOVE.W #$5555,$1554
000011AE  4E71                    3081m     NOP
000011B0  31FC 2020 2AAA          3082m     MOVE.W #$2020,$2AAA
000011B6                          3083m     ENDM
000011B6                          3084                              
000011B6                          3085      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000011B6  3E3C 0000               3086s     MOVE.W  #$0,D7
000011BA  6000 0006               3087s     BRA _20000013
000011BE                          3088s _20000012
000011BE  4E71                    3089          NOP
000011C0                          3090      ENDF
000011C0  5247                    3091s     ADD.W   #1,D7
000011C2                          3092s _20000013
000011C2  BE7C FFFF               3093s     CMP.W   #$FFFFFFFF,D7
000011C6  6FF6                    3094s     BLE _20000012
000011C8                          3095               
000011C8  45FA 0E6C               3096      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
000011CC                          3097m     PRINT_STR A2,D2
000011CC                          3098m LOOP_205
000011CC  0C12 0000               3099m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D0  6700 0016               3100m     BEQ EXIT_205
000011D4                          3101mm     PRINT_CHAR (A2)+,D2
000011D4                          3102mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011D4                 TRUE     3103mm     IFEQ DEBUG
000011D4  1439 00C00003           3104mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011DA  0802 0002               3105mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011DE  67F4                    3106mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
000011E0  13DA 00C00007           3107mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011E6                          3108mm     ENDC
000011E6                          3109mm 
000011E6                 FALSE    3110mm     IFNE DEBUG
000011E6                          3111mm     ENDC
000011E6                          3112mm 
000011E6                          3113mm     ENDM
000011E6  60E4                    3114m     BRA LOOP_205
000011E8                          3115m EXIT_205
000011E8                          3116m     ENDM
000011E8                          3117  
000011E8                          3118m     PRINT_REG D0,D3,D4,D5,A2
000011E8  45FA 0E66               3119m     LEA OX(PC),A2
000011EC                          3120mm     PRINT_STR A2,D3
000011EC                          3121mm LOOP_208
000011EC  0C12 0000               3122mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011F0  6700 0016               3123mm     BEQ EXIT_208
000011F4                          3124mmm     PRINT_CHAR (A2)+,D3
000011F4                          3125mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011F4                 TRUE     3126mmm     IFEQ DEBUG
000011F4  1639 00C00003           3127mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011FA  0803 0002               3128mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011FE  67F4                    3129mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
00001200  13DA 00C00007           3130mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001206                          3131mmm     ENDC
00001206                          3132mmm 
00001206                 FALSE    3133mmm     IFNE DEBUG
00001206                          3134mmm     ENDC
00001206                          3135mmm 
00001206                          3136mmm     ENDM
00001206  60E4                    3137mm     BRA LOOP_208
00001208                          3138mm EXIT_208
00001208                          3139mm     ENDM
00001208  7A07                    3140m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000120A                          3141m LOOP_207
0000120A                          3142mm     BIN2HEX D0,D4,A2
0000120A  45FA 0E03               3143mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000120E  E998                    3144mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001210  1800                    3145mm     MOVE.B D0,D4
00001212  0284 0000000F           3146mm     ANDI.L #$F,D4
00001218  1832 4000               3147mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000121C                          3148mm     ENDM
0000121C                          3149mm     PRINT_CHAR D4,D3
0000121C                          3150mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121C                 TRUE     3151mm     IFEQ DEBUG
0000121C  1639 00C00003           3152mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001222  0803 0002               3153mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001226  67F4                    3154mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
00001228  13C4 00C00007           3155mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000122E                          3156mm     ENDC
0000122E                          3157mm 
0000122E                 FALSE    3158mm     IFNE DEBUG
0000122E                          3159mm     ENDC
0000122E                          3160mm 
0000122E                          3161mm     ENDM
0000122E  57CD FFDA               3162m     DBEQ D5,LOOP_207
00001232                          3163m     ENDM
00001232                          3164  
00001232  45FA 0E1F               3165      LEA TO(PC),A2
00001236                          3166m     PRINT_STR A2,D3
00001236                          3167m LOOP_212
00001236  0C12 0000               3168m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000123A  6700 0016               3169m     BEQ EXIT_212
0000123E                          3170mm     PRINT_CHAR (A2)+,D3
0000123E                          3171mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000123E                 TRUE     3172mm     IFEQ DEBUG
0000123E  1639 00C00003           3173mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001244  0803 0002               3174mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001248  67F4                    3175mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
0000124A  13DA 00C00007           3176mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001250                          3177mm     ENDC
00001250                          3178mm 
00001250                 FALSE    3179mm     IFNE DEBUG
00001250                          3180mm     ENDC
00001250                          3181mm 
00001250                          3182mm     ENDM
00001250  60E4                    3183m     BRA LOOP_212
00001252                          3184m EXIT_212
00001252                          3185m     ENDM
00001252                          3186  
00001252  2408                    3187      MOVE.L A0,D2
00001254                          3188m     PRINT_REG D2,D3,D4,D5,A2
00001254  45FA 0DFA               3189m     LEA OX(PC),A2
00001258                          3190mm     PRINT_STR A2,D3
00001258                          3191mm LOOP_215
00001258  0C12 0000               3192mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000125C  6700 0016               3193mm     BEQ EXIT_215
00001260                          3194mmm     PRINT_CHAR (A2)+,D3
00001260                          3195mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001260                 TRUE     3196mmm     IFEQ DEBUG
00001260  1639 00C00003           3197mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001266  0803 0002               3198mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000126A  67F4                    3199mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
0000126C  13DA 00C00007           3200mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001272                          3201mmm     ENDC
00001272                          3202mmm 
00001272                 FALSE    3203mmm     IFNE DEBUG
00001272                          3204mmm     ENDC
00001272                          3205mmm 
00001272                          3206mmm     ENDM
00001272  60E4                    3207mm     BRA LOOP_215
00001274                          3208mm EXIT_215
00001274                          3209mm     ENDM
00001274  7A07                    3210m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001276                          3211m LOOP_214
00001276                          3212mm     BIN2HEX D2,D4,A2
00001276  45FA 0D97               3213mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000127A  E99A                    3214mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000127C  1802                    3215mm     MOVE.B D2,D4
0000127E  0284 0000000F           3216mm     ANDI.L #$F,D4
00001284  1832 4000               3217mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001288                          3218mm     ENDM
00001288                          3219mm     PRINT_CHAR D4,D3
00001288                          3220mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001288                 TRUE     3221mm     IFEQ DEBUG
00001288  1639 00C00003           3222mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000128E  0803 0002               3223mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001292  67F4                    3224mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001294  13C4 00C00007           3225mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000129A                          3226mm     ENDC
0000129A                          3227mm 
0000129A                 FALSE    3228mm     IFNE DEBUG
0000129A                          3229mm     ENDC
0000129A                          3230mm 
0000129A                          3231mm     ENDM
0000129A  57CD FFDA               3232m     DBEQ D5,LOOP_214
0000129E                          3233m     ENDM
0000129E                          3234  
0000129E                          3235m     PRINT_CRLF D3,A2
0000129E  45FA 0DAA               3236m     LEA CRLF(PC),A2
000012A2                          3237mm     PRINT_STR A2,D3
000012A2                          3238mm LOOP_220
000012A2  0C12 0000               3239mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012A6  6700 0016               3240mm     BEQ EXIT_220
000012AA                          3241mmm     PRINT_CHAR (A2)+,D3
000012AA                          3242mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012AA                 TRUE     3243mmm     IFEQ DEBUG
000012AA  1639 00C00003           3244mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B0  0803 0002               3245mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012B4  67F4                    3246mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
000012B6  13DA 00C00007           3247mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012BC                          3248mmm     ENDC
000012BC                          3249mmm 
000012BC                 FALSE    3250mmm     IFNE DEBUG
000012BC                          3251mmm     ENDC
000012BC                          3252mmm 
000012BC                          3253mmm     ENDM
000012BC  60E4                    3254mm     BRA LOOP_220
000012BE                          3255mm EXIT_220
000012BE                          3256mm     ENDM
000012BE                          3257m     ENDM
000012BE                          3258  
000012BE                          3259m     PROGRAM D0,(A0),D2
000012BE  3080                    3260m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000012C0                          3261m 
000012C0                          3262m WAIT_FOR_COMPLETE_222
000012C0  3410                    3263m         MOVE.W (A0),D2
000012C2                          3264m 
000012C2                          3265m         IF.W D2 <NE> D0 THEN
000012C2  B440                    3266ms     CMP.W   D0,D2
000012C4  6700 0004               3267ms     BEQ _00000013
000012C8  60F6                    3268m             BRA WAIT_FOR_COMPLETE_222
000012CA                          3269m         ENDI
000012CA                          3270ms _00000013
000012CA                          3271m         ENDM
000012CA                          3272  
000012CA                          3273m     PROTECT
000012CA  31FC AAAA 2AAA          3274m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000012D0  31FC 5555 1554          3275m     MOVE.W #$5555,$1554
000012D6  31FC A0A0 2AAA          3276m     MOVE.W #$A0A0,$2AAA
000012DC                          3277m     ENDM
000012DC                          3278  
000012DC  6000 F066               3279      BRA MAIN_LOOP
000012E0                          3280      
000012E0                          3281  X
000012E0  45FA 0D81               3282      LEA STATUS_REGISTER(PC),A2
000012E4                          3283m     PRINT_STR A2,D3
000012E4                          3284m LOOP_224
000012E4  0C12 0000               3285m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012E8  6700 0016               3286m     BEQ EXIT_224
000012EC                          3287mm     PRINT_CHAR (A2)+,D3
000012EC                          3288mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012EC                 TRUE     3289mm     IFEQ DEBUG
000012EC  1639 00C00003           3290mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012F2  0803 0002               3291mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012F6  67F4                    3292mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
000012F8  13DA 00C00007           3293mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012FE                          3294mm     ENDC
000012FE                          3295mm 
000012FE                 FALSE    3296mm     IFNE DEBUG
000012FE                          3297mm     ENDC
000012FE                          3298mm 
000012FE                          3299mm     ENDM
000012FE  60E4                    3300m     BRA LOOP_224
00001300                          3301m EXIT_224
00001300                          3302m     ENDM
00001300                          3303  
00001300  40C0                    3304      MOVE SR,D0
00001302                          3305m     PRINT_REG D0,D3,D4,D5,A2
00001302  45FA 0D4C               3306m     LEA OX(PC),A2
00001306                          3307mm     PRINT_STR A2,D3
00001306                          3308mm LOOP_227
00001306  0C12 0000               3309mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000130A  6700 0016               3310mm     BEQ EXIT_227
0000130E                          3311mmm     PRINT_CHAR (A2)+,D3
0000130E                          3312mmm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000130E                 TRUE     3313mmm     IFEQ DEBUG
0000130E  1639 00C00003           3314mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001314  0803 0002               3315mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001318  67F4                    3316mmm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
0000131A  13DA 00C00007           3317mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001320                          3318mmm     ENDC
00001320                          3319mmm 
00001320                 FALSE    3320mmm     IFNE DEBUG
00001320                          3321mmm     ENDC
00001320                          3322mmm 
00001320                          3323mmm     ENDM
00001320  60E4                    3324mm     BRA LOOP_227
00001322                          3325mm EXIT_227
00001322                          3326mm     ENDM
00001322  7A07                    3327m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001324                          3328m LOOP_226
00001324                          3329mm     BIN2HEX D0,D4,A2
00001324  45FA 0CE9               3330mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001328  E998                    3331mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000132A  1800                    3332mm     MOVE.B D0,D4
0000132C  0284 0000000F           3333mm     ANDI.L #$F,D4
00001332  1832 4000               3334mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001336                          3335mm     ENDM
00001336                          3336mm     PRINT_CHAR D4,D3
00001336                          3337mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001336                 TRUE     3338mm     IFEQ DEBUG
00001336  1639 00C00003           3339mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000133C  0803 0002               3340mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001340  67F4                    3341mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
00001342  13C4 00C00007           3342mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001348                          3343mm     ENDC
00001348                          3344mm 
00001348                 FALSE    3345mm     IFNE DEBUG
00001348                          3346mm     ENDC
00001348                          3347mm 
00001348                          3348mm     ENDM
00001348  57CD FFDA               3349m     DBEQ D5,LOOP_226
0000134C                          3350m     ENDM
0000134C                          3351m     PRINT_CRLF D3,A2
0000134C  45FA 0CFC               3352m     LEA CRLF(PC),A2
00001350                          3353mm     PRINT_STR A2,D3
00001350                          3354mm LOOP_232
00001350  0C12 0000               3355mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001354  6700 0016               3356mm     BEQ EXIT_232
00001358                          3357mmm     PRINT_CHAR (A2)+,D3
00001358                          3358mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001358                 TRUE     3359mmm     IFEQ DEBUG
00001358  1639 00C00003           3360mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000135E  0803 0002               3361mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001362  67F4                    3362mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001364  13DA 00C00007           3363mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000136A                          3364mmm     ENDC
0000136A                          3365mmm 
0000136A                 FALSE    3366mmm     IFNE DEBUG
0000136A                          3367mmm     ENDC
0000136A                          3368mmm 
0000136A                          3369mmm     ENDM
0000136A  60E4                    3370mm     BRA LOOP_232
0000136C                          3371mm EXIT_232
0000136C                          3372mm     ENDM
0000136C                          3373m     ENDM
0000136C                          3374  
0000136C  45FA 0CF0               3375      LEA STACK_POINTER(PC),A2
00001370                          3376m     PRINT_STR A2,D3
00001370                          3377m LOOP_234
00001370  0C12 0000               3378m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001374  6700 0016               3379m     BEQ EXIT_234
00001378                          3380mm     PRINT_CHAR (A2)+,D3
00001378                          3381mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001378                 TRUE     3382mm     IFEQ DEBUG
00001378  1639 00C00003           3383mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000137E  0803 0002               3384mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001382  67F4                    3385mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
00001384  13DA 00C00007           3386mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000138A                          3387mm     ENDC
0000138A                          3388mm 
0000138A                 FALSE    3389mm     IFNE DEBUG
0000138A                          3390mm     ENDC
0000138A                          3391mm 
0000138A                          3392mm     ENDM
0000138A  60E4                    3393m     BRA LOOP_234
0000138C                          3394m EXIT_234
0000138C                          3395m     ENDM
0000138C                          3396  
0000138C  200F                    3397      MOVE.L SP,D0
0000138E                          3398m     PRINT_REG D0,D3,D4,D5,A2
0000138E  45FA 0CC0               3399m     LEA OX(PC),A2
00001392                          3400mm     PRINT_STR A2,D3
00001392                          3401mm LOOP_237
00001392  0C12 0000               3402mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001396  6700 0016               3403mm     BEQ EXIT_237
0000139A                          3404mmm     PRINT_CHAR (A2)+,D3
0000139A                          3405mmm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000139A                 TRUE     3406mmm     IFEQ DEBUG
0000139A  1639 00C00003           3407mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013A0  0803 0002               3408mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013A4  67F4                    3409mmm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
000013A6  13DA 00C00007           3410mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013AC                          3411mmm     ENDC
000013AC                          3412mmm 
000013AC                 FALSE    3413mmm     IFNE DEBUG
000013AC                          3414mmm     ENDC
000013AC                          3415mmm 
000013AC                          3416mmm     ENDM
000013AC  60E4                    3417mm     BRA LOOP_237
000013AE                          3418mm EXIT_237
000013AE                          3419mm     ENDM
000013AE  7A07                    3420m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000013B0                          3421m LOOP_236
000013B0                          3422mm     BIN2HEX D0,D4,A2
000013B0  45FA 0C5D               3423mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000013B4  E998                    3424mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000013B6  1800                    3425mm     MOVE.B D0,D4
000013B8  0284 0000000F           3426mm     ANDI.L #$F,D4
000013BE  1832 4000               3427mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000013C2                          3428mm     ENDM
000013C2                          3429mm     PRINT_CHAR D4,D3
000013C2                          3430mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013C2                 TRUE     3431mm     IFEQ DEBUG
000013C2  1639 00C00003           3432mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013C8  0803 0002               3433mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013CC  67F4                    3434mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
000013CE  13C4 00C00007           3435mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013D4                          3436mm     ENDC
000013D4                          3437mm 
000013D4                 FALSE    3438mm     IFNE DEBUG
000013D4                          3439mm     ENDC
000013D4                          3440mm 
000013D4                          3441mm     ENDM
000013D4  57CD FFDA               3442m     DBEQ D5,LOOP_236
000013D8                          3443m     ENDM
000013D8                          3444m     PRINT_CRLF D3,A2
000013D8  45FA 0C70               3445m     LEA CRLF(PC),A2
000013DC                          3446mm     PRINT_STR A2,D3
000013DC                          3447mm LOOP_242
000013DC  0C12 0000               3448mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013E0  6700 0016               3449mm     BEQ EXIT_242
000013E4                          3450mmm     PRINT_CHAR (A2)+,D3
000013E4                          3451mmm WAIT_FOR_READY_243                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013E4                 TRUE     3452mmm     IFEQ DEBUG
000013E4  1639 00C00003           3453mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013EA  0803 0002               3454mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013EE  67F4                    3455mmm         BEQ WAIT_FOR_READY_243                      ; NO SPACE, CHECK AGAIN
000013F0  13DA 00C00007           3456mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013F6                          3457mmm     ENDC
000013F6                          3458mmm 
000013F6                 FALSE    3459mmm     IFNE DEBUG
000013F6                          3460mmm     ENDC
000013F6                          3461mmm 
000013F6                          3462mmm     ENDM
000013F6  60E4                    3463mm     BRA LOOP_242
000013F8                          3464mm EXIT_242
000013F8                          3465mm     ENDM
000013F8                          3466m     ENDM
000013F8                          3467  
000013F8  6000 EF4A               3468      BRA MAIN_LOOP
000013FC                          3469          
000013FC                          3470  I
000013FC  13FC 0008 00C0000B      3471      MOVE.B #8,DUART_IMR
00001404  027C F8FF               3472      AND.W #$F8FF,SR
00001408  6000 EF3A               3473      BRA MAIN_LOOP
0000140C                          3474      
0000140C                          3475  O
0000140C  13FC 0000 00C0000B      3476      MOVE.B #0,DUART_IMR
00001414  007C 0700               3477      OR.W #$0700,SR
00001418  6000 EF2A               3478      BRA MAIN_LOOP
0000141C                          3479          
0000141C                          3480  HASH
0000141C                          3481m     PROTECT
0000141C  31FC AAAA 2AAA          3482m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001422  31FC 5555 1554          3483m     MOVE.W #$5555,$1554
00001428  31FC A0A0 2AAA          3484m     MOVE.W #$A0A0,$2AAA
0000142E                          3485m     ENDM
0000142E  6000 EF14               3486      BRA MAIN_LOOP
00001432                          3487      
00001432                          3488  B
00001432  13FC 0038 00A00019      3489      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000143A                          3490      
0000143A                          3491m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
0000143A  13FC 00FF 00A00007      3492m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001442  103C 0030               3493m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001446  0000 0006               3494m     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000144A  13C0 00A00019           3495m     MOVE.B D0, MC68230_PORT_C_DATA
00001450  0200 00EF               3496m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001454  13FC 00E0 00A00013      3497m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
0000145C  13C0 00A00019           3498m     MOVE.B D0, MC68230_PORT_C_DATA
00001462  0000 0010               3499m     ORI.B #MC68230_PORT_C_WRITE, D0
00001466  13C0 00A00019           3500m     MOVE.B D0, MC68230_PORT_C_DATA
0000146C  13FC 0038 00A00019      3501m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001474                          3502m     ENDM
00001474                          3503m     WAIT_DRIVE_READY D0, D1
00001474                          3504m LOOP_246
00001474                          3505mm     READ_IDE_STATUS D0, D1
00001474                          3506mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001474  13FC 0000 00A00007      3507mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000147C  123C 0030               3508mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001480  0001 0007               3509mmm     ORI.B #IDE_STATUS_REGISTER, D1
00001484  13C1 00A00019           3510mmm     MOVE.B D1, MC68230_PORT_C_DATA
0000148A  0201 00DF               3511mmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000148E  13C1 00A00019           3512mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001494  1039 00A00013           3513mmm     MOVE.B MC68230_PORT_B_DATA, D0
0000149A  0001 0020               3514mmm     ORI.B #MC68230_PORT_C_READ, D1
0000149E  13C1 00A00019           3515mmm     MOVE.B D1, MC68230_PORT_C_DATA
000014A4  13FC 0038 00A00019      3516mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014AC                          3517mmm     ENDM
000014AC                          3518mm     ENDM
000014AC  0800 0006               3519m     BTST #IDE_STATUS_READY, D0
000014B0  67C2                    3520m     BEQ LOOP_246
000014B2                          3521m     ENDM
000014B2                          3522      
000014B2                          3523m     READ_8 #IDE_DRIVESEL_REGISTER, D0, D1
000014B2  13FC 0000 00A00007      3524m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014BA  123C 0030               3525m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000014BE  0001 0006               3526m     ORI.B #IDE_DRIVESEL_REGISTER, D1
000014C2  13C1 00A00019           3527m     MOVE.B D1, MC68230_PORT_C_DATA
000014C8  0201 00DF               3528m     ANDI.B #~MC68230_PORT_C_READ, D1
000014CC  13C1 00A00019           3529m     MOVE.B D1, MC68230_PORT_C_DATA
000014D2  1039 00A00013           3530m     MOVE.B MC68230_PORT_B_DATA, D0
000014D8  0001 0020               3531m     ORI.B #MC68230_PORT_C_READ, D1
000014DC  13C1 00A00019           3532m     MOVE.B D1, MC68230_PORT_C_DATA
000014E2  13FC 0038 00A00019      3533m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014EA                          3534m     ENDM
000014EA                          3535      
000014EA  263C 00000201           3536      MOVE.L #513,D3
000014F0                          3537  
000014F0                          3538m     SEND_READ_COMMAND_AND_WAIT D3, D0, D1, D2       
000014F0                          3539mm     WAIT_DRIVE_NOT_BUSY D0, D1
000014F0                          3540mm LOOP_251
000014F0                          3541mmm     READ_IDE_STATUS D0, D1
000014F0                          3542mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000014F0  13FC 0000 00A00007      3543mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014F8  123C 0030               3544mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000014FC  0001 0007               3545mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001500  13C1 00A00019           3546mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001506  0201 00DF               3547mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000150A  13C1 00A00019           3548mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001510  1039 00A00013           3549mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001516  0001 0020               3550mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000151A  13C1 00A00019           3551mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001520  13FC 0038 00A00019      3552mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001528                          3553mmmm     ENDM
00001528                          3554mmm     ENDM
00001528  0800 0007               3555mm     BTST #IDE_STATUS_BUSY, D0
0000152C  66C2                    3556mm     BNE LOOP_251
0000152E                          3557mm     ENDM
0000152E                          3558mm     SET_READ_ADDRESS D3, D0, D1, D2
0000152E                          3559mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
0000152E  13FC 00FF 00A00007      3560mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001536  103C 0030               3561mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000153A  0000 0002               3562mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
0000153E  13C0 00A00019           3563mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001544  0200 00EF               3564mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001548  13FC 0001 00A00013      3565mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001550  13C0 00A00019           3566mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001556  0000 0010               3567mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000155A  13C0 00A00019           3568mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001560  13FC 0038 00A00019      3569mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001568                          3570mmm     ENDM
00001568  2203                    3571mm     MOVE.L D3,D1
0000156A                          3572mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
0000156A  13FC 00FF 00A00007      3573mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001572  103C 0030               3574mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001576  0000 0003               3575mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
0000157A  13C0 00A00019           3576mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001580  0200 00EF               3577mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001584  13C1 00A00013           3578mmm     MOVE.B D1, MC68230_PORT_B_DATA
0000158A  13C0 00A00019           3579mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001590  0000 0010               3580mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001594  13C0 00A00019           3581mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000159A  13FC 0038 00A00019      3582mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015A2                          3583mmm     ENDM
000015A2  E089                    3584mm     LSR.L #8, D1
000015A4                          3585mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
000015A4  13FC 00FF 00A00007      3586mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000015AC  103C 0030               3587mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000015B0  0000 0004               3588mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
000015B4  13C0 00A00019           3589mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015BA  0200 00EF               3590mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000015BE  13C1 00A00013           3591mmm     MOVE.B D1, MC68230_PORT_B_DATA
000015C4  13C0 00A00019           3592mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015CA  0000 0010               3593mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000015CE  13C0 00A00019           3594mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015D4  13FC 0038 00A00019      3595mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015DC                          3596mmm     ENDM
000015DC  E089                    3597mm     LSR.L #8, D1
000015DE                          3598mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
000015DE  13FC 00FF 00A00007      3599mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000015E6  103C 0030               3600mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000015EA  0000 0005               3601mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
000015EE  13C0 00A00019           3602mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015F4  0200 00EF               3603mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000015F8  13C1 00A00013           3604mmm     MOVE.B D1, MC68230_PORT_B_DATA
000015FE  13C0 00A00019           3605mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001604  0000 0010               3606mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001608  13C0 00A00019           3607mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000160E  13FC 0038 00A00019      3608mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001616                          3609mmm     ENDM
00001616  E089                    3610mm     LSR.L #8, D1
00001618                          3611mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
00001618  13FC 0000 00A00007      3612mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001620  103C 0030               3613mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001624  0000 0006               3614mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001628  13C0 00A00019           3615mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000162E  0200 00DF               3616mmm     ANDI.B #~MC68230_PORT_C_READ, D0
00001632  13C0 00A00019           3617mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001638  1439 00A00013           3618mmm     MOVE.B MC68230_PORT_B_DATA, D2
0000163E  0000 0020               3619mmm     ORI.B #MC68230_PORT_C_READ, D0
00001642  13C0 00A00019           3620mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001648  13FC 0038 00A00019      3621mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001650                          3622mmm     ENDM
00001650  0201 000F               3623mm     ANDI.B #$0F,D1
00001654  8401                    3624mm     OR.B D1,D2
00001656                          3625mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
00001656  13FC 00FF 00A00007      3626mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000165E  103C 0030               3627mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001662  0000 0006               3628mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001666  13C0 00A00019           3629mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000166C  0200 00EF               3630mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001670  13C2 00A00013           3631mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001676  13C0 00A00019           3632mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000167C  0000 0010               3633mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001680  13C0 00A00019           3634mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001686  13FC 0038 00A00019      3635mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000168E                          3636mmm     ENDM
0000168E                          3637mm     ENDM
0000168E                          3638mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
0000168E                          3639mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
0000168E  13FC 00FF 00A00007      3640mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001696  103C 0030               3641mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000169A  0000 0007               3642mmm     ORI.B #IDE_COMMAND_REGISTER, D0
0000169E  13C0 00A00019           3643mmm     MOVE.B D0, MC68230_PORT_C_DATA
000016A4  0200 00EF               3644mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000016A8  13FC 0020 00A00013      3645mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
000016B0  13C0 00A00019           3646mmm     MOVE.B D0, MC68230_PORT_C_DATA
000016B6  0000 0010               3647mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000016BA  13C0 00A00019           3648mmm     MOVE.B D0, MC68230_PORT_C_DATA
000016C0  13FC 0038 00A00019      3649mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016C8                          3650mmm     ENDM
000016C8                          3651mm     ENDM
000016C8                          3652mm     WAIT_DRIVE_NOT_BUSY D0, D1
000016C8                          3653mm LOOP_263
000016C8                          3654mmm     READ_IDE_STATUS D0, D1
000016C8                          3655mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000016C8  13FC 0000 00A00007      3656mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016D0  123C 0030               3657mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000016D4  0001 0007               3658mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000016D8  13C1 00A00019           3659mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016DE  0201 00DF               3660mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000016E2  13C1 00A00019           3661mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016E8  1039 00A00013           3662mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000016EE  0001 0020               3663mmmm     ORI.B #MC68230_PORT_C_READ, D1
000016F2  13C1 00A00019           3664mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000016F8  13FC 0038 00A00019      3665mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001700                          3666mmmm     ENDM
00001700                          3667mmm     ENDM
00001700  0800 0007               3668mm     BTST #IDE_STATUS_BUSY, D0
00001704  66C2                    3669mm     BNE LOOP_263
00001706                          3670mm     ENDM
00001706                          3671mm     WAIT_DRIVE_DRQ D0, D1
00001706                          3672mm LOOP_266
00001706                          3673mmm     READ_IDE_STATUS D0, D1
00001706                          3674mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001706  13FC 0000 00A00007      3675mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000170E  123C 0030               3676mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001712  0001 0007               3677mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001716  13C1 00A00019           3678mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000171C  0201 00DF               3679mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001720  13C1 00A00019           3680mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001726  1039 00A00013           3681mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000172C  0001 0020               3682mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001730  13C1 00A00019           3683mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001736  13FC 0038 00A00019      3684mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000173E                          3685mmmm     ENDM
0000173E                          3686mmm     ENDM
0000173E  0800 0003               3687mm     BTST #IDE_STATUS_DRQ, D0
00001742  67C2                    3688mm     BEQ LOOP_266
00001744                          3689mm     ENDM
00001744                          3690m     ENDM
00001744                          3691  
00001744                          3692m     READ_32 #IDE_DATA_REGISTER, D4, D1      ; start -> D4
00001744                          3693mm     READ_16 #IDE_DATA_REGISTER, D4, D1
00001744  13FC 0000 00A00007      3694mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000174C  13FC 0000 00A00005      3695mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001754                          3696mm     
00001754  123C 0030               3697mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001758  0001 0000               3698mm     ORI.B #IDE_DATA_REGISTER, D1
0000175C  13C1 00A00019           3699mm     MOVE.B D1, MC68230_PORT_C_DATA
00001762  0201 00DF               3700mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001766  13C1 00A00019           3701mm     MOVE.B D1, MC68230_PORT_C_DATA
0000176C  1839 00A00011           3702mm     MOVE.B MC68230_PORT_A_DATA, D4
00001772  E14C                    3703mm     LSL.W #8, D4
00001774  1839 00A00013           3704mm     MOVE.B MC68230_PORT_B_DATA, D4
0000177A  0001 0020               3705mm     ORI.B #MC68230_PORT_C_READ, D1
0000177E  13C1 00A00019           3706mm     MOVE.B D1, MC68230_PORT_C_DATA
00001784  13FC 0038 00A00019      3707mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000178C                          3708mm     ENDM
0000178C  E18C                    3709m     LSL.L #8, D4
0000178E  E18C                    3710m     LSL.L #8, D4
00001790                          3711mm     READ_16 #IDE_DATA_REGISTER, D4, D1
00001790  13FC 0000 00A00007      3712mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001798  13FC 0000 00A00005      3713mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000017A0                          3714mm     
000017A0  123C 0030               3715mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000017A4  0001 0000               3716mm     ORI.B #IDE_DATA_REGISTER, D1
000017A8  13C1 00A00019           3717mm     MOVE.B D1, MC68230_PORT_C_DATA
000017AE  0201 00DF               3718mm     ANDI.B #~MC68230_PORT_C_READ, D1
000017B2  13C1 00A00019           3719mm     MOVE.B D1, MC68230_PORT_C_DATA
000017B8  1839 00A00011           3720mm     MOVE.B MC68230_PORT_A_DATA, D4
000017BE  E14C                    3721mm     LSL.W #8, D4
000017C0  1839 00A00013           3722mm     MOVE.B MC68230_PORT_B_DATA, D4
000017C6  0001 0020               3723mm     ORI.B #MC68230_PORT_C_READ, D1
000017CA  13C1 00A00019           3724mm     MOVE.B D1, MC68230_PORT_C_DATA
000017D0  13FC 0038 00A00019      3725mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017D8                          3726mm     ENDM
000017D8                          3727m     ENDM
000017D8                          3728m     READ_32 #IDE_DATA_REGISTER, D5, D1      ; end -> D5
000017D8                          3729mm     READ_16 #IDE_DATA_REGISTER, D5, D1
000017D8  13FC 0000 00A00007      3730mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000017E0  13FC 0000 00A00005      3731mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000017E8                          3732mm     
000017E8  123C 0030               3733mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000017EC  0001 0000               3734mm     ORI.B #IDE_DATA_REGISTER, D1
000017F0  13C1 00A00019           3735mm     MOVE.B D1, MC68230_PORT_C_DATA
000017F6  0201 00DF               3736mm     ANDI.B #~MC68230_PORT_C_READ, D1
000017FA  13C1 00A00019           3737mm     MOVE.B D1, MC68230_PORT_C_DATA
00001800  1A39 00A00011           3738mm     MOVE.B MC68230_PORT_A_DATA, D5
00001806  E14D                    3739mm     LSL.W #8, D5
00001808  1A39 00A00013           3740mm     MOVE.B MC68230_PORT_B_DATA, D5
0000180E  0001 0020               3741mm     ORI.B #MC68230_PORT_C_READ, D1
00001812  13C1 00A00019           3742mm     MOVE.B D1, MC68230_PORT_C_DATA
00001818  13FC 0038 00A00019      3743mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001820                          3744mm     ENDM
00001820  E18D                    3745m     LSL.L #8, D5
00001822  E18D                    3746m     LSL.L #8, D5
00001824                          3747mm     READ_16 #IDE_DATA_REGISTER, D5, D1
00001824  13FC 0000 00A00007      3748mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000182C  13FC 0000 00A00005      3749mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001834                          3750mm     
00001834  123C 0030               3751mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001838  0001 0000               3752mm     ORI.B #IDE_DATA_REGISTER, D1
0000183C  13C1 00A00019           3753mm     MOVE.B D1, MC68230_PORT_C_DATA
00001842  0201 00DF               3754mm     ANDI.B #~MC68230_PORT_C_READ, D1
00001846  13C1 00A00019           3755mm     MOVE.B D1, MC68230_PORT_C_DATA
0000184C  1A39 00A00011           3756mm     MOVE.B MC68230_PORT_A_DATA, D5
00001852  E14D                    3757mm     LSL.W #8, D5
00001854  1A39 00A00013           3758mm     MOVE.B MC68230_PORT_B_DATA, D5
0000185A  0001 0020               3759mm     ORI.B #MC68230_PORT_C_READ, D1
0000185E  13C1 00A00019           3760mm     MOVE.B D1, MC68230_PORT_C_DATA
00001864  13FC 0038 00A00019      3761mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000186C                          3762mm     ENDM
0000186C                          3763m     ENDM
0000186C                          3764m     READ_32 #IDE_DATA_REGISTER, D7, D1      ; read entry point into address accumulator
0000186C                          3765mm     READ_16 #IDE_DATA_REGISTER, D7, D1
0000186C  13FC 0000 00A00007      3766mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001874  13FC 0000 00A00005      3767mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000187C                          3768mm     
0000187C  123C 0030               3769mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001880  0001 0000               3770mm     ORI.B #IDE_DATA_REGISTER, D1
00001884  13C1 00A00019           3771mm     MOVE.B D1, MC68230_PORT_C_DATA
0000188A  0201 00DF               3772mm     ANDI.B #~MC68230_PORT_C_READ, D1
0000188E  13C1 00A00019           3773mm     MOVE.B D1, MC68230_PORT_C_DATA
00001894  1E39 00A00011           3774mm     MOVE.B MC68230_PORT_A_DATA, D7
0000189A  E14F                    3775mm     LSL.W #8, D7
0000189C  1E39 00A00013           3776mm     MOVE.B MC68230_PORT_B_DATA, D7
000018A2  0001 0020               3777mm     ORI.B #MC68230_PORT_C_READ, D1
000018A6  13C1 00A00019           3778mm     MOVE.B D1, MC68230_PORT_C_DATA
000018AC  13FC 0038 00A00019      3779mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000018B4                          3780mm     ENDM
000018B4  E18F                    3781m     LSL.L #8, D7
000018B6  E18F                    3782m     LSL.L #8, D7
000018B8                          3783mm     READ_16 #IDE_DATA_REGISTER, D7, D1
000018B8  13FC 0000 00A00007      3784mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000018C0  13FC 0000 00A00005      3785mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000018C8                          3786mm     
000018C8  123C 0030               3787mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
000018CC  0001 0000               3788mm     ORI.B #IDE_DATA_REGISTER, D1
000018D0  13C1 00A00019           3789mm     MOVE.B D1, MC68230_PORT_C_DATA
000018D6  0201 00DF               3790mm     ANDI.B #~MC68230_PORT_C_READ, D1
000018DA  13C1 00A00019           3791mm     MOVE.B D1, MC68230_PORT_C_DATA
000018E0  1E39 00A00011           3792mm     MOVE.B MC68230_PORT_A_DATA, D7
000018E6  E14F                    3793mm     LSL.W #8, D7
000018E8  1E39 00A00013           3794mm     MOVE.B MC68230_PORT_B_DATA, D7
000018EE  0001 0020               3795mm     ORI.B #MC68230_PORT_C_READ, D1
000018F2  13C1 00A00019           3796mm     MOVE.B D1, MC68230_PORT_C_DATA
000018F8  13FC 0038 00A00019      3797mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001900                          3798mm     ENDM
00001900                          3799m     ENDM
00001900  9A84                    3800      SUB.L D4,D5                             ; work out num bytes
00001902                          3801  
00001902                          3802m     PRINT_CHAR #'.',D0
00001902                          3803m WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001902                 TRUE     3804m     IFEQ DEBUG
00001902  1039 00C00003           3805m         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001908  0800 0002               3806m         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000190C  67F4                    3807m         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
0000190E  13FC 002E 00C00007      3808m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001916                          3809m     ENDC
00001916                          3810m 
00001916                 FALSE    3811m     IFNE DEBUG
00001916                          3812m     ENDC
00001916                          3813m 
00001916                          3814m     ENDM
00001916  2044                    3815      MOVE.L D4, A0
00001918                          3816      FOR D6 = #6 TO #255 DO
00001918  3C3C 0006               3817s     MOVE.W  #6,D6
0000191C  6000 004E               3818s     BRA _20000015
00001920                          3819s _20000014
00001920                          3820m         READ_16 #IDE_DATA_REGISTER, D0, D1
00001920  13FC 0000 00A00007      3821m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001928  13FC 0000 00A00005      3822m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001930                          3823m     
00001930  123C 0030               3824m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001934  0001 0000               3825m     ORI.B #IDE_DATA_REGISTER, D1
00001938  13C1 00A00019           3826m     MOVE.B D1, MC68230_PORT_C_DATA
0000193E  0201 00DF               3827m     ANDI.B #~MC68230_PORT_C_READ, D1
00001942  13C1 00A00019           3828m     MOVE.B D1, MC68230_PORT_C_DATA
00001948  1039 00A00011           3829m     MOVE.B MC68230_PORT_A_DATA, D0
0000194E  E148                    3830m     LSL.W #8, D0
00001950  1039 00A00013           3831m     MOVE.B MC68230_PORT_B_DATA, D0
00001956  0001 0020               3832m     ORI.B #MC68230_PORT_C_READ, D1
0000195A  13C1 00A00019           3833m     MOVE.B D1, MC68230_PORT_C_DATA
00001960  13FC 0038 00A00019      3834m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001968                          3835m     ENDM
00001968  30C0                    3836          MOVE.W D0,(A0)+
0000196A                          3837      ENDF
0000196A  5246                    3838s     ADD.W   #1,D6
0000196C                          3839s _20000015
0000196C  BC7C 00FF               3840s     CMP.W   #255,D6
00001970  6FAE                    3841s     BLE _20000014
00001972  2808                    3842      MOVE.L A0,D4
00001974  5283                    3843      ADD.L #1,D3
00001976  0485 000001F4           3844      SUB.L #500,D5
0000197C                          3845      
0000197C                          3846      WHILE D5 <GT> 0 DO
0000197C                          3847s _10000016
0000197C  BA78 0000               3848s     CMP.W   0,D5
00001980  6F00 02D4               3849s     BLE _10000017
00001984                          3850m         SEND_READ_COMMAND_AND_WAIT D3, D0, D1, D2
00001984                          3851mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001984                          3852mm LOOP_281
00001984                          3853mmm     READ_IDE_STATUS D0, D1
00001984                          3854mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001984  13FC 0000 00A00007      3855mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000198C  123C 0030               3856mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001990  0001 0007               3857mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001994  13C1 00A00019           3858mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000199A  0201 00DF               3859mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000199E  13C1 00A00019           3860mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000019A4  1039 00A00013           3861mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000019AA  0001 0020               3862mmmm     ORI.B #MC68230_PORT_C_READ, D1
000019AE  13C1 00A00019           3863mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000019B4  13FC 0038 00A00019      3864mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019BC                          3865mmmm     ENDM
000019BC                          3866mmm     ENDM
000019BC  0800 0007               3867mm     BTST #IDE_STATUS_BUSY, D0
000019C0  66C2                    3868mm     BNE LOOP_281
000019C2                          3869mm     ENDM
000019C2                          3870mm     SET_READ_ADDRESS D3, D0, D1, D2
000019C2                          3871mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
000019C2  13FC 00FF 00A00007      3872mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019CA  103C 0030               3873mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000019CE  0000 0002               3874mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
000019D2  13C0 00A00019           3875mmm     MOVE.B D0, MC68230_PORT_C_DATA
000019D8  0200 00EF               3876mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000019DC  13FC 0001 00A00013      3877mmm     MOVE.B #1, MC68230_PORT_B_DATA
000019E4  13C0 00A00019           3878mmm     MOVE.B D0, MC68230_PORT_C_DATA
000019EA  0000 0010               3879mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000019EE  13C0 00A00019           3880mmm     MOVE.B D0, MC68230_PORT_C_DATA
000019F4  13FC 0038 00A00019      3881mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019FC                          3882mmm     ENDM
000019FC  2203                    3883mm     MOVE.L D3,D1
000019FE                          3884mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
000019FE  13FC 00FF 00A00007      3885mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A06  103C 0030               3886mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001A0A  0000 0003               3887mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
00001A0E  13C0 00A00019           3888mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A14  0200 00EF               3889mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001A18  13C1 00A00013           3890mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001A1E  13C0 00A00019           3891mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A24  0000 0010               3892mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001A28  13C0 00A00019           3893mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A2E  13FC 0038 00A00019      3894mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A36                          3895mmm     ENDM
00001A36  E089                    3896mm     LSR.L #8, D1
00001A38                          3897mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001A38  13FC 00FF 00A00007      3898mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A40  103C 0030               3899mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001A44  0000 0004               3900mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
00001A48  13C0 00A00019           3901mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A4E  0200 00EF               3902mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001A52  13C1 00A00013           3903mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001A58  13C0 00A00019           3904mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A5E  0000 0010               3905mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001A62  13C0 00A00019           3906mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A68  13FC 0038 00A00019      3907mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A70                          3908mmm     ENDM
00001A70  E089                    3909mm     LSR.L #8, D1
00001A72                          3910mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
00001A72  13FC 00FF 00A00007      3911mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A7A  103C 0030               3912mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001A7E  0000 0005               3913mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
00001A82  13C0 00A00019           3914mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A88  0200 00EF               3915mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001A8C  13C1 00A00013           3916mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001A92  13C0 00A00019           3917mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001A98  0000 0010               3918mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001A9C  13C0 00A00019           3919mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001AA2  13FC 0038 00A00019      3920mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AAA                          3921mmm     ENDM
00001AAA  E089                    3922mm     LSR.L #8, D1
00001AAC                          3923mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
00001AAC  13FC 0000 00A00007      3924mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001AB4  103C 0030               3925mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001AB8  0000 0006               3926mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001ABC  13C0 00A00019           3927mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001AC2  0200 00DF               3928mmm     ANDI.B #~MC68230_PORT_C_READ, D0
00001AC6  13C0 00A00019           3929mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001ACC  1439 00A00013           3930mmm     MOVE.B MC68230_PORT_B_DATA, D2
00001AD2  0000 0020               3931mmm     ORI.B #MC68230_PORT_C_READ, D0
00001AD6  13C0 00A00019           3932mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001ADC  13FC 0038 00A00019      3933mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AE4                          3934mmm     ENDM
00001AE4  0201 000F               3935mm     ANDI.B #$0F,D1
00001AE8  8401                    3936mm     OR.B D1,D2
00001AEA                          3937mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
00001AEA  13FC 00FF 00A00007      3938mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001AF2  103C 0030               3939mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001AF6  0000 0006               3940mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001AFA  13C0 00A00019           3941mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001B00  0200 00EF               3942mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001B04  13C2 00A00013           3943mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001B0A  13C0 00A00019           3944mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001B10  0000 0010               3945mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001B14  13C0 00A00019           3946mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001B1A  13FC 0038 00A00019      3947mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B22                          3948mmm     ENDM
00001B22                          3949mm     ENDM
00001B22                          3950mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
00001B22                          3951mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
00001B22  13FC 00FF 00A00007      3952mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001B2A  103C 0030               3953mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001B2E  0000 0007               3954mmm     ORI.B #IDE_COMMAND_REGISTER, D0
00001B32  13C0 00A00019           3955mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001B38  0200 00EF               3956mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001B3C  13FC 0020 00A00013      3957mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001B44  13C0 00A00019           3958mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001B4A  0000 0010               3959mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001B4E  13C0 00A00019           3960mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001B54  13FC 0038 00A00019      3961mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B5C                          3962mmm     ENDM
00001B5C                          3963mm     ENDM
00001B5C                          3964mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001B5C                          3965mm LOOP_293
00001B5C                          3966mmm     READ_IDE_STATUS D0, D1
00001B5C                          3967mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001B5C  13FC 0000 00A00007      3968mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B64  123C 0030               3969mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001B68  0001 0007               3970mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001B6C  13C1 00A00019           3971mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001B72  0201 00DF               3972mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001B76  13C1 00A00019           3973mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001B7C  1039 00A00013           3974mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001B82  0001 0020               3975mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001B86  13C1 00A00019           3976mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001B8C  13FC 0038 00A00019      3977mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B94                          3978mmmm     ENDM
00001B94                          3979mmm     ENDM
00001B94  0800 0007               3980mm     BTST #IDE_STATUS_BUSY, D0
00001B98  66C2                    3981mm     BNE LOOP_293
00001B9A                          3982mm     ENDM
00001B9A                          3983mm     WAIT_DRIVE_DRQ D0, D1
00001B9A                          3984mm LOOP_296
00001B9A                          3985mmm     READ_IDE_STATUS D0, D1
00001B9A                          3986mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001B9A  13FC 0000 00A00007      3987mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BA2  123C 0030               3988mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001BA6  0001 0007               3989mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001BAA  13C1 00A00019           3990mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001BB0  0201 00DF               3991mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001BB4  13C1 00A00019           3992mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001BBA  1039 00A00013           3993mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001BC0  0001 0020               3994mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001BC4  13C1 00A00019           3995mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001BCA  13FC 0038 00A00019      3996mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001BD2                          3997mmmm     ENDM
00001BD2                          3998mmm     ENDM
00001BD2  0800 0003               3999mm     BTST #IDE_STATUS_DRQ, D0
00001BD6  67C2                    4000mm     BEQ LOOP_296
00001BD8                          4001mm     ENDM
00001BD8                          4002m     ENDM
00001BD8                          4003  
00001BD8                          4004m         PRINT_CHAR #'.', D1
00001BD8                          4005m WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001BD8                 TRUE     4006m     IFEQ DEBUG
00001BD8  1239 00C00003           4007m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001BDE  0801 0002               4008m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001BE2  67F4                    4009m         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001BE4  13FC 002E 00C00007      4010m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001BEC                          4011m     ENDC
00001BEC                          4012m 
00001BEC                 FALSE    4013m     IFNE DEBUG
00001BEC                          4014m     ENDC
00001BEC                          4015m 
00001BEC                          4016m     ENDM
00001BEC  2044                    4017          MOVE.L D4, A0
00001BEE                          4018          FOR D6 = #$0 TO #255 DO
00001BEE  3C3C 0000               4019s     MOVE.W  #$0,D6
00001BF2  6000 004E               4020s     BRA _20000017
00001BF6                          4021s _20000016
00001BF6                          4022m             READ_16 #IDE_DATA_REGISTER, D0,D1
00001BF6  13FC 0000 00A00007      4023m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BFE  13FC 0000 00A00005      4024m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001C06                          4025m     
00001C06  123C 0030               4026m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1    
00001C0A  0001 0000               4027m     ORI.B #IDE_DATA_REGISTER, D1
00001C0E  13C1 00A00019           4028m     MOVE.B D1, MC68230_PORT_C_DATA
00001C14  0201 00DF               4029m     ANDI.B #~MC68230_PORT_C_READ, D1
00001C18  13C1 00A00019           4030m     MOVE.B D1, MC68230_PORT_C_DATA
00001C1E  1039 00A00011           4031m     MOVE.B MC68230_PORT_A_DATA, D0
00001C24  E148                    4032m     LSL.W #8, D0
00001C26  1039 00A00013           4033m     MOVE.B MC68230_PORT_B_DATA, D0
00001C2C  0001 0020               4034m     ORI.B #MC68230_PORT_C_READ, D1
00001C30  13C1 00A00019           4035m     MOVE.B D1, MC68230_PORT_C_DATA
00001C36  13FC 0038 00A00019      4036m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001C3E                          4037m     ENDM
00001C3E  30C0                    4038              MOVE.W D0,(A0)+
00001C40                          4039          ENDF
00001C40  5246                    4040s     ADD.W   #1,D6
00001C42                          4041s _20000017
00001C42  BC7C 00FF               4042s     CMP.W   #255,D6
00001C46  6FAE                    4043s     BLE _20000016
00001C48  2808                    4044          MOVE.L A0, D4       
00001C4A  5283                    4045          ADD.L #1,D3
00001C4C  0485 00000200           4046          SUB.L #512,D5
00001C52                          4047      ENDW
00001C52  6000 FD28               4048s     BRA _10000016
00001C56                          4049s _10000017
00001C56                          4050  
00001C56                          4051m     PRINT_CRLF D3,A3
00001C56  47FA 03F2               4052m     LEA CRLF(PC),A3
00001C5A                          4053mm     PRINT_STR A3,D3
00001C5A                          4054mm LOOP_302
00001C5A  0C13 0000               4055mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001C5E  6700 0016               4056mm     BEQ EXIT_302
00001C62                          4057mmm     PRINT_CHAR (A3)+,D3
00001C62                          4058mmm WAIT_FOR_READY_303                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C62                 TRUE     4059mmm     IFEQ DEBUG
00001C62  1639 00C00003           4060mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001C68  0803 0002               4061mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001C6C  67F4                    4062mmm         BEQ WAIT_FOR_READY_303                      ; NO SPACE, CHECK AGAIN
00001C6E  13DB 00C00007           4063mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C74                          4064mmm     ENDC
00001C74                          4065mmm 
00001C74                 FALSE    4066mmm     IFNE DEBUG
00001C74                          4067mmm     ENDC
00001C74                          4068mmm 
00001C74                          4069mmm     ENDM
00001C74  60E4                    4070mm     BRA LOOP_302
00001C76                          4071mm EXIT_302
00001C76                          4072mm     ENDM
00001C76                          4073m     ENDM
00001C76                          4074      
00001C76  6000 E6CC               4075      BRA MAIN_LOOP
00001C7A                          4076  
00001C7A                          4077  HEX_DIGIT
00001C7A  E98F                    4078      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
00001C7C                          4079m     HEX2BIN D2,D2,A0
00001C7C  41FA 03A1               4080m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001C80  0402 0030               4081m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001C84  C4BC 000000FF           4082m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001C8A  1430 2000               4083m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001C8E                          4084m     ENDM
00001C8E  8E02                    4085      OR.B D2,D7  
00001C90  6000 E6D2               4086      BRA GET_INPUT
00001C94                          4087  
00001C94                          4088  ; exceptions    
00001C94                          4089  BUS_ERROR_HANDLER
00001C94                          4090  
00001C94  41FA 03D9               4091      LEA BUS_ERROR(PC),A0
00001C98                          4092m     PRINT_STR A0,D1
00001C98                          4093m LOOP_305
00001C98  0C10 0000               4094m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C9C  6700 0016               4095m     BEQ EXIT_305
00001CA0                          4096mm     PRINT_CHAR (A0)+,D1
00001CA0                          4097mm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CA0                 TRUE     4098mm     IFEQ DEBUG
00001CA0  1239 00C00003           4099mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CA6  0801 0002               4100mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CAA  67F4                    4101mm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
00001CAC  13D8 00C00007           4102mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CB2                          4103mm     ENDC
00001CB2                          4104mm 
00001CB2                 FALSE    4105mm     IFNE DEBUG
00001CB2                          4106mm     ENDC
00001CB2                          4107mm 
00001CB2                          4108mm     ENDM
00001CB2  60E4                    4109m     BRA LOOP_305
00001CB4                          4110m EXIT_305
00001CB4                          4111m     ENDM
00001CB4                          4112  
00001CB4  7000                    4113      MOVE.L #0,D0
00001CB6  3017                    4114      MOVE.W (SP),D0
00001CB8                          4115  
00001CB8  0800 0004               4116      BTST #4,D0
00001CBC  6700 0026               4117      BEQ WRITE
00001CC0                          4118      
00001CC0  41FA 03C2               4119      LEA READING(PC),A0
00001CC4                          4120m     PRINT_STR A0,D1
00001CC4                          4121m LOOP_307
00001CC4  0C10 0000               4122m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CC8  6700 0016               4123m     BEQ EXIT_307
00001CCC                          4124mm     PRINT_CHAR (A0)+,D1
00001CCC                          4125mm WAIT_FOR_READY_308                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CCC                 TRUE     4126mm     IFEQ DEBUG
00001CCC  1239 00C00003           4127mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CD2  0801 0002               4128mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CD6  67F4                    4129mm         BEQ WAIT_FOR_READY_308                      ; NO SPACE, CHECK AGAIN
00001CD8  13D8 00C00007           4130mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CDE                          4131mm     ENDC
00001CDE                          4132mm 
00001CDE                 FALSE    4133mm     IFNE DEBUG
00001CDE                          4134mm     ENDC
00001CDE                          4135mm 
00001CDE                          4136mm     ENDM
00001CDE  60E4                    4137m     BRA LOOP_307
00001CE0                          4138m EXIT_307
00001CE0                          4139m     ENDM
00001CE0                          4140  
00001CE0  6000 0022               4141      BRA CONTINUE    
00001CE4                          4142  WRITE
00001CE4  41FA 03A7               4143      LEA WRITING(PC),A0
00001CE8                          4144m     PRINT_STR A0,D1
00001CE8                          4145m LOOP_309
00001CE8  0C10 0000               4146m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CEC  6700 0016               4147m     BEQ EXIT_309
00001CF0                          4148mm     PRINT_CHAR (A0)+,D1
00001CF0                          4149mm WAIT_FOR_READY_310                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CF0                 TRUE     4150mm     IFEQ DEBUG
00001CF0  1239 00C00003           4151mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CF6  0801 0002               4152mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CFA  67F4                    4153mm         BEQ WAIT_FOR_READY_310                      ; NO SPACE, CHECK AGAIN
00001CFC  13D8 00C00007           4154mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D02                          4155mm     ENDC
00001D02                          4156mm 
00001D02                 FALSE    4157mm     IFNE DEBUG
00001D02                          4158mm     ENDC
00001D02                          4159mm 
00001D02                          4160mm     ENDM
00001D02  60E4                    4161m     BRA LOOP_309
00001D04                          4162m EXIT_309
00001D04                          4163m     ENDM
00001D04                          4164  
00001D04                          4165  CONTINUE
00001D04  222F 0002               4166      MOVE.L 2(SP),D1
00001D08                          4167m     PRINT_REG D1,D2,D3,D4,A0
00001D08  41FA 0346               4168m     LEA OX(PC),A0
00001D0C                          4169mm     PRINT_STR A0,D2
00001D0C                          4170mm LOOP_312
00001D0C  0C10 0000               4171mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D10  6700 0016               4172mm     BEQ EXIT_312
00001D14                          4173mmm     PRINT_CHAR (A0)+,D2
00001D14                          4174mmm WAIT_FOR_READY_313                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D14                 TRUE     4175mmm     IFEQ DEBUG
00001D14  1439 00C00003           4176mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D1A  0802 0002               4177mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D1E  67F4                    4178mmm         BEQ WAIT_FOR_READY_313                      ; NO SPACE, CHECK AGAIN
00001D20  13D8 00C00007           4179mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D26                          4180mmm     ENDC
00001D26                          4181mmm 
00001D26                 FALSE    4182mmm     IFNE DEBUG
00001D26                          4183mmm     ENDC
00001D26                          4184mmm 
00001D26                          4185mmm     ENDM
00001D26  60E4                    4186mm     BRA LOOP_312
00001D28                          4187mm EXIT_312
00001D28                          4188mm     ENDM
00001D28  7807                    4189m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001D2A                          4190m LOOP_311
00001D2A                          4191mm     BIN2HEX D1,D3,A0
00001D2A  41FA 02E3               4192mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001D2E  E999                    4193mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001D30  1601                    4194mm     MOVE.B D1,D3
00001D32  0283 0000000F           4195mm     ANDI.L #$F,D3
00001D38  1630 3000               4196mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D3C                          4197mm     ENDM
00001D3C                          4198mm     PRINT_CHAR D3,D2
00001D3C                          4199mm WAIT_FOR_READY_315                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D3C                 TRUE     4200mm     IFEQ DEBUG
00001D3C  1439 00C00003           4201mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D42  0802 0002               4202mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D46  67F4                    4203mm         BEQ WAIT_FOR_READY_315                      ; NO SPACE, CHECK AGAIN
00001D48  13C3 00C00007           4204mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D4E                          4205mm     ENDC
00001D4E                          4206mm 
00001D4E                 FALSE    4207mm     IFNE DEBUG
00001D4E                          4208mm     ENDC
00001D4E                          4209mm 
00001D4E                          4210mm     ENDM
00001D4E  57CC FFDA               4211m     DBEQ D4,LOOP_311
00001D52                          4212m     ENDM
00001D52                          4213  
00001D52  41FA 0342               4214      LEA FROM(PC),A0
00001D56                          4215m     PRINT_STR A0,D0
00001D56                          4216m LOOP_316
00001D56  0C10 0000               4217m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D5A  6700 0016               4218m     BEQ EXIT_316
00001D5E                          4219mm     PRINT_CHAR (A0)+,D0
00001D5E                          4220mm WAIT_FOR_READY_317                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D5E                 TRUE     4221mm     IFEQ DEBUG
00001D5E  1039 00C00003           4222mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D64  0800 0002               4223mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001D68  67F4                    4224mm         BEQ WAIT_FOR_READY_317                      ; NO SPACE, CHECK AGAIN
00001D6A  13D8 00C00007           4225mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D70                          4226mm     ENDC
00001D70                          4227mm 
00001D70                 FALSE    4228mm     IFNE DEBUG
00001D70                          4229mm     ENDC
00001D70                          4230mm 
00001D70                          4231mm     ENDM
00001D70  60E4                    4232m     BRA LOOP_316
00001D72                          4233m EXIT_316
00001D72                          4234m     ENDM
00001D72                          4235  
00001D72  222F 000A               4236      MOVE.L 10(SP),D1
00001D76                          4237m     PRINT_REG D1,D2,D3,D4,A0
00001D76  41FA 02D8               4238m     LEA OX(PC),A0
00001D7A                          4239mm     PRINT_STR A0,D2
00001D7A                          4240mm LOOP_319
00001D7A  0C10 0000               4241mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D7E  6700 0016               4242mm     BEQ EXIT_319
00001D82                          4243mmm     PRINT_CHAR (A0)+,D2
00001D82                          4244mmm WAIT_FOR_READY_320                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D82                 TRUE     4245mmm     IFEQ DEBUG
00001D82  1439 00C00003           4246mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D88  0802 0002               4247mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D8C  67F4                    4248mmm         BEQ WAIT_FOR_READY_320                      ; NO SPACE, CHECK AGAIN
00001D8E  13D8 00C00007           4249mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D94                          4250mmm     ENDC
00001D94                          4251mmm 
00001D94                 FALSE    4252mmm     IFNE DEBUG
00001D94                          4253mmm     ENDC
00001D94                          4254mmm 
00001D94                          4255mmm     ENDM
00001D94  60E4                    4256mm     BRA LOOP_319
00001D96                          4257mm EXIT_319
00001D96                          4258mm     ENDM
00001D96  7807                    4259m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001D98                          4260m LOOP_318
00001D98                          4261mm     BIN2HEX D1,D3,A0
00001D98  41FA 0275               4262mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001D9C  E999                    4263mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001D9E  1601                    4264mm     MOVE.B D1,D3
00001DA0  0283 0000000F           4265mm     ANDI.L #$F,D3
00001DA6  1630 3000               4266mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001DAA                          4267mm     ENDM
00001DAA                          4268mm     PRINT_CHAR D3,D2
00001DAA                          4269mm WAIT_FOR_READY_322                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DAA                 TRUE     4270mm     IFEQ DEBUG
00001DAA  1439 00C00003           4271mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001DB0  0802 0002               4272mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001DB4  67F4                    4273mm         BEQ WAIT_FOR_READY_322                      ; NO SPACE, CHECK AGAIN
00001DB6  13C3 00C00007           4274mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001DBC                          4275mm     ENDC
00001DBC                          4276mm 
00001DBC                 FALSE    4277mm     IFNE DEBUG
00001DBC                          4278mm     ENDC
00001DBC                          4279mm 
00001DBC                          4280mm     ENDM
00001DBC  57CC FFDA               4281m     DBEQ D4,LOOP_318
00001DC0                          4282m     ENDM
00001DC0                          4283m     PRINT_CRLF D0,A0
00001DC0  41FA 0288               4284m     LEA CRLF(PC),A0
00001DC4                          4285mm     PRINT_STR A0,D0
00001DC4                          4286mm LOOP_324
00001DC4  0C10 0000               4287mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001DC8  6700 0016               4288mm     BEQ EXIT_324
00001DCC                          4289mmm     PRINT_CHAR (A0)+,D0
00001DCC                          4290mmm WAIT_FOR_READY_325                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DCC                 TRUE     4291mmm     IFEQ DEBUG
00001DCC  1039 00C00003           4292mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001DD2  0800 0002               4293mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001DD6  67F4                    4294mmm         BEQ WAIT_FOR_READY_325                      ; NO SPACE, CHECK AGAIN
00001DD8  13D8 00C00007           4295mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DDE                          4296mmm     ENDC
00001DDE                          4297mmm 
00001DDE                 FALSE    4298mmm     IFNE DEBUG
00001DDE                          4299mmm     ENDC
00001DDE                          4300mmm 
00001DDE                          4301mmm     ENDM
00001DDE  60E4                    4302mm     BRA LOOP_324
00001DE0                          4303mm EXIT_324
00001DE0                          4304mm     ENDM
00001DE0                          4305m     ENDM
00001DE0                          4306      
00001DE0  207C 00000004           4307      MOVE.L #4,A0
00001DE6  4ED0                    4308      JMP (A0)
00001DE8                          4309          
00001DE8                          4310  ILLEGAL_HANDLER
00001DE8  13FC 0007 00E00001      4311      MOVE.B #7,DISPLAY   
00001DF0                          4312      
00001DF0  207C 00000004           4313      MOVE.L #4,A0
00001DF6  4ED0                    4314      JMP (A0)
00001DF8                          4315          
00001DF8                          4316  UNHANDLED_HANDLER
00001DF8  41FA 02A3               4317      LEA UNHANDLED(PC),A0
00001DFC  4EF9 00001E20           4318      JMP PRINTIT_RTE
00001E02                          4319      
00001E02                          4320  UNINITIALISED_HANDLER
00001E02  41FA 02AF               4321      LEA UNINITIALISED(PC),A0
00001E06  4EF9 00001E20           4322      JMP PRINTIT_RTE
00001E0C                          4323  
00001E0C                          4324  TICK_HANDLER
00001E0C  1039 00C0001F           4325      MOVE.B DUART_RESET_OPR,D0
00001E12  41FA 0254               4326      LEA TICK(PC),A0
00001E16  4EF9 00001E20           4327      JMP PRINTIT_RTE
00001E1C                          4328  
00001E1C                          4329  SPURIOUS_HANDLER
00001E1C  41FA 02B5               4330      LEA SPURIOUS(PC),A0
00001E20                          4331  PRINTIT_RTE
00001E20                          4332m     PRINT_STR A0,D1
00001E20                          4333m LOOP_326
00001E20  0C10 0000               4334m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001E24  6700 0016               4335m     BEQ EXIT_326
00001E28                          4336mm     PRINT_CHAR (A0)+,D1
00001E28                          4337mm WAIT_FOR_READY_327                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001E28                 TRUE     4338mm     IFEQ DEBUG
00001E28  1239 00C00003           4339mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001E2E  0801 0002               4340mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001E32  67F4                    4341mm         BEQ WAIT_FOR_READY_327                      ; NO SPACE, CHECK AGAIN
00001E34  13D8 00C00007           4342mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001E3A                          4343mm     ENDC
00001E3A                          4344mm 
00001E3A                 FALSE    4345mm     IFNE DEBUG
00001E3A                          4346mm     ENDC
00001E3A                          4347mm 
00001E3A                          4348mm     ENDM
00001E3A  60E4                    4349m     BRA LOOP_326
00001E3C                          4350m EXIT_326
00001E3C                          4351m     ENDM
00001E3C  4E73                    4352      RTE 
00001E3E                          4353      
00001E3E  FFFF FFFF               4354      SIMHALT                                             ; halt simulator
00001E42                          4355  
00001E42                          4356  ; strings
00001E42= 50 72 65 73 73 20 ...   4357  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001E55= 5B 3F 5D 09 09 09 ...   4358  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001E61= 5B 76 5D 09 09 09 ...   4359          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001E70= 78 78 78 78 78 78 ...   4360          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001E88= 78 78 78 78 78 78 ...   4361          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001EA8= 78 78 78 78 78 78 ...   4362          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001EC9= 78 78 78 78 78 78 ...   4363          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001EDA= 5B 7A 5D 09 09 09 ...   4364          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001EEC= 78 78 78 78 78 78 ...   4365          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001F10= 78 78 78 78 78 78 ...   4366          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001F32= 23 09 09 09 77 72 ...   4367          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001F4C= 5B 78 5D 09 09 09 ...   4368          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001F63= 5B 69 5D 09 09 09 ...   4369          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001F7C= 5B 6F 5D 09 09 09 ...   4370          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001F96= 5B 62 5D 09 09 09 ...   4371          DC.B '[b]',TAB,TAB,TAB,'boot from disk',CR,LF,NULL
00001FAD= 48 75 68 3F 0D 0A 00    4372  HUH  DC.B 'Huh?',CR,LF,NULL
00001FB4= 20 53 20 72 65 63 ...   4373  READ    DC.B ' S records read, start address = ',NULL
00001FD6= 57 3A 20 55 6E 6B ...   4374  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001FED= 21 20 43 53 20 66 ...   4375  CS_FAILURE  DC.B '! CS failure at ',NULL
00001FFE= 21 20 52 41 4D 20 ...   4376  RAM_ERROR   DC.B '! RAM error at: ',NULL
0000200F= 30 31 32 33 34 35 ...   4377  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000201F= 00 01 02 03 04 05 ...   4378  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00002036= 4C 6F 61 64 69 6E ...   4379  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
0000204A= 0D 0A 00                4380  CRLF    DC.B CR,LF,NULL
0000204D= 3E 20 00                4381  PROMPT  DC.B '> ',NULL
00002050= 30 78 00                4382  ox      DC.B '0x',NULL
00002053= 20 2D 3E 20 00          4383  to      DC.B ' -> ',NULL
00002058= 20 66 6F 72 20 00       4384  for     DC.B ' for ',NULL
0000205E= 53 50 3A 20 00          4385  STACK_POINTER DC.B 'SP: ',NULL
00002063= 53 52 3A 20 00          4386  STATUS_REGISTER DC.B 'SR: ',NULL
00002068= 74 69 63 6B 0D 0A 00    4387  TICK DC.B 'tick',CR,LF,NULL
0000206F= 2A 20 42 75 73 2F ...   4388  BUS_ERROR DC.B '* Bus/address error ',NULL
00002084= 72 65 61 64 69 6E ...   4389  READING DC.B 'reading ',NULL
0000208D= 77 72 69 74 69 6E ...   4390  WRITING DC.B 'writing ',NULL
00002096= 20 66 72 6F 6D 20 00    4391  FROM DC.B ' from ',NULL
0000209D= 2A 20 55 6E 68 61 ...   4392  UNHANDLED DC.B '* Unhandled interrupt',NULL
000020B3= 2A 20 20 55 6E 69 ...   4393  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
000020D3= 2A 20 53 70 75 72 ...   4394  SPURIOUS DC.B '* Spurious interrupt',NULL
000020E8= 4D 44 46 2D 6D 6F ...   4395  VERSION DC.B 'MDF-mon V1.135 (17/05/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00002106= 00                      4396  END     DC.B 0
00002107                          4397      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
B                   1432
BIN2HEX             0
BIN2HEX_LUT         200F
BUS_ERROR           206F
BUS_ERROR_HANDLER   1C94
CONTINUE            1D04
CONTINUE_113        B34
CONTINUE_54         610
CONTINUE_57         660
CONTINUE_61         6B6
CONTINUE_69         76A
CONTINUE_74         7DC
CONTINUE_79         858
CONTINUE_84         8D6
CONTINUE_89         95E
CONTINUE_94         9D0
CONTINUE_99         A42
CR                  D
CRLF                204A
CS_FAILURE          1FED
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C3E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 2106
EXIT_10             288
EXIT_104            AB4
EXIT_106            AD4
EXIT_110            B06
EXIT_118            B9C
EXIT_120            BC4
EXIT_123            BE4
EXIT_128            C2E
EXIT_131            C5E
EXIT_135            CA8
EXIT_138            CCA
EXIT_143            D14
EXIT_145            D90
EXIT_148            DB4
EXIT_15             2D2
EXIT_153            DFE
EXIT_160            E90
EXIT_163            F00
EXIT_165            F20
EXIT_168            F42
EXIT_17             2F2
EXIT_172            F8C
EXIT_175            FAE
EXIT_179            FF8
EXIT_182            1018
EXIT_187            1062
EXIT_20             312
EXIT_202            1184
EXIT_205            11E8
EXIT_208            1208
EXIT_212            1252
EXIT_215            1274
EXIT_22             364
EXIT_220            12BE
EXIT_224            1300
EXIT_227            1322
EXIT_232            136C
EXIT_234            138C
EXIT_237            13AE
EXIT_242            13F8
EXIT_28             3F0
EXIT_30             468
EXIT_302            1C76
EXIT_305            1CB4
EXIT_307            1CE0
EXIT_309            1D04
EXIT_312            1D28
EXIT_316            1D72
EXIT_319            1D96
EXIT_32             494
EXIT_324            1DE0
EXIT_326            1E3C
EXIT_35             4BE
EXIT_45             56C
EXIT_5              240
EXIT_52             5E2
EXIT_66             726
EXIT_7              260
FOR                 2058
FROM                2096
G                   D18
GET_INPUT           364
H                   46C
HASH                141C
HELP                1E55
HELPPROMPT          1E42
HEX2BIN             10B
HEX2BIN_LUT         201F
HEX_DIGIT           1C7A
HUH                 1FAD
I                   13FC
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1DE8
L                   E0E
LF                  A
LOADING             2036
LOOP_10             26C
LOOP_104            A98
LOOP_106            AB8
LOOP_110            AEA
LOOP_118            B80
LOOP_120            BA8
LOOP_122            BE6
LOOP_123            BC8
LOOP_128            C12
LOOP_130            C60
LOOP_131            C42
LOOP_135            C8C
LOOP_137            CCC
LOOP_138            CAE
LOOP_143            CF8
LOOP_145            D74
LOOP_147            DB6
LOOP_148            D98
LOOP_15             2B6
LOOP_153            DE2
LOOP_160            E74
LOOP_163            EE4
LOOP_165            F04
LOOP_167            F44
LOOP_168            F26
LOOP_17             2D6
LOOP_172            F70
LOOP_174            FB0
LOOP_175            F92
LOOP_179            FDC
LOOP_181            101A
LOOP_182            FFC
LOOP_187            1046
LOOP_20             2F6
LOOP_202            1168
LOOP_205            11CC
LOOP_207            120A
LOOP_208            11EC
LOOP_212            1236
LOOP_214            1276
LOOP_215            1258
LOOP_22             348
LOOP_220            12A2
LOOP_224            12E4
LOOP_226            1324
LOOP_227            1306
LOOP_232            1350
LOOP_234            1370
LOOP_236            13B0
LOOP_237            1392
LOOP_242            13DC
LOOP_246            1474
LOOP_251            14F0
LOOP_263            16C8
LOOP_266            1706
LOOP_28             3D4
LOOP_281            1984
LOOP_293            1B5C
LOOP_296            1B9A
LOOP_30             44C
LOOP_302            1C5A
LOOP_305            1C98
LOOP_307            1CC4
LOOP_309            1CE8
LOOP_311            1D2A
LOOP_312            1D0C
LOOP_316            1D56
LOOP_318            1D98
LOOP_319            1D7A
LOOP_32             478
LOOP_324            1DC4
LOOP_326            1E20
LOOP_34             4C0
LOOP_35             4A2
LOOP_45             550
LOOP_5              224
LOOP_52             5C6
LOOP_66             70A
LOOP_7              244
LOOP_9              28A
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NULL                0
O                   140C
OX                  2050
P                   1110
PRINTIT             478
PRINTIT_RTE         1E20
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              204D
PROTECT             A40
R                   498
RAM                 200000
RAM_ERROR           1FFE
READ                1FB4
READING             2084
READ_16             10D7
READ_32             1304
READ_8              D62
READ_CHAR           62D
READ_IDE_STATUS     1353
RESET               4
ROM                 0
S                   5EC
SEND_COMMAND        15CD
SEND_READ_COMMAND_AND_WAIT  15FC
SET_READ_ADDRESS    1473
SPURIOUS            20D3
SPURIOUS_HANDLER    1E1C
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       205E
START               104
STATUS_REGISTER     2063
TAB                 9
TICK                2068
TICK_HANDLER        1E0C
TO                  2053
UNHANDLED           209D
UNHANDLED_HANDLER   1DF8
UNINITIALISED       20B3
UNINITIALISED_HANDLER  1E02
UNPROTECT           979
UNREC               1FD6
USER                100
V                   474
VECS                8
VERSION             20E8
W                   570
WAIT_CHAR           4E9
WAIT_DRIVE_DRQ      1423
WAIT_DRIVE_NOT_BUSY  13D2
WAIT_DRIVE_READY    1380
WAIT_FOR_COMPLETE_189  1074
WAIT_FOR_COMPLETE_191  1096
WAIT_FOR_COMPLETE_192  10A8
WAIT_FOR_COMPLETE_194  10D6
WAIT_FOR_COMPLETE_195  10E8
WAIT_FOR_COMPLETE_222  12C0
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A5A
WAIT_FOR_READY_105  AA0
WAIT_FOR_READY_107  AC0
WAIT_FOR_READY_108  AD4
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AF2
WAIT_FOR_READY_113  B18
WAIT_FOR_READY_115  B4C
WAIT_FOR_READY_119  B88
WAIT_FOR_READY_121  BB0
WAIT_FOR_READY_124  BD0
WAIT_FOR_READY_126  BF8
WAIT_FOR_READY_129  C1A
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_132  C4A
WAIT_FOR_READY_134  C72
WAIT_FOR_READY_136  C94
WAIT_FOR_READY_139  CB6
WAIT_FOR_READY_141  CDE
WAIT_FOR_READY_144  D00
WAIT_FOR_READY_146  D7C
WAIT_FOR_READY_149  DA0
WAIT_FOR_READY_151  DC8
WAIT_FOR_READY_154  DEA
WAIT_FOR_READY_155  E1C
WAIT_FOR_READY_157  E36
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E7C
WAIT_FOR_READY_164  EEC
WAIT_FOR_READY_166  F0C
WAIT_FOR_READY_169  F2E
WAIT_FOR_READY_171  F56
WAIT_FOR_READY_173  F78
WAIT_FOR_READY_176  F9A
WAIT_FOR_READY_178  FC2
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  FE4
WAIT_FOR_READY_183  1004
WAIT_FOR_READY_185  102C
WAIT_FOR_READY_188  104E
WAIT_FOR_READY_197  111C
WAIT_FOR_READY_199  1136
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_203  1170
WAIT_FOR_READY_206  11D4
WAIT_FOR_READY_209  11F4
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  121C
WAIT_FOR_READY_213  123E
WAIT_FOR_READY_216  1260
WAIT_FOR_READY_218  1288
WAIT_FOR_READY_221  12AA
WAIT_FOR_READY_225  12EC
WAIT_FOR_READY_228  130E
WAIT_FOR_READY_23   350
WAIT_FOR_READY_230  1336
WAIT_FOR_READY_233  1358
WAIT_FOR_READY_235  1378
WAIT_FOR_READY_238  139A
WAIT_FOR_READY_24   364
WAIT_FOR_READY_240  13C2
WAIT_FOR_READY_243  13E4
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_278  1902
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_299  1BD8
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_303  1C62
WAIT_FOR_READY_306  1CA0
WAIT_FOR_READY_308  1CCC
WAIT_FOR_READY_31   454
WAIT_FOR_READY_310  1CF0
WAIT_FOR_READY_313  1D14
WAIT_FOR_READY_315  1D3C
WAIT_FOR_READY_317  1D5E
WAIT_FOR_READY_320  1D82
WAIT_FOR_READY_322  1DAA
WAIT_FOR_READY_325  1DCC
WAIT_FOR_READY_327  1E28
WAIT_FOR_READY_33   480
WAIT_FOR_READY_36   4AA
WAIT_FOR_READY_38   4D2
WAIT_FOR_READY_39   4E8
WAIT_FOR_READY_40   4FE
WAIT_FOR_READY_41   512
WAIT_FOR_READY_42   526
WAIT_FOR_READY_43   53A
WAIT_FOR_READY_46   558
WAIT_FOR_READY_47   57A
WAIT_FOR_READY_49   594
WAIT_FOR_READY_53   5CE
WAIT_FOR_READY_54   5F4
WAIT_FOR_READY_56   62E
WAIT_FOR_READY_57   644
WAIT_FOR_READY_59   678
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   69A
WAIT_FOR_READY_63   6CE
WAIT_FOR_READY_67   712
WAIT_FOR_READY_69   74E
WAIT_FOR_READY_71   782
WAIT_FOR_READY_74   7C0
WAIT_FOR_READY_76   7F4
WAIT_FOR_READY_79   83C
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_81   870
WAIT_FOR_READY_84   8BA
WAIT_FOR_READY_86   8EE
WAIT_FOR_READY_89   942
WAIT_FOR_READY_91   976
WAIT_FOR_READY_94   9B4
WAIT_FOR_READY_96   9E8
WAIT_FOR_READY_99   A26
WAIT_FOR_SRECORD    5F4
WRITE               1CE4
WRITE_8             F1B
WRITING             208D
X                   12E0
Z                   D1E
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           72E
_00000004           B0A
_00000005           73C
_00000006           92A
_00000007           8A0
_00000008           B0A
_00000009           A94
_0000000A           B0A
_0000000B           C32
_0000000C           C3E
_0000000D           DFE
_0000000E           107E
_0000000F           10A0
_00000010           10B2
_00000011           10E0
_00000012           10F2
_00000013           12CA
_10000000           690
_10000001           6F8
_10000002           744
_10000003           7AC
_10000004           7B6
_10000005           81E
_10000006           832
_10000007           89A
_10000008           8A4
_10000009           924
_1000000A           8B0
_1000000B           918
_1000000C           938
_1000000D           9A0
_1000000E           9AA
_1000000F           A12
_10000010           A1C
_10000011           A84
_10000012           B0E
_10000013           B76
_10000014           1062
_10000015           1084
_10000016           197C
_10000017           1C56
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           578
_20000005           5BC
_20000006           D30
_20000007           D40
_20000008           D5A
_20000009           E00
_2000000A           E1A
_2000000B           E5E
_2000000C           ED6
_2000000D           EDA
_2000000E           10BA
_2000000F           10F4
_20000010           111A
_20000011           115E
_20000012           11BE
_20000013           11C2
_20000014           1920
_20000015           196C
_20000016           1BF6
_20000017           1C42
