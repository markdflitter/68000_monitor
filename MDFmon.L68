00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/04/2021 12:44:12

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00C00000                 22  DUART_BASE          EQU $C00000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000006                 31  DUART_CTUR_         EQU $6
00000000  =00000007                 32  DUART_CTLR_         EQU $7
00000000  =00000008                 33  DUART_MRB_          EQU $8
00000000  =00000009                 34  DUART_CSRB_         EQU $9
00000000  =00000009                 35  DUART_SRB_          EQU $9
00000000  =0000000A                 36  DUART_CRB_          EQU $A
00000000  =0000000B                 37  DUART_TXB_          EQU $B
00000000  =0000000B                 38  DUART_RXB_          EQU $B
00000000  =0000000C                 39  DUART_IVR_          EQU $C
00000000  =0000000D                 40  DUART_OPCR_         EQU $D
00000000  =0000000E                 41  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 42  DUART_RESET_OPR_    EQU $F
00000000                            43  
00000000  =00C00001                 44  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 45  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 46  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 47  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 48  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 49  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            50  
00000000  =00C00011                 51  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 52  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 53  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 54  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 55  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 56  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            57  
00000000  =00C00009                 58  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 59  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 60  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 61  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 62  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 63  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 64  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 65  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            66  
00000000  =00E00000                 67  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 68  DISPLAY_            EQU $0
00000000  =00E00001                 69  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            77      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78      MOVE.B \1,\2
00000000                            79      ANDI.L #$F,\2
00000000                            80      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            81      ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            88      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            89      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            90      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           100          BTST #2,\2                                  ; check for space to send
00000000                           101          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           102          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           103      ENDC
00000000                           104  
00000000                           105      IFNE DEBUG
00000000                           106          MOVE.B \1,D1
00000000                           107          MOVE.L #6,D0   
00000000                           108          TRAP #15                                    ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll, /2 = working address register
00000000                           115  PRINT_CRLF MACRO
00000000                           116      LEA CRLF(PC),\2
00000000                           117      PRINT_STR \2,\1
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      BRA LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           133  PRINT_REG MACRO
00000000                           134      LEA ox(PC),\5
00000000                           135      PRINT_STR \5,\2
00000000                           136      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142  
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           148      IFEQ DEBUG
00000000                           149          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           150          BTST #0,\2                                  ; check for character
00000000                           151          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           152      ENDC
00000000                           153  
00000000                           154      READ_CHAR \1
00000000                           155  
00000000                           156      IFEQ DEBUG
00000000                           157          PRINT_CHAR \1,\2                            ; echo it back
00000000                           158      ENDC
00000000                           159      ENDM
00000000                           160  
00000000                           161  ; read a char from the serial port - assumes that there is one!
00000000                           162  ; \ 1= data register for read char
00000000                           163  ; will stamp on D0 and D1 in debug mode
00000000                           164  READ_CHAR MACRO
00000000                           165      IFEQ DEBUG
00000000                           166          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           167      ENDC
00000000                           168      IFNE DEBUG
00000000                           169          MOVE.L #5,D0    
00000000                           170          TRAP #15                                    ; read from keyboard in simulator
00000000                           171          MOVE.L D1,\1
00000000                           172      ENDC
00000000                           173  
00000000                           174      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           175      BEQ START
00000000                           176      ENDM
00000000                           177  
00000000                           178  
00000000                           179  ; read data from the download serial port
00000000                           180  ; \ 1= data register for read char
00000000                           181  DOWNLOAD MACRO
00000000                           182  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           183  
00000000                           184      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           185      BTST #0,\1                                      ; check for character
00000000                           186      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           187  
00000000                           188      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           189  CONTINUE\@
00000000                           190      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           193      
00000000                           194      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           195      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           196  
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; unprotect the EEPROM
00000000                           200  UNPROTECT MACRO
00000000                           201      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           202      NOP
00000000                           203      MOVE.W #$5555,$1554
00000000                           204      NOP
00000000                           205      MOVE.W #$8080,$2AAA
00000000                           206      NOP
00000000                           207      MOVE.W #$AAAA,$2AAA
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$2020,$2AAA
00000000                           212      ENDM
00000000                           213      
00000000                           214  ; protect the EEPROM
00000000                           215  PROTECT MACRO
00000000                           216      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           217      MOVE.W #$5555,$1554
00000000                           218      MOVE.W #$A0A0,$2AAA
00000000                           219      ENDM
00000000                           220  
00000000                           221  
00000000                           222  ; read two hex digits from the download serial port and convert to a byte
00000000                           223  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           224  DOWNLOAD_BYTE MACRO
00000000                           225      MOVE.B #2,\4
00000000                           226      WHILE.B \4 <GT> 0 DO
00000000                           227          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           228          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           229          PRINT_CHAR \2,\3
00000000                           230          HEX2BIN \2,\2,\6
00000000                           231          OR.B \2,\1
00000000                           232          SUB.B #1,\4
00000000                           233      ENDW
00000000                           234  
00000000                           235      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           236      MOVE.B \1,\2
00000000                           237      ADD.L \1,\5
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; write word to EEPROM
00000000                           242  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           243  PROGRAM MACRO
00000000                           244    MOVE.W \1,\2                                      ; write the data
00000000                           245  
00000000                           246  WAIT_FOR_COMPLETE\@
00000000                           247          MOVE.W \2,\3
00000000                           248  
00000000                           249          IF.W \3 <NE> \1 THEN
00000000                           250              BRA WAIT_FOR_COMPLETE\@
00000000                           251          ENDI
00000000                           252          ENDM
00000000                           253          
00000000                           254  ; program vector to EEPROM
00000000                           255  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           256  PROGRAM_VECTOR MACRO
00000000                           257      ADD.L #2,\2
00000000                           258      PROGRAM \1, (\2), \3                                ; write it
00000000                           259      LSR.L #8,\1
00000000                           260      LSR.L #8,\1
00000000                           261      SUB.L #2,\2
00000000                           262      PROGRAM \1, (\2), \3
00000000                           263      ENDM
00000000                           264  
00000000                           265  
00000000                           266  ; register catalogue
00000000                           267  ; D0 - used for simulator I/O
00000000                           268  ; D1 - used for simulator I/O
00000000                           269  ; D2 - read character
00000000                           270  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           271  ; D6 - working register used in R/W
00000000                           272  ; D7 - address accumulator, reset by download
00000000                           273  ; A0 - address of string to print 
00000000                           274  
00000000                           275  ; start vector
00000000= 002E0000                 276  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 277  RESET   DC.L START                              ; RESET
00000008= 000014A6                 278  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 000014A6                 279          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 000015FA                 280          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 0000160A                 281          DC.L UNHANDLED_HANDLER
00000018= 0000160A                 282          DC.L UNHANDLED_HANDLER
0000001C= 0000160A                 283          DC.L UNHANDLED_HANDLER
00000020= 0000160A                 284          DC.L UNHANDLED_HANDLER
00000024= 0000160A                 285          DC.L UNHANDLED_HANDLER
00000028= 0000160A                 286          DC.L UNHANDLED_HANDLER
0000002C= 0000160A                 287          DC.L UNHANDLED_HANDLER
00000030= 0000160A                 288          DC.L UNHANDLED_HANDLER
00000034= 0000160A                 289          DC.L UNHANDLED_HANDLER
00000038= 0000160A                 290          DC.L UNHANDLED_HANDLER
0000003C= 0000160A                 291          DC.L UNHANDLED_HANDLER
00000040= 0000160A                 292          DC.L UNHANDLED_HANDLER
00000044= 0000160A                 293          DC.L UNHANDLED_HANDLER
00000048= 0000160A                 294          DC.L UNHANDLED_HANDLER
0000004C= 0000160A                 295          DC.L UNHANDLED_HANDLER
00000050= 0000160A                 296          DC.L UNHANDLED_HANDLER
00000054= 0000160A                 297          DC.L UNHANDLED_HANDLER
00000058= 0000160A                 298          DC.L UNHANDLED_HANDLER
0000005C= 0000160A                 299          DC.L UNHANDLED_HANDLER
00000060= 0000164E                 300          DC.L SPURIOUS_HANDLER
00000064= 0000160A                 301          DC.L UNHANDLED_HANDLER
00000068= 0000160A                 302          DC.L UNHANDLED_HANDLER
0000006C= 0000160A                 303          DC.L UNHANDLED_HANDLER
00000070= 0000160A                 304          DC.L UNHANDLED_HANDLER
00000074= 0000160A                 305          DC.L UNHANDLED_HANDLER
00000078= 0000160A                 306          DC.L UNHANDLED_HANDLER
0000007C= 0000160A                 307          DC.L UNHANDLED_HANDLER
00000080= 0000160A                 308          DC.L UNHANDLED_HANDLER
00000084= 0000160A                 309          DC.L UNHANDLED_HANDLER
00000088= 0000160A                 310          DC.L UNHANDLED_HANDLER
0000008C= 0000160A                 311          DC.L UNHANDLED_HANDLER
00000090= 0000160A                 312          DC.L UNHANDLED_HANDLER
00000094= 0000160A                 313          DC.L UNHANDLED_HANDLER
00000098= 0000160A                 314          DC.L UNHANDLED_HANDLER
0000009C= 0000160A                 315          DC.L UNHANDLED_HANDLER
000000A0= 0000160A                 316          DC.L UNHANDLED_HANDLER
000000A4= 0000160A                 317          DC.L UNHANDLED_HANDLER
000000A8= 0000160A                 318          DC.L UNHANDLED_HANDLER
000000AC= 0000160A                 319          DC.L UNHANDLED_HANDLER
000000B0= 0000160A                 320          DC.L UNHANDLED_HANDLER
000000B4= 0000160A                 321          DC.L UNHANDLED_HANDLER
000000B8= 0000160A                 322          DC.L UNHANDLED_HANDLER
000000BC= 0000160A                 323          DC.L UNHANDLED_HANDLER
000000C0= 0000160A                 324          DC.L UNHANDLED_HANDLER
000000C4= 0000160A                 325          DC.L UNHANDLED_HANDLER
000000C8= 0000160A                 326          DC.L UNHANDLED_HANDLER
000000CC= 0000160A                 327          DC.L UNHANDLED_HANDLER
000000D0= 0000160A                 328          DC.L UNHANDLED_HANDLER
000000D4= 0000160A                 329          DC.L UNHANDLED_HANDLER
000000D8= 0000160A                 330          DC.L UNHANDLED_HANDLER 
000000DC= 0000160A                 331          DC.L UNHANDLED_HANDLER
000000E0= 0000160A                 332          DC.L UNHANDLED_HANDLER
000000E4= 0000160A                 333          DC.L UNHANDLED_HANDLER 
000000E8= 0000160A                 334          DC.L UNHANDLED_HANDLER 
000000EC= 0000160A                 335          DC.L UNHANDLED_HANDLER
000000F0= 0000160A                 336          DC.L UNHANDLED_HANDLER 
000000F4= 0000160A                 337          DC.L UNHANDLED_HANDLER 
000000F8= 0000160A                 338          DC.L UNHANDLED_HANDLER 
000000FC= 0000160A                 339          DC.L UNHANDLED_HANDLER
00000100= 00001670                 340  USER    DC.L TICK_HANDLER
00000104                           341      ; start of program  
00000104                           342  START
00000104  2E7C 002E0000            343      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       344      MOVE.B #0,DISPLAY
00000112                           345  
00000112  7000                     346      MOVE.L #0,D0
00000114  1039 00C00019            347      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           348  
0000011A                           349  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       350      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       351      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           352      
0000012A                           353      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                354s     MOVE.W  #$50,D1
0000012E  6000 000E                355s     BRA _20000001
00000132                           356s _20000000
00000132  13C1 00C00005            357          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     358          NOP
0000013A                           359      ENDF
0000013A  0441 0010                360s     SUB.W   #$10,D1
0000013E                           361s _20000001
0000013E  B27C 0010                362s     CMP.W   #$10,D1
00000142  6CEE                     363s     BGE _20000000
00000144                           364  
00000144                           365      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                366s     MOVE.W  #$50,D1
00000148  6000 000E                367s     BRA _20000003
0000014C                           368s _20000002
0000014C  13C1 00C00015            369          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     370          NOP
00000154                           371      ENDF
00000154  0441 0010                372s     SUB.W   #$10,D1
00000158                           373s _20000003
00000158  B27C 0010                374s     CMP.W   #$10,D1
0000015C  6CEE                     375s     BGE _20000002
0000015E                           376      
0000015E                           377  ;initialise UART
0000015E  13FC 0000 00C0000B       378      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       379      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       380      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       381      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       382      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           383  
00000186                           384  ; channel A
00000186  13FC 0013 00C00001       385      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       386      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       387      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       388      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           389  
000001A6                           390  ; channel B
000001A6  13FC 0013 00C00011       391      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       392      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       393      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       394      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       395      MOVE.B #64,DUART_IVR
000001CE                           396  
000001CE                           397m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           398m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      399m     IFEQ DEBUG
000001CE  1239 00C00003            400m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                401m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     402m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       403m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           404m     ENDC
000001E2                           405m 
000001E2                 FALSE     406m     IFNE DEBUG
000001E2                           407m     ENDC
000001E2                           408m 
000001E2                           409m     ENDM
000001E2                           410m     PRINT_CHAR #0,D1
000001E2                           411m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      412m     IFEQ DEBUG
000001E2  1239 00C00003            413m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                414m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     415m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       416m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           417m     ENDC
000001F6                           418m 
000001F6                 FALSE     419m     IFNE DEBUG
000001F6                           420m     ENDC
000001F6                           421m 
000001F6                           422m     ENDM
000001F6                           423m     PRINT_CHAR #0,D1
000001F6                           424m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      425m     IFEQ DEBUG
000001F6  1239 00C00003            426m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                427m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     428m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       429m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           430m     ENDC
0000020A                           431m 
0000020A                 FALSE     432m     IFNE DEBUG
0000020A                           433m     ENDC
0000020A                           434m 
0000020A                           435m     ENDM
0000020A                           436      
0000020A                           437      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                438s     CMP.W   #$0F,D0
0000020E  6600 0008                439s     BNE _00000000
00000212  1039 00C00005            440          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           441      ENDI
00000218                           442s _00000000
00000218                           443  
00000218  13FC 0001 00E00001       444      MOVE.B #1,DISPLAY
00000220                           445      
00000220                           446m     PRINT_CRLF D1,A0
00000220  41FA 1686                447m     LEA CRLF(PC),A0
00000224                           448mm     PRINT_STR A0,D1
00000224                           449mm LOOP_5
00000224  0C10 0000                450mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                451mm     BEQ EXIT_5
0000022C                           452mmm     PRINT_CHAR (A0)+,D1
0000022C                           453mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      454mmm     IFEQ DEBUG
0000022C  1239 00C00003            455mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                456mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     457mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            458mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           459mmm     ENDC
0000023E                           460mmm 
0000023E                 FALSE     461mmm     IFNE DEBUG
0000023E                           462mmm     ENDC
0000023E                           463mmm 
0000023E                           464mmm     ENDM
0000023E  60E4                     465mm     BRA LOOP_5
00000240                           466mm EXIT_5
00000240                           467mm     ENDM
00000240                           468m     ENDM
00000240  41FA 1704                469      LEA VERSION(PC),A0
00000244                           470m     PRINT_STR A0,D3
00000244                           471m LOOP_7
00000244  0C10 0000                472m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                473m     BEQ EXIT_7
0000024C                           474mm     PRINT_CHAR (A0)+,D3
0000024C                           475mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      476mm     IFEQ DEBUG
0000024C  1639 00C00003            477mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                478mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     479mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            480mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           481mm     ENDC
0000025E                           482mm 
0000025E                 FALSE     483mm     IFNE DEBUG
0000025E                           484mm     ENDC
0000025E                           485mm 
0000025E                           486mm     ENDM
0000025E  60E4                     487m     BRA LOOP_7
00000260                           488m EXIT_7
00000260                           489m     ENDM
00000260                           490  
00000260  41F9 00001964            491      LEA END,A0
00000266  2008                     492      MOVE.L A0,D0
00000268                           493m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1644                494m     LEA OX(PC),A0
0000026C                           495mm     PRINT_STR A0,D1
0000026C                           496mm LOOP_10
0000026C  0C10 0000                497mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                498mm     BEQ EXIT_10
00000274                           499mmm     PRINT_CHAR (A0)+,D1
00000274                           500mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      501mmm     IFEQ DEBUG
00000274  1239 00C00003            502mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                503mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     504mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            505mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           506mmm     ENDC
00000286                           507mmm 
00000286                 FALSE     508mmm     IFNE DEBUG
00000286                           509mmm     ENDC
00000286                           510mmm 
00000286                           511mmm     ENDM
00000286  60E4                     512mm     BRA LOOP_10
00000288                           513mm EXIT_10
00000288                           514mm     ENDM
00000288  7607                     515m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           516m LOOP_9
0000028A                           517mm     BIN2HEX D0,D2,A0
0000028A  41FA 15E1                518mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     519mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     520mm     MOVE.B D0,D2
00000292  0282 0000000F            521mm     ANDI.L #$F,D2
00000298  1430 2000                522mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           523mm     ENDM
0000029C                           524mm     PRINT_CHAR D2,D1
0000029C                           525mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      526mm     IFEQ DEBUG
0000029C  1239 00C00003            527mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                528mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     529mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            530mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           531mm     ENDC
000002AE                           532mm 
000002AE                 FALSE     533mm     IFNE DEBUG
000002AE                           534mm     ENDC
000002AE                           535mm 
000002AE                           536mm     ENDM
000002AE  57CB FFDA                537m     DBEQ D3,LOOP_9
000002B2                           538m     ENDM
000002B2                           539m     PRINT_CRLF D1,A0
000002B2  41FA 15F4                540m     LEA CRLF(PC),A0
000002B6                           541mm     PRINT_STR A0,D1
000002B6                           542mm LOOP_15
000002B6  0C10 0000                543mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                544mm     BEQ EXIT_15
000002BE                           545mmm     PRINT_CHAR (A0)+,D1
000002BE                           546mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      547mmm     IFEQ DEBUG
000002BE  1239 00C00003            548mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                549mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     550mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            551mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           552mmm     ENDC
000002D0                           553mmm 
000002D0                 FALSE     554mmm     IFNE DEBUG
000002D0                           555mmm     ENDC
000002D0                           556mmm 
000002D0                           557mmm     ENDM
000002D0  60E4                     558mm     BRA LOOP_15
000002D2                           559mm EXIT_15
000002D2                           560mm     ENDM
000002D2                           561m     ENDM
000002D2                           562  
000002D2  41FA 13C4                563      LEA HELPPROMPT(PC),A0
000002D6                           564m     PRINT_STR A0,D3
000002D6                           565m LOOP_17
000002D6  0C10 0000                566m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                567m     BEQ EXIT_17
000002DE                           568mm     PRINT_CHAR (A0)+,D3
000002DE                           569mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      570mm     IFEQ DEBUG
000002DE  1639 00C00003            571mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                572mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     573mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            574mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           575mm     ENDC
000002F0                           576mm 
000002F0                 FALSE     577mm     IFNE DEBUG
000002F0                           578mm     ENDC
000002F0                           579mm 
000002F0                           580mm     ENDM
000002F0  60E4                     581m     BRA LOOP_17
000002F2                           582m EXIT_17
000002F2                           583m     ENDM
000002F2                           584  
000002F2                           585m     PRINT_CRLF D3,A0
000002F2  41FA 15B4                586m     LEA CRLF(PC),A0
000002F6                           587mm     PRINT_STR A0,D3
000002F6                           588mm LOOP_20
000002F6  0C10 0000                589mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                590mm     BEQ EXIT_20
000002FE                           591mmm     PRINT_CHAR (A0)+,D3
000002FE                           592mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      593mmm     IFEQ DEBUG
000002FE  1639 00C00003            594mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                595mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     596mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            597mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           598mmm     ENDC
00000310                           599mmm 
00000310                 FALSE     600mmm     IFNE DEBUG
00000310                           601mmm     ENDC
00000310                           602mmm 
00000310                           603mmm     ENDM
00000310  60E4                     604mm     BRA LOOP_20
00000312                           605mm EXIT_20
00000312                           606mm     ENDM
00000312                           607m     ENDM
00000312                           608  
00000312  7E00                     609      MOVE.L #0,D7                                    ; address accumulator
00000314                           610  
00000314  13FC 0002 00E00001       611      MOVE.B #2,DISPLAY
0000031C                           612      
0000031C                           613  MAIN_LOOP
0000031C  41FA 158D                614      LEA PROMPT(PC),A0
00000320                           615m     PRINT_STR A0,D3
00000320                           616m LOOP_22
00000320  0C10 0000                617m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000324  6700 0016                618m     BEQ EXIT_22
00000328                           619mm     PRINT_CHAR (A0)+,D3
00000328                           620mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      621mm     IFEQ DEBUG
00000328  1639 00C00003            622mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0002                623mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000332  67F4                     624mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000334  13D8 00C00007            625mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000033A                           626mm     ENDC
0000033A                           627mm 
0000033A                 FALSE     628mm     IFNE DEBUG
0000033A                           629mm     ENDC
0000033A                           630mm 
0000033A                           631mm     ENDM
0000033A  60E4                     632m     BRA LOOP_22
0000033C                           633m EXIT_22
0000033C                           634m     ENDM
0000033C                           635  
0000033C                           636  GET_INPUT
0000033C                           637m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000033C                           638m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033C                 TRUE      639m     IFEQ DEBUG
0000033C  1639 00C00003            640m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000342  0803 0000                641m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000346  67F4                     642m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000348                           643m     ENDC
00000348                           644m 
00000348                           645mm     READ_CHAR D2
00000348                 TRUE      646mm     IFEQ DEBUG
00000348  1439 00C00007            647mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000034E                           648mm     ENDC
0000034E                 FALSE     649mm     IFNE DEBUG
0000034E                           650mm     ENDC
0000034E                           651mm 
0000034E  B43C 001B                652mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000352  6700 FDB0                653mm     BEQ START
00000356                           654mm     ENDM
00000356                           655m 
00000356                 TRUE      656m     IFEQ DEBUG
00000356                           657mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000356                           658mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000356                 TRUE      659mm     IFEQ DEBUG
00000356  1639 00C00003            660mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000035C  0803 0002                661mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000360  67F4                     662mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000362  13C2 00C00007            663mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000368                           664mm     ENDC
00000368                           665mm 
00000368                 FALSE     666mm     IFNE DEBUG
00000368                           667mm     ENDC
00000368                           668mm 
00000368                           669mm     ENDM
00000368                           670m     ENDC
00000368                           671m     ENDM
00000368                           672  
00000368                           673      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000368  B43C 0030                674s     CMP.B   #'0',D2
0000036C  6D00 000E                675s     BLT _00000001
00000370  B43C 0039                676s     CMP.B   #'9',D2
00000374  6E00 0006                677s     BGT _00000001
00000378  6000 110E                678          BRA HEX_DIGIT
0000037C                           679      ENDI
0000037C                           680s _00000001
0000037C                           681      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000037C  B43C 0041                682s     CMP.B   #'A',D2
00000380  6D00 000E                683s     BLT _00000002
00000384  B43C 0046                684s     CMP.B   #'F',D2
00000388  6E00 0006                685s     BGT _00000002
0000038C  6000 10FA                686          BRA HEX_DIGIT
00000390                           687      ENDI
00000390                           688s _00000002
00000390                           689  
00000390  B43C 0077                690      CMP.B #'w',D2
00000394  6700 01B2                691      BEQ W
00000398                           692  
00000398  B43C 006C                693      CMP.B #'l',D2
0000039C  6700 0A48                694      BEQ L 
000003A0                           695  
000003A0  B43C 0070                696      CMP.B #'p',D2
000003A4  6700 0D28                697      BEQ P
000003A8                           698  
000003A8  B43C 006D                699      CMP.B #'m',D2
000003AC  6700 0EF0                700      BEQ M
000003B0                           701  
000003B0                           702m     PRINT_CRLF D3,A0
000003B0  41FA 14F6                703m     LEA CRLF(PC),A0
000003B4                           704mm     PRINT_STR A0,D3
000003B4                           705mm LOOP_28
000003B4  0C10 0000                706mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003B8  6700 0016                707mm     BEQ EXIT_28
000003BC                           708mmm     PRINT_CHAR (A0)+,D3
000003BC                           709mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003BC                 TRUE      710mmm     IFEQ DEBUG
000003BC  1639 00C00003            711mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003C2  0803 0002                712mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003C6  67F4                     713mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003C8  13D8 00C00007            714mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003CE                           715mmm     ENDC
000003CE                           716mmm 
000003CE                 FALSE     717mmm     IFNE DEBUG
000003CE                           718mmm     ENDC
000003CE                           719mmm 
000003CE                           720mmm     ENDM
000003CE  60E4                     721mm     BRA LOOP_28
000003D0                           722mm EXIT_28
000003D0                           723mm     ENDM
000003D0                           724m     ENDM
000003D0                           725   
000003D0  B43C 003F                726      CMP.B #'?',D2
000003D4  6700 006E                727      BEQ H
000003D8                           728   
000003D8  B43C 0076                729      CMP.B #'v',D2
000003DC  6700 006E                730      BEQ V
000003E0                           731      
000003E0  B43C 0072                732      CMP.B #'r',D2
000003E4  6700 008A                733      BEQ R
000003E8                           734  
000003E8  B43C 0073                735      CMP.B #'s',D2
000003EC  6700 01D6                736      BEQ S
000003F0                           737  
000003F0  B43C 0067                738      CMP.B #'g',D2
000003F4  6700 08FA                739      BEQ G   
000003F8                           740  
000003F8  B43C 007A                741      CMP.B #'z',D2
000003FC  6700 08F8                742      BEQ Z   
00000400                           743  
00000400  B43C 0078                744      CMP.B #'x',D2
00000404  6700 0F30                745      BEQ X
00000408                           746  
00000408  B43C 0069                747      CMP.B #'i',D2
0000040C  6700 1044                748      BEQ I
00000410                           749  
00000410  B43C 006F                750      CMP.B #'o',D2
00000414  6700 104C                751      BEQ O
00000418                           752  
00000418  B43C 0023                753      CMP.B #'#',D2
0000041C  6700 1054                754      BEQ HASH
00000420                           755  
00000420  41FA 13E9                756      LEA HUH(PC),A0
00000424                           757m     PRINT_STR A0,D3
00000424                           758m LOOP_30
00000424  0C10 0000                759m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000428  6700 0016                760m     BEQ EXIT_30
0000042C                           761mm     PRINT_CHAR (A0)+,D3
0000042C                           762mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042C                 TRUE      763mm     IFEQ DEBUG
0000042C  1639 00C00003            764mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000432  0803 0002                765mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000436  67F4                     766mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000438  13D8 00C00007            767mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000043E                           768mm     ENDC
0000043E                           769mm 
0000043E                 FALSE     770mm     IFNE DEBUG
0000043E                           771mm     ENDC
0000043E                           772mm 
0000043E                           773mm     ENDM
0000043E  60E4                     774m     BRA LOOP_30
00000440                           775m EXIT_30
00000440                           776m     ENDM
00000440                           777  
00000440  6000 FEDA                778      BRA MAIN_LOOP
00000444                           779  
00000444                           780  ; commands
00000444                           781  H
00000444  41FA 1265                782      LEA HELP(PC),A0
00000448  6000 0006                783      BRA PRINTSTR
0000044C                           784  
0000044C                           785  V
0000044C  41FA 14F8                786      LEA VERSION(PC),A0
00000450                           787  PRINTSTR
00000450                           788m     PRINT_STR A0,D3    
00000450                           789m LOOP_32
00000450  0C10 0000                790m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000454  6700 0016                791m     BEQ EXIT_32
00000458                           792mm     PRINT_CHAR (A0)+,D3
00000458                           793mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000458                 TRUE      794mm     IFEQ DEBUG
00000458  1639 00C00003            795mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000045E  0803 0002                796mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000462  67F4                     797mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000464  13D8 00C00007            798mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000046A                           799mm     ENDC
0000046A                           800mm 
0000046A                 FALSE     801mm     IFNE DEBUG
0000046A                           802mm     ENDC
0000046A                           803mm 
0000046A                           804mm     ENDM
0000046A  60E4                     805m     BRA LOOP_32
0000046C                           806m EXIT_32
0000046C                           807m     ENDM
0000046C  6000 FEAE                808      BRA MAIN_LOOP
00000470                           809  
00000470                           810  R
00000470  2047                     811      MOVE.L D7,A0                                    ; address accumulator -> address register
00000472  7E00                     812      MOVE.L #0,D7                                    ;clear the now used address accumulator
00000474  2410                     813      MOVE.L (A0),D2                                  ; read the memory and print it
00000476                           814m     PRINT_REG D2,D3,D4,D5,A0
00000476  41FA 1436                815m     LEA OX(PC),A0
0000047A                           816mm     PRINT_STR A0,D3
0000047A                           817mm LOOP_35
0000047A  0C10 0000                818mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000047E  6700 0016                819mm     BEQ EXIT_35
00000482                           820mmm     PRINT_CHAR (A0)+,D3
00000482                           821mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000482                 TRUE      822mmm     IFEQ DEBUG
00000482  1639 00C00003            823mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000488  0803 0002                824mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000048C  67F4                     825mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
0000048E  13D8 00C00007            826mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000494                           827mmm     ENDC
00000494                           828mmm 
00000494                 FALSE     829mmm     IFNE DEBUG
00000494                           830mmm     ENDC
00000494                           831mmm 
00000494                           832mmm     ENDM
00000494  60E4                     833mm     BRA LOOP_35
00000496                           834mm EXIT_35
00000496                           835mm     ENDM
00000496  7A07                     836m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000498                           837m LOOP_34
00000498                           838mm     BIN2HEX D2,D4,A0
00000498  41FA 13D3                839mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000049C  E99A                     840mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000049E  1802                     841mm     MOVE.B D2,D4
000004A0  0284 0000000F            842mm     ANDI.L #$F,D4
000004A6  1830 4000                843mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004AA                           844mm     ENDM
000004AA                           845mm     PRINT_CHAR D4,D3
000004AA                           846mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AA                 TRUE      847mm     IFEQ DEBUG
000004AA  1639 00C00003            848mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004B0  0803 0002                849mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004B4  67F4                     850mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004B6  13C4 00C00007            851mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004BC                           852mm     ENDC
000004BC                           853mm 
000004BC                 FALSE     854mm     IFNE DEBUG
000004BC                           855mm     ENDC
000004BC                           856mm 
000004BC                           857mm     ENDM
000004BC  57CD FFDA                858m     DBEQ D5,LOOP_34
000004C0                           859m     ENDM
000004C0                           860      
000004C0                           861m     PRINT_CHAR #32,D3
000004C0                           862m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C0                 TRUE      863m     IFEQ DEBUG
000004C0  1639 00C00003            864m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004C6  0803 0002                865m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004CA  67F4                     866m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004CC  13FC 0020 00C00007       867m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004D4                           868m     ENDC
000004D4                           869m 
000004D4                 FALSE     870m     IFNE DEBUG
000004D4                           871m     ENDC
000004D4                           872m 
000004D4                           873m     ENDM
000004D4                           874  
000004D4  E19A                     875      ROL.L #8,D2
000004D6                           876m     PRINT_CHAR D2,D3
000004D6                           877m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D6                 TRUE      878m     IFEQ DEBUG
000004D6  1639 00C00003            879m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004DC  0803 0002                880m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004E0  67F4                     881m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000004E2  13C2 00C00007            882m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E8                           883m     ENDC
000004E8                           884m 
000004E8                 FALSE     885m     IFNE DEBUG
000004E8                           886m     ENDC
000004E8                           887m 
000004E8                           888m     ENDM
000004E8  E19A                     889      ROL.L #8,D2
000004EA                           890m     PRINT_CHAR D2,D3
000004EA                           891m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004EA                 TRUE      892m     IFEQ DEBUG
000004EA  1639 00C00003            893m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004F0  0803 0002                894m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F4  67F4                     895m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000004F6  13C2 00C00007            896m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004FC                           897m     ENDC
000004FC                           898m 
000004FC                 FALSE     899m     IFNE DEBUG
000004FC                           900m     ENDC
000004FC                           901m 
000004FC                           902m     ENDM
000004FC  E19A                     903      ROL.L #8,D2
000004FE                           904m     PRINT_CHAR D2,D3
000004FE                           905m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FE                 TRUE      906m     IFEQ DEBUG
000004FE  1639 00C00003            907m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000504  0803 0002                908m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000508  67F4                     909m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
0000050A  13C2 00C00007            910m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000510                           911m     ENDC
00000510                           912m 
00000510                 FALSE     913m     IFNE DEBUG
00000510                           914m     ENDC
00000510                           915m 
00000510                           916m     ENDM
00000510  E19A                     917      ROL.L #8,D2
00000512                           918m     PRINT_CHAR D2,D3
00000512                           919m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE      920m     IFEQ DEBUG
00000512  1639 00C00003            921m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002                922m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                     923m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007            924m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                           925m     ENDC
00000524                           926m 
00000524                 FALSE     927m     IFNE DEBUG
00000524                           928m     ENDC
00000524                           929m 
00000524                           930m     ENDM
00000524                           931  
00000524                           932m     PRINT_CRLF D3,A0
00000524  41FA 1382                933m     LEA CRLF(PC),A0
00000528                           934mm     PRINT_STR A0,D3
00000528                           935mm LOOP_45
00000528  0C10 0000                936mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000052C  6700 0016                937mm     BEQ EXIT_45
00000530                           938mmm     PRINT_CHAR (A0)+,D3
00000530                           939mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000530                 TRUE      940mmm     IFEQ DEBUG
00000530  1639 00C00003            941mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000536  0803 0002                942mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000053A  67F4                     943mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
0000053C  13D8 00C00007            944mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000542                           945mmm     ENDC
00000542                           946mmm 
00000542                 FALSE     947mmm     IFNE DEBUG
00000542                           948mmm     ENDC
00000542                           949mmm 
00000542                           950mmm     ENDM
00000542  60E4                     951mm     BRA LOOP_45
00000544                           952mm EXIT_45
00000544                           953mm     ENDM
00000544                           954m     ENDM
00000544                           955      
00000544  6000 FDD6                956      BRA MAIN_LOOP
00000548                           957  
00000548                           958  W
00000548                           959      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000548  3C3C 0000                960s     MOVE.W  #0,D6
0000054C  6000 0046                961s     BRA _20000005
00000550                           962s _20000004
00000550  E98D                     963          LSL.L #4,D5                                     ; make what we have so far more significant
00000552                           964m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000552                           965m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000552                 TRUE      966m     IFEQ DEBUG
00000552  1639 00C00003            967m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000558  0803 0000                968m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000055C  67F4                     969m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
0000055E                           970m     ENDC
0000055E                           971m 
0000055E                           972mm     READ_CHAR D2
0000055E                 TRUE      973mm     IFEQ DEBUG
0000055E  1439 00C00007            974mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000564                           975mm     ENDC
00000564                 FALSE     976mm     IFNE DEBUG
00000564                           977mm     ENDC
00000564                           978mm 
00000564  B43C 001B                979mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000568  6700 FB9A                980mm     BEQ START
0000056C                           981mm     ENDM
0000056C                           982m 
0000056C                 TRUE      983m     IFEQ DEBUG
0000056C                           984mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000056C                           985mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE      986mm     IFEQ DEBUG
0000056C  1639 00C00003            987mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000572  0803 0002                988mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                     989mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
00000578  13C2 00C00007            990mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000057E                           991mm     ENDC
0000057E                           992mm 
0000057E                 FALSE     993mm     IFNE DEBUG
0000057E                           994mm     ENDC
0000057E                           995mm 
0000057E                           996mm     ENDM
0000057E                           997m     ENDC
0000057E                           998m     ENDM
0000057E                           999m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
0000057E  41FA 12FD               1000m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000582  0402 0030               1001m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000586  C4BC 000000FF           1002m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000058C  1430 2000               1003m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000590                          1004m     ENDM
00000590  8A02                    1005          OR.B D2,D5
00000592                          1006      ENDF
00000592  5246                    1007s     ADD.W   #1,D6
00000594                          1008s _20000005
00000594  BC7C 0007               1009s     CMP.W   #7,D6
00000598  6FB6                    1010s     BLE _20000004
0000059A                          1011  
0000059A                          1012m     PRINT_CRLF D3,A0
0000059A  41FA 130C               1013m     LEA CRLF(PC),A0
0000059E                          1014mm     PRINT_STR A0,D3
0000059E                          1015mm LOOP_52
0000059E  0C10 0000               1016mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005A2  6700 0016               1017mm     BEQ EXIT_52
000005A6                          1018mmm     PRINT_CHAR (A0)+,D3
000005A6                          1019mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A6                 TRUE     1020mmm     IFEQ DEBUG
000005A6  1639 00C00003           1021mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005AC  0803 0002               1022mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B0  67F4                    1023mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005B2  13D8 00C00007           1024mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005B8                          1025mmm     ENDC
000005B8                          1026mmm 
000005B8                 FALSE    1027mmm     IFNE DEBUG
000005B8                          1028mmm     ENDC
000005B8                          1029mmm 
000005B8                          1030mmm     ENDM
000005B8  60E4                    1031mm     BRA LOOP_52
000005BA                          1032mm EXIT_52
000005BA                          1033mm     ENDM
000005BA                          1034m     ENDM
000005BA                          1035  
000005BA  2047                    1036      MOVE.L D7,A0                                    ; address accumulator -> address register
000005BC  7E00                    1037      MOVE.L #0,D7                                    ; clear the now used address accumulator
000005BE                          1038  
000005BE  2085                    1039      MOVE.L D5,(A0)                                  ; write the data
000005C0                          1040  
000005C0  6000 FD5A               1041      BRA MAIN_LOOP
000005C4                          1042  
000005C4                          1043  ; register map for S
000005C4                          1044  ; A0 - start address
000005C4                          1045  ; A1 - offset
000005C4                          1046  ; A2 - next address to write
000005C4                          1047  ; A3 - next location (jmp)
000005C4                          1048  ; A4 - Working Address Register
000005C4                          1049  ; D0 - record count
000005C4                          1050  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005C4                          1051  ; D2 - checksum
000005C4                          1052  ; D3 - data byte count
000005C4                          1053  ; D4 - read address, moved into A2
000005C4                          1054  ; D5 - temp
000005C4                          1055  ; D6 - temp
000005C4                          1056  ; D7 - temp
000005C4                          1057  S
000005C4  2078 0000               1058      MOVE.L 0,A0                                     ; start address -> A0
000005C8  2247                    1059      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005CA                          1060      
000005CA  7000                    1061      MOVE.L #0,D0                                    ; count of records read -> D0
000005CC                          1062          
000005CC                          1063  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005CC                          1064m     DOWNLOAD D1
000005CC                          1065m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CC                          1066m 
000005CC  1239 00C00003           1067m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005D2  0801 0000               1068m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005D6  6700 0010               1069m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
000005DA                          1070m 
000005DA                          1071mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000005DA                 TRUE     1072mm     IFEQ DEBUG
000005DA  1239 00C00007           1073mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000005E0                          1074mm     ENDC
000005E0                 FALSE    1075mm     IFNE DEBUG
000005E0                          1076mm     ENDC
000005E0                          1077mm 
000005E0  B23C 001B               1078mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000005E4  6700 FB1E               1079mm     BEQ START
000005E8                          1080mm     ENDM
000005E8                          1081m CONTINUE_54
000005E8  1239 00C00013           1082m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000005EE  0801 0000               1083m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005F2  67D8                    1084m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000005F4                          1085m     
000005F4  1239 00C00017           1086m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000005FA  13C1 00E00001           1087m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000600                          1088m 
00000600                          1089m     ENDM
00000600  B23C 0053               1090      CMP.B #'S',D1                                   ; found S?
00000604  66C6                    1091      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000606                          1092      
00000606                          1093m     PRINT_CHAR #'S',D5                              ; print the S
00000606                          1094m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000606                 TRUE     1095m     IFEQ DEBUG
00000606  1A39 00C00003           1096m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000060C  0805 0002               1097m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000610  67F4                    1098m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
00000612  13FC 0053 00C00007      1099m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000061A                          1100m     ENDC
0000061A                          1101m 
0000061A                 FALSE    1102m     IFNE DEBUG
0000061A                          1103m     ENDC
0000061A                          1104m 
0000061A                          1105m     ENDM
0000061A  5280                    1106      ADD.L #1,D0                                     ; read another S record, increment count
0000061C                          1107      
0000061C                          1108m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000061C                          1109m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000061C                          1110m 
0000061C  1239 00C00003           1111m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000622  0801 0000               1112m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000626  6700 0010               1113m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
0000062A                          1114m 
0000062A                          1115mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000062A                 TRUE     1116mm     IFEQ DEBUG
0000062A  1239 00C00007           1117mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000630                          1118mm     ENDC
00000630                 FALSE    1119mm     IFNE DEBUG
00000630                          1120mm     ENDC
00000630                          1121mm 
00000630  B23C 001B               1122mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000634  6700 FACE               1123mm     BEQ START
00000638                          1124mm     ENDM
00000638                          1125m CONTINUE_57
00000638  1239 00C00013           1126m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000063E  0801 0000               1127m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000642  67D8                    1128m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
00000644                          1129m     
00000644  1239 00C00017           1130m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000064A  13C1 00E00001           1131m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000650                          1132m 
00000650                          1133m     ENDM
00000650                          1134m     PRINT_CHAR D1,D5
00000650                          1135m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000650                 TRUE     1136m     IFEQ DEBUG
00000650  1A39 00C00003           1137m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000656  0805 0002               1138m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000065A  67F4                    1139m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
0000065C  13C1 00C00007           1140m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000662                          1141m     ENDC
00000662                          1142m 
00000662                 FALSE    1143m     IFNE DEBUG
00000662                          1144m     ENDC
00000662                          1145m 
00000662                          1146m     ENDM
00000662                          1147  
00000662  7400                    1148      MOVE.L #0,D2                                    ; clear the checksum
00000664                          1149  
00000664                          1150m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000664  1E3C 0002               1151m     MOVE.B #2,D7
00000668                          1152m     WHILE.B D7 <GT> 0 DO
00000668                          1153ms _10000000
00000668  BE38 0000               1154ms     CMP.B   0,D7
0000066C  6F00 0062               1155ms     BLE _10000001
00000670  E98B                    1156m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000672                          1157mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000672                          1158mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000672                          1159mm 
00000672  1A39 00C00003           1160mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000678  0805 0000               1161mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000067C  6700 0010               1162mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000680                          1163mm 
00000680                          1164mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000680                 TRUE     1165mmm     IFEQ DEBUG
00000680  1A39 00C00007           1166mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000686                          1167mmm     ENDC
00000686                 FALSE    1168mmm     IFNE DEBUG
00000686                          1169mmm     ENDC
00000686                          1170mmm 
00000686  BA3C 001B               1171mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000068A  6700 FA78               1172mmm     BEQ START
0000068E                          1173mmm     ENDM
0000068E                          1174mm CONTINUE_61
0000068E  1A39 00C00013           1175mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000694  0805 0000               1176mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000698  67D8                    1177mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
0000069A                          1178mm     
0000069A  1A39 00C00017           1179mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006A0  13C5 00E00001           1180mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006A6                          1181mm 
000006A6                          1182mm     ENDM
000006A6                          1183mm         PRINT_CHAR D5,D6
000006A6                          1184mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006A6                 TRUE     1185mm     IFEQ DEBUG
000006A6  1C39 00C00003           1186mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006AC  0806 0002               1187mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006B0  67F4                    1188mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006B2  13C5 00C00007           1189mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006B8                          1190mm     ENDC
000006B8                          1191mm 
000006B8                 FALSE    1192mm     IFNE DEBUG
000006B8                          1193mm     ENDC
000006B8                          1194mm 
000006B8                          1195mm     ENDM
000006B8                          1196mm         HEX2BIN D5,D5,A4
000006B8  49FA 11C3               1197mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006BC  0405 0030               1198mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006C0  CABC 000000FF           1199mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006C6  1A34 5000               1200mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006CA                          1201mm     ENDM
000006CA  8605                    1202m         OR.B D5,D3
000006CC  5307                    1203m         SUB.B #1,D7
000006CE                          1204m     ENDW
000006CE  6098                    1205ms     BRA _10000000
000006D0                          1206ms _10000001
000006D0                          1207m 
000006D0  7A00                    1208m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006D2  1A03                    1209m     MOVE.B D3,D5
000006D4  D483                    1210m     ADD.L D3,D2
000006D6                          1211m 
000006D6                          1212m     ENDM
000006D6                          1213  
000006D6                          1214      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006D6  B23C 0030               1215s     CMP.B   #'0',D1
000006DA  6600 002A               1216s     BNE.L   _00000003
000006DE                          1217m         PRINT_CRLF D5,A4
000006DE  49FA 11C8               1218m     LEA CRLF(PC),A4
000006E2                          1219mm     PRINT_STR A4,D5
000006E2                          1220mm LOOP_66
000006E2  0C14 0000               1221mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000006E6  6700 0016               1222mm     BEQ EXIT_66
000006EA                          1223mmm     PRINT_CHAR (A4)+,D5
000006EA                          1224mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006EA                 TRUE     1225mmm     IFEQ DEBUG
000006EA  1A39 00C00003           1226mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000006F0  0805 0002               1227mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000006F4  67F4                    1228mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000006F6  13DC 00C00007           1229mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000006FC                          1230mmm     ENDC
000006FC                          1231mmm 
000006FC                 FALSE    1232mmm     IFNE DEBUG
000006FC                          1233mmm     ENDC
000006FC                          1234mmm 
000006FC                          1235mmm     ENDM
000006FC  60E4                    1236mm     BRA LOOP_66
000006FE                          1237mm EXIT_66
000006FE                          1238mm     ENDM
000006FE                          1239m     ENDM
000006FE  6000 FECC               1240          BRA WAIT_FOR_SRECORD
00000702                          1241      ELSE
00000702  6000 03DE               1242s     BRA _00000004
00000706                          1243s _00000003
00000706                          1244          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
00000706  B23C 0031               1245s     CMP.B   #'1',D1
0000070A  6708                    1246s     BEQ.S   _00000005
0000070C  B23C 0032               1247s     CMP.B   #'2',D1
00000710  6600 01F0               1248s     BNE.L   _00000006
00000714                          1249s _00000005
00000714  5783                    1250              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000716                          1251  
00000716  7800                    1252              MOVE.L #0,D4                            ; read two bytes of address
00000718                          1253m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000718  1E3C 0002               1254m     MOVE.B #2,D7
0000071C                          1255m     WHILE.B D7 <GT> 0 DO
0000071C                          1256ms _10000002
0000071C  BE38 0000               1257ms     CMP.B   0,D7
00000720  6F00 0062               1258ms     BLE _10000003
00000724  E98C                    1259m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000726                          1260mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000726                          1261mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000726                          1262mm 
00000726  1A39 00C00003           1263mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000072C  0805 0000               1264mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000730  6700 0010               1265mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
00000734                          1266mm 
00000734                          1267mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000734                 TRUE     1268mmm     IFEQ DEBUG
00000734  1A39 00C00007           1269mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000073A                          1270mmm     ENDC
0000073A                 FALSE    1271mmm     IFNE DEBUG
0000073A                          1272mmm     ENDC
0000073A                          1273mmm 
0000073A  BA3C 001B               1274mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000073E  6700 F9C4               1275mmm     BEQ START
00000742                          1276mmm     ENDM
00000742                          1277mm CONTINUE_69
00000742  1A39 00C00013           1278mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000748  0805 0000               1279mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000074C  67D8                    1280mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
0000074E                          1281mm     
0000074E  1A39 00C00017           1282mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000754  13C5 00E00001           1283mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000075A                          1284mm 
0000075A                          1285mm     ENDM
0000075A                          1286mm         PRINT_CHAR D5,D6
0000075A                          1287mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000075A                 TRUE     1288mm     IFEQ DEBUG
0000075A  1C39 00C00003           1289mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000760  0806 0002               1290mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000764  67F4                    1291mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
00000766  13C5 00C00007           1292mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000076C                          1293mm     ENDC
0000076C                          1294mm 
0000076C                 FALSE    1295mm     IFNE DEBUG
0000076C                          1296mm     ENDC
0000076C                          1297mm 
0000076C                          1298mm     ENDM
0000076C                          1299mm         HEX2BIN D5,D5,A4
0000076C  49FA 110F               1300mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000770  0405 0030               1301mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000774  CABC 000000FF           1302mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000077A  1A34 5000               1303mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000077E                          1304mm     ENDM
0000077E  8805                    1305m         OR.B D5,D4
00000780  5307                    1306m         SUB.B #1,D7
00000782                          1307m     ENDW
00000782  6098                    1308ms     BRA _10000002
00000784                          1309ms _10000003
00000784                          1310m 
00000784  7A00                    1311m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000786  1A04                    1312m     MOVE.B D4,D5
00000788  D484                    1313m     ADD.L D4,D2
0000078A                          1314m 
0000078A                          1315m     ENDM
0000078A                          1316m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
0000078A  1E3C 0002               1317m     MOVE.B #2,D7
0000078E                          1318m     WHILE.B D7 <GT> 0 DO
0000078E                          1319ms _10000004
0000078E  BE38 0000               1320ms     CMP.B   0,D7
00000792  6F00 0062               1321ms     BLE _10000005
00000796  E98C                    1322m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000798                          1323mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000798                          1324mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                          1325mm 
00000798  1A39 00C00003           1326mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000079E  0805 0000               1327mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007A2  6700 0010               1328mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
000007A6                          1329mm 
000007A6                          1330mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007A6                 TRUE     1331mmm     IFEQ DEBUG
000007A6  1A39 00C00007           1332mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007AC                          1333mmm     ENDC
000007AC                 FALSE    1334mmm     IFNE DEBUG
000007AC                          1335mmm     ENDC
000007AC                          1336mmm 
000007AC  BA3C 001B               1337mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007B0  6700 F952               1338mmm     BEQ START
000007B4                          1339mmm     ENDM
000007B4                          1340mm CONTINUE_74
000007B4  1A39 00C00013           1341mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007BA  0805 0000               1342mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007BE  67D8                    1343mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000007C0                          1344mm     
000007C0  1A39 00C00017           1345mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007C6  13C5 00E00001           1346mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007CC                          1347mm 
000007CC                          1348mm     ENDM
000007CC                          1349mm         PRINT_CHAR D5,D6
000007CC                          1350mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007CC                 TRUE     1351mm     IFEQ DEBUG
000007CC  1C39 00C00003           1352mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007D2  0806 0002               1353mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007D6  67F4                    1354mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
000007D8  13C5 00C00007           1355mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007DE                          1356mm     ENDC
000007DE                          1357mm 
000007DE                 FALSE    1358mm     IFNE DEBUG
000007DE                          1359mm     ENDC
000007DE                          1360mm 
000007DE                          1361mm     ENDM
000007DE                          1362mm         HEX2BIN D5,D5,A4
000007DE  49FA 109D               1363mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007E2  0405 0030               1364mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007E6  CABC 000000FF           1365mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007EC  1A34 5000               1366mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007F0                          1367mm     ENDM
000007F0  8805                    1368m         OR.B D5,D4
000007F2  5307                    1369m         SUB.B #1,D7
000007F4                          1370m     ENDW
000007F4  6098                    1371ms     BRA _10000004
000007F6                          1372ms _10000005
000007F6                          1373m 
000007F6  7A00                    1374m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007F8  1A04                    1375m     MOVE.B D4,D5
000007FA  D484                    1376m     ADD.L D4,D2
000007FC                          1377m 
000007FC                          1378m     ENDM
000007FC                          1379  
000007FC                          1380              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000007FC  B23C 0032               1381s     CMP.B   #'2',D1
00000800  6600 0076               1382s     BNE.L   _00000007
00000804  5383                    1383                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000806                          1384m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000806  1E3C 0002               1385m     MOVE.B #2,D7
0000080A                          1386m     WHILE.B D7 <GT> 0 DO
0000080A                          1387ms _10000006
0000080A  BE38 0000               1388ms     CMP.B   0,D7
0000080E  6F00 0062               1389ms     BLE _10000007
00000812  E98C                    1390m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000814                          1391mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000814                          1392mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000814                          1393mm 
00000814  1A39 00C00003           1394mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000081A  0805 0000               1395mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000081E  6700 0010               1396mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
00000822                          1397mm 
00000822                          1398mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000822                 TRUE     1399mmm     IFEQ DEBUG
00000822  1A39 00C00007           1400mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000828                          1401mmm     ENDC
00000828                 FALSE    1402mmm     IFNE DEBUG
00000828                          1403mmm     ENDC
00000828                          1404mmm 
00000828  BA3C 001B               1405mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000082C  6700 F8D6               1406mmm     BEQ START
00000830                          1407mmm     ENDM
00000830                          1408mm CONTINUE_79
00000830  1A39 00C00013           1409mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000836  0805 0000               1410mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000083A  67D8                    1411mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
0000083C                          1412mm     
0000083C  1A39 00C00017           1413mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000842  13C5 00E00001           1414mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000848                          1415mm 
00000848                          1416mm     ENDM
00000848                          1417mm         PRINT_CHAR D5,D6
00000848                          1418mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000848                 TRUE     1419mm     IFEQ DEBUG
00000848  1C39 00C00003           1420mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000084E  0806 0002               1421mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000852  67F4                    1422mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
00000854  13C5 00C00007           1423mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000085A                          1424mm     ENDC
0000085A                          1425mm 
0000085A                 FALSE    1426mm     IFNE DEBUG
0000085A                          1427mm     ENDC
0000085A                          1428mm 
0000085A                          1429mm     ENDM
0000085A                          1430mm         HEX2BIN D5,D5,A4
0000085A  49FA 1021               1431mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000085E  0405 0030               1432mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000862  CABC 000000FF           1433mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000868  1A34 5000               1434mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000086C                          1435mm     ENDM
0000086C  8805                    1436m         OR.B D5,D4
0000086E  5307                    1437m         SUB.B #1,D7
00000870                          1438m     ENDW
00000870  6098                    1439ms     BRA _10000006
00000872                          1440ms _10000007
00000872                          1441m 
00000872  7A00                    1442m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000874  1A04                    1443m     MOVE.B D4,D5
00000876  D484                    1444m     ADD.L D4,D2
00000878                          1445m 
00000878                          1446m     ENDM
00000878                          1447              ENDI
00000878                          1448s _00000007
00000878                          1449  
00000878  2444                    1450              MOVE.L D4,A2                            ; put the address in an address register
0000087A  D5C9                    1451              ADD.L A1,A2                             ; add in the offset
0000087C                          1452  
0000087C                          1453              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000087C                          1454s _10000008
0000087C  B63C 0000               1455s     CMP.B   #0,D3
00000880  6F00 007A               1456s     BLE _10000009
00000884                          1457m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000884  1E3C 0002               1458m     MOVE.B #2,D7
00000888                          1459m     WHILE.B D7 <GT> 0 DO
00000888                          1460ms _1000000A
00000888  BE38 0000               1461ms     CMP.B   0,D7
0000088C  6F00 0062               1462ms     BLE _1000000B
00000890  E989                    1463m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000892                          1464mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000892                          1465mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000892                          1466mm 
00000892  1A39 00C00003           1467mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000898  0805 0000               1468mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000089C  6700 0010               1469mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
000008A0                          1470mm 
000008A0                          1471mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008A0                 TRUE     1472mmm     IFEQ DEBUG
000008A0  1A39 00C00007           1473mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008A6                          1474mmm     ENDC
000008A6                 FALSE    1475mmm     IFNE DEBUG
000008A6                          1476mmm     ENDC
000008A6                          1477mmm 
000008A6  BA3C 001B               1478mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008AA  6700 F858               1479mmm     BEQ START
000008AE                          1480mmm     ENDM
000008AE                          1481mm CONTINUE_84
000008AE  1A39 00C00013           1482mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008B4  0805 0000               1483mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008B8  67D8                    1484mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000008BA                          1485mm     
000008BA  1A39 00C00017           1486mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008C0  13C5 00E00001           1487mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008C6                          1488mm 
000008C6                          1489mm     ENDM
000008C6                          1490mm         PRINT_CHAR D5,D6
000008C6                          1491mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008C6                 TRUE     1492mm     IFEQ DEBUG
000008C6  1C39 00C00003           1493mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008CC  0806 0002               1494mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008D0  67F4                    1495mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
000008D2  13C5 00C00007           1496mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008D8                          1497mm     ENDC
000008D8                          1498mm 
000008D8                 FALSE    1499mm     IFNE DEBUG
000008D8                          1500mm     ENDC
000008D8                          1501mm 
000008D8                          1502mm     ENDM
000008D8                          1503mm         HEX2BIN D5,D5,A4
000008D8  49FA 0FA3               1504mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008DC  0405 0030               1505mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008E0  CABC 000000FF           1506mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008E6  1A34 5000               1507mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008EA                          1508mm     ENDM
000008EA  8205                    1509m         OR.B D5,D1
000008EC  5307                    1510m         SUB.B #1,D7
000008EE                          1511m     ENDW
000008EE  6098                    1512ms     BRA _1000000A
000008F0                          1513ms _1000000B
000008F0                          1514m 
000008F0  7A00                    1515m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008F2  1A01                    1516m     MOVE.B D1,D5
000008F4  D481                    1517m     ADD.L D1,D2
000008F6                          1518m 
000008F6                          1519m     ENDM
000008F6                          1520   
000008F6  14C1                    1521                  MOVE.B D1,(A2)+                     ; store it!
000008F8                          1522  
000008F8  5303                    1523                  SUB.B #1,D3                         ; 1 less byte to go
000008FA                          1524              ENDW
000008FA  6080                    1525s     BRA _10000008
000008FC                          1526s _10000009
000008FC                          1527  
000008FC  7200                    1528              MOVE.L #0,D1                            ; not done yet
000008FE                          1529          ELSE
000008FE  6000 01E2               1530s     BRA _00000008
00000902                          1531s _00000006
00000902                          1532              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000902  B23C 0038               1533s     CMP.B   #'8',D1
00000906  6600 0164               1534s     BNE.L   _00000009
0000090A  7800                    1535                  MOVE.L #0,D4                        ; read the 24 bit start address
0000090C                          1536m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
0000090C  1E3C 0002               1537m     MOVE.B #2,D7
00000910                          1538m     WHILE.B D7 <GT> 0 DO
00000910                          1539ms _1000000C
00000910  BE38 0000               1540ms     CMP.B   0,D7
00000914  6F00 0062               1541ms     BLE _1000000D
00000918  E98C                    1542m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000091A                          1543mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000091A                          1544mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000091A                          1545mm 
0000091A  1A39 00C00003           1546mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000920  0805 0000               1547mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000924  6700 0010               1548mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000928                          1549mm 
00000928                          1550mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000928                 TRUE     1551mmm     IFEQ DEBUG
00000928  1A39 00C00007           1552mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000092E                          1553mmm     ENDC
0000092E                 FALSE    1554mmm     IFNE DEBUG
0000092E                          1555mmm     ENDC
0000092E                          1556mmm 
0000092E  BA3C 001B               1557mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000932  6700 F7D0               1558mmm     BEQ START
00000936                          1559mmm     ENDM
00000936                          1560mm CONTINUE_89
00000936  1A39 00C00013           1561mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000093C  0805 0000               1562mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000940  67D8                    1563mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
00000942                          1564mm     
00000942  1A39 00C00017           1565mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000948  13C5 00E00001           1566mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000094E                          1567mm 
0000094E                          1568mm     ENDM
0000094E                          1569mm         PRINT_CHAR D5,D6
0000094E                          1570mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000094E                 TRUE     1571mm     IFEQ DEBUG
0000094E  1C39 00C00003           1572mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000954  0806 0002               1573mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000958  67F4                    1574mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
0000095A  13C5 00C00007           1575mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000960                          1576mm     ENDC
00000960                          1577mm 
00000960                 FALSE    1578mm     IFNE DEBUG
00000960                          1579mm     ENDC
00000960                          1580mm 
00000960                          1581mm     ENDM
00000960                          1582mm         HEX2BIN D5,D5,A4
00000960  49FA 0F1B               1583mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000964  0405 0030               1584mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000968  CABC 000000FF           1585mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000096E  1A34 5000               1586mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000972                          1587mm     ENDM
00000972  8805                    1588m         OR.B D5,D4
00000974  5307                    1589m         SUB.B #1,D7
00000976                          1590m     ENDW
00000976  6098                    1591ms     BRA _1000000C
00000978                          1592ms _1000000D
00000978                          1593m 
00000978  7A00                    1594m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000097A  1A04                    1595m     MOVE.B D4,D5
0000097C  D484                    1596m     ADD.L D4,D2
0000097E                          1597m 
0000097E                          1598m     ENDM
0000097E                          1599m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000097E  1E3C 0002               1600m     MOVE.B #2,D7
00000982                          1601m     WHILE.B D7 <GT> 0 DO
00000982                          1602ms _1000000E
00000982  BE38 0000               1603ms     CMP.B   0,D7
00000986  6F00 0062               1604ms     BLE _1000000F
0000098A  E98C                    1605m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000098C                          1606mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000098C                          1607mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098C                          1608mm 
0000098C  1A39 00C00003           1609mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000992  0805 0000               1610mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000996  6700 0010               1611mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
0000099A                          1612mm 
0000099A                          1613mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000099A                 TRUE     1614mmm     IFEQ DEBUG
0000099A  1A39 00C00007           1615mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009A0                          1616mmm     ENDC
000009A0                 FALSE    1617mmm     IFNE DEBUG
000009A0                          1618mmm     ENDC
000009A0                          1619mmm 
000009A0  BA3C 001B               1620mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009A4  6700 F75E               1621mmm     BEQ START
000009A8                          1622mmm     ENDM
000009A8                          1623mm CONTINUE_94
000009A8  1A39 00C00013           1624mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009AE  0805 0000               1625mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009B2  67D8                    1626mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
000009B4                          1627mm     
000009B4  1A39 00C00017           1628mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009BA  13C5 00E00001           1629mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009C0                          1630mm 
000009C0                          1631mm     ENDM
000009C0                          1632mm         PRINT_CHAR D5,D6
000009C0                          1633mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009C0                 TRUE     1634mm     IFEQ DEBUG
000009C0  1C39 00C00003           1635mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009C6  0806 0002               1636mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009CA  67F4                    1637mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000009CC  13C5 00C00007           1638mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009D2                          1639mm     ENDC
000009D2                          1640mm 
000009D2                 FALSE    1641mm     IFNE DEBUG
000009D2                          1642mm     ENDC
000009D2                          1643mm 
000009D2                          1644mm     ENDM
000009D2                          1645mm         HEX2BIN D5,D5,A4
000009D2  49FA 0EA9               1646mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009D6  0405 0030               1647mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009DA  CABC 000000FF           1648mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009E0  1A34 5000               1649mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009E4                          1650mm     ENDM
000009E4  8805                    1651m         OR.B D5,D4
000009E6  5307                    1652m         SUB.B #1,D7
000009E8                          1653m     ENDW
000009E8  6098                    1654ms     BRA _1000000E
000009EA                          1655ms _1000000F
000009EA                          1656m 
000009EA  7A00                    1657m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009EC  1A04                    1658m     MOVE.B D4,D5
000009EE  D484                    1659m     ADD.L D4,D2
000009F0                          1660m 
000009F0                          1661m     ENDM
000009F0                          1662m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000009F0  1E3C 0002               1663m     MOVE.B #2,D7
000009F4                          1664m     WHILE.B D7 <GT> 0 DO
000009F4                          1665ms _10000010
000009F4  BE38 0000               1666ms     CMP.B   0,D7
000009F8  6F00 0062               1667ms     BLE _10000011
000009FC  E98C                    1668m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009FE                          1669mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009FE                          1670mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FE                          1671mm 
000009FE  1A39 00C00003           1672mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A04  0805 0000               1673mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A08  6700 0010               1674mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000A0C                          1675mm 
00000A0C                          1676mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A0C                 TRUE     1677mmm     IFEQ DEBUG
00000A0C  1A39 00C00007           1678mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A12                          1679mmm     ENDC
00000A12                 FALSE    1680mmm     IFNE DEBUG
00000A12                          1681mmm     ENDC
00000A12                          1682mmm 
00000A12  BA3C 001B               1683mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A16  6700 F6EC               1684mmm     BEQ START
00000A1A                          1685mmm     ENDM
00000A1A                          1686mm CONTINUE_99
00000A1A  1A39 00C00013           1687mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A20  0805 0000               1688mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A24  67D8                    1689mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000A26                          1690mm     
00000A26  1A39 00C00017           1691mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A2C  13C5 00E00001           1692mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A32                          1693mm 
00000A32                          1694mm     ENDM
00000A32                          1695mm         PRINT_CHAR D5,D6
00000A32                          1696mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A32                 TRUE     1697mm     IFEQ DEBUG
00000A32  1C39 00C00003           1698mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A38  0806 0002               1699mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A3C  67F4                    1700mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000A3E  13C5 00C00007           1701mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A44                          1702mm     ENDC
00000A44                          1703mm 
00000A44                 FALSE    1704mm     IFNE DEBUG
00000A44                          1705mm     ENDC
00000A44                          1706mm 
00000A44                          1707mm     ENDM
00000A44                          1708mm         HEX2BIN D5,D5,A4
00000A44  49FA 0E37               1709mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A48  0405 0030               1710mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A4C  CABC 000000FF           1711mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A52  1A34 5000               1712mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A56                          1713mm     ENDM
00000A56  8805                    1714m         OR.B D5,D4
00000A58  5307                    1715m         SUB.B #1,D7
00000A5A                          1716m     ENDW
00000A5A  6098                    1717ms     BRA _10000010
00000A5C                          1718ms _10000011
00000A5C                          1719m 
00000A5C  7A00                    1720m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A5E  1A04                    1721m     MOVE.B D4,D5
00000A60  D484                    1722m     ADD.L D4,D2
00000A62                          1723m 
00000A62                          1724m     ENDM
00000A62                          1725  
00000A62  2044                    1726                  MOVE.L D4,A0                        ; start address -> A0
00000A64  D1C9                    1727                  ADD.L A1,A0                         ; add in the offset
00000A66                          1728  
00000A66  72FF                    1729                  MOVE.L #$FFFFFFFF,D1                ; done
00000A68                          1730              ELSE
00000A68  6000 0078               1731s     BRA _0000000A
00000A6C                          1732s _00000009
00000A6C                          1733m                 PRINT_CRLF D5,A4
00000A6C  49FA 0E3A               1734m     LEA CRLF(PC),A4
00000A70                          1735mm     PRINT_STR A4,D5
00000A70                          1736mm LOOP_104
00000A70  0C14 0000               1737mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A74  6700 0016               1738mm     BEQ EXIT_104
00000A78                          1739mmm     PRINT_CHAR (A4)+,D5
00000A78                          1740mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A78                 TRUE     1741mmm     IFEQ DEBUG
00000A78  1A39 00C00003           1742mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A7E  0805 0002               1743mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A82  67F4                    1744mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A84  13DC 00C00007           1745mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A8A                          1746mmm     ENDC
00000A8A                          1747mmm 
00000A8A                 FALSE    1748mmm     IFNE DEBUG
00000A8A                          1749mmm     ENDC
00000A8A                          1750mmm 
00000A8A                          1751mmm     ENDM
00000A8A  60E4                    1752mm     BRA LOOP_104
00000A8C                          1753mm EXIT_104
00000A8C                          1754mm     ENDM
00000A8C                          1755m     ENDM
00000A8C                          1756  
00000A8C  49FA 0DA6               1757                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000A90                          1758m                 PRINT_STR A4,D5
00000A90                          1759m LOOP_106
00000A90  0C14 0000               1760m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A94  6700 0016               1761m     BEQ EXIT_106
00000A98                          1762mm     PRINT_CHAR (A4)+,D5
00000A98                          1763mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A98                 TRUE     1764mm     IFEQ DEBUG
00000A98  1A39 00C00003           1765mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A9E  0805 0002               1766mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AA2  67F4                    1767mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000AA4  13DC 00C00007           1768mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AAA                          1769mm     ENDC
00000AAA                          1770mm 
00000AAA                 FALSE    1771mm     IFNE DEBUG
00000AAA                          1772mm     ENDC
00000AAA                          1773mm 
00000AAA                          1774mm     ENDM
00000AAA  60E4                    1775m     BRA LOOP_106
00000AAC                          1776m EXIT_106
00000AAC                          1777m     ENDM
00000AAC                          1778m                 PRINT_CHAR D1,D5
00000AAC                          1779m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AAC                 TRUE     1780m     IFEQ DEBUG
00000AAC  1A39 00C00003           1781m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB2  0805 0002               1782m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AB6  67F4                    1783m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AB8  13C1 00C00007           1784m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000ABE                          1785m     ENDC
00000ABE                          1786m 
00000ABE                 FALSE    1787m     IFNE DEBUG
00000ABE                          1788m     ENDC
00000ABE                          1789m 
00000ABE                          1790m     ENDM
00000ABE                          1791m                 PRINT_CRLF D5,A4
00000ABE  49FA 0DE8               1792m     LEA CRLF(PC),A4
00000AC2                          1793mm     PRINT_STR A4,D5
00000AC2                          1794mm LOOP_110
00000AC2  0C14 0000               1795mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AC6  6700 0016               1796mm     BEQ EXIT_110
00000ACA                          1797mmm     PRINT_CHAR (A4)+,D5
00000ACA                          1798mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACA                 TRUE     1799mmm     IFEQ DEBUG
00000ACA  1A39 00C00003           1800mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD0  0805 0002               1801mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AD4  67F4                    1802mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000AD6  13DC 00C00007           1803mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ADC                          1804mmm     ENDC
00000ADC                          1805mmm 
00000ADC                 FALSE    1806mmm     IFNE DEBUG
00000ADC                          1807mmm     ENDC
00000ADC                          1808mmm 
00000ADC                          1809mmm     ENDM
00000ADC  60E4                    1810mm     BRA LOOP_110
00000ADE                          1811mm EXIT_110
00000ADE                          1812mm     ENDM
00000ADE                          1813m     ENDM
00000ADE                          1814  
00000ADE  6000 FAEC               1815                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000AE2                          1816              ENDI
00000AE2                          1817s _0000000A
00000AE2                          1818          ENDI
00000AE2                          1819s _00000008
00000AE2                          1820      ENDI
00000AE2                          1821s _00000004
00000AE2                          1822  
00000AE2                          1823m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000AE2  1E3C 0002               1824m     MOVE.B #2,D7
00000AE6                          1825m     WHILE.B D7 <GT> 0 DO
00000AE6                          1826ms _10000012
00000AE6  BE38 0000               1827ms     CMP.B   0,D7
00000AEA  6F00 0062               1828ms     BLE _10000013
00000AEE  E98C                    1829m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000AF0                          1830mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000AF0                          1831mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF0                          1832mm 
00000AF0  1A39 00C00003           1833mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000AF6  0805 0000               1834mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AFA  6700 0010               1835mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000AFE                          1836mm 
00000AFE                          1837mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AFE                 TRUE     1838mmm     IFEQ DEBUG
00000AFE  1A39 00C00007           1839mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B04                          1840mmm     ENDC
00000B04                 FALSE    1841mmm     IFNE DEBUG
00000B04                          1842mmm     ENDC
00000B04                          1843mmm 
00000B04  BA3C 001B               1844mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B08  6700 F5FA               1845mmm     BEQ START
00000B0C                          1846mmm     ENDM
00000B0C                          1847mm CONTINUE_113
00000B0C  1A39 00C00013           1848mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B12  0805 0000               1849mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B16  67D8                    1850mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000B18                          1851mm     
00000B18  1A39 00C00017           1852mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B1E  13C5 00E00001           1853mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B24                          1854mm 
00000B24                          1855mm     ENDM
00000B24                          1856mm         PRINT_CHAR D5,D6
00000B24                          1857mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B24                 TRUE     1858mm     IFEQ DEBUG
00000B24  1C39 00C00003           1859mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B2A  0806 0002               1860mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B2E  67F4                    1861mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B30  13C5 00C00007           1862mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B36                          1863mm     ENDC
00000B36                          1864mm 
00000B36                 FALSE    1865mm     IFNE DEBUG
00000B36                          1866mm     ENDC
00000B36                          1867mm 
00000B36                          1868mm     ENDM
00000B36                          1869mm         HEX2BIN D5,D5,A4
00000B36  49FA 0D45               1870mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B3A  0405 0030               1871mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B3E  CABC 000000FF           1872mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B44  1A34 5000               1873mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B48                          1874mm     ENDM
00000B48  8805                    1875m         OR.B D5,D4
00000B4A  5307                    1876m         SUB.B #1,D7
00000B4C                          1877m     ENDW
00000B4C  6098                    1878ms     BRA _10000012
00000B4E                          1879ms _10000013
00000B4E                          1880m 
00000B4E  7A00                    1881m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B50  1A04                    1882m     MOVE.B D4,D5
00000B52  D484                    1883m     ADD.L D4,D2
00000B54                          1884m 
00000B54                          1885m     ENDM
00000B54                          1886m     PRINT_CRLF D5,A4
00000B54  49FA 0D52               1887m     LEA CRLF(PC),A4
00000B58                          1888mm     PRINT_STR A4,D5
00000B58                          1889mm LOOP_118
00000B58  0C14 0000               1890mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B5C  6700 0016               1891mm     BEQ EXIT_118
00000B60                          1892mmm     PRINT_CHAR (A4)+,D5
00000B60                          1893mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B60                 TRUE     1894mmm     IFEQ DEBUG
00000B60  1A39 00C00003           1895mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B66  0805 0002               1896mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B6A  67F4                    1897mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B6C  13DC 00C00007           1898mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B72                          1899mmm     ENDC
00000B72                          1900mmm 
00000B72                 FALSE    1901mmm     IFNE DEBUG
00000B72                          1902mmm     ENDC
00000B72                          1903mmm 
00000B72                          1904mmm     ENDM
00000B72  60E4                    1905mm     BRA LOOP_118
00000B74                          1906mm EXIT_118
00000B74                          1907mm     ENDM
00000B74                          1908m     ENDM
00000B74                          1909  
00000B74                          1910      IF.B D2 <NE> #$FF THEN.L
00000B74  B43C 00FF               1911s     CMP.B   #$FF,D2
00000B78  6700 0090               1912s     BEQ.L   _0000000B
00000B7C  49FA 0CCD               1913          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000B80                          1914m         PRINT_STR A4,D5
00000B80                          1915m LOOP_120
00000B80  0C14 0000               1916m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B84  6700 0016               1917m     BEQ EXIT_120
00000B88                          1918mm     PRINT_CHAR (A4)+,D5
00000B88                          1919mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     1920mm     IFEQ DEBUG
00000B88  1A39 00C00003           1921mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B8E  0805 0002               1922mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    1923mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B94  13DC 00C00007           1924mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9A                          1925mm     ENDC
00000B9A                          1926mm 
00000B9A                 FALSE    1927mm     IFNE DEBUG
00000B9A                          1928mm     ENDC
00000B9A                          1929mm 
00000B9A                          1930mm     ENDM
00000B9A  60E4                    1931m     BRA LOOP_120
00000B9C                          1932m EXIT_120
00000B9C                          1933m     ENDM
00000B9C                          1934m         PRINT_REG D0,D5,D3,D6,A4
00000B9C  49FA 0D10               1935m     LEA OX(PC),A4
00000BA0                          1936mm     PRINT_STR A4,D5
00000BA0                          1937mm LOOP_123
00000BA0  0C14 0000               1938mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BA4  6700 0016               1939mm     BEQ EXIT_123
00000BA8                          1940mmm     PRINT_CHAR (A4)+,D5
00000BA8                          1941mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA8                 TRUE     1942mmm     IFEQ DEBUG
00000BA8  1A39 00C00003           1943mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BAE  0805 0002               1944mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BB2  67F4                    1945mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BB4  13DC 00C00007           1946mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BBA                          1947mmm     ENDC
00000BBA                          1948mmm 
00000BBA                 FALSE    1949mmm     IFNE DEBUG
00000BBA                          1950mmm     ENDC
00000BBA                          1951mmm 
00000BBA                          1952mmm     ENDM
00000BBA  60E4                    1953mm     BRA LOOP_123
00000BBC                          1954mm EXIT_123
00000BBC                          1955mm     ENDM
00000BBC  7C07                    1956m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BBE                          1957m LOOP_122
00000BBE                          1958mm     BIN2HEX D0,D3,A4
00000BBE  49FA 0CAD               1959mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000BC2  E998                    1960mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC4  1600                    1961mm     MOVE.B D0,D3
00000BC6  0283 0000000F           1962mm     ANDI.L #$F,D3
00000BCC  1634 3000               1963mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000BD0                          1964mm     ENDM
00000BD0                          1965mm     PRINT_CHAR D3,D5
00000BD0                          1966mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                 TRUE     1967mm     IFEQ DEBUG
00000BD0  1A39 00C00003           1968mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD6  0805 0002               1969mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BDA  67F4                    1970mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000BDC  13C3 00C00007           1971mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BE2                          1972mm     ENDC
00000BE2                          1973mm 
00000BE2                 FALSE    1974mm     IFNE DEBUG
00000BE2                          1975mm     ENDC
00000BE2                          1976mm 
00000BE2                          1977mm     ENDM
00000BE2  57CE FFDA               1978m     DBEQ D6,LOOP_122
00000BE6                          1979m     ENDM
00000BE6                          1980m         PRINT_CRLF D5,A4
00000BE6  49FA 0CC0               1981m     LEA CRLF(PC),A4
00000BEA                          1982mm     PRINT_STR A4,D5
00000BEA                          1983mm LOOP_128
00000BEA  0C14 0000               1984mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BEE  6700 0016               1985mm     BEQ EXIT_128
00000BF2                          1986mmm     PRINT_CHAR (A4)+,D5
00000BF2                          1987mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF2                 TRUE     1988mmm     IFEQ DEBUG
00000BF2  1A39 00C00003           1989mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BF8  0805 0002               1990mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BFC  67F4                    1991mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BFE  13DC 00C00007           1992mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C04                          1993mmm     ENDC
00000C04                          1994mmm 
00000C04                 FALSE    1995mmm     IFNE DEBUG
00000C04                          1996mmm     ENDC
00000C04                          1997mmm 
00000C04                          1998mmm     ENDM
00000C04  60E4                    1999mm     BRA LOOP_128
00000C06                          2000mm EXIT_128
00000C06                          2001mm     ENDM
00000C06                          2002m     ENDM
00000C06                          2003          
00000C06  6000 F714               2004          BRA MAIN_LOOP
00000C0A                          2005      ENDI
00000C0A                          2006s _0000000B
00000C0A                          2007  
00000C0A                          2008      IF D1 <EQ> #0 THEN
00000C0A  B27C 0000               2009s     CMP.W   #0,D1
00000C0E  6600 0006               2010s     BNE _0000000C
00000C12  6000 F9B8               2011        BRA WAIT_FOR_SRECORD
00000C16                          2012      ENDI
00000C16                          2013s _0000000C
00000C16                          2014  DOWNLOAD_DONE
00000C16                          2015m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C16  43FA 0C96               2016m     LEA OX(PC),A1
00000C1A                          2017mm     PRINT_STR A1,D5
00000C1A                          2018mm LOOP_131
00000C1A  0C11 0000               2019mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C1E  6700 0016               2020mm     BEQ EXIT_131
00000C22                          2021mmm     PRINT_CHAR (A1)+,D5
00000C22                          2022mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C22                 TRUE     2023mmm     IFEQ DEBUG
00000C22  1A39 00C00003           2024mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C28  0805 0002               2025mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C2C  67F4                    2026mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000C2E  13D9 00C00007           2027mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C34                          2028mmm     ENDC
00000C34                          2029mmm 
00000C34                 FALSE    2030mmm     IFNE DEBUG
00000C34                          2031mmm     ENDC
00000C34                          2032mmm 
00000C34                          2033mmm     ENDM
00000C34  60E4                    2034mm     BRA LOOP_131
00000C36                          2035mm EXIT_131
00000C36                          2036mm     ENDM
00000C36  7407                    2037m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C38                          2038m LOOP_130
00000C38                          2039mm     BIN2HEX D0,D6,A1
00000C38  43FA 0C33               2040mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C3C  E998                    2041mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C3E  1C00                    2042mm     MOVE.B D0,D6
00000C40  0286 0000000F           2043mm     ANDI.L #$F,D6
00000C46  1C31 6000               2044mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C4A                          2045mm     ENDM
00000C4A                          2046mm     PRINT_CHAR D6,D5
00000C4A                          2047mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4A                 TRUE     2048mm     IFEQ DEBUG
00000C4A  1A39 00C00003           2049mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C50  0805 0002               2050mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C54  67F4                    2051mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C56  13C6 00C00007           2052mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C5C                          2053mm     ENDC
00000C5C                          2054mm 
00000C5C                 FALSE    2055mm     IFNE DEBUG
00000C5C                          2056mm     ENDC
00000C5C                          2057mm 
00000C5C                          2058mm     ENDM
00000C5C  57CA FFDA               2059m     DBEQ D2,LOOP_130
00000C60                          2060m     ENDM
00000C60  43FA 0BB0               2061      LEA READ(PC),A1
00000C64                          2062m     PRINT_STR A1,D5
00000C64                          2063m LOOP_135
00000C64  0C11 0000               2064m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C68  6700 0016               2065m     BEQ EXIT_135
00000C6C                          2066mm     PRINT_CHAR (A1)+,D5
00000C6C                          2067mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C6C                 TRUE     2068mm     IFEQ DEBUG
00000C6C  1A39 00C00003           2069mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C72  0805 0002               2070mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C76  67F4                    2071mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C78  13D9 00C00007           2072mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C7E                          2073mm     ENDC
00000C7E                          2074mm 
00000C7E                 FALSE    2075mm     IFNE DEBUG
00000C7E                          2076mm     ENDC
00000C7E                          2077mm 
00000C7E                          2078mm     ENDM
00000C7E  60E4                    2079m     BRA LOOP_135
00000C80                          2080m EXIT_135
00000C80                          2081m     ENDM
00000C80  2E08                    2082      MOVE.L A0,D7                                    ; set address accumulator to start address
00000C82                          2083m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000C82  43FA 0C2A               2084m     LEA OX(PC),A1
00000C86                          2085mm     PRINT_STR A1,D5
00000C86                          2086mm LOOP_138
00000C86  0C11 0000               2087mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C8A  6700 0016               2088mm     BEQ EXIT_138
00000C8E                          2089mmm     PRINT_CHAR (A1)+,D5
00000C8E                          2090mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     2091mmm     IFEQ DEBUG
00000C8E  1A39 00C00003           2092mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C94  0805 0002               2093mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    2094mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000C9A  13D9 00C00007           2095mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CA0                          2096mmm     ENDC
00000CA0                          2097mmm 
00000CA0                 FALSE    2098mmm     IFNE DEBUG
00000CA0                          2099mmm     ENDC
00000CA0                          2100mmm 
00000CA0                          2101mmm     ENDM
00000CA0  60E4                    2102mm     BRA LOOP_138
00000CA2                          2103mm EXIT_138
00000CA2                          2104mm     ENDM
00000CA2  7407                    2105m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000CA4                          2106m LOOP_137
00000CA4                          2107mm     BIN2HEX D7,D6,A1
00000CA4  43FA 0BC7               2108mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CA8  E99F                    2109mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CAA  1C07                    2110mm     MOVE.B D7,D6
00000CAC  0286 0000000F           2111mm     ANDI.L #$F,D6
00000CB2  1C31 6000               2112mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CB6                          2113mm     ENDM
00000CB6                          2114mm     PRINT_CHAR D6,D5
00000CB6                          2115mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB6                 TRUE     2116mm     IFEQ DEBUG
00000CB6  1A39 00C00003           2117mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CBC  0805 0002               2118mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CC0  67F4                    2119mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CC2  13C6 00C00007           2120mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CC8                          2121mm     ENDC
00000CC8                          2122mm 
00000CC8                 FALSE    2123mm     IFNE DEBUG
00000CC8                          2124mm     ENDC
00000CC8                          2125mm 
00000CC8                          2126mm     ENDM
00000CC8  57CA FFDA               2127m     DBEQ D2,LOOP_137
00000CCC                          2128m     ENDM
00000CCC                          2129m     PRINT_CRLF D5,A4
00000CCC  49FA 0BDA               2130m     LEA CRLF(PC),A4
00000CD0                          2131mm     PRINT_STR A4,D5
00000CD0                          2132mm LOOP_143
00000CD0  0C14 0000               2133mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000CD4  6700 0016               2134mm     BEQ EXIT_143
00000CD8                          2135mmm     PRINT_CHAR (A4)+,D5
00000CD8                          2136mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD8                 TRUE     2137mmm     IFEQ DEBUG
00000CD8  1A39 00C00003           2138mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CDE  0805 0002               2139mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CE2  67F4                    2140mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000CE4  13DC 00C00007           2141mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CEA                          2142mmm     ENDC
00000CEA                          2143mmm 
00000CEA                 FALSE    2144mmm     IFNE DEBUG
00000CEA                          2145mmm     ENDC
00000CEA                          2146mmm 
00000CEA                          2147mmm     ENDM
00000CEA  60E4                    2148mm     BRA LOOP_143
00000CEC                          2149mm EXIT_143
00000CEC                          2150mm     ENDM
00000CEC                          2151m     ENDM
00000CEC                          2152  
00000CEC  6000 F62E               2153      BRA MAIN_LOOP
00000CF0                          2154  
00000CF0                          2155  G
00000CF0  2047                    2156      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000CF2  7E00                    2157      MOVE.L #0,D7
00000CF4                          2158  
00000CF4  4ED0                    2159      JMP (A0)
00000CF6                          2160          
00000CF6                          2161  Z
00000CF6  207C 00200000           2162      MOVE.L #RAM,A0                                  ; address of RAM
00000CFC  D1FC 00100000           2163      ADD.L #$100000,A0
00000D02                          2164  
00000D02                          2165      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000D02  7000                    2166s     MOVE.L  #0,D0
00000D04  6000 0012               2167s     BRA _20000007
00000D08                          2168s _20000006
00000D08  2200                    2169          MOVE.L D0,D1                                ; progress update
00000D0A  E089                    2170          LSR.L #8,D1 
00000D0C  E089                    2171          LSR.L #8,D1
00000D0E  13C1 00E00001           2172          MOVE.B D1,DISPLAY
00000D14                          2173          
00000D14  2108                    2174          MOVE.L A0,-(A0)
00000D16                          2175      ENDF
00000D16  5880                    2176s     ADD.L   #4,D0
00000D18                          2177s _20000007
00000D18  B0BC 000FFFFC           2178s     CMP.L   #$FFFFC,D0
00000D1E  6FE8                    2179s     BLE _20000006
00000D20                          2180  
00000D20  207C 00200000           2181      MOVE.L #RAM,A0                                  ; address of RAM
00000D26  D1FC 00100000           2182      ADD.L #$100000,A0
00000D2C                          2183  
00000D2C                          2184      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D2C  7000                    2185s     MOVE.L  #0,D0
00000D2E  6000 00A8               2186s     BRA _20000009
00000D32                          2187s _20000008
00000D32  2200                    2188          MOVE.L D0,D1                                ; progress update
00000D34  E089                    2189          LSR.L #8,D1
00000D36  E089                    2190          LSR.L #8,D1
00000D38  13C1 00E00001           2191          MOVE.B D1,DISPLAY
00000D3E                          2192  
00000D3E  2408                    2193          MOVE.L A0,D2
00000D40  2220                    2194          MOVE.L -(A0),D1
00000D42                          2195  
00000D42                          2196          IF.L D2 <NE> D1 THEN
00000D42  B481                    2197s     CMP.L   D1,D2
00000D44  6700 0090               2198s     BEQ _0000000D
00000D48  43FA 0B12               2199              LEA RAM_ERROR(PC),A1
00000D4C                          2200m             PRINT_STR A1,D1
00000D4C                          2201m LOOP_145
00000D4C  0C11 0000               2202m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D50  6700 0016               2203m     BEQ EXIT_145
00000D54                          2204mm     PRINT_CHAR (A1)+,D1
00000D54                          2205mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D54                 TRUE     2206mm     IFEQ DEBUG
00000D54  1239 00C00003           2207mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D5A  0801 0002               2208mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000D5E  67F4                    2209mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000D60  13D9 00C00007           2210mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D66                          2211mm     ENDC
00000D66                          2212mm 
00000D66                 FALSE    2213mm     IFNE DEBUG
00000D66                          2214mm     ENDC
00000D66                          2215mm 
00000D66                          2216mm     ENDM
00000D66  60E4                    2217m     BRA LOOP_145
00000D68                          2218m EXIT_145
00000D68                          2219m     ENDM
00000D68  2208                    2220              MOVE.L A0,D1
00000D6A  5981                    2221              SUB.L #4,D1
00000D6C                          2222m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000D6C  43FA 0B40               2223m     LEA OX(PC),A1
00000D70                          2224mm     PRINT_STR A1,D3
00000D70                          2225mm LOOP_148
00000D70  0C11 0000               2226mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D74  6700 0016               2227mm     BEQ EXIT_148
00000D78                          2228mmm     PRINT_CHAR (A1)+,D3
00000D78                          2229mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D78                 TRUE     2230mmm     IFEQ DEBUG
00000D78  1639 00C00003           2231mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D7E  0803 0002               2232mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D82  67F4                    2233mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000D84  13D9 00C00007           2234mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D8A                          2235mmm     ENDC
00000D8A                          2236mmm 
00000D8A                 FALSE    2237mmm     IFNE DEBUG
00000D8A                          2238mmm     ENDC
00000D8A                          2239mmm 
00000D8A                          2240mmm     ENDM
00000D8A  60E4                    2241mm     BRA LOOP_148
00000D8C                          2242mm EXIT_148
00000D8C                          2243mm     ENDM
00000D8C  7C07                    2244m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D8E                          2245m LOOP_147
00000D8E                          2246mm     BIN2HEX D1,D2,A1
00000D8E  43FA 0ADD               2247mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000D92  E999                    2248mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D94  1401                    2249mm     MOVE.B D1,D2
00000D96  0282 0000000F           2250mm     ANDI.L #$F,D2
00000D9C  1431 2000               2251mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000DA0                          2252mm     ENDM
00000DA0                          2253mm     PRINT_CHAR D2,D3
00000DA0                          2254mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA0                 TRUE     2255mm     IFEQ DEBUG
00000DA0  1639 00C00003           2256mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DA6  0803 0002               2257mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DAA  67F4                    2258mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DAC  13C2 00C00007           2259mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DB2                          2260mm     ENDC
00000DB2                          2261mm 
00000DB2                 FALSE    2262mm     IFNE DEBUG
00000DB2                          2263mm     ENDC
00000DB2                          2264mm 
00000DB2                          2265mm     ENDM
00000DB2  57CE FFDA               2266m     DBEQ D6,LOOP_147
00000DB6                          2267m     ENDM
00000DB6                          2268m             PRINT_CRLF D3,A1
00000DB6  43FA 0AF0               2269m     LEA CRLF(PC),A1
00000DBA                          2270mm     PRINT_STR A1,D3
00000DBA                          2271mm LOOP_153
00000DBA  0C11 0000               2272mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DBE  6700 0016               2273mm     BEQ EXIT_153
00000DC2                          2274mmm     PRINT_CHAR (A1)+,D3
00000DC2                          2275mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC2                 TRUE     2276mmm     IFEQ DEBUG
00000DC2  1639 00C00003           2277mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DC8  0803 0002               2278mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DCC  67F4                    2279mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DCE  13D9 00C00007           2280mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DD4                          2281mmm     ENDC
00000DD4                          2282mmm 
00000DD4                 FALSE    2283mmm     IFNE DEBUG
00000DD4                          2284mmm     ENDC
00000DD4                          2285mmm 
00000DD4                          2286mmm     ENDM
00000DD4  60E4                    2287mm     BRA LOOP_153
00000DD6                          2288mm EXIT_153
00000DD6                          2289mm     ENDM
00000DD6                          2290m     ENDM
00000DD6                          2291          ENDI 
00000DD6                          2292s _0000000D
00000DD6                          2293      ENDF
00000DD6  5880                    2294s     ADD.L   #4,D0
00000DD8                          2295s _20000009
00000DD8  B0BC 000FFFFC           2296s     CMP.L   #$FFFFC,D0
00000DDE  6F00 FF52               2297s     BLE _20000008
00000DE2                          2298  
00000DE2  6000 F538               2299      BRA MAIN_LOOP
00000DE6                          2300  
00000DE6                          2301  L
00000DE6  7000                    2302      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000DE8  7200                    2303      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000DEA                          2304  
00000DEA                          2305      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000DEA  343C 0000               2306s     MOVE.W  #0,D2
00000DEE  6000 0046               2307s     BRA _2000000B
00000DF2                          2308s _2000000A
00000DF2  E989                    2309          LSL.L #4,D1                                 ; make what we have so far more significant
00000DF4                          2310m         WAIT_CHAR D3,D4                             ; next character -> D2
00000DF4                          2311m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF4                 TRUE     2312m     IFEQ DEBUG
00000DF4  1839 00C00003           2313m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000DFA  0804 0000               2314m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000DFE  67F4                    2315m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000E00                          2316m     ENDC
00000E00                          2317m 
00000E00                          2318mm     READ_CHAR D3
00000E00                 TRUE     2319mm     IFEQ DEBUG
00000E00  1639 00C00007           2320mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000E06                          2321mm     ENDC
00000E06                 FALSE    2322mm     IFNE DEBUG
00000E06                          2323mm     ENDC
00000E06                          2324mm 
00000E06  B63C 001B               2325mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E0A  6700 F2F8               2326mm     BEQ START
00000E0E                          2327mm     ENDM
00000E0E                          2328m 
00000E0E                 TRUE     2329m     IFEQ DEBUG
00000E0E                          2330mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E0E                          2331mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E0E                 TRUE     2332mm     IFEQ DEBUG
00000E0E  1839 00C00003           2333mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E14  0804 0002               2334mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E18  67F4                    2335mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E1A  13C3 00C00007           2336mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E20                          2337mm     ENDC
00000E20                          2338mm 
00000E20                 FALSE    2339mm     IFNE DEBUG
00000E20                          2340mm     ENDC
00000E20                          2341mm 
00000E20                          2342mm     ENDM
00000E20                          2343m     ENDC
00000E20                          2344m     ENDM
00000E20                          2345m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E20  41FA 0A5B               2346m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E24  0403 0030               2347m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E28  C6BC 000000FF           2348m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E2E  1630 3000               2349m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E32                          2350m     ENDM
00000E32  8203                    2351          OR.B D3,D1
00000E34                          2352      ENDF
00000E34  5242                    2353s     ADD.W   #1,D2
00000E36                          2354s _2000000B
00000E36  B47C 0007               2355s     CMP.W   #7,D2
00000E3A  6FB6                    2356s     BLE _2000000A
00000E3C                          2357  
00000E3C  3001                    2358      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E3E  0480 00000104           2359      SUB.L #START,D0                                 ; remove the vector table from the length
00000E44  E089                    2360      LSR.L #8,D1                                     ; extract the MSword for the address
00000E46  E089                    2361      LSR.L #8,D1
00000E48                          2362  
00000E48                          2363m     PRINT_CRLF D2,A1
00000E48  43FA 0A5E               2364m     LEA CRLF(PC),A1
00000E4C                          2365mm     PRINT_STR A1,D2
00000E4C                          2366mm LOOP_160
00000E4C  0C11 0000               2367mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E50  6700 0016               2368mm     BEQ EXIT_160
00000E54                          2369mmm     PRINT_CHAR (A1)+,D2
00000E54                          2370mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E54                 TRUE     2371mmm     IFEQ DEBUG
00000E54  1439 00C00003           2372mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E5A  0802 0002               2373mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E5E  67F4                    2374mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E60  13D9 00C00007           2375mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E66                          2376mmm     ENDC
00000E66                          2377mmm 
00000E66                 FALSE    2378mmm     IFNE DEBUG
00000E66                          2379mmm     ENDC
00000E66                          2380mmm 
00000E66                          2381mmm     ENDM
00000E66  60E4                    2382mm     BRA LOOP_160
00000E68                          2383mm EXIT_160
00000E68                          2384mm     ENDM
00000E68                          2385m     ENDM
00000E68                          2386  
00000E68  2041                    2387      MOVE.L D1,A0                                    ; target address
00000E6A  2641                    2388      MOVE.L D1,A3                                    ; keep a copy for later
00000E6C                          2389  
00000E6C  2247                    2390      MOVE.L D7,A1                                    ; address accumulator -> address register
00000E6E  D3FC 00000104           2391      ADD.L #START,A1                                 ; skip the vectors
00000E74  2847                    2392      MOVE.L D7,A4                                    ; keep a clean copy for later
00000E76  7E00                    2393      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E78                          2394  
00000E78                          2395m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000E78  31FC AAAA 2AAA          2396m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E7E  4E71                    2397m     NOP
00000E80  31FC 5555 1554          2398m     MOVE.W #$5555,$1554
00000E86  4E71                    2399m     NOP
00000E88  31FC 8080 2AAA          2400m     MOVE.W #$8080,$2AAA
00000E8E  4E71                    2401m     NOP
00000E90  31FC AAAA 2AAA          2402m     MOVE.W #$AAAA,$2AAA
00000E96  4E71                    2403m     NOP
00000E98  31FC 5555 1554          2404m     MOVE.W #$5555,$1554
00000E9E  4E71                    2405m     NOP
00000EA0  31FC 2020 2AAA          2406m     MOVE.W #$2020,$2AAA
00000EA6                          2407m     ENDM
00000EA6                          2408                                  
00000EA6  45FA 09EC               2409      LEA LOADING(PC),A2
00000EAA                          2410m     PRINT_STR A2,D2
00000EAA                          2411m LOOP_163
00000EAA  0C12 0000               2412m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EAE  6700 0016               2413m     BEQ EXIT_163
00000EB2                          2414mm     PRINT_CHAR (A2)+,D2
00000EB2                          2415mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EB2                 TRUE     2416mm     IFEQ DEBUG
00000EB2  1439 00C00003           2417mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EB8  0802 0002               2418mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EBC  67F4                    2419mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EBE  13DA 00C00007           2420mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EC4                          2421mm     ENDC
00000EC4                          2422mm 
00000EC4                 FALSE    2423mm     IFNE DEBUG
00000EC4                          2424mm     ENDC
00000EC4                          2425mm 
00000EC4                          2426mm     ENDM
00000EC4  60E4                    2427m     BRA LOOP_163
00000EC6                          2428m EXIT_163
00000EC6                          2429m     ENDM
00000EC6  45FA 09CC               2430      LEA LOADING(PC),A2
00000ECA                          2431m     PRINT_STR A2,D2
00000ECA                          2432m LOOP_165
00000ECA  0C12 0000               2433m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000ECE  6700 0016               2434m     BEQ EXIT_165
00000ED2                          2435mm     PRINT_CHAR (A2)+,D2
00000ED2                          2436mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ED2                 TRUE     2437mm     IFEQ DEBUG
00000ED2  1439 00C00003           2438mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000ED8  0802 0002               2439mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EDC  67F4                    2440mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000EDE  13DA 00C00007           2441mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EE4                          2442mm     ENDC
00000EE4                          2443mm 
00000EE4                 FALSE    2444mm     IFNE DEBUG
00000EE4                          2445mm     ENDC
00000EE4                          2446mm 
00000EE4                          2447mm     ENDM
00000EE4  60E4                    2448m     BRA LOOP_165
00000EE6                          2449m EXIT_165
00000EE6                          2450m     ENDM
00000EE6                          2451          
00000EE6  2409                    2452      MOVE.L A1,D2
00000EE8                          2453m     PRINT_REG D2,D3,D4,D5,A2
00000EE8  45FA 09C4               2454m     LEA OX(PC),A2
00000EEC                          2455mm     PRINT_STR A2,D3
00000EEC                          2456mm LOOP_168
00000EEC  0C12 0000               2457mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EF0  6700 0016               2458mm     BEQ EXIT_168
00000EF4                          2459mmm     PRINT_CHAR (A2)+,D3
00000EF4                          2460mmm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EF4                 TRUE     2461mmm     IFEQ DEBUG
00000EF4  1639 00C00003           2462mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EFA  0803 0002               2463mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EFE  67F4                    2464mmm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F00  13DA 00C00007           2465mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F06                          2466mmm     ENDC
00000F06                          2467mmm 
00000F06                 FALSE    2468mmm     IFNE DEBUG
00000F06                          2469mmm     ENDC
00000F06                          2470mmm 
00000F06                          2471mmm     ENDM
00000F06  60E4                    2472mm     BRA LOOP_168
00000F08                          2473mm EXIT_168
00000F08                          2474mm     ENDM
00000F08  7A07                    2475m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F0A                          2476m LOOP_167
00000F0A                          2477mm     BIN2HEX D2,D4,A2
00000F0A  45FA 0961               2478mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F0E  E99A                    2479mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F10  1802                    2480mm     MOVE.B D2,D4
00000F12  0284 0000000F           2481mm     ANDI.L #$F,D4
00000F18  1832 4000               2482mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F1C                          2483mm     ENDM
00000F1C                          2484mm     PRINT_CHAR D4,D3
00000F1C                          2485mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F1C                 TRUE     2486mm     IFEQ DEBUG
00000F1C  1639 00C00003           2487mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F22  0803 0002               2488mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F26  67F4                    2489mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F28  13C4 00C00007           2490mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F2E                          2491mm     ENDC
00000F2E                          2492mm 
00000F2E                 FALSE    2493mm     IFNE DEBUG
00000F2E                          2494mm     ENDC
00000F2E                          2495mm 
00000F2E                          2496mm     ENDM
00000F2E  57CD FFDA               2497m     DBEQ D5,LOOP_167
00000F32                          2498m     ENDM
00000F32                          2499  
00000F32  45FA 097D               2500      LEA TO(PC),A2
00000F36                          2501m     PRINT_STR A2,D3
00000F36                          2502m LOOP_172
00000F36  0C12 0000               2503m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F3A  6700 0016               2504m     BEQ EXIT_172
00000F3E                          2505mm     PRINT_CHAR (A2)+,D3
00000F3E                          2506mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F3E                 TRUE     2507mm     IFEQ DEBUG
00000F3E  1639 00C00003           2508mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F44  0803 0002               2509mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F48  67F4                    2510mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F4A  13DA 00C00007           2511mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F50                          2512mm     ENDC
00000F50                          2513mm 
00000F50                 FALSE    2514mm     IFNE DEBUG
00000F50                          2515mm     ENDC
00000F50                          2516mm 
00000F50                          2517mm     ENDM
00000F50  60E4                    2518m     BRA LOOP_172
00000F52                          2519m EXIT_172
00000F52                          2520m     ENDM
00000F52                          2521  
00000F52  2408                    2522      MOVE.L A0,D2
00000F54                          2523m     PRINT_REG D2,D3,D4,D5,A2
00000F54  45FA 0958               2524m     LEA OX(PC),A2
00000F58                          2525mm     PRINT_STR A2,D3
00000F58                          2526mm LOOP_175
00000F58  0C12 0000               2527mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F5C  6700 0016               2528mm     BEQ EXIT_175
00000F60                          2529mmm     PRINT_CHAR (A2)+,D3
00000F60                          2530mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F60                 TRUE     2531mmm     IFEQ DEBUG
00000F60  1639 00C00003           2532mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F66  0803 0002               2533mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F6A  67F4                    2534mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000F6C  13DA 00C00007           2535mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F72                          2536mmm     ENDC
00000F72                          2537mmm 
00000F72                 FALSE    2538mmm     IFNE DEBUG
00000F72                          2539mmm     ENDC
00000F72                          2540mmm 
00000F72                          2541mmm     ENDM
00000F72  60E4                    2542mm     BRA LOOP_175
00000F74                          2543mm EXIT_175
00000F74                          2544mm     ENDM
00000F74  7A07                    2545m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F76                          2546m LOOP_174
00000F76                          2547mm     BIN2HEX D2,D4,A2
00000F76  45FA 08F5               2548mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F7A  E99A                    2549mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F7C  1802                    2550mm     MOVE.B D2,D4
00000F7E  0284 0000000F           2551mm     ANDI.L #$F,D4
00000F84  1832 4000               2552mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F88                          2553mm     ENDM
00000F88                          2554mm     PRINT_CHAR D4,D3
00000F88                          2555mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F88                 TRUE     2556mm     IFEQ DEBUG
00000F88  1639 00C00003           2557mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F8E  0803 0002               2558mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F92  67F4                    2559mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000F94  13C4 00C00007           2560mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F9A                          2561mm     ENDC
00000F9A                          2562mm 
00000F9A                 FALSE    2563mm     IFNE DEBUG
00000F9A                          2564mm     ENDC
00000F9A                          2565mm 
00000F9A                          2566mm     ENDM
00000F9A  57CD FFDA               2567m     DBEQ D5,LOOP_174
00000F9E                          2568m     ENDM
00000F9E                          2569  
00000F9E  45FA 0916               2570      LEA FOR(PC),A2
00000FA2                          2571m     PRINT_STR A2,D3
00000FA2                          2572m LOOP_179
00000FA2  0C12 0000               2573m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FA6  6700 0016               2574m     BEQ EXIT_179
00000FAA                          2575mm     PRINT_CHAR (A2)+,D3
00000FAA                          2576mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FAA                 TRUE     2577mm     IFEQ DEBUG
00000FAA  1639 00C00003           2578mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FB0  0803 0002               2579mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FB4  67F4                    2580mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000FB6  13DA 00C00007           2581mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FBC                          2582mm     ENDC
00000FBC                          2583mm 
00000FBC                 FALSE    2584mm     IFNE DEBUG
00000FBC                          2585mm     ENDC
00000FBC                          2586mm 
00000FBC                          2587mm     ENDM
00000FBC  60E4                    2588m     BRA LOOP_179
00000FBE                          2589m EXIT_179
00000FBE                          2590m     ENDM
00000FBE                          2591m     PRINT_REG D0,D3,D4,D5,A2
00000FBE  45FA 08EE               2592m     LEA OX(PC),A2
00000FC2                          2593mm     PRINT_STR A2,D3
00000FC2                          2594mm LOOP_182
00000FC2  0C12 0000               2595mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FC6  6700 0016               2596mm     BEQ EXIT_182
00000FCA                          2597mmm     PRINT_CHAR (A2)+,D3
00000FCA                          2598mmm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FCA                 TRUE     2599mmm     IFEQ DEBUG
00000FCA  1639 00C00003           2600mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FD0  0803 0002               2601mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FD4  67F4                    2602mmm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000FD6  13DA 00C00007           2603mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FDC                          2604mmm     ENDC
00000FDC                          2605mmm 
00000FDC                 FALSE    2606mmm     IFNE DEBUG
00000FDC                          2607mmm     ENDC
00000FDC                          2608mmm 
00000FDC                          2609mmm     ENDM
00000FDC  60E4                    2610mm     BRA LOOP_182
00000FDE                          2611mm EXIT_182
00000FDE                          2612mm     ENDM
00000FDE  7A07                    2613m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FE0                          2614m LOOP_181
00000FE0                          2615mm     BIN2HEX D0,D4,A2
00000FE0  45FA 088B               2616mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FE4  E998                    2617mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FE6  1800                    2618mm     MOVE.B D0,D4
00000FE8  0284 0000000F           2619mm     ANDI.L #$F,D4
00000FEE  1832 4000               2620mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FF2                          2621mm     ENDM
00000FF2                          2622mm     PRINT_CHAR D4,D3
00000FF2                          2623mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FF2                 TRUE     2624mm     IFEQ DEBUG
00000FF2  1639 00C00003           2625mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FF8  0803 0002               2626mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FFC  67F4                    2627mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00000FFE  13C4 00C00007           2628mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001004                          2629mm     ENDC
00001004                          2630mm 
00001004                 FALSE    2631mm     IFNE DEBUG
00001004                          2632mm     ENDC
00001004                          2633mm 
00001004                          2634mm     ENDM
00001004  57CD FFDA               2635m     DBEQ D5,LOOP_181
00001008                          2636m     ENDM
00001008                          2637  
00001008                          2638m     PRINT_CRLF D3,A2
00001008  45FA 089E               2639m     LEA CRLF(PC),A2
0000100C                          2640mm     PRINT_STR A2,D3
0000100C                          2641mm LOOP_187
0000100C  0C12 0000               2642mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001010  6700 0016               2643mm     BEQ EXIT_187
00001014                          2644mmm     PRINT_CHAR (A2)+,D3
00001014                          2645mmm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001014                 TRUE     2646mmm     IFEQ DEBUG
00001014  1639 00C00003           2647mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000101A  0803 0002               2648mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000101E  67F4                    2649mmm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00001020  13DA 00C00007           2650mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001026                          2651mmm     ENDC
00001026                          2652mmm 
00001026                 FALSE    2653mmm     IFNE DEBUG
00001026                          2654mmm     ENDC
00001026                          2655mmm 
00001026                          2656mmm     ENDM
00001026  60E4                    2657mm     BRA LOOP_187
00001028                          2658mm EXIT_187
00001028                          2659mm     ENDM
00001028                          2660m     ENDM
00001028                          2661  
00001028                          2662      WHILE D0 <GT> #0 DO
00001028                          2663s _10000014
00001028  B07C 0000               2664s     CMP.W   #0,D0
0000102C  6F00 001C               2665s     BLE _10000015
00001030  5580                    2666          SUB.L #2,D0
00001032                          2667  
00001032  13D1 00E00001           2668          MOVE.B (A1),DISPLAY
00001038                          2669m         PROGRAM (A1),(A0),D2
00001038  3091                    2670m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
0000103A                          2671m 
0000103A                          2672m WAIT_FOR_COMPLETE_189
0000103A  3410                    2673m         MOVE.W (A0),D2
0000103C                          2674m 
0000103C                          2675m         IF.W D2 <NE> (A1) THEN
0000103C  B451                    2676ms     CMP.W   (A1),D2
0000103E  6700 0004               2677ms     BEQ _0000000E
00001042  60F6                    2678m             BRA WAIT_FOR_COMPLETE_189
00001044                          2679m         ENDI
00001044                          2680ms _0000000E
00001044                          2681m         ENDM
00001044                          2682                  
00001044  5488                    2683          ADD.L #2,A0
00001046  5489                    2684          ADD.L #2,A1
00001048                          2685      ENDW
00001048  60DE                    2686s     BRA _10000014
0000104A                          2687s _10000015
0000104A                          2688      
0000104A  41F8 0000               2689      LEA STACK,A0
0000104E  D1CC                    2690      ADD.L A4,A0
00001050  2010                    2691      MOVE.L (A0),D0
00001052                          2692      
00001052  207C 00000000           2693      MOVE.L #0,A0
00001058                          2694m     PROGRAM_VECTOR D0,A0,D2
00001058  5488                    2695m     ADD.L #2,A0
0000105A                          2696mm     PROGRAM D0, (A0), D2                                ; WRITE IT
0000105A  3080                    2697mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000105C                          2698mm 
0000105C                          2699mm WAIT_FOR_COMPLETE_191
0000105C  3410                    2700mm         MOVE.W (A0),D2
0000105E                          2701mm 
0000105E                          2702mm         IF.W D2 <NE> D0 THEN
0000105E  B440                    2703mms     CMP.W   D0,D2
00001060  6700 0004               2704mms     BEQ _0000000F
00001064  60F6                    2705mm             BRA WAIT_FOR_COMPLETE_191
00001066                          2706mm         ENDI
00001066                          2707mms _0000000F
00001066                          2708mm         ENDM
00001066  E088                    2709m     LSR.L #8,D0
00001068  E088                    2710m     LSR.L #8,D0
0000106A  5588                    2711m     SUB.L #2,A0
0000106C                          2712mm     PROGRAM D0, (A0), D2
0000106C  3080                    2713mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000106E                          2714mm 
0000106E                          2715mm WAIT_FOR_COMPLETE_192
0000106E  3410                    2716mm         MOVE.W (A0),D2
00001070                          2717mm 
00001070                          2718mm         IF.W D2 <NE> D0 THEN
00001070  B440                    2719mms     CMP.W   D0,D2
00001072  6700 0004               2720mms     BEQ _00000010
00001076  60F6                    2721mm             BRA WAIT_FOR_COMPLETE_192
00001078                          2722mm         ENDI
00001078                          2723mms _00000010
00001078                          2724mm         ENDM
00001078                          2725m     ENDM
00001078                          2726      
00001078                          2727      FOR A0 = #RESET TO #START-4 BY #4 DO
00001078  307C 0004               2728s     MOVE.W  #RESET,A0
0000107C  6000 0034               2729s     BRA _2000000D
00001080                          2730s _2000000C
00001080                          2731  
00001080  2248                    2732          MOVE.L A0,A1
00001082  D3CC                    2733          ADD.L A4,A1
00001084                          2734              
00001084  2011                    2735          MOVE.L (A1),D0  
00001086  D081                    2736          ADD.L D1,D0
00001088  0480 00000104           2737          SUB.L #START,D0
0000108E                          2738  
0000108E  2408                    2739          MOVE.L A0,D2
00001090                          2740          
00001090                          2741m         PROGRAM_VECTOR D0,A0,D2
00001090  5488                    2742m     ADD.L #2,A0
00001092                          2743mm     PROGRAM D0, (A0), D2                                ; WRITE IT
00001092  3080                    2744mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001094                          2745mm 
00001094                          2746mm WAIT_FOR_COMPLETE_194
00001094  3410                    2747mm         MOVE.W (A0),D2
00001096                          2748mm 
00001096                          2749mm         IF.W D2 <NE> D0 THEN
00001096  B440                    2750mms     CMP.W   D0,D2
00001098  6700 0004               2751mms     BEQ _00000011
0000109C  60F6                    2752mm             BRA WAIT_FOR_COMPLETE_194
0000109E                          2753mm         ENDI
0000109E                          2754mms _00000011
0000109E                          2755mm         ENDM
0000109E  E088                    2756m     LSR.L #8,D0
000010A0  E088                    2757m     LSR.L #8,D0
000010A2  5588                    2758m     SUB.L #2,A0
000010A4                          2759mm     PROGRAM D0, (A0), D2
000010A4  3080                    2760mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010A6                          2761mm 
000010A6                          2762mm WAIT_FOR_COMPLETE_195
000010A6  3410                    2763mm         MOVE.W (A0),D2
000010A8                          2764mm 
000010A8                          2765mm         IF.W D2 <NE> D0 THEN
000010A8  B440                    2766mms     CMP.W   D0,D2
000010AA  6700 0004               2767mms     BEQ _00000012
000010AE  60F6                    2768mm             BRA WAIT_FOR_COMPLETE_195
000010B0                          2769mm         ENDI
000010B0                          2770mms _00000012
000010B0                          2771mm         ENDM
000010B0                          2772m     ENDM
000010B0                          2773      ENDF
000010B0  5848                    2774s     ADD.W   #4,A0
000010B2                          2775s _2000000D
000010B2  B0FC 0100               2776s     CMP.W   #START-4,A0
000010B6  6FC8                    2777s     BLE _2000000C
000010B8                          2778                                          
000010B8                          2779m     PROTECT
000010B8  31FC AAAA 2AAA          2780m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010BE  31FC 5555 1554          2781m     MOVE.W #$5555,$1554
000010C4  31FC A0A0 2AAA          2782m     MOVE.W #$A0A0,$2AAA
000010CA                          2783m     ENDM
000010CA                          2784  
000010CA  6000 F250               2785      BRA MAIN_LOOP
000010CE                          2786      
000010CE                          2787  P
000010CE  7000                    2788      MOVE.L #0,D0                                    ; D0 will be the data to write
000010D0                          2789  
000010D0                          2790      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000010D0  323C 0000               2791s     MOVE.W  #0,D1
000010D4  6000 0046               2792s     BRA _2000000F
000010D8                          2793s _2000000E
000010D8  E988                    2794          LSL.L #4,D0                                 ; make what we have so far more significant
000010DA                          2795m         WAIT_CHAR D2,D3                             ; next character -> D2
000010DA                          2796m WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010DA                 TRUE     2797m     IFEQ DEBUG
000010DA  1639 00C00003           2798m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010E0  0803 0000               2799m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000010E4  67F4                    2800m         BEQ WAIT_FOR_READY_197                      ; NOTHING, CHECK AGAIN
000010E6                          2801m     ENDC
000010E6                          2802m 
000010E6                          2803mm     READ_CHAR D2
000010E6                 TRUE     2804mm     IFEQ DEBUG
000010E6  1439 00C00007           2805mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000010EC                          2806mm     ENDC
000010EC                 FALSE    2807mm     IFNE DEBUG
000010EC                          2808mm     ENDC
000010EC                          2809mm 
000010EC  B43C 001B               2810mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000010F0  6700 F012               2811mm     BEQ START
000010F4                          2812mm     ENDM
000010F4                          2813m 
000010F4                 TRUE     2814m     IFEQ DEBUG
000010F4                          2815mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000010F4                          2816mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010F4                 TRUE     2817mm     IFEQ DEBUG
000010F4  1639 00C00003           2818mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010FA  0803 0002               2819mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010FE  67F4                    2820mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001100  13C2 00C00007           2821mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001106                          2822mm     ENDC
00001106                          2823mm 
00001106                 FALSE    2824mm     IFNE DEBUG
00001106                          2825mm     ENDC
00001106                          2826mm 
00001106                          2827mm     ENDM
00001106                          2828m     ENDC
00001106                          2829m     ENDM
00001106                          2830m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001106  41FA 0775               2831m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000110A  0402 0030               2832m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000110E  C4BC 000000FF           2833m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001114  1430 2000               2834m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001118                          2835m     ENDM
00001118  8002                    2836          OR.B D2,D0
0000111A                          2837      ENDF
0000111A  5241                    2838s     ADD.W   #1,D1
0000111C                          2839s _2000000F
0000111C  B27C 0003               2840s     CMP.W   #3,D1
00001120  6FB6                    2841s     BLE _2000000E
00001122                          2842  
00001122                          2843m     PRINT_CRLF D2,A1
00001122  43FA 0784               2844m     LEA CRLF(PC),A1
00001126                          2845mm     PRINT_STR A1,D2
00001126                          2846mm LOOP_202
00001126  0C11 0000               2847mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000112A  6700 0016               2848mm     BEQ EXIT_202
0000112E                          2849mmm     PRINT_CHAR (A1)+,D2
0000112E                          2850mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000112E                 TRUE     2851mmm     IFEQ DEBUG
0000112E  1439 00C00003           2852mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001134  0802 0002               2853mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001138  67F4                    2854mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
0000113A  13D9 00C00007           2855mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001140                          2856mmm     ENDC
00001140                          2857mmm 
00001140                 FALSE    2858mmm     IFNE DEBUG
00001140                          2859mmm     ENDC
00001140                          2860mmm 
00001140                          2861mmm     ENDM
00001140  60E4                    2862mm     BRA LOOP_202
00001142                          2863mm EXIT_202
00001142                          2864mm     ENDM
00001142                          2865m     ENDM
00001142                          2866  
00001142  2047                    2867      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001144  7E00                    2868      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001146                          2869  
00001146                          2870m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001146  31FC AAAA 2AAA          2871m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000114C  4E71                    2872m     NOP
0000114E  31FC 5555 1554          2873m     MOVE.W #$5555,$1554
00001154  4E71                    2874m     NOP
00001156  31FC 8080 2AAA          2875m     MOVE.W #$8080,$2AAA
0000115C  4E71                    2876m     NOP
0000115E  31FC AAAA 2AAA          2877m     MOVE.W #$AAAA,$2AAA
00001164  4E71                    2878m     NOP
00001166  31FC 5555 1554          2879m     MOVE.W #$5555,$1554
0000116C  4E71                    2880m     NOP
0000116E  31FC 2020 2AAA          2881m     MOVE.W #$2020,$2AAA
00001174                          2882m     ENDM
00001174                          2883                              
00001174                          2884      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001174  3E3C 0000               2885s     MOVE.W  #$0,D7
00001178  6000 0006               2886s     BRA _20000011
0000117C                          2887s _20000010
0000117C  4E71                    2888          NOP
0000117E                          2889      ENDF
0000117E  5247                    2890s     ADD.W   #1,D7
00001180                          2891s _20000011
00001180  BE7C FFFF               2892s     CMP.W   #$FFFFFFFF,D7
00001184  6FF6                    2893s     BLE _20000010
00001186                          2894               
00001186  45FA 070C               2895      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000118A                          2896m     PRINT_STR A2,D2
0000118A                          2897m LOOP_205
0000118A  0C12 0000               2898m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000118E  6700 0016               2899m     BEQ EXIT_205
00001192                          2900mm     PRINT_CHAR (A2)+,D2
00001192                          2901mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001192                 TRUE     2902mm     IFEQ DEBUG
00001192  1439 00C00003           2903mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001198  0802 0002               2904mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000119C  67F4                    2905mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
0000119E  13DA 00C00007           2906mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011A4                          2907mm     ENDC
000011A4                          2908mm 
000011A4                 FALSE    2909mm     IFNE DEBUG
000011A4                          2910mm     ENDC
000011A4                          2911mm 
000011A4                          2912mm     ENDM
000011A4  60E4                    2913m     BRA LOOP_205
000011A6                          2914m EXIT_205
000011A6                          2915m     ENDM
000011A6                          2916  
000011A6                          2917m     PRINT_REG D0,D3,D4,D5,A2
000011A6  45FA 0706               2918m     LEA OX(PC),A2
000011AA                          2919mm     PRINT_STR A2,D3
000011AA                          2920mm LOOP_208
000011AA  0C12 0000               2921mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011AE  6700 0016               2922mm     BEQ EXIT_208
000011B2                          2923mmm     PRINT_CHAR (A2)+,D3
000011B2                          2924mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011B2                 TRUE     2925mmm     IFEQ DEBUG
000011B2  1639 00C00003           2926mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011B8  0803 0002               2927mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011BC  67F4                    2928mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
000011BE  13DA 00C00007           2929mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011C4                          2930mmm     ENDC
000011C4                          2931mmm 
000011C4                 FALSE    2932mmm     IFNE DEBUG
000011C4                          2933mmm     ENDC
000011C4                          2934mmm 
000011C4                          2935mmm     ENDM
000011C4  60E4                    2936mm     BRA LOOP_208
000011C6                          2937mm EXIT_208
000011C6                          2938mm     ENDM
000011C6  7A07                    2939m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011C8                          2940m LOOP_207
000011C8                          2941mm     BIN2HEX D0,D4,A2
000011C8  45FA 06A3               2942mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011CC  E998                    2943mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011CE  1800                    2944mm     MOVE.B D0,D4
000011D0  0284 0000000F           2945mm     ANDI.L #$F,D4
000011D6  1832 4000               2946mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011DA                          2947mm     ENDM
000011DA                          2948mm     PRINT_CHAR D4,D3
000011DA                          2949mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011DA                 TRUE     2950mm     IFEQ DEBUG
000011DA  1639 00C00003           2951mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011E0  0803 0002               2952mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011E4  67F4                    2953mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000011E6  13C4 00C00007           2954mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011EC                          2955mm     ENDC
000011EC                          2956mm 
000011EC                 FALSE    2957mm     IFNE DEBUG
000011EC                          2958mm     ENDC
000011EC                          2959mm 
000011EC                          2960mm     ENDM
000011EC  57CD FFDA               2961m     DBEQ D5,LOOP_207
000011F0                          2962m     ENDM
000011F0                          2963  
000011F0  45FA 06BF               2964      LEA TO(PC),A2
000011F4                          2965m     PRINT_STR A2,D3
000011F4                          2966m LOOP_212
000011F4  0C12 0000               2967m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011F8  6700 0016               2968m     BEQ EXIT_212
000011FC                          2969mm     PRINT_CHAR (A2)+,D3
000011FC                          2970mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011FC                 TRUE     2971mm     IFEQ DEBUG
000011FC  1639 00C00003           2972mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001202  0803 0002               2973mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001206  67F4                    2974mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
00001208  13DA 00C00007           2975mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000120E                          2976mm     ENDC
0000120E                          2977mm 
0000120E                 FALSE    2978mm     IFNE DEBUG
0000120E                          2979mm     ENDC
0000120E                          2980mm 
0000120E                          2981mm     ENDM
0000120E  60E4                    2982m     BRA LOOP_212
00001210                          2983m EXIT_212
00001210                          2984m     ENDM
00001210                          2985  
00001210  2408                    2986      MOVE.L A0,D2
00001212                          2987m     PRINT_REG D2,D3,D4,D5,A2
00001212  45FA 069A               2988m     LEA OX(PC),A2
00001216                          2989mm     PRINT_STR A2,D3
00001216                          2990mm LOOP_215
00001216  0C12 0000               2991mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000121A  6700 0016               2992mm     BEQ EXIT_215
0000121E                          2993mmm     PRINT_CHAR (A2)+,D3
0000121E                          2994mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121E                 TRUE     2995mmm     IFEQ DEBUG
0000121E  1639 00C00003           2996mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001224  0803 0002               2997mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001228  67F4                    2998mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
0000122A  13DA 00C00007           2999mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001230                          3000mmm     ENDC
00001230                          3001mmm 
00001230                 FALSE    3002mmm     IFNE DEBUG
00001230                          3003mmm     ENDC
00001230                          3004mmm 
00001230                          3005mmm     ENDM
00001230  60E4                    3006mm     BRA LOOP_215
00001232                          3007mm EXIT_215
00001232                          3008mm     ENDM
00001232  7A07                    3009m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001234                          3010m LOOP_214
00001234                          3011mm     BIN2HEX D2,D4,A2
00001234  45FA 0637               3012mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001238  E99A                    3013mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000123A  1802                    3014mm     MOVE.B D2,D4
0000123C  0284 0000000F           3015mm     ANDI.L #$F,D4
00001242  1832 4000               3016mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001246                          3017mm     ENDM
00001246                          3018mm     PRINT_CHAR D4,D3
00001246                          3019mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001246                 TRUE     3020mm     IFEQ DEBUG
00001246  1639 00C00003           3021mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000124C  0803 0002               3022mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001250  67F4                    3023mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001252  13C4 00C00007           3024mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001258                          3025mm     ENDC
00001258                          3026mm 
00001258                 FALSE    3027mm     IFNE DEBUG
00001258                          3028mm     ENDC
00001258                          3029mm 
00001258                          3030mm     ENDM
00001258  57CD FFDA               3031m     DBEQ D5,LOOP_214
0000125C                          3032m     ENDM
0000125C                          3033  
0000125C                          3034m     PRINT_CRLF D3,A2
0000125C  45FA 064A               3035m     LEA CRLF(PC),A2
00001260                          3036mm     PRINT_STR A2,D3
00001260                          3037mm LOOP_220
00001260  0C12 0000               3038mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001264  6700 0016               3039mm     BEQ EXIT_220
00001268                          3040mmm     PRINT_CHAR (A2)+,D3
00001268                          3041mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001268                 TRUE     3042mmm     IFEQ DEBUG
00001268  1639 00C00003           3043mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126E  0803 0002               3044mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001272  67F4                    3045mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001274  13DA 00C00007           3046mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000127A                          3047mmm     ENDC
0000127A                          3048mmm 
0000127A                 FALSE    3049mmm     IFNE DEBUG
0000127A                          3050mmm     ENDC
0000127A                          3051mmm 
0000127A                          3052mmm     ENDM
0000127A  60E4                    3053mm     BRA LOOP_220
0000127C                          3054mm EXIT_220
0000127C                          3055mm     ENDM
0000127C                          3056m     ENDM
0000127C                          3057  
0000127C                          3058m     PROGRAM D0,(A0),D2
0000127C  3080                    3059m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000127E                          3060m 
0000127E                          3061m WAIT_FOR_COMPLETE_222
0000127E  3410                    3062m         MOVE.W (A0),D2
00001280                          3063m 
00001280                          3064m         IF.W D2 <NE> D0 THEN
00001280  B440                    3065ms     CMP.W   D0,D2
00001282  6700 0004               3066ms     BEQ _00000013
00001286  60F6                    3067m             BRA WAIT_FOR_COMPLETE_222
00001288                          3068m         ENDI
00001288                          3069ms _00000013
00001288                          3070m         ENDM
00001288                          3071  
00001288                          3072m     PROTECT
00001288  31FC AAAA 2AAA          3073m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000128E  31FC 5555 1554          3074m     MOVE.W #$5555,$1554
00001294  31FC A0A0 2AAA          3075m     MOVE.W #$A0A0,$2AAA
0000129A                          3076m     ENDM
0000129A                          3077  
0000129A  6000 F080               3078      BRA MAIN_LOOP
0000129E                          3079      
0000129E                          3080  M
0000129E  7000                    3081      MOVE.L #0,D0                                        ; D0 will be the length to read            
000012A0  7200                    3082      MOVE.L #0,D1                                        ; D1 will be the address to read 
000012A2                          3083  
000012A2                          3084      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
000012A2  343C 0000               3085s     MOVE.W  #0,D2
000012A6  6000 0046               3086s     BRA _20000013
000012AA                          3087s _20000012
000012AA  E989                    3088          LSL.L #4,D1                                     ; make what we have so far more significant
000012AC                          3089m         WAIT_CHAR D3,D4                                 ; next character -> D2
000012AC                          3090m WAIT_FOR_READY_224                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012AC                 TRUE     3091m     IFEQ DEBUG
000012AC  1839 00C00003           3092m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000012B2  0804 0000               3093m         BTST #0,D4                                  ; CHECK FOR CHARACTER
000012B6  67F4                    3094m         BEQ WAIT_FOR_READY_224                      ; NOTHING, CHECK AGAIN
000012B8                          3095m     ENDC
000012B8                          3096m 
000012B8                          3097mm     READ_CHAR D3
000012B8                 TRUE     3098mm     IFEQ DEBUG
000012B8  1639 00C00007           3099mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
000012BE                          3100mm     ENDC
000012BE                 FALSE    3101mm     IFNE DEBUG
000012BE                          3102mm     ENDC
000012BE                          3103mm 
000012BE  B63C 001B               3104mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
000012C2  6700 EE40               3105mm     BEQ START
000012C6                          3106mm     ENDM
000012C6                          3107m 
000012C6                 TRUE     3108m     IFEQ DEBUG
000012C6                          3109mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
000012C6                          3110mm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012C6                 TRUE     3111mm     IFEQ DEBUG
000012C6  1839 00C00003           3112mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000012CC  0804 0002               3113mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
000012D0  67F4                    3114mm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012D2  13C3 00C00007           3115mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012D8                          3116mm     ENDC
000012D8                          3117mm 
000012D8                 FALSE    3118mm     IFNE DEBUG
000012D8                          3119mm     ENDC
000012D8                          3120mm 
000012D8                          3121mm     ENDM
000012D8                          3122m     ENDC
000012D8                          3123m     ENDM
000012D8                          3124m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
000012D8  41FA 05A3               3125m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000012DC  0403 0030               3126m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000012E0  C6BC 000000FF           3127m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
000012E6  1630 3000               3128m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
000012EA                          3129m     ENDM
000012EA  8203                    3130          OR.B D3,D1
000012EC                          3131      ENDF
000012EC  5242                    3132s     ADD.W   #1,D2
000012EE                          3133s _20000013
000012EE  B47C 0007               3134s     CMP.W   #7,D2
000012F2  6FB6                    3135s     BLE _20000012
000012F4                          3136m     PRINT_CRLF D2,A1
000012F4  43FA 05B2               3137m     LEA CRLF(PC),A1
000012F8                          3138mm     PRINT_STR A1,D2
000012F8                          3139mm LOOP_229
000012F8  0C11 0000               3140mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000012FC  6700 0016               3141mm     BEQ EXIT_229
00001300                          3142mmm     PRINT_CHAR (A1)+,D2
00001300                          3143mmm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001300                 TRUE     3144mmm     IFEQ DEBUG
00001300  1439 00C00003           3145mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001306  0802 0002               3146mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000130A  67F4                    3147mmm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
0000130C  13D9 00C00007           3148mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001312                          3149mmm     ENDC
00001312                          3150mmm 
00001312                 FALSE    3151mmm     IFNE DEBUG
00001312                          3152mmm     ENDC
00001312                          3153mmm 
00001312                          3154mmm     ENDM
00001312  60E4                    3155mm     BRA LOOP_229
00001314                          3156mm EXIT_229
00001314                          3157mm     ENDM
00001314                          3158m     ENDM
00001314                          3159  
00001314  3001                    3160      MOVE.W D1,D0                                        ; extract the LSword for the length
00001316  E089                    3161      LSR.L #8,D1                                         ; extract the MSword for the address
00001318  E089                    3162      LSR.L #8,D1
0000131A                          3163  
0000131A  2241                    3164      MOVE.L D1,A1
0000131C                          3165      
0000131C  2047                    3166      MOVE.L D7,A0                                        ; address accumulator -> target address register
0000131E                          3167      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
0000131E                          3168  
0000131E                          3169      WHILE D0 <GT> #0 DO
0000131E                          3170s _10000016
0000131E  B07C 0000               3171s     CMP.W   #0,D0
00001322  6F00 000E               3172s     BLE _10000017
00001326  5580                    3173          SUB.L #2,D0
00001328                          3174  
00001328  13D1 00E00001           3175          MOVE.B (A1),DISPLAY
0000132E  30D9                    3176          MOVE.W (A1)+,(A0)+
00001330                          3177      ENDW
00001330  60EC                    3178s     BRA _10000016
00001332                          3179s _10000017
00001332                          3180      
00001332  6000 EFE8               3181      BRA MAIN_LOOP
00001336                          3182  
00001336                          3183  X
00001336  45FA 0589               3184      LEA STATUS_REGISTER(PC),A2
0000133A                          3185m     PRINT_STR A2,D3
0000133A                          3186m LOOP_231
0000133A  0C12 0000               3187m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000133E  6700 0016               3188m     BEQ EXIT_231
00001342                          3189mm     PRINT_CHAR (A2)+,D3
00001342                          3190mm WAIT_FOR_READY_232                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001342                 TRUE     3191mm     IFEQ DEBUG
00001342  1639 00C00003           3192mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001348  0803 0002               3193mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000134C  67F4                    3194mm         BEQ WAIT_FOR_READY_232                      ; NO SPACE, CHECK AGAIN
0000134E  13DA 00C00007           3195mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001354                          3196mm     ENDC
00001354                          3197mm 
00001354                 FALSE    3198mm     IFNE DEBUG
00001354                          3199mm     ENDC
00001354                          3200mm 
00001354                          3201mm     ENDM
00001354  60E4                    3202m     BRA LOOP_231
00001356                          3203m EXIT_231
00001356                          3204m     ENDM
00001356                          3205  
00001356  40C0                    3206      MOVE SR,D0
00001358                          3207m     PRINT_REG D0,D3,D4,D5,A2
00001358  45FA 0554               3208m     LEA OX(PC),A2
0000135C                          3209mm     PRINT_STR A2,D3
0000135C                          3210mm LOOP_234
0000135C  0C12 0000               3211mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001360  6700 0016               3212mm     BEQ EXIT_234
00001364                          3213mmm     PRINT_CHAR (A2)+,D3
00001364                          3214mmm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001364                 TRUE     3215mmm     IFEQ DEBUG
00001364  1639 00C00003           3216mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000136A  0803 0002               3217mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000136E  67F4                    3218mmm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
00001370  13DA 00C00007           3219mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001376                          3220mmm     ENDC
00001376                          3221mmm 
00001376                 FALSE    3222mmm     IFNE DEBUG
00001376                          3223mmm     ENDC
00001376                          3224mmm 
00001376                          3225mmm     ENDM
00001376  60E4                    3226mm     BRA LOOP_234
00001378                          3227mm EXIT_234
00001378                          3228mm     ENDM
00001378  7A07                    3229m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000137A                          3230m LOOP_233
0000137A                          3231mm     BIN2HEX D0,D4,A2
0000137A  45FA 04F1               3232mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000137E  E998                    3233mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001380  1800                    3234mm     MOVE.B D0,D4
00001382  0284 0000000F           3235mm     ANDI.L #$F,D4
00001388  1832 4000               3236mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000138C                          3237mm     ENDM
0000138C                          3238mm     PRINT_CHAR D4,D3
0000138C                          3239mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000138C                 TRUE     3240mm     IFEQ DEBUG
0000138C  1639 00C00003           3241mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001392  0803 0002               3242mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001396  67F4                    3243mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
00001398  13C4 00C00007           3244mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000139E                          3245mm     ENDC
0000139E                          3246mm 
0000139E                 FALSE    3247mm     IFNE DEBUG
0000139E                          3248mm     ENDC
0000139E                          3249mm 
0000139E                          3250mm     ENDM
0000139E  57CD FFDA               3251m     DBEQ D5,LOOP_233
000013A2                          3252m     ENDM
000013A2                          3253m     PRINT_CRLF D3,A2
000013A2  45FA 0504               3254m     LEA CRLF(PC),A2
000013A6                          3255mm     PRINT_STR A2,D3
000013A6                          3256mm LOOP_239
000013A6  0C12 0000               3257mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013AA  6700 0016               3258mm     BEQ EXIT_239
000013AE                          3259mmm     PRINT_CHAR (A2)+,D3
000013AE                          3260mmm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013AE                 TRUE     3261mmm     IFEQ DEBUG
000013AE  1639 00C00003           3262mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013B4  0803 0002               3263mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013B8  67F4                    3264mmm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
000013BA  13DA 00C00007           3265mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013C0                          3266mmm     ENDC
000013C0                          3267mmm 
000013C0                 FALSE    3268mmm     IFNE DEBUG
000013C0                          3269mmm     ENDC
000013C0                          3270mmm 
000013C0                          3271mmm     ENDM
000013C0  60E4                    3272mm     BRA LOOP_239
000013C2                          3273mm EXIT_239
000013C2                          3274mm     ENDM
000013C2                          3275m     ENDM
000013C2                          3276  
000013C2  45FA 04F8               3277      LEA STACK_POINTER(PC),A2
000013C6                          3278m     PRINT_STR A2,D3
000013C6                          3279m LOOP_241
000013C6  0C12 0000               3280m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013CA  6700 0016               3281m     BEQ EXIT_241
000013CE                          3282mm     PRINT_CHAR (A2)+,D3
000013CE                          3283mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013CE                 TRUE     3284mm     IFEQ DEBUG
000013CE  1639 00C00003           3285mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013D4  0803 0002               3286mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013D8  67F4                    3287mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
000013DA  13DA 00C00007           3288mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013E0                          3289mm     ENDC
000013E0                          3290mm 
000013E0                 FALSE    3291mm     IFNE DEBUG
000013E0                          3292mm     ENDC
000013E0                          3293mm 
000013E0                          3294mm     ENDM
000013E0  60E4                    3295m     BRA LOOP_241
000013E2                          3296m EXIT_241
000013E2                          3297m     ENDM
000013E2                          3298  
000013E2  200F                    3299      MOVE.L SP,D0
000013E4                          3300m     PRINT_REG D0,D3,D4,D5,A2
000013E4  45FA 04C8               3301m     LEA OX(PC),A2
000013E8                          3302mm     PRINT_STR A2,D3
000013E8                          3303mm LOOP_244
000013E8  0C12 0000               3304mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013EC  6700 0016               3305mm     BEQ EXIT_244
000013F0                          3306mmm     PRINT_CHAR (A2)+,D3
000013F0                          3307mmm WAIT_FOR_READY_245                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013F0                 TRUE     3308mmm     IFEQ DEBUG
000013F0  1639 00C00003           3309mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013F6  0803 0002               3310mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013FA  67F4                    3311mmm         BEQ WAIT_FOR_READY_245                      ; NO SPACE, CHECK AGAIN
000013FC  13DA 00C00007           3312mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001402                          3313mmm     ENDC
00001402                          3314mmm 
00001402                 FALSE    3315mmm     IFNE DEBUG
00001402                          3316mmm     ENDC
00001402                          3317mmm 
00001402                          3318mmm     ENDM
00001402  60E4                    3319mm     BRA LOOP_244
00001404                          3320mm EXIT_244
00001404                          3321mm     ENDM
00001404  7A07                    3322m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001406                          3323m LOOP_243
00001406                          3324mm     BIN2HEX D0,D4,A2
00001406  45FA 0465               3325mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000140A  E998                    3326mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000140C  1800                    3327mm     MOVE.B D0,D4
0000140E  0284 0000000F           3328mm     ANDI.L #$F,D4
00001414  1832 4000               3329mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001418                          3330mm     ENDM
00001418                          3331mm     PRINT_CHAR D4,D3
00001418                          3332mm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001418                 TRUE     3333mm     IFEQ DEBUG
00001418  1639 00C00003           3334mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000141E  0803 0002               3335mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001422  67F4                    3336mm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
00001424  13C4 00C00007           3337mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000142A                          3338mm     ENDC
0000142A                          3339mm 
0000142A                 FALSE    3340mm     IFNE DEBUG
0000142A                          3341mm     ENDC
0000142A                          3342mm 
0000142A                          3343mm     ENDM
0000142A  57CD FFDA               3344m     DBEQ D5,LOOP_243
0000142E                          3345m     ENDM
0000142E                          3346m     PRINT_CRLF D3,A2
0000142E  45FA 0478               3347m     LEA CRLF(PC),A2
00001432                          3348mm     PRINT_STR A2,D3
00001432                          3349mm LOOP_249
00001432  0C12 0000               3350mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001436  6700 0016               3351mm     BEQ EXIT_249
0000143A                          3352mmm     PRINT_CHAR (A2)+,D3
0000143A                          3353mmm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000143A                 TRUE     3354mmm     IFEQ DEBUG
0000143A  1639 00C00003           3355mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001440  0803 0002               3356mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001444  67F4                    3357mmm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
00001446  13DA 00C00007           3358mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000144C                          3359mmm     ENDC
0000144C                          3360mmm 
0000144C                 FALSE    3361mmm     IFNE DEBUG
0000144C                          3362mmm     ENDC
0000144C                          3363mmm 
0000144C                          3364mmm     ENDM
0000144C  60E4                    3365mm     BRA LOOP_249
0000144E                          3366mm EXIT_249
0000144E                          3367mm     ENDM
0000144E                          3368m     ENDM
0000144E                          3369  
0000144E  6000 EECC               3370      BRA MAIN_LOOP
00001452                          3371  
00001452                          3372          
00001452                          3373  I
00001452  13FC 0008 00C0000B      3374      MOVE.B #8,DUART_IMR
0000145A  027C F8FF               3375      AND.W #$F8FF,SR
0000145E  6000 EEBC               3376      BRA MAIN_LOOP
00001462                          3377      
00001462                          3378  O
00001462  13FC 0000 00C0000B      3379      MOVE.B #0,DUART_IMR
0000146A  007C 0700               3380      OR.W #$0700,SR
0000146E  6000 EEAC               3381      BRA MAIN_LOOP
00001472                          3382          
00001472                          3383  HASH
00001472                          3384m     PROTECT
00001472  31FC AAAA 2AAA          3385m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001478  31FC 5555 1554          3386m     MOVE.W #$5555,$1554
0000147E  31FC A0A0 2AAA          3387m     MOVE.W #$A0A0,$2AAA
00001484                          3388m     ENDM
00001484  6000 EE96               3389      BRA MAIN_LOOP
00001488                          3390  
00001488                          3391  
00001488                          3392  
00001488                          3393  HEX_DIGIT
00001488  E98F                    3394      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
0000148A                          3395m     HEX2BIN D2,D2,A0
0000148A  41FA 03F1               3396m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000148E  0402 0030               3397m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001492  C4BC 000000FF           3398m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001498  1430 2000               3399m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000149C                          3400m     ENDM
0000149C  8E02                    3401      OR.B D2,D7  
0000149E  6000 EE9C               3402      BRA GET_INPUT
000014A2                          3403  
000014A2  FFFF FFFF               3404      SIMHALT                                             ; halt simulator
000014A6                          3405  
000014A6                          3406  ; exceptions    
000014A6                          3407  BUS_ERROR_HANDLER
000014A6                          3408  
000014A6  41FA 0425               3409      LEA BUS_ERROR(PC),A0
000014AA                          3410m     PRINT_STR A0,D1
000014AA                          3411m LOOP_253
000014AA  0C10 0000               3412m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000014AE  6700 0016               3413m     BEQ EXIT_253
000014B2                          3414mm     PRINT_CHAR (A0)+,D1
000014B2                          3415mm WAIT_FOR_READY_254                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014B2                 TRUE     3416mm     IFEQ DEBUG
000014B2  1239 00C00003           3417mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000014B8  0801 0002               3418mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000014BC  67F4                    3419mm         BEQ WAIT_FOR_READY_254                      ; NO SPACE, CHECK AGAIN
000014BE  13D8 00C00007           3420mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014C4                          3421mm     ENDC
000014C4                          3422mm 
000014C4                 FALSE    3423mm     IFNE DEBUG
000014C4                          3424mm     ENDC
000014C4                          3425mm 
000014C4                          3426mm     ENDM
000014C4  60E4                    3427m     BRA LOOP_253
000014C6                          3428m EXIT_253
000014C6                          3429m     ENDM
000014C6                          3430  
000014C6  7000                    3431      MOVE.L #0,D0
000014C8  3017                    3432      MOVE.W (SP),D0
000014CA                          3433  
000014CA  0800 0004               3434      BTST #4,D0
000014CE  6700 0026               3435      BEQ WRITE
000014D2                          3436      
000014D2  41FA 040E               3437      LEA READING(PC),A0
000014D6                          3438m     PRINT_STR A0,D1
000014D6                          3439m LOOP_255
000014D6  0C10 0000               3440m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000014DA  6700 0016               3441m     BEQ EXIT_255
000014DE                          3442mm     PRINT_CHAR (A0)+,D1
000014DE                          3443mm WAIT_FOR_READY_256                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014DE                 TRUE     3444mm     IFEQ DEBUG
000014DE  1239 00C00003           3445mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000014E4  0801 0002               3446mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000014E8  67F4                    3447mm         BEQ WAIT_FOR_READY_256                      ; NO SPACE, CHECK AGAIN
000014EA  13D8 00C00007           3448mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014F0                          3449mm     ENDC
000014F0                          3450mm 
000014F0                 FALSE    3451mm     IFNE DEBUG
000014F0                          3452mm     ENDC
000014F0                          3453mm 
000014F0                          3454mm     ENDM
000014F0  60E4                    3455m     BRA LOOP_255
000014F2                          3456m EXIT_255
000014F2                          3457m     ENDM
000014F2                          3458  
000014F2  6000 0022               3459      BRA CONTINUE    
000014F6                          3460  WRITE
000014F6  41FA 03F3               3461      LEA WRITING(PC),A0
000014FA                          3462m     PRINT_STR A0,D1
000014FA                          3463m LOOP_257
000014FA  0C10 0000               3464m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000014FE  6700 0016               3465m     BEQ EXIT_257
00001502                          3466mm     PRINT_CHAR (A0)+,D1
00001502                          3467mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001502                 TRUE     3468mm     IFEQ DEBUG
00001502  1239 00C00003           3469mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001508  0801 0002               3470mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000150C  67F4                    3471mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
0000150E  13D8 00C00007           3472mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001514                          3473mm     ENDC
00001514                          3474mm 
00001514                 FALSE    3475mm     IFNE DEBUG
00001514                          3476mm     ENDC
00001514                          3477mm 
00001514                          3478mm     ENDM
00001514  60E4                    3479m     BRA LOOP_257
00001516                          3480m EXIT_257
00001516                          3481m     ENDM
00001516                          3482  
00001516                          3483  CONTINUE
00001516  222F 0002               3484      MOVE.L 2(SP),D1
0000151A                          3485m     PRINT_REG D1,D2,D3,D4,A0
0000151A  41FA 0392               3486m     LEA OX(PC),A0
0000151E                          3487mm     PRINT_STR A0,D2
0000151E                          3488mm LOOP_260
0000151E  0C10 0000               3489mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001522  6700 0016               3490mm     BEQ EXIT_260
00001526                          3491mmm     PRINT_CHAR (A0)+,D2
00001526                          3492mmm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001526                 TRUE     3493mmm     IFEQ DEBUG
00001526  1439 00C00003           3494mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000152C  0802 0002               3495mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001530  67F4                    3496mmm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
00001532  13D8 00C00007           3497mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001538                          3498mmm     ENDC
00001538                          3499mmm 
00001538                 FALSE    3500mmm     IFNE DEBUG
00001538                          3501mmm     ENDC
00001538                          3502mmm 
00001538                          3503mmm     ENDM
00001538  60E4                    3504mm     BRA LOOP_260
0000153A                          3505mm EXIT_260
0000153A                          3506mm     ENDM
0000153A  7807                    3507m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000153C                          3508m LOOP_259
0000153C                          3509mm     BIN2HEX D1,D3,A0
0000153C  41FA 032F               3510mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001540  E999                    3511mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001542  1601                    3512mm     MOVE.B D1,D3
00001544  0283 0000000F           3513mm     ANDI.L #$F,D3
0000154A  1630 3000               3514mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000154E                          3515mm     ENDM
0000154E                          3516mm     PRINT_CHAR D3,D2
0000154E                          3517mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000154E                 TRUE     3518mm     IFEQ DEBUG
0000154E  1439 00C00003           3519mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001554  0802 0002               3520mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001558  67F4                    3521mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
0000155A  13C3 00C00007           3522mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001560                          3523mm     ENDC
00001560                          3524mm 
00001560                 FALSE    3525mm     IFNE DEBUG
00001560                          3526mm     ENDC
00001560                          3527mm 
00001560                          3528mm     ENDM
00001560  57CC FFDA               3529m     DBEQ D4,LOOP_259
00001564                          3530m     ENDM
00001564                          3531  
00001564  41FA 038E               3532      LEA FROM(PC),A0
00001568                          3533m     PRINT_STR A0,D0
00001568                          3534m LOOP_264
00001568  0C10 0000               3535m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000156C  6700 0016               3536m     BEQ EXIT_264
00001570                          3537mm     PRINT_CHAR (A0)+,D0
00001570                          3538mm WAIT_FOR_READY_265                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001570                 TRUE     3539mm     IFEQ DEBUG
00001570  1039 00C00003           3540mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001576  0800 0002               3541mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000157A  67F4                    3542mm         BEQ WAIT_FOR_READY_265                      ; NO SPACE, CHECK AGAIN
0000157C  13D8 00C00007           3543mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001582                          3544mm     ENDC
00001582                          3545mm 
00001582                 FALSE    3546mm     IFNE DEBUG
00001582                          3547mm     ENDC
00001582                          3548mm 
00001582                          3549mm     ENDM
00001582  60E4                    3550m     BRA LOOP_264
00001584                          3551m EXIT_264
00001584                          3552m     ENDM
00001584                          3553  
00001584  222F 000A               3554      MOVE.L 10(SP),D1
00001588                          3555m     PRINT_REG D1,D2,D3,D4,A0
00001588  41FA 0324               3556m     LEA OX(PC),A0
0000158C                          3557mm     PRINT_STR A0,D2
0000158C                          3558mm LOOP_267
0000158C  0C10 0000               3559mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001590  6700 0016               3560mm     BEQ EXIT_267
00001594                          3561mmm     PRINT_CHAR (A0)+,D2
00001594                          3562mmm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001594                 TRUE     3563mmm     IFEQ DEBUG
00001594  1439 00C00003           3564mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000159A  0802 0002               3565mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000159E  67F4                    3566mmm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
000015A0  13D8 00C00007           3567mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015A6                          3568mmm     ENDC
000015A6                          3569mmm 
000015A6                 FALSE    3570mmm     IFNE DEBUG
000015A6                          3571mmm     ENDC
000015A6                          3572mmm 
000015A6                          3573mmm     ENDM
000015A6  60E4                    3574mm     BRA LOOP_267
000015A8                          3575mm EXIT_267
000015A8                          3576mm     ENDM
000015A8  7807                    3577m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000015AA                          3578m LOOP_266
000015AA                          3579mm     BIN2HEX D1,D3,A0
000015AA  41FA 02C1               3580mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000015AE  E999                    3581mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000015B0  1601                    3582mm     MOVE.B D1,D3
000015B2  0283 0000000F           3583mm     ANDI.L #$F,D3
000015B8  1630 3000               3584mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000015BC                          3585mm     ENDM
000015BC                          3586mm     PRINT_CHAR D3,D2
000015BC                          3587mm WAIT_FOR_READY_270                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015BC                 TRUE     3588mm     IFEQ DEBUG
000015BC  1439 00C00003           3589mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000015C2  0802 0002               3590mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000015C6  67F4                    3591mm         BEQ WAIT_FOR_READY_270                      ; NO SPACE, CHECK AGAIN
000015C8  13C3 00C00007           3592mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000015CE                          3593mm     ENDC
000015CE                          3594mm 
000015CE                 FALSE    3595mm     IFNE DEBUG
000015CE                          3596mm     ENDC
000015CE                          3597mm 
000015CE                          3598mm     ENDM
000015CE  57CC FFDA               3599m     DBEQ D4,LOOP_266
000015D2                          3600m     ENDM
000015D2                          3601m     PRINT_CRLF D0,A0
000015D2  41FA 02D4               3602m     LEA CRLF(PC),A0
000015D6                          3603mm     PRINT_STR A0,D0
000015D6                          3604mm LOOP_272
000015D6  0C10 0000               3605mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000015DA  6700 0016               3606mm     BEQ EXIT_272
000015DE                          3607mmm     PRINT_CHAR (A0)+,D0
000015DE                          3608mmm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015DE                 TRUE     3609mmm     IFEQ DEBUG
000015DE  1039 00C00003           3610mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000015E4  0800 0002               3611mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000015E8  67F4                    3612mmm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000015EA  13D8 00C00007           3613mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015F0                          3614mmm     ENDC
000015F0                          3615mmm 
000015F0                 FALSE    3616mmm     IFNE DEBUG
000015F0                          3617mmm     ENDC
000015F0                          3618mmm 
000015F0                          3619mmm     ENDM
000015F0  60E4                    3620mm     BRA LOOP_272
000015F2                          3621mm EXIT_272
000015F2                          3622mm     ENDM
000015F2                          3623m     ENDM
000015F2                          3624      
000015F2  207C 00000004           3625      MOVE.L #4,A0
000015F8  4ED0                    3626      JMP (A0)
000015FA                          3627          
000015FA                          3628  ILLEGAL_HANDLER
000015FA  13FC 0007 00E00001      3629      MOVE.B #7,DISPLAY   
00001602                          3630      
00001602  207C 00000004           3631      MOVE.L #4,A0
00001608  4ED0                    3632      JMP (A0)
0000160A                          3633          
0000160A                          3634  UNHANDLED_HANDLER
0000160A  41FA 02EF               3635      LEA UNHANDLED(PC),A0
0000160E                          3636m     PRINT_STR A0,D1
0000160E                          3637m LOOP_274
0000160E  0C10 0000               3638m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001612  6700 0016               3639m     BEQ EXIT_274
00001616                          3640mm     PRINT_CHAR (A0)+,D1
00001616                          3641mm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001616                 TRUE     3642mm     IFEQ DEBUG
00001616  1239 00C00003           3643mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000161C  0801 0002               3644mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001620  67F4                    3645mm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
00001622  13D8 00C00007           3646mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001628                          3647mm     ENDC
00001628                          3648mm 
00001628                 FALSE    3649mm     IFNE DEBUG
00001628                          3650mm     ENDC
00001628                          3651mm 
00001628                          3652mm     ENDM
00001628  60E4                    3653m     BRA LOOP_274
0000162A                          3654m EXIT_274
0000162A                          3655m     ENDM
0000162A                          3656  
0000162A  4E73                    3657      RTE 
0000162C                          3658      
0000162C                          3659  UNINITIALISED_HANDLER
0000162C  41FA 02E3               3660      LEA UNINITIALISED(PC),A0
00001630                          3661m     PRINT_STR A0,D1
00001630                          3662m LOOP_276
00001630  0C10 0000               3663m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001634  6700 0016               3664m     BEQ EXIT_276
00001638                          3665mm     PRINT_CHAR (A0)+,D1
00001638                          3666mm WAIT_FOR_READY_277                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001638                 TRUE     3667mm     IFEQ DEBUG
00001638  1239 00C00003           3668mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000163E  0801 0002               3669mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001642  67F4                    3670mm         BEQ WAIT_FOR_READY_277                      ; NO SPACE, CHECK AGAIN
00001644  13D8 00C00007           3671mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000164A                          3672mm     ENDC
0000164A                          3673mm 
0000164A                 FALSE    3674mm     IFNE DEBUG
0000164A                          3675mm     ENDC
0000164A                          3676mm 
0000164A                          3677mm     ENDM
0000164A  60E4                    3678m     BRA LOOP_276
0000164C                          3679m EXIT_276
0000164C                          3680m     ENDM
0000164C                          3681  
0000164C  4E73                    3682      RTE 
0000164E                          3683  
0000164E                          3684  SPURIOUS_HANDLER
0000164E  41FA 02E1               3685      LEA SPURIOUS(PC),A0
00001652                          3686m     PRINT_STR A0,D1
00001652                          3687m LOOP_278
00001652  0C10 0000               3688m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001656  6700 0016               3689m     BEQ EXIT_278
0000165A                          3690mm     PRINT_CHAR (A0)+,D1
0000165A                          3691mm WAIT_FOR_READY_279                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000165A                 TRUE     3692mm     IFEQ DEBUG
0000165A  1239 00C00003           3693mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001660  0801 0002               3694mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001664  67F4                    3695mm         BEQ WAIT_FOR_READY_279                      ; NO SPACE, CHECK AGAIN
00001666  13D8 00C00007           3696mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000166C                          3697mm     ENDC
0000166C                          3698mm 
0000166C                 FALSE    3699mm     IFNE DEBUG
0000166C                          3700mm     ENDC
0000166C                          3701mm 
0000166C                          3702mm     ENDM
0000166C  60E4                    3703m     BRA LOOP_278
0000166E                          3704m EXIT_278
0000166E                          3705m     ENDM
0000166E                          3706  
0000166E  4E73                    3707      RTE 
00001670                          3708      
00001670                          3709  TICK_HANDLER
00001670  41FA 0254               3710      LEA TICK(PC),A0
00001674                          3711m     PRINT_STR A0,D1
00001674                          3712m LOOP_280
00001674  0C10 0000               3713m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001678  6700 0016               3714m     BEQ EXIT_280
0000167C                          3715mm     PRINT_CHAR (A0)+,D1
0000167C                          3716mm WAIT_FOR_READY_281                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000167C                 TRUE     3717mm     IFEQ DEBUG
0000167C  1239 00C00003           3718mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001682  0801 0002               3719mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001686  67F4                    3720mm         BEQ WAIT_FOR_READY_281                      ; NO SPACE, CHECK AGAIN
00001688  13D8 00C00007           3721mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000168E                          3722mm     ENDC
0000168E                          3723mm 
0000168E                 FALSE    3724mm     IFNE DEBUG
0000168E                          3725mm     ENDC
0000168E                          3726mm 
0000168E                          3727mm     ENDM
0000168E  60E4                    3728m     BRA LOOP_280
00001690                          3729m EXIT_280
00001690                          3730m     ENDM
00001690                          3731      
00001690  1039 00C0001F           3732      MOVE.B DUART_RESET_OPR,D0
00001696  4E73                    3733      RTE 
00001698                          3734  
00001698                          3735  ; strings
00001698= 50 72 65 73 73 20 ...   3736  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
000016AB= 5B 3F 5D 09 09 09 ...   3737  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
000016B7= 5B 76 5D 09 09 09 ...   3738          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
000016C6= 78 78 78 78 78 78 ...   3739          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
000016DE= 78 78 78 78 78 78 ...   3740          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
000016FE= 78 78 78 78 78 78 ...   3741          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
0000171F= 78 78 78 78 78 78 ...   3742          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001730= 5B 7A 5D 09 09 09 ...   3743          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001742= 78 78 78 78 78 78 ...   3744          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001763= 78 78 78 78 78 78 ...   3745          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
00001782= 78 78 78 78 78 78 ...   3746          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
000017A6= 23 09 09 09 77 72 ...   3747          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
000017C0= 5B 78 5D 09 09 09 ...   3748          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
000017D7= 5B 69 5D 09 09 09 ...   3749          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
000017F0= 5B 6F 5D 09 09 09 ...   3750          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
0000180B= 48 75 68 3F 0D 0A 00    3751  HUH  DC.B 'Huh?',CR,LF,NULL
00001812= 20 53 20 72 65 63 ...   3752  READ    DC.B ' S records read, start address = ',NULL
00001834= 57 3A 20 55 6E 6B ...   3753  UNREC   DC.B 'W: Unknown Srec type: ',NULL
0000184B= 21 20 43 53 20 66 ...   3754  CS_FAILURE  DC.B '! CS failure at ',NULL
0000185C= 21 20 52 41 4D 20 ...   3755  RAM_ERROR   DC.B '! RAM error at: ',NULL
0000186D= 30 31 32 33 34 35 ...   3756  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000187D= 00 01 02 03 04 05 ...   3757  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001894= 4C 6F 61 64 69 6E ...   3758  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000018A8= 0D 0A 00                3759  CRLF    DC.B CR,LF,NULL
000018AB= 3E 20 00                3760  PROMPT  DC.B '> ',NULL
000018AE= 30 78 00                3761  ox      DC.B '0x',NULL
000018B1= 20 2D 3E 20 00          3762  to      DC.B ' -> ',NULL
000018B6= 20 66 6F 72 20 00       3763  for     DC.B ' for ',NULL
000018BC= 53 50 3A 20 00          3764  STACK_POINTER DC.B 'SP: ',NULL
000018C1= 53 52 3A 20 00          3765  STATUS_REGISTER DC.B 'SR: ',NULL
000018C6= 74 69 63 6B 0D 0A 00    3766  TICK DC.B 'tick',CR,LF,NULL
000018CD= 2A 20 42 75 73 2F ...   3767  BUS_ERROR DC.B '* Bus/address error ',NULL
000018E2= 72 65 61 64 69 6E ...   3768  READING DC.B 'reading ',NULL
000018EB= 77 72 69 74 69 6E ...   3769  WRITING DC.B 'writing ',NULL
000018F4= 20 66 72 6F 6D 20 00    3770  FROM DC.B ' from ',NULL
000018FB= 2A 20 55 6E 68 61 ...   3771  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001911= 2A 20 20 55 6E 69 ...   3772  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
00001931= 2A 20 53 70 75 72 ...   3773  SPURIOUS DC.B '* Spurious interrupt',NULL
00001946= 4D 44 46 2D 6D 6F ...   3774  VERSION DC.B 'MDF-mon V1.129 (30/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001964= 00                      3775  END     DC.B 0
00001965                          3776      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         186D
BUS_ERROR           18CD
BUS_ERROR_HANDLER   14A6
CONTINUE            1516
CONTINUE_113        B0C
CONTINUE_54         5E8
CONTINUE_57         638
CONTINUE_61         68E
CONTINUE_69         742
CONTINUE_74         7B4
CONTINUE_79         830
CONTINUE_84         8AE
CONTINUE_89         936
CONTINUE_94         9A8
CONTINUE_99         A1A
CR                  D
CRLF                18A8
CS_FAILURE          184B
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C16
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1964
EXIT_10             288
EXIT_104            A8C
EXIT_106            AAC
EXIT_110            ADE
EXIT_118            B74
EXIT_120            B9C
EXIT_123            BBC
EXIT_128            C06
EXIT_131            C36
EXIT_135            C80
EXIT_138            CA2
EXIT_143            CEC
EXIT_145            D68
EXIT_148            D8C
EXIT_15             2D2
EXIT_153            DD6
EXIT_160            E68
EXIT_163            EC6
EXIT_165            EE6
EXIT_168            F08
EXIT_17             2F2
EXIT_172            F52
EXIT_175            F74
EXIT_179            FBE
EXIT_182            FDE
EXIT_187            1028
EXIT_20             312
EXIT_202            1142
EXIT_205            11A6
EXIT_208            11C6
EXIT_212            1210
EXIT_215            1232
EXIT_22             33C
EXIT_220            127C
EXIT_229            1314
EXIT_231            1356
EXIT_234            1378
EXIT_239            13C2
EXIT_241            13E2
EXIT_244            1404
EXIT_249            144E
EXIT_253            14C6
EXIT_255            14F2
EXIT_257            1516
EXIT_260            153A
EXIT_264            1584
EXIT_267            15A8
EXIT_272            15F2
EXIT_274            162A
EXIT_276            164C
EXIT_278            166E
EXIT_28             3D0
EXIT_280            1690
EXIT_30             440
EXIT_32             46C
EXIT_35             496
EXIT_45             544
EXIT_5              240
EXIT_52             5BA
EXIT_66             6FE
EXIT_7              260
FOR                 18B6
FROM                18F4
G                   CF0
GET_INPUT           33C
H                   444
HASH                1472
HELP                16AB
HELPPROMPT          1698
HEX2BIN             10B
HEX2BIN_LUT         187D
HEX_DIGIT           1488
HUH                 180B
I                   1452
ILLEGAL_HANDLER     15FA
L                   DE6
LF                  A
LOADING             1894
LOOP_10             26C
LOOP_104            A70
LOOP_106            A90
LOOP_110            AC2
LOOP_118            B58
LOOP_120            B80
LOOP_122            BBE
LOOP_123            BA0
LOOP_128            BEA
LOOP_130            C38
LOOP_131            C1A
LOOP_135            C64
LOOP_137            CA4
LOOP_138            C86
LOOP_143            CD0
LOOP_145            D4C
LOOP_147            D8E
LOOP_148            D70
LOOP_15             2B6
LOOP_153            DBA
LOOP_160            E4C
LOOP_163            EAA
LOOP_165            ECA
LOOP_167            F0A
LOOP_168            EEC
LOOP_17             2D6
LOOP_172            F36
LOOP_174            F76
LOOP_175            F58
LOOP_179            FA2
LOOP_181            FE0
LOOP_182            FC2
LOOP_187            100C
LOOP_20             2F6
LOOP_202            1126
LOOP_205            118A
LOOP_207            11C8
LOOP_208            11AA
LOOP_212            11F4
LOOP_214            1234
LOOP_215            1216
LOOP_22             320
LOOP_220            1260
LOOP_229            12F8
LOOP_231            133A
LOOP_233            137A
LOOP_234            135C
LOOP_239            13A6
LOOP_241            13C6
LOOP_243            1406
LOOP_244            13E8
LOOP_249            1432
LOOP_253            14AA
LOOP_255            14D6
LOOP_257            14FA
LOOP_259            153C
LOOP_260            151E
LOOP_264            1568
LOOP_266            15AA
LOOP_267            158C
LOOP_272            15D6
LOOP_274            160E
LOOP_276            1630
LOOP_278            1652
LOOP_28             3B4
LOOP_280            1674
LOOP_30             424
LOOP_32             450
LOOP_34             498
LOOP_35             47A
LOOP_45             528
LOOP_5              224
LOOP_52             59E
LOOP_66             6E2
LOOP_7              244
LOOP_9              28A
M                   129E
MAIN_LOOP           31C
NULL                0
O                   1462
OX                  18AE
P                   10CE
PRINTSTR            450
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              18AB
PROTECT             A40
R                   470
RAM                 200000
RAM_ERROR           185C
READ                1812
READING             18E2
READ_CHAR           62D
RESET               4
ROM                 0
S                   5C4
SPURIOUS            1931
SPURIOUS_HANDLER    164E
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       18BC
START               104
STATUS_REGISTER     18C1
TAB                 9
TICK                18C6
TICK_HANDLER        1670
TO                  18B1
UNHANDLED           18FB
UNHANDLED_HANDLER   160A
UNINITIALISED       1911
UNINITIALISED_HANDLER  162C
UNPROTECT           979
UNREC               1834
USER                100
V                   44C
VECS                8
VERSION             1946
W                   548
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_189  103A
WAIT_FOR_COMPLETE_191  105C
WAIT_FOR_COMPLETE_192  106E
WAIT_FOR_COMPLETE_194  1094
WAIT_FOR_COMPLETE_195  10A6
WAIT_FOR_COMPLETE_222  127E
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A32
WAIT_FOR_READY_105  A78
WAIT_FOR_READY_107  A98
WAIT_FOR_READY_108  AAC
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  ACA
WAIT_FOR_READY_113  AF0
WAIT_FOR_READY_115  B24
WAIT_FOR_READY_119  B60
WAIT_FOR_READY_121  B88
WAIT_FOR_READY_124  BA8
WAIT_FOR_READY_126  BD0
WAIT_FOR_READY_129  BF2
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_132  C22
WAIT_FOR_READY_134  C4A
WAIT_FOR_READY_136  C6C
WAIT_FOR_READY_139  C8E
WAIT_FOR_READY_141  CB6
WAIT_FOR_READY_144  CD8
WAIT_FOR_READY_146  D54
WAIT_FOR_READY_149  D78
WAIT_FOR_READY_151  DA0
WAIT_FOR_READY_154  DC2
WAIT_FOR_READY_155  DF4
WAIT_FOR_READY_157  E0E
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E54
WAIT_FOR_READY_164  EB2
WAIT_FOR_READY_166  ED2
WAIT_FOR_READY_169  EF4
WAIT_FOR_READY_171  F1C
WAIT_FOR_READY_173  F3E
WAIT_FOR_READY_176  F60
WAIT_FOR_READY_178  F88
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  FAA
WAIT_FOR_READY_183  FCA
WAIT_FOR_READY_185  FF2
WAIT_FOR_READY_188  1014
WAIT_FOR_READY_197  10DA
WAIT_FOR_READY_199  10F4
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_203  112E
WAIT_FOR_READY_206  1192
WAIT_FOR_READY_209  11B2
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  11DA
WAIT_FOR_READY_213  11FC
WAIT_FOR_READY_216  121E
WAIT_FOR_READY_218  1246
WAIT_FOR_READY_221  1268
WAIT_FOR_READY_224  12AC
WAIT_FOR_READY_226  12C6
WAIT_FOR_READY_23   328
WAIT_FOR_READY_230  1300
WAIT_FOR_READY_232  1342
WAIT_FOR_READY_235  1364
WAIT_FOR_READY_237  138C
WAIT_FOR_READY_24   33C
WAIT_FOR_READY_240  13AE
WAIT_FOR_READY_242  13CE
WAIT_FOR_READY_245  13F0
WAIT_FOR_READY_247  1418
WAIT_FOR_READY_250  143A
WAIT_FOR_READY_254  14B2
WAIT_FOR_READY_256  14DE
WAIT_FOR_READY_258  1502
WAIT_FOR_READY_26   356
WAIT_FOR_READY_261  1526
WAIT_FOR_READY_263  154E
WAIT_FOR_READY_265  1570
WAIT_FOR_READY_268  1594
WAIT_FOR_READY_270  15BC
WAIT_FOR_READY_273  15DE
WAIT_FOR_READY_275  1616
WAIT_FOR_READY_277  1638
WAIT_FOR_READY_279  165A
WAIT_FOR_READY_281  167C
WAIT_FOR_READY_29   3BC
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_31   42C
WAIT_FOR_READY_33   458
WAIT_FOR_READY_36   482
WAIT_FOR_READY_38   4AA
WAIT_FOR_READY_39   4C0
WAIT_FOR_READY_40   4D6
WAIT_FOR_READY_41   4EA
WAIT_FOR_READY_42   4FE
WAIT_FOR_READY_43   512
WAIT_FOR_READY_46   530
WAIT_FOR_READY_47   552
WAIT_FOR_READY_49   56C
WAIT_FOR_READY_53   5A6
WAIT_FOR_READY_54   5CC
WAIT_FOR_READY_56   606
WAIT_FOR_READY_57   61C
WAIT_FOR_READY_59   650
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   672
WAIT_FOR_READY_63   6A6
WAIT_FOR_READY_67   6EA
WAIT_FOR_READY_69   726
WAIT_FOR_READY_71   75A
WAIT_FOR_READY_74   798
WAIT_FOR_READY_76   7CC
WAIT_FOR_READY_79   814
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_81   848
WAIT_FOR_READY_84   892
WAIT_FOR_READY_86   8C6
WAIT_FOR_READY_89   91A
WAIT_FOR_READY_91   94E
WAIT_FOR_READY_94   98C
WAIT_FOR_READY_96   9C0
WAIT_FOR_READY_99   9FE
WAIT_FOR_SRECORD    5CC
WRITE               14F6
WRITING             18EB
X                   1336
Z                   CF6
_00000000           218
_00000001           37C
_00000002           390
_00000003           706
_00000004           AE2
_00000005           714
_00000006           902
_00000007           878
_00000008           AE2
_00000009           A6C
_0000000A           AE2
_0000000B           C0A
_0000000C           C16
_0000000D           DD6
_0000000E           1044
_0000000F           1066
_00000010           1078
_00000011           109E
_00000012           10B0
_00000013           1288
_10000000           668
_10000001           6D0
_10000002           71C
_10000003           784
_10000004           78E
_10000005           7F6
_10000006           80A
_10000007           872
_10000008           87C
_10000009           8FC
_1000000A           888
_1000000B           8F0
_1000000C           910
_1000000D           978
_1000000E           982
_1000000F           9EA
_10000010           9F4
_10000011           A5C
_10000012           AE6
_10000013           B4E
_10000014           1028
_10000015           104A
_10000016           131E
_10000017           1332
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           550
_20000005           594
_20000006           D08
_20000007           D18
_20000008           D32
_20000009           DD8
_2000000A           DF2
_2000000B           E36
_2000000C           1080
_2000000D           10B2
_2000000E           10D8
_2000000F           111C
_20000010           117C
_20000011           1180
_20000012           12AA
_20000013           12EE
