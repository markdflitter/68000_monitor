00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/05/2021 17:38:11

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           190  PRINT_REG_4BIT MACRO
00000000                           191      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           192      MOVE.B \1,\3
00000000                           193      ANDI.L #$F,\3
00000000                           194      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           195      PRINT_CHAR \3,\2
00000000                           196      ENDM
00000000                           197  
00000000                           198  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           199  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           200  PRINT_REG MACRO
00000000                           201      LEA ox(PC),\5
00000000                           202      PRINT_STR \5,\2
00000000                           203      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           204  LOOP\@
00000000                           205      BIN2HEX \1,\3,\5
00000000                           206      PRINT_CHAR \3,\2
00000000                           207      DBEQ \4,LOOP\@
00000000                           208      ENDM
00000000                           209  
00000000                           210  ; wait for a char from the serial port
00000000                           211  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           212  ; will stamp on D0 and D1 in debug mode
00000000                           213  WAIT_CHAR MACRO
00000000                           214  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           215      IFEQ DEBUG
00000000                           216          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           217          BTST #0,\2                                  ; check for character
00000000                           218          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           219      ENDC
00000000                           220  
00000000                           221      READ_CHAR \1
00000000                           222  
00000000                           223      IFEQ DEBUG
00000000                           224          PRINT_CHAR \1,\2                            ; echo it back
00000000                           225      ENDC
00000000                           226      ENDM
00000000                           227  
00000000                           228  ; read a char from the serial port - assumes that there is one!
00000000                           229  ; \ 1= data register for read char
00000000                           230  ; will stamp on D0 and D1 in debug mode
00000000                           231  READ_CHAR MACRO
00000000                           232      IFEQ DEBUG
00000000                           233          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           234      ENDC
00000000                           235      IFNE DEBUG
00000000                           236          MOVE.L #5,D0    
00000000                           237          TRAP #15                                    ; read from keyboard in simulator
00000000                           238          MOVE.L D1,\1
00000000                           239      ENDC
00000000                           240  
00000000                           241      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           242      BEQ START
00000000                           243      ENDM
00000000                           244  
00000000                           245  
00000000                           246  ; read data from the download serial port
00000000                           247  ; \ 1= data register for read char
00000000                           248  DOWNLOAD MACRO
00000000                           249  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           250  
00000000                           251      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           252      BTST #0,\1                                      ; check for character
00000000                           253      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           254  
00000000                           255      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           256  CONTINUE\@
00000000                           257      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           258      BTST #0,\1                                      ; check for character
00000000                           259      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           260      
00000000                           261      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           262      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           263  
00000000                           264      ENDM
00000000                           265  
00000000                           266  ; unprotect the EEPROM
00000000                           267  UNPROTECT MACRO
00000000                           268      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           269      NOP
00000000                           270      MOVE.W #$5555,$1554
00000000                           271      NOP
00000000                           272      MOVE.W #$8080,$2AAA
00000000                           273      NOP
00000000                           274      MOVE.W #$AAAA,$2AAA
00000000                           275      NOP
00000000                           276      MOVE.W #$5555,$1554
00000000                           277      NOP
00000000                           278      MOVE.W #$2020,$2AAA
00000000                           279      ENDM
00000000                           280      
00000000                           281  ; protect the EEPROM
00000000                           282  PROTECT MACRO
00000000                           283      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           284      MOVE.W #$5555,$1554
00000000                           285      MOVE.W #$A0A0,$2AAA
00000000                           286      ENDM
00000000                           287  
00000000                           288  
00000000                           289  ; read two hex digits from the download serial port and convert to a byte
00000000                           290  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           291  DOWNLOAD_BYTE MACRO
00000000                           292      MOVE.B #2,\4
00000000                           293      WHILE.B \4 <GT> 0 DO
00000000                           294          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           295          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           296          ;PRINT_CHAR \2,\3
00000000                           297          HEX2BIN \2,\2,\6
00000000                           298          OR.B \2,\1
00000000                           299          SUB.B #1,\4
00000000                           300      ENDW
00000000                           301  
00000000                           302      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           303      MOVE.B \1,\2
00000000                           304      ADD.L \1,\5
00000000                           305  
00000000                           306      ENDM
00000000                           307  
00000000                           308  ; write word to EEPROM
00000000                           309  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           310  PROGRAM MACRO
00000000                           311    MOVE.W \1,\2                                      ; write the data
00000000                           312  
00000000                           313  WAIT_FOR_COMPLETE\@
00000000                           314          MOVE.W \2,\3
00000000                           315  
00000000                           316          IF.W \3 <NE> \1 THEN
00000000                           317              BRA WAIT_FOR_COMPLETE\@
00000000                           318          ENDI
00000000                           319          ENDM
00000000                           320          
00000000                           321  ; program vector to EEPROM
00000000                           322  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           323  PROGRAM_VECTOR MACRO
00000000                           324      ADD.L #2,\2
00000000                           325      PROGRAM \1, (\2), \3                            ; write it
00000000                           326      LSR.L #8,\1
00000000                           327      LSR.L #8,\1
00000000                           328      SUB.L #2,\2
00000000                           329      PROGRAM \1, (\2), \3
00000000                           330      ENDM
00000000                           331  
00000000                           332  ; read an ide register
00000000                           333  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           334  READ_8 MACRO
00000000                           335      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           336      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           337      ORI.B \1, \3
00000000                           338      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           339      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           340      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           341      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           342      ORI.B #MC68230_PORT_C_READ, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           345      ENDM
00000000                           346      
00000000                           347  ; write an ide register
00000000                           348  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           349  WRITE_8 MACRO
00000000                           350      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           351      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           352      ORI.B \2, \3
00000000                           353      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           354      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           355      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           356      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           357      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           358      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           359      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           360      ENDM
00000000                           361  
00000000                           362  ; read ide data
00000000                           363  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           364  READ_16 MACRO
00000000                           365      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           366      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           367      
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           369      ORI.B \1, \3
00000000                           370      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           371      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           372      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           373      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           374      LSL.W #8, \2
00000000                           375      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           376      ORI.B #MC68230_PORT_C_READ, \3
00000000                           377      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           378      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           379      ENDM
00000000                           380      
00000000                           381  ; read ide data
00000000                           382  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           383  READ_32 MACRO
00000000                           384      READ_16 \1, \2, \3
00000000                           385      LSL.L #8, \2
00000000                           386      LSL.L #8, \2
00000000                           387      READ_16 \1, \2, \3
00000000                           388      ENDM
00000000                           389          
00000000                           390  ; read ide status
00000000                           391  ;\1 = data register for result, \2 = working data register 
00000000                           392  READ_IDE_STATUS MACRO   
00000000                           393      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           394      ENDM
00000000                           395      
00000000                           396  ; wait for ide drive to be ready
00000000                           397  ;\1 = working data register 1, \2 = working data register 2
00000000                           398  WAIT_DRIVE_READY MACRO
00000000                           399  LOOP\@
00000000                           400      READ_IDE_STATUS \1, \2
00000000                           401      BTST #IDE_STATUS_READY, \1
00000000                           402      BEQ LOOP\@
00000000                           403      ENDM
00000000                           404      
00000000                           405  ; wait for ide drive to be not busy
00000000                           406  ;\1 = working data register 1, \2 = working data register 2
00000000                           407  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           408  LOOP\@
00000000                           409      READ_IDE_STATUS \1, \2
00000000                           410      BTST #IDE_STATUS_BUSY, \1
00000000                           411      BNE LOOP\@
00000000                           412      ENDM
00000000                           413      
00000000                           414  ; wait for ide drive to have data for us
00000000                           415  ;\1 = working data register 1, \2 = working data register 2
00000000                           416  WAIT_DRIVE_DRQ MACRO
00000000                           417  LOOP\@
00000000                           418      READ_IDE_STATUS \1, \2
00000000                           419      BTST #IDE_STATUS_DRQ, \1
00000000                           420      BEQ LOOP\@
00000000                           421      ENDM
00000000                           422      
00000000                           423  ; prepare to send a read command
00000000                           424  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           425  SET_READ_ADDRESS MACRO
00000000                           426      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           427      MOVE.L \1,\3
00000000                           428      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           429      LSR.L #8, \3
00000000                           430      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           431      LSR.L #8, \3                                
00000000                           432      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           433      LSR.L #8, \3
00000000                           434      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           435      ANDI.B #$0F,\3
00000000                           436      OR.B \3,\4
00000000                           437      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           438      ENDM
00000000                           439  
00000000                           440  ; send command
00000000                           441  ; \1 = command, \2 = working data register 1,
00000000                           442  SEND_COMMAND MACRO
00000000                           443      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           444      ENDM
00000000                           445      
00000000                           446  ; send read command and wait
00000000                           447  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           448  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           449      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           450      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           451      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           452      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           453      WAIT_DRIVE_DRQ \2, \3
00000000                           454      ENDM
00000000                           455  
00000000                           456  ; register catalogue
00000000                           457  ; D0 - used for simulator I/O
00000000                           458  ; D1 - used for simulator I/O
00000000                           459  ; D2 - read character
00000000                           460  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           461  ; D6 - working register used in R/W
00000000                           462  ; D7 - address accumulator, reset by download
00000000                           463  ; A0 - address of string to print 
00000000                           464  
00000000                           465  ; start vector
00000000= 002E0000                 466  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 467  RESET   DC.L START                              ; RESET
00000008= 000018DC                 468  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 000018DC                 469          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001A30                 470          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001A40                 471          DC.L UNHANDLED_HANDLER
00000018= 00001A40                 472          DC.L UNHANDLED_HANDLER
0000001C= 00001A40                 473          DC.L UNHANDLED_HANDLER
00000020= 00001A40                 474          DC.L UNHANDLED_HANDLER
00000024= 00001A40                 475          DC.L UNHANDLED_HANDLER
00000028= 00001A40                 476          DC.L UNHANDLED_HANDLER
0000002C= 00001A40                 477          DC.L UNHANDLED_HANDLER
00000030= 00001A40                 478          DC.L UNHANDLED_HANDLER
00000034= 00001A40                 479          DC.L UNHANDLED_HANDLER
00000038= 00001A40                 480          DC.L UNHANDLED_HANDLER
0000003C= 00001A40                 481          DC.L UNHANDLED_HANDLER
00000040= 00001A40                 482          DC.L UNHANDLED_HANDLER
00000044= 00001A40                 483          DC.L UNHANDLED_HANDLER
00000048= 00001A40                 484          DC.L UNHANDLED_HANDLER
0000004C= 00001A40                 485          DC.L UNHANDLED_HANDLER
00000050= 00001A40                 486          DC.L UNHANDLED_HANDLER
00000054= 00001A40                 487          DC.L UNHANDLED_HANDLER
00000058= 00001A40                 488          DC.L UNHANDLED_HANDLER
0000005C= 00001A40                 489          DC.L UNHANDLED_HANDLER
00000060= 00001A64                 490          DC.L SPURIOUS_HANDLER
00000064= 00001A40                 491          DC.L UNHANDLED_HANDLER
00000068= 00001A40                 492          DC.L UNHANDLED_HANDLER
0000006C= 00001A40                 493          DC.L UNHANDLED_HANDLER
00000070= 00001A40                 494          DC.L UNHANDLED_HANDLER
00000074= 00001A40                 495          DC.L UNHANDLED_HANDLER
00000078= 00001A40                 496          DC.L UNHANDLED_HANDLER
0000007C= 00001A40                 497          DC.L UNHANDLED_HANDLER
00000080= 00001A40                 498          DC.L UNHANDLED_HANDLER
00000084= 00001A40                 499          DC.L UNHANDLED_HANDLER
00000088= 00001A40                 500          DC.L UNHANDLED_HANDLER
0000008C= 00001A40                 501          DC.L UNHANDLED_HANDLER
00000090= 00001A40                 502          DC.L UNHANDLED_HANDLER
00000094= 00001A40                 503          DC.L UNHANDLED_HANDLER
00000098= 00001A40                 504          DC.L UNHANDLED_HANDLER
0000009C= 00001A40                 505          DC.L UNHANDLED_HANDLER
000000A0= 00001A40                 506          DC.L UNHANDLED_HANDLER
000000A4= 00001A40                 507          DC.L UNHANDLED_HANDLER
000000A8= 00001A40                 508          DC.L UNHANDLED_HANDLER
000000AC= 00001A40                 509          DC.L UNHANDLED_HANDLER
000000B0= 00001A40                 510          DC.L UNHANDLED_HANDLER
000000B4= 00001A40                 511          DC.L UNHANDLED_HANDLER
000000B8= 00001A40                 512          DC.L UNHANDLED_HANDLER
000000BC= 00001A40                 513          DC.L UNHANDLED_HANDLER
000000C0= 00001A40                 514          DC.L UNHANDLED_HANDLER
000000C4= 00001A40                 515          DC.L UNHANDLED_HANDLER
000000C8= 00001A40                 516          DC.L UNHANDLED_HANDLER
000000CC= 00001A40                 517          DC.L UNHANDLED_HANDLER
000000D0= 00001A40                 518          DC.L UNHANDLED_HANDLER
000000D4= 00001A40                 519          DC.L UNHANDLED_HANDLER
000000D8= 00001A40                 520          DC.L UNHANDLED_HANDLER 
000000DC= 00001A40                 521          DC.L UNHANDLED_HANDLER
000000E0= 00001A40                 522          DC.L UNHANDLED_HANDLER
000000E4= 00001A40                 523          DC.L UNHANDLED_HANDLER 
000000E8= 00001A40                 524          DC.L UNHANDLED_HANDLER 
000000EC= 00001A40                 525          DC.L UNHANDLED_HANDLER
000000F0= 00001A40                 526          DC.L UNHANDLED_HANDLER 
000000F4= 00001A40                 527          DC.L UNHANDLED_HANDLER 
000000F8= 00001A40                 528          DC.L UNHANDLED_HANDLER 
000000FC= 00001A40                 529          DC.L UNHANDLED_HANDLER
00000100= 00001A54                 530  USER    DC.L TICK_HANDLER
00000104                           531      ; start of program  
00000104                           532  START
00000104  2E7C 002E0000            533      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       534      MOVE.B #0,DISPLAY
00000112                           535  
00000112  7000                     536      MOVE.L #0,D0
00000114  1039 00C00019            537      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           538  
0000011A                           539  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       540      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       541      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           542      
0000012A                           543      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                544s     MOVE.W  #$50,D1
0000012E  6000 000E                545s     BRA _20000001
00000132                           546s _20000000
00000132  13C1 00C00005            547          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     548          NOP
0000013A                           549      ENDF
0000013A  0441 0010                550s     SUB.W   #$10,D1
0000013E                           551s _20000001
0000013E  B27C 0010                552s     CMP.W   #$10,D1
00000142  6CEE                     553s     BGE _20000000
00000144                           554  
00000144                           555      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                556s     MOVE.W  #$50,D1
00000148  6000 000E                557s     BRA _20000003
0000014C                           558s _20000002
0000014C  13C1 00C00015            559          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     560          NOP
00000154                           561      ENDF
00000154  0441 0010                562s     SUB.W   #$10,D1
00000158                           563s _20000003
00000158  B27C 0010                564s     CMP.W   #$10,D1
0000015C  6CEE                     565s     BGE _20000002
0000015E                           566      
0000015E                           567  ;initialise UART
0000015E  13FC 0000 00C0000B       568      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       569      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       570      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       571      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       572      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           573  
00000186                           574  ; channel A
00000186  13FC 0013 00C00001       575      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       576      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       577      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       578      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           579  
000001A6                           580  ; channel B
000001A6  13FC 0013 00C00011       581      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       582      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       583      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       584      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       585      MOVE.B #64,DUART_IVR
000001CE                           586  
000001CE                           587m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           588m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      589m     IFEQ DEBUG
000001CE  1239 00C00003            590m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                591m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     592m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       593m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           594m     ENDC
000001E2                           595m 
000001E2                 FALSE     596m     IFNE DEBUG
000001E2                           597m     ENDC
000001E2                           598m 
000001E2                           599m     ENDM
000001E2                           600m     PRINT_CHAR #0,D1
000001E2                           601m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      602m     IFEQ DEBUG
000001E2  1239 00C00003            603m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                604m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     605m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       606m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           607m     ENDC
000001F6                           608m 
000001F6                 FALSE     609m     IFNE DEBUG
000001F6                           610m     ENDC
000001F6                           611m 
000001F6                           612m     ENDM
000001F6                           613m     PRINT_CHAR #0,D1
000001F6                           614m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      615m     IFEQ DEBUG
000001F6  1239 00C00003            616m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                617m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     618m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       619m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           620m     ENDC
0000020A                           621m 
0000020A                 FALSE     622m     IFNE DEBUG
0000020A                           623m     ENDC
0000020A                           624m 
0000020A                           625m     ENDM
0000020A                           626      
0000020A                           627      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                628s     CMP.W   #$0F,D0
0000020E  6600 0008                629s     BNE _00000000
00000212  1039 00C00005            630          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           631      ENDI
00000218                           632s _00000000
00000218                           633  
00000218  13FC 0001 00E00001       634      MOVE.B #1,DISPLAY
00000220                           635      
00000220                           636m     PRINT_CRLF D1,A0
00000220  41FA 1A8D                637m     LEA CRLF(PC),A0
00000224                           638mm     PRINT_STR A0,D1
00000224                           639mm LOOP_5
00000224  0C10 0000                640mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                641mm     BEQ EXIT_5
0000022C                           642mmm     PRINT_CHAR (A0)+,D1
0000022C                           643mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      644mmm     IFEQ DEBUG
0000022C  1239 00C00003            645mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                646mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     647mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            648mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           649mmm     ENDC
0000023E                           650mmm 
0000023E                 FALSE     651mmm     IFNE DEBUG
0000023E                           652mmm     ENDC
0000023E                           653mmm 
0000023E                           654mmm     ENDM
0000023E  60E4                     655mm     BRA LOOP_5
00000240                           656mm EXIT_5
00000240                           657mm     ENDM
00000240                           658m     ENDM
00000240  41FA 1B23                659      LEA VERSION(PC),A0
00000244                           660m     PRINT_STR A0,D3
00000244                           661m LOOP_7
00000244  0C10 0000                662m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                663m     BEQ EXIT_7
0000024C                           664mm     PRINT_CHAR (A0)+,D3
0000024C                           665mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      666mm     IFEQ DEBUG
0000024C  1639 00C00003            667mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                668mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     669mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            670mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           671mm     ENDC
0000025E                           672mm 
0000025E                 FALSE     673mm     IFNE DEBUG
0000025E                           674mm     ENDC
0000025E                           675mm 
0000025E                           676mm     ENDM
0000025E  60E4                     677m     BRA LOOP_7
00000260                           678m EXIT_7
00000260                           679m     ENDM
00000260                           680  
00000260  41F9 00001D83            681      LEA END,A0
00000266  2008                     682      MOVE.L A0,D0
00000268                           683m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1A4B                684m     LEA OX(PC),A0
0000026C                           685mm     PRINT_STR A0,D1
0000026C                           686mm LOOP_10
0000026C  0C10 0000                687mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                688mm     BEQ EXIT_10
00000274                           689mmm     PRINT_CHAR (A0)+,D1
00000274                           690mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      691mmm     IFEQ DEBUG
00000274  1239 00C00003            692mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                693mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     694mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            695mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           696mmm     ENDC
00000286                           697mmm 
00000286                 FALSE     698mmm     IFNE DEBUG
00000286                           699mmm     ENDC
00000286                           700mmm 
00000286                           701mmm     ENDM
00000286  60E4                     702mm     BRA LOOP_10
00000288                           703mm EXIT_10
00000288                           704mm     ENDM
00000288  7607                     705m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           706m LOOP_9
0000028A                           707mm     BIN2HEX D0,D2,A0
0000028A  41FA 19E8                708mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     709mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     710mm     MOVE.B D0,D2
00000292  0282 0000000F            711mm     ANDI.L #$F,D2
00000298  1430 2000                712mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           713mm     ENDM
0000029C                           714mm     PRINT_CHAR D2,D1
0000029C                           715mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      716mm     IFEQ DEBUG
0000029C  1239 00C00003            717mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                718mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     719mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            720mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           721mm     ENDC
000002AE                           722mm 
000002AE                 FALSE     723mm     IFNE DEBUG
000002AE                           724mm     ENDC
000002AE                           725mm 
000002AE                           726mm     ENDM
000002AE  57CB FFDA                727m     DBEQ D3,LOOP_9
000002B2                           728m     ENDM
000002B2                           729m     PRINT_CRLF D1,A0
000002B2  41FA 19FB                730m     LEA CRLF(PC),A0
000002B6                           731mm     PRINT_STR A0,D1
000002B6                           732mm LOOP_15
000002B6  0C10 0000                733mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                734mm     BEQ EXIT_15
000002BE                           735mmm     PRINT_CHAR (A0)+,D1
000002BE                           736mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      737mmm     IFEQ DEBUG
000002BE  1239 00C00003            738mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                739mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     740mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            741mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           742mmm     ENDC
000002D0                           743mmm 
000002D0                 FALSE     744mmm     IFNE DEBUG
000002D0                           745mmm     ENDC
000002D0                           746mmm 
000002D0                           747mmm     ENDM
000002D0  60E4                     748mm     BRA LOOP_15
000002D2                           749mm EXIT_15
000002D2                           750mm     ENDM
000002D2                           751m     ENDM
000002D2                           752  
000002D2  41FA 17B6                753      LEA HELPPROMPT(PC),A0
000002D6                           754m     PRINT_STR A0,D3
000002D6                           755m LOOP_17
000002D6  0C10 0000                756m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                757m     BEQ EXIT_17
000002DE                           758mm     PRINT_CHAR (A0)+,D3
000002DE                           759mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      760mm     IFEQ DEBUG
000002DE  1639 00C00003            761mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                762mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     763mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            764mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           765mm     ENDC
000002F0                           766mm 
000002F0                 FALSE     767mm     IFNE DEBUG
000002F0                           768mm     ENDC
000002F0                           769mm 
000002F0                           770mm     ENDM
000002F0  60E4                     771m     BRA LOOP_17
000002F2                           772m EXIT_17
000002F2                           773m     ENDM
000002F2                           774  
000002F2                           775m     PRINT_CRLF D3,A0
000002F2  41FA 19BB                776m     LEA CRLF(PC),A0
000002F6                           777mm     PRINT_STR A0,D3
000002F6                           778mm LOOP_20
000002F6  0C10 0000                779mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                780mm     BEQ EXIT_20
000002FE                           781mmm     PRINT_CHAR (A0)+,D3
000002FE                           782mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      783mmm     IFEQ DEBUG
000002FE  1639 00C00003            784mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                785mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     786mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            787mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           788mmm     ENDC
00000310                           789mmm 
00000310                 FALSE     790mmm     IFNE DEBUG
00000310                           791mmm     ENDC
00000310                           792mmm 
00000310                           793mmm     ENDM
00000310  60E4                     794mm     BRA LOOP_20
00000312                           795mm EXIT_20
00000312                           796mm     ENDM
00000312                           797m     ENDM
00000312                           798  
00000312  7E00                     799      MOVE.L #0,D7                                    ; address accumulator
00000314                           800  
00000314  13FC 0002 00E00001       801      MOVE.B #2,DISPLAY
0000031C                           802      
0000031C  13FC 0000 00A00001       803      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       804      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       805      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       806      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           807      
0000033C  13FC 0003 00E00001       808      MOVE.B #3,DISPLAY
00000344                           809      
00000344                           810      
00000344                           811  MAIN_LOOP
00000344  41FA 196C                812      LEA PROMPT(PC),A0
00000348                           813m     PRINT_STR A0,D3
00000348                           814m LOOP_22
00000348  0C10 0000                815m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                816m     BEQ EXIT_22
00000350                           817mm     PRINT_CHAR (A0)+,D3
00000350                           818mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      819mm     IFEQ DEBUG
00000350  1639 00C00003            820mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                821mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     822mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            823mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           824mm     ENDC
00000362                           825mm 
00000362                 FALSE     826mm     IFNE DEBUG
00000362                           827mm     ENDC
00000362                           828mm 
00000362                           829mm     ENDM
00000362  60E4                     830m     BRA LOOP_22
00000364                           831m EXIT_22
00000364                           832m     ENDM
00000364                           833  
00000364                           834  GET_INPUT
00000364                           835m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           836m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      837m     IFEQ DEBUG
00000364  1639 00C00003            838m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                839m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     840m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           841m     ENDC
00000370                           842m 
00000370                           843mm     READ_CHAR D2
00000370                 TRUE      844mm     IFEQ DEBUG
00000370  1439 00C00007            845mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           846mm     ENDC
00000376                 FALSE     847mm     IFNE DEBUG
00000376                           848mm     ENDC
00000376                           849mm 
00000376  B43C 001B                850mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                851mm     BEQ START
0000037E                           852mm     ENDM
0000037E                           853m 
0000037E                 TRUE      854m     IFEQ DEBUG
0000037E                           855mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           856mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      857mm     IFEQ DEBUG
0000037E  1639 00C00003            858mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                859mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     860mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            861mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           862mm     ENDC
00000390                           863mm 
00000390                 FALSE     864mm     IFNE DEBUG
00000390                           865mm     ENDC
00000390                           866mm 
00000390                           867mm     ENDM
00000390                           868m     ENDC
00000390                           869m     ENDM
00000390                           870  
00000390                           871      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                872s     CMP.B   #'0',D2
00000394  6D00 000E                873s     BLT _00000001
00000398  B43C 0039                874s     CMP.B   #'9',D2
0000039C  6E00 0006                875s     BGT _00000001
000003A0  6000 1520                876          BRA HEX_DIGIT
000003A4                           877      ENDI
000003A4                           878s _00000001
000003A4                           879      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                880s     CMP.B   #'A',D2
000003A8  6D00 000E                881s     BLT _00000002
000003AC  B43C 0046                882s     CMP.B   #'F',D2
000003B0  6E00 0006                883s     BGT _00000002
000003B4  6000 150C                884          BRA HEX_DIGIT
000003B8                           885      ENDI
000003B8                           886s _00000002
000003B8                           887  
000003B8  B43C 0077                888      CMP.B #'w',D2
000003BC  6700 01B2                889      BEQ W
000003C0                           890  
000003C0  B43C 006C                891      CMP.B #'l',D2
000003C4  6700 0994                892      BEQ L 
000003C8                           893  
000003C8  B43C 0070                894      CMP.B #'p',D2
000003CC  6700 0C6E                895      BEQ P
000003D0                           896  
000003D0                           897m     PRINT_CRLF D3,A0
000003D0  41FA 18DD                898m     LEA CRLF(PC),A0
000003D4                           899mm     PRINT_STR A0,D3
000003D4                           900mm LOOP_28
000003D4  0C10 0000                901mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                902mm     BEQ EXIT_28
000003DC                           903mmm     PRINT_CHAR (A0)+,D3
000003DC                           904mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      905mmm     IFEQ DEBUG
000003DC  1639 00C00003            906mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                907mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     908mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            909mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           910mmm     ENDC
000003EE                           911mmm 
000003EE                 FALSE     912mmm     IFNE DEBUG
000003EE                           913mmm     ENDC
000003EE                           914mmm 
000003EE                           915mmm     ENDM
000003EE  60E4                     916mm     BRA LOOP_28
000003F0                           917mm EXIT_28
000003F0                           918mm     ENDM
000003F0                           919m     ENDM
000003F0                           920   
000003F0  B43C 003F                921      CMP.B #'?',D2
000003F4  6700 0076                922      BEQ H
000003F8                           923   
000003F8  B43C 0076                924      CMP.B #'v',D2
000003FC  6700 0076                925      BEQ V
00000400                           926      
00000400  B43C 0072                927      CMP.B #'r',D2
00000404  6700 0092                928      BEQ R
00000408                           929  
00000408  B43C 0073                930      CMP.B #'s',D2
0000040C  6700 01DC                931      BEQ S
00000410                           932  
00000410  B43C 0067                933      CMP.B #'g',D2
00000414  6700 084E                934      BEQ G   
00000418                           935  
00000418  B43C 007A                936      CMP.B #'z',D2
0000041C  6700 084C                937      BEQ Z   
00000420                           938  
00000420  B43C 0078                939      CMP.B #'x',D2
00000424  6700 0DE6                940      BEQ X
00000428                           941  
00000428  B43C 0049                942      CMP.B #'I',D2
0000042C  6700 0EFA                943      BEQ EI
00000430                           944  
00000430  B43C 006F                945      CMP.B #'o',D2
00000434  6700 0F02                946      BEQ DI
00000438                           947  
00000438  B43C 0023                948      CMP.B #'#',D2
0000043C  6700 0F0A                949      BEQ HASH
00000440                           950  
00000440  B43C 0069                951      CMP.B #'i',D2
00000444  6700 0F18                952      BEQ I
00000448                           953  
00000448  41FA 17C8                954      LEA HUH(PC),A0
0000044C                           955m     PRINT_STR A0,D3
0000044C                           956m LOOP_30
0000044C  0C10 0000                957m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000450  6700 0016                958m     BEQ EXIT_30
00000454                           959mm     PRINT_CHAR (A0)+,D3
00000454                           960mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000454                 TRUE      961mm     IFEQ DEBUG
00000454  1639 00C00003            962mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000045A  0803 0002                963mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000045E  67F4                     964mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000460  13D8 00C00007            965mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000466                           966mm     ENDC
00000466                           967mm 
00000466                 FALSE     968mm     IFNE DEBUG
00000466                           969mm     ENDC
00000466                           970mm 
00000466                           971mm     ENDM
00000466  60E4                     972m     BRA LOOP_30
00000468                           973m EXIT_30
00000468                           974m     ENDM
00000468                           975  
00000468  6000 FEDA                976      BRA MAIN_LOOP
0000046C                           977  
0000046C                           978  ; commands
0000046C                           979  H
0000046C  41FA 162F                980      LEA HELP(PC),A0
00000470  6000 0006                981      BRA PRINTIT
00000474                           982  
00000474                           983  V
00000474  41FA 18EF                984      LEA VERSION(PC),A0
00000478                           985  PRINTIT
00000478                           986m     PRINT_STR A0,D3    
00000478                           987m LOOP_32
00000478  0C10 0000                988m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000047C  6700 0016                989m     BEQ EXIT_32
00000480                           990mm     PRINT_CHAR (A0)+,D3
00000480                           991mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000480                 TRUE      992mm     IFEQ DEBUG
00000480  1639 00C00003            993mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000486  0803 0002                994mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000048A  67F4                     995mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000048C  13D8 00C00007            996mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000492                           997mm     ENDC
00000492                           998mm 
00000492                 FALSE     999mm     IFNE DEBUG
00000492                          1000mm     ENDC
00000492                          1001mm 
00000492                          1002mm     ENDM
00000492  60E4                    1003m     BRA LOOP_32
00000494                          1004m EXIT_32
00000494                          1005m     ENDM
00000494  6000 FEAE               1006      BRA MAIN_LOOP
00000498                          1007  
00000498                          1008  R
00000498  2047                    1009      MOVE.L D7,A0                                    ; address accumulator -> address register
0000049A  7E00                    1010      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000049C  2410                    1011      MOVE.L (A0),D2                                  ; read the memory and print it
0000049E                          1012m     PRINT_REG D2,D3,D4,D5,A0
0000049E  41FA 1815               1013m     LEA OX(PC),A0
000004A2                          1014mm     PRINT_STR A0,D3
000004A2                          1015mm LOOP_35
000004A2  0C10 0000               1016mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004A6  6700 0016               1017mm     BEQ EXIT_35
000004AA                          1018mmm     PRINT_CHAR (A0)+,D3
000004AA                          1019mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AA                 TRUE     1020mmm     IFEQ DEBUG
000004AA  1639 00C00003           1021mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004B0  0803 0002               1022mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004B4  67F4                    1023mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004B6  13D8 00C00007           1024mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004BC                          1025mmm     ENDC
000004BC                          1026mmm 
000004BC                 FALSE    1027mmm     IFNE DEBUG
000004BC                          1028mmm     ENDC
000004BC                          1029mmm 
000004BC                          1030mmm     ENDM
000004BC  60E4                    1031mm     BRA LOOP_35
000004BE                          1032mm EXIT_35
000004BE                          1033mm     ENDM
000004BE  7A07                    1034m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004C0                          1035m LOOP_34
000004C0                          1036mm     BIN2HEX D2,D4,A0
000004C0  41FA 17B2               1037mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004C4  E99A                    1038mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004C6  1802                    1039mm     MOVE.B D2,D4
000004C8  0284 0000000F           1040mm     ANDI.L #$F,D4
000004CE  1830 4000               1041mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004D2                          1042mm     ENDM
000004D2                          1043mm     PRINT_CHAR D4,D3
000004D2                          1044mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D2                 TRUE     1045mm     IFEQ DEBUG
000004D2  1639 00C00003           1046mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004D8  0803 0002               1047mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004DC  67F4                    1048mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004DE  13C4 00C00007           1049mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E4                          1050mm     ENDC
000004E4                          1051mm 
000004E4                 FALSE    1052mm     IFNE DEBUG
000004E4                          1053mm     ENDC
000004E4                          1054mm 
000004E4                          1055mm     ENDM
000004E4  57CD FFDA               1056m     DBEQ D5,LOOP_34
000004E8                          1057m     ENDM
000004E8                          1058      
000004E8                          1059m     PRINT_CHAR #32,D3
000004E8                          1060m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E8                 TRUE     1061m     IFEQ DEBUG
000004E8  1639 00C00003           1062m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EE  0803 0002               1063m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F2  67F4                    1064m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004F4  13FC 0020 00C00007      1065m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004FC                          1066m     ENDC
000004FC                          1067m 
000004FC                 FALSE    1068m     IFNE DEBUG
000004FC                          1069m     ENDC
000004FC                          1070m 
000004FC                          1071m     ENDM
000004FC                          1072  
000004FC  E19A                    1073      ROL.L #8,D2
000004FE                          1074m     PRINT_CHAR D2,D3
000004FE                          1075m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FE                 TRUE     1076m     IFEQ DEBUG
000004FE  1639 00C00003           1077m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000504  0803 0002               1078m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000508  67F4                    1079m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000050A  13C2 00C00007           1080m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000510                          1081m     ENDC
00000510                          1082m 
00000510                 FALSE    1083m     IFNE DEBUG
00000510                          1084m     ENDC
00000510                          1085m 
00000510                          1086m     ENDM
00000510  E19A                    1087      ROL.L #8,D2
00000512                          1088m     PRINT_CHAR D2,D3
00000512                          1089m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1090m     IFEQ DEBUG
00000512  1639 00C00003           1091m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1092m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1093m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1094m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1095m     ENDC
00000524                          1096m 
00000524                 FALSE    1097m     IFNE DEBUG
00000524                          1098m     ENDC
00000524                          1099m 
00000524                          1100m     ENDM
00000524  E19A                    1101      ROL.L #8,D2
00000526                          1102m     PRINT_CHAR D2,D3
00000526                          1103m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1104m     IFEQ DEBUG
00000526  1639 00C00003           1105m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1106m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1107m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1108m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1109m     ENDC
00000538                          1110m 
00000538                 FALSE    1111m     IFNE DEBUG
00000538                          1112m     ENDC
00000538                          1113m 
00000538                          1114m     ENDM
00000538  E19A                    1115      ROL.L #8,D2
0000053A                          1116m     PRINT_CHAR D2,D3
0000053A                          1117m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1118m     IFEQ DEBUG
0000053A  1639 00C00003           1119m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1120m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1121m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1122m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1123m     ENDC
0000054C                          1124m 
0000054C                 FALSE    1125m     IFNE DEBUG
0000054C                          1126m     ENDC
0000054C                          1127m 
0000054C                          1128m     ENDM
0000054C                          1129  
0000054C                          1130m     PRINT_CRLF D3,A0
0000054C  41FA 1761               1131m     LEA CRLF(PC),A0
00000550                          1132mm     PRINT_STR A0,D3
00000550                          1133mm LOOP_45
00000550  0C10 0000               1134mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000554  6700 0016               1135mm     BEQ EXIT_45
00000558                          1136mmm     PRINT_CHAR (A0)+,D3
00000558                          1137mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000558                 TRUE     1138mmm     IFEQ DEBUG
00000558  1639 00C00003           1139mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000055E  0803 0002               1140mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000562  67F4                    1141mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000564  13D8 00C00007           1142mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000056A                          1143mmm     ENDC
0000056A                          1144mmm 
0000056A                 FALSE    1145mmm     IFNE DEBUG
0000056A                          1146mmm     ENDC
0000056A                          1147mmm 
0000056A                          1148mmm     ENDM
0000056A  60E4                    1149mm     BRA LOOP_45
0000056C                          1150mm EXIT_45
0000056C                          1151mm     ENDM
0000056C                          1152m     ENDM
0000056C                          1153      
0000056C  6000 FDD6               1154      BRA MAIN_LOOP
00000570                          1155  
00000570                          1156  W
00000570                          1157      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000570  3C3C 0000               1158s     MOVE.W  #0,D6
00000574  6000 0046               1159s     BRA _20000005
00000578                          1160s _20000004
00000578  E98D                    1161          LSL.L #4,D5                                     ; make what we have so far more significant
0000057A                          1162m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000057A                          1163m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000057A                 TRUE     1164m     IFEQ DEBUG
0000057A  1639 00C00003           1165m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000580  0803 0000               1166m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000584  67F4                    1167m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000586                          1168m     ENDC
00000586                          1169m 
00000586                          1170mm     READ_CHAR D2
00000586                 TRUE     1171mm     IFEQ DEBUG
00000586  1439 00C00007           1172mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000058C                          1173mm     ENDC
0000058C                 FALSE    1174mm     IFNE DEBUG
0000058C                          1175mm     ENDC
0000058C                          1176mm 
0000058C  B43C 001B               1177mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000590  6700 FB72               1178mm     BEQ START
00000594                          1179mm     ENDM
00000594                          1180m 
00000594                 TRUE     1181m     IFEQ DEBUG
00000594                          1182mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000594                          1183mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000594                 TRUE     1184mm     IFEQ DEBUG
00000594  1639 00C00003           1185mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000059A  0803 0002               1186mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000059E  67F4                    1187mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005A0  13C2 00C00007           1188mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005A6                          1189mm     ENDC
000005A6                          1190mm 
000005A6                 FALSE    1191mm     IFNE DEBUG
000005A6                          1192mm     ENDC
000005A6                          1193mm 
000005A6                          1194mm     ENDM
000005A6                          1195m     ENDC
000005A6                          1196m     ENDM
000005A6                          1197m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005A6  41FA 16DC               1198m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005AA  0402 0030               1199m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005AE  C4BC 000000FF           1200m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005B4  1430 2000               1201m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005B8                          1202m     ENDM
000005B8  8A02                    1203          OR.B D2,D5
000005BA                          1204      ENDF
000005BA  5246                    1205s     ADD.W   #1,D6
000005BC                          1206s _20000005
000005BC  BC7C 0007               1207s     CMP.W   #7,D6
000005C0  6FB6                    1208s     BLE _20000004
000005C2                          1209  
000005C2                          1210m     PRINT_CRLF D3,A0
000005C2  41FA 16EB               1211m     LEA CRLF(PC),A0
000005C6                          1212mm     PRINT_STR A0,D3
000005C6                          1213mm LOOP_52
000005C6  0C10 0000               1214mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005CA  6700 0016               1215mm     BEQ EXIT_52
000005CE                          1216mmm     PRINT_CHAR (A0)+,D3
000005CE                          1217mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CE                 TRUE     1218mmm     IFEQ DEBUG
000005CE  1639 00C00003           1219mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005D4  0803 0002               1220mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005D8  67F4                    1221mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005DA  13D8 00C00007           1222mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005E0                          1223mmm     ENDC
000005E0                          1224mmm 
000005E0                 FALSE    1225mmm     IFNE DEBUG
000005E0                          1226mmm     ENDC
000005E0                          1227mmm 
000005E0                          1228mmm     ENDM
000005E0  60E4                    1229mm     BRA LOOP_52
000005E2                          1230mm EXIT_52
000005E2                          1231mm     ENDM
000005E2                          1232m     ENDM
000005E2                          1233  
000005E2  2047                    1234      MOVE.L D7,A0                                    ; address accumulator -> address register
000005E4                          1235  
000005E4  2085                    1236      MOVE.L D5,(A0)                                  ; write the data
000005E6                          1237  
000005E6  6000 FD5C               1238      BRA MAIN_LOOP
000005EA                          1239  
000005EA                          1240  ; register map for S
000005EA                          1241  ; A0 - start address
000005EA                          1242  ; A1 - offset
000005EA                          1243  ; A2 - next address to write
000005EA                          1244  ; A3 - next location (jmp)
000005EA                          1245  ; A4 - Working Address Register
000005EA                          1246  ; D0 - record count
000005EA                          1247  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005EA                          1248  ; D2 - checksum
000005EA                          1249  ; D3 - data byte count
000005EA                          1250  ; D4 - read address, moved into A2
000005EA                          1251  ; D5 - temp
000005EA                          1252  ; D6 - temp
000005EA                          1253  ; D7 - temp
000005EA                          1254  S
000005EA  2078 0000               1255      MOVE.L 0,A0                                     ; start address -> A0
000005EE  2247                    1256      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005F0  7E00                    1257      MOVE.L #0,D7
000005F2  7000                    1258      MOVE.L #0,D0                                    ; count of records read -> D0
000005F4                          1259          
000005F4                          1260  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005F4                          1261m     DOWNLOAD D1
000005F4                          1262m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F4                          1263m 
000005F4  1239 00C00003           1264m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005FA  0801 0000               1265m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005FE  6700 0010               1266m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000602                          1267m 
00000602                          1268mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000602                 TRUE     1269mm     IFEQ DEBUG
00000602  1239 00C00007           1270mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000608                          1271mm     ENDC
00000608                 FALSE    1272mm     IFNE DEBUG
00000608                          1273mm     ENDC
00000608                          1274mm 
00000608  B23C 001B               1275mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000060C  6700 FAF6               1276mm     BEQ START
00000610                          1277mm     ENDM
00000610                          1278m CONTINUE_54
00000610  1239 00C00013           1279m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000616  0801 0000               1280m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061A  67D8                    1281m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
0000061C                          1282m     
0000061C  1239 00C00017           1283m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000622  13C1 00E00001           1284m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000628                          1285m 
00000628                          1286m     ENDM
00000628  B23C 0053               1287      CMP.B #'S',D1                                   ; found S?
0000062C  66C6                    1288      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
0000062E                          1289      
0000062E                          1290m     PRINT_CHAR #'.',D5                              ; print a progress indicator
0000062E                          1291m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000062E                 TRUE     1292m     IFEQ DEBUG
0000062E  1A39 00C00003           1293m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000634  0805 0002               1294m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000638  67F4                    1295m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000063A  13FC 002E 00C00007      1296m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000642                          1297m     ENDC
00000642                          1298m 
00000642                 FALSE    1299m     IFNE DEBUG
00000642                          1300m     ENDC
00000642                          1301m 
00000642                          1302m     ENDM
00000642                          1303      ;PRINT_CHAR #'S',D5                             ; print the S
00000642  5280                    1304      ADD.L #1,D0                                     ; read another S record, increment count
00000644                          1305      
00000644                          1306m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000644                          1307m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000644                          1308m 
00000644  1239 00C00003           1309m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000064A  0801 0000               1310m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000064E  6700 0010               1311m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000652                          1312m 
00000652                          1313mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000652                 TRUE     1314mm     IFEQ DEBUG
00000652  1239 00C00007           1315mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000658                          1316mm     ENDC
00000658                 FALSE    1317mm     IFNE DEBUG
00000658                          1318mm     ENDC
00000658                          1319mm 
00000658  B23C 001B               1320mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000065C  6700 FAA6               1321mm     BEQ START
00000660                          1322mm     ENDM
00000660                          1323m CONTINUE_57
00000660  1239 00C00013           1324m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000666  0801 0000               1325m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000066A  67D8                    1326m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000066C                          1327m     
0000066C  1239 00C00017           1328m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000672  13C1 00E00001           1329m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000678                          1330m 
00000678                          1331m     ENDM
00000678                          1332      ;PRINT_CHAR D1,D5
00000678                          1333  
00000678  7400                    1334      MOVE.L #0,D2                                    ; clear the checksum
0000067A                          1335  
0000067A                          1336m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000067A  1E3C 0002               1337m     MOVE.B #2,D7
0000067E                          1338m     WHILE.B D7 <GT> 0 DO
0000067E                          1339ms _10000000
0000067E  BE38 0000               1340ms     CMP.B   0,D7
00000682  6F00 0050               1341ms     BLE _10000001
00000686  E98B                    1342m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000688                          1343mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000688                          1344mm WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000688                          1345mm 
00000688  1A39 00C00003           1346mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000068E  0805 0000               1347mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000692  6700 0010               1348mm     BEQ CONTINUE_60                                 ; NOTHING, CONTINUE
00000696                          1349mm 
00000696                          1350mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000696                 TRUE     1351mmm     IFEQ DEBUG
00000696  1A39 00C00007           1352mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000069C                          1353mmm     ENDC
0000069C                 FALSE    1354mmm     IFNE DEBUG
0000069C                          1355mmm     ENDC
0000069C                          1356mmm 
0000069C  BA3C 001B               1357mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006A0  6700 FA62               1358mmm     BEQ START
000006A4                          1359mmm     ENDM
000006A4                          1360mm CONTINUE_60
000006A4  1A39 00C00013           1361mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006AA  0805 0000               1362mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006AE  67D8                    1363mm     BEQ WAIT_FOR_READY_60                           ; NOTHING, CHECK AGAIN
000006B0                          1364mm     
000006B0  1A39 00C00017           1365mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006B6  13C5 00E00001           1366mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006BC                          1367mm 
000006BC                          1368mm     ENDM
000006BC                          1369m         ;PRINT_CHAR D5,D6
000006BC                          1370mm         HEX2BIN D5,D5,A4
000006BC  49FA 15C6               1371mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006C0  0405 0030               1372mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006C4  CABC 000000FF           1373mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006CA  1A34 5000               1374mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006CE                          1375mm     ENDM
000006CE  8605                    1376m         OR.B D5,D3
000006D0  5307                    1377m         SUB.B #1,D7
000006D2                          1378m     ENDW
000006D2  60AA                    1379ms     BRA _10000000
000006D4                          1380ms _10000001
000006D4                          1381m 
000006D4  7A00                    1382m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006D6  1A03                    1383m     MOVE.B D3,D5
000006D8  D483                    1384m     ADD.L D3,D2
000006DA                          1385m 
000006DA                          1386m     ENDM
000006DA                          1387  
000006DA                          1388      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006DA  B23C 0030               1389s     CMP.B   #'0',D1
000006DE  6600 000A               1390s     BNE.L   _00000003
000006E2                          1391          ;PRINT_CRLF D5,A4
000006E2  6000 FF10               1392          BRA WAIT_FOR_SRECORD
000006E6                          1393      ELSE
000006E6  6000 0360               1394s     BRA _00000004
000006EA                          1395s _00000003
000006EA                          1396          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006EA  B23C 0031               1397s     CMP.B   #'1',D1
000006EE  6708                    1398s     BEQ.S   _00000005
000006F0  B23C 0032               1399s     CMP.B   #'2',D1
000006F4  6600 01A8               1400s     BNE.L   _00000006
000006F8                          1401s _00000005
000006F8  5783                    1402              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000006FA                          1403  
000006FA  7800                    1404              MOVE.L #0,D4                            ; read two bytes of address
000006FC                          1405m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000006FC  1E3C 0002               1406m     MOVE.B #2,D7
00000700                          1407m     WHILE.B D7 <GT> 0 DO
00000700                          1408ms _10000002
00000700  BE38 0000               1409ms     CMP.B   0,D7
00000704  6F00 0050               1410ms     BLE _10000003
00000708  E98C                    1411m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000070A                          1412mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000070A                          1413mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000070A                          1414mm 
0000070A  1A39 00C00003           1415mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000710  0805 0000               1416mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000714  6700 0010               1417mm     BEQ CONTINUE_64                                 ; NOTHING, CONTINUE
00000718                          1418mm 
00000718                          1419mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000718                 TRUE     1420mmm     IFEQ DEBUG
00000718  1A39 00C00007           1421mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000071E                          1422mmm     ENDC
0000071E                 FALSE    1423mmm     IFNE DEBUG
0000071E                          1424mmm     ENDC
0000071E                          1425mmm 
0000071E  BA3C 001B               1426mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000722  6700 F9E0               1427mmm     BEQ START
00000726                          1428mmm     ENDM
00000726                          1429mm CONTINUE_64
00000726  1A39 00C00013           1430mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000072C  0805 0000               1431mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000730  67D8                    1432mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
00000732                          1433mm     
00000732  1A39 00C00017           1434mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000738  13C5 00E00001           1435mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000073E                          1436mm 
0000073E                          1437mm     ENDM
0000073E                          1438m         ;PRINT_CHAR D5,D6
0000073E                          1439mm         HEX2BIN D5,D5,A4
0000073E  49FA 1544               1440mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000742  0405 0030               1441mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000746  CABC 000000FF           1442mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000074C  1A34 5000               1443mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000750                          1444mm     ENDM
00000750  8805                    1445m         OR.B D5,D4
00000752  5307                    1446m         SUB.B #1,D7
00000754                          1447m     ENDW
00000754  60AA                    1448ms     BRA _10000002
00000756                          1449ms _10000003
00000756                          1450m 
00000756  7A00                    1451m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000758  1A04                    1452m     MOVE.B D4,D5
0000075A  D484                    1453m     ADD.L D4,D2
0000075C                          1454m 
0000075C                          1455m     ENDM
0000075C                          1456m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
0000075C  1E3C 0002               1457m     MOVE.B #2,D7
00000760                          1458m     WHILE.B D7 <GT> 0 DO
00000760                          1459ms _10000004
00000760  BE38 0000               1460ms     CMP.B   0,D7
00000764  6F00 0050               1461ms     BLE _10000005
00000768  E98C                    1462m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000076A                          1463mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000076A                          1464mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076A                          1465mm 
0000076A  1A39 00C00003           1466mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000770  0805 0000               1467mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000774  6700 0010               1468mm     BEQ CONTINUE_68                                 ; NOTHING, CONTINUE
00000778                          1469mm 
00000778                          1470mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000778                 TRUE     1471mmm     IFEQ DEBUG
00000778  1A39 00C00007           1472mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000077E                          1473mmm     ENDC
0000077E                 FALSE    1474mmm     IFNE DEBUG
0000077E                          1475mmm     ENDC
0000077E                          1476mmm 
0000077E  BA3C 001B               1477mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000782  6700 F980               1478mmm     BEQ START
00000786                          1479mmm     ENDM
00000786                          1480mm CONTINUE_68
00000786  1A39 00C00013           1481mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000078C  0805 0000               1482mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000790  67D8                    1483mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
00000792                          1484mm     
00000792  1A39 00C00017           1485mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000798  13C5 00E00001           1486mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000079E                          1487mm 
0000079E                          1488mm     ENDM
0000079E                          1489m         ;PRINT_CHAR D5,D6
0000079E                          1490mm         HEX2BIN D5,D5,A4
0000079E  49FA 14E4               1491mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007A2  0405 0030               1492mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007A6  CABC 000000FF           1493mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007AC  1A34 5000               1494mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007B0                          1495mm     ENDM
000007B0  8805                    1496m         OR.B D5,D4
000007B2  5307                    1497m         SUB.B #1,D7
000007B4                          1498m     ENDW
000007B4  60AA                    1499ms     BRA _10000004
000007B6                          1500ms _10000005
000007B6                          1501m 
000007B6  7A00                    1502m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B8  1A04                    1503m     MOVE.B D4,D5
000007BA  D484                    1504m     ADD.L D4,D2
000007BC                          1505m 
000007BC                          1506m     ENDM
000007BC                          1507  
000007BC                          1508              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000007BC  B23C 0032               1509s     CMP.B   #'2',D1
000007C0  6600 0064               1510s     BNE.L   _00000007
000007C4  5383                    1511                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000007C6                          1512m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000007C6  1E3C 0002               1513m     MOVE.B #2,D7
000007CA                          1514m     WHILE.B D7 <GT> 0 DO
000007CA                          1515ms _10000006
000007CA  BE38 0000               1516ms     CMP.B   0,D7
000007CE  6F00 0050               1517ms     BLE _10000007
000007D2  E98C                    1518m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007D4                          1519mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007D4                          1520mm WAIT_FOR_READY_72                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007D4                          1521mm 
000007D4  1A39 00C00003           1522mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007DA  0805 0000               1523mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007DE  6700 0010               1524mm     BEQ CONTINUE_72                                 ; NOTHING, CONTINUE
000007E2                          1525mm 
000007E2                          1526mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007E2                 TRUE     1527mmm     IFEQ DEBUG
000007E2  1A39 00C00007           1528mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007E8                          1529mmm     ENDC
000007E8                 FALSE    1530mmm     IFNE DEBUG
000007E8                          1531mmm     ENDC
000007E8                          1532mmm 
000007E8  BA3C 001B               1533mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007EC  6700 F916               1534mmm     BEQ START
000007F0                          1535mmm     ENDM
000007F0                          1536mm CONTINUE_72
000007F0  1A39 00C00013           1537mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007F6  0805 0000               1538mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007FA  67D8                    1539mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
000007FC                          1540mm     
000007FC  1A39 00C00017           1541mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000802  13C5 00E00001           1542mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000808                          1543mm 
00000808                          1544mm     ENDM
00000808                          1545m         ;PRINT_CHAR D5,D6
00000808                          1546mm         HEX2BIN D5,D5,A4
00000808  49FA 147A               1547mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000080C  0405 0030               1548mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000810  CABC 000000FF           1549mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000816  1A34 5000               1550mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000081A                          1551mm     ENDM
0000081A  8805                    1552m         OR.B D5,D4
0000081C  5307                    1553m         SUB.B #1,D7
0000081E                          1554m     ENDW
0000081E  60AA                    1555ms     BRA _10000006
00000820                          1556ms _10000007
00000820                          1557m 
00000820  7A00                    1558m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000822  1A04                    1559m     MOVE.B D4,D5
00000824  D484                    1560m     ADD.L D4,D2
00000826                          1561m 
00000826                          1562m     ENDM
00000826                          1563              ENDI
00000826                          1564s _00000007
00000826                          1565  
00000826  2444                    1566              MOVE.L D4,A2                            ; put the address in an address register
00000828  D5C9                    1567              ADD.L A1,A2                             ; add in the offset
0000082A                          1568  
0000082A                          1569              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000082A                          1570s _10000008
0000082A  B63C 0000               1571s     CMP.B   #0,D3
0000082E  6F00 0068               1572s     BLE _10000009
00000832                          1573m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000832  1E3C 0002               1574m     MOVE.B #2,D7
00000836                          1575m     WHILE.B D7 <GT> 0 DO
00000836                          1576ms _1000000A
00000836  BE38 0000               1577ms     CMP.B   0,D7
0000083A  6F00 0050               1578ms     BLE _1000000B
0000083E  E989                    1579m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000840                          1580mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000840                          1581mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                          1582mm 
00000840  1A39 00C00003           1583mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000846  0805 0000               1584mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000084A  6700 0010               1585mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
0000084E                          1586mm 
0000084E                          1587mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084E                 TRUE     1588mmm     IFEQ DEBUG
0000084E  1A39 00C00007           1589mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000854                          1590mmm     ENDC
00000854                 FALSE    1591mmm     IFNE DEBUG
00000854                          1592mmm     ENDC
00000854                          1593mmm 
00000854  BA3C 001B               1594mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000858  6700 F8AA               1595mmm     BEQ START
0000085C                          1596mmm     ENDM
0000085C                          1597mm CONTINUE_76
0000085C  1A39 00C00013           1598mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000862  0805 0000               1599mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000866  67D8                    1600mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00000868                          1601mm     
00000868  1A39 00C00017           1602mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000086E  13C5 00E00001           1603mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000874                          1604mm 
00000874                          1605mm     ENDM
00000874                          1606m         ;PRINT_CHAR D5,D6
00000874                          1607mm         HEX2BIN D5,D5,A4
00000874  49FA 140E               1608mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000878  0405 0030               1609mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000087C  CABC 000000FF           1610mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000882  1A34 5000               1611mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000886                          1612mm     ENDM
00000886  8205                    1613m         OR.B D5,D1
00000888  5307                    1614m         SUB.B #1,D7
0000088A                          1615m     ENDW
0000088A  60AA                    1616ms     BRA _1000000A
0000088C                          1617ms _1000000B
0000088C                          1618m 
0000088C  7A00                    1619m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000088E  1A01                    1620m     MOVE.B D1,D5
00000890  D481                    1621m     ADD.L D1,D2
00000892                          1622m 
00000892                          1623m     ENDM
00000892                          1624   
00000892  14C1                    1625                  MOVE.B D1,(A2)+                     ; store it!
00000894                          1626  
00000894  5303                    1627                  SUB.B #1,D3                         ; 1 less byte to go
00000896                          1628              ENDW
00000896  6092                    1629s     BRA _10000008
00000898                          1630s _10000009
00000898                          1631  
00000898  7200                    1632              MOVE.L #0,D1                            ; not done yet
0000089A                          1633          ELSE
0000089A  6000 01AC               1634s     BRA _00000008
0000089E                          1635s _00000006
0000089E                          1636              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
0000089E  B23C 0038               1637s     CMP.B   #'8',D1
000008A2  6600 012E               1638s     BNE.L   _00000009
000008A6  7800                    1639                  MOVE.L #0,D4                        ; read the 24 bit start address
000008A8                          1640m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000008A8  1E3C 0002               1641m     MOVE.B #2,D7
000008AC                          1642m     WHILE.B D7 <GT> 0 DO
000008AC                          1643ms _1000000C
000008AC  BE38 0000               1644ms     CMP.B   0,D7
000008B0  6F00 0050               1645ms     BLE _1000000D
000008B4  E98C                    1646m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008B6                          1647mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008B6                          1648mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008B6                          1649mm 
000008B6  1A39 00C00003           1650mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008BC  0805 0000               1651mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C0  6700 0010               1652mm     BEQ CONTINUE_80                                 ; NOTHING, CONTINUE
000008C4                          1653mm 
000008C4                          1654mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008C4                 TRUE     1655mmm     IFEQ DEBUG
000008C4  1A39 00C00007           1656mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008CA                          1657mmm     ENDC
000008CA                 FALSE    1658mmm     IFNE DEBUG
000008CA                          1659mmm     ENDC
000008CA                          1660mmm 
000008CA  BA3C 001B               1661mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008CE  6700 F834               1662mmm     BEQ START
000008D2                          1663mmm     ENDM
000008D2                          1664mm CONTINUE_80
000008D2  1A39 00C00013           1665mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008D8  0805 0000               1666mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008DC  67D8                    1667mm     BEQ WAIT_FOR_READY_80                           ; NOTHING, CHECK AGAIN
000008DE                          1668mm     
000008DE  1A39 00C00017           1669mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008E4  13C5 00E00001           1670mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008EA                          1671mm 
000008EA                          1672mm     ENDM
000008EA                          1673m         ;PRINT_CHAR D5,D6
000008EA                          1674mm         HEX2BIN D5,D5,A4
000008EA  49FA 1398               1675mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008EE  0405 0030               1676mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008F2  CABC 000000FF           1677mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008F8  1A34 5000               1678mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008FC                          1679mm     ENDM
000008FC  8805                    1680m         OR.B D5,D4
000008FE  5307                    1681m         SUB.B #1,D7
00000900                          1682m     ENDW
00000900  60AA                    1683ms     BRA _1000000C
00000902                          1684ms _1000000D
00000902                          1685m 
00000902  7A00                    1686m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000904  1A04                    1687m     MOVE.B D4,D5
00000906  D484                    1688m     ADD.L D4,D2
00000908                          1689m 
00000908                          1690m     ENDM
00000908                          1691m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000908  1E3C 0002               1692m     MOVE.B #2,D7
0000090C                          1693m     WHILE.B D7 <GT> 0 DO
0000090C                          1694ms _1000000E
0000090C  BE38 0000               1695ms     CMP.B   0,D7
00000910  6F00 0050               1696ms     BLE _1000000F
00000914  E98C                    1697m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000916                          1698mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000916                          1699mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000916                          1700mm 
00000916  1A39 00C00003           1701mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000091C  0805 0000               1702mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000920  6700 0010               1703mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000924                          1704mm 
00000924                          1705mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000924                 TRUE     1706mmm     IFEQ DEBUG
00000924  1A39 00C00007           1707mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000092A                          1708mmm     ENDC
0000092A                 FALSE    1709mmm     IFNE DEBUG
0000092A                          1710mmm     ENDC
0000092A                          1711mmm 
0000092A  BA3C 001B               1712mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000092E  6700 F7D4               1713mmm     BEQ START
00000932                          1714mmm     ENDM
00000932                          1715mm CONTINUE_84
00000932  1A39 00C00013           1716mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000938  0805 0000               1717mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000093C  67D8                    1718mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
0000093E                          1719mm     
0000093E  1A39 00C00017           1720mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000944  13C5 00E00001           1721mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000094A                          1722mm 
0000094A                          1723mm     ENDM
0000094A                          1724m         ;PRINT_CHAR D5,D6
0000094A                          1725mm         HEX2BIN D5,D5,A4
0000094A  49FA 1338               1726mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000094E  0405 0030               1727mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000952  CABC 000000FF           1728mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000958  1A34 5000               1729mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000095C                          1730mm     ENDM
0000095C  8805                    1731m         OR.B D5,D4
0000095E  5307                    1732m         SUB.B #1,D7
00000960                          1733m     ENDW
00000960  60AA                    1734ms     BRA _1000000E
00000962                          1735ms _1000000F
00000962                          1736m 
00000962  7A00                    1737m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000964  1A04                    1738m     MOVE.B D4,D5
00000966  D484                    1739m     ADD.L D4,D2
00000968                          1740m 
00000968                          1741m     ENDM
00000968                          1742m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000968  1E3C 0002               1743m     MOVE.B #2,D7
0000096C                          1744m     WHILE.B D7 <GT> 0 DO
0000096C                          1745ms _10000010
0000096C  BE38 0000               1746ms     CMP.B   0,D7
00000970  6F00 0050               1747ms     BLE _10000011
00000974  E98C                    1748m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000976                          1749mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000976                          1750mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000976                          1751mm 
00000976  1A39 00C00003           1752mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000097C  0805 0000               1753mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000980  6700 0010               1754mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
00000984                          1755mm 
00000984                          1756mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000984                 TRUE     1757mmm     IFEQ DEBUG
00000984  1A39 00C00007           1758mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000098A                          1759mmm     ENDC
0000098A                 FALSE    1760mmm     IFNE DEBUG
0000098A                          1761mmm     ENDC
0000098A                          1762mmm 
0000098A  BA3C 001B               1763mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000098E  6700 F774               1764mmm     BEQ START
00000992                          1765mmm     ENDM
00000992                          1766mm CONTINUE_88
00000992  1A39 00C00013           1767mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000998  0805 0000               1768mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000099C  67D8                    1769mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
0000099E                          1770mm     
0000099E  1A39 00C00017           1771mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009A4  13C5 00E00001           1772mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009AA                          1773mm 
000009AA                          1774mm     ENDM
000009AA                          1775m         ;PRINT_CHAR D5,D6
000009AA                          1776mm         HEX2BIN D5,D5,A4
000009AA  49FA 12D8               1777mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009AE  0405 0030               1778mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009B2  CABC 000000FF           1779mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009B8  1A34 5000               1780mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009BC                          1781mm     ENDM
000009BC  8805                    1782m         OR.B D5,D4
000009BE  5307                    1783m         SUB.B #1,D7
000009C0                          1784m     ENDW
000009C0  60AA                    1785ms     BRA _10000010
000009C2                          1786ms _10000011
000009C2                          1787m 
000009C2  7A00                    1788m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009C4  1A04                    1789m     MOVE.B D4,D5
000009C6  D484                    1790m     ADD.L D4,D2
000009C8                          1791m 
000009C8                          1792m     ENDM
000009C8                          1793  
000009C8  2044                    1794                  MOVE.L D4,A0                        ; start address -> A0
000009CA  D1C9                    1795                  ADD.L A1,A0                         ; add in the offset
000009CC                          1796  
000009CC  72FF                    1797                  MOVE.L #$FFFFFFFF,D1                ; done
000009CE                          1798              ELSE
000009CE  6000 0078               1799s     BRA _0000000A
000009D2                          1800s _00000009
000009D2                          1801m                 PRINT_CRLF D5,A4
000009D2  49FA 12DB               1802m     LEA CRLF(PC),A4
000009D6                          1803mm     PRINT_STR A4,D5
000009D6                          1804mm LOOP_92
000009D6  0C14 0000               1805mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009DA  6700 0016               1806mm     BEQ EXIT_92
000009DE                          1807mmm     PRINT_CHAR (A4)+,D5
000009DE                          1808mmm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009DE                 TRUE     1809mmm     IFEQ DEBUG
000009DE  1A39 00C00003           1810mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009E4  0805 0002               1811mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009E8  67F4                    1812mmm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
000009EA  13DC 00C00007           1813mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009F0                          1814mmm     ENDC
000009F0                          1815mmm 
000009F0                 FALSE    1816mmm     IFNE DEBUG
000009F0                          1817mmm     ENDC
000009F0                          1818mmm 
000009F0                          1819mmm     ENDM
000009F0  60E4                    1820mm     BRA LOOP_92
000009F2                          1821mm EXIT_92
000009F2                          1822mm     ENDM
000009F2                          1823m     ENDM
000009F2                          1824  
000009F2  49FA 1247               1825                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000009F6                          1826m                 PRINT_STR A4,D5
000009F6                          1827m LOOP_94
000009F6  0C14 0000               1828m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009FA  6700 0016               1829m     BEQ EXIT_94
000009FE                          1830mm     PRINT_CHAR (A4)+,D5
000009FE                          1831mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009FE                 TRUE     1832mm     IFEQ DEBUG
000009FE  1A39 00C00003           1833mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A04  0805 0002               1834mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A08  67F4                    1835mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000A0A  13DC 00C00007           1836mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A10                          1837mm     ENDC
00000A10                          1838mm 
00000A10                 FALSE    1839mm     IFNE DEBUG
00000A10                          1840mm     ENDC
00000A10                          1841mm 
00000A10                          1842mm     ENDM
00000A10  60E4                    1843m     BRA LOOP_94
00000A12                          1844m EXIT_94
00000A12                          1845m     ENDM
00000A12                          1846m                 PRINT_CHAR D1,D5
00000A12                          1847m WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A12                 TRUE     1848m     IFEQ DEBUG
00000A12  1A39 00C00003           1849m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A18  0805 0002               1850m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A1C  67F4                    1851m         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
00000A1E  13C1 00C00007           1852m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A24                          1853m     ENDC
00000A24                          1854m 
00000A24                 FALSE    1855m     IFNE DEBUG
00000A24                          1856m     ENDC
00000A24                          1857m 
00000A24                          1858m     ENDM
00000A24                          1859m                 PRINT_CRLF D5,A4
00000A24  49FA 1289               1860m     LEA CRLF(PC),A4
00000A28                          1861mm     PRINT_STR A4,D5
00000A28                          1862mm LOOP_98
00000A28  0C14 0000               1863mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A2C  6700 0016               1864mm     BEQ EXIT_98
00000A30                          1865mmm     PRINT_CHAR (A4)+,D5
00000A30                          1866mmm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A30                 TRUE     1867mmm     IFEQ DEBUG
00000A30  1A39 00C00003           1868mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A36  0805 0002               1869mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A3A  67F4                    1870mmm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
00000A3C  13DC 00C00007           1871mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A42                          1872mmm     ENDC
00000A42                          1873mmm 
00000A42                 FALSE    1874mmm     IFNE DEBUG
00000A42                          1875mmm     ENDC
00000A42                          1876mmm 
00000A42                          1877mmm     ENDM
00000A42  60E4                    1878mm     BRA LOOP_98
00000A44                          1879mm EXIT_98
00000A44                          1880mm     ENDM
00000A44                          1881m     ENDM
00000A44                          1882  
00000A44  6000 FBAE               1883                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000A48                          1884              ENDI
00000A48                          1885s _0000000A
00000A48                          1886          ENDI
00000A48                          1887s _00000008
00000A48                          1888      ENDI
00000A48                          1889s _00000004
00000A48                          1890  
00000A48                          1891m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000A48  1E3C 0002               1892m     MOVE.B #2,D7
00000A4C                          1893m     WHILE.B D7 <GT> 0 DO
00000A4C                          1894ms _10000012
00000A4C  BE38 0000               1895ms     CMP.B   0,D7
00000A50  6F00 0050               1896ms     BLE _10000013
00000A54  E98C                    1897m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A56                          1898mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A56                          1899mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A56                          1900mm 
00000A56  1A39 00C00003           1901mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A5C  0805 0000               1902mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A60  6700 0010               1903mm     BEQ CONTINUE_101                                    ; NOTHING, CONTINUE
00000A64                          1904mm 
00000A64                          1905mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A64                 TRUE     1906mmm     IFEQ DEBUG
00000A64  1A39 00C00007           1907mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A6A                          1908mmm     ENDC
00000A6A                 FALSE    1909mmm     IFNE DEBUG
00000A6A                          1910mmm     ENDC
00000A6A                          1911mmm 
00000A6A  BA3C 001B               1912mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A6E  6700 F694               1913mmm     BEQ START
00000A72                          1914mmm     ENDM
00000A72                          1915mm CONTINUE_101
00000A72  1A39 00C00013           1916mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A78  0805 0000               1917mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A7C  67D8                    1918mm     BEQ WAIT_FOR_READY_101                          ; NOTHING, CHECK AGAIN
00000A7E                          1919mm     
00000A7E  1A39 00C00017           1920mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A84  13C5 00E00001           1921mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A8A                          1922mm 
00000A8A                          1923mm     ENDM
00000A8A                          1924m         ;PRINT_CHAR D5,D6
00000A8A                          1925mm         HEX2BIN D5,D5,A4
00000A8A  49FA 11F8               1926mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A8E  0405 0030               1927mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A92  CABC 000000FF           1928mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A98  1A34 5000               1929mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A9C                          1930mm     ENDM
00000A9C  8805                    1931m         OR.B D5,D4
00000A9E  5307                    1932m         SUB.B #1,D7
00000AA0                          1933m     ENDW
00000AA0  60AA                    1934ms     BRA _10000012
00000AA2                          1935ms _10000013
00000AA2                          1936m 
00000AA2  7A00                    1937m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AA4  1A04                    1938m     MOVE.B D4,D5
00000AA6  D484                    1939m     ADD.L D4,D2
00000AA8                          1940m 
00000AA8                          1941m     ENDM
00000AA8                          1942  
00000AA8                          1943      IF.B D2 <NE> #$FF THEN.L
00000AA8  B43C 00FF               1944s     CMP.B   #$FF,D2
00000AAC  6700 00B0               1945s     BEQ.L   _0000000B
00000AB0                          1946m         PRINT_CRLF D5,A4
00000AB0  49FA 11FD               1947m     LEA CRLF(PC),A4
00000AB4                          1948mm     PRINT_STR A4,D5
00000AB4                          1949mm LOOP_105
00000AB4  0C14 0000               1950mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AB8  6700 0016               1951mm     BEQ EXIT_105
00000ABC                          1952mmm     PRINT_CHAR (A4)+,D5
00000ABC                          1953mmm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ABC                 TRUE     1954mmm     IFEQ DEBUG
00000ABC  1A39 00C00003           1955mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC2  0805 0002               1956mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AC6  67F4                    1957mmm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000AC8  13DC 00C00007           1958mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ACE                          1959mmm     ENDC
00000ACE                          1960mmm 
00000ACE                 FALSE    1961mmm     IFNE DEBUG
00000ACE                          1962mmm     ENDC
00000ACE                          1963mmm 
00000ACE                          1964mmm     ENDM
00000ACE  60E4                    1965mm     BRA LOOP_105
00000AD0                          1966mm EXIT_105
00000AD0                          1967mm     ENDM
00000AD0                          1968m     ENDM
00000AD0  49FA 1180               1969          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000AD4                          1970m         PRINT_STR A4,D5
00000AD4                          1971m LOOP_107
00000AD4  0C14 0000               1972m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AD8  6700 0016               1973m     BEQ EXIT_107
00000ADC                          1974mm     PRINT_CHAR (A4)+,D5
00000ADC                          1975mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ADC                 TRUE     1976mm     IFEQ DEBUG
00000ADC  1A39 00C00003           1977mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AE2  0805 0002               1978mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AE6  67F4                    1979mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AE8  13DC 00C00007           1980mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AEE                          1981mm     ENDC
00000AEE                          1982mm 
00000AEE                 FALSE    1983mm     IFNE DEBUG
00000AEE                          1984mm     ENDC
00000AEE                          1985mm 
00000AEE                          1986mm     ENDM
00000AEE  60E4                    1987m     BRA LOOP_107
00000AF0                          1988m EXIT_107
00000AF0                          1989m     ENDM
00000AF0                          1990m         PRINT_REG D0,D5,D3,D6,A4
00000AF0  49FA 11C3               1991m     LEA OX(PC),A4
00000AF4                          1992mm     PRINT_STR A4,D5
00000AF4                          1993mm LOOP_110
00000AF4  0C14 0000               1994mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AF8  6700 0016               1995mm     BEQ EXIT_110
00000AFC                          1996mmm     PRINT_CHAR (A4)+,D5
00000AFC                          1997mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AFC                 TRUE     1998mmm     IFEQ DEBUG
00000AFC  1A39 00C00003           1999mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B02  0805 0002               2000mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B06  67F4                    2001mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000B08  13DC 00C00007           2002mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B0E                          2003mmm     ENDC
00000B0E                          2004mmm 
00000B0E                 FALSE    2005mmm     IFNE DEBUG
00000B0E                          2006mmm     ENDC
00000B0E                          2007mmm 
00000B0E                          2008mmm     ENDM
00000B0E  60E4                    2009mm     BRA LOOP_110
00000B10                          2010mm EXIT_110
00000B10                          2011mm     ENDM
00000B10  7C07                    2012m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B12                          2013m LOOP_109
00000B12                          2014mm     BIN2HEX D0,D3,A4
00000B12  49FA 1160               2015mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B16  E998                    2016mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B18  1600                    2017mm     MOVE.B D0,D3
00000B1A  0283 0000000F           2018mm     ANDI.L #$F,D3
00000B20  1634 3000               2019mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000B24                          2020mm     ENDM
00000B24                          2021mm     PRINT_CHAR D3,D5
00000B24                          2022mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B24                 TRUE     2023mm     IFEQ DEBUG
00000B24  1A39 00C00003           2024mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B2A  0805 0002               2025mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B2E  67F4                    2026mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000B30  13C3 00C00007           2027mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B36                          2028mm     ENDC
00000B36                          2029mm 
00000B36                 FALSE    2030mm     IFNE DEBUG
00000B36                          2031mm     ENDC
00000B36                          2032mm 
00000B36                          2033mm     ENDM
00000B36  57CE FFDA               2034m     DBEQ D6,LOOP_109
00000B3A                          2035m     ENDM
00000B3A                          2036m         PRINT_CRLF D5,A4
00000B3A  49FA 1173               2037m     LEA CRLF(PC),A4
00000B3E                          2038mm     PRINT_STR A4,D5
00000B3E                          2039mm LOOP_115
00000B3E  0C14 0000               2040mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B42  6700 0016               2041mm     BEQ EXIT_115
00000B46                          2042mmm     PRINT_CHAR (A4)+,D5
00000B46                          2043mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B46                 TRUE     2044mmm     IFEQ DEBUG
00000B46  1A39 00C00003           2045mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B4C  0805 0002               2046mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B50  67F4                    2047mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000B52  13DC 00C00007           2048mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B58                          2049mmm     ENDC
00000B58                          2050mmm 
00000B58                 FALSE    2051mmm     IFNE DEBUG
00000B58                          2052mmm     ENDC
00000B58                          2053mmm 
00000B58                          2054mmm     ENDM
00000B58  60E4                    2055mm     BRA LOOP_115
00000B5A                          2056mm EXIT_115
00000B5A                          2057mm     ENDM
00000B5A                          2058m     ENDM
00000B5A                          2059          
00000B5A  6000 F7E8               2060          BRA MAIN_LOOP
00000B5E                          2061      ENDI
00000B5E                          2062s _0000000B
00000B5E                          2063  
00000B5E                          2064      IF D1 <EQ> #0 THEN
00000B5E  B27C 0000               2065s     CMP.W   #0,D1
00000B62  6600 0006               2066s     BNE _0000000C
00000B66  6000 FA8C               2067        BRA WAIT_FOR_SRECORD
00000B6A                          2068      ENDI
00000B6A                          2069s _0000000C
00000B6A                          2070  DOWNLOAD_DONE
00000B6A                          2071m     PRINT_CRLF D5,A4
00000B6A  49FA 1143               2072m     LEA CRLF(PC),A4
00000B6E                          2073mm     PRINT_STR A4,D5
00000B6E                          2074mm LOOP_118
00000B6E  0C14 0000               2075mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B72  6700 0016               2076mm     BEQ EXIT_118
00000B76                          2077mmm     PRINT_CHAR (A4)+,D5
00000B76                          2078mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B76                 TRUE     2079mmm     IFEQ DEBUG
00000B76  1A39 00C00003           2080mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B7C  0805 0002               2081mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B80  67F4                    2082mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B82  13DC 00C00007           2083mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B88                          2084mmm     ENDC
00000B88                          2085mmm 
00000B88                 FALSE    2086mmm     IFNE DEBUG
00000B88                          2087mmm     ENDC
00000B88                          2088mmm 
00000B88                          2089mmm     ENDM
00000B88  60E4                    2090mm     BRA LOOP_118
00000B8A                          2091mm EXIT_118
00000B8A                          2092mm     ENDM
00000B8A                          2093m     ENDM
00000B8A                          2094m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000B8A  43FA 1129               2095m     LEA OX(PC),A1
00000B8E                          2096mm     PRINT_STR A1,D5
00000B8E                          2097mm LOOP_121
00000B8E  0C11 0000               2098mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B92  6700 0016               2099mm     BEQ EXIT_121
00000B96                          2100mmm     PRINT_CHAR (A1)+,D5
00000B96                          2101mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B96                 TRUE     2102mmm     IFEQ DEBUG
00000B96  1A39 00C00003           2103mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B9C  0805 0002               2104mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BA0  67F4                    2105mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000BA2  13D9 00C00007           2106mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BA8                          2107mmm     ENDC
00000BA8                          2108mmm 
00000BA8                 FALSE    2109mmm     IFNE DEBUG
00000BA8                          2110mmm     ENDC
00000BA8                          2111mmm 
00000BA8                          2112mmm     ENDM
00000BA8  60E4                    2113mm     BRA LOOP_121
00000BAA                          2114mm EXIT_121
00000BAA                          2115mm     ENDM
00000BAA  7407                    2116m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BAC                          2117m LOOP_120
00000BAC                          2118mm     BIN2HEX D0,D6,A1
00000BAC  43FA 10C6               2119mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BB0  E998                    2120mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BB2  1C00                    2121mm     MOVE.B D0,D6
00000BB4  0286 0000000F           2122mm     ANDI.L #$F,D6
00000BBA  1C31 6000               2123mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000BBE                          2124mm     ENDM
00000BBE                          2125mm     PRINT_CHAR D6,D5
00000BBE                          2126mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BBE                 TRUE     2127mm     IFEQ DEBUG
00000BBE  1A39 00C00003           2128mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BC4  0805 0002               2129mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BC8  67F4                    2130mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BCA  13C6 00C00007           2131mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BD0                          2132mm     ENDC
00000BD0                          2133mm 
00000BD0                 FALSE    2134mm     IFNE DEBUG
00000BD0                          2135mm     ENDC
00000BD0                          2136mm 
00000BD0                          2137mm     ENDM
00000BD0  57CA FFDA               2138m     DBEQ D2,LOOP_120
00000BD4                          2139m     ENDM
00000BD4  43FA 1043               2140      LEA READ(PC),A1
00000BD8                          2141m     PRINT_STR A1,D5
00000BD8                          2142m LOOP_125
00000BD8  0C11 0000               2143m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BDC  6700 0016               2144m     BEQ EXIT_125
00000BE0                          2145mm     PRINT_CHAR (A1)+,D5
00000BE0                          2146mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BE0                 TRUE     2147mm     IFEQ DEBUG
00000BE0  1A39 00C00003           2148mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BE6  0805 0002               2149mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BEA  67F4                    2150mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000BEC  13D9 00C00007           2151mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BF2                          2152mm     ENDC
00000BF2                          2153mm 
00000BF2                 FALSE    2154mm     IFNE DEBUG
00000BF2                          2155mm     ENDC
00000BF2                          2156mm 
00000BF2                          2157mm     ENDM
00000BF2  60E4                    2158m     BRA LOOP_125
00000BF4                          2159m EXIT_125
00000BF4                          2160m     ENDM
00000BF4  2E08                    2161      MOVE.L A0,D7                                    ; set address accumulator to start address
00000BF6                          2162m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000BF6  43FA 10BD               2163m     LEA OX(PC),A1
00000BFA                          2164mm     PRINT_STR A1,D5
00000BFA                          2165mm LOOP_128
00000BFA  0C11 0000               2166mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BFE  6700 0016               2167mm     BEQ EXIT_128
00000C02                          2168mmm     PRINT_CHAR (A1)+,D5
00000C02                          2169mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C02                 TRUE     2170mmm     IFEQ DEBUG
00000C02  1A39 00C00003           2171mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C08  0805 0002               2172mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C0C  67F4                    2173mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000C0E  13D9 00C00007           2174mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C14                          2175mmm     ENDC
00000C14                          2176mmm 
00000C14                 FALSE    2177mmm     IFNE DEBUG
00000C14                          2178mmm     ENDC
00000C14                          2179mmm 
00000C14                          2180mmm     ENDM
00000C14  60E4                    2181mm     BRA LOOP_128
00000C16                          2182mm EXIT_128
00000C16                          2183mm     ENDM
00000C16  7407                    2184m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C18                          2185m LOOP_127
00000C18                          2186mm     BIN2HEX D7,D6,A1
00000C18  43FA 105A               2187mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C1C  E99F                    2188mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C1E  1C07                    2189mm     MOVE.B D7,D6
00000C20  0286 0000000F           2190mm     ANDI.L #$F,D6
00000C26  1C31 6000               2191mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C2A                          2192mm     ENDM
00000C2A                          2193mm     PRINT_CHAR D6,D5
00000C2A                          2194mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C2A                 TRUE     2195mm     IFEQ DEBUG
00000C2A  1A39 00C00003           2196mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C30  0805 0002               2197mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C34  67F4                    2198mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000C36  13C6 00C00007           2199mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C3C                          2200mm     ENDC
00000C3C                          2201mm 
00000C3C                 FALSE    2202mm     IFNE DEBUG
00000C3C                          2203mm     ENDC
00000C3C                          2204mm 
00000C3C                          2205mm     ENDM
00000C3C  57CA FFDA               2206m     DBEQ D2,LOOP_127
00000C40                          2207m     ENDM
00000C40                          2208m     PRINT_CRLF D5,A4
00000C40  49FA 106D               2209m     LEA CRLF(PC),A4
00000C44                          2210mm     PRINT_STR A4,D5
00000C44                          2211mm LOOP_133
00000C44  0C14 0000               2212mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C48  6700 0016               2213mm     BEQ EXIT_133
00000C4C                          2214mmm     PRINT_CHAR (A4)+,D5
00000C4C                          2215mmm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C4C                 TRUE     2216mmm     IFEQ DEBUG
00000C4C  1A39 00C00003           2217mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C52  0805 0002               2218mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C56  67F4                    2219mmm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C58  13DC 00C00007           2220mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C5E                          2221mmm     ENDC
00000C5E                          2222mmm 
00000C5E                 FALSE    2223mmm     IFNE DEBUG
00000C5E                          2224mmm     ENDC
00000C5E                          2225mmm 
00000C5E                          2226mmm     ENDM
00000C5E  60E4                    2227mm     BRA LOOP_133
00000C60                          2228mm EXIT_133
00000C60                          2229mm     ENDM
00000C60                          2230m     ENDM
00000C60                          2231  
00000C60  6000 F6E2               2232      BRA MAIN_LOOP
00000C64                          2233  
00000C64                          2234  G
00000C64  2047                    2235      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000C66  7E00                    2236      MOVE.L #0,D7
00000C68                          2237  
00000C68  4ED0                    2238      JMP (A0)
00000C6A                          2239          
00000C6A                          2240  Z
00000C6A  207C 00200000           2241      MOVE.L #RAM,A0                                  ; address of RAM
00000C70  D1FC 00100000           2242      ADD.L #$100000,A0
00000C76                          2243  
00000C76                          2244      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000C76  7000                    2245s     MOVE.L  #0,D0
00000C78  6000 0012               2246s     BRA _20000007
00000C7C                          2247s _20000006
00000C7C  2200                    2248          MOVE.L D0,D1                                ; progress update
00000C7E  E089                    2249          LSR.L #8,D1 
00000C80  E089                    2250          LSR.L #8,D1
00000C82  13C1 00E00001           2251          MOVE.B D1,DISPLAY
00000C88                          2252          
00000C88  2108                    2253          MOVE.L A0,-(A0)
00000C8A                          2254      ENDF
00000C8A  5880                    2255s     ADD.L   #4,D0
00000C8C                          2256s _20000007
00000C8C  B0BC 000FFFFC           2257s     CMP.L   #$FFFFC,D0
00000C92  6FE8                    2258s     BLE _20000006
00000C94                          2259  
00000C94  207C 00200000           2260      MOVE.L #RAM,A0                                  ; address of RAM
00000C9A  D1FC 00100000           2261      ADD.L #$100000,A0
00000CA0                          2262  
00000CA0                          2263      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000CA0  7000                    2264s     MOVE.L  #0,D0
00000CA2  6000 00A8               2265s     BRA _20000009
00000CA6                          2266s _20000008
00000CA6  2200                    2267          MOVE.L D0,D1                                ; progress update
00000CA8  E089                    2268          LSR.L #8,D1
00000CAA  E089                    2269          LSR.L #8,D1
00000CAC  13C1 00E00001           2270          MOVE.B D1,DISPLAY
00000CB2                          2271  
00000CB2  2408                    2272          MOVE.L A0,D2
00000CB4  2220                    2273          MOVE.L -(A0),D1
00000CB6                          2274  
00000CB6                          2275          IF.L D2 <NE> D1 THEN
00000CB6  B481                    2276s     CMP.L   D1,D2
00000CB8  6700 0090               2277s     BEQ _0000000D
00000CBC  43FA 0FA5               2278              LEA RAM_ERROR(PC),A1
00000CC0                          2279m             PRINT_STR A1,D1
00000CC0                          2280m LOOP_135
00000CC0  0C11 0000               2281m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CC4  6700 0016               2282m     BEQ EXIT_135
00000CC8                          2283mm     PRINT_CHAR (A1)+,D1
00000CC8                          2284mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CC8                 TRUE     2285mm     IFEQ DEBUG
00000CC8  1239 00C00003           2286mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000CCE  0801 0002               2287mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000CD2  67F4                    2288mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CD4  13D9 00C00007           2289mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CDA                          2290mm     ENDC
00000CDA                          2291mm 
00000CDA                 FALSE    2292mm     IFNE DEBUG
00000CDA                          2293mm     ENDC
00000CDA                          2294mm 
00000CDA                          2295mm     ENDM
00000CDA  60E4                    2296m     BRA LOOP_135
00000CDC                          2297m EXIT_135
00000CDC                          2298m     ENDM
00000CDC  2208                    2299              MOVE.L A0,D1
00000CDE  5981                    2300              SUB.L #4,D1
00000CE0                          2301m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000CE0  43FA 0FD3               2302m     LEA OX(PC),A1
00000CE4                          2303mm     PRINT_STR A1,D3
00000CE4                          2304mm LOOP_138
00000CE4  0C11 0000               2305mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CE8  6700 0016               2306mm     BEQ EXIT_138
00000CEC                          2307mmm     PRINT_CHAR (A1)+,D3
00000CEC                          2308mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CEC                 TRUE     2309mmm     IFEQ DEBUG
00000CEC  1639 00C00003           2310mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000CF2  0803 0002               2311mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000CF6  67F4                    2312mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000CF8  13D9 00C00007           2313mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CFE                          2314mmm     ENDC
00000CFE                          2315mmm 
00000CFE                 FALSE    2316mmm     IFNE DEBUG
00000CFE                          2317mmm     ENDC
00000CFE                          2318mmm 
00000CFE                          2319mmm     ENDM
00000CFE  60E4                    2320mm     BRA LOOP_138
00000D00                          2321mm EXIT_138
00000D00                          2322mm     ENDM
00000D00  7C07                    2323m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D02                          2324m LOOP_137
00000D02                          2325mm     BIN2HEX D1,D2,A1
00000D02  43FA 0F70               2326mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000D06  E999                    2327mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D08  1401                    2328mm     MOVE.B D1,D2
00000D0A  0282 0000000F           2329mm     ANDI.L #$F,D2
00000D10  1431 2000               2330mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000D14                          2331mm     ENDM
00000D14                          2332mm     PRINT_CHAR D2,D3
00000D14                          2333mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D14                 TRUE     2334mm     IFEQ DEBUG
00000D14  1639 00C00003           2335mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D1A  0803 0002               2336mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D1E  67F4                    2337mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000D20  13C2 00C00007           2338mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D26                          2339mm     ENDC
00000D26                          2340mm 
00000D26                 FALSE    2341mm     IFNE DEBUG
00000D26                          2342mm     ENDC
00000D26                          2343mm 
00000D26                          2344mm     ENDM
00000D26  57CE FFDA               2345m     DBEQ D6,LOOP_137
00000D2A                          2346m     ENDM
00000D2A                          2347m             PRINT_CRLF D3,A1
00000D2A  43FA 0F83               2348m     LEA CRLF(PC),A1
00000D2E                          2349mm     PRINT_STR A1,D3
00000D2E                          2350mm LOOP_143
00000D2E  0C11 0000               2351mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D32  6700 0016               2352mm     BEQ EXIT_143
00000D36                          2353mmm     PRINT_CHAR (A1)+,D3
00000D36                          2354mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D36                 TRUE     2355mmm     IFEQ DEBUG
00000D36  1639 00C00003           2356mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D3C  0803 0002               2357mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D40  67F4                    2358mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D42  13D9 00C00007           2359mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D48                          2360mmm     ENDC
00000D48                          2361mmm 
00000D48                 FALSE    2362mmm     IFNE DEBUG
00000D48                          2363mmm     ENDC
00000D48                          2364mmm 
00000D48                          2365mmm     ENDM
00000D48  60E4                    2366mm     BRA LOOP_143
00000D4A                          2367mm EXIT_143
00000D4A                          2368mm     ENDM
00000D4A                          2369m     ENDM
00000D4A                          2370          ENDI 
00000D4A                          2371s _0000000D
00000D4A                          2372      ENDF
00000D4A  5880                    2373s     ADD.L   #4,D0
00000D4C                          2374s _20000009
00000D4C  B0BC 000FFFFC           2375s     CMP.L   #$FFFFC,D0
00000D52  6F00 FF52               2376s     BLE _20000008
00000D56                          2377  
00000D56  6000 F5EC               2378      BRA MAIN_LOOP
00000D5A                          2379  
00000D5A                          2380  L
00000D5A  7000                    2381      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000D5C  7200                    2382      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000D5E                          2383  
00000D5E                          2384      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000D5E  343C 0000               2385s     MOVE.W  #0,D2
00000D62  6000 0046               2386s     BRA _2000000B
00000D66                          2387s _2000000A
00000D66  E989                    2388          LSL.L #4,D1                                 ; make what we have so far more significant
00000D68                          2389m         WAIT_CHAR D3,D4                             ; next character -> D2
00000D68                          2390m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D68                 TRUE     2391m     IFEQ DEBUG
00000D68  1839 00C00003           2392m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000D6E  0804 0000               2393m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000D72  67F4                    2394m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D74                          2395m     ENDC
00000D74                          2396m 
00000D74                          2397mm     READ_CHAR D3
00000D74                 TRUE     2398mm     IFEQ DEBUG
00000D74  1639 00C00007           2399mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000D7A                          2400mm     ENDC
00000D7A                 FALSE    2401mm     IFNE DEBUG
00000D7A                          2402mm     ENDC
00000D7A                          2403mm 
00000D7A  B63C 001B               2404mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000D7E  6700 F384               2405mm     BEQ START
00000D82                          2406mm     ENDM
00000D82                          2407m 
00000D82                 TRUE     2408m     IFEQ DEBUG
00000D82                          2409mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000D82                          2410mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D82                 TRUE     2411mm     IFEQ DEBUG
00000D82  1839 00C00003           2412mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000D88  0804 0002               2413mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000D8C  67F4                    2414mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D8E  13C3 00C00007           2415mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D94                          2416mm     ENDC
00000D94                          2417mm 
00000D94                 FALSE    2418mm     IFNE DEBUG
00000D94                          2419mm     ENDC
00000D94                          2420mm 
00000D94                          2421mm     ENDM
00000D94                          2422m     ENDC
00000D94                          2423m     ENDM
00000D94                          2424m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000D94  41FA 0EEE               2425m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000D98  0403 0030               2426m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D9C  C6BC 000000FF           2427m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000DA2  1630 3000               2428m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000DA6                          2429m     ENDM
00000DA6  8203                    2430          OR.B D3,D1
00000DA8                          2431      ENDF
00000DA8  5242                    2432s     ADD.W   #1,D2
00000DAA                          2433s _2000000B
00000DAA  B47C 0007               2434s     CMP.W   #7,D2
00000DAE  6FB6                    2435s     BLE _2000000A
00000DB0                          2436  
00000DB0  3001                    2437      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000DB2  0480 00000104           2438      SUB.L #START,D0                                 ; remove the vector table from the length
00000DB8  E089                    2439      LSR.L #8,D1                                     ; extract the MSword for the address
00000DBA  E089                    2440      LSR.L #8,D1
00000DBC                          2441  
00000DBC                          2442m     PRINT_CRLF D2,A1
00000DBC  43FA 0EF1               2443m     LEA CRLF(PC),A1
00000DC0                          2444mm     PRINT_STR A1,D2
00000DC0                          2445mm LOOP_150
00000DC0  0C11 0000               2446mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DC4  6700 0016               2447mm     BEQ EXIT_150
00000DC8                          2448mmm     PRINT_CHAR (A1)+,D2
00000DC8                          2449mmm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DC8                 TRUE     2450mmm     IFEQ DEBUG
00000DC8  1439 00C00003           2451mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DCE  0802 0002               2452mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DD2  67F4                    2453mmm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DD4  13D9 00C00007           2454mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DDA                          2455mmm     ENDC
00000DDA                          2456mmm 
00000DDA                 FALSE    2457mmm     IFNE DEBUG
00000DDA                          2458mmm     ENDC
00000DDA                          2459mmm 
00000DDA                          2460mmm     ENDM
00000DDA  60E4                    2461mm     BRA LOOP_150
00000DDC                          2462mm EXIT_150
00000DDC                          2463mm     ENDM
00000DDC                          2464m     ENDM
00000DDC                          2465  
00000DDC  2041                    2466      MOVE.L D1,A0                                    ; target address
00000DDE  2641                    2467      MOVE.L D1,A3                                    ; keep a copy for later
00000DE0                          2468  
00000DE0  2247                    2469      MOVE.L D7,A1                                    ; address accumulator -> address register
00000DE2  D3FC 00000104           2470      ADD.L #START,A1                                 ; skip the vectors
00000DE8  2847                    2471      MOVE.L D7,A4                                    ; keep a clean copy for later
00000DEA  7E00                    2472      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000DEC                          2473  
00000DEC                          2474m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000DEC  31FC AAAA 2AAA          2475m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000DF2  4E71                    2476m     NOP
00000DF4  31FC 5555 1554          2477m     MOVE.W #$5555,$1554
00000DFA  4E71                    2478m     NOP
00000DFC  31FC 8080 2AAA          2479m     MOVE.W #$8080,$2AAA
00000E02  4E71                    2480m     NOP
00000E04  31FC AAAA 2AAA          2481m     MOVE.W #$AAAA,$2AAA
00000E0A  4E71                    2482m     NOP
00000E0C  31FC 5555 1554          2483m     MOVE.W #$5555,$1554
00000E12  4E71                    2484m     NOP
00000E14  31FC 2020 2AAA          2485m     MOVE.W #$2020,$2AAA
00000E1A                          2486m     ENDM
00000E1A                          2487                      
00000E1A                          2488      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000E1A  3E3C 0000               2489s     MOVE.W  #$0,D7
00000E1E  6000 0006               2490s     BRA _2000000D
00000E22                          2491s _2000000C
00000E22  4E71                    2492          NOP
00000E24                          2493      ENDF
00000E24  5247                    2494s     ADD.W   #1,D7
00000E26                          2495s _2000000D
00000E26  BE7C FFFF               2496s     CMP.W   #$FFFFFFFF,D7
00000E2A  6FF6                    2497s     BLE _2000000C
00000E2C                          2498                  
00000E2C  45FA 0E6D               2499      LEA LOADING(PC),A2
00000E30                          2500m     PRINT_STR A2,D2
00000E30                          2501m LOOP_153
00000E30  0C12 0000               2502m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E34  6700 0016               2503m     BEQ EXIT_153
00000E38                          2504mm     PRINT_CHAR (A2)+,D2
00000E38                          2505mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E38                 TRUE     2506mm     IFEQ DEBUG
00000E38  1439 00C00003           2507mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E3E  0802 0002               2508mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E42  67F4                    2509mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000E44  13DA 00C00007           2510mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E4A                          2511mm     ENDC
00000E4A                          2512mm 
00000E4A                 FALSE    2513mm     IFNE DEBUG
00000E4A                          2514mm     ENDC
00000E4A                          2515mm 
00000E4A                          2516mm     ENDM
00000E4A  60E4                    2517m     BRA LOOP_153
00000E4C                          2518m EXIT_153
00000E4C                          2519m     ENDM
00000E4C                          2520          
00000E4C  2409                    2521      MOVE.L A1,D2
00000E4E                          2522m     PRINT_REG D2,D3,D4,D5,A2
00000E4E  45FA 0E65               2523m     LEA OX(PC),A2
00000E52                          2524mm     PRINT_STR A2,D3
00000E52                          2525mm LOOP_156
00000E52  0C12 0000               2526mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E56  6700 0016               2527mm     BEQ EXIT_156
00000E5A                          2528mmm     PRINT_CHAR (A2)+,D3
00000E5A                          2529mmm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E5A                 TRUE     2530mmm     IFEQ DEBUG
00000E5A  1639 00C00003           2531mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E60  0803 0002               2532mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E64  67F4                    2533mmm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E66  13DA 00C00007           2534mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E6C                          2535mmm     ENDC
00000E6C                          2536mmm 
00000E6C                 FALSE    2537mmm     IFNE DEBUG
00000E6C                          2538mmm     ENDC
00000E6C                          2539mmm 
00000E6C                          2540mmm     ENDM
00000E6C  60E4                    2541mm     BRA LOOP_156
00000E6E                          2542mm EXIT_156
00000E6E                          2543mm     ENDM
00000E6E  7A07                    2544m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E70                          2545m LOOP_155
00000E70                          2546mm     BIN2HEX D2,D4,A2
00000E70  45FA 0E02               2547mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E74  E99A                    2548mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E76  1802                    2549mm     MOVE.B D2,D4
00000E78  0284 0000000F           2550mm     ANDI.L #$F,D4
00000E7E  1832 4000               2551mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E82                          2552mm     ENDM
00000E82                          2553mm     PRINT_CHAR D4,D3
00000E82                          2554mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E82                 TRUE     2555mm     IFEQ DEBUG
00000E82  1639 00C00003           2556mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E88  0803 0002               2557mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E8C  67F4                    2558mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000E8E  13C4 00C00007           2559mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E94                          2560mm     ENDC
00000E94                          2561mm 
00000E94                 FALSE    2562mm     IFNE DEBUG
00000E94                          2563mm     ENDC
00000E94                          2564mm 
00000E94                          2565mm     ENDM
00000E94  57CD FFDA               2566m     DBEQ D5,LOOP_155
00000E98                          2567m     ENDM
00000E98                          2568  
00000E98  45FA 0E1E               2569      LEA TO(PC),A2
00000E9C                          2570m     PRINT_STR A2,D3
00000E9C                          2571m LOOP_160
00000E9C  0C12 0000               2572m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EA0  6700 0016               2573m     BEQ EXIT_160
00000EA4                          2574mm     PRINT_CHAR (A2)+,D3
00000EA4                          2575mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA4                 TRUE     2576mm     IFEQ DEBUG
00000EA4  1639 00C00003           2577mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EAA  0803 0002               2578mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EAE  67F4                    2579mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000EB0  13DA 00C00007           2580mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB6                          2581mm     ENDC
00000EB6                          2582mm 
00000EB6                 FALSE    2583mm     IFNE DEBUG
00000EB6                          2584mm     ENDC
00000EB6                          2585mm 
00000EB6                          2586mm     ENDM
00000EB6  60E4                    2587m     BRA LOOP_160
00000EB8                          2588m EXIT_160
00000EB8                          2589m     ENDM
00000EB8                          2590  
00000EB8  2408                    2591      MOVE.L A0,D2
00000EBA                          2592m     PRINT_REG D2,D3,D4,D5,A2
00000EBA  45FA 0DF9               2593m     LEA OX(PC),A2
00000EBE                          2594mm     PRINT_STR A2,D3
00000EBE                          2595mm LOOP_163
00000EBE  0C12 0000               2596mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EC2  6700 0016               2597mm     BEQ EXIT_163
00000EC6                          2598mmm     PRINT_CHAR (A2)+,D3
00000EC6                          2599mmm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC6                 TRUE     2600mmm     IFEQ DEBUG
00000EC6  1639 00C00003           2601mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000ECC  0803 0002               2602mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000ED0  67F4                    2603mmm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000ED2  13DA 00C00007           2604mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ED8                          2605mmm     ENDC
00000ED8                          2606mmm 
00000ED8                 FALSE    2607mmm     IFNE DEBUG
00000ED8                          2608mmm     ENDC
00000ED8                          2609mmm 
00000ED8                          2610mmm     ENDM
00000ED8  60E4                    2611mm     BRA LOOP_163
00000EDA                          2612mm EXIT_163
00000EDA                          2613mm     ENDM
00000EDA  7A07                    2614m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EDC                          2615m LOOP_162
00000EDC                          2616mm     BIN2HEX D2,D4,A2
00000EDC  45FA 0D96               2617mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EE0  E99A                    2618mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EE2  1802                    2619mm     MOVE.B D2,D4
00000EE4  0284 0000000F           2620mm     ANDI.L #$F,D4
00000EEA  1832 4000               2621mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000EEE                          2622mm     ENDM
00000EEE                          2623mm     PRINT_CHAR D4,D3
00000EEE                          2624mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EEE                 TRUE     2625mm     IFEQ DEBUG
00000EEE  1639 00C00003           2626mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EF4  0803 0002               2627mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EF8  67F4                    2628mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000EFA  13C4 00C00007           2629mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F00                          2630mm     ENDC
00000F00                          2631mm 
00000F00                 FALSE    2632mm     IFNE DEBUG
00000F00                          2633mm     ENDC
00000F00                          2634mm 
00000F00                          2635mm     ENDM
00000F00  57CD FFDA               2636m     DBEQ D5,LOOP_162
00000F04                          2637m     ENDM
00000F04                          2638  
00000F04  45FA 0DB7               2639      LEA FOR(PC),A2
00000F08                          2640m     PRINT_STR A2,D3
00000F08                          2641m LOOP_167
00000F08  0C12 0000               2642m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F0C  6700 0016               2643m     BEQ EXIT_167
00000F10                          2644mm     PRINT_CHAR (A2)+,D3
00000F10                          2645mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F10                 TRUE     2646mm     IFEQ DEBUG
00000F10  1639 00C00003           2647mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F16  0803 0002               2648mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F1A  67F4                    2649mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000F1C  13DA 00C00007           2650mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F22                          2651mm     ENDC
00000F22                          2652mm 
00000F22                 FALSE    2653mm     IFNE DEBUG
00000F22                          2654mm     ENDC
00000F22                          2655mm 
00000F22                          2656mm     ENDM
00000F22  60E4                    2657m     BRA LOOP_167
00000F24                          2658m EXIT_167
00000F24                          2659m     ENDM
00000F24                          2660m     PRINT_REG D0,D3,D4,D5,A2
00000F24  45FA 0D8F               2661m     LEA OX(PC),A2
00000F28                          2662mm     PRINT_STR A2,D3
00000F28                          2663mm LOOP_170
00000F28  0C12 0000               2664mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F2C  6700 0016               2665mm     BEQ EXIT_170
00000F30                          2666mmm     PRINT_CHAR (A2)+,D3
00000F30                          2667mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F30                 TRUE     2668mmm     IFEQ DEBUG
00000F30  1639 00C00003           2669mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F36  0803 0002               2670mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F3A  67F4                    2671mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F3C  13DA 00C00007           2672mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F42                          2673mmm     ENDC
00000F42                          2674mmm 
00000F42                 FALSE    2675mmm     IFNE DEBUG
00000F42                          2676mmm     ENDC
00000F42                          2677mmm 
00000F42                          2678mmm     ENDM
00000F42  60E4                    2679mm     BRA LOOP_170
00000F44                          2680mm EXIT_170
00000F44                          2681mm     ENDM
00000F44  7A07                    2682m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F46                          2683m LOOP_169
00000F46                          2684mm     BIN2HEX D0,D4,A2
00000F46  45FA 0D2C               2685mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F4A  E998                    2686mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F4C  1800                    2687mm     MOVE.B D0,D4
00000F4E  0284 0000000F           2688mm     ANDI.L #$F,D4
00000F54  1832 4000               2689mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F58                          2690mm     ENDM
00000F58                          2691mm     PRINT_CHAR D4,D3
00000F58                          2692mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F58                 TRUE     2693mm     IFEQ DEBUG
00000F58  1639 00C00003           2694mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F5E  0803 0002               2695mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F62  67F4                    2696mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F64  13C4 00C00007           2697mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F6A                          2698mm     ENDC
00000F6A                          2699mm 
00000F6A                 FALSE    2700mm     IFNE DEBUG
00000F6A                          2701mm     ENDC
00000F6A                          2702mm 
00000F6A                          2703mm     ENDM
00000F6A  57CD FFDA               2704m     DBEQ D5,LOOP_169
00000F6E                          2705m     ENDM
00000F6E                          2706  
00000F6E                          2707m     PRINT_CRLF D3,A2
00000F6E  45FA 0D3F               2708m     LEA CRLF(PC),A2
00000F72                          2709mm     PRINT_STR A2,D3
00000F72                          2710mm LOOP_175
00000F72  0C12 0000               2711mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F76  6700 0016               2712mm     BEQ EXIT_175
00000F7A                          2713mmm     PRINT_CHAR (A2)+,D3
00000F7A                          2714mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F7A                 TRUE     2715mmm     IFEQ DEBUG
00000F7A  1639 00C00003           2716mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F80  0803 0002               2717mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F84  67F4                    2718mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000F86  13DA 00C00007           2719mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F8C                          2720mmm     ENDC
00000F8C                          2721mmm 
00000F8C                 FALSE    2722mmm     IFNE DEBUG
00000F8C                          2723mmm     ENDC
00000F8C                          2724mmm 
00000F8C                          2725mmm     ENDM
00000F8C  60E4                    2726mm     BRA LOOP_175
00000F8E                          2727mm EXIT_175
00000F8E                          2728mm     ENDM
00000F8E                          2729m     ENDM
00000F8E                          2730  
00000F8E                          2731      WHILE D0 <GT> #0 DO
00000F8E                          2732s _10000014
00000F8E  B07C 0000               2733s     CMP.W   #0,D0
00000F92  6F00 001C               2734s     BLE _10000015
00000F96  5580                    2735          SUB.L #2,D0
00000F98                          2736  
00000F98  13D1 00E00001           2737          MOVE.B (A1),DISPLAY
00000F9E                          2738m         PROGRAM (A1),(A0),D2
00000F9E  3091                    2739m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000FA0                          2740m 
00000FA0                          2741m WAIT_FOR_COMPLETE_177
00000FA0  3410                    2742m         MOVE.W (A0),D2
00000FA2                          2743m 
00000FA2                          2744m         IF.W D2 <NE> (A1) THEN
00000FA2  B451                    2745ms     CMP.W   (A1),D2
00000FA4  6700 0004               2746ms     BEQ _0000000E
00000FA8  60F6                    2747m             BRA WAIT_FOR_COMPLETE_177
00000FAA                          2748m         ENDI
00000FAA                          2749ms _0000000E
00000FAA                          2750m         ENDM
00000FAA                          2751                  
00000FAA  5488                    2752          ADD.L #2,A0
00000FAC  5489                    2753          ADD.L #2,A1
00000FAE                          2754      ENDW
00000FAE  60DE                    2755s     BRA _10000014
00000FB0                          2756s _10000015
00000FB0                          2757      
00000FB0  41F8 0000               2758      LEA STACK,A0
00000FB4  D1CC                    2759      ADD.L A4,A0
00000FB6  2010                    2760      MOVE.L (A0),D0
00000FB8                          2761      
00000FB8  207C 00000000           2762      MOVE.L #0,A0
00000FBE                          2763m     PROGRAM_VECTOR D0,A0,D2
00000FBE  5488                    2764m     ADD.L #2,A0
00000FC0                          2765mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000FC0  3080                    2766mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FC2                          2767mm 
00000FC2                          2768mm WAIT_FOR_COMPLETE_179
00000FC2  3410                    2769mm         MOVE.W (A0),D2
00000FC4                          2770mm 
00000FC4                          2771mm         IF.W D2 <NE> D0 THEN
00000FC4  B440                    2772mms     CMP.W   D0,D2
00000FC6  6700 0004               2773mms     BEQ _0000000F
00000FCA  60F6                    2774mm             BRA WAIT_FOR_COMPLETE_179
00000FCC                          2775mm         ENDI
00000FCC                          2776mms _0000000F
00000FCC                          2777mm         ENDM
00000FCC  E088                    2778m     LSR.L #8,D0
00000FCE  E088                    2779m     LSR.L #8,D0
00000FD0  5588                    2780m     SUB.L #2,A0
00000FD2                          2781mm     PROGRAM D0, (A0), D2
00000FD2  3080                    2782mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FD4                          2783mm 
00000FD4                          2784mm WAIT_FOR_COMPLETE_180
00000FD4  3410                    2785mm         MOVE.W (A0),D2
00000FD6                          2786mm 
00000FD6                          2787mm         IF.W D2 <NE> D0 THEN
00000FD6  B440                    2788mms     CMP.W   D0,D2
00000FD8  6700 0004               2789mms     BEQ _00000010
00000FDC  60F6                    2790mm             BRA WAIT_FOR_COMPLETE_180
00000FDE                          2791mm         ENDI
00000FDE                          2792mms _00000010
00000FDE                          2793mm         ENDM
00000FDE                          2794m     ENDM
00000FDE                          2795      
00000FDE                          2796      FOR A0 = #RESET TO #START-4 BY #4 DO
00000FDE  307C 0004               2797s     MOVE.W  #RESET,A0
00000FE2  6000 003C               2798s     BRA _2000000F
00000FE6                          2799s _2000000E
00000FE6                          2800  
00000FE6  2248                    2801          MOVE.L A0,A1
00000FE8  D3CC                    2802          ADD.L A4,A1
00000FEA                          2803              
00000FEA  2011                    2804          MOVE.L (A1),D0  
00000FEC  D081                    2805          ADD.L D1,D0
00000FEE  0480 00000104           2806          SUB.L #START,D0
00000FF4                          2807  
00000FF4  2408                    2808          MOVE.L A0,D2
00000FF6                          2809          
00000FF6  2408                    2810          MOVE.L A0,D2
00000FF8  13C2 00E00001           2811          MOVE.B D2,DISPLAY
00000FFE                          2812m         PROGRAM_VECTOR D0,A0,D2
00000FFE  5488                    2813m     ADD.L #2,A0
00001000                          2814mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00001000  3080                    2815mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001002                          2816mm 
00001002                          2817mm WAIT_FOR_COMPLETE_182
00001002  3410                    2818mm         MOVE.W (A0),D2
00001004                          2819mm 
00001004                          2820mm         IF.W D2 <NE> D0 THEN
00001004  B440                    2821mms     CMP.W   D0,D2
00001006  6700 0004               2822mms     BEQ _00000011
0000100A  60F6                    2823mm             BRA WAIT_FOR_COMPLETE_182
0000100C                          2824mm         ENDI
0000100C                          2825mms _00000011
0000100C                          2826mm         ENDM
0000100C  E088                    2827m     LSR.L #8,D0
0000100E  E088                    2828m     LSR.L #8,D0
00001010  5588                    2829m     SUB.L #2,A0
00001012                          2830mm     PROGRAM D0, (A0), D2
00001012  3080                    2831mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001014                          2832mm 
00001014                          2833mm WAIT_FOR_COMPLETE_183
00001014  3410                    2834mm         MOVE.W (A0),D2
00001016                          2835mm 
00001016                          2836mm         IF.W D2 <NE> D0 THEN
00001016  B440                    2837mms     CMP.W   D0,D2
00001018  6700 0004               2838mms     BEQ _00000012
0000101C  60F6                    2839mm             BRA WAIT_FOR_COMPLETE_183
0000101E                          2840mm         ENDI
0000101E                          2841mms _00000012
0000101E                          2842mm         ENDM
0000101E                          2843m     ENDM
0000101E                          2844      ENDF
0000101E  5848                    2845s     ADD.W   #4,A0
00001020                          2846s _2000000F
00001020  B0FC 0100               2847s     CMP.W   #START-4,A0
00001024  6FC0                    2848s     BLE _2000000E
00001026                          2849                                          
00001026                          2850m     PROTECT
00001026  31FC AAAA 2AAA          2851m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000102C  31FC 5555 1554          2852m     MOVE.W #$5555,$1554
00001032  31FC A0A0 2AAA          2853m     MOVE.W #$A0A0,$2AAA
00001038                          2854m     ENDM
00001038                          2855  
00001038  6000 F30A               2856      BRA MAIN_LOOP
0000103C                          2857      
0000103C                          2858  P
0000103C  7000                    2859      MOVE.L #0,D0                                    ; D0 will be the data to write
0000103E                          2860  
0000103E                          2861      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
0000103E  323C 0000               2862s     MOVE.W  #0,D1
00001042  6000 0046               2863s     BRA _20000011
00001046                          2864s _20000010
00001046  E988                    2865          LSL.L #4,D0                                 ; make what we have so far more significant
00001048                          2866m         WAIT_CHAR D2,D3                             ; next character -> D2
00001048                          2867m WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001048                 TRUE     2868m     IFEQ DEBUG
00001048  1639 00C00003           2869m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000104E  0803 0000               2870m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001052  67F4                    2871m         BEQ WAIT_FOR_READY_185                      ; NOTHING, CHECK AGAIN
00001054                          2872m     ENDC
00001054                          2873m 
00001054                          2874mm     READ_CHAR D2
00001054                 TRUE     2875mm     IFEQ DEBUG
00001054  1439 00C00007           2876mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000105A                          2877mm     ENDC
0000105A                 FALSE    2878mm     IFNE DEBUG
0000105A                          2879mm     ENDC
0000105A                          2880mm 
0000105A  B43C 001B               2881mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000105E  6700 F0A4               2882mm     BEQ START
00001062                          2883mm     ENDM
00001062                          2884m 
00001062                 TRUE     2885m     IFEQ DEBUG
00001062                          2886mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001062                          2887mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001062                 TRUE     2888mm     IFEQ DEBUG
00001062  1639 00C00003           2889mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001068  0803 0002               2890mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000106C  67F4                    2891mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
0000106E  13C2 00C00007           2892mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001074                          2893mm     ENDC
00001074                          2894mm 
00001074                 FALSE    2895mm     IFNE DEBUG
00001074                          2896mm     ENDC
00001074                          2897mm 
00001074                          2898mm     ENDM
00001074                          2899m     ENDC
00001074                          2900m     ENDM
00001074                          2901m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001074  41FA 0C0E               2902m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001078  0402 0030               2903m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000107C  C4BC 000000FF           2904m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001082  1430 2000               2905m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001086                          2906m     ENDM
00001086  8002                    2907          OR.B D2,D0
00001088                          2908      ENDF
00001088  5241                    2909s     ADD.W   #1,D1
0000108A                          2910s _20000011
0000108A  B27C 0003               2911s     CMP.W   #3,D1
0000108E  6FB6                    2912s     BLE _20000010
00001090                          2913  
00001090                          2914m     PRINT_CRLF D2,A1
00001090  43FA 0C1D               2915m     LEA CRLF(PC),A1
00001094                          2916mm     PRINT_STR A1,D2
00001094                          2917mm LOOP_190
00001094  0C11 0000               2918mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001098  6700 0016               2919mm     BEQ EXIT_190
0000109C                          2920mmm     PRINT_CHAR (A1)+,D2
0000109C                          2921mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000109C                 TRUE     2922mmm     IFEQ DEBUG
0000109C  1439 00C00003           2923mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010A2  0802 0002               2924mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010A6  67F4                    2925mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
000010A8  13D9 00C00007           2926mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010AE                          2927mmm     ENDC
000010AE                          2928mmm 
000010AE                 FALSE    2929mmm     IFNE DEBUG
000010AE                          2930mmm     ENDC
000010AE                          2931mmm 
000010AE                          2932mmm     ENDM
000010AE  60E4                    2933mm     BRA LOOP_190
000010B0                          2934mm EXIT_190
000010B0                          2935mm     ENDM
000010B0                          2936m     ENDM
000010B0                          2937  
000010B0  2047                    2938      MOVE.L D7,A0                                    ; address accumulator -> target address register
000010B2  7E00                    2939      MOVE.L #0,D7                                    ; clear the now used address accumulator
000010B4                          2940  
000010B4                          2941m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000010B4  31FC AAAA 2AAA          2942m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000010BA  4E71                    2943m     NOP
000010BC  31FC 5555 1554          2944m     MOVE.W #$5555,$1554
000010C2  4E71                    2945m     NOP
000010C4  31FC 8080 2AAA          2946m     MOVE.W #$8080,$2AAA
000010CA  4E71                    2947m     NOP
000010CC  31FC AAAA 2AAA          2948m     MOVE.W #$AAAA,$2AAA
000010D2  4E71                    2949m     NOP
000010D4  31FC 5555 1554          2950m     MOVE.W #$5555,$1554
000010DA  4E71                    2951m     NOP
000010DC  31FC 2020 2AAA          2952m     MOVE.W #$2020,$2AAA
000010E2                          2953m     ENDM
000010E2                          2954                              
000010E2                          2955      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000010E2  3E3C 0000               2956s     MOVE.W  #$0,D7
000010E6  6000 0006               2957s     BRA _20000013
000010EA                          2958s _20000012
000010EA  4E71                    2959          NOP
000010EC                          2960      ENDF
000010EC  5247                    2961s     ADD.W   #1,D7
000010EE                          2962s _20000013
000010EE  BE7C FFFF               2963s     CMP.W   #$FFFFFFFF,D7
000010F2  6FF6                    2964s     BLE _20000012
000010F4                          2965               
000010F4  45FA 0BA5               2966      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
000010F8                          2967m     PRINT_STR A2,D2
000010F8                          2968m LOOP_193
000010F8  0C12 0000               2969m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010FC  6700 0016               2970m     BEQ EXIT_193
00001100                          2971mm     PRINT_CHAR (A2)+,D2
00001100                          2972mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001100                 TRUE     2973mm     IFEQ DEBUG
00001100  1439 00C00003           2974mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001106  0802 0002               2975mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000110A  67F4                    2976mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
0000110C  13DA 00C00007           2977mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001112                          2978mm     ENDC
00001112                          2979mm 
00001112                 FALSE    2980mm     IFNE DEBUG
00001112                          2981mm     ENDC
00001112                          2982mm 
00001112                          2983mm     ENDM
00001112  60E4                    2984m     BRA LOOP_193
00001114                          2985m EXIT_193
00001114                          2986m     ENDM
00001114                          2987  
00001114                          2988m     PRINT_REG D0,D3,D4,D5,A2
00001114  45FA 0B9F               2989m     LEA OX(PC),A2
00001118                          2990mm     PRINT_STR A2,D3
00001118                          2991mm LOOP_196
00001118  0C12 0000               2992mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000111C  6700 0016               2993mm     BEQ EXIT_196
00001120                          2994mmm     PRINT_CHAR (A2)+,D3
00001120                          2995mmm WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001120                 TRUE     2996mmm     IFEQ DEBUG
00001120  1639 00C00003           2997mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001126  0803 0002               2998mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000112A  67F4                    2999mmm         BEQ WAIT_FOR_READY_197                      ; NO SPACE, CHECK AGAIN
0000112C  13DA 00C00007           3000mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001132                          3001mmm     ENDC
00001132                          3002mmm 
00001132                 FALSE    3003mmm     IFNE DEBUG
00001132                          3004mmm     ENDC
00001132                          3005mmm 
00001132                          3006mmm     ENDM
00001132  60E4                    3007mm     BRA LOOP_196
00001134                          3008mm EXIT_196
00001134                          3009mm     ENDM
00001134  7A07                    3010m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001136                          3011m LOOP_195
00001136                          3012mm     BIN2HEX D0,D4,A2
00001136  45FA 0B3C               3013mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000113A  E998                    3014mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000113C  1800                    3015mm     MOVE.B D0,D4
0000113E  0284 0000000F           3016mm     ANDI.L #$F,D4
00001144  1832 4000               3017mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001148                          3018mm     ENDM
00001148                          3019mm     PRINT_CHAR D4,D3
00001148                          3020mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001148                 TRUE     3021mm     IFEQ DEBUG
00001148  1639 00C00003           3022mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000114E  0803 0002               3023mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001152  67F4                    3024mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001154  13C4 00C00007           3025mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000115A                          3026mm     ENDC
0000115A                          3027mm 
0000115A                 FALSE    3028mm     IFNE DEBUG
0000115A                          3029mm     ENDC
0000115A                          3030mm 
0000115A                          3031mm     ENDM
0000115A  57CD FFDA               3032m     DBEQ D5,LOOP_195
0000115E                          3033m     ENDM
0000115E                          3034  
0000115E  45FA 0B58               3035      LEA TO(PC),A2
00001162                          3036m     PRINT_STR A2,D3
00001162                          3037m LOOP_200
00001162  0C12 0000               3038m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001166  6700 0016               3039m     BEQ EXIT_200
0000116A                          3040mm     PRINT_CHAR (A2)+,D3
0000116A                          3041mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000116A                 TRUE     3042mm     IFEQ DEBUG
0000116A  1639 00C00003           3043mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001170  0803 0002               3044mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001174  67F4                    3045mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
00001176  13DA 00C00007           3046mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000117C                          3047mm     ENDC
0000117C                          3048mm 
0000117C                 FALSE    3049mm     IFNE DEBUG
0000117C                          3050mm     ENDC
0000117C                          3051mm 
0000117C                          3052mm     ENDM
0000117C  60E4                    3053m     BRA LOOP_200
0000117E                          3054m EXIT_200
0000117E                          3055m     ENDM
0000117E                          3056  
0000117E  2408                    3057      MOVE.L A0,D2
00001180                          3058m     PRINT_REG D2,D3,D4,D5,A2
00001180  45FA 0B33               3059m     LEA OX(PC),A2
00001184                          3060mm     PRINT_STR A2,D3
00001184                          3061mm LOOP_203
00001184  0C12 0000               3062mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001188  6700 0016               3063mm     BEQ EXIT_203
0000118C                          3064mmm     PRINT_CHAR (A2)+,D3
0000118C                          3065mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000118C                 TRUE     3066mmm     IFEQ DEBUG
0000118C  1639 00C00003           3067mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001192  0803 0002               3068mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001196  67F4                    3069mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001198  13DA 00C00007           3070mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000119E                          3071mmm     ENDC
0000119E                          3072mmm 
0000119E                 FALSE    3073mmm     IFNE DEBUG
0000119E                          3074mmm     ENDC
0000119E                          3075mmm 
0000119E                          3076mmm     ENDM
0000119E  60E4                    3077mm     BRA LOOP_203
000011A0                          3078mm EXIT_203
000011A0                          3079mm     ENDM
000011A0  7A07                    3080m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011A2                          3081m LOOP_202
000011A2                          3082mm     BIN2HEX D2,D4,A2
000011A2  45FA 0AD0               3083mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011A6  E99A                    3084mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011A8  1802                    3085mm     MOVE.B D2,D4
000011AA  0284 0000000F           3086mm     ANDI.L #$F,D4
000011B0  1832 4000               3087mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011B4                          3088mm     ENDM
000011B4                          3089mm     PRINT_CHAR D4,D3
000011B4                          3090mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011B4                 TRUE     3091mm     IFEQ DEBUG
000011B4  1639 00C00003           3092mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011BA  0803 0002               3093mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011BE  67F4                    3094mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
000011C0  13C4 00C00007           3095mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011C6                          3096mm     ENDC
000011C6                          3097mm 
000011C6                 FALSE    3098mm     IFNE DEBUG
000011C6                          3099mm     ENDC
000011C6                          3100mm 
000011C6                          3101mm     ENDM
000011C6  57CD FFDA               3102m     DBEQ D5,LOOP_202
000011CA                          3103m     ENDM
000011CA                          3104  
000011CA                          3105m     PRINT_CRLF D3,A2
000011CA  45FA 0AE3               3106m     LEA CRLF(PC),A2
000011CE                          3107mm     PRINT_STR A2,D3
000011CE                          3108mm LOOP_208
000011CE  0C12 0000               3109mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D2  6700 0016               3110mm     BEQ EXIT_208
000011D6                          3111mmm     PRINT_CHAR (A2)+,D3
000011D6                          3112mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011D6                 TRUE     3113mmm     IFEQ DEBUG
000011D6  1639 00C00003           3114mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011DC  0803 0002               3115mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011E0  67F4                    3116mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
000011E2  13DA 00C00007           3117mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011E8                          3118mmm     ENDC
000011E8                          3119mmm 
000011E8                 FALSE    3120mmm     IFNE DEBUG
000011E8                          3121mmm     ENDC
000011E8                          3122mmm 
000011E8                          3123mmm     ENDM
000011E8  60E4                    3124mm     BRA LOOP_208
000011EA                          3125mm EXIT_208
000011EA                          3126mm     ENDM
000011EA                          3127m     ENDM
000011EA                          3128  
000011EA                          3129m     PROGRAM D0,(A0),D2
000011EA  3080                    3130m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000011EC                          3131m 
000011EC                          3132m WAIT_FOR_COMPLETE_210
000011EC  3410                    3133m         MOVE.W (A0),D2
000011EE                          3134m 
000011EE                          3135m         IF.W D2 <NE> D0 THEN
000011EE  B440                    3136ms     CMP.W   D0,D2
000011F0  6700 0004               3137ms     BEQ _00000013
000011F4  60F6                    3138m             BRA WAIT_FOR_COMPLETE_210
000011F6                          3139m         ENDI
000011F6                          3140ms _00000013
000011F6                          3141m         ENDM
000011F6                          3142  
000011F6                          3143m     PROTECT
000011F6  31FC AAAA 2AAA          3144m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000011FC  31FC 5555 1554          3145m     MOVE.W #$5555,$1554
00001202  31FC A0A0 2AAA          3146m     MOVE.W #$A0A0,$2AAA
00001208                          3147m     ENDM
00001208                          3148      
00001208  6000 F13A               3149      BRA MAIN_LOOP
0000120C                          3150      
0000120C                          3151  X
0000120C  45FA 0ABA               3152      LEA STATUS_REGISTER(PC),A2
00001210                          3153m     PRINT_STR A2,D3
00001210                          3154m LOOP_212
00001210  0C12 0000               3155m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001214  6700 0016               3156m     BEQ EXIT_212
00001218                          3157mm     PRINT_CHAR (A2)+,D3
00001218                          3158mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001218                 TRUE     3159mm     IFEQ DEBUG
00001218  1639 00C00003           3160mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000121E  0803 0002               3161mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001222  67F4                    3162mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
00001224  13DA 00C00007           3163mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000122A                          3164mm     ENDC
0000122A                          3165mm 
0000122A                 FALSE    3166mm     IFNE DEBUG
0000122A                          3167mm     ENDC
0000122A                          3168mm 
0000122A                          3169mm     ENDM
0000122A  60E4                    3170m     BRA LOOP_212
0000122C                          3171m EXIT_212
0000122C                          3172m     ENDM
0000122C                          3173  
0000122C  40C0                    3174      MOVE SR,D0
0000122E                          3175m     PRINT_REG D0,D3,D4,D5,A2
0000122E  45FA 0A85               3176m     LEA OX(PC),A2
00001232                          3177mm     PRINT_STR A2,D3
00001232                          3178mm LOOP_215
00001232  0C12 0000               3179mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001236  6700 0016               3180mm     BEQ EXIT_215
0000123A                          3181mmm     PRINT_CHAR (A2)+,D3
0000123A                          3182mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000123A                 TRUE     3183mmm     IFEQ DEBUG
0000123A  1639 00C00003           3184mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001240  0803 0002               3185mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001244  67F4                    3186mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001246  13DA 00C00007           3187mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000124C                          3188mmm     ENDC
0000124C                          3189mmm 
0000124C                 FALSE    3190mmm     IFNE DEBUG
0000124C                          3191mmm     ENDC
0000124C                          3192mmm 
0000124C                          3193mmm     ENDM
0000124C  60E4                    3194mm     BRA LOOP_215
0000124E                          3195mm EXIT_215
0000124E                          3196mm     ENDM
0000124E  7A07                    3197m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001250                          3198m LOOP_214
00001250                          3199mm     BIN2HEX D0,D4,A2
00001250  45FA 0A22               3200mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001254  E998                    3201mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001256  1800                    3202mm     MOVE.B D0,D4
00001258  0284 0000000F           3203mm     ANDI.L #$F,D4
0000125E  1832 4000               3204mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001262                          3205mm     ENDM
00001262                          3206mm     PRINT_CHAR D4,D3
00001262                          3207mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001262                 TRUE     3208mm     IFEQ DEBUG
00001262  1639 00C00003           3209mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001268  0803 0002               3210mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000126C  67F4                    3211mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
0000126E  13C4 00C00007           3212mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001274                          3213mm     ENDC
00001274                          3214mm 
00001274                 FALSE    3215mm     IFNE DEBUG
00001274                          3216mm     ENDC
00001274                          3217mm 
00001274                          3218mm     ENDM
00001274  57CD FFDA               3219m     DBEQ D5,LOOP_214
00001278                          3220m     ENDM
00001278                          3221m     PRINT_CRLF D3,A2
00001278  45FA 0A35               3222m     LEA CRLF(PC),A2
0000127C                          3223mm     PRINT_STR A2,D3
0000127C                          3224mm LOOP_220
0000127C  0C12 0000               3225mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001280  6700 0016               3226mm     BEQ EXIT_220
00001284                          3227mmm     PRINT_CHAR (A2)+,D3
00001284                          3228mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001284                 TRUE     3229mmm     IFEQ DEBUG
00001284  1639 00C00003           3230mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000128A  0803 0002               3231mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000128E  67F4                    3232mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001290  13DA 00C00007           3233mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001296                          3234mmm     ENDC
00001296                          3235mmm 
00001296                 FALSE    3236mmm     IFNE DEBUG
00001296                          3237mmm     ENDC
00001296                          3238mmm 
00001296                          3239mmm     ENDM
00001296  60E4                    3240mm     BRA LOOP_220
00001298                          3241mm EXIT_220
00001298                          3242mm     ENDM
00001298                          3243m     ENDM
00001298                          3244  
00001298  45FA 0A29               3245      LEA STACK_POINTER(PC),A2
0000129C                          3246m     PRINT_STR A2,D3
0000129C                          3247m LOOP_222
0000129C  0C12 0000               3248m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012A0  6700 0016               3249m     BEQ EXIT_222
000012A4                          3250mm     PRINT_CHAR (A2)+,D3
000012A4                          3251mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012A4                 TRUE     3252mm     IFEQ DEBUG
000012A4  1639 00C00003           3253mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012AA  0803 0002               3254mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012AE  67F4                    3255mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
000012B0  13DA 00C00007           3256mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012B6                          3257mm     ENDC
000012B6                          3258mm 
000012B6                 FALSE    3259mm     IFNE DEBUG
000012B6                          3260mm     ENDC
000012B6                          3261mm 
000012B6                          3262mm     ENDM
000012B6  60E4                    3263m     BRA LOOP_222
000012B8                          3264m EXIT_222
000012B8                          3265m     ENDM
000012B8                          3266  
000012B8  200F                    3267      MOVE.L SP,D0
000012BA                          3268m     PRINT_REG D0,D3,D4,D5,A2
000012BA  45FA 09F9               3269m     LEA OX(PC),A2
000012BE                          3270mm     PRINT_STR A2,D3
000012BE                          3271mm LOOP_225
000012BE  0C12 0000               3272mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012C2  6700 0016               3273mm     BEQ EXIT_225
000012C6                          3274mmm     PRINT_CHAR (A2)+,D3
000012C6                          3275mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012C6                 TRUE     3276mmm     IFEQ DEBUG
000012C6  1639 00C00003           3277mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012CC  0803 0002               3278mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012D0  67F4                    3279mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012D2  13DA 00C00007           3280mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012D8                          3281mmm     ENDC
000012D8                          3282mmm 
000012D8                 FALSE    3283mmm     IFNE DEBUG
000012D8                          3284mmm     ENDC
000012D8                          3285mmm 
000012D8                          3286mmm     ENDM
000012D8  60E4                    3287mm     BRA LOOP_225
000012DA                          3288mm EXIT_225
000012DA                          3289mm     ENDM
000012DA  7A07                    3290m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012DC                          3291m LOOP_224
000012DC                          3292mm     BIN2HEX D0,D4,A2
000012DC  45FA 0996               3293mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012E0  E998                    3294mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012E2  1800                    3295mm     MOVE.B D0,D4
000012E4  0284 0000000F           3296mm     ANDI.L #$F,D4
000012EA  1832 4000               3297mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000012EE                          3298mm     ENDM
000012EE                          3299mm     PRINT_CHAR D4,D3
000012EE                          3300mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012EE                 TRUE     3301mm     IFEQ DEBUG
000012EE  1639 00C00003           3302mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012F4  0803 0002               3303mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012F8  67F4                    3304mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
000012FA  13C4 00C00007           3305mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001300                          3306mm     ENDC
00001300                          3307mm 
00001300                 FALSE    3308mm     IFNE DEBUG
00001300                          3309mm     ENDC
00001300                          3310mm 
00001300                          3311mm     ENDM
00001300  57CD FFDA               3312m     DBEQ D5,LOOP_224
00001304                          3313m     ENDM
00001304                          3314m     PRINT_CRLF D3,A2
00001304  45FA 09A9               3315m     LEA CRLF(PC),A2
00001308                          3316mm     PRINT_STR A2,D3
00001308                          3317mm LOOP_230
00001308  0C12 0000               3318mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000130C  6700 0016               3319mm     BEQ EXIT_230
00001310                          3320mmm     PRINT_CHAR (A2)+,D3
00001310                          3321mmm WAIT_FOR_READY_231                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001310                 TRUE     3322mmm     IFEQ DEBUG
00001310  1639 00C00003           3323mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001316  0803 0002               3324mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000131A  67F4                    3325mmm         BEQ WAIT_FOR_READY_231                      ; NO SPACE, CHECK AGAIN
0000131C  13DA 00C00007           3326mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001322                          3327mmm     ENDC
00001322                          3328mmm 
00001322                 FALSE    3329mmm     IFNE DEBUG
00001322                          3330mmm     ENDC
00001322                          3331mmm 
00001322                          3332mmm     ENDM
00001322  60E4                    3333mm     BRA LOOP_230
00001324                          3334mm EXIT_230
00001324                          3335mm     ENDM
00001324                          3336m     ENDM
00001324                          3337  
00001324  6000 F01E               3338      BRA MAIN_LOOP
00001328                          3339          
00001328                          3340  EI
00001328  13FC 0008 00C0000B      3341      MOVE.B #8,DUART_IMR
00001330  027C F8FF               3342      AND.W #$F8FF,SR
00001334  6000 F00E               3343      BRA MAIN_LOOP
00001338                          3344      
00001338                          3345  DI
00001338  13FC 0000 00C0000B      3346      MOVE.B #0,DUART_IMR
00001340  007C 0700               3347      OR.W #$0700,SR
00001344  6000 EFFE               3348      BRA MAIN_LOOP
00001348                          3349          
00001348                          3350  HASH
00001348                          3351m     PROTECT
00001348  31FC AAAA 2AAA          3352m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000134E  31FC 5555 1554          3353m     MOVE.W #$5555,$1554
00001354  31FC A0A0 2AAA          3354m     MOVE.W #$A0A0,$2AAA
0000135A                          3355m     ENDM
0000135A  6000 EFE8               3356      BRA MAIN_LOOP
0000135E                          3357  
0000135E                          3358  I
0000135E  13FC 0038 00A00019      3359      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001366                          3360      
00001366                          3361m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
00001366  13FC 00FF 00A00007      3362m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000136E  103C 0030               3363m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001372  0000 0006               3364m     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001376  13C0 00A00019           3365m     MOVE.B D0, MC68230_PORT_C_DATA
0000137C  0200 00EF               3366m     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001380  13FC 00E0 00A00013      3367m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
00001388  13C0 00A00019           3368m     MOVE.B D0, MC68230_PORT_C_DATA
0000138E  0000 0010               3369m     ORI.B #MC68230_PORT_C_WRITE, D0
00001392  13C0 00A00019           3370m     MOVE.B D0, MC68230_PORT_C_DATA
00001398  13FC 0038 00A00019      3371m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013A0                          3372m     ENDM
000013A0                          3373m     WAIT_DRIVE_READY D0, D1
000013A0                          3374m LOOP_234
000013A0                          3375mm     READ_IDE_STATUS D0, D1
000013A0                          3376mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000013A0  13FC 0000 00A00007      3377mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000013A8  123C 0030               3378mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000013AC  0001 0007               3379mmm     ORI.B #IDE_STATUS_REGISTER, D1
000013B0  13C1 00A00019           3380mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013B6  0201 00DF               3381mmm     ANDI.B #~MC68230_PORT_C_READ, D1
000013BA  13C1 00A00019           3382mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013C0  1039 00A00013           3383mmm     MOVE.B MC68230_PORT_B_DATA, D0
000013C6  0001 0020               3384mmm     ORI.B #MC68230_PORT_C_READ, D1
000013CA  13C1 00A00019           3385mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013D0  13FC 0038 00A00019      3386mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013D8                          3387mmm     ENDM
000013D8                          3388mm     ENDM
000013D8  0800 0006               3389m     BTST #IDE_STATUS_READY, D0
000013DC  67C2                    3390m     BEQ LOOP_234
000013DE                          3391m     ENDM
000013DE                          3392          
000013DE                          3393m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
000013DE                          3394mm     WAIT_DRIVE_NOT_BUSY D0, D1
000013DE                          3395mm LOOP_238
000013DE                          3396mmm     READ_IDE_STATUS D0, D1
000013DE                          3397mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000013DE  13FC 0000 00A00007      3398mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000013E6  123C 0030               3399mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000013EA  0001 0007               3400mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000013EE  13C1 00A00019           3401mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000013F4  0201 00DF               3402mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000013F8  13C1 00A00019           3403mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000013FE  1039 00A00013           3404mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001404  0001 0020               3405mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001408  13C1 00A00019           3406mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000140E  13FC 0038 00A00019      3407mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001416                          3408mmmm     ENDM
00001416                          3409mmm     ENDM
00001416  0800 0007               3410mm     BTST #IDE_STATUS_BUSY, D0
0000141A  66C2                    3411mm     BNE LOOP_238
0000141C                          3412mm     ENDM
0000141C                          3413mm     SET_READ_ADDRESS #0, D0, D1, D2
0000141C                          3414mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
0000141C  13FC 00FF 00A00007      3415mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001424  103C 0030               3416mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001428  0000 0002               3417mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
0000142C  13C0 00A00019           3418mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001432  0200 00EF               3419mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001436  13FC 0001 00A00013      3420mmm     MOVE.B #1, MC68230_PORT_B_DATA
0000143E  13C0 00A00019           3421mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001444  0000 0010               3422mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001448  13C0 00A00019           3423mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000144E  13FC 0038 00A00019      3424mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001456                          3425mmm     ENDM
00001456  7200                    3426mm     MOVE.L #0,D1
00001458                          3427mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
00001458  13FC 00FF 00A00007      3428mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001460  103C 0030               3429mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001464  0000 0003               3430mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
00001468  13C0 00A00019           3431mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000146E  0200 00EF               3432mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001472  13C1 00A00013           3433mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001478  13C0 00A00019           3434mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000147E  0000 0010               3435mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001482  13C0 00A00019           3436mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001488  13FC 0038 00A00019      3437mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001490                          3438mmm     ENDM
00001490  E089                    3439mm     LSR.L #8, D1
00001492                          3440mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
00001492  13FC 00FF 00A00007      3441mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000149A  103C 0030               3442mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000149E  0000 0004               3443mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
000014A2  13C0 00A00019           3444mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014A8  0200 00EF               3445mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014AC  13C1 00A00013           3446mmm     MOVE.B D1, MC68230_PORT_B_DATA
000014B2  13C0 00A00019           3447mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014B8  0000 0010               3448mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014BC  13C0 00A00019           3449mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014C2  13FC 0038 00A00019      3450mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014CA                          3451mmm     ENDM
000014CA  E089                    3452mm     LSR.L #8, D1                                
000014CC                          3453mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
000014CC  13FC 00FF 00A00007      3454mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014D4  103C 0030               3455mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014D8  0000 0005               3456mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
000014DC  13C0 00A00019           3457mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014E2  0200 00EF               3458mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014E6  13C1 00A00013           3459mmm     MOVE.B D1, MC68230_PORT_B_DATA
000014EC  13C0 00A00019           3460mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014F2  0000 0010               3461mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014F6  13C0 00A00019           3462mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014FC  13FC 0038 00A00019      3463mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001504                          3464mmm     ENDM
00001504  E089                    3465mm     LSR.L #8, D1
00001506                          3466mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
00001506  13FC 0000 00A00007      3467mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000150E  103C 0030               3468mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001512  0000 0006               3469mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001516  13C0 00A00019           3470mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000151C  0200 00DF               3471mmm     ANDI.B #~MC68230_PORT_C_READ, D0
00001520  13C0 00A00019           3472mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001526  1439 00A00013           3473mmm     MOVE.B MC68230_PORT_B_DATA, D2
0000152C  0000 0020               3474mmm     ORI.B #MC68230_PORT_C_READ, D0
00001530  13C0 00A00019           3475mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001536  13FC 0038 00A00019      3476mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000153E                          3477mmm     ENDM
0000153E  0201 000F               3478mm     ANDI.B #$0F,D1
00001542  8401                    3479mm     OR.B D1,D2
00001544                          3480mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
00001544  13FC 00FF 00A00007      3481mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000154C  103C 0030               3482mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001550  0000 0006               3483mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001554  13C0 00A00019           3484mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000155A  0200 00EF               3485mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000155E  13C2 00A00013           3486mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001564  13C0 00A00019           3487mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000156A  0000 0010               3488mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000156E  13C0 00A00019           3489mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001574  13FC 0038 00A00019      3490mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000157C                          3491mmm     ENDM
0000157C                          3492mm     ENDM
0000157C                          3493mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
0000157C                          3494mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
0000157C  13FC 00FF 00A00007      3495mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001584  103C 0030               3496mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001588  0000 0007               3497mmm     ORI.B #IDE_COMMAND_REGISTER, D0
0000158C  13C0 00A00019           3498mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001592  0200 00EF               3499mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001596  13FC 0020 00A00013      3500mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
0000159E  13C0 00A00019           3501mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015A4  0000 0010               3502mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000015A8  13C0 00A00019           3503mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015AE  13FC 0038 00A00019      3504mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015B6                          3505mmm     ENDM
000015B6                          3506mm     ENDM
000015B6                          3507mm     WAIT_DRIVE_NOT_BUSY D0, D1
000015B6                          3508mm LOOP_250
000015B6                          3509mmm     READ_IDE_STATUS D0, D1
000015B6                          3510mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000015B6  13FC 0000 00A00007      3511mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015BE  123C 0030               3512mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000015C2  0001 0007               3513mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000015C6  13C1 00A00019           3514mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015CC  0201 00DF               3515mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000015D0  13C1 00A00019           3516mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015D6  1039 00A00013           3517mmmm     MOVE.B MC68230_PORT_B_DATA, D0
000015DC  0001 0020               3518mmmm     ORI.B #MC68230_PORT_C_READ, D1
000015E0  13C1 00A00019           3519mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015E6  13FC 0038 00A00019      3520mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015EE                          3521mmmm     ENDM
000015EE                          3522mmm     ENDM
000015EE  0800 0007               3523mm     BTST #IDE_STATUS_BUSY, D0
000015F2  66C2                    3524mm     BNE LOOP_250
000015F4                          3525mm     ENDM
000015F4                          3526mm     WAIT_DRIVE_DRQ D0, D1
000015F4                          3527mm LOOP_253
000015F4                          3528mmm     READ_IDE_STATUS D0, D1
000015F4                          3529mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000015F4  13FC 0000 00A00007      3530mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015FC  123C 0030               3531mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001600  0001 0007               3532mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001604  13C1 00A00019           3533mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000160A  0201 00DF               3534mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000160E  13C1 00A00019           3535mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001614  1039 00A00013           3536mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000161A  0001 0020               3537mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000161E  13C1 00A00019           3538mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001624  13FC 0038 00A00019      3539mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000162C                          3540mmmm     ENDM
0000162C                          3541mmm     ENDM
0000162C  0800 0003               3542mm     BTST #IDE_STATUS_DRQ, D0
00001630  67C2                    3543mm     BEQ LOOP_253
00001632                          3544mm     ENDM
00001632                          3545m     ENDM
00001632                          3546  
00001632                          3547m     READ_32 #IDE_DATA_REGISTER, D0, D7          ; num entries in boot table -> D0
00001632                          3548mm     READ_16 #IDE_DATA_REGISTER, D0, D7
00001632  13FC 0000 00A00007      3549mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000163A  13FC 0000 00A00005      3550mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001642                          3551mm     
00001642  1E3C 0030               3552mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001646  0007 0000               3553mm     ORI.B #IDE_DATA_REGISTER, D7
0000164A  13C7 00A00019           3554mm     MOVE.B D7, MC68230_PORT_C_DATA
00001650  0207 00DF               3555mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001654  13C7 00A00019           3556mm     MOVE.B D7, MC68230_PORT_C_DATA
0000165A  1039 00A00011           3557mm     MOVE.B MC68230_PORT_A_DATA, D0
00001660  E148                    3558mm     LSL.W #8, D0
00001662  1039 00A00013           3559mm     MOVE.B MC68230_PORT_B_DATA, D0
00001668  0007 0020               3560mm     ORI.B #MC68230_PORT_C_READ, D7
0000166C  13C7 00A00019           3561mm     MOVE.B D7, MC68230_PORT_C_DATA
00001672  13FC 0038 00A00019      3562mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000167A                          3563mm     ENDM
0000167A  E188                    3564m     LSL.L #8, D0
0000167C  E188                    3565m     LSL.L #8, D0
0000167E                          3566mm     READ_16 #IDE_DATA_REGISTER, D0, D7
0000167E  13FC 0000 00A00007      3567mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001686  13FC 0000 00A00005      3568mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000168E                          3569mm     
0000168E  1E3C 0030               3570mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001692  0007 0000               3571mm     ORI.B #IDE_DATA_REGISTER, D7
00001696  13C7 00A00019           3572mm     MOVE.B D7, MC68230_PORT_C_DATA
0000169C  0207 00DF               3573mm     ANDI.B #~MC68230_PORT_C_READ, D7
000016A0  13C7 00A00019           3574mm     MOVE.B D7, MC68230_PORT_C_DATA
000016A6  1039 00A00011           3575mm     MOVE.B MC68230_PORT_A_DATA, D0
000016AC  E148                    3576mm     LSL.W #8, D0
000016AE  1039 00A00013           3577mm     MOVE.B MC68230_PORT_B_DATA, D0
000016B4  0007 0020               3578mm     ORI.B #MC68230_PORT_C_READ, D7
000016B8  13C7 00A00019           3579mm     MOVE.B D7, MC68230_PORT_C_DATA
000016BE  13FC 0038 00A00019      3580mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016C6                          3581mm     ENDM
000016C6                          3582m     ENDM
000016C6  7200                    3583      MOVE.L #0, D1                               ; current boot table index -> D1
000016C8                          3584  
000016C8                          3585      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
000016C8  143C 0000               3586s     MOVE.B  #0,D2
000016CC  6000 01E8               3587s     BRA _20000015
000016D0                          3588s _20000014
000016D0                          3589          FOR.B D3 = #0 TO #12 DO                 ; words read from this boot table entry -> D2
000016D0  163C 0000               3590s     MOVE.B  #0,D3
000016D4  6000 01AC               3591s     BRA _20000017
000016D8                          3592s _20000016
000016D8                          3593m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
000016D8                          3594mm     READ_16 #IDE_DATA_REGISTER, D4, D7
000016D8  13FC 0000 00A00007      3595mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016E0  13FC 0000 00A00005      3596mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000016E8                          3597mm     
000016E8  1E3C 0030               3598mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000016EC  0007 0000               3599mm     ORI.B #IDE_DATA_REGISTER, D7
000016F0  13C7 00A00019           3600mm     MOVE.B D7, MC68230_PORT_C_DATA
000016F6  0207 00DF               3601mm     ANDI.B #~MC68230_PORT_C_READ, D7
000016FA  13C7 00A00019           3602mm     MOVE.B D7, MC68230_PORT_C_DATA
00001700  1839 00A00011           3603mm     MOVE.B MC68230_PORT_A_DATA, D4
00001706  E14C                    3604mm     LSL.W #8, D4
00001708  1839 00A00013           3605mm     MOVE.B MC68230_PORT_B_DATA, D4
0000170E  0007 0020               3606mm     ORI.B #MC68230_PORT_C_READ, D7
00001712  13C7 00A00019           3607mm     MOVE.B D7, MC68230_PORT_C_DATA
00001718  13FC 0038 00A00019      3608mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001720                          3609mm     ENDM
00001720  E18C                    3610m     LSL.L #8, D4
00001722  E18C                    3611m     LSL.L #8, D4
00001724                          3612mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001724  13FC 0000 00A00007      3613mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000172C  13FC 0000 00A00005      3614mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001734                          3615mm     
00001734  1E3C 0030               3616mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001738  0007 0000               3617mm     ORI.B #IDE_DATA_REGISTER, D7
0000173C  13C7 00A00019           3618mm     MOVE.B D7, MC68230_PORT_C_DATA
00001742  0207 00DF               3619mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001746  13C7 00A00019           3620mm     MOVE.B D7, MC68230_PORT_C_DATA
0000174C  1839 00A00011           3621mm     MOVE.B MC68230_PORT_A_DATA, D4
00001752  E14C                    3622mm     LSL.W #8, D4
00001754  1839 00A00013           3623mm     MOVE.B MC68230_PORT_B_DATA, D4
0000175A  0007 0020               3624mm     ORI.B #MC68230_PORT_C_READ, D7
0000175E  13C7 00A00019           3625mm     MOVE.B D7, MC68230_PORT_C_DATA
00001764  13FC 0038 00A00019      3626mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000176C                          3627mm     ENDM
0000176C                          3628m     ENDM
0000176C                          3629              IF.B D1 <LT> D0 THEN                ; still in the boot table?
0000176C  B200                    3630s     CMP.B   D0,D1
0000176E  6C00 0110               3631s     BGE _00000014
00001772                          3632  
00001772                          3633                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
00001772  B63C 0000               3634s     CMP.B   #0,D3
00001776  6600 0004               3635s     BNE _00000015
0000177A  1A04                    3636                      MOVE.B D4, D5               ; empty flag -> D5
0000177C                          3637                  ENDI
0000177C                          3638s _00000015
0000177C                          3639                  
0000177C                          3640                  IF.B D5 <NE> #1 THEN            ; not empty
0000177C  BA3C 0001               3641s     CMP.B   #1,D5
00001780  6700 00FE               3642s     BEQ _00000016
00001784  2245                    3643                      MOVE.L D5, A1               ; preserve the empty flag, we're gonna need D5
00001786                          3644                      
00001786                          3645                      IF.B D3 <EQ> #0 THEN        ; first word in boot table, print the index
00001786  B63C 0000               3646s     CMP.B   #0,D3
0000178A  6600 0044               3647s     BNE _00000017
0000178E                          3648m                         PRINT_REG_4BIT D1, D6, D7, A0   
0000178E  41FA 04E4               3649m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001792  1E01                    3650m     MOVE.B D1,D7
00001794  0287 0000000F           3651m     ANDI.L #$F,D7
0000179A  1E30 7000               3652m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
0000179E                          3653mm     PRINT_CHAR D7,D6
0000179E                          3654mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000179E                 TRUE     3655mm     IFEQ DEBUG
0000179E  1C39 00C00003           3656mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000017A4  0806 0002               3657mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000017A8  67F4                    3658mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
000017AA  13C7 00C00007           3659mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017B0                          3660mm     ENDC
000017B0                          3661mm 
000017B0                 FALSE    3662mm     IFNE DEBUG
000017B0                          3663mm     ENDC
000017B0                          3664mm 
000017B0                          3665mm     ENDM
000017B0                          3666m     ENDM
000017B0  41FA 051B               3667                          LEA INDEX_SEP(PC), A0
000017B4                          3668m                         PRINT_STR A0, D7
000017B4                          3669m LOOP_264
000017B4  0C10 0000               3670m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017B8  6700 0016               3671m     BEQ EXIT_264
000017BC                          3672mm     PRINT_CHAR (A0)+,D7
000017BC                          3673mm WAIT_FOR_READY_265                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017BC                 TRUE     3674mm     IFEQ DEBUG
000017BC  1E39 00C00003           3675mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017C2  0807 0002               3676mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017C6  67F4                    3677mm         BEQ WAIT_FOR_READY_265                      ; NO SPACE, CHECK AGAIN
000017C8  13D8 00C00007           3678mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017CE                          3679mm     ENDC
000017CE                          3680mm 
000017CE                 FALSE    3681mm     IFNE DEBUG
000017CE                          3682mm     ENDC
000017CE                          3683mm 
000017CE                          3684mm     ENDM
000017CE  60E4                    3685m     BRA LOOP_264
000017D0                          3686m EXIT_264
000017D0                          3687m     ENDM
000017D0                          3688                      ENDI
000017D0                          3689s _00000017
000017D0                          3690                              
000017D0                          3691                      IF.B D3 <GT> #1 AND.B D3 <LT> #8 THEN   ; str, print it
000017D0  B63C 0001               3692s     CMP.B   #1,D3
000017D4  6F00 002E               3693s     BLE _00000018
000017D8  B63C 0008               3694s     CMP.B   #8,D3
000017DC  6C00 0026               3695s     BGE _00000018
000017E0                          3696                          FOR.B D6 = #0 TO #3 DO
000017E0  1C3C 0000               3697s     MOVE.B  #0,D6
000017E4  6000 0018               3698s     BRA _20000019
000017E8                          3699s _20000018
000017E8  E19C                    3700                              ROL.L #8, D4                    
000017EA                          3701m                             PRINT_CHAR D4, D7
000017EA                          3702m WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017EA                 TRUE     3703m     IFEQ DEBUG
000017EA  1E39 00C00003           3704m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000017F0  0807 0002               3705m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017F4  67F4                    3706m         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
000017F6  13C4 00C00007           3707m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017FC                          3708m     ENDC
000017FC                          3709m 
000017FC                 FALSE    3710m     IFNE DEBUG
000017FC                          3711m     ENDC
000017FC                          3712m 
000017FC                          3713m     ENDM
000017FC                          3714                          ENDF
000017FC  5206                    3715s     ADD.B   #1,D6
000017FE                          3716s _20000019
000017FE  BC3C 0003               3717s     CMP.B   #3,D6
00001802  6FE4                    3718s     BLE _20000018
00001804                          3719                      ENDI
00001804                          3720s _00000018
00001804                          3721  
00001804                          3722                      IF.B D3 <GT> #8 AND.B D3 <LT> #13 THEN
00001804  B63C 0008               3723s     CMP.B   #8,D3
00001808  6F00 0074               3724s     BLE _00000019
0000180C  B63C 000D               3725s     CMP.B   #13,D3
00001810  6C00 006C               3726s     BGE _00000019
00001814  41FA 04B7               3727                          LEA INDEX_SEP(PC), A0
00001818                          3728m                         PRINT_STR A0, D7
00001818                          3729m LOOP_267
00001818  0C10 0000               3730m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000181C  6700 0016               3731m     BEQ EXIT_267
00001820                          3732mm     PRINT_CHAR (A0)+,D7
00001820                          3733mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001820                 TRUE     3734mm     IFEQ DEBUG
00001820  1E39 00C00003           3735mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001826  0807 0002               3736mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000182A  67F4                    3737mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
0000182C  13D8 00C00007           3738mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001832                          3739mm     ENDC
00001832                          3740mm 
00001832                 FALSE    3741mm     IFNE DEBUG
00001832                          3742mm     ENDC
00001832                          3743mm 
00001832                          3744mm     ENDM
00001832  60E4                    3745m     BRA LOOP_267
00001834                          3746m EXIT_267
00001834                          3747m     ENDM
00001834                          3748m                         PRINT_REG D4, D5, D6, D7, A0    
00001834  41FA 047F               3749m     LEA OX(PC),A0
00001838                          3750mm     PRINT_STR A0,D5
00001838                          3751mm LOOP_270
00001838  0C10 0000               3752mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000183C  6700 0016               3753mm     BEQ EXIT_270
00001840                          3754mmm     PRINT_CHAR (A0)+,D5
00001840                          3755mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001840                 TRUE     3756mmm     IFEQ DEBUG
00001840  1A39 00C00003           3757mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00001846  0805 0002               3758mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000184A  67F4                    3759mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
0000184C  13D8 00C00007           3760mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001852                          3761mmm     ENDC
00001852                          3762mmm 
00001852                 FALSE    3763mmm     IFNE DEBUG
00001852                          3764mmm     ENDC
00001852                          3765mmm 
00001852                          3766mmm     ENDM
00001852  60E4                    3767mm     BRA LOOP_270
00001854                          3768mm EXIT_270
00001854                          3769mm     ENDM
00001854  7E07                    3770m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001856                          3771m LOOP_269
00001856                          3772mm     BIN2HEX D4,D6,A0
00001856  41FA 041C               3773mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000185A  E99C                    3774mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000185C  1C04                    3775mm     MOVE.B D4,D6
0000185E  0286 0000000F           3776mm     ANDI.L #$F,D6
00001864  1C30 6000               3777mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00001868                          3778mm     ENDM
00001868                          3779mm     PRINT_CHAR D6,D5
00001868                          3780mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001868                 TRUE     3781mm     IFEQ DEBUG
00001868  1A39 00C00003           3782mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000186E  0805 0002               3783mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001872  67F4                    3784mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
00001874  13C6 00C00007           3785mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000187A                          3786mm     ENDC
0000187A                          3787mm 
0000187A                 FALSE    3788mm     IFNE DEBUG
0000187A                          3789mm     ENDC
0000187A                          3790mm 
0000187A                          3791mm     ENDM
0000187A  57CF FFDA               3792m     DBEQ D7,LOOP_269
0000187E                          3793m     ENDM
0000187E                          3794                      ENDI        
0000187E                          3795s _00000019
0000187E                          3796                      
0000187E  2A09                    3797                      MOVE.L A1, D5               ; restore the empty flag into D5
00001880                          3798                  ENDI
00001880                          3799s _00000016
00001880                          3800              ENDI            
00001880                          3801s _00000014
00001880                          3802          ENDF
00001880  5203                    3803s     ADD.B   #1,D3
00001882                          3804s _20000017
00001882  B63C 000C               3805s     CMP.B   #12,D3
00001886  6F00 FE50               3806s     BLE _20000016
0000188A                          3807  
0000188A                          3808          IF.B D5 <NE> #1 THEN                    ; not empty
0000188A  BA3C 0001               3809s     CMP.B   #1,D5
0000188E  6700 0022               3810s     BEQ _0000001A
00001892                          3811m             PRINT_CRLF D7, A0
00001892  41FA 041B               3812m     LEA CRLF(PC),A0
00001896                          3813mm     PRINT_STR A0,D7
00001896                          3814mm LOOP_275
00001896  0C10 0000               3815mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000189A  6700 0016               3816mm     BEQ EXIT_275
0000189E                          3817mmm     PRINT_CHAR (A0)+,D7
0000189E                          3818mmm WAIT_FOR_READY_276                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000189E                 TRUE     3819mmm     IFEQ DEBUG
0000189E  1E39 00C00003           3820mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000018A4  0807 0002               3821mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000018A8  67F4                    3822mmm         BEQ WAIT_FOR_READY_276                      ; NO SPACE, CHECK AGAIN
000018AA  13D8 00C00007           3823mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018B0                          3824mmm     ENDC
000018B0                          3825mmm 
000018B0                 FALSE    3826mmm     IFNE DEBUG
000018B0                          3827mmm     ENDC
000018B0                          3828mmm 
000018B0                          3829mmm     ENDM
000018B0  60E4                    3830mm     BRA LOOP_275
000018B2                          3831mm EXIT_275
000018B2                          3832mm     ENDM
000018B2                          3833m     ENDM
000018B2                          3834          ENDI
000018B2                          3835s _0000001A
000018B2                          3836          
000018B2  5281                    3837          ADD.L #1,D1                             ; next boot table index
000018B4                          3838      ENDF
000018B4  5202                    3839s     ADD.B   #1,D2
000018B6                          3840s _20000015
000018B6  B43C 0009               3841s     CMP.B   #9,D2
000018BA  6F00 FE14               3842s     BLE _20000014
000018BE                          3843              
000018BE  6000 EA84               3844      BRA MAIN_LOOP
000018C2                          3845  
000018C2                          3846  HEX_DIGIT
000018C2  E98F                    3847      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
000018C4                          3848m     HEX2BIN D2,D2,A0
000018C4  41FA 03BE               3849m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000018C8  0402 0030               3850m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000018CC  C4BC 000000FF           3851m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000018D2  1430 2000               3852m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000018D6                          3853m     ENDM
000018D6  8E02                    3854      OR.B D2,D7  
000018D8  6000 EA8A               3855      BRA GET_INPUT
000018DC                          3856  
000018DC                          3857  ; exceptions    
000018DC                          3858  BUS_ERROR_HANDLER
000018DC                          3859  
000018DC  41FA 040F               3860      LEA BUS_ERROR(PC),A0
000018E0                          3861m     PRINT_STR A0,D1
000018E0                          3862m LOOP_278
000018E0  0C10 0000               3863m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000018E4  6700 0016               3864m     BEQ EXIT_278
000018E8                          3865mm     PRINT_CHAR (A0)+,D1
000018E8                          3866mm WAIT_FOR_READY_279                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018E8                 TRUE     3867mm     IFEQ DEBUG
000018E8  1239 00C00003           3868mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000018EE  0801 0002               3869mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000018F2  67F4                    3870mm         BEQ WAIT_FOR_READY_279                      ; NO SPACE, CHECK AGAIN
000018F4  13D8 00C00007           3871mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018FA                          3872mm     ENDC
000018FA                          3873mm 
000018FA                 FALSE    3874mm     IFNE DEBUG
000018FA                          3875mm     ENDC
000018FA                          3876mm 
000018FA                          3877mm     ENDM
000018FA  60E4                    3878m     BRA LOOP_278
000018FC                          3879m EXIT_278
000018FC                          3880m     ENDM
000018FC                          3881  
000018FC  7000                    3882      MOVE.L #0,D0
000018FE  3017                    3883      MOVE.W (SP),D0
00001900                          3884  
00001900  0800 0004               3885      BTST #4,D0
00001904  6700 0026               3886      BEQ WRITE
00001908                          3887      
00001908  41FA 03F8               3888      LEA READING(PC),A0
0000190C                          3889m     PRINT_STR A0,D1
0000190C                          3890m LOOP_280
0000190C  0C10 0000               3891m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001910  6700 0016               3892m     BEQ EXIT_280
00001914                          3893mm     PRINT_CHAR (A0)+,D1
00001914                          3894mm WAIT_FOR_READY_281                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001914                 TRUE     3895mm     IFEQ DEBUG
00001914  1239 00C00003           3896mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000191A  0801 0002               3897mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000191E  67F4                    3898mm         BEQ WAIT_FOR_READY_281                      ; NO SPACE, CHECK AGAIN
00001920  13D8 00C00007           3899mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001926                          3900mm     ENDC
00001926                          3901mm 
00001926                 FALSE    3902mm     IFNE DEBUG
00001926                          3903mm     ENDC
00001926                          3904mm 
00001926                          3905mm     ENDM
00001926  60E4                    3906m     BRA LOOP_280
00001928                          3907m EXIT_280
00001928                          3908m     ENDM
00001928                          3909  
00001928  6000 0022               3910      BRA CONTINUE    
0000192C                          3911  WRITE
0000192C  41FA 03DD               3912      LEA WRITING(PC),A0
00001930                          3913m     PRINT_STR A0,D1
00001930                          3914m LOOP_282
00001930  0C10 0000               3915m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001934  6700 0016               3916m     BEQ EXIT_282
00001938                          3917mm     PRINT_CHAR (A0)+,D1
00001938                          3918mm WAIT_FOR_READY_283                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001938                 TRUE     3919mm     IFEQ DEBUG
00001938  1239 00C00003           3920mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000193E  0801 0002               3921mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001942  67F4                    3922mm         BEQ WAIT_FOR_READY_283                      ; NO SPACE, CHECK AGAIN
00001944  13D8 00C00007           3923mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000194A                          3924mm     ENDC
0000194A                          3925mm 
0000194A                 FALSE    3926mm     IFNE DEBUG
0000194A                          3927mm     ENDC
0000194A                          3928mm 
0000194A                          3929mm     ENDM
0000194A  60E4                    3930m     BRA LOOP_282
0000194C                          3931m EXIT_282
0000194C                          3932m     ENDM
0000194C                          3933  
0000194C                          3934  CONTINUE
0000194C  222F 0002               3935      MOVE.L 2(SP),D1
00001950                          3936m     PRINT_REG D1,D2,D3,D4,A0
00001950  41FA 0363               3937m     LEA OX(PC),A0
00001954                          3938mm     PRINT_STR A0,D2
00001954                          3939mm LOOP_285
00001954  0C10 0000               3940mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001958  6700 0016               3941mm     BEQ EXIT_285
0000195C                          3942mmm     PRINT_CHAR (A0)+,D2
0000195C                          3943mmm WAIT_FOR_READY_286                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000195C                 TRUE     3944mmm     IFEQ DEBUG
0000195C  1439 00C00003           3945mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001962  0802 0002               3946mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001966  67F4                    3947mmm         BEQ WAIT_FOR_READY_286                      ; NO SPACE, CHECK AGAIN
00001968  13D8 00C00007           3948mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000196E                          3949mmm     ENDC
0000196E                          3950mmm 
0000196E                 FALSE    3951mmm     IFNE DEBUG
0000196E                          3952mmm     ENDC
0000196E                          3953mmm 
0000196E                          3954mmm     ENDM
0000196E  60E4                    3955mm     BRA LOOP_285
00001970                          3956mm EXIT_285
00001970                          3957mm     ENDM
00001970  7807                    3958m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001972                          3959m LOOP_284
00001972                          3960mm     BIN2HEX D1,D3,A0
00001972  41FA 0300               3961mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001976  E999                    3962mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001978  1601                    3963mm     MOVE.B D1,D3
0000197A  0283 0000000F           3964mm     ANDI.L #$F,D3
00001980  1630 3000               3965mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001984                          3966mm     ENDM
00001984                          3967mm     PRINT_CHAR D3,D2
00001984                          3968mm WAIT_FOR_READY_288                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001984                 TRUE     3969mm     IFEQ DEBUG
00001984  1439 00C00003           3970mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000198A  0802 0002               3971mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000198E  67F4                    3972mm         BEQ WAIT_FOR_READY_288                      ; NO SPACE, CHECK AGAIN
00001990  13C3 00C00007           3973mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001996                          3974mm     ENDC
00001996                          3975mm 
00001996                 FALSE    3976mm     IFNE DEBUG
00001996                          3977mm     ENDC
00001996                          3978mm 
00001996                          3979mm     ENDM
00001996  57CC FFDA               3980m     DBEQ D4,LOOP_284
0000199A                          3981m     ENDM
0000199A                          3982  
0000199A  41FA 0378               3983      LEA FROM(PC),A0
0000199E                          3984m     PRINT_STR A0,D0
0000199E                          3985m LOOP_289
0000199E  0C10 0000               3986m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019A2  6700 0016               3987m     BEQ EXIT_289
000019A6                          3988mm     PRINT_CHAR (A0)+,D0
000019A6                          3989mm WAIT_FOR_READY_290                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019A6                 TRUE     3990mm     IFEQ DEBUG
000019A6  1039 00C00003           3991mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000019AC  0800 0002               3992mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000019B0  67F4                    3993mm         BEQ WAIT_FOR_READY_290                      ; NO SPACE, CHECK AGAIN
000019B2  13D8 00C00007           3994mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019B8                          3995mm     ENDC
000019B8                          3996mm 
000019B8                 FALSE    3997mm     IFNE DEBUG
000019B8                          3998mm     ENDC
000019B8                          3999mm 
000019B8                          4000mm     ENDM
000019B8  60E4                    4001m     BRA LOOP_289
000019BA                          4002m EXIT_289
000019BA                          4003m     ENDM
000019BA                          4004  
000019BA  222F 000A               4005      MOVE.L 10(SP),D1
000019BE                          4006m     PRINT_REG D1,D2,D3,D4,A0
000019BE  41FA 02F5               4007m     LEA OX(PC),A0
000019C2                          4008mm     PRINT_STR A0,D2
000019C2                          4009mm LOOP_292
000019C2  0C10 0000               4010mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019C6  6700 0016               4011mm     BEQ EXIT_292
000019CA                          4012mmm     PRINT_CHAR (A0)+,D2
000019CA                          4013mmm WAIT_FOR_READY_293                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019CA                 TRUE     4014mmm     IFEQ DEBUG
000019CA  1439 00C00003           4015mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019D0  0802 0002               4016mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000019D4  67F4                    4017mmm         BEQ WAIT_FOR_READY_293                      ; NO SPACE, CHECK AGAIN
000019D6  13D8 00C00007           4018mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019DC                          4019mmm     ENDC
000019DC                          4020mmm 
000019DC                 FALSE    4021mmm     IFNE DEBUG
000019DC                          4022mmm     ENDC
000019DC                          4023mmm 
000019DC                          4024mmm     ENDM
000019DC  60E4                    4025mm     BRA LOOP_292
000019DE                          4026mm EXIT_292
000019DE                          4027mm     ENDM
000019DE  7807                    4028m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000019E0                          4029m LOOP_291
000019E0                          4030mm     BIN2HEX D1,D3,A0
000019E0  41FA 0292               4031mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000019E4  E999                    4032mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000019E6  1601                    4033mm     MOVE.B D1,D3
000019E8  0283 0000000F           4034mm     ANDI.L #$F,D3
000019EE  1630 3000               4035mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000019F2                          4036mm     ENDM
000019F2                          4037mm     PRINT_CHAR D3,D2
000019F2                          4038mm WAIT_FOR_READY_295                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019F2                 TRUE     4039mm     IFEQ DEBUG
000019F2  1439 00C00003           4040mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019F8  0802 0002               4041mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000019FC  67F4                    4042mm         BEQ WAIT_FOR_READY_295                      ; NO SPACE, CHECK AGAIN
000019FE  13C3 00C00007           4043mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001A04                          4044mm     ENDC
00001A04                          4045mm 
00001A04                 FALSE    4046mm     IFNE DEBUG
00001A04                          4047mm     ENDC
00001A04                          4048mm 
00001A04                          4049mm     ENDM
00001A04  57CC FFDA               4050m     DBEQ D4,LOOP_291
00001A08                          4051m     ENDM
00001A08                          4052m     PRINT_CRLF D0,A0
00001A08  41FA 02A5               4053m     LEA CRLF(PC),A0
00001A0C                          4054mm     PRINT_STR A0,D0
00001A0C                          4055mm LOOP_297
00001A0C  0C10 0000               4056mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A10  6700 0016               4057mm     BEQ EXIT_297
00001A14                          4058mmm     PRINT_CHAR (A0)+,D0
00001A14                          4059mmm WAIT_FOR_READY_298                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A14                 TRUE     4060mmm     IFEQ DEBUG
00001A14  1039 00C00003           4061mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001A1A  0800 0002               4062mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001A1E  67F4                    4063mmm         BEQ WAIT_FOR_READY_298                      ; NO SPACE, CHECK AGAIN
00001A20  13D8 00C00007           4064mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A26                          4065mmm     ENDC
00001A26                          4066mmm 
00001A26                 FALSE    4067mmm     IFNE DEBUG
00001A26                          4068mmm     ENDC
00001A26                          4069mmm 
00001A26                          4070mmm     ENDM
00001A26  60E4                    4071mm     BRA LOOP_297
00001A28                          4072mm EXIT_297
00001A28                          4073mm     ENDM
00001A28                          4074m     ENDM
00001A28                          4075      
00001A28  207C 00000004           4076      MOVE.L #4,A0
00001A2E  4ED0                    4077      JMP (A0)
00001A30                          4078          
00001A30                          4079  ILLEGAL_HANDLER
00001A30  13FC 0007 00E00001      4080      MOVE.B #7,DISPLAY   
00001A38  207C 00000004           4081      MOVE.L #4,A0
00001A3E  4ED0                    4082      JMP (A0)
00001A40                          4083          
00001A40                          4084  UNHANDLED_HANDLER
00001A40  41FA 02D9               4085      LEA UNHANDLED(PC),A0
00001A44  4EF9 00001A68           4086      JMP PRINTIT_RTE
00001A4A                          4087      
00001A4A                          4088  UNINITIALISED_HANDLER
00001A4A  41FA 02E5               4089      LEA UNINITIALISED(PC),A0
00001A4E  4EF9 00001A68           4090      JMP PRINTIT_RTE
00001A54                          4091  
00001A54                          4092  TICK_HANDLER
00001A54  1039 00C0001F           4093      MOVE.B DUART_RESET_OPR,D0
00001A5A  41FA 028A               4094      LEA TICK(PC),A0
00001A5E  4EF9 00001A68           4095      JMP PRINTIT_RTE
00001A64                          4096  
00001A64                          4097  SPURIOUS_HANDLER
00001A64  41FA 02EA               4098      LEA SPURIOUS(PC),A0
00001A68                          4099  PRINTIT_RTE
00001A68                          4100m     PRINT_STR A0,D1
00001A68                          4101m LOOP_299
00001A68  0C10 0000               4102m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A6C  6700 0016               4103m     BEQ EXIT_299
00001A70                          4104mm     PRINT_CHAR (A0)+,D1
00001A70                          4105mm WAIT_FOR_READY_300                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A70                 TRUE     4106mm     IFEQ DEBUG
00001A70  1239 00C00003           4107mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001A76  0801 0002               4108mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001A7A  67F4                    4109mm         BEQ WAIT_FOR_READY_300                      ; NO SPACE, CHECK AGAIN
00001A7C  13D8 00C00007           4110mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A82                          4111mm     ENDC
00001A82                          4112mm 
00001A82                 FALSE    4113mm     IFNE DEBUG
00001A82                          4114mm     ENDC
00001A82                          4115mm 
00001A82                          4116mm     ENDM
00001A82  60E4                    4117m     BRA LOOP_299
00001A84                          4118m EXIT_299
00001A84                          4119m     ENDM
00001A84  4E73                    4120      RTE 
00001A86                          4121      
00001A86  FFFF FFFF               4122      SIMHALT                                             ; halt simulator
00001A8A                          4123  
00001A8A                          4124  ; strings
00001A8A= 50 72 65 73 73 20 ...   4125  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001A9D= 5B 3F 5D 09 09 09 ...   4126  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001AA9= 5B 76 5D 09 09 09 ...   4127          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001AB8= 78 78 78 78 78 78 ...   4128          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001AD0= 78 78 78 78 78 78 ...   4129          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001AF0= 78 78 78 78 78 78 ...   4130          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001B11= 78 78 78 78 78 78 ...   4131          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001B22= 5B 7A 5D 09 09 09 ...   4132          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001B34= 78 78 78 78 78 78 ...   4133          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001B58= 78 78 78 78 78 78 ...   4134          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001B7A= 23 09 09 09 77 72 ...   4135          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001B94= 5B 78 5D 09 09 09 ...   4136          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001BAB= 5B 49 5D 09 09 09 ...   4137          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001BC4= 5B 6F 5D 09 09 09 ...   4138          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001BDE= 5B 69 5D 09 09 09 ...   4139          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001BF4= 78 78 78 78 78 78 ...   4140          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001C12= 48 75 68 3F 0D 0A 00    4141  HUH  DC.B 'Huh?',CR,LF,NULL
00001C19= 20 53 20 72 65 63 ...   4142  READ    DC.B ' S records read, start address = ',NULL
00001C3B= 57 3A 20 55 6E 6B ...   4143  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001C52= 21 20 43 53 20 66 ...   4144  CS_FAILURE  DC.B '! CS failure at ',NULL
00001C63= 21 20 52 41 4D 20 ...   4145  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001C74= 30 31 32 33 34 35 ...   4146  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001C84= 00 01 02 03 04 05 ...   4147  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001C9B= 4C 6F 61 64 69 6E ...   4148  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001CAF= 0D 0A 00                4149  CRLF    DC.B CR,LF,NULL
00001CB2= 3E 20 00                4150  PROMPT  DC.B '> ',NULL
00001CB5= 30 78 00                4151  ox      DC.B '0x',NULL
00001CB8= 20 2D 3E 20 00          4152  to      DC.B ' -> ',NULL
00001CBD= 20 66 6F 72 20 00       4153  for     DC.B ' for ',NULL
00001CC3= 53 50 3A 20 00          4154  STACK_POINTER DC.B 'SP: ',NULL
00001CC8= 53 52 3A 20 00          4155  STATUS_REGISTER DC.B 'SR: ',NULL
00001CCD= 20 3A 20 00             4156  INDEX_SEP DC.B ' : ',NULL
00001CD1= 42 6F 6F 74 69 6E ...   4157  BOOT DC.B 'Booting ',NULL
00001CDA= 4E 6F 74 20 66 6F ...   4158  NOT_FOUND DC.B 'Not found',CR,LF,NULL
00001CE6= 74 69 63 6B 0D 0A 00    4159  TICK DC.B 'tick',CR,LF,NULL
00001CED= 2A 20 42 75 73 2F ...   4160  BUS_ERROR DC.B '* Bus/address error ',NULL
00001D02= 72 65 61 64 69 6E ...   4161  READING DC.B 'reading ',NULL
00001D0B= 77 72 69 74 69 6E ...   4162  WRITING DC.B 'writing ',NULL
00001D14= 20 66 72 6F 6D 20 00    4163  FROM DC.B ' from ',NULL
00001D1B= 2A 20 55 6E 68 61 ...   4164  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001D31= 2A 20 55 6E 69 74 ...   4165  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00001D50= 2A 20 53 70 75 72 ...   4166  SPURIOUS DC.B '* Spurious interrupt',NULL
00001D65= 4D 44 46 2D 6D 6F ...   4167  VERSION DC.B 'MDF-mon V1.146 (30/05/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001D83= 00                      4168  END     DC.B 0
00001D84                          4169      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1C74
BOOT                1CD1
BUS_ERROR           1CED
BUS_ERROR_HANDLER   18DC
CONTINUE            194C
CONTINUE_101        A72
CONTINUE_54         610
CONTINUE_57         660
CONTINUE_60         6A4
CONTINUE_64         726
CONTINUE_68         786
CONTINUE_72         7F0
CONTINUE_76         85C
CONTINUE_80         8D2
CONTINUE_84         932
CONTINUE_88         992
CR                  D
CRLF                1CAF
CS_FAILURE          1C52
DEBUG               0
DI                  1338
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       B54
DOWNLOAD_DONE       B6A
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  1328
END                 1D83
EXIT_10             288
EXIT_105            AD0
EXIT_107            AF0
EXIT_110            B10
EXIT_115            B5A
EXIT_118            B8A
EXIT_121            BAA
EXIT_125            BF4
EXIT_128            C16
EXIT_133            C60
EXIT_135            CDC
EXIT_138            D00
EXIT_143            D4A
EXIT_15             2D2
EXIT_150            DDC
EXIT_153            E4C
EXIT_156            E6E
EXIT_160            EB8
EXIT_163            EDA
EXIT_167            F24
EXIT_17             2F2
EXIT_170            F44
EXIT_175            F8E
EXIT_190            10B0
EXIT_193            1114
EXIT_196            1134
EXIT_20             312
EXIT_200            117E
EXIT_203            11A0
EXIT_208            11EA
EXIT_212            122C
EXIT_215            124E
EXIT_22             364
EXIT_220            1298
EXIT_222            12B8
EXIT_225            12DA
EXIT_230            1324
EXIT_264            17D0
EXIT_267            1834
EXIT_270            1854
EXIT_275            18B2
EXIT_278            18FC
EXIT_28             3F0
EXIT_280            1928
EXIT_282            194C
EXIT_285            1970
EXIT_289            19BA
EXIT_292            19DE
EXIT_297            1A28
EXIT_299            1A84
EXIT_30             468
EXIT_32             494
EXIT_35             4BE
EXIT_45             56C
EXIT_5              240
EXIT_52             5E2
EXIT_7              260
EXIT_92             9F2
EXIT_94             A12
EXIT_98             A44
FOR                 1CBD
FROM                1D14
G                   C64
GET_INPUT           364
H                   46C
HASH                1348
HELP                1A9D
HELPPROMPT          1A8A
HEX2BIN             10B
HEX2BIN_LUT         1C84
HEX_DIGIT           18C2
HUH                 1C12
I                   135E
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1A30
INDEX_SEP           1CCD
L                   D5A
LF                  A
LOADING             1C9B
LOOP_10             26C
LOOP_105            AB4
LOOP_107            AD4
LOOP_109            B12
LOOP_110            AF4
LOOP_115            B3E
LOOP_118            B6E
LOOP_120            BAC
LOOP_121            B8E
LOOP_125            BD8
LOOP_127            C18
LOOP_128            BFA
LOOP_133            C44
LOOP_135            CC0
LOOP_137            D02
LOOP_138            CE4
LOOP_143            D2E
LOOP_15             2B6
LOOP_150            DC0
LOOP_153            E30
LOOP_155            E70
LOOP_156            E52
LOOP_160            E9C
LOOP_162            EDC
LOOP_163            EBE
LOOP_167            F08
LOOP_169            F46
LOOP_17             2D6
LOOP_170            F28
LOOP_175            F72
LOOP_190            1094
LOOP_193            10F8
LOOP_195            1136
LOOP_196            1118
LOOP_20             2F6
LOOP_200            1162
LOOP_202            11A2
LOOP_203            1184
LOOP_208            11CE
LOOP_212            1210
LOOP_214            1250
LOOP_215            1232
LOOP_22             348
LOOP_220            127C
LOOP_222            129C
LOOP_224            12DC
LOOP_225            12BE
LOOP_230            1308
LOOP_234            13A0
LOOP_238            13DE
LOOP_250            15B6
LOOP_253            15F4
LOOP_264            17B4
LOOP_267            1818
LOOP_269            1856
LOOP_270            1838
LOOP_275            1896
LOOP_278            18E0
LOOP_28             3D4
LOOP_280            190C
LOOP_282            1930
LOOP_284            1972
LOOP_285            1954
LOOP_289            199E
LOOP_291            19E0
LOOP_292            19C2
LOOP_297            1A0C
LOOP_299            1A68
LOOP_30             44C
LOOP_32             478
LOOP_34             4C0
LOOP_35             4A2
LOOP_45             550
LOOP_5              224
LOOP_52             5C6
LOOP_7              244
LOOP_9              28A
LOOP_92             9D6
LOOP_94             9F6
LOOP_98             A28
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           1CDA
NULL                0
OX                  1CB5
P                   103C
PRINTIT             478
PRINTIT_RTE         1A68
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             CFE
PROGRAM_VECTOR      D95
PROMPT              1CB2
PROTECT             AF0
R                   498
RAM                 200000
RAM_ERROR           1C63
READ                1C19
READING             1D02
READ_16             1188
READ_32             13B5
READ_8              E13
READ_CHAR           6DD
READ_IDE_STATUS     1404
RESET               4
ROM                 0
S                   5EA
SEND_COMMAND        1686
SEND_READ_COMMAND_AND_WAIT  16B5
SET_READ_ADDRESS    1524
SPURIOUS            1D50
SPURIOUS_HANDLER    1A64
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1CC3
START               104
STATUS_REGISTER     1CC8
TAB                 9
TICK                1CE6
TICK_HANDLER        1A54
TO                  1CB8
UNHANDLED           1D1B
UNHANDLED_HANDLER   1A40
UNINITIALISED       1D31
UNINITIALISED_HANDLER  1A4A
UNPROTECT           A29
UNREC               1C3B
USER                100
V                   474
VECS                8
VERSION             1D65
W                   570
WAIT_CHAR           599
WAIT_DRIVE_DRQ      14D4
WAIT_DRIVE_NOT_BUSY  1483
WAIT_DRIVE_READY    1431
WAIT_FOR_COMPLETE_177  FA0
WAIT_FOR_COMPLETE_179  FC2
WAIT_FOR_COMPLETE_180  FD4
WAIT_FOR_COMPLETE_182  1002
WAIT_FOR_COMPLETE_183  1014
WAIT_FOR_COMPLETE_210  11EC
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A56
WAIT_FOR_READY_106  ABC
WAIT_FOR_READY_108  ADC
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AFC
WAIT_FOR_READY_113  B24
WAIT_FOR_READY_116  B46
WAIT_FOR_READY_119  B76
WAIT_FOR_READY_122  B96
WAIT_FOR_READY_124  BBE
WAIT_FOR_READY_126  BE0
WAIT_FOR_READY_129  C02
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_131  C2A
WAIT_FOR_READY_134  C4C
WAIT_FOR_READY_136  CC8
WAIT_FOR_READY_139  CEC
WAIT_FOR_READY_141  D14
WAIT_FOR_READY_144  D36
WAIT_FOR_READY_145  D68
WAIT_FOR_READY_147  D82
WAIT_FOR_READY_151  DC8
WAIT_FOR_READY_154  E38
WAIT_FOR_READY_157  E5A
WAIT_FOR_READY_159  E82
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  EA4
WAIT_FOR_READY_164  EC6
WAIT_FOR_READY_166  EEE
WAIT_FOR_READY_168  F10
WAIT_FOR_READY_171  F30
WAIT_FOR_READY_173  F58
WAIT_FOR_READY_176  F7A
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_185  1048
WAIT_FOR_READY_187  1062
WAIT_FOR_READY_191  109C
WAIT_FOR_READY_194  1100
WAIT_FOR_READY_197  1120
WAIT_FOR_READY_199  1148
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  116A
WAIT_FOR_READY_204  118C
WAIT_FOR_READY_206  11B4
WAIT_FOR_READY_209  11D6
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_213  1218
WAIT_FOR_READY_216  123A
WAIT_FOR_READY_218  1262
WAIT_FOR_READY_221  1284
WAIT_FOR_READY_223  12A4
WAIT_FOR_READY_226  12C6
WAIT_FOR_READY_228  12EE
WAIT_FOR_READY_23   350
WAIT_FOR_READY_231  1310
WAIT_FOR_READY_24   364
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_263  179E
WAIT_FOR_READY_265  17BC
WAIT_FOR_READY_266  17EA
WAIT_FOR_READY_268  1820
WAIT_FOR_READY_271  1840
WAIT_FOR_READY_273  1868
WAIT_FOR_READY_276  189E
WAIT_FOR_READY_279  18E8
WAIT_FOR_READY_281  1914
WAIT_FOR_READY_283  1938
WAIT_FOR_READY_286  195C
WAIT_FOR_READY_288  1984
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_290  19A6
WAIT_FOR_READY_293  19CA
WAIT_FOR_READY_295  19F2
WAIT_FOR_READY_298  1A14
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_300  1A70
WAIT_FOR_READY_31   454
WAIT_FOR_READY_33   480
WAIT_FOR_READY_36   4AA
WAIT_FOR_READY_38   4D2
WAIT_FOR_READY_39   4E8
WAIT_FOR_READY_40   4FE
WAIT_FOR_READY_41   512
WAIT_FOR_READY_42   526
WAIT_FOR_READY_43   53A
WAIT_FOR_READY_46   558
WAIT_FOR_READY_47   57A
WAIT_FOR_READY_49   594
WAIT_FOR_READY_53   5CE
WAIT_FOR_READY_54   5F4
WAIT_FOR_READY_56   62E
WAIT_FOR_READY_57   644
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_60   688
WAIT_FOR_READY_64   70A
WAIT_FOR_READY_68   76A
WAIT_FOR_READY_72   7D4
WAIT_FOR_READY_76   840
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_80   8B6
WAIT_FOR_READY_84   916
WAIT_FOR_READY_88   976
WAIT_FOR_READY_93   9DE
WAIT_FOR_READY_95   9FE
WAIT_FOR_READY_96   A12
WAIT_FOR_READY_99   A30
WAIT_FOR_SRECORD    5F4
WRITE               192C
WRITE_8             FCC
WRITING             1D0B
X                   120C
Z                   C6A
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6EA
_00000004           A48
_00000005           6F8
_00000006           89E
_00000007           826
_00000008           A48
_00000009           9D2
_0000000A           A48
_0000000B           B5E
_0000000C           B6A
_0000000D           D4A
_0000000E           FAA
_0000000F           FCC
_00000010           FDE
_00000011           100C
_00000012           101E
_00000013           11F6
_00000014           1880
_00000015           177C
_00000016           1880
_00000017           17D0
_00000018           1804
_00000019           187E
_0000001A           18B2
_10000000           67E
_10000001           6D4
_10000002           700
_10000003           756
_10000004           760
_10000005           7B6
_10000006           7CA
_10000007           820
_10000008           82A
_10000009           898
_1000000A           836
_1000000B           88C
_1000000C           8AC
_1000000D           902
_1000000E           90C
_1000000F           962
_10000010           96C
_10000011           9C2
_10000012           A4C
_10000013           AA2
_10000014           F8E
_10000015           FB0
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           578
_20000005           5BC
_20000006           C7C
_20000007           C8C
_20000008           CA6
_20000009           D4C
_2000000A           D66
_2000000B           DAA
_2000000C           E22
_2000000D           E26
_2000000E           FE6
_2000000F           1020
_20000010           1046
_20000011           108A
_20000012           10EA
_20000013           10EE
_20000014           16D0
_20000015           18B6
_20000016           16D8
_20000017           1882
_20000018           17E8
_20000019           17FE
