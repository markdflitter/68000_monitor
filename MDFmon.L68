00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/04/2021 12:56:31

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00C00000                 22  DUART_BASE          EQU $C00000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000006                 31  DUART_CTUR_         EQU $6
00000000  =00000007                 32  DUART_CTLR_         EQU $7
00000000  =00000008                 33  DUART_MRB_          EQU $8
00000000  =00000009                 34  DUART_CSRB_         EQU $9
00000000  =00000009                 35  DUART_SRB_          EQU $9
00000000  =0000000A                 36  DUART_CRB_          EQU $A
00000000  =0000000B                 37  DUART_TXB_          EQU $B
00000000  =0000000B                 38  DUART_RXB_          EQU $B
00000000  =0000000C                 39  DUART_IVR_          EQU $C
00000000  =0000000D                 40  DUART_OPCR_         EQU $D
00000000  =0000000E                 41  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 42  DUART_RESET_OPR_    EQU $F
00000000                            43  
00000000  =00C00001                 44  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 45  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 46  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 47  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 48  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 49  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            50  
00000000  =00C00011                 51  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 52  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 53  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 54  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 55  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 56  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            57  
00000000  =00C00009                 58  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 59  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 60  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 61  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 62  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 63  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 64  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 65  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            66  
00000000  =00E00000                 67  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 68  DISPLAY_            EQU $0
00000000  =00E00001                 69  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            77      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78      MOVE.B \1,\2
00000000                            79      ANDI.L #$F,\2
00000000                            80      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            81      ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            88      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            89      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            90      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           100          BTST #2,\2                                  ; check for space to send
00000000                           101          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           102          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           103      ENDC
00000000                           104  
00000000                           105      IFNE DEBUG
00000000                           106          MOVE.B \1,D1
00000000                           107          MOVE.L #6,D0   
00000000                           108          TRAP #15                                    ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll, /2 = working address register
00000000                           115  PRINT_CRLF MACRO
00000000                           116      LEA CRLF(PC),\2
00000000                           117      PRINT_STR \2,\1
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      BRA LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           133  PRINT_REG MACRO
00000000                           134      LEA ox(PC),\5
00000000                           135      PRINT_STR \5,\2
00000000                           136      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142  
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           148      IFEQ DEBUG
00000000                           149          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           150          BTST #0,\2                                  ; check for character
00000000                           151          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           152      ENDC
00000000                           153  
00000000                           154      READ_CHAR \1
00000000                           155  
00000000                           156      IFEQ DEBUG
00000000                           157          PRINT_CHAR \1,\2                            ; echo it back
00000000                           158      ENDC
00000000                           159      ENDM
00000000                           160  
00000000                           161  ; read a char from the serial port - assumes that there is one!
00000000                           162  ; \ 1= data register for read char
00000000                           163  ; will stamp on D0 and D1 in debug mode
00000000                           164  READ_CHAR MACRO
00000000                           165      IFEQ DEBUG
00000000                           166          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           167      ENDC
00000000                           168      IFNE DEBUG
00000000                           169          MOVE.L #5,D0    
00000000                           170          TRAP #15                                    ; read from keyboard in simulator
00000000                           171          MOVE.L D1,\1
00000000                           172      ENDC
00000000                           173  
00000000                           174      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           175      BEQ START
00000000                           176      ENDM
00000000                           177  
00000000                           178  
00000000                           179  ; read data from the download serial port
00000000                           180  ; \ 1= data register for read char
00000000                           181  DOWNLOAD MACRO
00000000                           182  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           183  
00000000                           184      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           185      BTST #0,\1                                      ; check for character
00000000                           186      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           187  
00000000                           188      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           189  CONTINUE\@
00000000                           190      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           193      
00000000                           194      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           195      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           196  
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; unprotect the EEPROM
00000000                           200  UNPROTECT MACRO
00000000                           201      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           202      NOP
00000000                           203      MOVE.W #$5555,$1554
00000000                           204      NOP
00000000                           205      MOVE.W #$8080,$2AAA
00000000                           206      NOP
00000000                           207      MOVE.W #$AAAA,$2AAA
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$2020,$2AAA
00000000                           212      ENDM
00000000                           213      
00000000                           214  ; protect the EEPROM
00000000                           215  PROTECT MACRO
00000000                           216      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           217      MOVE.W #$5555,$1554
00000000                           218      MOVE.W #$A0A0,$2AAA
00000000                           219      ENDM
00000000                           220  
00000000                           221  
00000000                           222  ; read two hex digits from the download serial port and convert to a byte
00000000                           223  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           224  DOWNLOAD_BYTE MACRO
00000000                           225      MOVE.B #2,\4
00000000                           226      WHILE.B \4 <GT> 0 DO
00000000                           227          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           228          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           229          PRINT_CHAR \2,\3
00000000                           230          HEX2BIN \2,\2,\6
00000000                           231          OR.B \2,\1
00000000                           232          SUB.B #1,\4
00000000                           233      ENDW
00000000                           234  
00000000                           235      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           236      MOVE.B \1,\2
00000000                           237      ADD.L \1,\5
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; write word to EEPROM
00000000                           242  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           243  PROGRAM MACRO
00000000                           244    MOVE.W \1,\2                                      ; write the data
00000000                           245  
00000000                           246  WAIT_FOR_COMPLETE\@
00000000                           247          MOVE.W \2,\3
00000000                           248  
00000000                           249          IF.W \3 <NE> \1 THEN
00000000                           250              BRA WAIT_FOR_COMPLETE\@
00000000                           251          ENDI
00000000                           252          ENDM
00000000                           253          
00000000                           254  ; program vector to EEPROM
00000000                           255  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           256  PROGRAM_VECTOR MACRO
00000000                           257      ADD.L #2,\2
00000000                           258      PROGRAM \1, (\2), \3                                ; write it
00000000                           259      LSR.L #8,\1
00000000                           260      LSR.L #8,\1
00000000                           261      SUB.L #2,\2
00000000                           262      PROGRAM \1, (\2), \3
00000000                           263      ENDM
00000000                           264  
00000000                           265  
00000000                           266  ; register catalogue
00000000                           267  ; D0 - used for simulator I/O
00000000                           268  ; D1 - used for simulator I/O
00000000                           269  ; D2 - read character
00000000                           270  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           271  ; D6 - working register used in R/W
00000000                           272  ; D7 - address accumulator, reset by download
00000000                           273  ; A0 - address of string to print 
00000000                           274  
00000000                           275  ; start vector
00000000= 002E0000                 276  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 277  RESET   DC.L START                              ; RESET
00000008= 0000141C                 278  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 0000141C                 279          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001570                 280          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 00001580                 281          DC.L UNHANDLED_HANDLER
00000018= 00001580                 282          DC.L UNHANDLED_HANDLER
0000001C= 00001580                 283          DC.L UNHANDLED_HANDLER
00000020= 00001580                 284          DC.L UNHANDLED_HANDLER
00000024= 00001580                 285          DC.L UNHANDLED_HANDLER
00000028= 00001580                 286          DC.L UNHANDLED_HANDLER
0000002C= 00001580                 287          DC.L UNHANDLED_HANDLER
00000030= 00001580                 288          DC.L UNHANDLED_HANDLER
00000034= 00001580                 289          DC.L UNHANDLED_HANDLER
00000038= 00001580                 290          DC.L UNHANDLED_HANDLER
0000003C= 00001580                 291          DC.L UNHANDLED_HANDLER
00000040= 00001580                 292          DC.L UNHANDLED_HANDLER
00000044= 00001580                 293          DC.L UNHANDLED_HANDLER
00000048= 00001580                 294          DC.L UNHANDLED_HANDLER
0000004C= 00001580                 295          DC.L UNHANDLED_HANDLER
00000050= 00001580                 296          DC.L UNHANDLED_HANDLER
00000054= 00001580                 297          DC.L UNHANDLED_HANDLER
00000058= 00001580                 298          DC.L UNHANDLED_HANDLER
0000005C= 00001580                 299          DC.L UNHANDLED_HANDLER
00000060= 000015A4                 300          DC.L SPURIOUS_HANDLER
00000064= 00001580                 301          DC.L UNHANDLED_HANDLER
00000068= 00001580                 302          DC.L UNHANDLED_HANDLER
0000006C= 00001580                 303          DC.L UNHANDLED_HANDLER
00000070= 00001580                 304          DC.L UNHANDLED_HANDLER
00000074= 00001580                 305          DC.L UNHANDLED_HANDLER
00000078= 00001580                 306          DC.L UNHANDLED_HANDLER
0000007C= 00001580                 307          DC.L UNHANDLED_HANDLER
00000080= 00001580                 308          DC.L UNHANDLED_HANDLER
00000084= 00001580                 309          DC.L UNHANDLED_HANDLER
00000088= 00001580                 310          DC.L UNHANDLED_HANDLER
0000008C= 00001580                 311          DC.L UNHANDLED_HANDLER
00000090= 00001580                 312          DC.L UNHANDLED_HANDLER
00000094= 00001580                 313          DC.L UNHANDLED_HANDLER
00000098= 00001580                 314          DC.L UNHANDLED_HANDLER
0000009C= 00001580                 315          DC.L UNHANDLED_HANDLER
000000A0= 00001580                 316          DC.L UNHANDLED_HANDLER
000000A4= 00001580                 317          DC.L UNHANDLED_HANDLER
000000A8= 00001580                 318          DC.L UNHANDLED_HANDLER
000000AC= 00001580                 319          DC.L UNHANDLED_HANDLER
000000B0= 00001580                 320          DC.L UNHANDLED_HANDLER
000000B4= 00001580                 321          DC.L UNHANDLED_HANDLER
000000B8= 00001580                 322          DC.L UNHANDLED_HANDLER
000000BC= 00001580                 323          DC.L UNHANDLED_HANDLER
000000C0= 00001580                 324          DC.L UNHANDLED_HANDLER
000000C4= 00001580                 325          DC.L UNHANDLED_HANDLER
000000C8= 00001580                 326          DC.L UNHANDLED_HANDLER
000000CC= 00001580                 327          DC.L UNHANDLED_HANDLER
000000D0= 00001580                 328          DC.L UNHANDLED_HANDLER
000000D4= 00001580                 329          DC.L UNHANDLED_HANDLER
000000D8= 00001580                 330          DC.L UNHANDLED_HANDLER 
000000DC= 00001580                 331          DC.L UNHANDLED_HANDLER
000000E0= 00001580                 332          DC.L UNHANDLED_HANDLER
000000E4= 00001580                 333          DC.L UNHANDLED_HANDLER 
000000E8= 00001580                 334          DC.L UNHANDLED_HANDLER 
000000EC= 00001580                 335          DC.L UNHANDLED_HANDLER
000000F0= 00001580                 336          DC.L UNHANDLED_HANDLER 
000000F4= 00001580                 337          DC.L UNHANDLED_HANDLER 
000000F8= 00001580                 338          DC.L UNHANDLED_HANDLER 
000000FC= 00001580                 339          DC.L UNHANDLED_HANDLER
00000100= 00001594                 340  USER    DC.L TICK_HANDLER
00000104                           341      ; start of program  
00000104                           342  START
00000104  2E7C 002E0000            343      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       344      MOVE.B #0,DISPLAY
00000112                           345  
00000112  7000                     346      MOVE.L #0,D0
00000114  1039 00C00019            347      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           348  
0000011A                           349  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       350      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       351      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           352      
0000012A                           353      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                354s     MOVE.W  #$50,D1
0000012E  6000 000E                355s     BRA _20000001
00000132                           356s _20000000
00000132  13C1 00C00005            357          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     358          NOP
0000013A                           359      ENDF
0000013A  0441 0010                360s     SUB.W   #$10,D1
0000013E                           361s _20000001
0000013E  B27C 0010                362s     CMP.W   #$10,D1
00000142  6CEE                     363s     BGE _20000000
00000144                           364  
00000144                           365      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                366s     MOVE.W  #$50,D1
00000148  6000 000E                367s     BRA _20000003
0000014C                           368s _20000002
0000014C  13C1 00C00015            369          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     370          NOP
00000154                           371      ENDF
00000154  0441 0010                372s     SUB.W   #$10,D1
00000158                           373s _20000003
00000158  B27C 0010                374s     CMP.W   #$10,D1
0000015C  6CEE                     375s     BGE _20000002
0000015E                           376      
0000015E                           377  ;initialise UART
0000015E  13FC 0000 00C0000B       378      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       379      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       380      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       381      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       382      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           383  
00000186                           384  ; channel A
00000186  13FC 0013 00C00001       385      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       386      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       387      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       388      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           389  
000001A6                           390  ; channel B
000001A6  13FC 0013 00C00011       391      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       392      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       393      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       394      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       395      MOVE.B #64,DUART_IVR
000001CE                           396  
000001CE                           397m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           398m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      399m     IFEQ DEBUG
000001CE  1239 00C00003            400m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                401m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     402m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       403m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           404m     ENDC
000001E2                           405m 
000001E2                 FALSE     406m     IFNE DEBUG
000001E2                           407m     ENDC
000001E2                           408m 
000001E2                           409m     ENDM
000001E2                           410m     PRINT_CHAR #0,D1
000001E2                           411m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      412m     IFEQ DEBUG
000001E2  1239 00C00003            413m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                414m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     415m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       416m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           417m     ENDC
000001F6                           418m 
000001F6                 FALSE     419m     IFNE DEBUG
000001F6                           420m     ENDC
000001F6                           421m 
000001F6                           422m     ENDM
000001F6                           423m     PRINT_CHAR #0,D1
000001F6                           424m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      425m     IFEQ DEBUG
000001F6  1239 00C00003            426m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                427m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     428m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       429m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           430m     ENDC
0000020A                           431m 
0000020A                 FALSE     432m     IFNE DEBUG
0000020A                           433m     ENDC
0000020A                           434m 
0000020A                           435m     ENDM
0000020A                           436      
0000020A                           437      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                438s     CMP.W   #$0F,D0
0000020E  6600 0008                439s     BNE _00000000
00000212  1039 00C00005            440          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           441      ENDI
00000218                           442s _00000000
00000218                           443  
00000218  13FC 0001 00E00001       444      MOVE.B #1,DISPLAY
00000220                           445      
00000220                           446m     PRINT_CRLF D1,A0
00000220  41FA 159C                447m     LEA CRLF(PC),A0
00000224                           448mm     PRINT_STR A0,D1
00000224                           449mm LOOP_5
00000224  0C10 0000                450mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                451mm     BEQ EXIT_5
0000022C                           452mmm     PRINT_CHAR (A0)+,D1
0000022C                           453mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      454mmm     IFEQ DEBUG
0000022C  1239 00C00003            455mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                456mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     457mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            458mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           459mmm     ENDC
0000023E                           460mmm 
0000023E                 FALSE     461mmm     IFNE DEBUG
0000023E                           462mmm     ENDC
0000023E                           463mmm 
0000023E                           464mmm     ENDM
0000023E  60E4                     465mm     BRA LOOP_5
00000240                           466mm EXIT_5
00000240                           467mm     ENDM
00000240                           468m     ENDM
00000240  41FA 161A                469      LEA VERSION(PC),A0
00000244                           470m     PRINT_STR A0,D3
00000244                           471m LOOP_7
00000244  0C10 0000                472m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                473m     BEQ EXIT_7
0000024C                           474mm     PRINT_CHAR (A0)+,D3
0000024C                           475mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      476mm     IFEQ DEBUG
0000024C  1639 00C00003            477mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                478mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     479mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            480mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           481mm     ENDC
0000025E                           482mm 
0000025E                 FALSE     483mm     IFNE DEBUG
0000025E                           484mm     ENDC
0000025E                           485mm 
0000025E                           486mm     ENDM
0000025E  60E4                     487m     BRA LOOP_7
00000260                           488m EXIT_7
00000260                           489m     ENDM
00000260                           490  
00000260  41F9 0000187A            491      LEA END,A0
00000266  2008                     492      MOVE.L A0,D0
00000268                           493m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 155A                494m     LEA OX(PC),A0
0000026C                           495mm     PRINT_STR A0,D1
0000026C                           496mm LOOP_10
0000026C  0C10 0000                497mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                498mm     BEQ EXIT_10
00000274                           499mmm     PRINT_CHAR (A0)+,D1
00000274                           500mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      501mmm     IFEQ DEBUG
00000274  1239 00C00003            502mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                503mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     504mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            505mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           506mmm     ENDC
00000286                           507mmm 
00000286                 FALSE     508mmm     IFNE DEBUG
00000286                           509mmm     ENDC
00000286                           510mmm 
00000286                           511mmm     ENDM
00000286  60E4                     512mm     BRA LOOP_10
00000288                           513mm EXIT_10
00000288                           514mm     ENDM
00000288  7607                     515m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           516m LOOP_9
0000028A                           517mm     BIN2HEX D0,D2,A0
0000028A  41FA 14F7                518mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     519mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     520mm     MOVE.B D0,D2
00000292  0282 0000000F            521mm     ANDI.L #$F,D2
00000298  1430 2000                522mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           523mm     ENDM
0000029C                           524mm     PRINT_CHAR D2,D1
0000029C                           525mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      526mm     IFEQ DEBUG
0000029C  1239 00C00003            527mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                528mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     529mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            530mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           531mm     ENDC
000002AE                           532mm 
000002AE                 FALSE     533mm     IFNE DEBUG
000002AE                           534mm     ENDC
000002AE                           535mm 
000002AE                           536mm     ENDM
000002AE  57CB FFDA                537m     DBEQ D3,LOOP_9
000002B2                           538m     ENDM
000002B2                           539m     PRINT_CRLF D1,A0
000002B2  41FA 150A                540m     LEA CRLF(PC),A0
000002B6                           541mm     PRINT_STR A0,D1
000002B6                           542mm LOOP_15
000002B6  0C10 0000                543mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                544mm     BEQ EXIT_15
000002BE                           545mmm     PRINT_CHAR (A0)+,D1
000002BE                           546mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      547mmm     IFEQ DEBUG
000002BE  1239 00C00003            548mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                549mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     550mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            551mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           552mmm     ENDC
000002D0                           553mmm 
000002D0                 FALSE     554mmm     IFNE DEBUG
000002D0                           555mmm     ENDC
000002D0                           556mmm 
000002D0                           557mmm     ENDM
000002D0  60E4                     558mm     BRA LOOP_15
000002D2                           559mm EXIT_15
000002D2                           560mm     ENDM
000002D2                           561m     ENDM
000002D2                           562  
000002D2  41FA 12F6                563      LEA HELPPROMPT(PC),A0
000002D6                           564m     PRINT_STR A0,D3
000002D6                           565m LOOP_17
000002D6  0C10 0000                566m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                567m     BEQ EXIT_17
000002DE                           568mm     PRINT_CHAR (A0)+,D3
000002DE                           569mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      570mm     IFEQ DEBUG
000002DE  1639 00C00003            571mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                572mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     573mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            574mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           575mm     ENDC
000002F0                           576mm 
000002F0                 FALSE     577mm     IFNE DEBUG
000002F0                           578mm     ENDC
000002F0                           579mm 
000002F0                           580mm     ENDM
000002F0  60E4                     581m     BRA LOOP_17
000002F2                           582m EXIT_17
000002F2                           583m     ENDM
000002F2                           584  
000002F2                           585m     PRINT_CRLF D3,A0
000002F2  41FA 14CA                586m     LEA CRLF(PC),A0
000002F6                           587mm     PRINT_STR A0,D3
000002F6                           588mm LOOP_20
000002F6  0C10 0000                589mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                590mm     BEQ EXIT_20
000002FE                           591mmm     PRINT_CHAR (A0)+,D3
000002FE                           592mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      593mmm     IFEQ DEBUG
000002FE  1639 00C00003            594mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                595mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     596mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            597mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           598mmm     ENDC
00000310                           599mmm 
00000310                 FALSE     600mmm     IFNE DEBUG
00000310                           601mmm     ENDC
00000310                           602mmm 
00000310                           603mmm     ENDM
00000310  60E4                     604mm     BRA LOOP_20
00000312                           605mm EXIT_20
00000312                           606mm     ENDM
00000312                           607m     ENDM
00000312                           608  
00000312  7E00                     609      MOVE.L #0,D7                                    ; address accumulator
00000314                           610  
00000314  13FC 0002 00E00001       611      MOVE.B #2,DISPLAY
0000031C                           612      
0000031C                           613  MAIN_LOOP
0000031C  41FA 14A3                614      LEA PROMPT(PC),A0
00000320                           615m     PRINT_STR A0,D3
00000320                           616m LOOP_22
00000320  0C10 0000                617m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000324  6700 0016                618m     BEQ EXIT_22
00000328                           619mm     PRINT_CHAR (A0)+,D3
00000328                           620mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      621mm     IFEQ DEBUG
00000328  1639 00C00003            622mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0002                623mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000332  67F4                     624mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000334  13D8 00C00007            625mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000033A                           626mm     ENDC
0000033A                           627mm 
0000033A                 FALSE     628mm     IFNE DEBUG
0000033A                           629mm     ENDC
0000033A                           630mm 
0000033A                           631mm     ENDM
0000033A  60E4                     632m     BRA LOOP_22
0000033C                           633m EXIT_22
0000033C                           634m     ENDM
0000033C                           635  
0000033C                           636  GET_INPUT
0000033C                           637m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000033C                           638m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033C                 TRUE      639m     IFEQ DEBUG
0000033C  1639 00C00003            640m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000342  0803 0000                641m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000346  67F4                     642m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000348                           643m     ENDC
00000348                           644m 
00000348                           645mm     READ_CHAR D2
00000348                 TRUE      646mm     IFEQ DEBUG
00000348  1439 00C00007            647mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000034E                           648mm     ENDC
0000034E                 FALSE     649mm     IFNE DEBUG
0000034E                           650mm     ENDC
0000034E                           651mm 
0000034E  B43C 001B                652mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000352  6700 FDB0                653mm     BEQ START
00000356                           654mm     ENDM
00000356                           655m 
00000356                 TRUE      656m     IFEQ DEBUG
00000356                           657mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000356                           658mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000356                 TRUE      659mm     IFEQ DEBUG
00000356  1639 00C00003            660mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000035C  0803 0002                661mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000360  67F4                     662mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000362  13C2 00C00007            663mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000368                           664mm     ENDC
00000368                           665mm 
00000368                 FALSE     666mm     IFNE DEBUG
00000368                           667mm     ENDC
00000368                           668mm 
00000368                           669mm     ENDM
00000368                           670m     ENDC
00000368                           671m     ENDM
00000368                           672  
00000368                           673      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000368  B43C 0030                674s     CMP.B   #'0',D2
0000036C  6D00 000E                675s     BLT _00000001
00000370  B43C 0039                676s     CMP.B   #'9',D2
00000374  6E00 0006                677s     BGT _00000001
00000378  6000 1088                678          BRA HEX_DIGIT
0000037C                           679      ENDI
0000037C                           680s _00000001
0000037C                           681      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000037C  B43C 0041                682s     CMP.B   #'A',D2
00000380  6D00 000E                683s     BLT _00000002
00000384  B43C 0046                684s     CMP.B   #'F',D2
00000388  6E00 0006                685s     BGT _00000002
0000038C  6000 1074                686          BRA HEX_DIGIT
00000390                           687      ENDI
00000390                           688s _00000002
00000390                           689  
00000390  B43C 0077                690      CMP.B #'w',D2
00000394  6700 01AA                691      BEQ W
00000398                           692  
00000398  B43C 006C                693      CMP.B #'l',D2
0000039C  6700 0A40                694      BEQ L 
000003A0                           695  
000003A0  B43C 0070                696      CMP.B #'p',D2
000003A4  6700 0D3A                697      BEQ P
000003A8                           698  
000003A8                           699m     PRINT_CRLF D3,A0
000003A8  41FA 1414                700m     LEA CRLF(PC),A0
000003AC                           701mm     PRINT_STR A0,D3
000003AC                           702mm LOOP_28
000003AC  0C10 0000                703mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003B0  6700 0016                704mm     BEQ EXIT_28
000003B4                           705mmm     PRINT_CHAR (A0)+,D3
000003B4                           706mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B4                 TRUE      707mmm     IFEQ DEBUG
000003B4  1639 00C00003            708mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003BA  0803 0002                709mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003BE  67F4                     710mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003C0  13D8 00C00007            711mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003C6                           712mmm     ENDC
000003C6                           713mmm 
000003C6                 FALSE     714mmm     IFNE DEBUG
000003C6                           715mmm     ENDC
000003C6                           716mmm 
000003C6                           717mmm     ENDM
000003C6  60E4                     718mm     BRA LOOP_28
000003C8                           719mm EXIT_28
000003C8                           720mm     ENDM
000003C8                           721m     ENDM
000003C8                           722   
000003C8  B43C 003F                723      CMP.B #'?',D2
000003CC  6700 006E                724      BEQ H
000003D0                           725   
000003D0  B43C 0076                726      CMP.B #'v',D2
000003D4  6700 006E                727      BEQ V
000003D8                           728      
000003D8  B43C 0072                729      CMP.B #'r',D2
000003DC  6700 008A                730      BEQ R
000003E0                           731  
000003E0  B43C 0073                732      CMP.B #'s',D2
000003E4  6700 01D6                733      BEQ S
000003E8                           734  
000003E8  B43C 0067                735      CMP.B #'g',D2
000003EC  6700 08FA                736      BEQ G   
000003F0                           737  
000003F0  B43C 007A                738      CMP.B #'z',D2
000003F4  6700 08F8                739      BEQ Z   
000003F8                           740  
000003F8  B43C 0078                741      CMP.B #'x',D2
000003FC  6700 0EB2                742      BEQ X
00000400                           743  
00000400  B43C 0069                744      CMP.B #'i',D2
00000404  6700 0FC6                745      BEQ I
00000408                           746  
00000408  B43C 006F                747      CMP.B #'o',D2
0000040C  6700 0FCE                748      BEQ O
00000410                           749  
00000410  B43C 0023                750      CMP.B #'#',D2
00000414  6700 0FD6                751      BEQ HASH
00000418                           752  
00000418  41FA 1307                753      LEA HUH(PC),A0
0000041C                           754m     PRINT_STR A0,D3
0000041C                           755m LOOP_30
0000041C  0C10 0000                756m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000420  6700 0016                757m     BEQ EXIT_30
00000424                           758mm     PRINT_CHAR (A0)+,D3
00000424                           759mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000424                 TRUE      760mm     IFEQ DEBUG
00000424  1639 00C00003            761mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000042A  0803 0002                762mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000042E  67F4                     763mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000430  13D8 00C00007            764mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000436                           765mm     ENDC
00000436                           766mm 
00000436                 FALSE     767mm     IFNE DEBUG
00000436                           768mm     ENDC
00000436                           769mm 
00000436                           770mm     ENDM
00000436  60E4                     771m     BRA LOOP_30
00000438                           772m EXIT_30
00000438                           773m     ENDM
00000438                           774  
00000438  6000 FEE2                775      BRA MAIN_LOOP
0000043C                           776  
0000043C                           777  ; commands
0000043C                           778  H
0000043C  41FA 119F                779      LEA HELP(PC),A0
00000440  6000 0006                780      BRA PRINTIT
00000444                           781  
00000444                           782  V
00000444  41FA 1416                783      LEA VERSION(PC),A0
00000448                           784  PRINTIT
00000448                           785m     PRINT_STR A0,D3    
00000448                           786m LOOP_32
00000448  0C10 0000                787m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000044C  6700 0016                788m     BEQ EXIT_32
00000450                           789mm     PRINT_CHAR (A0)+,D3
00000450                           790mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000450                 TRUE      791mm     IFEQ DEBUG
00000450  1639 00C00003            792mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000456  0803 0002                793mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000045A  67F4                     794mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000045C  13D8 00C00007            795mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000462                           796mm     ENDC
00000462                           797mm 
00000462                 FALSE     798mm     IFNE DEBUG
00000462                           799mm     ENDC
00000462                           800mm 
00000462                           801mm     ENDM
00000462  60E4                     802m     BRA LOOP_32
00000464                           803m EXIT_32
00000464                           804m     ENDM
00000464  6000 FEB6                805      BRA MAIN_LOOP
00000468                           806  
00000468                           807  R
00000468  2047                     808      MOVE.L D7,A0                                    ; address accumulator -> address register
0000046A  7E00                     809      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000046C  2410                     810      MOVE.L (A0),D2                                  ; read the memory and print it
0000046E                           811m     PRINT_REG D2,D3,D4,D5,A0
0000046E  41FA 1354                812m     LEA OX(PC),A0
00000472                           813mm     PRINT_STR A0,D3
00000472                           814mm LOOP_35
00000472  0C10 0000                815mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000476  6700 0016                816mm     BEQ EXIT_35
0000047A                           817mmm     PRINT_CHAR (A0)+,D3
0000047A                           818mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000047A                 TRUE      819mmm     IFEQ DEBUG
0000047A  1639 00C00003            820mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000480  0803 0002                821mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000484  67F4                     822mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
00000486  13D8 00C00007            823mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000048C                           824mmm     ENDC
0000048C                           825mmm 
0000048C                 FALSE     826mmm     IFNE DEBUG
0000048C                           827mmm     ENDC
0000048C                           828mmm 
0000048C                           829mmm     ENDM
0000048C  60E4                     830mm     BRA LOOP_35
0000048E                           831mm EXIT_35
0000048E                           832mm     ENDM
0000048E  7A07                     833m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000490                           834m LOOP_34
00000490                           835mm     BIN2HEX D2,D4,A0
00000490  41FA 12F1                836mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000494  E99A                     837mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000496  1802                     838mm     MOVE.B D2,D4
00000498  0284 0000000F            839mm     ANDI.L #$F,D4
0000049E  1830 4000                840mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004A2                           841mm     ENDM
000004A2                           842mm     PRINT_CHAR D4,D3
000004A2                           843mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004A2                 TRUE      844mm     IFEQ DEBUG
000004A2  1639 00C00003            845mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004A8  0803 0002                846mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004AC  67F4                     847mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004AE  13C4 00C00007            848mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004B4                           849mm     ENDC
000004B4                           850mm 
000004B4                 FALSE     851mm     IFNE DEBUG
000004B4                           852mm     ENDC
000004B4                           853mm 
000004B4                           854mm     ENDM
000004B4  57CD FFDA                855m     DBEQ D5,LOOP_34
000004B8                           856m     ENDM
000004B8                           857      
000004B8                           858m     PRINT_CHAR #32,D3
000004B8                           859m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B8                 TRUE      860m     IFEQ DEBUG
000004B8  1639 00C00003            861m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004BE  0803 0002                862m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C2  67F4                     863m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004C4  13FC 0020 00C00007       864m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004CC                           865m     ENDC
000004CC                           866m 
000004CC                 FALSE     867m     IFNE DEBUG
000004CC                           868m     ENDC
000004CC                           869m 
000004CC                           870m     ENDM
000004CC                           871  
000004CC  E19A                     872      ROL.L #8,D2
000004CE                           873m     PRINT_CHAR D2,D3
000004CE                           874m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CE                 TRUE      875m     IFEQ DEBUG
000004CE  1639 00C00003            876m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004D4  0803 0002                877m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004D8  67F4                     878m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000004DA  13C2 00C00007            879m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E0                           880m     ENDC
000004E0                           881m 
000004E0                 FALSE     882m     IFNE DEBUG
000004E0                           883m     ENDC
000004E0                           884m 
000004E0                           885m     ENDM
000004E0  E19A                     886      ROL.L #8,D2
000004E2                           887m     PRINT_CHAR D2,D3
000004E2                           888m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E2                 TRUE      889m     IFEQ DEBUG
000004E2  1639 00C00003            890m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004E8  0803 0002                891m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004EC  67F4                     892m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000004EE  13C2 00C00007            893m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F4                           894m     ENDC
000004F4                           895m 
000004F4                 FALSE     896m     IFNE DEBUG
000004F4                           897m     ENDC
000004F4                           898m 
000004F4                           899m     ENDM
000004F4  E19A                     900      ROL.L #8,D2
000004F6                           901m     PRINT_CHAR D2,D3
000004F6                           902m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F6                 TRUE      903m     IFEQ DEBUG
000004F6  1639 00C00003            904m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004FC  0803 0002                905m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000500  67F4                     906m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000502  13C2 00C00007            907m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000508                           908m     ENDC
00000508                           909m 
00000508                 FALSE     910m     IFNE DEBUG
00000508                           911m     ENDC
00000508                           912m 
00000508                           913m     ENDM
00000508  E19A                     914      ROL.L #8,D2
0000050A                           915m     PRINT_CHAR D2,D3
0000050A                           916m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      917m     IFEQ DEBUG
0000050A  1639 00C00003            918m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000510  0803 0002                919m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000514  67F4                     920m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000516  13C2 00C00007            921m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000051C                           922m     ENDC
0000051C                           923m 
0000051C                 FALSE     924m     IFNE DEBUG
0000051C                           925m     ENDC
0000051C                           926m 
0000051C                           927m     ENDM
0000051C                           928  
0000051C                           929m     PRINT_CRLF D3,A0
0000051C  41FA 12A0                930m     LEA CRLF(PC),A0
00000520                           931mm     PRINT_STR A0,D3
00000520                           932mm LOOP_45
00000520  0C10 0000                933mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000524  6700 0016                934mm     BEQ EXIT_45
00000528                           935mmm     PRINT_CHAR (A0)+,D3
00000528                           936mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000528                 TRUE      937mmm     IFEQ DEBUG
00000528  1639 00C00003            938mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052E  0803 0002                939mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000532  67F4                     940mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000534  13D8 00C00007            941mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000053A                           942mmm     ENDC
0000053A                           943mmm 
0000053A                 FALSE     944mmm     IFNE DEBUG
0000053A                           945mmm     ENDC
0000053A                           946mmm 
0000053A                           947mmm     ENDM
0000053A  60E4                     948mm     BRA LOOP_45
0000053C                           949mm EXIT_45
0000053C                           950mm     ENDM
0000053C                           951m     ENDM
0000053C                           952      
0000053C  6000 FDDE                953      BRA MAIN_LOOP
00000540                           954  
00000540                           955  W
00000540                           956      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000540  3C3C 0000                957s     MOVE.W  #0,D6
00000544  6000 0046                958s     BRA _20000005
00000548                           959s _20000004
00000548  E98D                     960          LSL.L #4,D5                                     ; make what we have so far more significant
0000054A                           961m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000054A                           962m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054A                 TRUE      963m     IFEQ DEBUG
0000054A  1639 00C00003            964m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000550  0803 0000                965m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000554  67F4                     966m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000556                           967m     ENDC
00000556                           968m 
00000556                           969mm     READ_CHAR D2
00000556                 TRUE      970mm     IFEQ DEBUG
00000556  1439 00C00007            971mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000055C                           972mm     ENDC
0000055C                 FALSE     973mm     IFNE DEBUG
0000055C                           974mm     ENDC
0000055C                           975mm 
0000055C  B43C 001B                976mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000560  6700 FBA2                977mm     BEQ START
00000564                           978mm     ENDM
00000564                           979m 
00000564                 TRUE      980m     IFEQ DEBUG
00000564                           981mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000564                           982mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                 TRUE      983mm     IFEQ DEBUG
00000564  1639 00C00003            984mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000056A  0803 0002                985mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000056E  67F4                     986mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
00000570  13C2 00C00007            987mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000576                           988mm     ENDC
00000576                           989mm 
00000576                 FALSE     990mm     IFNE DEBUG
00000576                           991mm     ENDC
00000576                           992mm 
00000576                           993mm     ENDM
00000576                           994m     ENDC
00000576                           995m     ENDM
00000576                           996m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000576  41FA 121B                997m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000057A  0402 0030                998m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057E  C4BC 000000FF            999m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000584  1430 2000               1000m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000588                          1001m     ENDM
00000588  8A02                    1002          OR.B D2,D5
0000058A                          1003      ENDF
0000058A  5246                    1004s     ADD.W   #1,D6
0000058C                          1005s _20000005
0000058C  BC7C 0007               1006s     CMP.W   #7,D6
00000590  6FB6                    1007s     BLE _20000004
00000592                          1008  
00000592                          1009m     PRINT_CRLF D3,A0
00000592  41FA 122A               1010m     LEA CRLF(PC),A0
00000596                          1011mm     PRINT_STR A0,D3
00000596                          1012mm LOOP_52
00000596  0C10 0000               1013mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000059A  6700 0016               1014mm     BEQ EXIT_52
0000059E                          1015mmm     PRINT_CHAR (A0)+,D3
0000059E                          1016mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059E                 TRUE     1017mmm     IFEQ DEBUG
0000059E  1639 00C00003           1018mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005A4  0803 0002               1019mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005A8  67F4                    1020mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005AA  13D8 00C00007           1021mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005B0                          1022mmm     ENDC
000005B0                          1023mmm 
000005B0                 FALSE    1024mmm     IFNE DEBUG
000005B0                          1025mmm     ENDC
000005B0                          1026mmm 
000005B0                          1027mmm     ENDM
000005B0  60E4                    1028mm     BRA LOOP_52
000005B2                          1029mm EXIT_52
000005B2                          1030mm     ENDM
000005B2                          1031m     ENDM
000005B2                          1032  
000005B2  2047                    1033      MOVE.L D7,A0                                    ; address accumulator -> address register
000005B4  7E00                    1034      MOVE.L #0,D7                                    ; clear the now used address accumulator
000005B6                          1035  
000005B6  2085                    1036      MOVE.L D5,(A0)                                  ; write the data
000005B8                          1037  
000005B8  6000 FD62               1038      BRA MAIN_LOOP
000005BC                          1039  
000005BC                          1040  ; register map for S
000005BC                          1041  ; A0 - start address
000005BC                          1042  ; A1 - offset
000005BC                          1043  ; A2 - next address to write
000005BC                          1044  ; A3 - next location (jmp)
000005BC                          1045  ; A4 - Working Address Register
000005BC                          1046  ; D0 - record count
000005BC                          1047  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005BC                          1048  ; D2 - checksum
000005BC                          1049  ; D3 - data byte count
000005BC                          1050  ; D4 - read address, moved into A2
000005BC                          1051  ; D5 - temp
000005BC                          1052  ; D6 - temp
000005BC                          1053  ; D7 - temp
000005BC                          1054  S
000005BC  2078 0000               1055      MOVE.L 0,A0                                     ; start address -> A0
000005C0  2247                    1056      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005C2                          1057      
000005C2  7000                    1058      MOVE.L #0,D0                                    ; count of records read -> D0
000005C4                          1059          
000005C4                          1060  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005C4                          1061m     DOWNLOAD D1
000005C4                          1062m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005C4                          1063m 
000005C4  1239 00C00003           1064m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005CA  0801 0000               1065m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005CE  6700 0010               1066m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
000005D2                          1067m 
000005D2                          1068mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000005D2                 TRUE     1069mm     IFEQ DEBUG
000005D2  1239 00C00007           1070mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000005D8                          1071mm     ENDC
000005D8                 FALSE    1072mm     IFNE DEBUG
000005D8                          1073mm     ENDC
000005D8                          1074mm 
000005D8  B23C 001B               1075mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000005DC  6700 FB26               1076mm     BEQ START
000005E0                          1077mm     ENDM
000005E0                          1078m CONTINUE_54
000005E0  1239 00C00013           1079m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000005E6  0801 0000               1080m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005EA  67D8                    1081m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000005EC                          1082m     
000005EC  1239 00C00017           1083m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000005F2  13C1 00E00001           1084m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000005F8                          1085m 
000005F8                          1086m     ENDM
000005F8  B23C 0053               1087      CMP.B #'S',D1                                   ; found S?
000005FC  66C6                    1088      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000005FE                          1089      
000005FE                          1090m     PRINT_CHAR #'S',D5                              ; print the S
000005FE                          1091m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005FE                 TRUE     1092m     IFEQ DEBUG
000005FE  1A39 00C00003           1093m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000604  0805 0002               1094m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000608  67F4                    1095m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000060A  13FC 0053 00C00007      1096m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000612                          1097m     ENDC
00000612                          1098m 
00000612                 FALSE    1099m     IFNE DEBUG
00000612                          1100m     ENDC
00000612                          1101m 
00000612                          1102m     ENDM
00000612  5280                    1103      ADD.L #1,D0                                     ; read another S record, increment count
00000614                          1104      
00000614                          1105m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000614                          1106m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000614                          1107m 
00000614  1239 00C00003           1108m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000061A  0801 0000               1109m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061E  6700 0010               1110m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000622                          1111m 
00000622                          1112mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000622                 TRUE     1113mm     IFEQ DEBUG
00000622  1239 00C00007           1114mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000628                          1115mm     ENDC
00000628                 FALSE    1116mm     IFNE DEBUG
00000628                          1117mm     ENDC
00000628                          1118mm 
00000628  B23C 001B               1119mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000062C  6700 FAD6               1120mm     BEQ START
00000630                          1121mm     ENDM
00000630                          1122m CONTINUE_57
00000630  1239 00C00013           1123m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000636  0801 0000               1124m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000063A  67D8                    1125m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000063C                          1126m     
0000063C  1239 00C00017           1127m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000642  13C1 00E00001           1128m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000648                          1129m 
00000648                          1130m     ENDM
00000648                          1131m     PRINT_CHAR D1,D5
00000648                          1132m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000648                 TRUE     1133m     IFEQ DEBUG
00000648  1A39 00C00003           1134m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000064E  0805 0002               1135m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000652  67F4                    1136m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000654  13C1 00C00007           1137m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000065A                          1138m     ENDC
0000065A                          1139m 
0000065A                 FALSE    1140m     IFNE DEBUG
0000065A                          1141m     ENDC
0000065A                          1142m 
0000065A                          1143m     ENDM
0000065A                          1144  
0000065A  7400                    1145      MOVE.L #0,D2                                    ; clear the checksum
0000065C                          1146  
0000065C                          1147m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000065C  1E3C 0002               1148m     MOVE.B #2,D7
00000660                          1149m     WHILE.B D7 <GT> 0 DO
00000660                          1150ms _10000000
00000660  BE38 0000               1151ms     CMP.B   0,D7
00000664  6F00 0062               1152ms     BLE _10000001
00000668  E98B                    1153m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000066A                          1154mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000066A                          1155mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000066A                          1156mm 
0000066A  1A39 00C00003           1157mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000670  0805 0000               1158mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000674  6700 0010               1159mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000678                          1160mm 
00000678                          1161mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000678                 TRUE     1162mmm     IFEQ DEBUG
00000678  1A39 00C00007           1163mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000067E                          1164mmm     ENDC
0000067E                 FALSE    1165mmm     IFNE DEBUG
0000067E                          1166mmm     ENDC
0000067E                          1167mmm 
0000067E  BA3C 001B               1168mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000682  6700 FA80               1169mmm     BEQ START
00000686                          1170mmm     ENDM
00000686                          1171mm CONTINUE_61
00000686  1A39 00C00013           1172mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000068C  0805 0000               1173mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000690  67D8                    1174mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000692                          1175mm     
00000692  1A39 00C00017           1176mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000698  13C5 00E00001           1177mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000069E                          1178mm 
0000069E                          1179mm     ENDM
0000069E                          1180mm         PRINT_CHAR D5,D6
0000069E                          1181mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069E                 TRUE     1182mm     IFEQ DEBUG
0000069E  1C39 00C00003           1183mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006A4  0806 0002               1184mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006A8  67F4                    1185mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006AA  13C5 00C00007           1186mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006B0                          1187mm     ENDC
000006B0                          1188mm 
000006B0                 FALSE    1189mm     IFNE DEBUG
000006B0                          1190mm     ENDC
000006B0                          1191mm 
000006B0                          1192mm     ENDM
000006B0                          1193mm         HEX2BIN D5,D5,A4
000006B0  49FA 10E1               1194mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006B4  0405 0030               1195mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B8  CABC 000000FF           1196mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006BE  1A34 5000               1197mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006C2                          1198mm     ENDM
000006C2  8605                    1199m         OR.B D5,D3
000006C4  5307                    1200m         SUB.B #1,D7
000006C6                          1201m     ENDW
000006C6  6098                    1202ms     BRA _10000000
000006C8                          1203ms _10000001
000006C8                          1204m 
000006C8  7A00                    1205m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006CA  1A03                    1206m     MOVE.B D3,D5
000006CC  D483                    1207m     ADD.L D3,D2
000006CE                          1208m 
000006CE                          1209m     ENDM
000006CE                          1210  
000006CE                          1211      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006CE  B23C 0030               1212s     CMP.B   #'0',D1
000006D2  6600 002A               1213s     BNE.L   _00000003
000006D6                          1214m         PRINT_CRLF D5,A4
000006D6  49FA 10E6               1215m     LEA CRLF(PC),A4
000006DA                          1216mm     PRINT_STR A4,D5
000006DA                          1217mm LOOP_66
000006DA  0C14 0000               1218mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000006DE  6700 0016               1219mm     BEQ EXIT_66
000006E2                          1220mmm     PRINT_CHAR (A4)+,D5
000006E2                          1221mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E2                 TRUE     1222mmm     IFEQ DEBUG
000006E2  1A39 00C00003           1223mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000006E8  0805 0002               1224mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000006EC  67F4                    1225mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000006EE  13DC 00C00007           1226mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000006F4                          1227mmm     ENDC
000006F4                          1228mmm 
000006F4                 FALSE    1229mmm     IFNE DEBUG
000006F4                          1230mmm     ENDC
000006F4                          1231mmm 
000006F4                          1232mmm     ENDM
000006F4  60E4                    1233mm     BRA LOOP_66
000006F6                          1234mm EXIT_66
000006F6                          1235mm     ENDM
000006F6                          1236m     ENDM
000006F6  6000 FECC               1237          BRA WAIT_FOR_SRECORD
000006FA                          1238      ELSE
000006FA  6000 03DE               1239s     BRA _00000004
000006FE                          1240s _00000003
000006FE                          1241          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006FE  B23C 0031               1242s     CMP.B   #'1',D1
00000702  6708                    1243s     BEQ.S   _00000005
00000704  B23C 0032               1244s     CMP.B   #'2',D1
00000708  6600 01F0               1245s     BNE.L   _00000006
0000070C                          1246s _00000005
0000070C  5783                    1247              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000070E                          1248  
0000070E  7800                    1249              MOVE.L #0,D4                            ; read two bytes of address
00000710                          1250m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000710  1E3C 0002               1251m     MOVE.B #2,D7
00000714                          1252m     WHILE.B D7 <GT> 0 DO
00000714                          1253ms _10000002
00000714  BE38 0000               1254ms     CMP.B   0,D7
00000718  6F00 0062               1255ms     BLE _10000003
0000071C  E98C                    1256m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000071E                          1257mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000071E                          1258mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071E                          1259mm 
0000071E  1A39 00C00003           1260mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000724  0805 0000               1261mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000728  6700 0010               1262mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
0000072C                          1263mm 
0000072C                          1264mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000072C                 TRUE     1265mmm     IFEQ DEBUG
0000072C  1A39 00C00007           1266mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000732                          1267mmm     ENDC
00000732                 FALSE    1268mmm     IFNE DEBUG
00000732                          1269mmm     ENDC
00000732                          1270mmm 
00000732  BA3C 001B               1271mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000736  6700 F9CC               1272mmm     BEQ START
0000073A                          1273mmm     ENDM
0000073A                          1274mm CONTINUE_69
0000073A  1A39 00C00013           1275mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000740  0805 0000               1276mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000744  67D8                    1277mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000746                          1278mm     
00000746  1A39 00C00017           1279mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000074C  13C5 00E00001           1280mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000752                          1281mm 
00000752                          1282mm     ENDM
00000752                          1283mm         PRINT_CHAR D5,D6
00000752                          1284mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000752                 TRUE     1285mm     IFEQ DEBUG
00000752  1C39 00C00003           1286mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000758  0806 0002               1287mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000075C  67F4                    1288mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000075E  13C5 00C00007           1289mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000764                          1290mm     ENDC
00000764                          1291mm 
00000764                 FALSE    1292mm     IFNE DEBUG
00000764                          1293mm     ENDC
00000764                          1294mm 
00000764                          1295mm     ENDM
00000764                          1296mm         HEX2BIN D5,D5,A4
00000764  49FA 102D               1297mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000768  0405 0030               1298mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000076C  CABC 000000FF           1299mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000772  1A34 5000               1300mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000776                          1301mm     ENDM
00000776  8805                    1302m         OR.B D5,D4
00000778  5307                    1303m         SUB.B #1,D7
0000077A                          1304m     ENDW
0000077A  6098                    1305ms     BRA _10000002
0000077C                          1306ms _10000003
0000077C                          1307m 
0000077C  7A00                    1308m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000077E  1A04                    1309m     MOVE.B D4,D5
00000780  D484                    1310m     ADD.L D4,D2
00000782                          1311m 
00000782                          1312m     ENDM
00000782                          1313m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000782  1E3C 0002               1314m     MOVE.B #2,D7
00000786                          1315m     WHILE.B D7 <GT> 0 DO
00000786                          1316ms _10000004
00000786  BE38 0000               1317ms     CMP.B   0,D7
0000078A  6F00 0062               1318ms     BLE _10000005
0000078E  E98C                    1319m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000790                          1320mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000790                          1321mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000790                          1322mm 
00000790  1A39 00C00003           1323mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000796  0805 0000               1324mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000079A  6700 0010               1325mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
0000079E                          1326mm 
0000079E                          1327mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000079E                 TRUE     1328mmm     IFEQ DEBUG
0000079E  1A39 00C00007           1329mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007A4                          1330mmm     ENDC
000007A4                 FALSE    1331mmm     IFNE DEBUG
000007A4                          1332mmm     ENDC
000007A4                          1333mmm 
000007A4  BA3C 001B               1334mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007A8  6700 F95A               1335mmm     BEQ START
000007AC                          1336mmm     ENDM
000007AC                          1337mm CONTINUE_74
000007AC  1A39 00C00013           1338mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007B2  0805 0000               1339mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007B6  67D8                    1340mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000007B8                          1341mm     
000007B8  1A39 00C00017           1342mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007BE  13C5 00E00001           1343mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007C4                          1344mm 
000007C4                          1345mm     ENDM
000007C4                          1346mm         PRINT_CHAR D5,D6
000007C4                          1347mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C4                 TRUE     1348mm     IFEQ DEBUG
000007C4  1C39 00C00003           1349mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007CA  0806 0002               1350mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007CE  67F4                    1351mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
000007D0  13C5 00C00007           1352mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007D6                          1353mm     ENDC
000007D6                          1354mm 
000007D6                 FALSE    1355mm     IFNE DEBUG
000007D6                          1356mm     ENDC
000007D6                          1357mm 
000007D6                          1358mm     ENDM
000007D6                          1359mm         HEX2BIN D5,D5,A4
000007D6  49FA 0FBB               1360mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007DA  0405 0030               1361mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007DE  CABC 000000FF           1362mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007E4  1A34 5000               1363mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007E8                          1364mm     ENDM
000007E8  8805                    1365m         OR.B D5,D4
000007EA  5307                    1366m         SUB.B #1,D7
000007EC                          1367m     ENDW
000007EC  6098                    1368ms     BRA _10000004
000007EE                          1369ms _10000005
000007EE                          1370m 
000007EE  7A00                    1371m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007F0  1A04                    1372m     MOVE.B D4,D5
000007F2  D484                    1373m     ADD.L D4,D2
000007F4                          1374m 
000007F4                          1375m     ENDM
000007F4                          1376  
000007F4                          1377              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000007F4  B23C 0032               1378s     CMP.B   #'2',D1
000007F8  6600 0076               1379s     BNE.L   _00000007
000007FC  5383                    1380                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000007FE                          1381m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000007FE  1E3C 0002               1382m     MOVE.B #2,D7
00000802                          1383m     WHILE.B D7 <GT> 0 DO
00000802                          1384ms _10000006
00000802  BE38 0000               1385ms     CMP.B   0,D7
00000806  6F00 0062               1386ms     BLE _10000007
0000080A  E98C                    1387m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000080C                          1388mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000080C                          1389mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080C                          1390mm 
0000080C  1A39 00C00003           1391mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000812  0805 0000               1392mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000816  6700 0010               1393mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000081A                          1394mm 
0000081A                          1395mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000081A                 TRUE     1396mmm     IFEQ DEBUG
0000081A  1A39 00C00007           1397mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000820                          1398mmm     ENDC
00000820                 FALSE    1399mmm     IFNE DEBUG
00000820                          1400mmm     ENDC
00000820                          1401mmm 
00000820  BA3C 001B               1402mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000824  6700 F8DE               1403mmm     BEQ START
00000828                          1404mmm     ENDM
00000828                          1405mm CONTINUE_79
00000828  1A39 00C00013           1406mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000082E  0805 0000               1407mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000832  67D8                    1408mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000834                          1409mm     
00000834  1A39 00C00017           1410mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000083A  13C5 00E00001           1411mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000840                          1412mm 
00000840                          1413mm     ENDM
00000840                          1414mm         PRINT_CHAR D5,D6
00000840                          1415mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                 TRUE     1416mm     IFEQ DEBUG
00000840  1C39 00C00003           1417mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000846  0806 0002               1418mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000084A  67F4                    1419mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
0000084C  13C5 00C00007           1420mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000852                          1421mm     ENDC
00000852                          1422mm 
00000852                 FALSE    1423mm     IFNE DEBUG
00000852                          1424mm     ENDC
00000852                          1425mm 
00000852                          1426mm     ENDM
00000852                          1427mm         HEX2BIN D5,D5,A4
00000852  49FA 0F3F               1428mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000856  0405 0030               1429mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000085A  CABC 000000FF           1430mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000860  1A34 5000               1431mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000864                          1432mm     ENDM
00000864  8805                    1433m         OR.B D5,D4
00000866  5307                    1434m         SUB.B #1,D7
00000868                          1435m     ENDW
00000868  6098                    1436ms     BRA _10000006
0000086A                          1437ms _10000007
0000086A                          1438m 
0000086A  7A00                    1439m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000086C  1A04                    1440m     MOVE.B D4,D5
0000086E  D484                    1441m     ADD.L D4,D2
00000870                          1442m 
00000870                          1443m     ENDM
00000870                          1444              ENDI
00000870                          1445s _00000007
00000870                          1446  
00000870  2444                    1447              MOVE.L D4,A2                            ; put the address in an address register
00000872  D5C9                    1448              ADD.L A1,A2                             ; add in the offset
00000874                          1449  
00000874                          1450              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000874                          1451s _10000008
00000874  B63C 0000               1452s     CMP.B   #0,D3
00000878  6F00 007A               1453s     BLE _10000009
0000087C                          1454m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
0000087C  1E3C 0002               1455m     MOVE.B #2,D7
00000880                          1456m     WHILE.B D7 <GT> 0 DO
00000880                          1457ms _1000000A
00000880  BE38 0000               1458ms     CMP.B   0,D7
00000884  6F00 0062               1459ms     BLE _1000000B
00000888  E989                    1460m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
0000088A                          1461mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000088A                          1462mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088A                          1463mm 
0000088A  1A39 00C00003           1464mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000890  0805 0000               1465mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000894  6700 0010               1466mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000898                          1467mm 
00000898                          1468mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000898                 TRUE     1469mmm     IFEQ DEBUG
00000898  1A39 00C00007           1470mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000089E                          1471mmm     ENDC
0000089E                 FALSE    1472mmm     IFNE DEBUG
0000089E                          1473mmm     ENDC
0000089E                          1474mmm 
0000089E  BA3C 001B               1475mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008A2  6700 F860               1476mmm     BEQ START
000008A6                          1477mmm     ENDM
000008A6                          1478mm CONTINUE_84
000008A6  1A39 00C00013           1479mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008AC  0805 0000               1480mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008B0  67D8                    1481mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000008B2                          1482mm     
000008B2  1A39 00C00017           1483mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008B8  13C5 00E00001           1484mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008BE                          1485mm 
000008BE                          1486mm     ENDM
000008BE                          1487mm         PRINT_CHAR D5,D6
000008BE                          1488mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BE                 TRUE     1489mm     IFEQ DEBUG
000008BE  1C39 00C00003           1490mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008C4  0806 0002               1491mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008C8  67F4                    1492mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
000008CA  13C5 00C00007           1493mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008D0                          1494mm     ENDC
000008D0                          1495mm 
000008D0                 FALSE    1496mm     IFNE DEBUG
000008D0                          1497mm     ENDC
000008D0                          1498mm 
000008D0                          1499mm     ENDM
000008D0                          1500mm         HEX2BIN D5,D5,A4
000008D0  49FA 0EC1               1501mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008D4  0405 0030               1502mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D8  CABC 000000FF           1503mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008DE  1A34 5000               1504mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008E2                          1505mm     ENDM
000008E2  8205                    1506m         OR.B D5,D1
000008E4  5307                    1507m         SUB.B #1,D7
000008E6                          1508m     ENDW
000008E6  6098                    1509ms     BRA _1000000A
000008E8                          1510ms _1000000B
000008E8                          1511m 
000008E8  7A00                    1512m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008EA  1A01                    1513m     MOVE.B D1,D5
000008EC  D481                    1514m     ADD.L D1,D2
000008EE                          1515m 
000008EE                          1516m     ENDM
000008EE                          1517   
000008EE  14C1                    1518                  MOVE.B D1,(A2)+                     ; store it!
000008F0                          1519  
000008F0  5303                    1520                  SUB.B #1,D3                         ; 1 less byte to go
000008F2                          1521              ENDW
000008F2  6080                    1522s     BRA _10000008
000008F4                          1523s _10000009
000008F4                          1524  
000008F4  7200                    1525              MOVE.L #0,D1                            ; not done yet
000008F6                          1526          ELSE
000008F6  6000 01E2               1527s     BRA _00000008
000008FA                          1528s _00000006
000008FA                          1529              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000008FA  B23C 0038               1530s     CMP.B   #'8',D1
000008FE  6600 0164               1531s     BNE.L   _00000009
00000902  7800                    1532                  MOVE.L #0,D4                        ; read the 24 bit start address
00000904                          1533m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000904  1E3C 0002               1534m     MOVE.B #2,D7
00000908                          1535m     WHILE.B D7 <GT> 0 DO
00000908                          1536ms _1000000C
00000908  BE38 0000               1537ms     CMP.B   0,D7
0000090C  6F00 0062               1538ms     BLE _1000000D
00000910  E98C                    1539m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000912                          1540mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000912                          1541mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000912                          1542mm 
00000912  1A39 00C00003           1543mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000918  0805 0000               1544mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000091C  6700 0010               1545mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000920                          1546mm 
00000920                          1547mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000920                 TRUE     1548mmm     IFEQ DEBUG
00000920  1A39 00C00007           1549mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000926                          1550mmm     ENDC
00000926                 FALSE    1551mmm     IFNE DEBUG
00000926                          1552mmm     ENDC
00000926                          1553mmm 
00000926  BA3C 001B               1554mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000092A  6700 F7D8               1555mmm     BEQ START
0000092E                          1556mmm     ENDM
0000092E                          1557mm CONTINUE_89
0000092E  1A39 00C00013           1558mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000934  0805 0000               1559mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000938  67D8                    1560mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
0000093A                          1561mm     
0000093A  1A39 00C00017           1562mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000940  13C5 00E00001           1563mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000946                          1564mm 
00000946                          1565mm     ENDM
00000946                          1566mm         PRINT_CHAR D5,D6
00000946                          1567mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000946                 TRUE     1568mm     IFEQ DEBUG
00000946  1C39 00C00003           1569mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000094C  0806 0002               1570mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000950  67F4                    1571mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000952  13C5 00C00007           1572mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000958                          1573mm     ENDC
00000958                          1574mm 
00000958                 FALSE    1575mm     IFNE DEBUG
00000958                          1576mm     ENDC
00000958                          1577mm 
00000958                          1578mm     ENDM
00000958                          1579mm         HEX2BIN D5,D5,A4
00000958  49FA 0E39               1580mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000095C  0405 0030               1581mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000960  CABC 000000FF           1582mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000966  1A34 5000               1583mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000096A                          1584mm     ENDM
0000096A  8805                    1585m         OR.B D5,D4
0000096C  5307                    1586m         SUB.B #1,D7
0000096E                          1587m     ENDW
0000096E  6098                    1588ms     BRA _1000000C
00000970                          1589ms _1000000D
00000970                          1590m 
00000970  7A00                    1591m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000972  1A04                    1592m     MOVE.B D4,D5
00000974  D484                    1593m     ADD.L D4,D2
00000976                          1594m 
00000976                          1595m     ENDM
00000976                          1596m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000976  1E3C 0002               1597m     MOVE.B #2,D7
0000097A                          1598m     WHILE.B D7 <GT> 0 DO
0000097A                          1599ms _1000000E
0000097A  BE38 0000               1600ms     CMP.B   0,D7
0000097E  6F00 0062               1601ms     BLE _1000000F
00000982  E98C                    1602m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000984                          1603mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000984                          1604mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000984                          1605mm 
00000984  1A39 00C00003           1606mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000098A  0805 0000               1607mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000098E  6700 0010               1608mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
00000992                          1609mm 
00000992                          1610mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000992                 TRUE     1611mmm     IFEQ DEBUG
00000992  1A39 00C00007           1612mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000998                          1613mmm     ENDC
00000998                 FALSE    1614mmm     IFNE DEBUG
00000998                          1615mmm     ENDC
00000998                          1616mmm 
00000998  BA3C 001B               1617mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000099C  6700 F766               1618mmm     BEQ START
000009A0                          1619mmm     ENDM
000009A0                          1620mm CONTINUE_94
000009A0  1A39 00C00013           1621mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009A6  0805 0000               1622mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009AA  67D8                    1623mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
000009AC                          1624mm     
000009AC  1A39 00C00017           1625mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009B2  13C5 00E00001           1626mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009B8                          1627mm 
000009B8                          1628mm     ENDM
000009B8                          1629mm         PRINT_CHAR D5,D6
000009B8                          1630mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B8                 TRUE     1631mm     IFEQ DEBUG
000009B8  1C39 00C00003           1632mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009BE  0806 0002               1633mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009C2  67F4                    1634mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000009C4  13C5 00C00007           1635mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009CA                          1636mm     ENDC
000009CA                          1637mm 
000009CA                 FALSE    1638mm     IFNE DEBUG
000009CA                          1639mm     ENDC
000009CA                          1640mm 
000009CA                          1641mm     ENDM
000009CA                          1642mm         HEX2BIN D5,D5,A4
000009CA  49FA 0DC7               1643mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009CE  0405 0030               1644mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009D2  CABC 000000FF           1645mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009D8  1A34 5000               1646mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009DC                          1647mm     ENDM
000009DC  8805                    1648m         OR.B D5,D4
000009DE  5307                    1649m         SUB.B #1,D7
000009E0                          1650m     ENDW
000009E0  6098                    1651ms     BRA _1000000E
000009E2                          1652ms _1000000F
000009E2                          1653m 
000009E2  7A00                    1654m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009E4  1A04                    1655m     MOVE.B D4,D5
000009E6  D484                    1656m     ADD.L D4,D2
000009E8                          1657m 
000009E8                          1658m     ENDM
000009E8                          1659m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000009E8  1E3C 0002               1660m     MOVE.B #2,D7
000009EC                          1661m     WHILE.B D7 <GT> 0 DO
000009EC                          1662ms _10000010
000009EC  BE38 0000               1663ms     CMP.B   0,D7
000009F0  6F00 0062               1664ms     BLE _10000011
000009F4  E98C                    1665m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009F6                          1666mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009F6                          1667mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F6                          1668mm 
000009F6  1A39 00C00003           1669mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009FC  0805 0000               1670mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A00  6700 0010               1671mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000A04                          1672mm 
00000A04                          1673mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A04                 TRUE     1674mmm     IFEQ DEBUG
00000A04  1A39 00C00007           1675mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A0A                          1676mmm     ENDC
00000A0A                 FALSE    1677mmm     IFNE DEBUG
00000A0A                          1678mmm     ENDC
00000A0A                          1679mmm 
00000A0A  BA3C 001B               1680mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A0E  6700 F6F4               1681mmm     BEQ START
00000A12                          1682mmm     ENDM
00000A12                          1683mm CONTINUE_99
00000A12  1A39 00C00013           1684mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A18  0805 0000               1685mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A1C  67D8                    1686mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000A1E                          1687mm     
00000A1E  1A39 00C00017           1688mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A24  13C5 00E00001           1689mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A2A                          1690mm 
00000A2A                          1691mm     ENDM
00000A2A                          1692mm         PRINT_CHAR D5,D6
00000A2A                          1693mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2A                 TRUE     1694mm     IFEQ DEBUG
00000A2A  1C39 00C00003           1695mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A30  0806 0002               1696mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A34  67F4                    1697mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000A36  13C5 00C00007           1698mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A3C                          1699mm     ENDC
00000A3C                          1700mm 
00000A3C                 FALSE    1701mm     IFNE DEBUG
00000A3C                          1702mm     ENDC
00000A3C                          1703mm 
00000A3C                          1704mm     ENDM
00000A3C                          1705mm         HEX2BIN D5,D5,A4
00000A3C  49FA 0D55               1706mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A40  0405 0030               1707mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A44  CABC 000000FF           1708mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A4A  1A34 5000               1709mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A4E                          1710mm     ENDM
00000A4E  8805                    1711m         OR.B D5,D4
00000A50  5307                    1712m         SUB.B #1,D7
00000A52                          1713m     ENDW
00000A52  6098                    1714ms     BRA _10000010
00000A54                          1715ms _10000011
00000A54                          1716m 
00000A54  7A00                    1717m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A56  1A04                    1718m     MOVE.B D4,D5
00000A58  D484                    1719m     ADD.L D4,D2
00000A5A                          1720m 
00000A5A                          1721m     ENDM
00000A5A                          1722  
00000A5A  2044                    1723                  MOVE.L D4,A0                        ; start address -> A0
00000A5C  D1C9                    1724                  ADD.L A1,A0                         ; add in the offset
00000A5E                          1725  
00000A5E  72FF                    1726                  MOVE.L #$FFFFFFFF,D1                ; done
00000A60                          1727              ELSE
00000A60  6000 0078               1728s     BRA _0000000A
00000A64                          1729s _00000009
00000A64                          1730m                 PRINT_CRLF D5,A4
00000A64  49FA 0D58               1731m     LEA CRLF(PC),A4
00000A68                          1732mm     PRINT_STR A4,D5
00000A68                          1733mm LOOP_104
00000A68  0C14 0000               1734mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A6C  6700 0016               1735mm     BEQ EXIT_104
00000A70                          1736mmm     PRINT_CHAR (A4)+,D5
00000A70                          1737mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A70                 TRUE     1738mmm     IFEQ DEBUG
00000A70  1A39 00C00003           1739mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A76  0805 0002               1740mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A7A  67F4                    1741mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A7C  13DC 00C00007           1742mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A82                          1743mmm     ENDC
00000A82                          1744mmm 
00000A82                 FALSE    1745mmm     IFNE DEBUG
00000A82                          1746mmm     ENDC
00000A82                          1747mmm 
00000A82                          1748mmm     ENDM
00000A82  60E4                    1749mm     BRA LOOP_104
00000A84                          1750mm EXIT_104
00000A84                          1751mm     ENDM
00000A84                          1752m     ENDM
00000A84                          1753  
00000A84  49FA 0CC4               1754                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000A88                          1755m                 PRINT_STR A4,D5
00000A88                          1756m LOOP_106
00000A88  0C14 0000               1757m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A8C  6700 0016               1758m     BEQ EXIT_106
00000A90                          1759mm     PRINT_CHAR (A4)+,D5
00000A90                          1760mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A90                 TRUE     1761mm     IFEQ DEBUG
00000A90  1A39 00C00003           1762mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A96  0805 0002               1763mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A9A  67F4                    1764mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000A9C  13DC 00C00007           1765mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AA2                          1766mm     ENDC
00000AA2                          1767mm 
00000AA2                 FALSE    1768mm     IFNE DEBUG
00000AA2                          1769mm     ENDC
00000AA2                          1770mm 
00000AA2                          1771mm     ENDM
00000AA2  60E4                    1772m     BRA LOOP_106
00000AA4                          1773m EXIT_106
00000AA4                          1774m     ENDM
00000AA4                          1775m                 PRINT_CHAR D1,D5
00000AA4                          1776m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA4                 TRUE     1777m     IFEQ DEBUG
00000AA4  1A39 00C00003           1778m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AAA  0805 0002               1779m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAE  67F4                    1780m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AB0  13C1 00C00007           1781m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AB6                          1782m     ENDC
00000AB6                          1783m 
00000AB6                 FALSE    1784m     IFNE DEBUG
00000AB6                          1785m     ENDC
00000AB6                          1786m 
00000AB6                          1787m     ENDM
00000AB6                          1788m                 PRINT_CRLF D5,A4
00000AB6  49FA 0D06               1789m     LEA CRLF(PC),A4
00000ABA                          1790mm     PRINT_STR A4,D5
00000ABA                          1791mm LOOP_110
00000ABA  0C14 0000               1792mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ABE  6700 0016               1793mm     BEQ EXIT_110
00000AC2                          1794mmm     PRINT_CHAR (A4)+,D5
00000AC2                          1795mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC2                 TRUE     1796mmm     IFEQ DEBUG
00000AC2  1A39 00C00003           1797mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC8  0805 0002               1798mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACC  67F4                    1799mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000ACE  13DC 00C00007           1800mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD4                          1801mmm     ENDC
00000AD4                          1802mmm 
00000AD4                 FALSE    1803mmm     IFNE DEBUG
00000AD4                          1804mmm     ENDC
00000AD4                          1805mmm 
00000AD4                          1806mmm     ENDM
00000AD4  60E4                    1807mm     BRA LOOP_110
00000AD6                          1808mm EXIT_110
00000AD6                          1809mm     ENDM
00000AD6                          1810m     ENDM
00000AD6                          1811  
00000AD6  6000 FAEC               1812                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000ADA                          1813              ENDI
00000ADA                          1814s _0000000A
00000ADA                          1815          ENDI
00000ADA                          1816s _00000008
00000ADA                          1817      ENDI
00000ADA                          1818s _00000004
00000ADA                          1819  
00000ADA                          1820m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000ADA  1E3C 0002               1821m     MOVE.B #2,D7
00000ADE                          1822m     WHILE.B D7 <GT> 0 DO
00000ADE                          1823ms _10000012
00000ADE  BE38 0000               1824ms     CMP.B   0,D7
00000AE2  6F00 0062               1825ms     BLE _10000013
00000AE6  E98C                    1826m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000AE8                          1827mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000AE8                          1828mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE8                          1829mm 
00000AE8  1A39 00C00003           1830mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000AEE  0805 0000               1831mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AF2  6700 0010               1832mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000AF6                          1833mm 
00000AF6                          1834mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AF6                 TRUE     1835mmm     IFEQ DEBUG
00000AF6  1A39 00C00007           1836mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000AFC                          1837mmm     ENDC
00000AFC                 FALSE    1838mmm     IFNE DEBUG
00000AFC                          1839mmm     ENDC
00000AFC                          1840mmm 
00000AFC  BA3C 001B               1841mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B00  6700 F602               1842mmm     BEQ START
00000B04                          1843mmm     ENDM
00000B04                          1844mm CONTINUE_113
00000B04  1A39 00C00013           1845mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B0A  0805 0000               1846mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B0E  67D8                    1847mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000B10                          1848mm     
00000B10  1A39 00C00017           1849mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B16  13C5 00E00001           1850mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B1C                          1851mm 
00000B1C                          1852mm     ENDM
00000B1C                          1853mm         PRINT_CHAR D5,D6
00000B1C                          1854mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1C                 TRUE     1855mm     IFEQ DEBUG
00000B1C  1C39 00C00003           1856mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B22  0806 0002               1857mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B26  67F4                    1858mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B28  13C5 00C00007           1859mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B2E                          1860mm     ENDC
00000B2E                          1861mm 
00000B2E                 FALSE    1862mm     IFNE DEBUG
00000B2E                          1863mm     ENDC
00000B2E                          1864mm 
00000B2E                          1865mm     ENDM
00000B2E                          1866mm         HEX2BIN D5,D5,A4
00000B2E  49FA 0C63               1867mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B32  0405 0030               1868mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B36  CABC 000000FF           1869mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B3C  1A34 5000               1870mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B40                          1871mm     ENDM
00000B40  8805                    1872m         OR.B D5,D4
00000B42  5307                    1873m         SUB.B #1,D7
00000B44                          1874m     ENDW
00000B44  6098                    1875ms     BRA _10000012
00000B46                          1876ms _10000013
00000B46                          1877m 
00000B46  7A00                    1878m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B48  1A04                    1879m     MOVE.B D4,D5
00000B4A  D484                    1880m     ADD.L D4,D2
00000B4C                          1881m 
00000B4C                          1882m     ENDM
00000B4C                          1883m     PRINT_CRLF D5,A4
00000B4C  49FA 0C70               1884m     LEA CRLF(PC),A4
00000B50                          1885mm     PRINT_STR A4,D5
00000B50                          1886mm LOOP_118
00000B50  0C14 0000               1887mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B54  6700 0016               1888mm     BEQ EXIT_118
00000B58                          1889mmm     PRINT_CHAR (A4)+,D5
00000B58                          1890mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B58                 TRUE     1891mmm     IFEQ DEBUG
00000B58  1A39 00C00003           1892mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B5E  0805 0002               1893mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B62  67F4                    1894mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B64  13DC 00C00007           1895mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B6A                          1896mmm     ENDC
00000B6A                          1897mmm 
00000B6A                 FALSE    1898mmm     IFNE DEBUG
00000B6A                          1899mmm     ENDC
00000B6A                          1900mmm 
00000B6A                          1901mmm     ENDM
00000B6A  60E4                    1902mm     BRA LOOP_118
00000B6C                          1903mm EXIT_118
00000B6C                          1904mm     ENDM
00000B6C                          1905m     ENDM
00000B6C                          1906  
00000B6C                          1907      IF.B D2 <NE> #$FF THEN.L
00000B6C  B43C 00FF               1908s     CMP.B   #$FF,D2
00000B70  6700 0090               1909s     BEQ.L   _0000000B
00000B74  49FA 0BEB               1910          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000B78                          1911m         PRINT_STR A4,D5
00000B78                          1912m LOOP_120
00000B78  0C14 0000               1913m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B7C  6700 0016               1914m     BEQ EXIT_120
00000B80                          1915mm     PRINT_CHAR (A4)+,D5
00000B80                          1916mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B80                 TRUE     1917mm     IFEQ DEBUG
00000B80  1A39 00C00003           1918mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B86  0805 0002               1919mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B8A  67F4                    1920mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B8C  13DC 00C00007           1921mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B92                          1922mm     ENDC
00000B92                          1923mm 
00000B92                 FALSE    1924mm     IFNE DEBUG
00000B92                          1925mm     ENDC
00000B92                          1926mm 
00000B92                          1927mm     ENDM
00000B92  60E4                    1928m     BRA LOOP_120
00000B94                          1929m EXIT_120
00000B94                          1930m     ENDM
00000B94                          1931m         PRINT_REG D0,D5,D3,D6,A4
00000B94  49FA 0C2E               1932m     LEA OX(PC),A4
00000B98                          1933mm     PRINT_STR A4,D5
00000B98                          1934mm LOOP_123
00000B98  0C14 0000               1935mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B9C  6700 0016               1936mm     BEQ EXIT_123
00000BA0                          1937mmm     PRINT_CHAR (A4)+,D5
00000BA0                          1938mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA0                 TRUE     1939mmm     IFEQ DEBUG
00000BA0  1A39 00C00003           1940mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BA6  0805 0002               1941mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BAA  67F4                    1942mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BAC  13DC 00C00007           1943mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BB2                          1944mmm     ENDC
00000BB2                          1945mmm 
00000BB2                 FALSE    1946mmm     IFNE DEBUG
00000BB2                          1947mmm     ENDC
00000BB2                          1948mmm 
00000BB2                          1949mmm     ENDM
00000BB2  60E4                    1950mm     BRA LOOP_123
00000BB4                          1951mm EXIT_123
00000BB4                          1952mm     ENDM
00000BB4  7C07                    1953m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BB6                          1954m LOOP_122
00000BB6                          1955mm     BIN2HEX D0,D3,A4
00000BB6  49FA 0BCB               1956mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000BBA  E998                    1957mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BBC  1600                    1958mm     MOVE.B D0,D3
00000BBE  0283 0000000F           1959mm     ANDI.L #$F,D3
00000BC4  1634 3000               1960mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000BC8                          1961mm     ENDM
00000BC8                          1962mm     PRINT_CHAR D3,D5
00000BC8                          1963mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     1964mm     IFEQ DEBUG
00000BC8  1A39 00C00003           1965mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BCE  0805 0002               1966mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    1967mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000BD4  13C3 00C00007           1968mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BDA                          1969mm     ENDC
00000BDA                          1970mm 
00000BDA                 FALSE    1971mm     IFNE DEBUG
00000BDA                          1972mm     ENDC
00000BDA                          1973mm 
00000BDA                          1974mm     ENDM
00000BDA  57CE FFDA               1975m     DBEQ D6,LOOP_122
00000BDE                          1976m     ENDM
00000BDE                          1977m         PRINT_CRLF D5,A4
00000BDE  49FA 0BDE               1978m     LEA CRLF(PC),A4
00000BE2                          1979mm     PRINT_STR A4,D5
00000BE2                          1980mm LOOP_128
00000BE2  0C14 0000               1981mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BE6  6700 0016               1982mm     BEQ EXIT_128
00000BEA                          1983mmm     PRINT_CHAR (A4)+,D5
00000BEA                          1984mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BEA                 TRUE     1985mmm     IFEQ DEBUG
00000BEA  1A39 00C00003           1986mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BF0  0805 0002               1987mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BF4  67F4                    1988mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BF6  13DC 00C00007           1989mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BFC                          1990mmm     ENDC
00000BFC                          1991mmm 
00000BFC                 FALSE    1992mmm     IFNE DEBUG
00000BFC                          1993mmm     ENDC
00000BFC                          1994mmm 
00000BFC                          1995mmm     ENDM
00000BFC  60E4                    1996mm     BRA LOOP_128
00000BFE                          1997mm EXIT_128
00000BFE                          1998mm     ENDM
00000BFE                          1999m     ENDM
00000BFE                          2000          
00000BFE  6000 F71C               2001          BRA MAIN_LOOP
00000C02                          2002      ENDI
00000C02                          2003s _0000000B
00000C02                          2004  
00000C02                          2005      IF D1 <EQ> #0 THEN
00000C02  B27C 0000               2006s     CMP.W   #0,D1
00000C06  6600 0006               2007s     BNE _0000000C
00000C0A  6000 F9B8               2008        BRA WAIT_FOR_SRECORD
00000C0E                          2009      ENDI
00000C0E                          2010s _0000000C
00000C0E                          2011  DOWNLOAD_DONE
00000C0E                          2012m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C0E  43FA 0BB4               2013m     LEA OX(PC),A1
00000C12                          2014mm     PRINT_STR A1,D5
00000C12                          2015mm LOOP_131
00000C12  0C11 0000               2016mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C16  6700 0016               2017mm     BEQ EXIT_131
00000C1A                          2018mmm     PRINT_CHAR (A1)+,D5
00000C1A                          2019mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1A                 TRUE     2020mmm     IFEQ DEBUG
00000C1A  1A39 00C00003           2021mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C20  0805 0002               2022mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C24  67F4                    2023mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000C26  13D9 00C00007           2024mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C2C                          2025mmm     ENDC
00000C2C                          2026mmm 
00000C2C                 FALSE    2027mmm     IFNE DEBUG
00000C2C                          2028mmm     ENDC
00000C2C                          2029mmm 
00000C2C                          2030mmm     ENDM
00000C2C  60E4                    2031mm     BRA LOOP_131
00000C2E                          2032mm EXIT_131
00000C2E                          2033mm     ENDM
00000C2E  7407                    2034m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C30                          2035m LOOP_130
00000C30                          2036mm     BIN2HEX D0,D6,A1
00000C30  43FA 0B51               2037mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C34  E998                    2038mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C36  1C00                    2039mm     MOVE.B D0,D6
00000C38  0286 0000000F           2040mm     ANDI.L #$F,D6
00000C3E  1C31 6000               2041mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C42                          2042mm     ENDM
00000C42                          2043mm     PRINT_CHAR D6,D5
00000C42                          2044mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C42                 TRUE     2045mm     IFEQ DEBUG
00000C42  1A39 00C00003           2046mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C48  0805 0002               2047mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C4C  67F4                    2048mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C4E  13C6 00C00007           2049mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C54                          2050mm     ENDC
00000C54                          2051mm 
00000C54                 FALSE    2052mm     IFNE DEBUG
00000C54                          2053mm     ENDC
00000C54                          2054mm 
00000C54                          2055mm     ENDM
00000C54  57CA FFDA               2056m     DBEQ D2,LOOP_130
00000C58                          2057m     ENDM
00000C58  43FA 0ACE               2058      LEA READ(PC),A1
00000C5C                          2059m     PRINT_STR A1,D5
00000C5C                          2060m LOOP_135
00000C5C  0C11 0000               2061m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C60  6700 0016               2062m     BEQ EXIT_135
00000C64                          2063mm     PRINT_CHAR (A1)+,D5
00000C64                          2064mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C64                 TRUE     2065mm     IFEQ DEBUG
00000C64  1A39 00C00003           2066mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C6A  0805 0002               2067mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C6E  67F4                    2068mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C70  13D9 00C00007           2069mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C76                          2070mm     ENDC
00000C76                          2071mm 
00000C76                 FALSE    2072mm     IFNE DEBUG
00000C76                          2073mm     ENDC
00000C76                          2074mm 
00000C76                          2075mm     ENDM
00000C76  60E4                    2076m     BRA LOOP_135
00000C78                          2077m EXIT_135
00000C78                          2078m     ENDM
00000C78  2E08                    2079      MOVE.L A0,D7                                    ; set address accumulator to start address
00000C7A                          2080m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000C7A  43FA 0B48               2081m     LEA OX(PC),A1
00000C7E                          2082mm     PRINT_STR A1,D5
00000C7E                          2083mm LOOP_138
00000C7E  0C11 0000               2084mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C82  6700 0016               2085mm     BEQ EXIT_138
00000C86                          2086mmm     PRINT_CHAR (A1)+,D5
00000C86                          2087mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C86                 TRUE     2088mmm     IFEQ DEBUG
00000C86  1A39 00C00003           2089mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C8C  0805 0002               2090mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C90  67F4                    2091mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000C92  13D9 00C00007           2092mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C98                          2093mmm     ENDC
00000C98                          2094mmm 
00000C98                 FALSE    2095mmm     IFNE DEBUG
00000C98                          2096mmm     ENDC
00000C98                          2097mmm 
00000C98                          2098mmm     ENDM
00000C98  60E4                    2099mm     BRA LOOP_138
00000C9A                          2100mm EXIT_138
00000C9A                          2101mm     ENDM
00000C9A  7407                    2102m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C9C                          2103m LOOP_137
00000C9C                          2104mm     BIN2HEX D7,D6,A1
00000C9C  43FA 0AE5               2105mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CA0  E99F                    2106mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CA2  1C07                    2107mm     MOVE.B D7,D6
00000CA4  0286 0000000F           2108mm     ANDI.L #$F,D6
00000CAA  1C31 6000               2109mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CAE                          2110mm     ENDM
00000CAE                          2111mm     PRINT_CHAR D6,D5
00000CAE                          2112mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAE                 TRUE     2113mm     IFEQ DEBUG
00000CAE  1A39 00C00003           2114mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CB4  0805 0002               2115mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CB8  67F4                    2116mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CBA  13C6 00C00007           2117mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CC0                          2118mm     ENDC
00000CC0                          2119mm 
00000CC0                 FALSE    2120mm     IFNE DEBUG
00000CC0                          2121mm     ENDC
00000CC0                          2122mm 
00000CC0                          2123mm     ENDM
00000CC0  57CA FFDA               2124m     DBEQ D2,LOOP_137
00000CC4                          2125m     ENDM
00000CC4                          2126m     PRINT_CRLF D5,A4
00000CC4  49FA 0AF8               2127m     LEA CRLF(PC),A4
00000CC8                          2128mm     PRINT_STR A4,D5
00000CC8                          2129mm LOOP_143
00000CC8  0C14 0000               2130mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000CCC  6700 0016               2131mm     BEQ EXIT_143
00000CD0                          2132mmm     PRINT_CHAR (A4)+,D5
00000CD0                          2133mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD0                 TRUE     2134mmm     IFEQ DEBUG
00000CD0  1A39 00C00003           2135mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CD6  0805 0002               2136mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CDA  67F4                    2137mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000CDC  13DC 00C00007           2138mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CE2                          2139mmm     ENDC
00000CE2                          2140mmm 
00000CE2                 FALSE    2141mmm     IFNE DEBUG
00000CE2                          2142mmm     ENDC
00000CE2                          2143mmm 
00000CE2                          2144mmm     ENDM
00000CE2  60E4                    2145mm     BRA LOOP_143
00000CE4                          2146mm EXIT_143
00000CE4                          2147mm     ENDM
00000CE4                          2148m     ENDM
00000CE4                          2149  
00000CE4  6000 F636               2150      BRA MAIN_LOOP
00000CE8                          2151  
00000CE8                          2152  G
00000CE8  2047                    2153      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000CEA  7E00                    2154      MOVE.L #0,D7
00000CEC                          2155  
00000CEC  4ED0                    2156      JMP (A0)
00000CEE                          2157          
00000CEE                          2158  Z
00000CEE  207C 00200000           2159      MOVE.L #RAM,A0                                  ; address of RAM
00000CF4  D1FC 00100000           2160      ADD.L #$100000,A0
00000CFA                          2161  
00000CFA                          2162      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000CFA  7000                    2163s     MOVE.L  #0,D0
00000CFC  6000 0012               2164s     BRA _20000007
00000D00                          2165s _20000006
00000D00  2200                    2166          MOVE.L D0,D1                                ; progress update
00000D02  E089                    2167          LSR.L #8,D1 
00000D04  E089                    2168          LSR.L #8,D1
00000D06  13C1 00E00001           2169          MOVE.B D1,DISPLAY
00000D0C                          2170          
00000D0C  2108                    2171          MOVE.L A0,-(A0)
00000D0E                          2172      ENDF
00000D0E  5880                    2173s     ADD.L   #4,D0
00000D10                          2174s _20000007
00000D10  B0BC 000FFFFC           2175s     CMP.L   #$FFFFC,D0
00000D16  6FE8                    2176s     BLE _20000006
00000D18                          2177  
00000D18  207C 00200000           2178      MOVE.L #RAM,A0                                  ; address of RAM
00000D1E  D1FC 00100000           2179      ADD.L #$100000,A0
00000D24                          2180  
00000D24                          2181      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D24  7000                    2182s     MOVE.L  #0,D0
00000D26  6000 00A8               2183s     BRA _20000009
00000D2A                          2184s _20000008
00000D2A  2200                    2185          MOVE.L D0,D1                                ; progress update
00000D2C  E089                    2186          LSR.L #8,D1
00000D2E  E089                    2187          LSR.L #8,D1
00000D30  13C1 00E00001           2188          MOVE.B D1,DISPLAY
00000D36                          2189  
00000D36  2408                    2190          MOVE.L A0,D2
00000D38  2220                    2191          MOVE.L -(A0),D1
00000D3A                          2192  
00000D3A                          2193          IF.L D2 <NE> D1 THEN
00000D3A  B481                    2194s     CMP.L   D1,D2
00000D3C  6700 0090               2195s     BEQ _0000000D
00000D40  43FA 0A30               2196              LEA RAM_ERROR(PC),A1
00000D44                          2197m             PRINT_STR A1,D1
00000D44                          2198m LOOP_145
00000D44  0C11 0000               2199m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D48  6700 0016               2200m     BEQ EXIT_145
00000D4C                          2201mm     PRINT_CHAR (A1)+,D1
00000D4C                          2202mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D4C                 TRUE     2203mm     IFEQ DEBUG
00000D4C  1239 00C00003           2204mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D52  0801 0002               2205mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000D56  67F4                    2206mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000D58  13D9 00C00007           2207mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D5E                          2208mm     ENDC
00000D5E                          2209mm 
00000D5E                 FALSE    2210mm     IFNE DEBUG
00000D5E                          2211mm     ENDC
00000D5E                          2212mm 
00000D5E                          2213mm     ENDM
00000D5E  60E4                    2214m     BRA LOOP_145
00000D60                          2215m EXIT_145
00000D60                          2216m     ENDM
00000D60  2208                    2217              MOVE.L A0,D1
00000D62  5981                    2218              SUB.L #4,D1
00000D64                          2219m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000D64  43FA 0A5E               2220m     LEA OX(PC),A1
00000D68                          2221mm     PRINT_STR A1,D3
00000D68                          2222mm LOOP_148
00000D68  0C11 0000               2223mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D6C  6700 0016               2224mm     BEQ EXIT_148
00000D70                          2225mmm     PRINT_CHAR (A1)+,D3
00000D70                          2226mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D70                 TRUE     2227mmm     IFEQ DEBUG
00000D70  1639 00C00003           2228mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D76  0803 0002               2229mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D7A  67F4                    2230mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000D7C  13D9 00C00007           2231mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D82                          2232mmm     ENDC
00000D82                          2233mmm 
00000D82                 FALSE    2234mmm     IFNE DEBUG
00000D82                          2235mmm     ENDC
00000D82                          2236mmm 
00000D82                          2237mmm     ENDM
00000D82  60E4                    2238mm     BRA LOOP_148
00000D84                          2239mm EXIT_148
00000D84                          2240mm     ENDM
00000D84  7C07                    2241m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D86                          2242m LOOP_147
00000D86                          2243mm     BIN2HEX D1,D2,A1
00000D86  43FA 09FB               2244mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000D8A  E999                    2245mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D8C  1401                    2246mm     MOVE.B D1,D2
00000D8E  0282 0000000F           2247mm     ANDI.L #$F,D2
00000D94  1431 2000               2248mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000D98                          2249mm     ENDM
00000D98                          2250mm     PRINT_CHAR D2,D3
00000D98                          2251mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D98                 TRUE     2252mm     IFEQ DEBUG
00000D98  1639 00C00003           2253mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D9E  0803 0002               2254mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DA2  67F4                    2255mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DA4  13C2 00C00007           2256mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DAA                          2257mm     ENDC
00000DAA                          2258mm 
00000DAA                 FALSE    2259mm     IFNE DEBUG
00000DAA                          2260mm     ENDC
00000DAA                          2261mm 
00000DAA                          2262mm     ENDM
00000DAA  57CE FFDA               2263m     DBEQ D6,LOOP_147
00000DAE                          2264m     ENDM
00000DAE                          2265m             PRINT_CRLF D3,A1
00000DAE  43FA 0A0E               2266m     LEA CRLF(PC),A1
00000DB2                          2267mm     PRINT_STR A1,D3
00000DB2                          2268mm LOOP_153
00000DB2  0C11 0000               2269mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DB6  6700 0016               2270mm     BEQ EXIT_153
00000DBA                          2271mmm     PRINT_CHAR (A1)+,D3
00000DBA                          2272mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBA                 TRUE     2273mmm     IFEQ DEBUG
00000DBA  1639 00C00003           2274mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DC0  0803 0002               2275mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DC4  67F4                    2276mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DC6  13D9 00C00007           2277mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DCC                          2278mmm     ENDC
00000DCC                          2279mmm 
00000DCC                 FALSE    2280mmm     IFNE DEBUG
00000DCC                          2281mmm     ENDC
00000DCC                          2282mmm 
00000DCC                          2283mmm     ENDM
00000DCC  60E4                    2284mm     BRA LOOP_153
00000DCE                          2285mm EXIT_153
00000DCE                          2286mm     ENDM
00000DCE                          2287m     ENDM
00000DCE                          2288          ENDI 
00000DCE                          2289s _0000000D
00000DCE                          2290      ENDF
00000DCE  5880                    2291s     ADD.L   #4,D0
00000DD0                          2292s _20000009
00000DD0  B0BC 000FFFFC           2293s     CMP.L   #$FFFFC,D0
00000DD6  6F00 FF52               2294s     BLE _20000008
00000DDA                          2295  
00000DDA  6000 F540               2296      BRA MAIN_LOOP
00000DDE                          2297  
00000DDE                          2298  L
00000DDE  7000                    2299      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000DE0  7200                    2300      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000DE2                          2301  
00000DE2                          2302      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000DE2  343C 0000               2303s     MOVE.W  #0,D2
00000DE6  6000 0046               2304s     BRA _2000000B
00000DEA                          2305s _2000000A
00000DEA  E989                    2306          LSL.L #4,D1                                 ; make what we have so far more significant
00000DEC                          2307m         WAIT_CHAR D3,D4                             ; next character -> D2
00000DEC                          2308m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEC                 TRUE     2309m     IFEQ DEBUG
00000DEC  1839 00C00003           2310m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000DF2  0804 0000               2311m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000DF6  67F4                    2312m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000DF8                          2313m     ENDC
00000DF8                          2314m 
00000DF8                          2315mm     READ_CHAR D3
00000DF8                 TRUE     2316mm     IFEQ DEBUG
00000DF8  1639 00C00007           2317mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000DFE                          2318mm     ENDC
00000DFE                 FALSE    2319mm     IFNE DEBUG
00000DFE                          2320mm     ENDC
00000DFE                          2321mm 
00000DFE  B63C 001B               2322mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E02  6700 F300               2323mm     BEQ START
00000E06                          2324mm     ENDM
00000E06                          2325m 
00000E06                 TRUE     2326m     IFEQ DEBUG
00000E06                          2327mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E06                          2328mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E06                 TRUE     2329mm     IFEQ DEBUG
00000E06  1839 00C00003           2330mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E0C  0804 0002               2331mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E10  67F4                    2332mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E12  13C3 00C00007           2333mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E18                          2334mm     ENDC
00000E18                          2335mm 
00000E18                 FALSE    2336mm     IFNE DEBUG
00000E18                          2337mm     ENDC
00000E18                          2338mm 
00000E18                          2339mm     ENDM
00000E18                          2340m     ENDC
00000E18                          2341m     ENDM
00000E18                          2342m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E18  41FA 0979               2343m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E1C  0403 0030               2344m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E20  C6BC 000000FF           2345m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E26  1630 3000               2346m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E2A                          2347m     ENDM
00000E2A  8203                    2348          OR.B D3,D1
00000E2C                          2349      ENDF
00000E2C  5242                    2350s     ADD.W   #1,D2
00000E2E                          2351s _2000000B
00000E2E  B47C 0007               2352s     CMP.W   #7,D2
00000E32  6FB6                    2353s     BLE _2000000A
00000E34                          2354  
00000E34  3001                    2355      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E36  0480 00000104           2356      SUB.L #START,D0                                 ; remove the vector table from the length
00000E3C  E089                    2357      LSR.L #8,D1                                     ; extract the MSword for the address
00000E3E  E089                    2358      LSR.L #8,D1
00000E40                          2359  
00000E40                          2360m     PRINT_CRLF D2,A1
00000E40  43FA 097C               2361m     LEA CRLF(PC),A1
00000E44                          2362mm     PRINT_STR A1,D2
00000E44                          2363mm LOOP_160
00000E44  0C11 0000               2364mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E48  6700 0016               2365mm     BEQ EXIT_160
00000E4C                          2366mmm     PRINT_CHAR (A1)+,D2
00000E4C                          2367mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4C                 TRUE     2368mmm     IFEQ DEBUG
00000E4C  1439 00C00003           2369mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E52  0802 0002               2370mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E56  67F4                    2371mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E58  13D9 00C00007           2372mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E5E                          2373mmm     ENDC
00000E5E                          2374mmm 
00000E5E                 FALSE    2375mmm     IFNE DEBUG
00000E5E                          2376mmm     ENDC
00000E5E                          2377mmm 
00000E5E                          2378mmm     ENDM
00000E5E  60E4                    2379mm     BRA LOOP_160
00000E60                          2380mm EXIT_160
00000E60                          2381mm     ENDM
00000E60                          2382m     ENDM
00000E60                          2383  
00000E60  2041                    2384      MOVE.L D1,A0                                    ; target address
00000E62  2641                    2385      MOVE.L D1,A3                                    ; keep a copy for later
00000E64                          2386  
00000E64  2247                    2387      MOVE.L D7,A1                                    ; address accumulator -> address register
00000E66  D3FC 00000104           2388      ADD.L #START,A1                                 ; skip the vectors
00000E6C  2847                    2389      MOVE.L D7,A4                                    ; keep a clean copy for later
00000E6E  7E00                    2390      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E70                          2391  
00000E70                          2392m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000E70  31FC AAAA 2AAA          2393m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E76  4E71                    2394m     NOP
00000E78  31FC 5555 1554          2395m     MOVE.W #$5555,$1554
00000E7E  4E71                    2396m     NOP
00000E80  31FC 8080 2AAA          2397m     MOVE.W #$8080,$2AAA
00000E86  4E71                    2398m     NOP
00000E88  31FC AAAA 2AAA          2399m     MOVE.W #$AAAA,$2AAA
00000E8E  4E71                    2400m     NOP
00000E90  31FC 5555 1554          2401m     MOVE.W #$5555,$1554
00000E96  4E71                    2402m     NOP
00000E98  31FC 2020 2AAA          2403m     MOVE.W #$2020,$2AAA
00000E9E                          2404m     ENDM
00000E9E                          2405                      
00000E9E                          2406      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000E9E  3E3C 0000               2407s     MOVE.W  #$0,D7
00000EA2  6000 0006               2408s     BRA _2000000D
00000EA6                          2409s _2000000C
00000EA6  4E71                    2410          NOP
00000EA8                          2411      ENDF
00000EA8  5247                    2412s     ADD.W   #1,D7
00000EAA                          2413s _2000000D
00000EAA  BE7C FFFF               2414s     CMP.W   #$FFFFFFFF,D7
00000EAE  6FF6                    2415s     BLE _2000000C
00000EB0                          2416                  
00000EB0  45FA 08F8               2417      LEA LOADING(PC),A2
00000EB4                          2418m     PRINT_STR A2,D2
00000EB4                          2419m LOOP_163
00000EB4  0C12 0000               2420m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EB8  6700 0016               2421m     BEQ EXIT_163
00000EBC                          2422mm     PRINT_CHAR (A2)+,D2
00000EBC                          2423mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EBC                 TRUE     2424mm     IFEQ DEBUG
00000EBC  1439 00C00003           2425mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EC2  0802 0002               2426mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EC6  67F4                    2427mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EC8  13DA 00C00007           2428mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ECE                          2429mm     ENDC
00000ECE                          2430mm 
00000ECE                 FALSE    2431mm     IFNE DEBUG
00000ECE                          2432mm     ENDC
00000ECE                          2433mm 
00000ECE                          2434mm     ENDM
00000ECE  60E4                    2435m     BRA LOOP_163
00000ED0                          2436m EXIT_163
00000ED0                          2437m     ENDM
00000ED0  45FA 08D8               2438      LEA LOADING(PC),A2
00000ED4                          2439m     PRINT_STR A2,D2
00000ED4                          2440m LOOP_165
00000ED4  0C12 0000               2441m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000ED8  6700 0016               2442m     BEQ EXIT_165
00000EDC                          2443mm     PRINT_CHAR (A2)+,D2
00000EDC                          2444mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EDC                 TRUE     2445mm     IFEQ DEBUG
00000EDC  1439 00C00003           2446mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EE2  0802 0002               2447mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EE6  67F4                    2448mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000EE8  13DA 00C00007           2449mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EEE                          2450mm     ENDC
00000EEE                          2451mm 
00000EEE                 FALSE    2452mm     IFNE DEBUG
00000EEE                          2453mm     ENDC
00000EEE                          2454mm 
00000EEE                          2455mm     ENDM
00000EEE  60E4                    2456m     BRA LOOP_165
00000EF0                          2457m EXIT_165
00000EF0                          2458m     ENDM
00000EF0                          2459          
00000EF0  2409                    2460      MOVE.L A1,D2
00000EF2                          2461m     PRINT_REG D2,D3,D4,D5,A2
00000EF2  45FA 08D0               2462m     LEA OX(PC),A2
00000EF6                          2463mm     PRINT_STR A2,D3
00000EF6                          2464mm LOOP_168
00000EF6  0C12 0000               2465mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EFA  6700 0016               2466mm     BEQ EXIT_168
00000EFE                          2467mmm     PRINT_CHAR (A2)+,D3
00000EFE                          2468mmm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EFE                 TRUE     2469mmm     IFEQ DEBUG
00000EFE  1639 00C00003           2470mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F04  0803 0002               2471mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F08  67F4                    2472mmm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F0A  13DA 00C00007           2473mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F10                          2474mmm     ENDC
00000F10                          2475mmm 
00000F10                 FALSE    2476mmm     IFNE DEBUG
00000F10                          2477mmm     ENDC
00000F10                          2478mmm 
00000F10                          2479mmm     ENDM
00000F10  60E4                    2480mm     BRA LOOP_168
00000F12                          2481mm EXIT_168
00000F12                          2482mm     ENDM
00000F12  7A07                    2483m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F14                          2484m LOOP_167
00000F14                          2485mm     BIN2HEX D2,D4,A2
00000F14  45FA 086D               2486mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F18  E99A                    2487mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F1A  1802                    2488mm     MOVE.B D2,D4
00000F1C  0284 0000000F           2489mm     ANDI.L #$F,D4
00000F22  1832 4000               2490mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F26                          2491mm     ENDM
00000F26                          2492mm     PRINT_CHAR D4,D3
00000F26                          2493mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F26                 TRUE     2494mm     IFEQ DEBUG
00000F26  1639 00C00003           2495mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2C  0803 0002               2496mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F30  67F4                    2497mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F32  13C4 00C00007           2498mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F38                          2499mm     ENDC
00000F38                          2500mm 
00000F38                 FALSE    2501mm     IFNE DEBUG
00000F38                          2502mm     ENDC
00000F38                          2503mm 
00000F38                          2504mm     ENDM
00000F38  57CD FFDA               2505m     DBEQ D5,LOOP_167
00000F3C                          2506m     ENDM
00000F3C                          2507  
00000F3C  45FA 0889               2508      LEA TO(PC),A2
00000F40                          2509m     PRINT_STR A2,D3
00000F40                          2510m LOOP_172
00000F40  0C12 0000               2511m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F44  6700 0016               2512m     BEQ EXIT_172
00000F48                          2513mm     PRINT_CHAR (A2)+,D3
00000F48                          2514mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F48                 TRUE     2515mm     IFEQ DEBUG
00000F48  1639 00C00003           2516mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F4E  0803 0002               2517mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F52  67F4                    2518mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F54  13DA 00C00007           2519mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F5A                          2520mm     ENDC
00000F5A                          2521mm 
00000F5A                 FALSE    2522mm     IFNE DEBUG
00000F5A                          2523mm     ENDC
00000F5A                          2524mm 
00000F5A                          2525mm     ENDM
00000F5A  60E4                    2526m     BRA LOOP_172
00000F5C                          2527m EXIT_172
00000F5C                          2528m     ENDM
00000F5C                          2529  
00000F5C  2408                    2530      MOVE.L A0,D2
00000F5E                          2531m     PRINT_REG D2,D3,D4,D5,A2
00000F5E  45FA 0864               2532m     LEA OX(PC),A2
00000F62                          2533mm     PRINT_STR A2,D3
00000F62                          2534mm LOOP_175
00000F62  0C12 0000               2535mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F66  6700 0016               2536mm     BEQ EXIT_175
00000F6A                          2537mmm     PRINT_CHAR (A2)+,D3
00000F6A                          2538mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F6A                 TRUE     2539mmm     IFEQ DEBUG
00000F6A  1639 00C00003           2540mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F70  0803 0002               2541mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F74  67F4                    2542mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000F76  13DA 00C00007           2543mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F7C                          2544mmm     ENDC
00000F7C                          2545mmm 
00000F7C                 FALSE    2546mmm     IFNE DEBUG
00000F7C                          2547mmm     ENDC
00000F7C                          2548mmm 
00000F7C                          2549mmm     ENDM
00000F7C  60E4                    2550mm     BRA LOOP_175
00000F7E                          2551mm EXIT_175
00000F7E                          2552mm     ENDM
00000F7E  7A07                    2553m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F80                          2554m LOOP_174
00000F80                          2555mm     BIN2HEX D2,D4,A2
00000F80  45FA 0801               2556mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F84  E99A                    2557mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F86  1802                    2558mm     MOVE.B D2,D4
00000F88  0284 0000000F           2559mm     ANDI.L #$F,D4
00000F8E  1832 4000               2560mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F92                          2561mm     ENDM
00000F92                          2562mm     PRINT_CHAR D4,D3
00000F92                          2563mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F92                 TRUE     2564mm     IFEQ DEBUG
00000F92  1639 00C00003           2565mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F98  0803 0002               2566mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F9C  67F4                    2567mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000F9E  13C4 00C00007           2568mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FA4                          2569mm     ENDC
00000FA4                          2570mm 
00000FA4                 FALSE    2571mm     IFNE DEBUG
00000FA4                          2572mm     ENDC
00000FA4                          2573mm 
00000FA4                          2574mm     ENDM
00000FA4  57CD FFDA               2575m     DBEQ D5,LOOP_174
00000FA8                          2576m     ENDM
00000FA8                          2577  
00000FA8  45FA 0822               2578      LEA FOR(PC),A2
00000FAC                          2579m     PRINT_STR A2,D3
00000FAC                          2580m LOOP_179
00000FAC  0C12 0000               2581m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FB0  6700 0016               2582m     BEQ EXIT_179
00000FB4                          2583mm     PRINT_CHAR (A2)+,D3
00000FB4                          2584mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FB4                 TRUE     2585mm     IFEQ DEBUG
00000FB4  1639 00C00003           2586mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FBA  0803 0002               2587mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FBE  67F4                    2588mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000FC0  13DA 00C00007           2589mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FC6                          2590mm     ENDC
00000FC6                          2591mm 
00000FC6                 FALSE    2592mm     IFNE DEBUG
00000FC6                          2593mm     ENDC
00000FC6                          2594mm 
00000FC6                          2595mm     ENDM
00000FC6  60E4                    2596m     BRA LOOP_179
00000FC8                          2597m EXIT_179
00000FC8                          2598m     ENDM
00000FC8                          2599m     PRINT_REG D0,D3,D4,D5,A2
00000FC8  45FA 07FA               2600m     LEA OX(PC),A2
00000FCC                          2601mm     PRINT_STR A2,D3
00000FCC                          2602mm LOOP_182
00000FCC  0C12 0000               2603mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FD0  6700 0016               2604mm     BEQ EXIT_182
00000FD4                          2605mmm     PRINT_CHAR (A2)+,D3
00000FD4                          2606mmm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FD4                 TRUE     2607mmm     IFEQ DEBUG
00000FD4  1639 00C00003           2608mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FDA  0803 0002               2609mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FDE  67F4                    2610mmm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000FE0  13DA 00C00007           2611mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FE6                          2612mmm     ENDC
00000FE6                          2613mmm 
00000FE6                 FALSE    2614mmm     IFNE DEBUG
00000FE6                          2615mmm     ENDC
00000FE6                          2616mmm 
00000FE6                          2617mmm     ENDM
00000FE6  60E4                    2618mm     BRA LOOP_182
00000FE8                          2619mm EXIT_182
00000FE8                          2620mm     ENDM
00000FE8  7A07                    2621m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FEA                          2622m LOOP_181
00000FEA                          2623mm     BIN2HEX D0,D4,A2
00000FEA  45FA 0797               2624mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FEE  E998                    2625mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FF0  1800                    2626mm     MOVE.B D0,D4
00000FF2  0284 0000000F           2627mm     ANDI.L #$F,D4
00000FF8  1832 4000               2628mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FFC                          2629mm     ENDM
00000FFC                          2630mm     PRINT_CHAR D4,D3
00000FFC                          2631mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FFC                 TRUE     2632mm     IFEQ DEBUG
00000FFC  1639 00C00003           2633mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001002  0803 0002               2634mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001006  67F4                    2635mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00001008  13C4 00C00007           2636mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000100E                          2637mm     ENDC
0000100E                          2638mm 
0000100E                 FALSE    2639mm     IFNE DEBUG
0000100E                          2640mm     ENDC
0000100E                          2641mm 
0000100E                          2642mm     ENDM
0000100E  57CD FFDA               2643m     DBEQ D5,LOOP_181
00001012                          2644m     ENDM
00001012                          2645  
00001012                          2646m     PRINT_CRLF D3,A2
00001012  45FA 07AA               2647m     LEA CRLF(PC),A2
00001016                          2648mm     PRINT_STR A2,D3
00001016                          2649mm LOOP_187
00001016  0C12 0000               2650mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000101A  6700 0016               2651mm     BEQ EXIT_187
0000101E                          2652mmm     PRINT_CHAR (A2)+,D3
0000101E                          2653mmm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000101E                 TRUE     2654mmm     IFEQ DEBUG
0000101E  1639 00C00003           2655mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001024  0803 0002               2656mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001028  67F4                    2657mmm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
0000102A  13DA 00C00007           2658mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001030                          2659mmm     ENDC
00001030                          2660mmm 
00001030                 FALSE    2661mmm     IFNE DEBUG
00001030                          2662mmm     ENDC
00001030                          2663mmm 
00001030                          2664mmm     ENDM
00001030  60E4                    2665mm     BRA LOOP_187
00001032                          2666mm EXIT_187
00001032                          2667mm     ENDM
00001032                          2668m     ENDM
00001032                          2669  
00001032                          2670      WHILE D0 <GT> #0 DO
00001032                          2671s _10000014
00001032  B07C 0000               2672s     CMP.W   #0,D0
00001036  6F00 001C               2673s     BLE _10000015
0000103A  5580                    2674          SUB.L #2,D0
0000103C                          2675  
0000103C  13D1 00E00001           2676          MOVE.B (A1),DISPLAY
00001042                          2677m         PROGRAM (A1),(A0),D2
00001042  3091                    2678m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001044                          2679m 
00001044                          2680m WAIT_FOR_COMPLETE_189
00001044  3410                    2681m         MOVE.W (A0),D2
00001046                          2682m 
00001046                          2683m         IF.W D2 <NE> (A1) THEN
00001046  B451                    2684ms     CMP.W   (A1),D2
00001048  6700 0004               2685ms     BEQ _0000000E
0000104C  60F6                    2686m             BRA WAIT_FOR_COMPLETE_189
0000104E                          2687m         ENDI
0000104E                          2688ms _0000000E
0000104E                          2689m         ENDM
0000104E                          2690                  
0000104E  5488                    2691          ADD.L #2,A0
00001050  5489                    2692          ADD.L #2,A1
00001052                          2693      ENDW
00001052  60DE                    2694s     BRA _10000014
00001054                          2695s _10000015
00001054                          2696      
00001054  41F8 0000               2697      LEA STACK,A0
00001058  D1CC                    2698      ADD.L A4,A0
0000105A  2010                    2699      MOVE.L (A0),D0
0000105C                          2700      
0000105C  207C 00000000           2701      MOVE.L #0,A0
00001062                          2702m     PROGRAM_VECTOR D0,A0,D2
00001062  5488                    2703m     ADD.L #2,A0
00001064                          2704mm     PROGRAM D0, (A0), D2                                ; WRITE IT
00001064  3080                    2705mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001066                          2706mm 
00001066                          2707mm WAIT_FOR_COMPLETE_191
00001066  3410                    2708mm         MOVE.W (A0),D2
00001068                          2709mm 
00001068                          2710mm         IF.W D2 <NE> D0 THEN
00001068  B440                    2711mms     CMP.W   D0,D2
0000106A  6700 0004               2712mms     BEQ _0000000F
0000106E  60F6                    2713mm             BRA WAIT_FOR_COMPLETE_191
00001070                          2714mm         ENDI
00001070                          2715mms _0000000F
00001070                          2716mm         ENDM
00001070  E088                    2717m     LSR.L #8,D0
00001072  E088                    2718m     LSR.L #8,D0
00001074  5588                    2719m     SUB.L #2,A0
00001076                          2720mm     PROGRAM D0, (A0), D2
00001076  3080                    2721mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001078                          2722mm 
00001078                          2723mm WAIT_FOR_COMPLETE_192
00001078  3410                    2724mm         MOVE.W (A0),D2
0000107A                          2725mm 
0000107A                          2726mm         IF.W D2 <NE> D0 THEN
0000107A  B440                    2727mms     CMP.W   D0,D2
0000107C  6700 0004               2728mms     BEQ _00000010
00001080  60F6                    2729mm             BRA WAIT_FOR_COMPLETE_192
00001082                          2730mm         ENDI
00001082                          2731mms _00000010
00001082                          2732mm         ENDM
00001082                          2733m     ENDM
00001082                          2734      
00001082                          2735      FOR A0 = #RESET TO #START-4 BY #4 DO
00001082  307C 0004               2736s     MOVE.W  #RESET,A0
00001086  6000 003C               2737s     BRA _2000000F
0000108A                          2738s _2000000E
0000108A                          2739  
0000108A  2248                    2740          MOVE.L A0,A1
0000108C  D3CC                    2741          ADD.L A4,A1
0000108E                          2742              
0000108E  2011                    2743          MOVE.L (A1),D0  
00001090  D081                    2744          ADD.L D1,D0
00001092  0480 00000104           2745          SUB.L #START,D0
00001098                          2746  
00001098  2408                    2747          MOVE.L A0,D2
0000109A                          2748          
0000109A  2408                    2749          MOVE.L A0,D2
0000109C  13C2 00E00001           2750          MOVE.B D2,DISPLAY
000010A2                          2751m         PROGRAM_VECTOR D0,A0,D2
000010A2  5488                    2752m     ADD.L #2,A0
000010A4                          2753mm     PROGRAM D0, (A0), D2                                ; WRITE IT
000010A4  3080                    2754mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010A6                          2755mm 
000010A6                          2756mm WAIT_FOR_COMPLETE_194
000010A6  3410                    2757mm         MOVE.W (A0),D2
000010A8                          2758mm 
000010A8                          2759mm         IF.W D2 <NE> D0 THEN
000010A8  B440                    2760mms     CMP.W   D0,D2
000010AA  6700 0004               2761mms     BEQ _00000011
000010AE  60F6                    2762mm             BRA WAIT_FOR_COMPLETE_194
000010B0                          2763mm         ENDI
000010B0                          2764mms _00000011
000010B0                          2765mm         ENDM
000010B0  E088                    2766m     LSR.L #8,D0
000010B2  E088                    2767m     LSR.L #8,D0
000010B4  5588                    2768m     SUB.L #2,A0
000010B6                          2769mm     PROGRAM D0, (A0), D2
000010B6  3080                    2770mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010B8                          2771mm 
000010B8                          2772mm WAIT_FOR_COMPLETE_195
000010B8  3410                    2773mm         MOVE.W (A0),D2
000010BA                          2774mm 
000010BA                          2775mm         IF.W D2 <NE> D0 THEN
000010BA  B440                    2776mms     CMP.W   D0,D2
000010BC  6700 0004               2777mms     BEQ _00000012
000010C0  60F6                    2778mm             BRA WAIT_FOR_COMPLETE_195
000010C2                          2779mm         ENDI
000010C2                          2780mms _00000012
000010C2                          2781mm         ENDM
000010C2                          2782m     ENDM
000010C2                          2783      ENDF
000010C2  5848                    2784s     ADD.W   #4,A0
000010C4                          2785s _2000000F
000010C4  B0FC 0100               2786s     CMP.W   #START-4,A0
000010C8  6FC0                    2787s     BLE _2000000E
000010CA                          2788                                          
000010CA                          2789m     PROTECT
000010CA  31FC AAAA 2AAA          2790m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010D0  31FC 5555 1554          2791m     MOVE.W #$5555,$1554
000010D6  31FC A0A0 2AAA          2792m     MOVE.W #$A0A0,$2AAA
000010DC                          2793m     ENDM
000010DC                          2794  
000010DC  6000 F23E               2795      BRA MAIN_LOOP
000010E0                          2796      
000010E0                          2797  P
000010E0  7000                    2798      MOVE.L #0,D0                                    ; D0 will be the data to write
000010E2                          2799  
000010E2                          2800      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000010E2  323C 0000               2801s     MOVE.W  #0,D1
000010E6  6000 0046               2802s     BRA _20000011
000010EA                          2803s _20000010
000010EA  E988                    2804          LSL.L #4,D0                                 ; make what we have so far more significant
000010EC                          2805m         WAIT_CHAR D2,D3                             ; next character -> D2
000010EC                          2806m WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010EC                 TRUE     2807m     IFEQ DEBUG
000010EC  1639 00C00003           2808m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010F2  0803 0000               2809m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000010F6  67F4                    2810m         BEQ WAIT_FOR_READY_197                      ; NOTHING, CHECK AGAIN
000010F8                          2811m     ENDC
000010F8                          2812m 
000010F8                          2813mm     READ_CHAR D2
000010F8                 TRUE     2814mm     IFEQ DEBUG
000010F8  1439 00C00007           2815mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000010FE                          2816mm     ENDC
000010FE                 FALSE    2817mm     IFNE DEBUG
000010FE                          2818mm     ENDC
000010FE                          2819mm 
000010FE  B43C 001B               2820mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001102  6700 F000               2821mm     BEQ START
00001106                          2822mm     ENDM
00001106                          2823m 
00001106                 TRUE     2824m     IFEQ DEBUG
00001106                          2825mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001106                          2826mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001106                 TRUE     2827mm     IFEQ DEBUG
00001106  1639 00C00003           2828mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000110C  0803 0002               2829mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001110  67F4                    2830mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001112  13C2 00C00007           2831mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001118                          2832mm     ENDC
00001118                          2833mm 
00001118                 FALSE    2834mm     IFNE DEBUG
00001118                          2835mm     ENDC
00001118                          2836mm 
00001118                          2837mm     ENDM
00001118                          2838m     ENDC
00001118                          2839m     ENDM
00001118                          2840m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001118  41FA 0679               2841m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000111C  0402 0030               2842m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001120  C4BC 000000FF           2843m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001126  1430 2000               2844m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000112A                          2845m     ENDM
0000112A  8002                    2846          OR.B D2,D0
0000112C                          2847      ENDF
0000112C  5241                    2848s     ADD.W   #1,D1
0000112E                          2849s _20000011
0000112E  B27C 0003               2850s     CMP.W   #3,D1
00001132  6FB6                    2851s     BLE _20000010
00001134                          2852  
00001134                          2853m     PRINT_CRLF D2,A1
00001134  43FA 0688               2854m     LEA CRLF(PC),A1
00001138                          2855mm     PRINT_STR A1,D2
00001138                          2856mm LOOP_202
00001138  0C11 0000               2857mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000113C  6700 0016               2858mm     BEQ EXIT_202
00001140                          2859mmm     PRINT_CHAR (A1)+,D2
00001140                          2860mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001140                 TRUE     2861mmm     IFEQ DEBUG
00001140  1439 00C00003           2862mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001146  0802 0002               2863mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000114A  67F4                    2864mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
0000114C  13D9 00C00007           2865mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001152                          2866mmm     ENDC
00001152                          2867mmm 
00001152                 FALSE    2868mmm     IFNE DEBUG
00001152                          2869mmm     ENDC
00001152                          2870mmm 
00001152                          2871mmm     ENDM
00001152  60E4                    2872mm     BRA LOOP_202
00001154                          2873mm EXIT_202
00001154                          2874mm     ENDM
00001154                          2875m     ENDM
00001154                          2876  
00001154  2047                    2877      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001156  7E00                    2878      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001158                          2879  
00001158                          2880m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001158  31FC AAAA 2AAA          2881m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000115E  4E71                    2882m     NOP
00001160  31FC 5555 1554          2883m     MOVE.W #$5555,$1554
00001166  4E71                    2884m     NOP
00001168  31FC 8080 2AAA          2885m     MOVE.W #$8080,$2AAA
0000116E  4E71                    2886m     NOP
00001170  31FC AAAA 2AAA          2887m     MOVE.W #$AAAA,$2AAA
00001176  4E71                    2888m     NOP
00001178  31FC 5555 1554          2889m     MOVE.W #$5555,$1554
0000117E  4E71                    2890m     NOP
00001180  31FC 2020 2AAA          2891m     MOVE.W #$2020,$2AAA
00001186                          2892m     ENDM
00001186                          2893                              
00001186                          2894      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001186  3E3C 0000               2895s     MOVE.W  #$0,D7
0000118A  6000 0006               2896s     BRA _20000013
0000118E                          2897s _20000012
0000118E  4E71                    2898          NOP
00001190                          2899      ENDF
00001190  5247                    2900s     ADD.W   #1,D7
00001192                          2901s _20000013
00001192  BE7C FFFF               2902s     CMP.W   #$FFFFFFFF,D7
00001196  6FF6                    2903s     BLE _20000012
00001198                          2904               
00001198  45FA 0610               2905      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000119C                          2906m     PRINT_STR A2,D2
0000119C                          2907m LOOP_205
0000119C  0C12 0000               2908m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011A0  6700 0016               2909m     BEQ EXIT_205
000011A4                          2910mm     PRINT_CHAR (A2)+,D2
000011A4                          2911mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011A4                 TRUE     2912mm     IFEQ DEBUG
000011A4  1439 00C00003           2913mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011AA  0802 0002               2914mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011AE  67F4                    2915mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
000011B0  13DA 00C00007           2916mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011B6                          2917mm     ENDC
000011B6                          2918mm 
000011B6                 FALSE    2919mm     IFNE DEBUG
000011B6                          2920mm     ENDC
000011B6                          2921mm 
000011B6                          2922mm     ENDM
000011B6  60E4                    2923m     BRA LOOP_205
000011B8                          2924m EXIT_205
000011B8                          2925m     ENDM
000011B8                          2926  
000011B8                          2927m     PRINT_REG D0,D3,D4,D5,A2
000011B8  45FA 060A               2928m     LEA OX(PC),A2
000011BC                          2929mm     PRINT_STR A2,D3
000011BC                          2930mm LOOP_208
000011BC  0C12 0000               2931mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011C0  6700 0016               2932mm     BEQ EXIT_208
000011C4                          2933mmm     PRINT_CHAR (A2)+,D3
000011C4                          2934mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011C4                 TRUE     2935mmm     IFEQ DEBUG
000011C4  1639 00C00003           2936mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011CA  0803 0002               2937mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011CE  67F4                    2938mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
000011D0  13DA 00C00007           2939mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011D6                          2940mmm     ENDC
000011D6                          2941mmm 
000011D6                 FALSE    2942mmm     IFNE DEBUG
000011D6                          2943mmm     ENDC
000011D6                          2944mmm 
000011D6                          2945mmm     ENDM
000011D6  60E4                    2946mm     BRA LOOP_208
000011D8                          2947mm EXIT_208
000011D8                          2948mm     ENDM
000011D8  7A07                    2949m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011DA                          2950m LOOP_207
000011DA                          2951mm     BIN2HEX D0,D4,A2
000011DA  45FA 05A7               2952mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011DE  E998                    2953mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011E0  1800                    2954mm     MOVE.B D0,D4
000011E2  0284 0000000F           2955mm     ANDI.L #$F,D4
000011E8  1832 4000               2956mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011EC                          2957mm     ENDM
000011EC                          2958mm     PRINT_CHAR D4,D3
000011EC                          2959mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011EC                 TRUE     2960mm     IFEQ DEBUG
000011EC  1639 00C00003           2961mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011F2  0803 0002               2962mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011F6  67F4                    2963mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000011F8  13C4 00C00007           2964mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011FE                          2965mm     ENDC
000011FE                          2966mm 
000011FE                 FALSE    2967mm     IFNE DEBUG
000011FE                          2968mm     ENDC
000011FE                          2969mm 
000011FE                          2970mm     ENDM
000011FE  57CD FFDA               2971m     DBEQ D5,LOOP_207
00001202                          2972m     ENDM
00001202                          2973  
00001202  45FA 05C3               2974      LEA TO(PC),A2
00001206                          2975m     PRINT_STR A2,D3
00001206                          2976m LOOP_212
00001206  0C12 0000               2977m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000120A  6700 0016               2978m     BEQ EXIT_212
0000120E                          2979mm     PRINT_CHAR (A2)+,D3
0000120E                          2980mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000120E                 TRUE     2981mm     IFEQ DEBUG
0000120E  1639 00C00003           2982mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001214  0803 0002               2983mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001218  67F4                    2984mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
0000121A  13DA 00C00007           2985mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001220                          2986mm     ENDC
00001220                          2987mm 
00001220                 FALSE    2988mm     IFNE DEBUG
00001220                          2989mm     ENDC
00001220                          2990mm 
00001220                          2991mm     ENDM
00001220  60E4                    2992m     BRA LOOP_212
00001222                          2993m EXIT_212
00001222                          2994m     ENDM
00001222                          2995  
00001222  2408                    2996      MOVE.L A0,D2
00001224                          2997m     PRINT_REG D2,D3,D4,D5,A2
00001224  45FA 059E               2998m     LEA OX(PC),A2
00001228                          2999mm     PRINT_STR A2,D3
00001228                          3000mm LOOP_215
00001228  0C12 0000               3001mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000122C  6700 0016               3002mm     BEQ EXIT_215
00001230                          3003mmm     PRINT_CHAR (A2)+,D3
00001230                          3004mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001230                 TRUE     3005mmm     IFEQ DEBUG
00001230  1639 00C00003           3006mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001236  0803 0002               3007mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000123A  67F4                    3008mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
0000123C  13DA 00C00007           3009mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001242                          3010mmm     ENDC
00001242                          3011mmm 
00001242                 FALSE    3012mmm     IFNE DEBUG
00001242                          3013mmm     ENDC
00001242                          3014mmm 
00001242                          3015mmm     ENDM
00001242  60E4                    3016mm     BRA LOOP_215
00001244                          3017mm EXIT_215
00001244                          3018mm     ENDM
00001244  7A07                    3019m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001246                          3020m LOOP_214
00001246                          3021mm     BIN2HEX D2,D4,A2
00001246  45FA 053B               3022mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000124A  E99A                    3023mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000124C  1802                    3024mm     MOVE.B D2,D4
0000124E  0284 0000000F           3025mm     ANDI.L #$F,D4
00001254  1832 4000               3026mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001258                          3027mm     ENDM
00001258                          3028mm     PRINT_CHAR D4,D3
00001258                          3029mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001258                 TRUE     3030mm     IFEQ DEBUG
00001258  1639 00C00003           3031mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000125E  0803 0002               3032mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001262  67F4                    3033mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001264  13C4 00C00007           3034mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000126A                          3035mm     ENDC
0000126A                          3036mm 
0000126A                 FALSE    3037mm     IFNE DEBUG
0000126A                          3038mm     ENDC
0000126A                          3039mm 
0000126A                          3040mm     ENDM
0000126A  57CD FFDA               3041m     DBEQ D5,LOOP_214
0000126E                          3042m     ENDM
0000126E                          3043  
0000126E                          3044m     PRINT_CRLF D3,A2
0000126E  45FA 054E               3045m     LEA CRLF(PC),A2
00001272                          3046mm     PRINT_STR A2,D3
00001272                          3047mm LOOP_220
00001272  0C12 0000               3048mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001276  6700 0016               3049mm     BEQ EXIT_220
0000127A                          3050mmm     PRINT_CHAR (A2)+,D3
0000127A                          3051mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000127A                 TRUE     3052mmm     IFEQ DEBUG
0000127A  1639 00C00003           3053mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001280  0803 0002               3054mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001284  67F4                    3055mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001286  13DA 00C00007           3056mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000128C                          3057mmm     ENDC
0000128C                          3058mmm 
0000128C                 FALSE    3059mmm     IFNE DEBUG
0000128C                          3060mmm     ENDC
0000128C                          3061mmm 
0000128C                          3062mmm     ENDM
0000128C  60E4                    3063mm     BRA LOOP_220
0000128E                          3064mm EXIT_220
0000128E                          3065mm     ENDM
0000128E                          3066m     ENDM
0000128E                          3067  
0000128E                          3068m     PROGRAM D0,(A0),D2
0000128E  3080                    3069m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001290                          3070m 
00001290                          3071m WAIT_FOR_COMPLETE_222
00001290  3410                    3072m         MOVE.W (A0),D2
00001292                          3073m 
00001292                          3074m         IF.W D2 <NE> D0 THEN
00001292  B440                    3075ms     CMP.W   D0,D2
00001294  6700 0004               3076ms     BEQ _00000013
00001298  60F6                    3077m             BRA WAIT_FOR_COMPLETE_222
0000129A                          3078m         ENDI
0000129A                          3079ms _00000013
0000129A                          3080m         ENDM
0000129A                          3081  
0000129A                          3082m     PROTECT
0000129A  31FC AAAA 2AAA          3083m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000012A0  31FC 5555 1554          3084m     MOVE.W #$5555,$1554
000012A6  31FC A0A0 2AAA          3085m     MOVE.W #$A0A0,$2AAA
000012AC                          3086m     ENDM
000012AC                          3087  
000012AC  6000 F06E               3088      BRA MAIN_LOOP
000012B0                          3089      
000012B0                          3090  X
000012B0  45FA 0525               3091      LEA STATUS_REGISTER(PC),A2
000012B4                          3092m     PRINT_STR A2,D3
000012B4                          3093m LOOP_224
000012B4  0C12 0000               3094m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012B8  6700 0016               3095m     BEQ EXIT_224
000012BC                          3096mm     PRINT_CHAR (A2)+,D3
000012BC                          3097mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012BC                 TRUE     3098mm     IFEQ DEBUG
000012BC  1639 00C00003           3099mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012C2  0803 0002               3100mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012C6  67F4                    3101mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
000012C8  13DA 00C00007           3102mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012CE                          3103mm     ENDC
000012CE                          3104mm 
000012CE                 FALSE    3105mm     IFNE DEBUG
000012CE                          3106mm     ENDC
000012CE                          3107mm 
000012CE                          3108mm     ENDM
000012CE  60E4                    3109m     BRA LOOP_224
000012D0                          3110m EXIT_224
000012D0                          3111m     ENDM
000012D0                          3112  
000012D0  40C0                    3113      MOVE SR,D0
000012D2                          3114m     PRINT_REG D0,D3,D4,D5,A2
000012D2  45FA 04F0               3115m     LEA OX(PC),A2
000012D6                          3116mm     PRINT_STR A2,D3
000012D6                          3117mm LOOP_227
000012D6  0C12 0000               3118mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012DA  6700 0016               3119mm     BEQ EXIT_227
000012DE                          3120mmm     PRINT_CHAR (A2)+,D3
000012DE                          3121mmm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DE                 TRUE     3122mmm     IFEQ DEBUG
000012DE  1639 00C00003           3123mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012E4  0803 0002               3124mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012E8  67F4                    3125mmm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
000012EA  13DA 00C00007           3126mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012F0                          3127mmm     ENDC
000012F0                          3128mmm 
000012F0                 FALSE    3129mmm     IFNE DEBUG
000012F0                          3130mmm     ENDC
000012F0                          3131mmm 
000012F0                          3132mmm     ENDM
000012F0  60E4                    3133mm     BRA LOOP_227
000012F2                          3134mm EXIT_227
000012F2                          3135mm     ENDM
000012F2  7A07                    3136m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012F4                          3137m LOOP_226
000012F4                          3138mm     BIN2HEX D0,D4,A2
000012F4  45FA 048D               3139mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012F8  E998                    3140mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012FA  1800                    3141mm     MOVE.B D0,D4
000012FC  0284 0000000F           3142mm     ANDI.L #$F,D4
00001302  1832 4000               3143mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001306                          3144mm     ENDM
00001306                          3145mm     PRINT_CHAR D4,D3
00001306                          3146mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001306                 TRUE     3147mm     IFEQ DEBUG
00001306  1639 00C00003           3148mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000130C  0803 0002               3149mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001310  67F4                    3150mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
00001312  13C4 00C00007           3151mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001318                          3152mm     ENDC
00001318                          3153mm 
00001318                 FALSE    3154mm     IFNE DEBUG
00001318                          3155mm     ENDC
00001318                          3156mm 
00001318                          3157mm     ENDM
00001318  57CD FFDA               3158m     DBEQ D5,LOOP_226
0000131C                          3159m     ENDM
0000131C                          3160m     PRINT_CRLF D3,A2
0000131C  45FA 04A0               3161m     LEA CRLF(PC),A2
00001320                          3162mm     PRINT_STR A2,D3
00001320                          3163mm LOOP_232
00001320  0C12 0000               3164mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001324  6700 0016               3165mm     BEQ EXIT_232
00001328                          3166mmm     PRINT_CHAR (A2)+,D3
00001328                          3167mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001328                 TRUE     3168mmm     IFEQ DEBUG
00001328  1639 00C00003           3169mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000132E  0803 0002               3170mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001332  67F4                    3171mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001334  13DA 00C00007           3172mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000133A                          3173mmm     ENDC
0000133A                          3174mmm 
0000133A                 FALSE    3175mmm     IFNE DEBUG
0000133A                          3176mmm     ENDC
0000133A                          3177mmm 
0000133A                          3178mmm     ENDM
0000133A  60E4                    3179mm     BRA LOOP_232
0000133C                          3180mm EXIT_232
0000133C                          3181mm     ENDM
0000133C                          3182m     ENDM
0000133C                          3183  
0000133C  45FA 0494               3184      LEA STACK_POINTER(PC),A2
00001340                          3185m     PRINT_STR A2,D3
00001340                          3186m LOOP_234
00001340  0C12 0000               3187m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001344  6700 0016               3188m     BEQ EXIT_234
00001348                          3189mm     PRINT_CHAR (A2)+,D3
00001348                          3190mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001348                 TRUE     3191mm     IFEQ DEBUG
00001348  1639 00C00003           3192mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000134E  0803 0002               3193mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001352  67F4                    3194mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
00001354  13DA 00C00007           3195mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000135A                          3196mm     ENDC
0000135A                          3197mm 
0000135A                 FALSE    3198mm     IFNE DEBUG
0000135A                          3199mm     ENDC
0000135A                          3200mm 
0000135A                          3201mm     ENDM
0000135A  60E4                    3202m     BRA LOOP_234
0000135C                          3203m EXIT_234
0000135C                          3204m     ENDM
0000135C                          3205  
0000135C  200F                    3206      MOVE.L SP,D0
0000135E                          3207m     PRINT_REG D0,D3,D4,D5,A2
0000135E  45FA 0464               3208m     LEA OX(PC),A2
00001362                          3209mm     PRINT_STR A2,D3
00001362                          3210mm LOOP_237
00001362  0C12 0000               3211mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001366  6700 0016               3212mm     BEQ EXIT_237
0000136A                          3213mmm     PRINT_CHAR (A2)+,D3
0000136A                          3214mmm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000136A                 TRUE     3215mmm     IFEQ DEBUG
0000136A  1639 00C00003           3216mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001370  0803 0002               3217mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001374  67F4                    3218mmm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
00001376  13DA 00C00007           3219mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000137C                          3220mmm     ENDC
0000137C                          3221mmm 
0000137C                 FALSE    3222mmm     IFNE DEBUG
0000137C                          3223mmm     ENDC
0000137C                          3224mmm 
0000137C                          3225mmm     ENDM
0000137C  60E4                    3226mm     BRA LOOP_237
0000137E                          3227mm EXIT_237
0000137E                          3228mm     ENDM
0000137E  7A07                    3229m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001380                          3230m LOOP_236
00001380                          3231mm     BIN2HEX D0,D4,A2
00001380  45FA 0401               3232mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001384  E998                    3233mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001386  1800                    3234mm     MOVE.B D0,D4
00001388  0284 0000000F           3235mm     ANDI.L #$F,D4
0000138E  1832 4000               3236mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001392                          3237mm     ENDM
00001392                          3238mm     PRINT_CHAR D4,D3
00001392                          3239mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001392                 TRUE     3240mm     IFEQ DEBUG
00001392  1639 00C00003           3241mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001398  0803 0002               3242mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000139C  67F4                    3243mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
0000139E  13C4 00C00007           3244mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013A4                          3245mm     ENDC
000013A4                          3246mm 
000013A4                 FALSE    3247mm     IFNE DEBUG
000013A4                          3248mm     ENDC
000013A4                          3249mm 
000013A4                          3250mm     ENDM
000013A4  57CD FFDA               3251m     DBEQ D5,LOOP_236
000013A8                          3252m     ENDM
000013A8                          3253m     PRINT_CRLF D3,A2
000013A8  45FA 0414               3254m     LEA CRLF(PC),A2
000013AC                          3255mm     PRINT_STR A2,D3
000013AC                          3256mm LOOP_242
000013AC  0C12 0000               3257mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013B0  6700 0016               3258mm     BEQ EXIT_242
000013B4                          3259mmm     PRINT_CHAR (A2)+,D3
000013B4                          3260mmm WAIT_FOR_READY_243                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013B4                 TRUE     3261mmm     IFEQ DEBUG
000013B4  1639 00C00003           3262mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013BA  0803 0002               3263mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013BE  67F4                    3264mmm         BEQ WAIT_FOR_READY_243                      ; NO SPACE, CHECK AGAIN
000013C0  13DA 00C00007           3265mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013C6                          3266mmm     ENDC
000013C6                          3267mmm 
000013C6                 FALSE    3268mmm     IFNE DEBUG
000013C6                          3269mmm     ENDC
000013C6                          3270mmm 
000013C6                          3271mmm     ENDM
000013C6  60E4                    3272mm     BRA LOOP_242
000013C8                          3273mm EXIT_242
000013C8                          3274mm     ENDM
000013C8                          3275m     ENDM
000013C8                          3276  
000013C8  6000 EF52               3277      BRA MAIN_LOOP
000013CC                          3278          
000013CC                          3279  I
000013CC  13FC 0008 00C0000B      3280      MOVE.B #8,DUART_IMR
000013D4  027C F8FF               3281      AND.W #$F8FF,SR
000013D8  6000 EF42               3282      BRA MAIN_LOOP
000013DC                          3283      
000013DC                          3284  O
000013DC  13FC 0000 00C0000B      3285      MOVE.B #0,DUART_IMR
000013E4  007C 0700               3286      OR.W #$0700,SR
000013E8  6000 EF32               3287      BRA MAIN_LOOP
000013EC                          3288          
000013EC                          3289  HASH
000013EC                          3290m     PROTECT
000013EC  31FC AAAA 2AAA          3291m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000013F2  31FC 5555 1554          3292m     MOVE.W #$5555,$1554
000013F8  31FC A0A0 2AAA          3293m     MOVE.W #$A0A0,$2AAA
000013FE                          3294m     ENDM
000013FE  6000 EF1C               3295      BRA MAIN_LOOP
00001402                          3296  
00001402                          3297  
00001402                          3298  
00001402                          3299  HEX_DIGIT
00001402  E98F                    3300      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
00001404                          3301m     HEX2BIN D2,D2,A0
00001404  41FA 038D               3302m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001408  0402 0030               3303m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000140C  C4BC 000000FF           3304m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001412  1430 2000               3305m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001416                          3306m     ENDM
00001416  8E02                    3307      OR.B D2,D7  
00001418  6000 EF22               3308      BRA GET_INPUT
0000141C                          3309  
0000141C                          3310  ; exceptions    
0000141C                          3311  BUS_ERROR_HANDLER
0000141C                          3312  
0000141C  41FA 03C5               3313      LEA BUS_ERROR(PC),A0
00001420                          3314m     PRINT_STR A0,D1
00001420                          3315m LOOP_246
00001420  0C10 0000               3316m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001424  6700 0016               3317m     BEQ EXIT_246
00001428                          3318mm     PRINT_CHAR (A0)+,D1
00001428                          3319mm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001428                 TRUE     3320mm     IFEQ DEBUG
00001428  1239 00C00003           3321mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000142E  0801 0002               3322mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001432  67F4                    3323mm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
00001434  13D8 00C00007           3324mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000143A                          3325mm     ENDC
0000143A                          3326mm 
0000143A                 FALSE    3327mm     IFNE DEBUG
0000143A                          3328mm     ENDC
0000143A                          3329mm 
0000143A                          3330mm     ENDM
0000143A  60E4                    3331m     BRA LOOP_246
0000143C                          3332m EXIT_246
0000143C                          3333m     ENDM
0000143C                          3334  
0000143C  7000                    3335      MOVE.L #0,D0
0000143E  3017                    3336      MOVE.W (SP),D0
00001440                          3337  
00001440  0800 0004               3338      BTST #4,D0
00001444  6700 0026               3339      BEQ WRITE
00001448                          3340      
00001448  41FA 03AE               3341      LEA READING(PC),A0
0000144C                          3342m     PRINT_STR A0,D1
0000144C                          3343m LOOP_248
0000144C  0C10 0000               3344m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001450  6700 0016               3345m     BEQ EXIT_248
00001454                          3346mm     PRINT_CHAR (A0)+,D1
00001454                          3347mm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001454                 TRUE     3348mm     IFEQ DEBUG
00001454  1239 00C00003           3349mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000145A  0801 0002               3350mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000145E  67F4                    3351mm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
00001460  13D8 00C00007           3352mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001466                          3353mm     ENDC
00001466                          3354mm 
00001466                 FALSE    3355mm     IFNE DEBUG
00001466                          3356mm     ENDC
00001466                          3357mm 
00001466                          3358mm     ENDM
00001466  60E4                    3359m     BRA LOOP_248
00001468                          3360m EXIT_248
00001468                          3361m     ENDM
00001468                          3362  
00001468  6000 0022               3363      BRA CONTINUE    
0000146C                          3364  WRITE
0000146C  41FA 0393               3365      LEA WRITING(PC),A0
00001470                          3366m     PRINT_STR A0,D1
00001470                          3367m LOOP_250
00001470  0C10 0000               3368m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001474  6700 0016               3369m     BEQ EXIT_250
00001478                          3370mm     PRINT_CHAR (A0)+,D1
00001478                          3371mm WAIT_FOR_READY_251                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001478                 TRUE     3372mm     IFEQ DEBUG
00001478  1239 00C00003           3373mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000147E  0801 0002               3374mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001482  67F4                    3375mm         BEQ WAIT_FOR_READY_251                      ; NO SPACE, CHECK AGAIN
00001484  13D8 00C00007           3376mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000148A                          3377mm     ENDC
0000148A                          3378mm 
0000148A                 FALSE    3379mm     IFNE DEBUG
0000148A                          3380mm     ENDC
0000148A                          3381mm 
0000148A                          3382mm     ENDM
0000148A  60E4                    3383m     BRA LOOP_250
0000148C                          3384m EXIT_250
0000148C                          3385m     ENDM
0000148C                          3386  
0000148C                          3387  CONTINUE
0000148C  222F 0002               3388      MOVE.L 2(SP),D1
00001490                          3389m     PRINT_REG D1,D2,D3,D4,A0
00001490  41FA 0332               3390m     LEA OX(PC),A0
00001494                          3391mm     PRINT_STR A0,D2
00001494                          3392mm LOOP_253
00001494  0C10 0000               3393mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001498  6700 0016               3394mm     BEQ EXIT_253
0000149C                          3395mmm     PRINT_CHAR (A0)+,D2
0000149C                          3396mmm WAIT_FOR_READY_254                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000149C                 TRUE     3397mmm     IFEQ DEBUG
0000149C  1439 00C00003           3398mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014A2  0802 0002               3399mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014A6  67F4                    3400mmm         BEQ WAIT_FOR_READY_254                      ; NO SPACE, CHECK AGAIN
000014A8  13D8 00C00007           3401mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014AE                          3402mmm     ENDC
000014AE                          3403mmm 
000014AE                 FALSE    3404mmm     IFNE DEBUG
000014AE                          3405mmm     ENDC
000014AE                          3406mmm 
000014AE                          3407mmm     ENDM
000014AE  60E4                    3408mm     BRA LOOP_253
000014B0                          3409mm EXIT_253
000014B0                          3410mm     ENDM
000014B0  7807                    3411m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014B2                          3412m LOOP_252
000014B2                          3413mm     BIN2HEX D1,D3,A0
000014B2  41FA 02CF               3414mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000014B6  E999                    3415mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014B8  1601                    3416mm     MOVE.B D1,D3
000014BA  0283 0000000F           3417mm     ANDI.L #$F,D3
000014C0  1630 3000               3418mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000014C4                          3419mm     ENDM
000014C4                          3420mm     PRINT_CHAR D3,D2
000014C4                          3421mm WAIT_FOR_READY_256                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014C4                 TRUE     3422mm     IFEQ DEBUG
000014C4  1439 00C00003           3423mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014CA  0802 0002               3424mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014CE  67F4                    3425mm         BEQ WAIT_FOR_READY_256                      ; NO SPACE, CHECK AGAIN
000014D0  13C3 00C00007           3426mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014D6                          3427mm     ENDC
000014D6                          3428mm 
000014D6                 FALSE    3429mm     IFNE DEBUG
000014D6                          3430mm     ENDC
000014D6                          3431mm 
000014D6                          3432mm     ENDM
000014D6  57CC FFDA               3433m     DBEQ D4,LOOP_252
000014DA                          3434m     ENDM
000014DA                          3435  
000014DA  41FA 032E               3436      LEA FROM(PC),A0
000014DE                          3437m     PRINT_STR A0,D0
000014DE                          3438m LOOP_257
000014DE  0C10 0000               3439m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000014E2  6700 0016               3440m     BEQ EXIT_257
000014E6                          3441mm     PRINT_CHAR (A0)+,D0
000014E6                          3442mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014E6                 TRUE     3443mm     IFEQ DEBUG
000014E6  1039 00C00003           3444mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000014EC  0800 0002               3445mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000014F0  67F4                    3446mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
000014F2  13D8 00C00007           3447mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014F8                          3448mm     ENDC
000014F8                          3449mm 
000014F8                 FALSE    3450mm     IFNE DEBUG
000014F8                          3451mm     ENDC
000014F8                          3452mm 
000014F8                          3453mm     ENDM
000014F8  60E4                    3454m     BRA LOOP_257
000014FA                          3455m EXIT_257
000014FA                          3456m     ENDM
000014FA                          3457  
000014FA  222F 000A               3458      MOVE.L 10(SP),D1
000014FE                          3459m     PRINT_REG D1,D2,D3,D4,A0
000014FE  41FA 02C4               3460m     LEA OX(PC),A0
00001502                          3461mm     PRINT_STR A0,D2
00001502                          3462mm LOOP_260
00001502  0C10 0000               3463mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001506  6700 0016               3464mm     BEQ EXIT_260
0000150A                          3465mmm     PRINT_CHAR (A0)+,D2
0000150A                          3466mmm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000150A                 TRUE     3467mmm     IFEQ DEBUG
0000150A  1439 00C00003           3468mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001510  0802 0002               3469mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001514  67F4                    3470mmm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
00001516  13D8 00C00007           3471mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000151C                          3472mmm     ENDC
0000151C                          3473mmm 
0000151C                 FALSE    3474mmm     IFNE DEBUG
0000151C                          3475mmm     ENDC
0000151C                          3476mmm 
0000151C                          3477mmm     ENDM
0000151C  60E4                    3478mm     BRA LOOP_260
0000151E                          3479mm EXIT_260
0000151E                          3480mm     ENDM
0000151E  7807                    3481m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001520                          3482m LOOP_259
00001520                          3483mm     BIN2HEX D1,D3,A0
00001520  41FA 0261               3484mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001524  E999                    3485mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001526  1601                    3486mm     MOVE.B D1,D3
00001528  0283 0000000F           3487mm     ANDI.L #$F,D3
0000152E  1630 3000               3488mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001532                          3489mm     ENDM
00001532                          3490mm     PRINT_CHAR D3,D2
00001532                          3491mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001532                 TRUE     3492mm     IFEQ DEBUG
00001532  1439 00C00003           3493mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001538  0802 0002               3494mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000153C  67F4                    3495mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
0000153E  13C3 00C00007           3496mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001544                          3497mm     ENDC
00001544                          3498mm 
00001544                 FALSE    3499mm     IFNE DEBUG
00001544                          3500mm     ENDC
00001544                          3501mm 
00001544                          3502mm     ENDM
00001544  57CC FFDA               3503m     DBEQ D4,LOOP_259
00001548                          3504m     ENDM
00001548                          3505m     PRINT_CRLF D0,A0
00001548  41FA 0274               3506m     LEA CRLF(PC),A0
0000154C                          3507mm     PRINT_STR A0,D0
0000154C                          3508mm LOOP_265
0000154C  0C10 0000               3509mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001550  6700 0016               3510mm     BEQ EXIT_265
00001554                          3511mmm     PRINT_CHAR (A0)+,D0
00001554                          3512mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001554                 TRUE     3513mmm     IFEQ DEBUG
00001554  1039 00C00003           3514mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000155A  0800 0002               3515mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000155E  67F4                    3516mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
00001560  13D8 00C00007           3517mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001566                          3518mmm     ENDC
00001566                          3519mmm 
00001566                 FALSE    3520mmm     IFNE DEBUG
00001566                          3521mmm     ENDC
00001566                          3522mmm 
00001566                          3523mmm     ENDM
00001566  60E4                    3524mm     BRA LOOP_265
00001568                          3525mm EXIT_265
00001568                          3526mm     ENDM
00001568                          3527m     ENDM
00001568                          3528      
00001568  207C 00000004           3529      MOVE.L #4,A0
0000156E  4ED0                    3530      JMP (A0)
00001570                          3531          
00001570                          3532  ILLEGAL_HANDLER
00001570  13FC 0007 00E00001      3533      MOVE.B #7,DISPLAY   
00001578                          3534      
00001578  207C 00000004           3535      MOVE.L #4,A0
0000157E  4ED0                    3536      JMP (A0)
00001580                          3537          
00001580                          3538  UNHANDLED_HANDLER
00001580  41FA 028F               3539      LEA UNHANDLED(PC),A0
00001584  4EF9 000015A8           3540      JMP PRINTIT_RTE
0000158A                          3541      
0000158A                          3542  UNINITIALISED_HANDLER
0000158A  41FA 029B               3543      LEA UNINITIALISED(PC),A0
0000158E  4EF9 000015A8           3544      JMP PRINTIT_RTE
00001594                          3545  
00001594                          3546  TICK_HANDLER
00001594  1039 00C0001F           3547      MOVE.B DUART_RESET_OPR,D0
0000159A  41FA 0240               3548      LEA TICK(PC),A0
0000159E  4EF9 000015A8           3549      JMP PRINTIT_RTE
000015A4                          3550  
000015A4                          3551  SPURIOUS_HANDLER
000015A4  41FA 02A1               3552      LEA SPURIOUS(PC),A0
000015A8                          3553  PRINTIT_RTE
000015A8                          3554m     PRINT_STR A0,D1
000015A8                          3555m LOOP_267
000015A8  0C10 0000               3556m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000015AC  6700 0016               3557m     BEQ EXIT_267
000015B0                          3558mm     PRINT_CHAR (A0)+,D1
000015B0                          3559mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015B0                 TRUE     3560mm     IFEQ DEBUG
000015B0  1239 00C00003           3561mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000015B6  0801 0002               3562mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000015BA  67F4                    3563mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
000015BC  13D8 00C00007           3564mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015C2                          3565mm     ENDC
000015C2                          3566mm 
000015C2                 FALSE    3567mm     IFNE DEBUG
000015C2                          3568mm     ENDC
000015C2                          3569mm 
000015C2                          3570mm     ENDM
000015C2  60E4                    3571m     BRA LOOP_267
000015C4                          3572m EXIT_267
000015C4                          3573m     ENDM
000015C4  4E73                    3574      RTE 
000015C6                          3575      
000015C6  FFFF FFFF               3576      SIMHALT                                             ; halt simulator
000015CA                          3577  
000015CA                          3578  ; strings
000015CA= 50 72 65 73 73 20 ...   3579  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
000015DD= 5B 3F 5D 09 09 09 ...   3580  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
000015E9= 5B 76 5D 09 09 09 ...   3581          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
000015F8= 78 78 78 78 78 78 ...   3582          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001610= 78 78 78 78 78 78 ...   3583          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001630= 78 78 78 78 78 78 ...   3584          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001651= 78 78 78 78 78 78 ...   3585          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001662= 5B 7A 5D 09 09 09 ...   3586          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001674= 78 78 78 78 78 78 ...   3587          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,TAB,'load to EEPROM',CR,LF
00001699= 78 78 78 78 78 78 ...   3588          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,TAB,'patch EEPROM',CR,LF
000016BC= 23 09 09 09 77 72 ...   3589          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
000016D6= 5B 78 5D 09 09 09 ...   3590          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
000016ED= 5B 69 5D 09 09 09 ...   3591          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001706= 5B 6F 5D 09 09 09 ...   3592          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
00001721= 48 75 68 3F 0D 0A 00    3593  HUH  DC.B 'Huh?',CR,LF,NULL
00001728= 20 53 20 72 65 63 ...   3594  READ    DC.B ' S records read, start address = ',NULL
0000174A= 57 3A 20 55 6E 6B ...   3595  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001761= 21 20 43 53 20 66 ...   3596  CS_FAILURE  DC.B '! CS failure at ',NULL
00001772= 21 20 52 41 4D 20 ...   3597  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001783= 30 31 32 33 34 35 ...   3598  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001793= 00 01 02 03 04 05 ...   3599  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000017AA= 4C 6F 61 64 69 6E ...   3600  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000017BE= 0D 0A 00                3601  CRLF    DC.B CR,LF,NULL
000017C1= 3E 20 00                3602  PROMPT  DC.B '> ',NULL
000017C4= 30 78 00                3603  ox      DC.B '0x',NULL
000017C7= 20 2D 3E 20 00          3604  to      DC.B ' -> ',NULL
000017CC= 20 66 6F 72 20 00       3605  for     DC.B ' for ',NULL
000017D2= 53 50 3A 20 00          3606  STACK_POINTER DC.B 'SP: ',NULL
000017D7= 53 52 3A 20 00          3607  STATUS_REGISTER DC.B 'SR: ',NULL
000017DC= 74 69 63 6B 0D 0A 00    3608  TICK DC.B 'tick',CR,LF,NULL
000017E3= 2A 20 42 75 73 2F ...   3609  BUS_ERROR DC.B '* Bus/address error ',NULL
000017F8= 72 65 61 64 69 6E ...   3610  READING DC.B 'reading ',NULL
00001801= 77 72 69 74 69 6E ...   3611  WRITING DC.B 'writing ',NULL
0000180A= 20 66 72 6F 6D 20 00    3612  FROM DC.B ' from ',NULL
00001811= 2A 20 55 6E 68 61 ...   3613  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001827= 2A 20 20 55 6E 69 ...   3614  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
00001847= 2A 20 53 70 75 72 ...   3615  SPURIOUS DC.B '* Spurious interrupt',NULL
0000185C= 4D 44 46 2D 6D 6F ...   3616  VERSION DC.B 'MDF-mon V1.130 (30/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
0000187A= 00                      3617  END     DC.B 0
0000187B                          3618      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1783
BUS_ERROR           17E3
BUS_ERROR_HANDLER   141C
CONTINUE            148C
CONTINUE_113        B04
CONTINUE_54         5E0
CONTINUE_57         630
CONTINUE_61         686
CONTINUE_69         73A
CONTINUE_74         7AC
CONTINUE_79         828
CONTINUE_84         8A6
CONTINUE_89         92E
CONTINUE_94         9A0
CONTINUE_99         A12
CR                  D
CRLF                17BE
CS_FAILURE          1761
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C0E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 187A
EXIT_10             288
EXIT_104            A84
EXIT_106            AA4
EXIT_110            AD6
EXIT_118            B6C
EXIT_120            B94
EXIT_123            BB4
EXIT_128            BFE
EXIT_131            C2E
EXIT_135            C78
EXIT_138            C9A
EXIT_143            CE4
EXIT_145            D60
EXIT_148            D84
EXIT_15             2D2
EXIT_153            DCE
EXIT_160            E60
EXIT_163            ED0
EXIT_165            EF0
EXIT_168            F12
EXIT_17             2F2
EXIT_172            F5C
EXIT_175            F7E
EXIT_179            FC8
EXIT_182            FE8
EXIT_187            1032
EXIT_20             312
EXIT_202            1154
EXIT_205            11B8
EXIT_208            11D8
EXIT_212            1222
EXIT_215            1244
EXIT_22             33C
EXIT_220            128E
EXIT_224            12D0
EXIT_227            12F2
EXIT_232            133C
EXIT_234            135C
EXIT_237            137E
EXIT_242            13C8
EXIT_246            143C
EXIT_248            1468
EXIT_250            148C
EXIT_253            14B0
EXIT_257            14FA
EXIT_260            151E
EXIT_265            1568
EXIT_267            15C4
EXIT_28             3C8
EXIT_30             438
EXIT_32             464
EXIT_35             48E
EXIT_45             53C
EXIT_5              240
EXIT_52             5B2
EXIT_66             6F6
EXIT_7              260
FOR                 17CC
FROM                180A
G                   CE8
GET_INPUT           33C
H                   43C
HASH                13EC
HELP                15DD
HELPPROMPT          15CA
HEX2BIN             10B
HEX2BIN_LUT         1793
HEX_DIGIT           1402
HUH                 1721
I                   13CC
ILLEGAL_HANDLER     1570
L                   DDE
LF                  A
LOADING             17AA
LOOP_10             26C
LOOP_104            A68
LOOP_106            A88
LOOP_110            ABA
LOOP_118            B50
LOOP_120            B78
LOOP_122            BB6
LOOP_123            B98
LOOP_128            BE2
LOOP_130            C30
LOOP_131            C12
LOOP_135            C5C
LOOP_137            C9C
LOOP_138            C7E
LOOP_143            CC8
LOOP_145            D44
LOOP_147            D86
LOOP_148            D68
LOOP_15             2B6
LOOP_153            DB2
LOOP_160            E44
LOOP_163            EB4
LOOP_165            ED4
LOOP_167            F14
LOOP_168            EF6
LOOP_17             2D6
LOOP_172            F40
LOOP_174            F80
LOOP_175            F62
LOOP_179            FAC
LOOP_181            FEA
LOOP_182            FCC
LOOP_187            1016
LOOP_20             2F6
LOOP_202            1138
LOOP_205            119C
LOOP_207            11DA
LOOP_208            11BC
LOOP_212            1206
LOOP_214            1246
LOOP_215            1228
LOOP_22             320
LOOP_220            1272
LOOP_224            12B4
LOOP_226            12F4
LOOP_227            12D6
LOOP_232            1320
LOOP_234            1340
LOOP_236            1380
LOOP_237            1362
LOOP_242            13AC
LOOP_246            1420
LOOP_248            144C
LOOP_250            1470
LOOP_252            14B2
LOOP_253            1494
LOOP_257            14DE
LOOP_259            1520
LOOP_260            1502
LOOP_265            154C
LOOP_267            15A8
LOOP_28             3AC
LOOP_30             41C
LOOP_32             448
LOOP_34             490
LOOP_35             472
LOOP_45             520
LOOP_5              224
LOOP_52             596
LOOP_66             6DA
LOOP_7              244
LOOP_9              28A
MAIN_LOOP           31C
NULL                0
O                   13DC
OX                  17C4
P                   10E0
PRINTIT             448
PRINTIT_RTE         15A8
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              17C1
PROTECT             A40
R                   468
RAM                 200000
RAM_ERROR           1772
READ                1728
READING             17F8
READ_CHAR           62D
RESET               4
ROM                 0
S                   5BC
SPURIOUS            1847
SPURIOUS_HANDLER    15A4
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       17D2
START               104
STATUS_REGISTER     17D7
TAB                 9
TICK                17DC
TICK_HANDLER        1594
TO                  17C7
UNHANDLED           1811
UNHANDLED_HANDLER   1580
UNINITIALISED       1827
UNINITIALISED_HANDLER  158A
UNPROTECT           979
UNREC               174A
USER                100
V                   444
VECS                8
VERSION             185C
W                   540
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_189  1044
WAIT_FOR_COMPLETE_191  1066
WAIT_FOR_COMPLETE_192  1078
WAIT_FOR_COMPLETE_194  10A6
WAIT_FOR_COMPLETE_195  10B8
WAIT_FOR_COMPLETE_222  1290
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A2A
WAIT_FOR_READY_105  A70
WAIT_FOR_READY_107  A90
WAIT_FOR_READY_108  AA4
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AC2
WAIT_FOR_READY_113  AE8
WAIT_FOR_READY_115  B1C
WAIT_FOR_READY_119  B58
WAIT_FOR_READY_121  B80
WAIT_FOR_READY_124  BA0
WAIT_FOR_READY_126  BC8
WAIT_FOR_READY_129  BEA
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_132  C1A
WAIT_FOR_READY_134  C42
WAIT_FOR_READY_136  C64
WAIT_FOR_READY_139  C86
WAIT_FOR_READY_141  CAE
WAIT_FOR_READY_144  CD0
WAIT_FOR_READY_146  D4C
WAIT_FOR_READY_149  D70
WAIT_FOR_READY_151  D98
WAIT_FOR_READY_154  DBA
WAIT_FOR_READY_155  DEC
WAIT_FOR_READY_157  E06
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E4C
WAIT_FOR_READY_164  EBC
WAIT_FOR_READY_166  EDC
WAIT_FOR_READY_169  EFE
WAIT_FOR_READY_171  F26
WAIT_FOR_READY_173  F48
WAIT_FOR_READY_176  F6A
WAIT_FOR_READY_178  F92
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  FB4
WAIT_FOR_READY_183  FD4
WAIT_FOR_READY_185  FFC
WAIT_FOR_READY_188  101E
WAIT_FOR_READY_197  10EC
WAIT_FOR_READY_199  1106
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_203  1140
WAIT_FOR_READY_206  11A4
WAIT_FOR_READY_209  11C4
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  11EC
WAIT_FOR_READY_213  120E
WAIT_FOR_READY_216  1230
WAIT_FOR_READY_218  1258
WAIT_FOR_READY_221  127A
WAIT_FOR_READY_225  12BC
WAIT_FOR_READY_228  12DE
WAIT_FOR_READY_23   328
WAIT_FOR_READY_230  1306
WAIT_FOR_READY_233  1328
WAIT_FOR_READY_235  1348
WAIT_FOR_READY_238  136A
WAIT_FOR_READY_24   33C
WAIT_FOR_READY_240  1392
WAIT_FOR_READY_243  13B4
WAIT_FOR_READY_247  1428
WAIT_FOR_READY_249  1454
WAIT_FOR_READY_251  1478
WAIT_FOR_READY_254  149C
WAIT_FOR_READY_256  14C4
WAIT_FOR_READY_258  14E6
WAIT_FOR_READY_26   356
WAIT_FOR_READY_261  150A
WAIT_FOR_READY_263  1532
WAIT_FOR_READY_266  1554
WAIT_FOR_READY_268  15B0
WAIT_FOR_READY_29   3B4
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_31   424
WAIT_FOR_READY_33   450
WAIT_FOR_READY_36   47A
WAIT_FOR_READY_38   4A2
WAIT_FOR_READY_39   4B8
WAIT_FOR_READY_40   4CE
WAIT_FOR_READY_41   4E2
WAIT_FOR_READY_42   4F6
WAIT_FOR_READY_43   50A
WAIT_FOR_READY_46   528
WAIT_FOR_READY_47   54A
WAIT_FOR_READY_49   564
WAIT_FOR_READY_53   59E
WAIT_FOR_READY_54   5C4
WAIT_FOR_READY_56   5FE
WAIT_FOR_READY_57   614
WAIT_FOR_READY_59   648
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   66A
WAIT_FOR_READY_63   69E
WAIT_FOR_READY_67   6E2
WAIT_FOR_READY_69   71E
WAIT_FOR_READY_71   752
WAIT_FOR_READY_74   790
WAIT_FOR_READY_76   7C4
WAIT_FOR_READY_79   80C
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_81   840
WAIT_FOR_READY_84   88A
WAIT_FOR_READY_86   8BE
WAIT_FOR_READY_89   912
WAIT_FOR_READY_91   946
WAIT_FOR_READY_94   984
WAIT_FOR_READY_96   9B8
WAIT_FOR_READY_99   9F6
WAIT_FOR_SRECORD    5C4
WRITE               146C
WRITING             1801
X                   12B0
Z                   CEE
_00000000           218
_00000001           37C
_00000002           390
_00000003           6FE
_00000004           ADA
_00000005           70C
_00000006           8FA
_00000007           870
_00000008           ADA
_00000009           A64
_0000000A           ADA
_0000000B           C02
_0000000C           C0E
_0000000D           DCE
_0000000E           104E
_0000000F           1070
_00000010           1082
_00000011           10B0
_00000012           10C2
_00000013           129A
_10000000           660
_10000001           6C8
_10000002           714
_10000003           77C
_10000004           786
_10000005           7EE
_10000006           802
_10000007           86A
_10000008           874
_10000009           8F4
_1000000A           880
_1000000B           8E8
_1000000C           908
_1000000D           970
_1000000E           97A
_1000000F           9E2
_10000010           9EC
_10000011           A54
_10000012           ADE
_10000013           B46
_10000014           1032
_10000015           1054
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           548
_20000005           58C
_20000006           D00
_20000007           D10
_20000008           D2A
_20000009           DD0
_2000000A           DEA
_2000000B           E2E
_2000000C           EA6
_2000000D           EAA
_2000000E           108A
_2000000F           10C4
_20000010           10EA
_20000011           112E
_20000012           118E
_20000013           1192
