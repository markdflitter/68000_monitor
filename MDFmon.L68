00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/09/2021 19:24:15

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor 
00000000                             6  
00000000                             7  *-----------------------------------------------------------
00000000                             8  
00000000                             9      ORG  $0
00000000                            10  
00000000  =00000000                 11  DEBUG               EQU 0
00000000                            12  
00000000                            13  ; constants
00000000  =00000000                 14  NULL                EQU 0
00000000  =00000009                 15  TAB                 EQU 9
00000000  =0000000D                 16  CR                  EQU 13
00000000  =0000000A                 17  LF                  EQU 10
00000000                            18  
00000000  =00000000                 19  ROM                 EQU $0
00000000  =00200000                 20  RAM                 EQU $200000
00000000  =002E0000                 21  STACK_ADDRESS       EQU $2E0000
00000000                            22  
00000000  =00A00000                 23  MC68230_BASE        EQU $A00000
00000000  =00000000                 24  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 25  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 26  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 27  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 28  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 29  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 30  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 31  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 32  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 33  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 34  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 35  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 36  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 37  MC68230_STATUS_             EQU $D
00000000                            38  
00000000  =00A00001                 39  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 40  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 41  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 42  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 43  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 44  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 45  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            46  
00000000  =00A0000B                 47  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 48  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 49  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 50  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 51  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 52  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 53  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 54  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 55  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 56  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 57  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 58  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            59  
00000000  =00000020                 60  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 61  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 62  MC68230_PORT_C_CS           EQU $08
00000000                            63  
00000000  =00000000                 64  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 65  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 66  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 67  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 68  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 69  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 70  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            71  
00000000  =00000007                 72  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 73  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            74  
00000000  =00000007                 75  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 76  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 77  IDE_STATUS_READY            EQU 6
00000000  =00000003                 78  IDE_STATUS_DRQ              EQU 3
00000000                            79  
00000000  =00C00000                 80  DUART_BASE          EQU $C00000
00000000  =00000000                 81  DUART_MRA_          EQU $0
00000000  =00000001                 82  DUART_CSRA_         EQU $1
00000000  =00000001                 83  DUART_SRA_          EQU $1
00000000  =00000002                 84  DUART_CRA_          EQU $2
00000000  =00000003                 85  DUART_TXA_          EQU $3
00000000  =00000003                 86  DUART_RXA_          EQU $3
00000000  =00000004                 87  DUART_ACR_          EQU $4
00000000  =00000005                 88  DUART_IMR_          EQU $5
00000000  =00000006                 89  DUART_CTUR_         EQU $6
00000000  =00000007                 90  DUART_CTLR_         EQU $7
00000000  =00000008                 91  DUART_MRB_          EQU $8
00000000  =00000009                 92  DUART_CSRB_         EQU $9
00000000  =00000009                 93  DUART_SRB_          EQU $9
00000000  =0000000A                 94  DUART_CRB_          EQU $A
00000000  =0000000B                 95  DUART_TXB_          EQU $B
00000000  =0000000B                 96  DUART_RXB_          EQU $B
00000000  =0000000C                 97  DUART_IVR_          EQU $C
00000000  =0000000D                 98  DUART_OPCR_         EQU $D
00000000  =0000000E                 99  DUART_SET_OPR_      EQU $E
00000000  =0000000F                100  DUART_RESET_OPR_    EQU $F
00000000                           101  
00000000  =00C00001                102  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                103  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                104  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                105  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                106  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                107  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           108  
00000000  =00C00011                109  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                110  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                111  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                112  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                113  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                114  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           115  
00000000  =00C00009                116  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                117  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                118  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                119  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                120  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                121  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                122  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                123  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           124  
00000000  =00E00000                125  DISPLAY_BASE        EQU $E00000
00000000  =00000000                126  DISPLAY_            EQU $0
00000000  =00E00001                127  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           128  
00000000                           129  ; macros
00000000                           130  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           131  ; the input register is changed during the process
00000000                           132  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           133  BIN2HEX MACRO
00000000                           134      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           135      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           136      MOVE.B \1,\2
00000000                           137      ANDI.L #$F,\2
00000000                           138      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           139      ENDM
00000000                           140  
00000000                           141  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           142  ; the input register is changed during the process
00000000                           143  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           144  HEX2BIN MACRO
00000000                           145      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           146      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           147      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           148      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           149      ENDM
00000000                           150  
00000000                           151  ; send a single char to the serial port
00000000                           152  ; \1 = char to send, \2 = data register to use for status poll
00000000                           153  ; will stamp on D0 and D1 in debug mode
00000000                           154  PRINT_CHAR MACRO
00000000                           155  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           156      IFEQ DEBUG
00000000                           157          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           158          BTST #2,\2                                  ; check for space to send
00000000                           159          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           160          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           161      ENDC
00000000                           162  
00000000                           163      IFNE DEBUG
00000000                           164          MOVE.B \1,D1
00000000                           165          MOVE.L #6,D0   
00000000                           166          TRAP #15                                    ; write to terminal in simulator
00000000                           167      ENDC
00000000                           168  
00000000                           169      ENDM
00000000                           170  
00000000                           171  ; send CR,LF to the serial port
00000000                           172  ; \1 = data register to use for status poll, /2 = working address register
00000000                           173  PRINT_CRLF MACRO
00000000                           174      LEA CRLF(PC),\2
00000000                           175      PRINT_STR \2,\1
00000000                           176      ENDM
00000000                           177  
00000000                           178  ; send C-style, zero terminated string to the serial port
00000000                           179  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           180  PRINT_STR MACRO
00000000                           181  LOOP\@
00000000                           182      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           183      BEQ EXIT\@
00000000                           184      PRINT_CHAR (\1)+,\2
00000000                           185      BRA LOOP\@
00000000                           186  EXIT\@
00000000                           187      ENDM
00000000                           188    
00000000                           189  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           190  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           191  PRINT_REG_4BIT MACRO
00000000                           192      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           193      MOVE.B \1,\3
00000000                           194      ANDI.L #$F,\3
00000000                           195      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           196      PRINT_CHAR \3,\2
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           200  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           201  PRINT_REG MACRO
00000000                           202      LEA ox(PC),\5
00000000                           203      PRINT_STR \5,\2
00000000                           204      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           205  LOOP\@
00000000                           206      BIN2HEX \1,\3,\5
00000000                           207      PRINT_CHAR \3,\2
00000000                           208      DBEQ \4,LOOP\@
00000000                           209      ENDM
00000000                           210  
00000000                           211  ; wait for a char from the serial port
00000000                           212  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           213  ; will stamp on D0 and D1 in debug mode
00000000                           214  WAIT_CHAR MACRO
00000000                           215  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           216      IFEQ DEBUG
00000000                           217          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           218          BTST #0,\2                                  ; check for character
00000000                           219          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           220      ENDC
00000000                           221  
00000000                           222      READ_CHAR \1
00000000                           223  
00000000                           224      IFEQ DEBUG
00000000                           225          PRINT_CHAR \1,\2                            ; echo it back
00000000                           226      ENDC
00000000                           227      ENDM
00000000                           228  
00000000                           229  ; read a char from the serial port - assumes that there is one!
00000000                           230  ; \ 1= data register for read char
00000000                           231  ; will stamp on D0 and D1 in debug mode
00000000                           232  READ_CHAR MACRO
00000000                           233      IFEQ DEBUG
00000000                           234          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           235      ENDC
00000000                           236      IFNE DEBUG
00000000                           237          MOVE.L #5,D0    
00000000                           238          TRAP #15                                    ; read from keyboard in simulator
00000000                           239          MOVE.L D1,\1
00000000                           240      ENDC
00000000                           241  
00000000                           242      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           243      BEQ START
00000000                           244      ENDM
00000000                           245  
00000000                           246  
00000000                           247  ; read data from the download serial port
00000000                           248  ; \ 1= data register for read char
00000000                           249  DOWNLOAD MACRO
00000000                           250  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           251  
00000000                           252  ;   MOVE.B DUART_SRA,\1                             ; check for command
00000000                           253  ;   BTST #0,\1                                      ; check for character
00000000                           254  ;   BEQ CONTINUE\@                                  ; nothing, continue
00000000                           255  
00000000                           256  ;   READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           257  CONTINUE\@
00000000                           258  ;   MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           259      MOVE.B DUART_SRA,\1                             ; read download status register
00000000                           260      BTST #0,\1                                      ; check for character
00000000                           261      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           262      
00000000                           263  ;   MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           264      MOVE.B DUART_RXA,\1                             ; got a character, read it
00000000                           265      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           266  
00000000                           267      ENDM
00000000                           268  
00000000                           269  ; read two hex digits from the download serial port and convert to a byte
00000000                           270  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           271  DOWNLOAD_BYTE MACRO
00000000                           272      MOVE.B #2,\4
00000000                           273      WHILE.B \4 <GT> 0 DO
00000000                           274          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           275          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           276          ;PRINT_CHAR \2,\3
00000000                           277          HEX2BIN \2,\2,\6
00000000                           278          OR.B \2,\1
00000000                           279          SUB.B #1,\4
00000000                           280      ENDW
00000000                           281  
00000000                           282      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           283      MOVE.B \1,\2
00000000                           284      ADD.L \1,\5
00000000                           285  
00000000                           286      ENDM
00000000                           287  
00000000                           288  ; unprotect the EEPROM
00000000                           289  UNPROTECT MACRO
00000000                           290      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           291      NOP
00000000                           292      MOVE.W #$5555,$1554
00000000                           293      NOP
00000000                           294      MOVE.W #$8080,$2AAA
00000000                           295      NOP
00000000                           296      MOVE.W #$AAAA,$2AAA
00000000                           297      NOP
00000000                           298      MOVE.W #$5555,$1554
00000000                           299      NOP
00000000                           300      MOVE.W #$2020,$2AAA
00000000                           301      ENDM
00000000                           302      
00000000                           303  ; protect the EEPROM
00000000                           304  PROTECT MACRO
00000000                           305      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           306      MOVE.W #$5555,$1554
00000000                           307      MOVE.W #$A0A0,$2AAA
00000000                           308      ENDM
00000000                           309  ; write word to EEPROM
00000000                           310  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           311  PROGRAM MACRO
00000000                           312    MOVE.W \1,\2                                      ; write the data
00000000                           313  
00000000                           314  WAIT_FOR_COMPLETE\@
00000000                           315          MOVE.W \2,\3
00000000                           316  
00000000                           317          IF.W \3 <NE> \1 THEN
00000000                           318              BRA WAIT_FOR_COMPLETE\@
00000000                           319          ENDI
00000000                           320          ENDM
00000000                           321          
00000000                           322  ; program vector to EEPROM
00000000                           323  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           324  PROGRAM_VECTOR MACRO
00000000                           325      ADD.L #2,\2
00000000                           326      PROGRAM \1, (\2), \3                            ; write it
00000000                           327      LSR.L #8,\1
00000000                           328      LSR.L #8,\1
00000000                           329      SUB.L #2,\2
00000000                           330      PROGRAM \1, (\2), \3
00000000                           331      ENDM
00000000                           332  
00000000                           333  ; read an ide register
00000000                           334  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           335  READ_8 MACRO
00000000                           336      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           337      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           338      ORI.B \1, \3
00000000                           339      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           340      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           341      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           342      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           343      ORI.B #MC68230_PORT_C_READ, \3
00000000                           344      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           345      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           346      ENDM
00000000                           347      
00000000                           348  ; write an ide register
00000000                           349  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           350  WRITE_8 MACRO
00000000                           351      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           352      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           353      ORI.B \2, \3
00000000                           354      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           355      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           356      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           357      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           358      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           359      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           360      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           361      ENDM
00000000                           362  
00000000                           363  ; read ide data
00000000                           364  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           365  READ_16 MACRO
00000000                           366      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           367      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           368      
00000000                           369      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           370      ORI.B \1, \3
00000000                           371      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           372      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           373      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           374      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           375      LSL.W #8, \2
00000000                           376      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           377      ORI.B #MC68230_PORT_C_READ, \3
00000000                           378      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           379      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           380      ENDM
00000000                           381      
00000000                           382  ; read ide data
00000000                           383  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           384  READ_32 MACRO
00000000                           385      READ_16 \1, \2, \3
00000000                           386      LSL.L #8, \2
00000000                           387      LSL.L #8, \2
00000000                           388      READ_16 \1, \2, \3
00000000                           389      ENDM
00000000                           390          
00000000                           391  ; read ide status
00000000                           392  ;\1 = data register for result, \2 = working data register 
00000000                           393  READ_IDE_STATUS MACRO   
00000000                           394      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           395      ENDM
00000000                           396      
00000000                           397  ; wait for ide drive to be ready
00000000                           398  ;\1 = working data register 1, \2 = working data register 2
00000000                           399  WAIT_DRIVE_READY MACRO
00000000                           400  LOOP\@
00000000                           401      READ_IDE_STATUS \1, \2
00000000                           402      BTST #IDE_STATUS_READY, \1
00000000                           403      BEQ LOOP\@
00000000                           404      ENDM
00000000                           405      
00000000                           406  ; wait for ide drive to be not busy
00000000                           407  ;\1 = working data register 1, \2 = working data register 2
00000000                           408  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           409  LOOP\@
00000000                           410      READ_IDE_STATUS \1, \2
00000000                           411      BTST #IDE_STATUS_BUSY, \1
00000000                           412      BNE LOOP\@
00000000                           413      ENDM
00000000                           414      
00000000                           415  ; wait for ide drive to have data for us
00000000                           416  ;\1 = working data register 1, \2 = working data register 2
00000000                           417  WAIT_DRIVE_DRQ MACRO
00000000                           418  LOOP\@
00000000                           419      READ_IDE_STATUS \1, \2
00000000                           420      BTST #IDE_STATUS_DRQ, \1
00000000                           421      BEQ LOOP\@
00000000                           422      ENDM
00000000                           423      
00000000                           424  ; prepare to send a read command
00000000                           425  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           426  SET_READ_ADDRESS MACRO
00000000                           427      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           428      MOVE.L \1,\3
00000000                           429      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           430      LSR.L #8, \3
00000000                           431      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           432      LSR.L #8, \3                                
00000000                           433      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           434      LSR.L #8, \3
00000000                           435      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           436      ANDI.B #$0F,\3
00000000                           437      OR.B \3,\4
00000000                           438      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           439      ENDM
00000000                           440  
00000000                           441  ; send command
00000000                           442  ; \1 = command, \2 = working data register 1,
00000000                           443  SEND_COMMAND MACRO
00000000                           444      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           445      ENDM
00000000                           446      
00000000                           447  ; send read command and wait
00000000                           448  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           449  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           450      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           451      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           452      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           453      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           454      WAIT_DRIVE_DRQ \2, \3
00000000                           455      ENDM
00000000                           456  
00000000                           457  ; register catalogue
00000000                           458  ; D0 - used for simulator I/O
00000000                           459  ; D1 - used for simulator I/O
00000000                           460  ; D2 - read character
00000000                           461  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           462  ; D6 - working register used in R/W
00000000                           463  ; D7 - address accumulator, reset by download
00000000                           464  ; A0 - address of string to print 
00000000                           465  
00000000                           466  ; start vector
00000000= 002E0000                 467  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 468  RESET   DC.L START                              ; RESET
00000008= 00001C04                 469  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001C04                 470          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001D58                 471          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001D68                 472          DC.L UNHANDLED_HANDLER
00000018= 00001D68                 473          DC.L UNHANDLED_HANDLER
0000001C= 00001D68                 474          DC.L UNHANDLED_HANDLER
00000020= 00001D68                 475          DC.L UNHANDLED_HANDLER
00000024= 00001D68                 476          DC.L UNHANDLED_HANDLER
00000028= 00001D68                 477          DC.L UNHANDLED_HANDLER
0000002C= 00001D68                 478          DC.L UNHANDLED_HANDLER
00000030= 00001D68                 479          DC.L UNHANDLED_HANDLER
00000034= 00001D68                 480          DC.L UNHANDLED_HANDLER
00000038= 00001D68                 481          DC.L UNHANDLED_HANDLER
0000003C= 00001D68                 482          DC.L UNHANDLED_HANDLER
00000040= 00001D68                 483          DC.L UNHANDLED_HANDLER
00000044= 00001D68                 484          DC.L UNHANDLED_HANDLER
00000048= 00001D68                 485          DC.L UNHANDLED_HANDLER
0000004C= 00001D68                 486          DC.L UNHANDLED_HANDLER
00000050= 00001D68                 487          DC.L UNHANDLED_HANDLER
00000054= 00001D68                 488          DC.L UNHANDLED_HANDLER
00000058= 00001D68                 489          DC.L UNHANDLED_HANDLER
0000005C= 00001D68                 490          DC.L UNHANDLED_HANDLER
00000060= 00001D8C                 491          DC.L SPURIOUS_HANDLER
00000064= 00001D68                 492          DC.L UNHANDLED_HANDLER
00000068= 00001D68                 493          DC.L UNHANDLED_HANDLER
0000006C= 00001D68                 494          DC.L UNHANDLED_HANDLER
00000070= 00001D68                 495          DC.L UNHANDLED_HANDLER
00000074= 00001D68                 496          DC.L UNHANDLED_HANDLER
00000078= 00001D68                 497          DC.L UNHANDLED_HANDLER
0000007C= 00001D68                 498          DC.L UNHANDLED_HANDLER
00000080= 00001D68                 499          DC.L UNHANDLED_HANDLER
00000084= 00001D68                 500          DC.L UNHANDLED_HANDLER
00000088= 00001D68                 501          DC.L UNHANDLED_HANDLER
0000008C= 00001D68                 502          DC.L UNHANDLED_HANDLER
00000090= 00001D68                 503          DC.L UNHANDLED_HANDLER
00000094= 00001D68                 504          DC.L UNHANDLED_HANDLER
00000098= 00001D68                 505          DC.L UNHANDLED_HANDLER
0000009C= 00001D68                 506          DC.L UNHANDLED_HANDLER
000000A0= 00001D68                 507          DC.L UNHANDLED_HANDLER
000000A4= 00001D68                 508          DC.L UNHANDLED_HANDLER
000000A8= 00001D68                 509          DC.L UNHANDLED_HANDLER
000000AC= 00001D68                 510          DC.L UNHANDLED_HANDLER
000000B0= 00001D68                 511          DC.L UNHANDLED_HANDLER
000000B4= 00001D68                 512          DC.L UNHANDLED_HANDLER
000000B8= 00001D68                 513          DC.L UNHANDLED_HANDLER
000000BC= 00001D68                 514          DC.L UNHANDLED_HANDLER
000000C0= 00001D68                 515          DC.L UNHANDLED_HANDLER
000000C4= 00001D68                 516          DC.L UNHANDLED_HANDLER
000000C8= 00001D68                 517          DC.L UNHANDLED_HANDLER
000000CC= 00001D68                 518          DC.L UNHANDLED_HANDLER
000000D0= 00001D68                 519          DC.L UNHANDLED_HANDLER
000000D4= 00001D68                 520          DC.L UNHANDLED_HANDLER
000000D8= 00001D68                 521          DC.L UNHANDLED_HANDLER 
000000DC= 00001D68                 522          DC.L UNHANDLED_HANDLER
000000E0= 00001D68                 523          DC.L UNHANDLED_HANDLER
000000E4= 00001D68                 524          DC.L UNHANDLED_HANDLER 
000000E8= 00001D68                 525          DC.L UNHANDLED_HANDLER 
000000EC= 00001D68                 526          DC.L UNHANDLED_HANDLER
000000F0= 00001D68                 527          DC.L UNHANDLED_HANDLER 
000000F4= 00001D68                 528          DC.L UNHANDLED_HANDLER 
000000F8= 00001D68                 529          DC.L UNHANDLED_HANDLER 
000000FC= 00001D68                 530          DC.L UNHANDLED_HANDLER
00000100= 00001D7C                 531  USER    DC.L TICK_HANDLER
00000104                           532      ; start of program  
00000104                           533  START
00000104  2E7C 002E0000            534      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       535      MOVE.B #0,DISPLAY
00000112                           536  
00000112  7000                     537      MOVE.L #0,D0
00000114  1039 00C00019            538      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           539  
0000011A                           540  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       541      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       542      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           543      
0000012A                           544      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000132  13C1 00C00005            545          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     546          NOP
0000013A                           547      ENDF
00000144                           548  
00000144                           549      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000014C  13C1 00C00015            550          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     551          NOP
00000154                           552      ENDF
0000015E                           553      
0000015E                           554  ;initialise UART
0000015E  13FC 0000 00C0000B       555      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       556      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       557      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       558      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       559      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           560  
00000186                           561  ; channel A
00000186  13FC 0013 00C00001       562      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       563      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       564      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       565      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           566  
000001A6                           567  ; channel B
000001A6  13FC 0013 00C00011       568      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       569      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       570      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       571      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       572      MOVE.B #64,DUART_IVR
000001CE                           573  
000001CE                           574m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001E2                           575m     PRINT_CHAR #0,D1
000001F6                           576m     PRINT_CHAR #0,D1
0000020A                           577      
0000020A                           578      IF D0 <EQ> #$0F THEN
00000212  1039 00C00005            579          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           580      ENDI
00000218                           581  
00000218  13FC 0001 00E00001       582      MOVE.B #1,DISPLAY
00000220                           583      
00000220                           584m     PRINT_CRLF D1,A0
00000240  41FA 1E4A                585      LEA VERSION(PC),A0
00000244                           586m     PRINT_STR A0,D3
00000260                           587  
00000260  41F9 000020AA            588      LEA END,A0
00000266  2008                     589      MOVE.L A0,D0
00000268                           590m     PRINT_REG D0,D1,D2,D3,A0
000002B2                           591m     PRINT_CRLF D1,A0
000002D2                           592  
000002D2  41FA 1ADE                593      LEA HELPPROMPT(PC),A0
000002D6                           594m     PRINT_STR A0,D3
000002F2                           595  
000002F2                           596m     PRINT_CRLF D3,A0
00000312                           597  
00000312  7E00                     598      MOVE.L #0,D7                                    ; address accumulator
00000314                           599  
00000314  13FC 0002 00E00001       600      MOVE.B #2,DISPLAY
0000031C                           601      
0000031C  13FC 0000 00A00001       602      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       603      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       604      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       605      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           606      
0000033C  13FC 0003 00E00001       607      MOVE.B #3,DISPLAY
00000344                           608      
00000344                           609      
00000344                           610  MAIN_LOOP
00000344  41FA 1C94                611      LEA PROMPT(PC),A0
00000348                           612m     PRINT_STR A0,D3
00000364                           613  
00000364                           614  GET_INPUT
00000364                           615m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000390                           616  
00000390                           617      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000003A0  6000 1848                618          BRA HEX_DIGIT
000003A4                           619      ENDI
000003A4                           620      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003B4  6000 1834                621          BRA HEX_DIGIT
000003B8                           622      ENDI
000003B8                           623  
000003B8  B43C 0077                624      CMP.B #'w',D2
000003BC  6700 01C6                625      BEQ W
000003C0                           626  
000003C0  B43C 006C                627      CMP.B #'l',D2
000003C4  6700 0874                628      BEQ L 
000003C8                           629  
000003C8  B43C 0070                630      CMP.B #'p',D2
000003CC  6700 0BB6                631      BEQ P
000003D0                           632  
000003D0                           633m     PRINT_CRLF D3,A0
000003F0                           634   
000003F0  B43C 003F                635      CMP.B #'?',D2
000003F4  6700 008A                636      BEQ H
000003F8                           637   
000003F8  B43C 0076                638      CMP.B #'v',D2
000003FC  6700 008A                639      BEQ V
00000400                           640      
00000400  B43C 0072                641      CMP.B #'r',D2
00000404  6700 00A6                642      BEQ R
00000408                           643  
00000408  B43C 0073                644      CMP.B #'s',D2
0000040C  6700 01F0                645      BEQ S
00000410                           646  
00000410  B43C 0067                647      CMP.B #'g',D2
00000414  6700 072E                648      BEQ G   
00000418                           649  
00000418  B43C 007A                650      CMP.B #'z',D2
0000041C  6700 072C                651      BEQ Z   
00000420                           652  
00000420  B43C 0078                653      CMP.B #'x',D2
00000424  6700 0D2E                654      BEQ X
00000428                           655  
00000428  B43C 0049                656      CMP.B #'I',D2
0000042C  6700 0E42                657      BEQ EI
00000430                           658  
00000430  B43C 006F                659      CMP.B #'o',D2
00000434  6700 0E4A                660      BEQ DI
00000438                           661  
00000438  B43C 0023                662      CMP.B #'#',D2
0000043C  6700 0E52                663      BEQ HASH
00000440                           664  
00000440  B43C 0069                665      CMP.B #'i',D2
00000444  2A7C 00000000            666      MOVE.L #0, A5               ; not boot
0000044A  6700 0E5A                667      BEQ IB
0000044E                           668  
0000044E  B43C 0062                669      CMP.B #'b',D2
00000452  2A7C 00000001            670      MOVE.L #1, A5               ; boot
00000458  6700 0E4C                671      BEQ IB
0000045C                           672  
0000045C  41FA 1ADC                673      LEA HUH(PC),A0
00000460                           674m     PRINT_STR A0,D3
0000047C                           675  
0000047C  6000 FEC6                676      BRA MAIN_LOOP
00000480                           677  
00000480                           678  ; commands
00000480                           679  H
00000480  41FA 1943                680      LEA HELP(PC),A0
00000484  6000 0006                681      BRA PRINTIT
00000488                           682  
00000488                           683  V
00000488  41FA 1C02                684      LEA VERSION(PC),A0
0000048C                           685  PRINTIT
0000048C                           686m     PRINT_STR A0,D3    
000004A8  6000 FE9A                687      BRA MAIN_LOOP
000004AC                           688  
000004AC                           689  R
000004AC  2047                     690      MOVE.L D7,A0                                    ; address accumulator -> address register
000004AE  7E00                     691      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B0  2410                     692      MOVE.L (A0),D2                                  ; read the memory and print it
000004B2                           693m     PRINT_REG D2,D3,D4,D5,A0
000004FC                           694      
000004FC                           695m     PRINT_CHAR #32,D3
00000510                           696  
00000510  E19A                     697      ROL.L #8,D2
00000512                           698m     PRINT_CHAR D2,D3
00000524  E19A                     699      ROL.L #8,D2
00000526                           700m     PRINT_CHAR D2,D3
00000538  E19A                     701      ROL.L #8,D2
0000053A                           702m     PRINT_CHAR D2,D3
0000054C  E19A                     703      ROL.L #8,D2
0000054E                           704m     PRINT_CHAR D2,D3
00000560                           705  
00000560                           706m     PRINT_CRLF D3,A0
00000580                           707      
00000580  6000 FDC2                708      BRA MAIN_LOOP
00000584                           709  
00000584                           710  W
00000584                           711      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
0000058C  E98D                     712          LSL.L #4,D5                                     ; make what we have so far more significant
0000058E                           713m         WAIT_CHAR D2,D3                                 ; next character -> D2
000005BA                           714m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005CC  8A02                     715          OR.B D2,D5
000005CE                           716      ENDF
000005D6                           717  
000005D6                           718m     PRINT_CRLF D3,A0
000005F6                           719  
000005F6  2047                     720      MOVE.L D7,A0                                    ; address accumulator -> address register
000005F8                           721  
000005F8  2085                     722      MOVE.L D5,(A0)                                  ; write the data
000005FA                           723  
000005FA  6000 FD48                724      BRA MAIN_LOOP
000005FE                           725  
000005FE                           726  ; register map for S
000005FE                           727  ; A0 - start address
000005FE                           728  ; A1 - offset
000005FE                           729  ; A2 - next address to write
000005FE                           730  ; A3 - next location (jmp)
000005FE                           731  ; A4 - Working Address Register
000005FE                           732  ; D0 - record count
000005FE                           733  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005FE                           734  ; D2 - checksum
000005FE                           735  ; D3 - data byte count
000005FE                           736  ; D4 - read address, moved into A2
000005FE                           737  ; D5 - temp
000005FE                           738  ; D6 - temp
000005FE                           739  ; D7 - temp
000005FE                           740  S
000005FE  2078 0000                741      MOVE.L 0,A0                                     ; start address -> A0
00000602  2247                     742      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000604  7E00                     743      MOVE.L #0,D7
00000606  7000                     744      MOVE.L #0,D0                                    ; count of records read -> D0
00000608                           745          
00000608                           746  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000608                           747m     DOWNLOAD D1
00000608                           748m ;   MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000608                           749m ;   BTST #0,D1                                      ; CHECK FOR CHARACTER
00000608                           750m ;   BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000608                           751m ;   READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000608                           752m ;   MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000614                           753m ;   MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000620  B23C 0053                754      CMP.B #'S',D1                                   ; found S?
00000624  66E2                     755      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000626                           756      
00000626                           757m     PRINT_CHAR #'.',D5                              ; print a progress indicator
0000063A                           758      ;PRINT_CHAR #'S',D5                             ; print the S
0000063A  5280                     759      ADD.L #1,D0                                     ; read another S record, increment count
0000063C                           760      
0000063C                           761m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000063C                           762m ;   MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000063C                           763m ;   BTST #0,D1                                      ; CHECK FOR CHARACTER
0000063C                           764m ;   BEQ CONTINUE_56                                 ; NOTHING, CONTINUE
0000063C                           765m ;   READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000063C                           766m ;   MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000648                           767m ;   MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000654                           768      ;PRINT_CHAR D1,D5
00000654                           769  
00000654  7400                     770      MOVE.L #0,D2                                    ; clear the checksum
00000656                           771  
00000656                           772m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000664                           773mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000664                           774mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
00000664                           775mm ;   BEQ CONTINUE_58                                 ; NOTHING, CONTINUE
00000664                           776mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000664                           777mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000670                           778mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000067C                           779m         ;PRINT_CHAR D5,D6
0000069A                           780  
0000069A                           781      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006A2                           782          ;PRINT_CRLF D5,A4
000006A2  6000 FF64                783          BRA WAIT_FOR_SRECORD
000006A6                           784      ELSE
000006AA                           785          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006B8  5783                     786              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000006BA                           787  
000006BA  7800                     788              MOVE.L #0,D4                            ; read two bytes of address
000006BC                           789m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000006CA                           790mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006CA                           791mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
000006CA                           792mm ;   BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
000006CA                           793mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006CA                           794mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006D6                           795mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006E2                           796m         ;PRINT_CHAR D5,D6
00000700                           797m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
0000070E                           798mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000070E                           799mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000070E                           800mm ;   BEQ CONTINUE_64                                 ; NOTHING, CONTINUE
0000070E                           801mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000070E                           802mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000071A                           803mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000726                           804m         ;PRINT_CHAR D5,D6
00000744                           805  
00000744                           806              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
0000074C  5383                     807                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000074E                           808m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000075C                           809mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000075C                           810mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000075C                           811mm ;   BEQ CONTINUE_67                                 ; NOTHING, CONTINUE
0000075C                           812mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075C                           813mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000768                           814mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000774                           815m         ;PRINT_CHAR D5,D6
00000792                           816              ENDI
00000792                           817  
00000792  2444                     818              MOVE.L D4,A2                            ; put the address in an address register
00000794  D5C9                     819              ADD.L A1,A2                             ; add in the offset
00000796                           820  
00000796                           821              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000079E                           822m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
000007AC                           823mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007AC                           824mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
000007AC                           825mm ;   BEQ CONTINUE_70                                 ; NOTHING, CONTINUE
000007AC                           826mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007AC                           827mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007B8                           828mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007C4                           829m         ;PRINT_CHAR D5,D6
000007E2                           830   
000007E2  14C1                     831                  MOVE.B D1,(A2)+                     ; store it!
000007E4                           832  
000007E4  5303                     833                  SUB.B #1,D3                         ; 1 less byte to go
000007E6                           834              ENDW
000007E8                           835  
000007E8  7200                     836              MOVE.L #0,D1                            ; not done yet
000007EA                           837          ELSE
000007EE                           838              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000007F6  7800                     839                  MOVE.L #0,D4                        ; read the 24 bit start address
000007F8                           840m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000806                           841mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000806                           842mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
00000806                           843mm ;   BEQ CONTINUE_73                                 ; NOTHING, CONTINUE
00000806                           844mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000806                           845mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000812                           846mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000081E                           847m         ;PRINT_CHAR D5,D6
0000083C                           848m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000084A                           849mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000084A                           850mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000084A                           851mm ;   BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
0000084A                           852mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                           853mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000856                           854mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000862                           855m         ;PRINT_CHAR D5,D6
00000880                           856m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
0000088E                           857mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000088E                           858mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000088E                           859mm ;   BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000088E                           860mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000088E                           861mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000089A                           862mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008A6                           863m         ;PRINT_CHAR D5,D6
000008C4                           864  
000008C4  2044                     865                  MOVE.L D4,A0                        ; start address -> A0
000008C6  D1C9                     866                  ADD.L A1,A0                         ; add in the offset
000008C8                           867  
000008C8  72FF                     868                  MOVE.L #$FFFFFFFF,D1                ; done
000008CA                           869              ELSE
000008CE                           870m                 PRINT_CRLF D5,A4
000008EE                           871  
000008EE  49FA 1673                872                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000008F2                           873m                 PRINT_STR A4,D5
0000090E                           874m                 PRINT_CHAR D1,D5
00000920                           875m                 PRINT_CRLF D5,A4
00000940                           876  
00000940  6000 FCC6                877                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000944                           878              ENDI
00000944                           879          ENDI
00000944                           880      ENDI
00000944                           881  
00000944                           882m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000952                           883mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000952                           884mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
00000952                           885mm ;   BEQ CONTINUE_91                                 ; NOTHING, CONTINUE
00000952                           886mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000952                           887mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000095E                           888mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000096A                           889m         ;PRINT_CHAR D5,D6
00000988                           890  
00000988                           891      IF.B D2 <NE> #$FF THEN.L
00000990                           892m         PRINT_CRLF D5,A4
000009B0  49FA 15C8                893          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
000009B4                           894m         PRINT_STR A4,D5
000009D0                           895m         PRINT_REG D0,D5,D3,D6,A4
00000A1A                           896m         PRINT_CRLF D5,A4
00000A3A                           897          
00000A3A  6000 F908                898          BRA MAIN_LOOP
00000A3E                           899      ENDI
00000A3E                           900  
00000A3E                           901      IF D1 <EQ> #0 THEN
00000A46  6000 FBC0                902        BRA WAIT_FOR_SRECORD
00000A4A                           903      ENDI
00000A4A                           904  DOWNLOAD_DONE
00000A4A                           905m     PRINT_CRLF D5,A4
00000A6A                           906m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000AB4  43FA 148B                907      LEA READ(PC),A1
00000AB8                           908m     PRINT_STR A1,D5
00000AD4  2E08                     909      MOVE.L A0,D7                                    ; set address accumulator to start address
00000AD6                           910m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000B20                           911m     PRINT_CRLF D5,A4
00000B40                           912  
00000B40  6000 F802                913      BRA MAIN_LOOP
00000B44                           914  
00000B44                           915  G
00000B44  2047                     916      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000B46  7E00                     917      MOVE.L #0,D7
00000B48                           918  
00000B48  4ED0                     919      JMP (A0)
00000B4A                           920          
00000B4A                           921  Z
00000B4A  207C 00200000            922      MOVE.L #RAM,A0                                  ; address of RAM
00000B50  D1FC 00100000            923      ADD.L #$100000,A0
00000B56                           924  
00000B56                           925      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000B5C  2200                     926          MOVE.L D0,D1                                ; progress update
00000B5E  E089                     927          LSR.L #8,D1 
00000B60  E089                     928          LSR.L #8,D1
00000B62  13C1 00E00001            929          MOVE.B D1,DISPLAY
00000B68                           930          
00000B68  2108                     931          MOVE.L A0,-(A0)
00000B6A                           932      ENDF
00000B74                           933  
00000B74  207C 00200000            934      MOVE.L #RAM,A0                                  ; address of RAM
00000B7A  D1FC 00100000            935      ADD.L #$100000,A0
00000B80                           936  
00000B80                           937      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000B86  2200                     938          MOVE.L D0,D1                                ; progress update
00000B88  E089                     939          LSR.L #8,D1
00000B8A  E089                     940          LSR.L #8,D1
00000B8C  13C1 00E00001            941          MOVE.B D1,DISPLAY
00000B92                           942  
00000B92  2408                     943          MOVE.L A0,D2
00000B94  2220                     944          MOVE.L -(A0),D1
00000B96                           945  
00000B96                           946          IF.L D2 <NE> D1 THEN
00000B9C  43FA 13ED                947              LEA RAM_ERROR(PC),A1
00000BA0                           948m             PRINT_STR A1,D1
00000BBC  2208                     949              MOVE.L A0,D1
00000BBE  5981                     950              SUB.L #4,D1
00000BC0                           951m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C0A                           952m             PRINT_CRLF D3,A1
00000C2A                           953          ENDI 
00000C2A                           954      ENDF
00000C36                           955  
00000C36  6000 F70C                956      BRA MAIN_LOOP
00000C3A                           957  
00000C3A                           958  L
00000C3A  7000                     959      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C3C  7200                     960      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C3E                           961  
00000C3E                           962      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C46  E989                     963          LSL.L #4,D1                                 ; make what we have so far more significant
00000C48                           964m         WAIT_CHAR D3,D4                             ; next character -> D2
00000C74                           965m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000C86  8203                     966          OR.B D3,D1
00000C88                           967      ENDF
00000C90                           968  
00000C90  3001                     969      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000C92  0480 00000104            970      SUB.L #START,D0                                 ; remove the vector table from the length
00000C98  E089                     971      LSR.L #8,D1                                     ; extract the MSword for the address
00000C9A  E089                     972      LSR.L #8,D1
00000C9C                           973  
00000C9C                           974m     PRINT_CRLF D2,A1
00000CBC                           975  
00000CBC  2041                     976      MOVE.L D1,A0                                    ; target address
00000CBE  2641                     977      MOVE.L D1,A3                                    ; keep a copy for later
00000CC0                           978  
00000CC0  2247                     979      MOVE.L D7,A1                                    ; address accumulator -> address register
00000CC2  D3FC 00000104            980      ADD.L #START,A1                                 ; skip the vectors
00000CC8  2847                     981      MOVE.L D7,A4                                    ; keep a clean copy for later
00000CCA  7E00                     982      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000CCC                           983  
00000CCC                           984m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000CFA                           985                      
00000CFA                           986      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000D02  4E71                     987          NOP
00000D04                           988      ENDF
00000D0C                           989                  
00000D0C  45FA 12B5                990      LEA LOADING(PC),A2
00000D10                           991m     PRINT_STR A2,D2
00000D2C  45FA 1295                992      LEA LOADING(PC),A2
00000D30                           993m     PRINT_STR A2,D2
00000D4C  45FA 1275                994      LEA LOADING(PC),A2
00000D50                           995m     PRINT_STR A2,D2
00000D6C  45FA 1255                996      LEA LOADING(PC),A2
00000D70                           997m     PRINT_STR A2,D2
00000D8C                           998          
00000D8C  2409                     999      MOVE.L A1,D2
00000D8E                          1000m     PRINT_REG D2,D3,D4,D5,A2
00000DD8                          1001  
00000DD8  45FA 1206               1002      LEA TO(PC),A2
00000DDC                          1003m     PRINT_STR A2,D3
00000DF8                          1004  
00000DF8  2408                    1005      MOVE.L A0,D2
00000DFA                          1006m     PRINT_REG D2,D3,D4,D5,A2
00000E44                          1007  
00000E44  45FA 119F               1008      LEA FOR(PC),A2
00000E48                          1009m     PRINT_STR A2,D3
00000E64                          1010m     PRINT_REG D0,D3,D4,D5,A2
00000EAE                          1011  
00000EAE                          1012m     PRINT_CRLF D3,A2
00000ECE                          1013  
00000ECE                          1014      WHILE D0 <GT> #0 DO
00000ED6  5580                    1015          SUB.L #2,D0
00000ED8                          1016  
00000ED8  2408                    1017          MOVE.L A0,D2
00000EDA  0202 0007               1018          ANDI.B #$7,D2
00000EDE  13C2 00E00001           1019          MOVE.B D2,DISPLAY
00000EE4                          1020m         PROGRAM (A1),(A0),D2
00000EF0                          1021                  
00000EF0  5488                    1022          ADD.L #2,A0
00000EF2  5489                    1023          ADD.L #2,A1
00000EF4                          1024      ENDW
00000EF6                          1025      
00000EF6  41F8 0000               1026      LEA STACK,A0
00000EFA  D1CC                    1027      ADD.L A4,A0
00000EFC  2010                    1028      MOVE.L (A0),D0
00000EFE                          1029      
00000EFE  207C 00000000           1030      MOVE.L #0,A0
00000F04                          1031m     PROGRAM_VECTOR D0,A0,D2
00000F24                          1032      
00000F24                          1033      FOR A0 = #RESET TO #START-4 BY #4 DO
00000F2C                          1034  
00000F2C  2248                    1035          MOVE.L A0,A1
00000F2E  D3CC                    1036          ADD.L A4,A1
00000F30                          1037              
00000F30  2011                    1038          MOVE.L (A1),D0  
00000F32  D081                    1039          ADD.L D1,D0
00000F34  0480 00000104           1040          SUB.L #START,D0
00000F3A                          1041      
00000F3A  2408                    1042          MOVE.L A0,D2
00000F3C  0202 0007               1043          ANDI.B #$7,D2
00000F40  13C2 00E00001           1044          MOVE.B D2,DISPLAY
00000F46                          1045m         PROGRAM_VECTOR D0,A0,D2
00000F66                          1046      ENDF
00000F6E                          1047                                          
00000F6E                          1048m     PROTECT
00000F80                          1049  
00000F80  6000 F3C2               1050      BRA MAIN_LOOP
00000F84                          1051      
00000F84                          1052  P
00000F84  7000                    1053      MOVE.L #0,D0                                    ; D0 will be the data to write
00000F86                          1054  
00000F86                          1055      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000F8E  E988                    1056          LSL.L #4,D0                                 ; make what we have so far more significant
00000F90                          1057m         WAIT_CHAR D2,D3                             ; next character -> D2
00000FBC                          1058m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000FCE  8002                    1059          OR.B D2,D0
00000FD0                          1060      ENDF
00000FD8                          1061  
00000FD8                          1062m     PRINT_CRLF D2,A1
00000FF8                          1063  
00000FF8  2047                    1064      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000FFA  7E00                    1065      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000FFC                          1066  
00000FFC                          1067m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
0000102A                          1068                              
0000102A                          1069      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001032  4E71                    1070          NOP
00001034                          1071      ENDF
0000103C                          1072               
0000103C  45FA 0F85               1073      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00001040                          1074m     PRINT_STR A2,D2
0000105C                          1075  
0000105C                          1076m     PRINT_REG D0,D3,D4,D5,A2
000010A6                          1077  
000010A6  45FA 0F38               1078      LEA TO(PC),A2
000010AA                          1079m     PRINT_STR A2,D3
000010C6                          1080  
000010C6  2408                    1081      MOVE.L A0,D2
000010C8                          1082m     PRINT_REG D2,D3,D4,D5,A2
00001112                          1083  
00001112                          1084m     PRINT_CRLF D3,A2
00001132                          1085  
00001132                          1086m     PROGRAM D0,(A0),D2
0000113E                          1087  
0000113E                          1088m     PROTECT
00001150                          1089      
00001150  6000 F1F2               1090      BRA MAIN_LOOP
00001154                          1091      
00001154                          1092  X
00001154  45FA 0E9A               1093      LEA STATUS_REGISTER(PC),A2
00001158                          1094m     PRINT_STR A2,D3
00001174                          1095  
00001174  40C0                    1096      MOVE SR,D0
00001176                          1097m     PRINT_REG D0,D3,D4,D5,A2
000011C0                          1098m     PRINT_CRLF D3,A2
000011E0                          1099  
000011E0  45FA 0E09               1100      LEA STACK_POINTER(PC),A2
000011E4                          1101m     PRINT_STR A2,D3
00001200                          1102  
00001200  200F                    1103      MOVE.L SP,D0
00001202                          1104m     PRINT_REG D0,D3,D4,D5,A2
0000124C                          1105m     PRINT_CRLF D3,A2
0000126C                          1106  
0000126C  6000 F0D6               1107      BRA MAIN_LOOP
00001270                          1108          
00001270                          1109  EI
00001270  13FC 0008 00C0000B      1110      MOVE.B #8,DUART_IMR
00001278  027C F8FF               1111      AND.W #$F8FF,SR
0000127C  6000 F0C6               1112      BRA MAIN_LOOP
00001280                          1113      
00001280                          1114  DI
00001280  13FC 0000 00C0000B      1115      MOVE.B #0,DUART_IMR
00001288  007C 0700               1116      OR.W #$0700,SR
0000128C  6000 F0B6               1117      BRA MAIN_LOOP
00001290                          1118          
00001290                          1119  HASH
00001290                          1120m     PROTECT
000012A2  6000 F0A0               1121      BRA MAIN_LOOP
000012A6                          1122  IB
000012A6  13FC 0038 00A00019      1123      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000012AE                          1124      
000012AE                          1125m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
000012E8                          1126m     WAIT_DRIVE_READY D0, D1
00001326                          1127          
00001326                          1128m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
0000157A                          1129      
0000157A                          1130      FOR D1 = #0 to #7 DO
00001582                          1131m         READ_32 #IDE_DATA_REGISTER, D0, D6      ; num entries in boot table -> D0 (it's written 8 times to fill the block up)
00001616                          1132      ENDF
00001620  7200                    1133      MOVE.L #0, D1                               ; current boot table index -> D1
00001622                          1134                          
00001622                          1135      IF A5 <EQ> #1 THEN                          ; if we are booting...
0000162A  CEBC 0000000F           1136          AND.L #$F,D7                            ; consider bottom 4 bits of address accumulator only
00001630                          1137          IF D7 <GE> D0 THEN                      ; don't boot if off the end of the boot table
00001636  2A7C 00000002           1138              MOVE.L #2, A5
0000163C                          1139          ENDI
0000163C                          1140  
0000163C  2007                    1141          MOVE.L D7, D0                           ; then shorten the boot table to the selected entry 
0000163E  5280                    1142          ADD.L #1, D0
00001640                          1143      ENDI
00001640                          1144      
00001640  227C 00000000           1145      MOVE.L #0, A1
00001646                          1146      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
0000164E  1A3C 0001               1147          MOVE.B #1, D5                           ; assume empty
00001652                          1148          FOR.B D3 = #0 TO #11 DO                 ; words read from this boot table entry -> D2
0000165A                          1149m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
000016EE                          1150              IF.B D1 <LT> D0 THEN                ; still in the boot table?
000016F4                          1151                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
000016FC  1A04                    1152                      MOVE.B D4, D5               ; empty flag -> D5
000016FE                          1153                  ENDI
000016FE                          1154                  
000016FE                          1155                  IF.B D5 <NE> #1 THEN            ; not empty         
00001706                          1156                      IF A5 <EQ> #0 THEN          ; not booting, so print
0000170E                          1157                          IF.B D3 <EQ> #0 THEN    ; first word in boot table, print the index
00001716                          1158m                             PRINT_REG_4BIT D1, D6, D7, A0   
00001738  41FA 08BB               1159                              LEA INDEX_SEP(PC), A0
0000173C                          1160m                             PRINT_STR A0, D7
00001758                          1161                          ENDI
00001758                          1162  
00001758                          1163                          IF.B D3 <GT> #1 AND.B D3 <LT> #7 THEN   ; str, print it
00001768                          1164                              FOR.B D6 = #0 TO #3 DO
00001770  E19C                    1165                                  ROL.L #8, D4                    
00001772                          1166m                                 PRINT_CHAR D4, D7
00001784                          1167                              ENDF
0000178C                          1168                          ENDI
0000178C                          1169                      
0000178C                          1170                          IF.B D3 <GT> #7 AND.B D3 <LT> #12 THEN
0000179C  2C45                    1171                              MOVE.L D5, A6       ; preserve the empty flag, we're gonna use D5
0000179E  41FA 0855               1172                              LEA INDEX_SEP(PC), A0
000017A2                          1173m                             PRINT_STR A0, D7
000017BE                          1174m                             PRINT_REG D4, D5, D6, D7, A0
00001808  2A0E                    1175                              MOVE.L A6, D5       ; restore the empty flag into D5
0000180A                          1176                          ENDI
0000180A                          1177                      ENDI
0000180A                          1178                      
0000180A                          1179                      IF A5 <EQ> #1 THEN          ; save the params if we are booting
00001812                          1180                          IF.B D3 <EQ> #8 THEN                        
0000181A  2244                    1181                              MOVE.L D4, A1       ; length -> A1
0000181C                          1182                          ENDI
0000181C                          1183              
0000181C                          1184                          IF.B D3 <EQ> #9 THEN
00001824  2444                    1185                              MOVE.L D4, A2       ; start address -> A2
00001826                          1186                          ENDI
00001826                          1187  
00001826                          1188                          IF.B D3 <EQ> #10 THEN
0000182E  2644                    1189                              MOVE.L D4, A3       ; go address -> A3
00001830                          1190                          ENDI
00001830                          1191  
00001830                          1192                          IF.B D3 <EQ> #11 THEN
00001838  2844                    1193                              MOVE.L D4, A4       ; start block -> A4
0000183A                          1194                          ENDI                    
0000183A                          1195                      ENDI
0000183A                          1196                  ELSE
0000183E  227C 00000000           1197                      MOVE.L #0, A1
00001844                          1198                  ENDI
00001844                          1199              ENDI            
00001844                          1200          ENDF
0000184E                          1201  
0000184E                          1202          IF A5 <EQ> #0 THEN                  ; not booting?          
00001856                          1203              IF.B D5 <NE> #1 THEN            ; not booting and not empty, so print crlf
0000185E                          1204m                 PRINT_CRLF D7, A0
0000187E                          1205              ENDI
0000187E                          1206          ENDI
0000187E                          1207          
0000187E  5281                    1208          ADD.L #1,D1                         ; next boot table index
00001880                          1209      ENDF
0000188A                          1210                          
0000188A                          1211      IF A5 <NE> #0 THEN                      ; check for boot from empty slot
00001892                          1212          IF A5 <EQ> #2 OR A1 <EQ> #0  THEN 
000018A0  41FA 075F               1213              LEA NOT_FOUND(PC), A0
000018A4                          1214m             PRINT_STR A0, D7
000018C0  6000 EA82               1215              BRA MAIN_LOOP
000018C4                          1216          ENDI
000018C4                          1217      ENDI
000018C4                          1218      
000018C4                          1219      IF A5 <EQ> #1 THEN                      ; booting?
000018CC  41FA 072B               1220          LEA BOOT(PC), A0
000018D0                          1221m         PRINT_STR A0, D7
000018EC                          1222      
000018EC  2009                    1223          MOVE.L A1, D0                       ; length -> D0              
000018EE  220C                    1224          MOVE.L A4, D1                       ; start block -> D1
000018F0                          1225          
000018F0                          1226          WHILE.L D0 <GT> #0 DO
000018FA                          1227m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
00001B4E                          1228m             PRINT_CHAR #'.', D7
00001B62                          1229              
00001B62                          1230              FOR.L D3 = #0 TO #255 DO
00001B68                          1231m                 READ_16 #IDE_DATA_REGISTER, D4, D7
00001BB0  34C4                    1232                  MOVE.W D4,(A2)+
00001BB2  5580                    1233                  SUB.L #2, D0
00001BB4                          1234              ENDF
00001BBE                          1235          
00001BBE  5281                    1236              ADD.L #1, D1                    ; next block
00001BC0                          1237          ENDW
00001BC4                          1238  
00001BC4                          1239m         PRINT_CRLF D3, A6   
00001BE4                          1240      
00001BE4  2E0B                    1241          MOVE.L A3, D7                           ; set go address
00001BE6                          1242      ENDI
00001BE6                          1243  
00001BE6  6000 E75C               1244      BRA MAIN_LOOP
00001BEA                          1245  
00001BEA                          1246  HEX_DIGIT
00001BEA  E98F                    1247      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001BEC                          1248m     HEX2BIN D2,D2,A0
00001BFE  8E02                    1249      OR.B D2,D7  
00001C00  6000 E762               1250      BRA GET_INPUT
00001C04                          1251  
00001C04                          1252  ; exceptions    
00001C04                          1253  BUS_ERROR_HANDLER
00001C04                          1254  
00001C04  41FA 040E               1255      LEA BUS_ERROR(PC),A0
00001C08                          1256m     PRINT_STR A0,D1
00001C24                          1257  
00001C24  7000                    1258      MOVE.L #0,D0
00001C26  3017                    1259      MOVE.W (SP),D0
00001C28                          1260  
00001C28  0800 0004               1261      BTST #4,D0
00001C2C  6700 0026               1262      BEQ WRITE
00001C30                          1263      
00001C30  41FA 03F7               1264      LEA READING(PC),A0
00001C34                          1265m     PRINT_STR A0,D1
00001C50                          1266  
00001C50  6000 0022               1267      BRA CONTINUE    
00001C54                          1268  WRITE
00001C54  41FA 03DC               1269      LEA WRITING(PC),A0
00001C58                          1270m     PRINT_STR A0,D1
00001C74                          1271  
00001C74                          1272  CONTINUE
00001C74  222F 0002               1273      MOVE.L 2(SP),D1
00001C78                          1274m     PRINT_REG D1,D2,D3,D4,A0
00001CC2                          1275  
00001CC2  41FA 0377               1276      LEA FROM(PC),A0
00001CC6                          1277m     PRINT_STR A0,D0
00001CE2                          1278  
00001CE2  222F 000A               1279      MOVE.L 10(SP),D1
00001CE6                          1280m     PRINT_REG D1,D2,D3,D4,A0
00001D30                          1281m     PRINT_CRLF D0,A0
00001D50                          1282      
00001D50  207C 00000004           1283      MOVE.L #4,A0
00001D56  4ED0                    1284      JMP (A0)
00001D58                          1285          
00001D58                          1286  ILLEGAL_HANDLER
00001D58  13FC 0007 00E00001      1287      MOVE.B #7,DISPLAY   
00001D60  207C 00000004           1288      MOVE.L #4,A0
00001D66  4ED0                    1289      JMP (A0)
00001D68                          1290          
00001D68                          1291  UNHANDLED_HANDLER
00001D68  41FA 02D8               1292      LEA UNHANDLED(PC),A0
00001D6C  4EF9 00001D90           1293      JMP PRINTIT_RTE
00001D72                          1294      
00001D72                          1295  UNINITIALISED_HANDLER
00001D72  41FA 02E4               1296      LEA UNINITIALISED(PC),A0
00001D76  4EF9 00001D90           1297      JMP PRINTIT_RTE
00001D7C                          1298  
00001D7C                          1299  TICK_HANDLER
00001D7C  1039 00C0001F           1300      MOVE.B DUART_RESET_OPR,D0
00001D82  41FA 0289               1301      LEA TICK(PC),A0
00001D86  4EF9 00001D90           1302      JMP PRINTIT_RTE
00001D8C                          1303  
00001D8C                          1304  SPURIOUS_HANDLER
00001D8C  41FA 02E9               1305      LEA SPURIOUS(PC),A0
00001D90                          1306  PRINTIT_RTE
00001D90                          1307m     PRINT_STR A0,D1
00001DAC  4E73                    1308      RTE 
00001DAE                          1309      
00001DAE  FFFF FFFF               1310      SIMHALT                                             ; halt simulator
00001DB2                          1311  
00001DB2                          1312  ; strings
00001DB2= 50 72 65 73 73 20 ...   1313  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001DC5= 5B 3F 5D 09 09 09 ...   1314  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001DD1= 5B 76 5D 09 09 09 ...   1315          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001DE0= 78 78 78 78 78 78 ...   1316          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001DF8= 78 78 78 78 78 78 ...   1317          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001E18= 78 78 78 78 78 78 ...   1318          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001E39= 78 78 78 78 78 78 ...   1319          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001E4A= 5B 7A 5D 09 09 09 ...   1320          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001E5C= 78 78 78 78 78 78 ...   1321          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001E80= 78 78 78 78 78 78 ...   1322          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001EA2= 23 09 09 09 77 72 ...   1323          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001EBC= 5B 78 5D 09 09 09 ...   1324          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001ED3= 5B 49 5D 09 09 09 ...   1325          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001EEC= 5B 6F 5D 09 09 09 ...   1326          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001F06= 5B 69 5D 09 09 09 ...   1327          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001F1C= 78 78 78 78 78 78 ...   1328          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001F3A= 48 75 68 3F 0D 0A 00    1329  HUH  DC.B 'Huh?',CR,LF,NULL
00001F41= 20 53 20 72 65 63 ...   1330  READ    DC.B ' S records read, start address = ',NULL
00001F63= 57 3A 20 55 6E 6B ...   1331  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001F7A= 21 20 43 53 20 66 ...   1332  CS_FAILURE  DC.B '! CS failure at ',NULL
00001F8B= 21 20 52 41 4D 20 ...   1333  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001F9C= 30 31 32 33 34 35 ...   1334  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001FAC= 00 01 02 03 04 05 ...   1335  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001FC3= 4C 6F 61 64 69 6E ...   1336  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001FD7= 0D 0A 00                1337  CRLF    DC.B CR,LF,NULL
00001FDA= 3E 20 00                1338  PROMPT  DC.B '> ',NULL
00001FDD= 30 78 00                1339  ox      DC.B '0x',NULL
00001FE0= 20 2D 3E 20 00          1340  to      DC.B ' -> ',NULL
00001FE5= 20 66 6F 72 20 00       1341  for     DC.B ' for ',NULL
00001FEB= 53 50 3A 20 00          1342  STACK_POINTER DC.B 'SP: ',NULL
00001FF0= 53 52 3A 20 00          1343  STATUS_REGISTER DC.B 'SR: ',NULL
00001FF5= 20 3A 20 00             1344  INDEX_SEP DC.B ' : ',NULL
00001FF9= 42 6F 6F 74 69 6E ...   1345  BOOT DC.B 'Booting',NULL
00002001= 4E 6F 74 20 66 6F ...   1346  NOT_FOUND DC.B 'Not found',CR,LF,NULL
0000200D= 74 69 63 6B 0D 0A 00    1347  TICK DC.B 'tick',CR,LF,NULL
00002014= 2A 20 42 75 73 2F ...   1348  BUS_ERROR DC.B '* Bus/address error ',NULL
00002029= 72 65 61 64 69 6E ...   1349  READING DC.B 'reading ',NULL
00002032= 77 72 69 74 69 6E ...   1350  WRITING DC.B 'writing ',NULL
0000203B= 20 66 72 6F 6D 20 00    1351  FROM DC.B ' from ',NULL
00002042= 2A 20 55 6E 68 61 ...   1352  UNHANDLED DC.B '* Unhandled interrupt',NULL
00002058= 2A 20 55 6E 69 74 ...   1353  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00002077= 2A 20 53 70 75 72 ...   1354  SPURIOUS DC.B '* Spurious interrupt',NULL
0000208C= 4D 44 46 2D 6D 6F ...   1355  VERSION DC.B 'MDF-mon V1.152 (12/09/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
000020AA= 00                      1356  END     DC.B 0
000020AB                          1357      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1F9C
BOOT                1FF9
BUS_ERROR           2014
BUS_ERROR_HANDLER   1C04
CONTINUE            1C74
CONTINUE_54         608
CONTINUE_56         63C
CONTINUE_58         664
CONTINUE_61         6CA
CONTINUE_64         70E
CONTINUE_67         75C
CONTINUE_70         7AC
CONTINUE_73         806
CONTINUE_76         84A
CONTINUE_79         88E
CONTINUE_91         952
CR                  D
CRLF                1FD7
CS_FAILURE          1F7A
DEBUG               0
DI                  1280
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       A4A
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  1270
END                 20AA
EXIT_10             288
EXIT_104            A3A
EXIT_107            A6A
EXIT_110            A8A
EXIT_114            AD4
EXIT_117            AF6
EXIT_122            B40
EXIT_124            BBC
EXIT_127            BE0
EXIT_132            C2A
EXIT_139            CBC
EXIT_142            D2C
EXIT_144            D4C
EXIT_146            D6C
EXIT_148            D8C
EXIT_15             2D2
EXIT_151            DAE
EXIT_155            DF8
EXIT_158            E1A
EXIT_162            E64
EXIT_165            E84
EXIT_17             2F2
EXIT_170            ECE
EXIT_185            FF8
EXIT_188            105C
EXIT_191            107C
EXIT_195            10C6
EXIT_198            10E8
EXIT_20             312
EXIT_203            1132
EXIT_207            1174
EXIT_210            1196
EXIT_215            11E0
EXIT_217            1200
EXIT_22             364
EXIT_220            1222
EXIT_225            126C
EXIT_259            1758
EXIT_262            17BE
EXIT_265            17DE
EXIT_270            187E
EXIT_272            18C0
EXIT_274            18EC
EXIT_28             3F0
EXIT_298            1BE4
EXIT_30             47C
EXIT_301            1C24
EXIT_303            1C50
EXIT_305            1C74
EXIT_308            1C98
EXIT_312            1CE2
EXIT_315            1D06
EXIT_32             4A8
EXIT_320            1D50
EXIT_322            1DAC
EXIT_35             4D2
EXIT_45             580
EXIT_5              240
EXIT_52             5F6
EXIT_7              260
EXIT_82             8EE
EXIT_84             90E
EXIT_88             940
EXIT_94             9B0
EXIT_96             9D0
EXIT_99             9F0
FOR                 1FE5
FROM                203B
G                   B44
GET_INPUT           364
H                   480
HASH                1290
HELP                1DC5
HELPPROMPT          1DB2
HEX2BIN             10B
HEX2BIN_LUT         1FAC
HEX_DIGIT           1BEA
HUH                 1F3A
IB                  12A6
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1D58
INDEX_SEP           1FF5
L                   C3A
LF                  A
LOADING             1FC3
LOOP_10             26C
LOOP_104            A1E
LOOP_107            A4E
LOOP_109            A8C
LOOP_110            A6E
LOOP_114            AB8
LOOP_116            AF8
LOOP_117            ADA
LOOP_122            B24
LOOP_124            BA0
LOOP_126            BE2
LOOP_127            BC4
LOOP_132            C0E
LOOP_139            CA0
LOOP_142            D10
LOOP_144            D30
LOOP_146            D50
LOOP_148            D70
LOOP_15             2B6
LOOP_150            DB0
LOOP_151            D92
LOOP_155            DDC
LOOP_157            E1C
LOOP_158            DFE
LOOP_162            E48
LOOP_164            E86
LOOP_165            E68
LOOP_17             2D6
LOOP_170            EB2
LOOP_185            FDC
LOOP_188            1040
LOOP_190            107E
LOOP_191            1060
LOOP_195            10AA
LOOP_197            10EA
LOOP_198            10CC
LOOP_20             2F6
LOOP_203            1116
LOOP_207            1158
LOOP_209            1198
LOOP_210            117A
LOOP_215            11C4
LOOP_217            11E4
LOOP_219            1224
LOOP_22             348
LOOP_220            1206
LOOP_225            1250
LOOP_229            12E8
LOOP_233            1326
LOOP_245            14FE
LOOP_248            153C
LOOP_259            173C
LOOP_262            17A2
LOOP_264            17E0
LOOP_265            17C2
LOOP_270            1862
LOOP_272            18A4
LOOP_274            18D0
LOOP_277            18FA
LOOP_28             3D4
LOOP_289            1AD2
LOOP_292            1B10
LOOP_298            1BC8
LOOP_30             460
LOOP_301            1C08
LOOP_303            1C34
LOOP_305            1C58
LOOP_307            1C9A
LOOP_308            1C7C
LOOP_312            1CC6
LOOP_314            1D08
LOOP_315            1CEA
LOOP_32             48C
LOOP_320            1D34
LOOP_322            1D90
LOOP_34             4D4
LOOP_35             4B6
LOOP_45             564
LOOP_5              224
LOOP_52             5DA
LOOP_7              244
LOOP_82             8D2
LOOP_84             8F2
LOOP_88             924
LOOP_9              28A
LOOP_94             994
LOOP_96             9B4
LOOP_98             9F2
LOOP_99             9D4
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           2001
NULL                0
OX                  1FDD
P                   F84
PRINTIT             48C
PRINTIT_RTE         1D90
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             D79
PROGRAM_VECTOR      E10
PROMPT              1FDA
PROTECT             D15
R                   4AC
RAM                 200000
RAM_ERROR           1F8B
READ                1F41
READING             2029
READ_16             1203
READ_32             1430
READ_8              E8E
READ_CHAR           6DD
READ_IDE_STATUS     147F
RESET               4
ROM                 0
S                   5FE
SEND_COMMAND        1701
SEND_READ_COMMAND_AND_WAIT  1730
SET_READ_ADDRESS    159F
SPURIOUS            2077
SPURIOUS_HANDLER    1D8C
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1FEB
START               104
STATUS_REGISTER     1FF0
TAB                 9
TICK                200D
TICK_HANDLER        1D7C
TO                  1FE0
UNHANDLED           2042
UNHANDLED_HANDLER   1D68
UNINITIALISED       2058
UNINITIALISED_HANDLER  1D72
UNPROTECT           C4E
UNREC               1F63
USER                100
V                   488
VECS                8
VERSION             208C
W                   584
WAIT_CHAR           599
WAIT_DRIVE_DRQ      154F
WAIT_DRIVE_NOT_BUSY  14FE
WAIT_DRIVE_READY    14AC
WAIT_FOR_COMPLETE_172  EE6
WAIT_FOR_COMPLETE_174  F08
WAIT_FOR_COMPLETE_175  F1A
WAIT_FOR_COMPLETE_177  F4A
WAIT_FOR_COMPLETE_178  F5C
WAIT_FOR_COMPLETE_205  1134
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_100  9DC
WAIT_FOR_READY_102  A04
WAIT_FOR_READY_105  A26
WAIT_FOR_READY_108  A56
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  A76
WAIT_FOR_READY_113  A9E
WAIT_FOR_READY_115  AC0
WAIT_FOR_READY_118  AE2
WAIT_FOR_READY_120  B0A
WAIT_FOR_READY_123  B2C
WAIT_FOR_READY_125  BA8
WAIT_FOR_READY_128  BCC
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_130  BF4
WAIT_FOR_READY_133  C16
WAIT_FOR_READY_134  C48
WAIT_FOR_READY_136  C62
WAIT_FOR_READY_140  CA8
WAIT_FOR_READY_143  D18
WAIT_FOR_READY_145  D38
WAIT_FOR_READY_147  D58
WAIT_FOR_READY_149  D78
WAIT_FOR_READY_152  D9A
WAIT_FOR_READY_154  DC2
WAIT_FOR_READY_156  DE4
WAIT_FOR_READY_159  E06
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E2E
WAIT_FOR_READY_163  E50
WAIT_FOR_READY_166  E70
WAIT_FOR_READY_168  E98
WAIT_FOR_READY_171  EBA
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  F90
WAIT_FOR_READY_182  FAA
WAIT_FOR_READY_186  FE4
WAIT_FOR_READY_189  1048
WAIT_FOR_READY_192  1068
WAIT_FOR_READY_194  1090
WAIT_FOR_READY_196  10B2
WAIT_FOR_READY_199  10D4
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  10FC
WAIT_FOR_READY_204  111E
WAIT_FOR_READY_208  1160
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  1182
WAIT_FOR_READY_213  11AA
WAIT_FOR_READY_216  11CC
WAIT_FOR_READY_218  11EC
WAIT_FOR_READY_221  120E
WAIT_FOR_READY_223  1236
WAIT_FOR_READY_226  1258
WAIT_FOR_READY_23   350
WAIT_FOR_READY_24   364
WAIT_FOR_READY_258  1726
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_260  1744
WAIT_FOR_READY_261  1772
WAIT_FOR_READY_263  17AA
WAIT_FOR_READY_266  17CA
WAIT_FOR_READY_268  17F2
WAIT_FOR_READY_271  186A
WAIT_FOR_READY_273  18AC
WAIT_FOR_READY_275  18D8
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_295  1B4E
WAIT_FOR_READY_299  1BD0
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_302  1C10
WAIT_FOR_READY_304  1C3C
WAIT_FOR_READY_306  1C60
WAIT_FOR_READY_309  1C84
WAIT_FOR_READY_31   468
WAIT_FOR_READY_311  1CAC
WAIT_FOR_READY_313  1CCE
WAIT_FOR_READY_316  1CF2
WAIT_FOR_READY_318  1D1A
WAIT_FOR_READY_321  1D3C
WAIT_FOR_READY_323  1D98
WAIT_FOR_READY_33   494
WAIT_FOR_READY_36   4BE
WAIT_FOR_READY_38   4E6
WAIT_FOR_READY_39   4FC
WAIT_FOR_READY_40   512
WAIT_FOR_READY_41   526
WAIT_FOR_READY_42   53A
WAIT_FOR_READY_43   54E
WAIT_FOR_READY_46   56C
WAIT_FOR_READY_47   58E
WAIT_FOR_READY_49   5A8
WAIT_FOR_READY_53   5E2
WAIT_FOR_READY_54   608
WAIT_FOR_READY_55   626
WAIT_FOR_READY_56   63C
WAIT_FOR_READY_58   664
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   6CA
WAIT_FOR_READY_64   70E
WAIT_FOR_READY_67   75C
WAIT_FOR_READY_70   7AC
WAIT_FOR_READY_73   806
WAIT_FOR_READY_76   84A
WAIT_FOR_READY_79   88E
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_83   8DA
WAIT_FOR_READY_85   8FA
WAIT_FOR_READY_86   90E
WAIT_FOR_READY_89   92C
WAIT_FOR_READY_91   952
WAIT_FOR_READY_95   99C
WAIT_FOR_READY_97   9BC
WAIT_FOR_SRECORD    608
WRITE               1C54
WRITE_8             1047
WRITING             2032
X                   1154
Z                   B4A
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6AA
_00000004           944
_00000005           6B8
_00000006           7EE
_00000007           792
_00000008           944
_00000009           8CE
_0000000A           944
_0000000B           A3E
_0000000C           A4A
_0000000D           C2A
_0000000E           EF0
_0000000F           F12
_00000010           F24
_00000011           F54
_00000012           F66
_00000013           113E
_00000014           1640
_00000015           163C
_00000016           1844
_00000017           16FE
_00000018           183E
_00000019           180A
_0000001A           1758
_0000001B           178C
_0000001C           180A
_0000001D           183A
_0000001E           181C
_0000001F           1826
_00000020           1830
_00000021           183A
_00000022           1844
_00000023           187E
_00000024           187E
_00000025           18C4
_00000026           18A0
_00000027           18C4
_00000028           1BE6
_10000000           65A
_10000001           694
_10000002           6C0
_10000003           6FA
_10000004           704
_10000005           73E
_10000006           752
_10000007           78C
_10000008           796
_10000009           7E8
_1000000A           7A2
_1000000B           7DC
_1000000C           7FC
_1000000D           836
_1000000E           840
_1000000F           87A
_10000010           884
_10000011           8BE
_10000012           948
_10000013           982
_10000014           ECE
_10000015           EF6
_10000016           18F0
_10000017           1BC4
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           58C
_20000005           5D0
_20000006           B5C
_20000007           B6C
_20000008           B86
_20000009           C2C
_2000000A           C46
_2000000B           C8A
_2000000C           D02
_2000000D           D06
_2000000E           F2C
_2000000F           F68
_20000010           F8E
_20000011           FD2
_20000012           1032
_20000013           1036
_20000014           1582
_20000015           1618
_20000016           164E
_20000017           1882
_20000018           165A
_20000019           1846
_2000001A           1770
_2000001B           1786
_2000001C           1B68
_2000001D           1BB6
