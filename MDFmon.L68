00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 31/05/2021 09:13:43

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           190  PRINT_REG_4BIT MACRO
00000000                           191      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           192      MOVE.B \1,\3
00000000                           193      ANDI.L #$F,\3
00000000                           194      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           195      PRINT_CHAR \3,\2
00000000                           196      ENDM
00000000                           197  
00000000                           198  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           199  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           200  PRINT_REG MACRO
00000000                           201      LEA ox(PC),\5
00000000                           202      PRINT_STR \5,\2
00000000                           203      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           204  LOOP\@
00000000                           205      BIN2HEX \1,\3,\5
00000000                           206      PRINT_CHAR \3,\2
00000000                           207      DBEQ \4,LOOP\@
00000000                           208      ENDM
00000000                           209  
00000000                           210  ; wait for a char from the serial port
00000000                           211  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           212  ; will stamp on D0 and D1 in debug mode
00000000                           213  WAIT_CHAR MACRO
00000000                           214  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           215      IFEQ DEBUG
00000000                           216          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           217          BTST #0,\2                                  ; check for character
00000000                           218          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           219      ENDC
00000000                           220  
00000000                           221      READ_CHAR \1
00000000                           222  
00000000                           223      IFEQ DEBUG
00000000                           224          PRINT_CHAR \1,\2                            ; echo it back
00000000                           225      ENDC
00000000                           226      ENDM
00000000                           227  
00000000                           228  ; read a char from the serial port - assumes that there is one!
00000000                           229  ; \ 1= data register for read char
00000000                           230  ; will stamp on D0 and D1 in debug mode
00000000                           231  READ_CHAR MACRO
00000000                           232      IFEQ DEBUG
00000000                           233          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           234      ENDC
00000000                           235      IFNE DEBUG
00000000                           236          MOVE.L #5,D0    
00000000                           237          TRAP #15                                    ; read from keyboard in simulator
00000000                           238          MOVE.L D1,\1
00000000                           239      ENDC
00000000                           240  
00000000                           241      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           242      BEQ START
00000000                           243      ENDM
00000000                           244  
00000000                           245  
00000000                           246  ; read data from the download serial port
00000000                           247  ; \ 1= data register for read char
00000000                           248  DOWNLOAD MACRO
00000000                           249  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           250  
00000000                           251      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           252      BTST #0,\1                                      ; check for character
00000000                           253      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           254  
00000000                           255      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           256  CONTINUE\@
00000000                           257      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           258      BTST #0,\1                                      ; check for character
00000000                           259      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           260      
00000000                           261      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           262      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           263  
00000000                           264      ENDM
00000000                           265  
00000000                           266  ; unprotect the EEPROM
00000000                           267  UNPROTECT MACRO
00000000                           268      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           269      NOP
00000000                           270      MOVE.W #$5555,$1554
00000000                           271      NOP
00000000                           272      MOVE.W #$8080,$2AAA
00000000                           273      NOP
00000000                           274      MOVE.W #$AAAA,$2AAA
00000000                           275      NOP
00000000                           276      MOVE.W #$5555,$1554
00000000                           277      NOP
00000000                           278      MOVE.W #$2020,$2AAA
00000000                           279      ENDM
00000000                           280      
00000000                           281  ; protect the EEPROM
00000000                           282  PROTECT MACRO
00000000                           283      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           284      MOVE.W #$5555,$1554
00000000                           285      MOVE.W #$A0A0,$2AAA
00000000                           286      ENDM
00000000                           287  
00000000                           288  
00000000                           289  ; read two hex digits from the download serial port and convert to a byte
00000000                           290  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           291  DOWNLOAD_BYTE MACRO
00000000                           292      MOVE.B #2,\4
00000000                           293      WHILE.B \4 <GT> 0 DO
00000000                           294          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           295          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           296          ;PRINT_CHAR \2,\3
00000000                           297          HEX2BIN \2,\2,\6
00000000                           298          OR.B \2,\1
00000000                           299          SUB.B #1,\4
00000000                           300      ENDW
00000000                           301  
00000000                           302      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           303      MOVE.B \1,\2
00000000                           304      ADD.L \1,\5
00000000                           305  
00000000                           306      ENDM
00000000                           307  
00000000                           308  ; write word to EEPROM
00000000                           309  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           310  PROGRAM MACRO
00000000                           311    MOVE.W \1,\2                                      ; write the data
00000000                           312  
00000000                           313  WAIT_FOR_COMPLETE\@
00000000                           314          MOVE.W \2,\3
00000000                           315  
00000000                           316          IF.W \3 <NE> \1 THEN
00000000                           317              BRA WAIT_FOR_COMPLETE\@
00000000                           318          ENDI
00000000                           319          ENDM
00000000                           320          
00000000                           321  ; program vector to EEPROM
00000000                           322  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           323  PROGRAM_VECTOR MACRO
00000000                           324      ADD.L #2,\2
00000000                           325      PROGRAM \1, (\2), \3                            ; write it
00000000                           326      LSR.L #8,\1
00000000                           327      LSR.L #8,\1
00000000                           328      SUB.L #2,\2
00000000                           329      PROGRAM \1, (\2), \3
00000000                           330      ENDM
00000000                           331  
00000000                           332  ; read an ide register
00000000                           333  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           334  READ_8 MACRO
00000000                           335      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           336      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           337      ORI.B \1, \3
00000000                           338      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           339      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           340      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           341      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           342      ORI.B #MC68230_PORT_C_READ, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           345      ENDM
00000000                           346      
00000000                           347  ; write an ide register
00000000                           348  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           349  WRITE_8 MACRO
00000000                           350      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           351      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           352      ORI.B \2, \3
00000000                           353      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           354      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           355      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           356      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           357      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           358      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           359      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           360      ENDM
00000000                           361  
00000000                           362  ; read ide data
00000000                           363  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           364  READ_16 MACRO
00000000                           365      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           366      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           367      
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           369      ORI.B \1, \3
00000000                           370      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           371      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           372      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           373      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           374      LSL.W #8, \2
00000000                           375      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           376      ORI.B #MC68230_PORT_C_READ, \3
00000000                           377      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           378      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           379      ENDM
00000000                           380      
00000000                           381  ; read ide data
00000000                           382  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           383  READ_32 MACRO
00000000                           384      READ_16 \1, \2, \3
00000000                           385      LSL.L #8, \2
00000000                           386      LSL.L #8, \2
00000000                           387      READ_16 \1, \2, \3
00000000                           388      ENDM
00000000                           389          
00000000                           390  ; read ide status
00000000                           391  ;\1 = data register for result, \2 = working data register 
00000000                           392  READ_IDE_STATUS MACRO   
00000000                           393      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           394      ENDM
00000000                           395      
00000000                           396  ; wait for ide drive to be ready
00000000                           397  ;\1 = working data register 1, \2 = working data register 2
00000000                           398  WAIT_DRIVE_READY MACRO
00000000                           399  LOOP\@
00000000                           400      READ_IDE_STATUS \1, \2
00000000                           401      BTST #IDE_STATUS_READY, \1
00000000                           402      BEQ LOOP\@
00000000                           403      ENDM
00000000                           404      
00000000                           405  ; wait for ide drive to be not busy
00000000                           406  ;\1 = working data register 1, \2 = working data register 2
00000000                           407  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           408  LOOP\@
00000000                           409      READ_IDE_STATUS \1, \2
00000000                           410      BTST #IDE_STATUS_BUSY, \1
00000000                           411      BNE LOOP\@
00000000                           412      ENDM
00000000                           413      
00000000                           414  ; wait for ide drive to have data for us
00000000                           415  ;\1 = working data register 1, \2 = working data register 2
00000000                           416  WAIT_DRIVE_DRQ MACRO
00000000                           417  LOOP\@
00000000                           418      READ_IDE_STATUS \1, \2
00000000                           419      BTST #IDE_STATUS_DRQ, \1
00000000                           420      BEQ LOOP\@
00000000                           421      ENDM
00000000                           422      
00000000                           423  ; prepare to send a read command
00000000                           424  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           425  SET_READ_ADDRESS MACRO
00000000                           426      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           427      MOVE.L \1,\3
00000000                           428      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           429      LSR.L #8, \3
00000000                           430      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           431      LSR.L #8, \3                                
00000000                           432      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           433      LSR.L #8, \3
00000000                           434      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           435      ANDI.B #$0F,\3
00000000                           436      OR.B \3,\4
00000000                           437      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           438      ENDM
00000000                           439  
00000000                           440  ; send command
00000000                           441  ; \1 = command, \2 = working data register 1,
00000000                           442  SEND_COMMAND MACRO
00000000                           443      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           444      ENDM
00000000                           445      
00000000                           446  ; send read command and wait
00000000                           447  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           448  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           449      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           450      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           451      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           452      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           453      WAIT_DRIVE_DRQ \2, \3
00000000                           454      ENDM
00000000                           455  
00000000                           456  ; register catalogue
00000000                           457  ; D0 - used for simulator I/O
00000000                           458  ; D1 - used for simulator I/O
00000000                           459  ; D2 - read character
00000000                           460  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           461  ; D6 - working register used in R/W
00000000                           462  ; D7 - address accumulator, reset by download
00000000                           463  ; A0 - address of string to print 
00000000                           464  
00000000                           465  ; start vector
00000000= 002E0000                 466  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 467  RESET   DC.L START                              ; RESET
00000008= 00001CB2                 468  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001CB2                 469          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001E06                 470          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001E16                 471          DC.L UNHANDLED_HANDLER
00000018= 00001E16                 472          DC.L UNHANDLED_HANDLER
0000001C= 00001E16                 473          DC.L UNHANDLED_HANDLER
00000020= 00001E16                 474          DC.L UNHANDLED_HANDLER
00000024= 00001E16                 475          DC.L UNHANDLED_HANDLER
00000028= 00001E16                 476          DC.L UNHANDLED_HANDLER
0000002C= 00001E16                 477          DC.L UNHANDLED_HANDLER
00000030= 00001E16                 478          DC.L UNHANDLED_HANDLER
00000034= 00001E16                 479          DC.L UNHANDLED_HANDLER
00000038= 00001E16                 480          DC.L UNHANDLED_HANDLER
0000003C= 00001E16                 481          DC.L UNHANDLED_HANDLER
00000040= 00001E16                 482          DC.L UNHANDLED_HANDLER
00000044= 00001E16                 483          DC.L UNHANDLED_HANDLER
00000048= 00001E16                 484          DC.L UNHANDLED_HANDLER
0000004C= 00001E16                 485          DC.L UNHANDLED_HANDLER
00000050= 00001E16                 486          DC.L UNHANDLED_HANDLER
00000054= 00001E16                 487          DC.L UNHANDLED_HANDLER
00000058= 00001E16                 488          DC.L UNHANDLED_HANDLER
0000005C= 00001E16                 489          DC.L UNHANDLED_HANDLER
00000060= 00001E3A                 490          DC.L SPURIOUS_HANDLER
00000064= 00001E16                 491          DC.L UNHANDLED_HANDLER
00000068= 00001E16                 492          DC.L UNHANDLED_HANDLER
0000006C= 00001E16                 493          DC.L UNHANDLED_HANDLER
00000070= 00001E16                 494          DC.L UNHANDLED_HANDLER
00000074= 00001E16                 495          DC.L UNHANDLED_HANDLER
00000078= 00001E16                 496          DC.L UNHANDLED_HANDLER
0000007C= 00001E16                 497          DC.L UNHANDLED_HANDLER
00000080= 00001E16                 498          DC.L UNHANDLED_HANDLER
00000084= 00001E16                 499          DC.L UNHANDLED_HANDLER
00000088= 00001E16                 500          DC.L UNHANDLED_HANDLER
0000008C= 00001E16                 501          DC.L UNHANDLED_HANDLER
00000090= 00001E16                 502          DC.L UNHANDLED_HANDLER
00000094= 00001E16                 503          DC.L UNHANDLED_HANDLER
00000098= 00001E16                 504          DC.L UNHANDLED_HANDLER
0000009C= 00001E16                 505          DC.L UNHANDLED_HANDLER
000000A0= 00001E16                 506          DC.L UNHANDLED_HANDLER
000000A4= 00001E16                 507          DC.L UNHANDLED_HANDLER
000000A8= 00001E16                 508          DC.L UNHANDLED_HANDLER
000000AC= 00001E16                 509          DC.L UNHANDLED_HANDLER
000000B0= 00001E16                 510          DC.L UNHANDLED_HANDLER
000000B4= 00001E16                 511          DC.L UNHANDLED_HANDLER
000000B8= 00001E16                 512          DC.L UNHANDLED_HANDLER
000000BC= 00001E16                 513          DC.L UNHANDLED_HANDLER
000000C0= 00001E16                 514          DC.L UNHANDLED_HANDLER
000000C4= 00001E16                 515          DC.L UNHANDLED_HANDLER
000000C8= 00001E16                 516          DC.L UNHANDLED_HANDLER
000000CC= 00001E16                 517          DC.L UNHANDLED_HANDLER
000000D0= 00001E16                 518          DC.L UNHANDLED_HANDLER
000000D4= 00001E16                 519          DC.L UNHANDLED_HANDLER
000000D8= 00001E16                 520          DC.L UNHANDLED_HANDLER 
000000DC= 00001E16                 521          DC.L UNHANDLED_HANDLER
000000E0= 00001E16                 522          DC.L UNHANDLED_HANDLER
000000E4= 00001E16                 523          DC.L UNHANDLED_HANDLER 
000000E8= 00001E16                 524          DC.L UNHANDLED_HANDLER 
000000EC= 00001E16                 525          DC.L UNHANDLED_HANDLER
000000F0= 00001E16                 526          DC.L UNHANDLED_HANDLER 
000000F4= 00001E16                 527          DC.L UNHANDLED_HANDLER 
000000F8= 00001E16                 528          DC.L UNHANDLED_HANDLER 
000000FC= 00001E16                 529          DC.L UNHANDLED_HANDLER
00000100= 00001E2A                 530  USER    DC.L TICK_HANDLER
00000104                           531      ; start of program  
00000104                           532  START
00000104  2E7C 002E0000            533      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       534      MOVE.B #0,DISPLAY
00000112                           535  
00000112  7000                     536      MOVE.L #0,D0
00000114  1039 00C00019            537      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           538  
0000011A                           539  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       540      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       541      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           542      
0000012A                           543      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                544s     MOVE.W  #$50,D1
0000012E  6000 000E                545s     BRA _20000001
00000132                           546s _20000000
00000132  13C1 00C00005            547          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     548          NOP
0000013A                           549      ENDF
0000013A  0441 0010                550s     SUB.W   #$10,D1
0000013E                           551s _20000001
0000013E  B27C 0010                552s     CMP.W   #$10,D1
00000142  6CEE                     553s     BGE _20000000
00000144                           554  
00000144                           555      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                556s     MOVE.W  #$50,D1
00000148  6000 000E                557s     BRA _20000003
0000014C                           558s _20000002
0000014C  13C1 00C00015            559          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     560          NOP
00000154                           561      ENDF
00000154  0441 0010                562s     SUB.W   #$10,D1
00000158                           563s _20000003
00000158  B27C 0010                564s     CMP.W   #$10,D1
0000015C  6CEE                     565s     BGE _20000002
0000015E                           566      
0000015E                           567  ;initialise UART
0000015E  13FC 0000 00C0000B       568      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       569      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       570      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       571      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       572      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           573  
00000186                           574  ; channel A
00000186  13FC 0013 00C00001       575      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       576      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       577      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       578      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           579  
000001A6                           580  ; channel B
000001A6  13FC 0013 00C00011       581      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       582      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       583      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       584      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       585      MOVE.B #64,DUART_IVR
000001CE                           586  
000001CE                           587m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           588m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      589m     IFEQ DEBUG
000001CE  1239 00C00003            590m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                591m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     592m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       593m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           594m     ENDC
000001E2                           595m 
000001E2                 FALSE     596m     IFNE DEBUG
000001E2                           597m     ENDC
000001E2                           598m 
000001E2                           599m     ENDM
000001E2                           600m     PRINT_CHAR #0,D1
000001E2                           601m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      602m     IFEQ DEBUG
000001E2  1239 00C00003            603m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                604m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     605m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       606m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           607m     ENDC
000001F6                           608m 
000001F6                 FALSE     609m     IFNE DEBUG
000001F6                           610m     ENDC
000001F6                           611m 
000001F6                           612m     ENDM
000001F6                           613m     PRINT_CHAR #0,D1
000001F6                           614m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      615m     IFEQ DEBUG
000001F6  1239 00C00003            616m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                617m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     618m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       619m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           620m     ENDC
0000020A                           621m 
0000020A                 FALSE     622m     IFNE DEBUG
0000020A                           623m     ENDC
0000020A                           624m 
0000020A                           625m     ENDM
0000020A                           626      
0000020A                           627      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                628s     CMP.W   #$0F,D0
0000020E  6600 0008                629s     BNE _00000000
00000212  1039 00C00005            630          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           631      ENDI
00000218                           632s _00000000
00000218                           633  
00000218  13FC 0001 00E00001       634      MOVE.B #1,DISPLAY
00000220                           635      
00000220                           636m     PRINT_CRLF D1,A0
00000220  41FA 1E63                637m     LEA CRLF(PC),A0
00000224                           638mm     PRINT_STR A0,D1
00000224                           639mm LOOP_5
00000224  0C10 0000                640mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                641mm     BEQ EXIT_5
0000022C                           642mmm     PRINT_CHAR (A0)+,D1
0000022C                           643mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      644mmm     IFEQ DEBUG
0000022C  1239 00C00003            645mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                646mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     647mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            648mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           649mmm     ENDC
0000023E                           650mmm 
0000023E                 FALSE     651mmm     IFNE DEBUG
0000023E                           652mmm     ENDC
0000023E                           653mmm 
0000023E                           654mmm     ENDM
0000023E  60E4                     655mm     BRA LOOP_5
00000240                           656mm EXIT_5
00000240                           657mm     ENDM
00000240                           658m     ENDM
00000240  41FA 1EF9                659      LEA VERSION(PC),A0
00000244                           660m     PRINT_STR A0,D3
00000244                           661m LOOP_7
00000244  0C10 0000                662m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                663m     BEQ EXIT_7
0000024C                           664mm     PRINT_CHAR (A0)+,D3
0000024C                           665mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      666mm     IFEQ DEBUG
0000024C  1639 00C00003            667mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                668mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     669mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            670mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           671mm     ENDC
0000025E                           672mm 
0000025E                 FALSE     673mm     IFNE DEBUG
0000025E                           674mm     ENDC
0000025E                           675mm 
0000025E                           676mm     ENDM
0000025E  60E4                     677m     BRA LOOP_7
00000260                           678m EXIT_7
00000260                           679m     ENDM
00000260                           680  
00000260  41F9 00002159            681      LEA END,A0
00000266  2008                     682      MOVE.L A0,D0
00000268                           683m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1E21                684m     LEA OX(PC),A0
0000026C                           685mm     PRINT_STR A0,D1
0000026C                           686mm LOOP_10
0000026C  0C10 0000                687mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                688mm     BEQ EXIT_10
00000274                           689mmm     PRINT_CHAR (A0)+,D1
00000274                           690mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      691mmm     IFEQ DEBUG
00000274  1239 00C00003            692mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                693mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     694mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            695mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           696mmm     ENDC
00000286                           697mmm 
00000286                 FALSE     698mmm     IFNE DEBUG
00000286                           699mmm     ENDC
00000286                           700mmm 
00000286                           701mmm     ENDM
00000286  60E4                     702mm     BRA LOOP_10
00000288                           703mm EXIT_10
00000288                           704mm     ENDM
00000288  7607                     705m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           706m LOOP_9
0000028A                           707mm     BIN2HEX D0,D2,A0
0000028A  41FA 1DBE                708mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     709mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     710mm     MOVE.B D0,D2
00000292  0282 0000000F            711mm     ANDI.L #$F,D2
00000298  1430 2000                712mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           713mm     ENDM
0000029C                           714mm     PRINT_CHAR D2,D1
0000029C                           715mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      716mm     IFEQ DEBUG
0000029C  1239 00C00003            717mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                718mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     719mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            720mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           721mm     ENDC
000002AE                           722mm 
000002AE                 FALSE     723mm     IFNE DEBUG
000002AE                           724mm     ENDC
000002AE                           725mm 
000002AE                           726mm     ENDM
000002AE  57CB FFDA                727m     DBEQ D3,LOOP_9
000002B2                           728m     ENDM
000002B2                           729m     PRINT_CRLF D1,A0
000002B2  41FA 1DD1                730m     LEA CRLF(PC),A0
000002B6                           731mm     PRINT_STR A0,D1
000002B6                           732mm LOOP_15
000002B6  0C10 0000                733mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                734mm     BEQ EXIT_15
000002BE                           735mmm     PRINT_CHAR (A0)+,D1
000002BE                           736mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      737mmm     IFEQ DEBUG
000002BE  1239 00C00003            738mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                739mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     740mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            741mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           742mmm     ENDC
000002D0                           743mmm 
000002D0                 FALSE     744mmm     IFNE DEBUG
000002D0                           745mmm     ENDC
000002D0                           746mmm 
000002D0                           747mmm     ENDM
000002D0  60E4                     748mm     BRA LOOP_15
000002D2                           749mm EXIT_15
000002D2                           750mm     ENDM
000002D2                           751m     ENDM
000002D2                           752  
000002D2  41FA 1B8C                753      LEA HELPPROMPT(PC),A0
000002D6                           754m     PRINT_STR A0,D3
000002D6                           755m LOOP_17
000002D6  0C10 0000                756m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                757m     BEQ EXIT_17
000002DE                           758mm     PRINT_CHAR (A0)+,D3
000002DE                           759mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      760mm     IFEQ DEBUG
000002DE  1639 00C00003            761mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                762mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     763mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            764mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           765mm     ENDC
000002F0                           766mm 
000002F0                 FALSE     767mm     IFNE DEBUG
000002F0                           768mm     ENDC
000002F0                           769mm 
000002F0                           770mm     ENDM
000002F0  60E4                     771m     BRA LOOP_17
000002F2                           772m EXIT_17
000002F2                           773m     ENDM
000002F2                           774  
000002F2                           775m     PRINT_CRLF D3,A0
000002F2  41FA 1D91                776m     LEA CRLF(PC),A0
000002F6                           777mm     PRINT_STR A0,D3
000002F6                           778mm LOOP_20
000002F6  0C10 0000                779mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                780mm     BEQ EXIT_20
000002FE                           781mmm     PRINT_CHAR (A0)+,D3
000002FE                           782mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      783mmm     IFEQ DEBUG
000002FE  1639 00C00003            784mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                785mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     786mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            787mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           788mmm     ENDC
00000310                           789mmm 
00000310                 FALSE     790mmm     IFNE DEBUG
00000310                           791mmm     ENDC
00000310                           792mmm 
00000310                           793mmm     ENDM
00000310  60E4                     794mm     BRA LOOP_20
00000312                           795mm EXIT_20
00000312                           796mm     ENDM
00000312                           797m     ENDM
00000312                           798  
00000312  7E00                     799      MOVE.L #0,D7                                    ; address accumulator
00000314                           800  
00000314  13FC 0002 00E00001       801      MOVE.B #2,DISPLAY
0000031C                           802      
0000031C  13FC 0000 00A00001       803      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       804      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       805      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       806      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           807      
0000033C  13FC 0003 00E00001       808      MOVE.B #3,DISPLAY
00000344                           809      
00000344                           810      
00000344                           811  MAIN_LOOP
00000344  41FA 1D42                812      LEA PROMPT(PC),A0
00000348                           813m     PRINT_STR A0,D3
00000348                           814m LOOP_22
00000348  0C10 0000                815m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                816m     BEQ EXIT_22
00000350                           817mm     PRINT_CHAR (A0)+,D3
00000350                           818mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      819mm     IFEQ DEBUG
00000350  1639 00C00003            820mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                821mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     822mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            823mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           824mm     ENDC
00000362                           825mm 
00000362                 FALSE     826mm     IFNE DEBUG
00000362                           827mm     ENDC
00000362                           828mm 
00000362                           829mm     ENDM
00000362  60E4                     830m     BRA LOOP_22
00000364                           831m EXIT_22
00000364                           832m     ENDM
00000364                           833  
00000364                           834  GET_INPUT
00000364                           835m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           836m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      837m     IFEQ DEBUG
00000364  1639 00C00003            838m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                839m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     840m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           841m     ENDC
00000370                           842m 
00000370                           843mm     READ_CHAR D2
00000370                 TRUE      844mm     IFEQ DEBUG
00000370  1439 00C00007            845mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           846mm     ENDC
00000376                 FALSE     847mm     IFNE DEBUG
00000376                           848mm     ENDC
00000376                           849mm 
00000376  B43C 001B                850mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                851mm     BEQ START
0000037E                           852mm     ENDM
0000037E                           853m 
0000037E                 TRUE      854m     IFEQ DEBUG
0000037E                           855mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           856mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      857mm     IFEQ DEBUG
0000037E  1639 00C00003            858mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                859mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     860mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            861mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           862mm     ENDC
00000390                           863mm 
00000390                 FALSE     864mm     IFNE DEBUG
00000390                           865mm     ENDC
00000390                           866mm 
00000390                           867mm     ENDM
00000390                           868m     ENDC
00000390                           869m     ENDM
00000390                           870  
00000390                           871      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                872s     CMP.B   #'0',D2
00000394  6D00 000E                873s     BLT _00000001
00000398  B43C 0039                874s     CMP.B   #'9',D2
0000039C  6E00 0006                875s     BGT _00000001
000003A0  6000 18F6                876          BRA HEX_DIGIT
000003A4                           877      ENDI
000003A4                           878s _00000001
000003A4                           879      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                880s     CMP.B   #'A',D2
000003A8  6D00 000E                881s     BLT _00000002
000003AC  B43C 0046                882s     CMP.B   #'F',D2
000003B0  6E00 0006                883s     BGT _00000002
000003B4  6000 18E2                884          BRA HEX_DIGIT
000003B8                           885      ENDI
000003B8                           886s _00000002
000003B8                           887  
000003B8  B43C 0077                888      CMP.B #'w',D2
000003BC  6700 01C6                889      BEQ W
000003C0                           890  
000003C0  B43C 006C                891      CMP.B #'l',D2
000003C4  6700 09A8                892      BEQ L 
000003C8                           893  
000003C8  B43C 0070                894      CMP.B #'p',D2
000003CC  6700 0C82                895      BEQ P
000003D0                           896  
000003D0                           897m     PRINT_CRLF D3,A0
000003D0  41FA 1CB3                898m     LEA CRLF(PC),A0
000003D4                           899mm     PRINT_STR A0,D3
000003D4                           900mm LOOP_28
000003D4  0C10 0000                901mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                902mm     BEQ EXIT_28
000003DC                           903mmm     PRINT_CHAR (A0)+,D3
000003DC                           904mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      905mmm     IFEQ DEBUG
000003DC  1639 00C00003            906mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                907mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     908mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            909mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           910mmm     ENDC
000003EE                           911mmm 
000003EE                 FALSE     912mmm     IFNE DEBUG
000003EE                           913mmm     ENDC
000003EE                           914mmm 
000003EE                           915mmm     ENDM
000003EE  60E4                     916mm     BRA LOOP_28
000003F0                           917mm EXIT_28
000003F0                           918mm     ENDM
000003F0                           919m     ENDM
000003F0                           920   
000003F0  B43C 003F                921      CMP.B #'?',D2
000003F4  6700 008A                922      BEQ H
000003F8                           923   
000003F8  B43C 0076                924      CMP.B #'v',D2
000003FC  6700 008A                925      BEQ V
00000400                           926      
00000400  B43C 0072                927      CMP.B #'r',D2
00000404  6700 00A6                928      BEQ R
00000408                           929  
00000408  B43C 0073                930      CMP.B #'s',D2
0000040C  6700 01F0                931      BEQ S
00000410                           932  
00000410  B43C 0067                933      CMP.B #'g',D2
00000414  6700 0862                934      BEQ G   
00000418                           935  
00000418  B43C 007A                936      CMP.B #'z',D2
0000041C  6700 0860                937      BEQ Z   
00000420                           938  
00000420  B43C 0078                939      CMP.B #'x',D2
00000424  6700 0DFA                940      BEQ X
00000428                           941  
00000428  B43C 0049                942      CMP.B #'I',D2
0000042C  6700 0F0E                943      BEQ EI
00000430                           944  
00000430  B43C 006F                945      CMP.B #'o',D2
00000434  6700 0F16                946      BEQ DI
00000438                           947  
00000438  B43C 0023                948      CMP.B #'#',D2
0000043C  6700 0F1E                949      BEQ HASH
00000440                           950  
00000440  B43C 0069                951      CMP.B #'i',D2
00000444  2A7C 00000000            952      MOVE.L #0, A5               ; not boot
0000044A  6700 0F26                953      BEQ IB
0000044E                           954  
0000044E  B43C 0062                955      CMP.B #'b',D2
00000452  2A7C 00000001            956      MOVE.L #1, A5               ; boot
00000458  6700 0F18                957      BEQ IB
0000045C                           958  
0000045C  41FA 1B8A                959      LEA HUH(PC),A0
00000460                           960m     PRINT_STR A0,D3
00000460                           961m LOOP_30
00000460  0C10 0000                962m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000464  6700 0016                963m     BEQ EXIT_30
00000468                           964mm     PRINT_CHAR (A0)+,D3
00000468                           965mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      966mm     IFEQ DEBUG
00000468  1639 00C00003            967mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000046E  0803 0002                968mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000472  67F4                     969mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000474  13D8 00C00007            970mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047A                           971mm     ENDC
0000047A                           972mm 
0000047A                 FALSE     973mm     IFNE DEBUG
0000047A                           974mm     ENDC
0000047A                           975mm 
0000047A                           976mm     ENDM
0000047A  60E4                     977m     BRA LOOP_30
0000047C                           978m EXIT_30
0000047C                           979m     ENDM
0000047C                           980  
0000047C  6000 FEC6                981      BRA MAIN_LOOP
00000480                           982  
00000480                           983  ; commands
00000480                           984  H
00000480  41FA 19F1                985      LEA HELP(PC),A0
00000484  6000 0006                986      BRA PRINTIT
00000488                           987  
00000488                           988  V
00000488  41FA 1CB1                989      LEA VERSION(PC),A0
0000048C                           990  PRINTIT
0000048C                           991m     PRINT_STR A0,D3    
0000048C                           992m LOOP_32
0000048C  0C10 0000                993m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000490  6700 0016                994m     BEQ EXIT_32
00000494                           995mm     PRINT_CHAR (A0)+,D3
00000494                           996mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000494                 TRUE      997mm     IFEQ DEBUG
00000494  1639 00C00003            998mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000049A  0803 0002                999mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000049E  67F4                    1000mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
000004A0  13D8 00C00007           1001mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004A6                          1002mm     ENDC
000004A6                          1003mm 
000004A6                 FALSE    1004mm     IFNE DEBUG
000004A6                          1005mm     ENDC
000004A6                          1006mm 
000004A6                          1007mm     ENDM
000004A6  60E4                    1008m     BRA LOOP_32
000004A8                          1009m EXIT_32
000004A8                          1010m     ENDM
000004A8  6000 FE9A               1011      BRA MAIN_LOOP
000004AC                          1012  
000004AC                          1013  R
000004AC  2047                    1014      MOVE.L D7,A0                                    ; address accumulator -> address register
000004AE  7E00                    1015      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B0  2410                    1016      MOVE.L (A0),D2                                  ; read the memory and print it
000004B2                          1017m     PRINT_REG D2,D3,D4,D5,A0
000004B2  41FA 1BD7               1018m     LEA OX(PC),A0
000004B6                          1019mm     PRINT_STR A0,D3
000004B6                          1020mm LOOP_35
000004B6  0C10 0000               1021mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004BA  6700 0016               1022mm     BEQ EXIT_35
000004BE                          1023mmm     PRINT_CHAR (A0)+,D3
000004BE                          1024mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                 TRUE     1025mmm     IFEQ DEBUG
000004BE  1639 00C00003           1026mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004C4  0803 0002               1027mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C8  67F4                    1028mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004CA  13D8 00C00007           1029mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004D0                          1030mmm     ENDC
000004D0                          1031mmm 
000004D0                 FALSE    1032mmm     IFNE DEBUG
000004D0                          1033mmm     ENDC
000004D0                          1034mmm 
000004D0                          1035mmm     ENDM
000004D0  60E4                    1036mm     BRA LOOP_35
000004D2                          1037mm EXIT_35
000004D2                          1038mm     ENDM
000004D2  7A07                    1039m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004D4                          1040m LOOP_34
000004D4                          1041mm     BIN2HEX D2,D4,A0
000004D4  41FA 1B74               1042mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004D8  E99A                    1043mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004DA  1802                    1044mm     MOVE.B D2,D4
000004DC  0284 0000000F           1045mm     ANDI.L #$F,D4
000004E2  1830 4000               1046mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004E6                          1047mm     ENDM
000004E6                          1048mm     PRINT_CHAR D4,D3
000004E6                          1049mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E6                 TRUE     1050mm     IFEQ DEBUG
000004E6  1639 00C00003           1051mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EC  0803 0002               1052mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F0  67F4                    1053mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004F2  13C4 00C00007           1054mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F8                          1055mm     ENDC
000004F8                          1056mm 
000004F8                 FALSE    1057mm     IFNE DEBUG
000004F8                          1058mm     ENDC
000004F8                          1059mm 
000004F8                          1060mm     ENDM
000004F8  57CD FFDA               1061m     DBEQ D5,LOOP_34
000004FC                          1062m     ENDM
000004FC                          1063      
000004FC                          1064m     PRINT_CHAR #32,D3
000004FC                          1065m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FC                 TRUE     1066m     IFEQ DEBUG
000004FC  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000502  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000506  67F4                    1069m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000508  13FC 0020 00C00007      1070m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000510                          1071m     ENDC
00000510                          1072m 
00000510                 FALSE    1073m     IFNE DEBUG
00000510                          1074m     ENDC
00000510                          1075m 
00000510                          1076m     ENDM
00000510                          1077  
00000510  E19A                    1078      ROL.L #8,D2
00000512                          1079m     PRINT_CHAR D2,D3
00000512                          1080m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1081m     IFEQ DEBUG
00000512  1639 00C00003           1082m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1083m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1084m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1085m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1086m     ENDC
00000524                          1087m 
00000524                 FALSE    1088m     IFNE DEBUG
00000524                          1089m     ENDC
00000524                          1090m 
00000524                          1091m     ENDM
00000524  E19A                    1092      ROL.L #8,D2
00000526                          1093m     PRINT_CHAR D2,D3
00000526                          1094m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1095m     IFEQ DEBUG
00000526  1639 00C00003           1096m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1097m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1098m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1099m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1100m     ENDC
00000538                          1101m 
00000538                 FALSE    1102m     IFNE DEBUG
00000538                          1103m     ENDC
00000538                          1104m 
00000538                          1105m     ENDM
00000538  E19A                    1106      ROL.L #8,D2
0000053A                          1107m     PRINT_CHAR D2,D3
0000053A                          1108m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1109m     IFEQ DEBUG
0000053A  1639 00C00003           1110m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1111m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1112m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1113m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1114m     ENDC
0000054C                          1115m 
0000054C                 FALSE    1116m     IFNE DEBUG
0000054C                          1117m     ENDC
0000054C                          1118m 
0000054C                          1119m     ENDM
0000054C  E19A                    1120      ROL.L #8,D2
0000054E                          1121m     PRINT_CHAR D2,D3
0000054E                          1122m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054E                 TRUE     1123m     IFEQ DEBUG
0000054E  1639 00C00003           1124m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000554  0803 0002               1125m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000558  67F4                    1126m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000055A  13C2 00C00007           1127m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000560                          1128m     ENDC
00000560                          1129m 
00000560                 FALSE    1130m     IFNE DEBUG
00000560                          1131m     ENDC
00000560                          1132m 
00000560                          1133m     ENDM
00000560                          1134  
00000560                          1135m     PRINT_CRLF D3,A0
00000560  41FA 1B23               1136m     LEA CRLF(PC),A0
00000564                          1137mm     PRINT_STR A0,D3
00000564                          1138mm LOOP_45
00000564  0C10 0000               1139mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016               1140mm     BEQ EXIT_45
0000056C                          1141mmm     PRINT_CHAR (A0)+,D3
0000056C                          1142mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE     1143mmm     IFEQ DEBUG
0000056C  1639 00C00003           1144mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000572  0803 0002               1145mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                    1146mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007           1147mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                          1148mmm     ENDC
0000057E                          1149mmm 
0000057E                 FALSE    1150mmm     IFNE DEBUG
0000057E                          1151mmm     ENDC
0000057E                          1152mmm 
0000057E                          1153mmm     ENDM
0000057E  60E4                    1154mm     BRA LOOP_45
00000580                          1155mm EXIT_45
00000580                          1156mm     ENDM
00000580                          1157m     ENDM
00000580                          1158      
00000580  6000 FDC2               1159      BRA MAIN_LOOP
00000584                          1160  
00000584                          1161  W
00000584                          1162      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000584  3C3C 0000               1163s     MOVE.W  #0,D6
00000588  6000 0046               1164s     BRA _20000005
0000058C                          1165s _20000004
0000058C  E98D                    1166          LSL.L #4,D5                                     ; make what we have so far more significant
0000058E                          1167m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000058E                          1168m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058E                 TRUE     1169m     IFEQ DEBUG
0000058E  1639 00C00003           1170m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000594  0803 0000               1171m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000598  67F4                    1172m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
0000059A                          1173m     ENDC
0000059A                          1174m 
0000059A                          1175mm     READ_CHAR D2
0000059A                 TRUE     1176mm     IFEQ DEBUG
0000059A  1439 00C00007           1177mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000005A0                          1178mm     ENDC
000005A0                 FALSE    1179mm     IFNE DEBUG
000005A0                          1180mm     ENDC
000005A0                          1181mm 
000005A0  B43C 001B               1182mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000005A4  6700 FB5E               1183mm     BEQ START
000005A8                          1184mm     ENDM
000005A8                          1185m 
000005A8                 TRUE     1186m     IFEQ DEBUG
000005A8                          1187mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000005A8                          1188mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A8                 TRUE     1189mm     IFEQ DEBUG
000005A8  1639 00C00003           1190mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005AE  0803 0002               1191mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B2  67F4                    1192mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005B4  13C2 00C00007           1193mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005BA                          1194mm     ENDC
000005BA                          1195mm 
000005BA                 FALSE    1196mm     IFNE DEBUG
000005BA                          1197mm     ENDC
000005BA                          1198mm 
000005BA                          1199mm     ENDM
000005BA                          1200m     ENDC
000005BA                          1201m     ENDM
000005BA                          1202m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005BA  41FA 1A9E               1203m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005BE  0402 0030               1204m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005C2  C4BC 000000FF           1205m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005C8  1430 2000               1206m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005CC                          1207m     ENDM
000005CC  8A02                    1208          OR.B D2,D5
000005CE                          1209      ENDF
000005CE  5246                    1210s     ADD.W   #1,D6
000005D0                          1211s _20000005
000005D0  BC7C 0007               1212s     CMP.W   #7,D6
000005D4  6FB6                    1213s     BLE _20000004
000005D6                          1214  
000005D6                          1215m     PRINT_CRLF D3,A0
000005D6  41FA 1AAD               1216m     LEA CRLF(PC),A0
000005DA                          1217mm     PRINT_STR A0,D3
000005DA                          1218mm LOOP_52
000005DA  0C10 0000               1219mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005DE  6700 0016               1220mm     BEQ EXIT_52
000005E2                          1221mmm     PRINT_CHAR (A0)+,D3
000005E2                          1222mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                 TRUE     1223mmm     IFEQ DEBUG
000005E2  1639 00C00003           1224mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005E8  0803 0002               1225mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005EC  67F4                    1226mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005EE  13D8 00C00007           1227mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005F4                          1228mmm     ENDC
000005F4                          1229mmm 
000005F4                 FALSE    1230mmm     IFNE DEBUG
000005F4                          1231mmm     ENDC
000005F4                          1232mmm 
000005F4                          1233mmm     ENDM
000005F4  60E4                    1234mm     BRA LOOP_52
000005F6                          1235mm EXIT_52
000005F6                          1236mm     ENDM
000005F6                          1237m     ENDM
000005F6                          1238  
000005F6  2047                    1239      MOVE.L D7,A0                                    ; address accumulator -> address register
000005F8                          1240  
000005F8  2085                    1241      MOVE.L D5,(A0)                                  ; write the data
000005FA                          1242  
000005FA  6000 FD48               1243      BRA MAIN_LOOP
000005FE                          1244  
000005FE                          1245  ; register map for S
000005FE                          1246  ; A0 - start address
000005FE                          1247  ; A1 - offset
000005FE                          1248  ; A2 - next address to write
000005FE                          1249  ; A3 - next location (jmp)
000005FE                          1250  ; A4 - Working Address Register
000005FE                          1251  ; D0 - record count
000005FE                          1252  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005FE                          1253  ; D2 - checksum
000005FE                          1254  ; D3 - data byte count
000005FE                          1255  ; D4 - read address, moved into A2
000005FE                          1256  ; D5 - temp
000005FE                          1257  ; D6 - temp
000005FE                          1258  ; D7 - temp
000005FE                          1259  S
000005FE  2078 0000               1260      MOVE.L 0,A0                                     ; start address -> A0
00000602  2247                    1261      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000604  7E00                    1262      MOVE.L #0,D7
00000606  7000                    1263      MOVE.L #0,D0                                    ; count of records read -> D0
00000608                          1264          
00000608                          1265  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000608                          1266m     DOWNLOAD D1
00000608                          1267m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1268m 
00000608  1239 00C00003           1269m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000060E  0801 0000               1270m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000612  6700 0010               1271m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000616                          1272m 
00000616                          1273mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000616                 TRUE     1274mm     IFEQ DEBUG
00000616  1239 00C00007           1275mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000061C                          1276mm     ENDC
0000061C                 FALSE    1277mm     IFNE DEBUG
0000061C                          1278mm     ENDC
0000061C                          1279mm 
0000061C  B23C 001B               1280mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000620  6700 FAE2               1281mm     BEQ START
00000624                          1282mm     ENDM
00000624                          1283m CONTINUE_54
00000624  1239 00C00013           1284m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000062A  0801 0000               1285m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000062E  67D8                    1286m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
00000630                          1287m     
00000630  1239 00C00017           1288m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000636  13C1 00E00001           1289m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000063C                          1290m 
0000063C                          1291m     ENDM
0000063C  B23C 0053               1292      CMP.B #'S',D1                                   ; found S?
00000640  66C6                    1293      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000642                          1294      
00000642                          1295m     PRINT_CHAR #'.',D5                              ; print a progress indicator
00000642                          1296m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000642                 TRUE     1297m     IFEQ DEBUG
00000642  1A39 00C00003           1298m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000648  0805 0002               1299m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000064C  67F4                    1300m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000064E  13FC 002E 00C00007      1301m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000656                          1302m     ENDC
00000656                          1303m 
00000656                 FALSE    1304m     IFNE DEBUG
00000656                          1305m     ENDC
00000656                          1306m 
00000656                          1307m     ENDM
00000656                          1308      ;PRINT_CHAR #'S',D5                             ; print the S
00000656  5280                    1309      ADD.L #1,D0                                     ; read another S record, increment count
00000658                          1310      
00000658                          1311m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000658                          1312m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000658                          1313m 
00000658  1239 00C00003           1314m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000065E  0801 0000               1315m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000662  6700 0010               1316m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000666                          1317m 
00000666                          1318mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000666                 TRUE     1319mm     IFEQ DEBUG
00000666  1239 00C00007           1320mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000066C                          1321mm     ENDC
0000066C                 FALSE    1322mm     IFNE DEBUG
0000066C                          1323mm     ENDC
0000066C                          1324mm 
0000066C  B23C 001B               1325mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000670  6700 FA92               1326mm     BEQ START
00000674                          1327mm     ENDM
00000674                          1328m CONTINUE_57
00000674  1239 00C00013           1329m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000067A  0801 0000               1330m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000067E  67D8                    1331m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
00000680                          1332m     
00000680  1239 00C00017           1333m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000686  13C1 00E00001           1334m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000068C                          1335m 
0000068C                          1336m     ENDM
0000068C                          1337      ;PRINT_CHAR D1,D5
0000068C                          1338  
0000068C  7400                    1339      MOVE.L #0,D2                                    ; clear the checksum
0000068E                          1340  
0000068E                          1341m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000068E  1E3C 0002               1342m     MOVE.B #2,D7
00000692                          1343m     WHILE.B D7 <GT> 0 DO
00000692                          1344ms _10000000
00000692  BE38 0000               1345ms     CMP.B   0,D7
00000696  6F00 0050               1346ms     BLE _10000001
0000069A  E98B                    1347m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000069C                          1348mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000069C                          1349mm WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069C                          1350mm 
0000069C  1A39 00C00003           1351mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006A2  0805 0000               1352mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006A6  6700 0010               1353mm     BEQ CONTINUE_60                                 ; NOTHING, CONTINUE
000006AA                          1354mm 
000006AA                          1355mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006AA                 TRUE     1356mmm     IFEQ DEBUG
000006AA  1A39 00C00007           1357mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006B0                          1358mmm     ENDC
000006B0                 FALSE    1359mmm     IFNE DEBUG
000006B0                          1360mmm     ENDC
000006B0                          1361mmm 
000006B0  BA3C 001B               1362mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006B4  6700 FA4E               1363mmm     BEQ START
000006B8                          1364mmm     ENDM
000006B8                          1365mm CONTINUE_60
000006B8  1A39 00C00013           1366mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006BE  0805 0000               1367mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006C2  67D8                    1368mm     BEQ WAIT_FOR_READY_60                           ; NOTHING, CHECK AGAIN
000006C4                          1369mm     
000006C4  1A39 00C00017           1370mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006CA  13C5 00E00001           1371mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006D0                          1372mm 
000006D0                          1373mm     ENDM
000006D0                          1374m         ;PRINT_CHAR D5,D6
000006D0                          1375mm         HEX2BIN D5,D5,A4
000006D0  49FA 1988               1376mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006D4  0405 0030               1377mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006D8  CABC 000000FF           1378mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006DE  1A34 5000               1379mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006E2                          1380mm     ENDM
000006E2  8605                    1381m         OR.B D5,D3
000006E4  5307                    1382m         SUB.B #1,D7
000006E6                          1383m     ENDW
000006E6  60AA                    1384ms     BRA _10000000
000006E8                          1385ms _10000001
000006E8                          1386m 
000006E8  7A00                    1387m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006EA  1A03                    1388m     MOVE.B D3,D5
000006EC  D483                    1389m     ADD.L D3,D2
000006EE                          1390m 
000006EE                          1391m     ENDM
000006EE                          1392  
000006EE                          1393      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006EE  B23C 0030               1394s     CMP.B   #'0',D1
000006F2  6600 000A               1395s     BNE.L   _00000003
000006F6                          1396          ;PRINT_CRLF D5,A4
000006F6  6000 FF10               1397          BRA WAIT_FOR_SRECORD
000006FA                          1398      ELSE
000006FA  6000 0360               1399s     BRA _00000004
000006FE                          1400s _00000003
000006FE                          1401          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006FE  B23C 0031               1402s     CMP.B   #'1',D1
00000702  6708                    1403s     BEQ.S   _00000005
00000704  B23C 0032               1404s     CMP.B   #'2',D1
00000708  6600 01A8               1405s     BNE.L   _00000006
0000070C                          1406s _00000005
0000070C  5783                    1407              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000070E                          1408  
0000070E  7800                    1409              MOVE.L #0,D4                            ; read two bytes of address
00000710                          1410m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000710  1E3C 0002               1411m     MOVE.B #2,D7
00000714                          1412m     WHILE.B D7 <GT> 0 DO
00000714                          1413ms _10000002
00000714  BE38 0000               1414ms     CMP.B   0,D7
00000718  6F00 0050               1415ms     BLE _10000003
0000071C  E98C                    1416m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000071E                          1417mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000071E                          1418mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071E                          1419mm 
0000071E  1A39 00C00003           1420mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000724  0805 0000               1421mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000728  6700 0010               1422mm     BEQ CONTINUE_64                                 ; NOTHING, CONTINUE
0000072C                          1423mm 
0000072C                          1424mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000072C                 TRUE     1425mmm     IFEQ DEBUG
0000072C  1A39 00C00007           1426mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000732                          1427mmm     ENDC
00000732                 FALSE    1428mmm     IFNE DEBUG
00000732                          1429mmm     ENDC
00000732                          1430mmm 
00000732  BA3C 001B               1431mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000736  6700 F9CC               1432mmm     BEQ START
0000073A                          1433mmm     ENDM
0000073A                          1434mm CONTINUE_64
0000073A  1A39 00C00013           1435mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000740  0805 0000               1436mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000744  67D8                    1437mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
00000746                          1438mm     
00000746  1A39 00C00017           1439mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000074C  13C5 00E00001           1440mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000752                          1441mm 
00000752                          1442mm     ENDM
00000752                          1443m         ;PRINT_CHAR D5,D6
00000752                          1444mm         HEX2BIN D5,D5,A4
00000752  49FA 1906               1445mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000756  0405 0030               1446mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000075A  CABC 000000FF           1447mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000760  1A34 5000               1448mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000764                          1449mm     ENDM
00000764  8805                    1450m         OR.B D5,D4
00000766  5307                    1451m         SUB.B #1,D7
00000768                          1452m     ENDW
00000768  60AA                    1453ms     BRA _10000002
0000076A                          1454ms _10000003
0000076A                          1455m 
0000076A  7A00                    1456m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000076C  1A04                    1457m     MOVE.B D4,D5
0000076E  D484                    1458m     ADD.L D4,D2
00000770                          1459m 
00000770                          1460m     ENDM
00000770                          1461m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000770  1E3C 0002               1462m     MOVE.B #2,D7
00000774                          1463m     WHILE.B D7 <GT> 0 DO
00000774                          1464ms _10000004
00000774  BE38 0000               1465ms     CMP.B   0,D7
00000778  6F00 0050               1466ms     BLE _10000005
0000077C  E98C                    1467m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000077E                          1468mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000077E                          1469mm WAIT_FOR_READY_68                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000077E                          1470mm 
0000077E  1A39 00C00003           1471mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000784  0805 0000               1472mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000788  6700 0010               1473mm     BEQ CONTINUE_68                                 ; NOTHING, CONTINUE
0000078C                          1474mm 
0000078C                          1475mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000078C                 TRUE     1476mmm     IFEQ DEBUG
0000078C  1A39 00C00007           1477mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000792                          1478mmm     ENDC
00000792                 FALSE    1479mmm     IFNE DEBUG
00000792                          1480mmm     ENDC
00000792                          1481mmm 
00000792  BA3C 001B               1482mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000796  6700 F96C               1483mmm     BEQ START
0000079A                          1484mmm     ENDM
0000079A                          1485mm CONTINUE_68
0000079A  1A39 00C00013           1486mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007A0  0805 0000               1487mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007A4  67D8                    1488mm     BEQ WAIT_FOR_READY_68                           ; NOTHING, CHECK AGAIN
000007A6                          1489mm     
000007A6  1A39 00C00017           1490mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007AC  13C5 00E00001           1491mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007B2                          1492mm 
000007B2                          1493mm     ENDM
000007B2                          1494m         ;PRINT_CHAR D5,D6
000007B2                          1495mm         HEX2BIN D5,D5,A4
000007B2  49FA 18A6               1496mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007B6  0405 0030               1497mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007BA  CABC 000000FF           1498mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007C0  1A34 5000               1499mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007C4                          1500mm     ENDM
000007C4  8805                    1501m         OR.B D5,D4
000007C6  5307                    1502m         SUB.B #1,D7
000007C8                          1503m     ENDW
000007C8  60AA                    1504ms     BRA _10000004
000007CA                          1505ms _10000005
000007CA                          1506m 
000007CA  7A00                    1507m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007CC  1A04                    1508m     MOVE.B D4,D5
000007CE  D484                    1509m     ADD.L D4,D2
000007D0                          1510m 
000007D0                          1511m     ENDM
000007D0                          1512  
000007D0                          1513              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000007D0  B23C 0032               1514s     CMP.B   #'2',D1
000007D4  6600 0064               1515s     BNE.L   _00000007
000007D8  5383                    1516                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000007DA                          1517m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000007DA  1E3C 0002               1518m     MOVE.B #2,D7
000007DE                          1519m     WHILE.B D7 <GT> 0 DO
000007DE                          1520ms _10000006
000007DE  BE38 0000               1521ms     CMP.B   0,D7
000007E2  6F00 0050               1522ms     BLE _10000007
000007E6  E98C                    1523m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007E8                          1524mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007E8                          1525mm WAIT_FOR_READY_72                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007E8                          1526mm 
000007E8  1A39 00C00003           1527mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007EE  0805 0000               1528mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007F2  6700 0010               1529mm     BEQ CONTINUE_72                                 ; NOTHING, CONTINUE
000007F6                          1530mm 
000007F6                          1531mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007F6                 TRUE     1532mmm     IFEQ DEBUG
000007F6  1A39 00C00007           1533mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007FC                          1534mmm     ENDC
000007FC                 FALSE    1535mmm     IFNE DEBUG
000007FC                          1536mmm     ENDC
000007FC                          1537mmm 
000007FC  BA3C 001B               1538mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000800  6700 F902               1539mmm     BEQ START
00000804                          1540mmm     ENDM
00000804                          1541mm CONTINUE_72
00000804  1A39 00C00013           1542mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000080A  0805 0000               1543mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000080E  67D8                    1544mm     BEQ WAIT_FOR_READY_72                           ; NOTHING, CHECK AGAIN
00000810                          1545mm     
00000810  1A39 00C00017           1546mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000816  13C5 00E00001           1547mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000081C                          1548mm 
0000081C                          1549mm     ENDM
0000081C                          1550m         ;PRINT_CHAR D5,D6
0000081C                          1551mm         HEX2BIN D5,D5,A4
0000081C  49FA 183C               1552mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000820  0405 0030               1553mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000824  CABC 000000FF           1554mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000082A  1A34 5000               1555mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000082E                          1556mm     ENDM
0000082E  8805                    1557m         OR.B D5,D4
00000830  5307                    1558m         SUB.B #1,D7
00000832                          1559m     ENDW
00000832  60AA                    1560ms     BRA _10000006
00000834                          1561ms _10000007
00000834                          1562m 
00000834  7A00                    1563m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000836  1A04                    1564m     MOVE.B D4,D5
00000838  D484                    1565m     ADD.L D4,D2
0000083A                          1566m 
0000083A                          1567m     ENDM
0000083A                          1568              ENDI
0000083A                          1569s _00000007
0000083A                          1570  
0000083A  2444                    1571              MOVE.L D4,A2                            ; put the address in an address register
0000083C  D5C9                    1572              ADD.L A1,A2                             ; add in the offset
0000083E                          1573  
0000083E                          1574              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000083E                          1575s _10000008
0000083E  B63C 0000               1576s     CMP.B   #0,D3
00000842  6F00 0068               1577s     BLE _10000009
00000846                          1578m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000846  1E3C 0002               1579m     MOVE.B #2,D7
0000084A                          1580m     WHILE.B D7 <GT> 0 DO
0000084A                          1581ms _1000000A
0000084A  BE38 0000               1582ms     CMP.B   0,D7
0000084E  6F00 0050               1583ms     BLE _1000000B
00000852  E989                    1584m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000854                          1585mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000854                          1586mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000854                          1587mm 
00000854  1A39 00C00003           1588mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000085A  0805 0000               1589mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000085E  6700 0010               1590mm     BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
00000862                          1591mm 
00000862                          1592mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000862                 TRUE     1593mmm     IFEQ DEBUG
00000862  1A39 00C00007           1594mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000868                          1595mmm     ENDC
00000868                 FALSE    1596mmm     IFNE DEBUG
00000868                          1597mmm     ENDC
00000868                          1598mmm 
00000868  BA3C 001B               1599mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000086C  6700 F896               1600mmm     BEQ START
00000870                          1601mmm     ENDM
00000870                          1602mm CONTINUE_76
00000870  1A39 00C00013           1603mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000876  0805 0000               1604mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000087A  67D8                    1605mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
0000087C                          1606mm     
0000087C  1A39 00C00017           1607mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000882  13C5 00E00001           1608mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000888                          1609mm 
00000888                          1610mm     ENDM
00000888                          1611m         ;PRINT_CHAR D5,D6
00000888                          1612mm         HEX2BIN D5,D5,A4
00000888  49FA 17D0               1613mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000088C  0405 0030               1614mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000890  CABC 000000FF           1615mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000896  1A34 5000               1616mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000089A                          1617mm     ENDM
0000089A  8205                    1618m         OR.B D5,D1
0000089C  5307                    1619m         SUB.B #1,D7
0000089E                          1620m     ENDW
0000089E  60AA                    1621ms     BRA _1000000A
000008A0                          1622ms _1000000B
000008A0                          1623m 
000008A0  7A00                    1624m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008A2  1A01                    1625m     MOVE.B D1,D5
000008A4  D481                    1626m     ADD.L D1,D2
000008A6                          1627m 
000008A6                          1628m     ENDM
000008A6                          1629   
000008A6  14C1                    1630                  MOVE.B D1,(A2)+                     ; store it!
000008A8                          1631  
000008A8  5303                    1632                  SUB.B #1,D3                         ; 1 less byte to go
000008AA                          1633              ENDW
000008AA  6092                    1634s     BRA _10000008
000008AC                          1635s _10000009
000008AC                          1636  
000008AC  7200                    1637              MOVE.L #0,D1                            ; not done yet
000008AE                          1638          ELSE
000008AE  6000 01AC               1639s     BRA _00000008
000008B2                          1640s _00000006
000008B2                          1641              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000008B2  B23C 0038               1642s     CMP.B   #'8',D1
000008B6  6600 012E               1643s     BNE.L   _00000009
000008BA  7800                    1644                  MOVE.L #0,D4                        ; read the 24 bit start address
000008BC                          1645m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000008BC  1E3C 0002               1646m     MOVE.B #2,D7
000008C0                          1647m     WHILE.B D7 <GT> 0 DO
000008C0                          1648ms _1000000C
000008C0  BE38 0000               1649ms     CMP.B   0,D7
000008C4  6F00 0050               1650ms     BLE _1000000D
000008C8  E98C                    1651m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008CA                          1652mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008CA                          1653mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008CA                          1654mm 
000008CA  1A39 00C00003           1655mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008D0  0805 0000               1656mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008D4  6700 0010               1657mm     BEQ CONTINUE_80                                 ; NOTHING, CONTINUE
000008D8                          1658mm 
000008D8                          1659mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008D8                 TRUE     1660mmm     IFEQ DEBUG
000008D8  1A39 00C00007           1661mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008DE                          1662mmm     ENDC
000008DE                 FALSE    1663mmm     IFNE DEBUG
000008DE                          1664mmm     ENDC
000008DE                          1665mmm 
000008DE  BA3C 001B               1666mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008E2  6700 F820               1667mmm     BEQ START
000008E6                          1668mmm     ENDM
000008E6                          1669mm CONTINUE_80
000008E6  1A39 00C00013           1670mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008EC  0805 0000               1671mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008F0  67D8                    1672mm     BEQ WAIT_FOR_READY_80                           ; NOTHING, CHECK AGAIN
000008F2                          1673mm     
000008F2  1A39 00C00017           1674mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008F8  13C5 00E00001           1675mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008FE                          1676mm 
000008FE                          1677mm     ENDM
000008FE                          1678m         ;PRINT_CHAR D5,D6
000008FE                          1679mm         HEX2BIN D5,D5,A4
000008FE  49FA 175A               1680mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000902  0405 0030               1681mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000906  CABC 000000FF           1682mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000090C  1A34 5000               1683mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000910                          1684mm     ENDM
00000910  8805                    1685m         OR.B D5,D4
00000912  5307                    1686m         SUB.B #1,D7
00000914                          1687m     ENDW
00000914  60AA                    1688ms     BRA _1000000C
00000916                          1689ms _1000000D
00000916                          1690m 
00000916  7A00                    1691m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000918  1A04                    1692m     MOVE.B D4,D5
0000091A  D484                    1693m     ADD.L D4,D2
0000091C                          1694m 
0000091C                          1695m     ENDM
0000091C                          1696m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000091C  1E3C 0002               1697m     MOVE.B #2,D7
00000920                          1698m     WHILE.B D7 <GT> 0 DO
00000920                          1699ms _1000000E
00000920  BE38 0000               1700ms     CMP.B   0,D7
00000924  6F00 0050               1701ms     BLE _1000000F
00000928  E98C                    1702m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000092A                          1703mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000092A                          1704mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092A                          1705mm 
0000092A  1A39 00C00003           1706mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000930  0805 0000               1707mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000934  6700 0010               1708mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000938                          1709mm 
00000938                          1710mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000938                 TRUE     1711mmm     IFEQ DEBUG
00000938  1A39 00C00007           1712mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000093E                          1713mmm     ENDC
0000093E                 FALSE    1714mmm     IFNE DEBUG
0000093E                          1715mmm     ENDC
0000093E                          1716mmm 
0000093E  BA3C 001B               1717mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000942  6700 F7C0               1718mmm     BEQ START
00000946                          1719mmm     ENDM
00000946                          1720mm CONTINUE_84
00000946  1A39 00C00013           1721mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000094C  0805 0000               1722mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000950  67D8                    1723mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
00000952                          1724mm     
00000952  1A39 00C00017           1725mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000958  13C5 00E00001           1726mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000095E                          1727mm 
0000095E                          1728mm     ENDM
0000095E                          1729m         ;PRINT_CHAR D5,D6
0000095E                          1730mm         HEX2BIN D5,D5,A4
0000095E  49FA 16FA               1731mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000962  0405 0030               1732mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000966  CABC 000000FF           1733mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000096C  1A34 5000               1734mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000970                          1735mm     ENDM
00000970  8805                    1736m         OR.B D5,D4
00000972  5307                    1737m         SUB.B #1,D7
00000974                          1738m     ENDW
00000974  60AA                    1739ms     BRA _1000000E
00000976                          1740ms _1000000F
00000976                          1741m 
00000976  7A00                    1742m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000978  1A04                    1743m     MOVE.B D4,D5
0000097A  D484                    1744m     ADD.L D4,D2
0000097C                          1745m 
0000097C                          1746m     ENDM
0000097C                          1747m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
0000097C  1E3C 0002               1748m     MOVE.B #2,D7
00000980                          1749m     WHILE.B D7 <GT> 0 DO
00000980                          1750ms _10000010
00000980  BE38 0000               1751ms     CMP.B   0,D7
00000984  6F00 0050               1752ms     BLE _10000011
00000988  E98C                    1753m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000098A                          1754mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000098A                          1755mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000098A                          1756mm 
0000098A  1A39 00C00003           1757mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000990  0805 0000               1758mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000994  6700 0010               1759mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
00000998                          1760mm 
00000998                          1761mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000998                 TRUE     1762mmm     IFEQ DEBUG
00000998  1A39 00C00007           1763mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000099E                          1764mmm     ENDC
0000099E                 FALSE    1765mmm     IFNE DEBUG
0000099E                          1766mmm     ENDC
0000099E                          1767mmm 
0000099E  BA3C 001B               1768mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009A2  6700 F760               1769mmm     BEQ START
000009A6                          1770mmm     ENDM
000009A6                          1771mm CONTINUE_88
000009A6  1A39 00C00013           1772mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009AC  0805 0000               1773mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009B0  67D8                    1774mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
000009B2                          1775mm     
000009B2  1A39 00C00017           1776mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009B8  13C5 00E00001           1777mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009BE                          1778mm 
000009BE                          1779mm     ENDM
000009BE                          1780m         ;PRINT_CHAR D5,D6
000009BE                          1781mm         HEX2BIN D5,D5,A4
000009BE  49FA 169A               1782mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009C2  0405 0030               1783mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009C6  CABC 000000FF           1784mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009CC  1A34 5000               1785mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009D0                          1786mm     ENDM
000009D0  8805                    1787m         OR.B D5,D4
000009D2  5307                    1788m         SUB.B #1,D7
000009D4                          1789m     ENDW
000009D4  60AA                    1790ms     BRA _10000010
000009D6                          1791ms _10000011
000009D6                          1792m 
000009D6  7A00                    1793m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009D8  1A04                    1794m     MOVE.B D4,D5
000009DA  D484                    1795m     ADD.L D4,D2
000009DC                          1796m 
000009DC                          1797m     ENDM
000009DC                          1798  
000009DC  2044                    1799                  MOVE.L D4,A0                        ; start address -> A0
000009DE  D1C9                    1800                  ADD.L A1,A0                         ; add in the offset
000009E0                          1801  
000009E0  72FF                    1802                  MOVE.L #$FFFFFFFF,D1                ; done
000009E2                          1803              ELSE
000009E2  6000 0078               1804s     BRA _0000000A
000009E6                          1805s _00000009
000009E6                          1806m                 PRINT_CRLF D5,A4
000009E6  49FA 169D               1807m     LEA CRLF(PC),A4
000009EA                          1808mm     PRINT_STR A4,D5
000009EA                          1809mm LOOP_92
000009EA  0C14 0000               1810mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009EE  6700 0016               1811mm     BEQ EXIT_92
000009F2                          1812mmm     PRINT_CHAR (A4)+,D5
000009F2                          1813mmm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F2                 TRUE     1814mmm     IFEQ DEBUG
000009F2  1A39 00C00003           1815mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009F8  0805 0002               1816mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009FC  67F4                    1817mmm         BEQ WAIT_FOR_READY_93                       ; NO SPACE, CHECK AGAIN
000009FE  13DC 00C00007           1818mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A04                          1819mmm     ENDC
00000A04                          1820mmm 
00000A04                 FALSE    1821mmm     IFNE DEBUG
00000A04                          1822mmm     ENDC
00000A04                          1823mmm 
00000A04                          1824mmm     ENDM
00000A04  60E4                    1825mm     BRA LOOP_92
00000A06                          1826mm EXIT_92
00000A06                          1827mm     ENDM
00000A06                          1828m     ENDM
00000A06                          1829  
00000A06  49FA 1609               1830                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000A0A                          1831m                 PRINT_STR A4,D5
00000A0A                          1832m LOOP_94
00000A0A  0C14 0000               1833m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A0E  6700 0016               1834m     BEQ EXIT_94
00000A12                          1835mm     PRINT_CHAR (A4)+,D5
00000A12                          1836mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A12                 TRUE     1837mm     IFEQ DEBUG
00000A12  1A39 00C00003           1838mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A18  0805 0002               1839mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A1C  67F4                    1840mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000A1E  13DC 00C00007           1841mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A24                          1842mm     ENDC
00000A24                          1843mm 
00000A24                 FALSE    1844mm     IFNE DEBUG
00000A24                          1845mm     ENDC
00000A24                          1846mm 
00000A24                          1847mm     ENDM
00000A24  60E4                    1848m     BRA LOOP_94
00000A26                          1849m EXIT_94
00000A26                          1850m     ENDM
00000A26                          1851m                 PRINT_CHAR D1,D5
00000A26                          1852m WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1853m     IFEQ DEBUG
00000A26  1A39 00C00003           1854m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A2C  0805 0002               1855m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1856m         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
00000A32  13C1 00C00007           1857m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A38                          1858m     ENDC
00000A38                          1859m 
00000A38                 FALSE    1860m     IFNE DEBUG
00000A38                          1861m     ENDC
00000A38                          1862m 
00000A38                          1863m     ENDM
00000A38                          1864m                 PRINT_CRLF D5,A4
00000A38  49FA 164B               1865m     LEA CRLF(PC),A4
00000A3C                          1866mm     PRINT_STR A4,D5
00000A3C                          1867mm LOOP_98
00000A3C  0C14 0000               1868mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A40  6700 0016               1869mm     BEQ EXIT_98
00000A44                          1870mmm     PRINT_CHAR (A4)+,D5
00000A44                          1871mmm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A44                 TRUE     1872mmm     IFEQ DEBUG
00000A44  1A39 00C00003           1873mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A4A  0805 0002               1874mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A4E  67F4                    1875mmm         BEQ WAIT_FOR_READY_99                       ; NO SPACE, CHECK AGAIN
00000A50  13DC 00C00007           1876mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A56                          1877mmm     ENDC
00000A56                          1878mmm 
00000A56                 FALSE    1879mmm     IFNE DEBUG
00000A56                          1880mmm     ENDC
00000A56                          1881mmm 
00000A56                          1882mmm     ENDM
00000A56  60E4                    1883mm     BRA LOOP_98
00000A58                          1884mm EXIT_98
00000A58                          1885mm     ENDM
00000A58                          1886m     ENDM
00000A58                          1887  
00000A58  6000 FBAE               1888                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000A5C                          1889              ENDI
00000A5C                          1890s _0000000A
00000A5C                          1891          ENDI
00000A5C                          1892s _00000008
00000A5C                          1893      ENDI
00000A5C                          1894s _00000004
00000A5C                          1895  
00000A5C                          1896m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000A5C  1E3C 0002               1897m     MOVE.B #2,D7
00000A60                          1898m     WHILE.B D7 <GT> 0 DO
00000A60                          1899ms _10000012
00000A60  BE38 0000               1900ms     CMP.B   0,D7
00000A64  6F00 0050               1901ms     BLE _10000013
00000A68  E98C                    1902m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A6A                          1903mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A6A                          1904mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A6A                          1905mm 
00000A6A  1A39 00C00003           1906mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A70  0805 0000               1907mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A74  6700 0010               1908mm     BEQ CONTINUE_101                                    ; NOTHING, CONTINUE
00000A78                          1909mm 
00000A78                          1910mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A78                 TRUE     1911mmm     IFEQ DEBUG
00000A78  1A39 00C00007           1912mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A7E                          1913mmm     ENDC
00000A7E                 FALSE    1914mmm     IFNE DEBUG
00000A7E                          1915mmm     ENDC
00000A7E                          1916mmm 
00000A7E  BA3C 001B               1917mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A82  6700 F680               1918mmm     BEQ START
00000A86                          1919mmm     ENDM
00000A86                          1920mm CONTINUE_101
00000A86  1A39 00C00013           1921mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A8C  0805 0000               1922mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A90  67D8                    1923mm     BEQ WAIT_FOR_READY_101                          ; NOTHING, CHECK AGAIN
00000A92                          1924mm     
00000A92  1A39 00C00017           1925mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A98  13C5 00E00001           1926mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A9E                          1927mm 
00000A9E                          1928mm     ENDM
00000A9E                          1929m         ;PRINT_CHAR D5,D6
00000A9E                          1930mm         HEX2BIN D5,D5,A4
00000A9E  49FA 15BA               1931mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000AA2  0405 0030               1932mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AA6  CABC 000000FF           1933mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000AAC  1A34 5000               1934mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000AB0                          1935mm     ENDM
00000AB0  8805                    1936m         OR.B D5,D4
00000AB2  5307                    1937m         SUB.B #1,D7
00000AB4                          1938m     ENDW
00000AB4  60AA                    1939ms     BRA _10000012
00000AB6                          1940ms _10000013
00000AB6                          1941m 
00000AB6  7A00                    1942m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AB8  1A04                    1943m     MOVE.B D4,D5
00000ABA  D484                    1944m     ADD.L D4,D2
00000ABC                          1945m 
00000ABC                          1946m     ENDM
00000ABC                          1947  
00000ABC                          1948      IF.B D2 <NE> #$FF THEN.L
00000ABC  B43C 00FF               1949s     CMP.B   #$FF,D2
00000AC0  6700 00B0               1950s     BEQ.L   _0000000B
00000AC4                          1951m         PRINT_CRLF D5,A4
00000AC4  49FA 15BF               1952m     LEA CRLF(PC),A4
00000AC8                          1953mm     PRINT_STR A4,D5
00000AC8                          1954mm LOOP_105
00000AC8  0C14 0000               1955mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ACC  6700 0016               1956mm     BEQ EXIT_105
00000AD0                          1957mmm     PRINT_CHAR (A4)+,D5
00000AD0                          1958mmm WAIT_FOR_READY_106                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD0                 TRUE     1959mmm     IFEQ DEBUG
00000AD0  1A39 00C00003           1960mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AD6  0805 0002               1961mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ADA  67F4                    1962mmm         BEQ WAIT_FOR_READY_106                      ; NO SPACE, CHECK AGAIN
00000ADC  13DC 00C00007           1963mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AE2                          1964mmm     ENDC
00000AE2                          1965mmm 
00000AE2                 FALSE    1966mmm     IFNE DEBUG
00000AE2                          1967mmm     ENDC
00000AE2                          1968mmm 
00000AE2                          1969mmm     ENDM
00000AE2  60E4                    1970mm     BRA LOOP_105
00000AE4                          1971mm EXIT_105
00000AE4                          1972mm     ENDM
00000AE4                          1973m     ENDM
00000AE4  49FA 1542               1974          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000AE8                          1975m         PRINT_STR A4,D5
00000AE8                          1976m LOOP_107
00000AE8  0C14 0000               1977m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AEC  6700 0016               1978m     BEQ EXIT_107
00000AF0                          1979mm     PRINT_CHAR (A4)+,D5
00000AF0                          1980mm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AF0                 TRUE     1981mm     IFEQ DEBUG
00000AF0  1A39 00C00003           1982mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AF6  0805 0002               1983mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AFA  67F4                    1984mm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AFC  13DC 00C00007           1985mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B02                          1986mm     ENDC
00000B02                          1987mm 
00000B02                 FALSE    1988mm     IFNE DEBUG
00000B02                          1989mm     ENDC
00000B02                          1990mm 
00000B02                          1991mm     ENDM
00000B02  60E4                    1992m     BRA LOOP_107
00000B04                          1993m EXIT_107
00000B04                          1994m     ENDM
00000B04                          1995m         PRINT_REG D0,D5,D3,D6,A4
00000B04  49FA 1585               1996m     LEA OX(PC),A4
00000B08                          1997mm     PRINT_STR A4,D5
00000B08                          1998mm LOOP_110
00000B08  0C14 0000               1999mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B0C  6700 0016               2000mm     BEQ EXIT_110
00000B10                          2001mmm     PRINT_CHAR (A4)+,D5
00000B10                          2002mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B10                 TRUE     2003mmm     IFEQ DEBUG
00000B10  1A39 00C00003           2004mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B16  0805 0002               2005mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B1A  67F4                    2006mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000B1C  13DC 00C00007           2007mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B22                          2008mmm     ENDC
00000B22                          2009mmm 
00000B22                 FALSE    2010mmm     IFNE DEBUG
00000B22                          2011mmm     ENDC
00000B22                          2012mmm 
00000B22                          2013mmm     ENDM
00000B22  60E4                    2014mm     BRA LOOP_110
00000B24                          2015mm EXIT_110
00000B24                          2016mm     ENDM
00000B24  7C07                    2017m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B26                          2018m LOOP_109
00000B26                          2019mm     BIN2HEX D0,D3,A4
00000B26  49FA 1522               2020mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B2A  E998                    2021mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B2C  1600                    2022mm     MOVE.B D0,D3
00000B2E  0283 0000000F           2023mm     ANDI.L #$F,D3
00000B34  1634 3000               2024mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000B38                          2025mm     ENDM
00000B38                          2026mm     PRINT_CHAR D3,D5
00000B38                          2027mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B38                 TRUE     2028mm     IFEQ DEBUG
00000B38  1A39 00C00003           2029mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B3E  0805 0002               2030mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B42  67F4                    2031mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000B44  13C3 00C00007           2032mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B4A                          2033mm     ENDC
00000B4A                          2034mm 
00000B4A                 FALSE    2035mm     IFNE DEBUG
00000B4A                          2036mm     ENDC
00000B4A                          2037mm 
00000B4A                          2038mm     ENDM
00000B4A  57CE FFDA               2039m     DBEQ D6,LOOP_109
00000B4E                          2040m     ENDM
00000B4E                          2041m         PRINT_CRLF D5,A4
00000B4E  49FA 1535               2042m     LEA CRLF(PC),A4
00000B52                          2043mm     PRINT_STR A4,D5
00000B52                          2044mm LOOP_115
00000B52  0C14 0000               2045mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B56  6700 0016               2046mm     BEQ EXIT_115
00000B5A                          2047mmm     PRINT_CHAR (A4)+,D5
00000B5A                          2048mmm WAIT_FOR_READY_116                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B5A                 TRUE     2049mmm     IFEQ DEBUG
00000B5A  1A39 00C00003           2050mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B60  0805 0002               2051mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B64  67F4                    2052mmm         BEQ WAIT_FOR_READY_116                      ; NO SPACE, CHECK AGAIN
00000B66  13DC 00C00007           2053mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B6C                          2054mmm     ENDC
00000B6C                          2055mmm 
00000B6C                 FALSE    2056mmm     IFNE DEBUG
00000B6C                          2057mmm     ENDC
00000B6C                          2058mmm 
00000B6C                          2059mmm     ENDM
00000B6C  60E4                    2060mm     BRA LOOP_115
00000B6E                          2061mm EXIT_115
00000B6E                          2062mm     ENDM
00000B6E                          2063m     ENDM
00000B6E                          2064          
00000B6E  6000 F7D4               2065          BRA MAIN_LOOP
00000B72                          2066      ENDI
00000B72                          2067s _0000000B
00000B72                          2068  
00000B72                          2069      IF D1 <EQ> #0 THEN
00000B72  B27C 0000               2070s     CMP.W   #0,D1
00000B76  6600 0006               2071s     BNE _0000000C
00000B7A  6000 FA8C               2072        BRA WAIT_FOR_SRECORD
00000B7E                          2073      ENDI
00000B7E                          2074s _0000000C
00000B7E                          2075  DOWNLOAD_DONE
00000B7E                          2076m     PRINT_CRLF D5,A4
00000B7E  49FA 1505               2077m     LEA CRLF(PC),A4
00000B82                          2078mm     PRINT_STR A4,D5
00000B82                          2079mm LOOP_118
00000B82  0C14 0000               2080mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B86  6700 0016               2081mm     BEQ EXIT_118
00000B8A                          2082mmm     PRINT_CHAR (A4)+,D5
00000B8A                          2083mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B8A                 TRUE     2084mmm     IFEQ DEBUG
00000B8A  1A39 00C00003           2085mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B90  0805 0002               2086mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B94  67F4                    2087mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B96  13DC 00C00007           2088mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B9C                          2089mmm     ENDC
00000B9C                          2090mmm 
00000B9C                 FALSE    2091mmm     IFNE DEBUG
00000B9C                          2092mmm     ENDC
00000B9C                          2093mmm 
00000B9C                          2094mmm     ENDM
00000B9C  60E4                    2095mm     BRA LOOP_118
00000B9E                          2096mm EXIT_118
00000B9E                          2097mm     ENDM
00000B9E                          2098m     ENDM
00000B9E                          2099m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000B9E  43FA 14EB               2100m     LEA OX(PC),A1
00000BA2                          2101mm     PRINT_STR A1,D5
00000BA2                          2102mm LOOP_121
00000BA2  0C11 0000               2103mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BA6  6700 0016               2104mm     BEQ EXIT_121
00000BAA                          2105mmm     PRINT_CHAR (A1)+,D5
00000BAA                          2106mmm WAIT_FOR_READY_122                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BAA                 TRUE     2107mmm     IFEQ DEBUG
00000BAA  1A39 00C00003           2108mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BB0  0805 0002               2109mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BB4  67F4                    2110mmm         BEQ WAIT_FOR_READY_122                      ; NO SPACE, CHECK AGAIN
00000BB6  13D9 00C00007           2111mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BBC                          2112mmm     ENDC
00000BBC                          2113mmm 
00000BBC                 FALSE    2114mmm     IFNE DEBUG
00000BBC                          2115mmm     ENDC
00000BBC                          2116mmm 
00000BBC                          2117mmm     ENDM
00000BBC  60E4                    2118mm     BRA LOOP_121
00000BBE                          2119mm EXIT_121
00000BBE                          2120mm     ENDM
00000BBE  7407                    2121m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BC0                          2122m LOOP_120
00000BC0                          2123mm     BIN2HEX D0,D6,A1
00000BC0  43FA 1488               2124mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BC4  E998                    2125mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BC6  1C00                    2126mm     MOVE.B D0,D6
00000BC8  0286 0000000F           2127mm     ANDI.L #$F,D6
00000BCE  1C31 6000               2128mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000BD2                          2129mm     ENDM
00000BD2                          2130mm     PRINT_CHAR D6,D5
00000BD2                          2131mm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                 TRUE     2132mm     IFEQ DEBUG
00000BD2  1A39 00C00003           2133mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BD8  0805 0002               2134mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BDC  67F4                    2135mm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BDE  13C6 00C00007           2136mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BE4                          2137mm     ENDC
00000BE4                          2138mm 
00000BE4                 FALSE    2139mm     IFNE DEBUG
00000BE4                          2140mm     ENDC
00000BE4                          2141mm 
00000BE4                          2142mm     ENDM
00000BE4  57CA FFDA               2143m     DBEQ D2,LOOP_120
00000BE8                          2144m     ENDM
00000BE8  43FA 1405               2145      LEA READ(PC),A1
00000BEC                          2146m     PRINT_STR A1,D5
00000BEC                          2147m LOOP_125
00000BEC  0C11 0000               2148m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BF0  6700 0016               2149m     BEQ EXIT_125
00000BF4                          2150mm     PRINT_CHAR (A1)+,D5
00000BF4                          2151mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF4                 TRUE     2152mm     IFEQ DEBUG
00000BF4  1A39 00C00003           2153mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BFA  0805 0002               2154mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BFE  67F4                    2155mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000C00  13D9 00C00007           2156mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C06                          2157mm     ENDC
00000C06                          2158mm 
00000C06                 FALSE    2159mm     IFNE DEBUG
00000C06                          2160mm     ENDC
00000C06                          2161mm 
00000C06                          2162mm     ENDM
00000C06  60E4                    2163m     BRA LOOP_125
00000C08                          2164m EXIT_125
00000C08                          2165m     ENDM
00000C08  2E08                    2166      MOVE.L A0,D7                                    ; set address accumulator to start address
00000C0A                          2167m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000C0A  43FA 147F               2168m     LEA OX(PC),A1
00000C0E                          2169mm     PRINT_STR A1,D5
00000C0E                          2170mm LOOP_128
00000C0E  0C11 0000               2171mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C12  6700 0016               2172mm     BEQ EXIT_128
00000C16                          2173mmm     PRINT_CHAR (A1)+,D5
00000C16                          2174mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C16                 TRUE     2175mmm     IFEQ DEBUG
00000C16  1A39 00C00003           2176mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C1C  0805 0002               2177mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C20  67F4                    2178mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000C22  13D9 00C00007           2179mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C28                          2180mmm     ENDC
00000C28                          2181mmm 
00000C28                 FALSE    2182mmm     IFNE DEBUG
00000C28                          2183mmm     ENDC
00000C28                          2184mmm 
00000C28                          2185mmm     ENDM
00000C28  60E4                    2186mm     BRA LOOP_128
00000C2A                          2187mm EXIT_128
00000C2A                          2188mm     ENDM
00000C2A  7407                    2189m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C2C                          2190m LOOP_127
00000C2C                          2191mm     BIN2HEX D7,D6,A1
00000C2C  43FA 141C               2192mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C30  E99F                    2193mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C32  1C07                    2194mm     MOVE.B D7,D6
00000C34  0286 0000000F           2195mm     ANDI.L #$F,D6
00000C3A  1C31 6000               2196mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C3E                          2197mm     ENDM
00000C3E                          2198mm     PRINT_CHAR D6,D5
00000C3E                          2199mm WAIT_FOR_READY_131                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C3E                 TRUE     2200mm     IFEQ DEBUG
00000C3E  1A39 00C00003           2201mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C44  0805 0002               2202mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C48  67F4                    2203mm         BEQ WAIT_FOR_READY_131                      ; NO SPACE, CHECK AGAIN
00000C4A  13C6 00C00007           2204mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C50                          2205mm     ENDC
00000C50                          2206mm 
00000C50                 FALSE    2207mm     IFNE DEBUG
00000C50                          2208mm     ENDC
00000C50                          2209mm 
00000C50                          2210mm     ENDM
00000C50  57CA FFDA               2211m     DBEQ D2,LOOP_127
00000C54                          2212m     ENDM
00000C54                          2213m     PRINT_CRLF D5,A4
00000C54  49FA 142F               2214m     LEA CRLF(PC),A4
00000C58                          2215mm     PRINT_STR A4,D5
00000C58                          2216mm LOOP_133
00000C58  0C14 0000               2217mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000C5C  6700 0016               2218mm     BEQ EXIT_133
00000C60                          2219mmm     PRINT_CHAR (A4)+,D5
00000C60                          2220mmm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C60                 TRUE     2221mmm     IFEQ DEBUG
00000C60  1A39 00C00003           2222mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C66  0805 0002               2223mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C6A  67F4                    2224mmm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C6C  13DC 00C00007           2225mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C72                          2226mmm     ENDC
00000C72                          2227mmm 
00000C72                 FALSE    2228mmm     IFNE DEBUG
00000C72                          2229mmm     ENDC
00000C72                          2230mmm 
00000C72                          2231mmm     ENDM
00000C72  60E4                    2232mm     BRA LOOP_133
00000C74                          2233mm EXIT_133
00000C74                          2234mm     ENDM
00000C74                          2235m     ENDM
00000C74                          2236  
00000C74  6000 F6CE               2237      BRA MAIN_LOOP
00000C78                          2238  
00000C78                          2239  G
00000C78  2047                    2240      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000C7A  7E00                    2241      MOVE.L #0,D7
00000C7C                          2242  
00000C7C  4ED0                    2243      JMP (A0)
00000C7E                          2244          
00000C7E                          2245  Z
00000C7E  207C 00200000           2246      MOVE.L #RAM,A0                                  ; address of RAM
00000C84  D1FC 00100000           2247      ADD.L #$100000,A0
00000C8A                          2248  
00000C8A                          2249      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000C8A  7000                    2250s     MOVE.L  #0,D0
00000C8C  6000 0012               2251s     BRA _20000007
00000C90                          2252s _20000006
00000C90  2200                    2253          MOVE.L D0,D1                                ; progress update
00000C92  E089                    2254          LSR.L #8,D1 
00000C94  E089                    2255          LSR.L #8,D1
00000C96  13C1 00E00001           2256          MOVE.B D1,DISPLAY
00000C9C                          2257          
00000C9C  2108                    2258          MOVE.L A0,-(A0)
00000C9E                          2259      ENDF
00000C9E  5880                    2260s     ADD.L   #4,D0
00000CA0                          2261s _20000007
00000CA0  B0BC 000FFFFC           2262s     CMP.L   #$FFFFC,D0
00000CA6  6FE8                    2263s     BLE _20000006
00000CA8                          2264  
00000CA8  207C 00200000           2265      MOVE.L #RAM,A0                                  ; address of RAM
00000CAE  D1FC 00100000           2266      ADD.L #$100000,A0
00000CB4                          2267  
00000CB4                          2268      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000CB4  7000                    2269s     MOVE.L  #0,D0
00000CB6  6000 00A8               2270s     BRA _20000009
00000CBA                          2271s _20000008
00000CBA  2200                    2272          MOVE.L D0,D1                                ; progress update
00000CBC  E089                    2273          LSR.L #8,D1
00000CBE  E089                    2274          LSR.L #8,D1
00000CC0  13C1 00E00001           2275          MOVE.B D1,DISPLAY
00000CC6                          2276  
00000CC6  2408                    2277          MOVE.L A0,D2
00000CC8  2220                    2278          MOVE.L -(A0),D1
00000CCA                          2279  
00000CCA                          2280          IF.L D2 <NE> D1 THEN
00000CCA  B481                    2281s     CMP.L   D1,D2
00000CCC  6700 0090               2282s     BEQ _0000000D
00000CD0  43FA 1367               2283              LEA RAM_ERROR(PC),A1
00000CD4                          2284m             PRINT_STR A1,D1
00000CD4                          2285m LOOP_135
00000CD4  0C11 0000               2286m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CD8  6700 0016               2287m     BEQ EXIT_135
00000CDC                          2288mm     PRINT_CHAR (A1)+,D1
00000CDC                          2289mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CDC                 TRUE     2290mm     IFEQ DEBUG
00000CDC  1239 00C00003           2291mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000CE2  0801 0002               2292mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000CE6  67F4                    2293mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000CE8  13D9 00C00007           2294mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CEE                          2295mm     ENDC
00000CEE                          2296mm 
00000CEE                 FALSE    2297mm     IFNE DEBUG
00000CEE                          2298mm     ENDC
00000CEE                          2299mm 
00000CEE                          2300mm     ENDM
00000CEE  60E4                    2301m     BRA LOOP_135
00000CF0                          2302m EXIT_135
00000CF0                          2303m     ENDM
00000CF0  2208                    2304              MOVE.L A0,D1
00000CF2  5981                    2305              SUB.L #4,D1
00000CF4                          2306m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000CF4  43FA 1395               2307m     LEA OX(PC),A1
00000CF8                          2308mm     PRINT_STR A1,D3
00000CF8                          2309mm LOOP_138
00000CF8  0C11 0000               2310mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CFC  6700 0016               2311mm     BEQ EXIT_138
00000D00                          2312mmm     PRINT_CHAR (A1)+,D3
00000D00                          2313mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     2314mmm     IFEQ DEBUG
00000D00  1639 00C00003           2315mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D06  0803 0002               2316mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    2317mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000D0C  13D9 00C00007           2318mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D12                          2319mmm     ENDC
00000D12                          2320mmm 
00000D12                 FALSE    2321mmm     IFNE DEBUG
00000D12                          2322mmm     ENDC
00000D12                          2323mmm 
00000D12                          2324mmm     ENDM
00000D12  60E4                    2325mm     BRA LOOP_138
00000D14                          2326mm EXIT_138
00000D14                          2327mm     ENDM
00000D14  7C07                    2328m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D16                          2329m LOOP_137
00000D16                          2330mm     BIN2HEX D1,D2,A1
00000D16  43FA 1332               2331mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000D1A  E999                    2332mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D1C  1401                    2333mm     MOVE.B D1,D2
00000D1E  0282 0000000F           2334mm     ANDI.L #$F,D2
00000D24  1431 2000               2335mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000D28                          2336mm     ENDM
00000D28                          2337mm     PRINT_CHAR D2,D3
00000D28                          2338mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D28                 TRUE     2339mm     IFEQ DEBUG
00000D28  1639 00C00003           2340mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D2E  0803 0002               2341mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D32  67F4                    2342mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000D34  13C2 00C00007           2343mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D3A                          2344mm     ENDC
00000D3A                          2345mm 
00000D3A                 FALSE    2346mm     IFNE DEBUG
00000D3A                          2347mm     ENDC
00000D3A                          2348mm 
00000D3A                          2349mm     ENDM
00000D3A  57CE FFDA               2350m     DBEQ D6,LOOP_137
00000D3E                          2351m     ENDM
00000D3E                          2352m             PRINT_CRLF D3,A1
00000D3E  43FA 1345               2353m     LEA CRLF(PC),A1
00000D42                          2354mm     PRINT_STR A1,D3
00000D42                          2355mm LOOP_143
00000D42  0C11 0000               2356mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D46  6700 0016               2357mm     BEQ EXIT_143
00000D4A                          2358mmm     PRINT_CHAR (A1)+,D3
00000D4A                          2359mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D4A                 TRUE     2360mmm     IFEQ DEBUG
00000D4A  1639 00C00003           2361mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D50  0803 0002               2362mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D54  67F4                    2363mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000D56  13D9 00C00007           2364mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D5C                          2365mmm     ENDC
00000D5C                          2366mmm 
00000D5C                 FALSE    2367mmm     IFNE DEBUG
00000D5C                          2368mmm     ENDC
00000D5C                          2369mmm 
00000D5C                          2370mmm     ENDM
00000D5C  60E4                    2371mm     BRA LOOP_143
00000D5E                          2372mm EXIT_143
00000D5E                          2373mm     ENDM
00000D5E                          2374m     ENDM
00000D5E                          2375          ENDI 
00000D5E                          2376s _0000000D
00000D5E                          2377      ENDF
00000D5E  5880                    2378s     ADD.L   #4,D0
00000D60                          2379s _20000009
00000D60  B0BC 000FFFFC           2380s     CMP.L   #$FFFFC,D0
00000D66  6F00 FF52               2381s     BLE _20000008
00000D6A                          2382  
00000D6A  6000 F5D8               2383      BRA MAIN_LOOP
00000D6E                          2384  
00000D6E                          2385  L
00000D6E  7000                    2386      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000D70  7200                    2387      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000D72                          2388  
00000D72                          2389      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000D72  343C 0000               2390s     MOVE.W  #0,D2
00000D76  6000 0046               2391s     BRA _2000000B
00000D7A                          2392s _2000000A
00000D7A  E989                    2393          LSL.L #4,D1                                 ; make what we have so far more significant
00000D7C                          2394m         WAIT_CHAR D3,D4                             ; next character -> D2
00000D7C                          2395m WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D7C                 TRUE     2396m     IFEQ DEBUG
00000D7C  1839 00C00003           2397m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000D82  0804 0000               2398m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000D86  67F4                    2399m         BEQ WAIT_FOR_READY_145                      ; NOTHING, CHECK AGAIN
00000D88                          2400m     ENDC
00000D88                          2401m 
00000D88                          2402mm     READ_CHAR D3
00000D88                 TRUE     2403mm     IFEQ DEBUG
00000D88  1639 00C00007           2404mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000D8E                          2405mm     ENDC
00000D8E                 FALSE    2406mm     IFNE DEBUG
00000D8E                          2407mm     ENDC
00000D8E                          2408mm 
00000D8E  B63C 001B               2409mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000D92  6700 F370               2410mm     BEQ START
00000D96                          2411mm     ENDM
00000D96                          2412m 
00000D96                 TRUE     2413m     IFEQ DEBUG
00000D96                          2414mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000D96                          2415mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D96                 TRUE     2416mm     IFEQ DEBUG
00000D96  1839 00C00003           2417mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000D9C  0804 0002               2418mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000DA0  67F4                    2419mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000DA2  13C3 00C00007           2420mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DA8                          2421mm     ENDC
00000DA8                          2422mm 
00000DA8                 FALSE    2423mm     IFNE DEBUG
00000DA8                          2424mm     ENDC
00000DA8                          2425mm 
00000DA8                          2426mm     ENDM
00000DA8                          2427m     ENDC
00000DA8                          2428m     ENDM
00000DA8                          2429m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000DA8  41FA 12B0               2430m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000DAC  0403 0030               2431m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DB0  C6BC 000000FF           2432m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000DB6  1630 3000               2433m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000DBA                          2434m     ENDM
00000DBA  8203                    2435          OR.B D3,D1
00000DBC                          2436      ENDF
00000DBC  5242                    2437s     ADD.W   #1,D2
00000DBE                          2438s _2000000B
00000DBE  B47C 0007               2439s     CMP.W   #7,D2
00000DC2  6FB6                    2440s     BLE _2000000A
00000DC4                          2441  
00000DC4  3001                    2442      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000DC6  0480 00000104           2443      SUB.L #START,D0                                 ; remove the vector table from the length
00000DCC  E089                    2444      LSR.L #8,D1                                     ; extract the MSword for the address
00000DCE  E089                    2445      LSR.L #8,D1
00000DD0                          2446  
00000DD0                          2447m     PRINT_CRLF D2,A1
00000DD0  43FA 12B3               2448m     LEA CRLF(PC),A1
00000DD4                          2449mm     PRINT_STR A1,D2
00000DD4                          2450mm LOOP_150
00000DD4  0C11 0000               2451mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DD8  6700 0016               2452mm     BEQ EXIT_150
00000DDC                          2453mmm     PRINT_CHAR (A1)+,D2
00000DDC                          2454mmm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDC                 TRUE     2455mmm     IFEQ DEBUG
00000DDC  1439 00C00003           2456mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000DE2  0802 0002               2457mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000DE6  67F4                    2458mmm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DE8  13D9 00C00007           2459mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DEE                          2460mmm     ENDC
00000DEE                          2461mmm 
00000DEE                 FALSE    2462mmm     IFNE DEBUG
00000DEE                          2463mmm     ENDC
00000DEE                          2464mmm 
00000DEE                          2465mmm     ENDM
00000DEE  60E4                    2466mm     BRA LOOP_150
00000DF0                          2467mm EXIT_150
00000DF0                          2468mm     ENDM
00000DF0                          2469m     ENDM
00000DF0                          2470  
00000DF0  2041                    2471      MOVE.L D1,A0                                    ; target address
00000DF2  2641                    2472      MOVE.L D1,A3                                    ; keep a copy for later
00000DF4                          2473  
00000DF4  2247                    2474      MOVE.L D7,A1                                    ; address accumulator -> address register
00000DF6  D3FC 00000104           2475      ADD.L #START,A1                                 ; skip the vectors
00000DFC  2847                    2476      MOVE.L D7,A4                                    ; keep a clean copy for later
00000DFE  7E00                    2477      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E00                          2478  
00000E00                          2479m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000E00  31FC AAAA 2AAA          2480m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E06  4E71                    2481m     NOP
00000E08  31FC 5555 1554          2482m     MOVE.W #$5555,$1554
00000E0E  4E71                    2483m     NOP
00000E10  31FC 8080 2AAA          2484m     MOVE.W #$8080,$2AAA
00000E16  4E71                    2485m     NOP
00000E18  31FC AAAA 2AAA          2486m     MOVE.W #$AAAA,$2AAA
00000E1E  4E71                    2487m     NOP
00000E20  31FC 5555 1554          2488m     MOVE.W #$5555,$1554
00000E26  4E71                    2489m     NOP
00000E28  31FC 2020 2AAA          2490m     MOVE.W #$2020,$2AAA
00000E2E                          2491m     ENDM
00000E2E                          2492                      
00000E2E                          2493      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000E2E  3E3C 0000               2494s     MOVE.W  #$0,D7
00000E32  6000 0006               2495s     BRA _2000000D
00000E36                          2496s _2000000C
00000E36  4E71                    2497          NOP
00000E38                          2498      ENDF
00000E38  5247                    2499s     ADD.W   #1,D7
00000E3A                          2500s _2000000D
00000E3A  BE7C FFFF               2501s     CMP.W   #$FFFFFFFF,D7
00000E3E  6FF6                    2502s     BLE _2000000C
00000E40                          2503                  
00000E40  45FA 122F               2504      LEA LOADING(PC),A2
00000E44                          2505m     PRINT_STR A2,D2
00000E44                          2506m LOOP_153
00000E44  0C12 0000               2507m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E48  6700 0016               2508m     BEQ EXIT_153
00000E4C                          2509mm     PRINT_CHAR (A2)+,D2
00000E4C                          2510mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4C                 TRUE     2511mm     IFEQ DEBUG
00000E4C  1439 00C00003           2512mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E52  0802 0002               2513mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E56  67F4                    2514mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000E58  13DA 00C00007           2515mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E5E                          2516mm     ENDC
00000E5E                          2517mm 
00000E5E                 FALSE    2518mm     IFNE DEBUG
00000E5E                          2519mm     ENDC
00000E5E                          2520mm 
00000E5E                          2521mm     ENDM
00000E5E  60E4                    2522m     BRA LOOP_153
00000E60                          2523m EXIT_153
00000E60                          2524m     ENDM
00000E60                          2525          
00000E60  2409                    2526      MOVE.L A1,D2
00000E62                          2527m     PRINT_REG D2,D3,D4,D5,A2
00000E62  45FA 1227               2528m     LEA OX(PC),A2
00000E66                          2529mm     PRINT_STR A2,D3
00000E66                          2530mm LOOP_156
00000E66  0C12 0000               2531mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E6A  6700 0016               2532mm     BEQ EXIT_156
00000E6E                          2533mmm     PRINT_CHAR (A2)+,D3
00000E6E                          2534mmm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E6E                 TRUE     2535mmm     IFEQ DEBUG
00000E6E  1639 00C00003           2536mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E74  0803 0002               2537mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E78  67F4                    2538mmm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E7A  13DA 00C00007           2539mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E80                          2540mmm     ENDC
00000E80                          2541mmm 
00000E80                 FALSE    2542mmm     IFNE DEBUG
00000E80                          2543mmm     ENDC
00000E80                          2544mmm 
00000E80                          2545mmm     ENDM
00000E80  60E4                    2546mm     BRA LOOP_156
00000E82                          2547mm EXIT_156
00000E82                          2548mm     ENDM
00000E82  7A07                    2549m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E84                          2550m LOOP_155
00000E84                          2551mm     BIN2HEX D2,D4,A2
00000E84  45FA 11C4               2552mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E88  E99A                    2553mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E8A  1802                    2554mm     MOVE.B D2,D4
00000E8C  0284 0000000F           2555mm     ANDI.L #$F,D4
00000E92  1832 4000               2556mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E96                          2557mm     ENDM
00000E96                          2558mm     PRINT_CHAR D4,D3
00000E96                          2559mm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E96                 TRUE     2560mm     IFEQ DEBUG
00000E96  1639 00C00003           2561mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E9C  0803 0002               2562mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EA0  67F4                    2563mm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000EA2  13C4 00C00007           2564mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000EA8                          2565mm     ENDC
00000EA8                          2566mm 
00000EA8                 FALSE    2567mm     IFNE DEBUG
00000EA8                          2568mm     ENDC
00000EA8                          2569mm 
00000EA8                          2570mm     ENDM
00000EA8  57CD FFDA               2571m     DBEQ D5,LOOP_155
00000EAC                          2572m     ENDM
00000EAC                          2573  
00000EAC  45FA 11E0               2574      LEA TO(PC),A2
00000EB0                          2575m     PRINT_STR A2,D3
00000EB0                          2576m LOOP_160
00000EB0  0C12 0000               2577m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EB4  6700 0016               2578m     BEQ EXIT_160
00000EB8                          2579mm     PRINT_CHAR (A2)+,D3
00000EB8                          2580mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EB8                 TRUE     2581mm     IFEQ DEBUG
00000EB8  1639 00C00003           2582mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EBE  0803 0002               2583mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EC2  67F4                    2584mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000EC4  13DA 00C00007           2585mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ECA                          2586mm     ENDC
00000ECA                          2587mm 
00000ECA                 FALSE    2588mm     IFNE DEBUG
00000ECA                          2589mm     ENDC
00000ECA                          2590mm 
00000ECA                          2591mm     ENDM
00000ECA  60E4                    2592m     BRA LOOP_160
00000ECC                          2593m EXIT_160
00000ECC                          2594m     ENDM
00000ECC                          2595  
00000ECC  2408                    2596      MOVE.L A0,D2
00000ECE                          2597m     PRINT_REG D2,D3,D4,D5,A2
00000ECE  45FA 11BB               2598m     LEA OX(PC),A2
00000ED2                          2599mm     PRINT_STR A2,D3
00000ED2                          2600mm LOOP_163
00000ED2  0C12 0000               2601mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000ED6  6700 0016               2602mm     BEQ EXIT_163
00000EDA                          2603mmm     PRINT_CHAR (A2)+,D3
00000EDA                          2604mmm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EDA                 TRUE     2605mmm     IFEQ DEBUG
00000EDA  1639 00C00003           2606mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EE0  0803 0002               2607mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EE4  67F4                    2608mmm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EE6  13DA 00C00007           2609mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EEC                          2610mmm     ENDC
00000EEC                          2611mmm 
00000EEC                 FALSE    2612mmm     IFNE DEBUG
00000EEC                          2613mmm     ENDC
00000EEC                          2614mmm 
00000EEC                          2615mmm     ENDM
00000EEC  60E4                    2616mm     BRA LOOP_163
00000EEE                          2617mm EXIT_163
00000EEE                          2618mm     ENDM
00000EEE  7A07                    2619m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EF0                          2620m LOOP_162
00000EF0                          2621mm     BIN2HEX D2,D4,A2
00000EF0  45FA 1158               2622mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000EF4  E99A                    2623mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EF6  1802                    2624mm     MOVE.B D2,D4
00000EF8  0284 0000000F           2625mm     ANDI.L #$F,D4
00000EFE  1832 4000               2626mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F02                          2627mm     ENDM
00000F02                          2628mm     PRINT_CHAR D4,D3
00000F02                          2629mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F02                 TRUE     2630mm     IFEQ DEBUG
00000F02  1639 00C00003           2631mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F08  0803 0002               2632mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F0C  67F4                    2633mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000F0E  13C4 00C00007           2634mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F14                          2635mm     ENDC
00000F14                          2636mm 
00000F14                 FALSE    2637mm     IFNE DEBUG
00000F14                          2638mm     ENDC
00000F14                          2639mm 
00000F14                          2640mm     ENDM
00000F14  57CD FFDA               2641m     DBEQ D5,LOOP_162
00000F18                          2642m     ENDM
00000F18                          2643  
00000F18  45FA 1179               2644      LEA FOR(PC),A2
00000F1C                          2645m     PRINT_STR A2,D3
00000F1C                          2646m LOOP_167
00000F1C  0C12 0000               2647m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F20  6700 0016               2648m     BEQ EXIT_167
00000F24                          2649mm     PRINT_CHAR (A2)+,D3
00000F24                          2650mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F24                 TRUE     2651mm     IFEQ DEBUG
00000F24  1639 00C00003           2652mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2A  0803 0002               2653mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F2E  67F4                    2654mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000F30  13DA 00C00007           2655mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F36                          2656mm     ENDC
00000F36                          2657mm 
00000F36                 FALSE    2658mm     IFNE DEBUG
00000F36                          2659mm     ENDC
00000F36                          2660mm 
00000F36                          2661mm     ENDM
00000F36  60E4                    2662m     BRA LOOP_167
00000F38                          2663m EXIT_167
00000F38                          2664m     ENDM
00000F38                          2665m     PRINT_REG D0,D3,D4,D5,A2
00000F38  45FA 1151               2666m     LEA OX(PC),A2
00000F3C                          2667mm     PRINT_STR A2,D3
00000F3C                          2668mm LOOP_170
00000F3C  0C12 0000               2669mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F40  6700 0016               2670mm     BEQ EXIT_170
00000F44                          2671mmm     PRINT_CHAR (A2)+,D3
00000F44                          2672mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F44                 TRUE     2673mmm     IFEQ DEBUG
00000F44  1639 00C00003           2674mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F4A  0803 0002               2675mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F4E  67F4                    2676mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F50  13DA 00C00007           2677mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F56                          2678mmm     ENDC
00000F56                          2679mmm 
00000F56                 FALSE    2680mmm     IFNE DEBUG
00000F56                          2681mmm     ENDC
00000F56                          2682mmm 
00000F56                          2683mmm     ENDM
00000F56  60E4                    2684mm     BRA LOOP_170
00000F58                          2685mm EXIT_170
00000F58                          2686mm     ENDM
00000F58  7A07                    2687m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F5A                          2688m LOOP_169
00000F5A                          2689mm     BIN2HEX D0,D4,A2
00000F5A  45FA 10EE               2690mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F5E  E998                    2691mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F60  1800                    2692mm     MOVE.B D0,D4
00000F62  0284 0000000F           2693mm     ANDI.L #$F,D4
00000F68  1832 4000               2694mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F6C                          2695mm     ENDM
00000F6C                          2696mm     PRINT_CHAR D4,D3
00000F6C                          2697mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F6C                 TRUE     2698mm     IFEQ DEBUG
00000F6C  1639 00C00003           2699mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F72  0803 0002               2700mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F76  67F4                    2701mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F78  13C4 00C00007           2702mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F7E                          2703mm     ENDC
00000F7E                          2704mm 
00000F7E                 FALSE    2705mm     IFNE DEBUG
00000F7E                          2706mm     ENDC
00000F7E                          2707mm 
00000F7E                          2708mm     ENDM
00000F7E  57CD FFDA               2709m     DBEQ D5,LOOP_169
00000F82                          2710m     ENDM
00000F82                          2711  
00000F82                          2712m     PRINT_CRLF D3,A2
00000F82  45FA 1101               2713m     LEA CRLF(PC),A2
00000F86                          2714mm     PRINT_STR A2,D3
00000F86                          2715mm LOOP_175
00000F86  0C12 0000               2716mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F8A  6700 0016               2717mm     BEQ EXIT_175
00000F8E                          2718mmm     PRINT_CHAR (A2)+,D3
00000F8E                          2719mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F8E                 TRUE     2720mmm     IFEQ DEBUG
00000F8E  1639 00C00003           2721mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F94  0803 0002               2722mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F98  67F4                    2723mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000F9A  13DA 00C00007           2724mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FA0                          2725mmm     ENDC
00000FA0                          2726mmm 
00000FA0                 FALSE    2727mmm     IFNE DEBUG
00000FA0                          2728mmm     ENDC
00000FA0                          2729mmm 
00000FA0                          2730mmm     ENDM
00000FA0  60E4                    2731mm     BRA LOOP_175
00000FA2                          2732mm EXIT_175
00000FA2                          2733mm     ENDM
00000FA2                          2734m     ENDM
00000FA2                          2735  
00000FA2                          2736      WHILE D0 <GT> #0 DO
00000FA2                          2737s _10000014
00000FA2  B07C 0000               2738s     CMP.W   #0,D0
00000FA6  6F00 001C               2739s     BLE _10000015
00000FAA  5580                    2740          SUB.L #2,D0
00000FAC                          2741  
00000FAC  13D1 00E00001           2742          MOVE.B (A1),DISPLAY
00000FB2                          2743m         PROGRAM (A1),(A0),D2
00000FB2  3091                    2744m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000FB4                          2745m 
00000FB4                          2746m WAIT_FOR_COMPLETE_177
00000FB4  3410                    2747m         MOVE.W (A0),D2
00000FB6                          2748m 
00000FB6                          2749m         IF.W D2 <NE> (A1) THEN
00000FB6  B451                    2750ms     CMP.W   (A1),D2
00000FB8  6700 0004               2751ms     BEQ _0000000E
00000FBC  60F6                    2752m             BRA WAIT_FOR_COMPLETE_177
00000FBE                          2753m         ENDI
00000FBE                          2754ms _0000000E
00000FBE                          2755m         ENDM
00000FBE                          2756                  
00000FBE  5488                    2757          ADD.L #2,A0
00000FC0  5489                    2758          ADD.L #2,A1
00000FC2                          2759      ENDW
00000FC2  60DE                    2760s     BRA _10000014
00000FC4                          2761s _10000015
00000FC4                          2762      
00000FC4  41F8 0000               2763      LEA STACK,A0
00000FC8  D1CC                    2764      ADD.L A4,A0
00000FCA  2010                    2765      MOVE.L (A0),D0
00000FCC                          2766      
00000FCC  207C 00000000           2767      MOVE.L #0,A0
00000FD2                          2768m     PROGRAM_VECTOR D0,A0,D2
00000FD2  5488                    2769m     ADD.L #2,A0
00000FD4                          2770mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000FD4  3080                    2771mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FD6                          2772mm 
00000FD6                          2773mm WAIT_FOR_COMPLETE_179
00000FD6  3410                    2774mm         MOVE.W (A0),D2
00000FD8                          2775mm 
00000FD8                          2776mm         IF.W D2 <NE> D0 THEN
00000FD8  B440                    2777mms     CMP.W   D0,D2
00000FDA  6700 0004               2778mms     BEQ _0000000F
00000FDE  60F6                    2779mm             BRA WAIT_FOR_COMPLETE_179
00000FE0                          2780mm         ENDI
00000FE0                          2781mms _0000000F
00000FE0                          2782mm         ENDM
00000FE0  E088                    2783m     LSR.L #8,D0
00000FE2  E088                    2784m     LSR.L #8,D0
00000FE4  5588                    2785m     SUB.L #2,A0
00000FE6                          2786mm     PROGRAM D0, (A0), D2
00000FE6  3080                    2787mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000FE8                          2788mm 
00000FE8                          2789mm WAIT_FOR_COMPLETE_180
00000FE8  3410                    2790mm         MOVE.W (A0),D2
00000FEA                          2791mm 
00000FEA                          2792mm         IF.W D2 <NE> D0 THEN
00000FEA  B440                    2793mms     CMP.W   D0,D2
00000FEC  6700 0004               2794mms     BEQ _00000010
00000FF0  60F6                    2795mm             BRA WAIT_FOR_COMPLETE_180
00000FF2                          2796mm         ENDI
00000FF2                          2797mms _00000010
00000FF2                          2798mm         ENDM
00000FF2                          2799m     ENDM
00000FF2                          2800      
00000FF2                          2801      FOR A0 = #RESET TO #START-4 BY #4 DO
00000FF2  307C 0004               2802s     MOVE.W  #RESET,A0
00000FF6  6000 003C               2803s     BRA _2000000F
00000FFA                          2804s _2000000E
00000FFA                          2805  
00000FFA  2248                    2806          MOVE.L A0,A1
00000FFC  D3CC                    2807          ADD.L A4,A1
00000FFE                          2808              
00000FFE  2011                    2809          MOVE.L (A1),D0  
00001000  D081                    2810          ADD.L D1,D0
00001002  0480 00000104           2811          SUB.L #START,D0
00001008                          2812  
00001008  2408                    2813          MOVE.L A0,D2
0000100A                          2814          
0000100A  2408                    2815          MOVE.L A0,D2
0000100C  13C2 00E00001           2816          MOVE.B D2,DISPLAY
00001012                          2817m         PROGRAM_VECTOR D0,A0,D2
00001012  5488                    2818m     ADD.L #2,A0
00001014                          2819mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00001014  3080                    2820mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001016                          2821mm 
00001016                          2822mm WAIT_FOR_COMPLETE_182
00001016  3410                    2823mm         MOVE.W (A0),D2
00001018                          2824mm 
00001018                          2825mm         IF.W D2 <NE> D0 THEN
00001018  B440                    2826mms     CMP.W   D0,D2
0000101A  6700 0004               2827mms     BEQ _00000011
0000101E  60F6                    2828mm             BRA WAIT_FOR_COMPLETE_182
00001020                          2829mm         ENDI
00001020                          2830mms _00000011
00001020                          2831mm         ENDM
00001020  E088                    2832m     LSR.L #8,D0
00001022  E088                    2833m     LSR.L #8,D0
00001024  5588                    2834m     SUB.L #2,A0
00001026                          2835mm     PROGRAM D0, (A0), D2
00001026  3080                    2836mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001028                          2837mm 
00001028                          2838mm WAIT_FOR_COMPLETE_183
00001028  3410                    2839mm         MOVE.W (A0),D2
0000102A                          2840mm 
0000102A                          2841mm         IF.W D2 <NE> D0 THEN
0000102A  B440                    2842mms     CMP.W   D0,D2
0000102C  6700 0004               2843mms     BEQ _00000012
00001030  60F6                    2844mm             BRA WAIT_FOR_COMPLETE_183
00001032                          2845mm         ENDI
00001032                          2846mms _00000012
00001032                          2847mm         ENDM
00001032                          2848m     ENDM
00001032                          2849      ENDF
00001032  5848                    2850s     ADD.W   #4,A0
00001034                          2851s _2000000F
00001034  B0FC 0100               2852s     CMP.W   #START-4,A0
00001038  6FC0                    2853s     BLE _2000000E
0000103A                          2854                                          
0000103A                          2855m     PROTECT
0000103A  31FC AAAA 2AAA          2856m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001040  31FC 5555 1554          2857m     MOVE.W #$5555,$1554
00001046  31FC A0A0 2AAA          2858m     MOVE.W #$A0A0,$2AAA
0000104C                          2859m     ENDM
0000104C                          2860  
0000104C  6000 F2F6               2861      BRA MAIN_LOOP
00001050                          2862      
00001050                          2863  P
00001050  7000                    2864      MOVE.L #0,D0                                    ; D0 will be the data to write
00001052                          2865  
00001052                          2866      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00001052  323C 0000               2867s     MOVE.W  #0,D1
00001056  6000 0046               2868s     BRA _20000011
0000105A                          2869s _20000010
0000105A  E988                    2870          LSL.L #4,D0                                 ; make what we have so far more significant
0000105C                          2871m         WAIT_CHAR D2,D3                             ; next character -> D2
0000105C                          2872m WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000105C                 TRUE     2873m     IFEQ DEBUG
0000105C  1639 00C00003           2874m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001062  0803 0000               2875m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001066  67F4                    2876m         BEQ WAIT_FOR_READY_185                      ; NOTHING, CHECK AGAIN
00001068                          2877m     ENDC
00001068                          2878m 
00001068                          2879mm     READ_CHAR D2
00001068                 TRUE     2880mm     IFEQ DEBUG
00001068  1439 00C00007           2881mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000106E                          2882mm     ENDC
0000106E                 FALSE    2883mm     IFNE DEBUG
0000106E                          2884mm     ENDC
0000106E                          2885mm 
0000106E  B43C 001B               2886mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001072  6700 F090               2887mm     BEQ START
00001076                          2888mm     ENDM
00001076                          2889m 
00001076                 TRUE     2890m     IFEQ DEBUG
00001076                          2891mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001076                          2892mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001076                 TRUE     2893mm     IFEQ DEBUG
00001076  1639 00C00003           2894mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000107C  0803 0002               2895mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001080  67F4                    2896mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00001082  13C2 00C00007           2897mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001088                          2898mm     ENDC
00001088                          2899mm 
00001088                 FALSE    2900mm     IFNE DEBUG
00001088                          2901mm     ENDC
00001088                          2902mm 
00001088                          2903mm     ENDM
00001088                          2904m     ENDC
00001088                          2905m     ENDM
00001088                          2906m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001088  41FA 0FD0               2907m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000108C  0402 0030               2908m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001090  C4BC 000000FF           2909m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001096  1430 2000               2910m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000109A                          2911m     ENDM
0000109A  8002                    2912          OR.B D2,D0
0000109C                          2913      ENDF
0000109C  5241                    2914s     ADD.W   #1,D1
0000109E                          2915s _20000011
0000109E  B27C 0003               2916s     CMP.W   #3,D1
000010A2  6FB6                    2917s     BLE _20000010
000010A4                          2918  
000010A4                          2919m     PRINT_CRLF D2,A1
000010A4  43FA 0FDF               2920m     LEA CRLF(PC),A1
000010A8                          2921mm     PRINT_STR A1,D2
000010A8                          2922mm LOOP_190
000010A8  0C11 0000               2923mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010AC  6700 0016               2924mm     BEQ EXIT_190
000010B0                          2925mmm     PRINT_CHAR (A1)+,D2
000010B0                          2926mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010B0                 TRUE     2927mmm     IFEQ DEBUG
000010B0  1439 00C00003           2928mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000010B6  0802 0002               2929mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000010BA  67F4                    2930mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
000010BC  13D9 00C00007           2931mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010C2                          2932mmm     ENDC
000010C2                          2933mmm 
000010C2                 FALSE    2934mmm     IFNE DEBUG
000010C2                          2935mmm     ENDC
000010C2                          2936mmm 
000010C2                          2937mmm     ENDM
000010C2  60E4                    2938mm     BRA LOOP_190
000010C4                          2939mm EXIT_190
000010C4                          2940mm     ENDM
000010C4                          2941m     ENDM
000010C4                          2942  
000010C4  2047                    2943      MOVE.L D7,A0                                    ; address accumulator -> target address register
000010C6  7E00                    2944      MOVE.L #0,D7                                    ; clear the now used address accumulator
000010C8                          2945  
000010C8                          2946m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000010C8  31FC AAAA 2AAA          2947m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000010CE  4E71                    2948m     NOP
000010D0  31FC 5555 1554          2949m     MOVE.W #$5555,$1554
000010D6  4E71                    2950m     NOP
000010D8  31FC 8080 2AAA          2951m     MOVE.W #$8080,$2AAA
000010DE  4E71                    2952m     NOP
000010E0  31FC AAAA 2AAA          2953m     MOVE.W #$AAAA,$2AAA
000010E6  4E71                    2954m     NOP
000010E8  31FC 5555 1554          2955m     MOVE.W #$5555,$1554
000010EE  4E71                    2956m     NOP
000010F0  31FC 2020 2AAA          2957m     MOVE.W #$2020,$2AAA
000010F6                          2958m     ENDM
000010F6                          2959                              
000010F6                          2960      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000010F6  3E3C 0000               2961s     MOVE.W  #$0,D7
000010FA  6000 0006               2962s     BRA _20000013
000010FE                          2963s _20000012
000010FE  4E71                    2964          NOP
00001100                          2965      ENDF
00001100  5247                    2966s     ADD.W   #1,D7
00001102                          2967s _20000013
00001102  BE7C FFFF               2968s     CMP.W   #$FFFFFFFF,D7
00001106  6FF6                    2969s     BLE _20000012
00001108                          2970               
00001108  45FA 0F67               2971      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000110C                          2972m     PRINT_STR A2,D2
0000110C                          2973m LOOP_193
0000110C  0C12 0000               2974m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001110  6700 0016               2975m     BEQ EXIT_193
00001114                          2976mm     PRINT_CHAR (A2)+,D2
00001114                          2977mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001114                 TRUE     2978mm     IFEQ DEBUG
00001114  1439 00C00003           2979mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000111A  0802 0002               2980mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000111E  67F4                    2981mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
00001120  13DA 00C00007           2982mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001126                          2983mm     ENDC
00001126                          2984mm 
00001126                 FALSE    2985mm     IFNE DEBUG
00001126                          2986mm     ENDC
00001126                          2987mm 
00001126                          2988mm     ENDM
00001126  60E4                    2989m     BRA LOOP_193
00001128                          2990m EXIT_193
00001128                          2991m     ENDM
00001128                          2992  
00001128                          2993m     PRINT_REG D0,D3,D4,D5,A2
00001128  45FA 0F61               2994m     LEA OX(PC),A2
0000112C                          2995mm     PRINT_STR A2,D3
0000112C                          2996mm LOOP_196
0000112C  0C12 0000               2997mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001130  6700 0016               2998mm     BEQ EXIT_196
00001134                          2999mmm     PRINT_CHAR (A2)+,D3
00001134                          3000mmm WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001134                 TRUE     3001mmm     IFEQ DEBUG
00001134  1639 00C00003           3002mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000113A  0803 0002               3003mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000113E  67F4                    3004mmm         BEQ WAIT_FOR_READY_197                      ; NO SPACE, CHECK AGAIN
00001140  13DA 00C00007           3005mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001146                          3006mmm     ENDC
00001146                          3007mmm 
00001146                 FALSE    3008mmm     IFNE DEBUG
00001146                          3009mmm     ENDC
00001146                          3010mmm 
00001146                          3011mmm     ENDM
00001146  60E4                    3012mm     BRA LOOP_196
00001148                          3013mm EXIT_196
00001148                          3014mm     ENDM
00001148  7A07                    3015m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000114A                          3016m LOOP_195
0000114A                          3017mm     BIN2HEX D0,D4,A2
0000114A  45FA 0EFE               3018mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000114E  E998                    3019mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001150  1800                    3020mm     MOVE.B D0,D4
00001152  0284 0000000F           3021mm     ANDI.L #$F,D4
00001158  1832 4000               3022mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000115C                          3023mm     ENDM
0000115C                          3024mm     PRINT_CHAR D4,D3
0000115C                          3025mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000115C                 TRUE     3026mm     IFEQ DEBUG
0000115C  1639 00C00003           3027mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001162  0803 0002               3028mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001166  67F4                    3029mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00001168  13C4 00C00007           3030mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000116E                          3031mm     ENDC
0000116E                          3032mm 
0000116E                 FALSE    3033mm     IFNE DEBUG
0000116E                          3034mm     ENDC
0000116E                          3035mm 
0000116E                          3036mm     ENDM
0000116E  57CD FFDA               3037m     DBEQ D5,LOOP_195
00001172                          3038m     ENDM
00001172                          3039  
00001172  45FA 0F1A               3040      LEA TO(PC),A2
00001176                          3041m     PRINT_STR A2,D3
00001176                          3042m LOOP_200
00001176  0C12 0000               3043m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000117A  6700 0016               3044m     BEQ EXIT_200
0000117E                          3045mm     PRINT_CHAR (A2)+,D3
0000117E                          3046mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000117E                 TRUE     3047mm     IFEQ DEBUG
0000117E  1639 00C00003           3048mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001184  0803 0002               3049mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001188  67F4                    3050mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
0000118A  13DA 00C00007           3051mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001190                          3052mm     ENDC
00001190                          3053mm 
00001190                 FALSE    3054mm     IFNE DEBUG
00001190                          3055mm     ENDC
00001190                          3056mm 
00001190                          3057mm     ENDM
00001190  60E4                    3058m     BRA LOOP_200
00001192                          3059m EXIT_200
00001192                          3060m     ENDM
00001192                          3061  
00001192  2408                    3062      MOVE.L A0,D2
00001194                          3063m     PRINT_REG D2,D3,D4,D5,A2
00001194  45FA 0EF5               3064m     LEA OX(PC),A2
00001198                          3065mm     PRINT_STR A2,D3
00001198                          3066mm LOOP_203
00001198  0C12 0000               3067mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000119C  6700 0016               3068mm     BEQ EXIT_203
000011A0                          3069mmm     PRINT_CHAR (A2)+,D3
000011A0                          3070mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011A0                 TRUE     3071mmm     IFEQ DEBUG
000011A0  1639 00C00003           3072mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011A6  0803 0002               3073mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011AA  67F4                    3074mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
000011AC  13DA 00C00007           3075mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011B2                          3076mmm     ENDC
000011B2                          3077mmm 
000011B2                 FALSE    3078mmm     IFNE DEBUG
000011B2                          3079mmm     ENDC
000011B2                          3080mmm 
000011B2                          3081mmm     ENDM
000011B2  60E4                    3082mm     BRA LOOP_203
000011B4                          3083mm EXIT_203
000011B4                          3084mm     ENDM
000011B4  7A07                    3085m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011B6                          3086m LOOP_202
000011B6                          3087mm     BIN2HEX D2,D4,A2
000011B6  45FA 0E92               3088mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011BA  E99A                    3089mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011BC  1802                    3090mm     MOVE.B D2,D4
000011BE  0284 0000000F           3091mm     ANDI.L #$F,D4
000011C4  1832 4000               3092mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011C8                          3093mm     ENDM
000011C8                          3094mm     PRINT_CHAR D4,D3
000011C8                          3095mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011C8                 TRUE     3096mm     IFEQ DEBUG
000011C8  1639 00C00003           3097mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011CE  0803 0002               3098mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011D2  67F4                    3099mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
000011D4  13C4 00C00007           3100mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011DA                          3101mm     ENDC
000011DA                          3102mm 
000011DA                 FALSE    3103mm     IFNE DEBUG
000011DA                          3104mm     ENDC
000011DA                          3105mm 
000011DA                          3106mm     ENDM
000011DA  57CD FFDA               3107m     DBEQ D5,LOOP_202
000011DE                          3108m     ENDM
000011DE                          3109  
000011DE                          3110m     PRINT_CRLF D3,A2
000011DE  45FA 0EA5               3111m     LEA CRLF(PC),A2
000011E2                          3112mm     PRINT_STR A2,D3
000011E2                          3113mm LOOP_208
000011E2  0C12 0000               3114mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011E6  6700 0016               3115mm     BEQ EXIT_208
000011EA                          3116mmm     PRINT_CHAR (A2)+,D3
000011EA                          3117mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011EA                 TRUE     3118mmm     IFEQ DEBUG
000011EA  1639 00C00003           3119mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011F0  0803 0002               3120mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011F4  67F4                    3121mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
000011F6  13DA 00C00007           3122mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011FC                          3123mmm     ENDC
000011FC                          3124mmm 
000011FC                 FALSE    3125mmm     IFNE DEBUG
000011FC                          3126mmm     ENDC
000011FC                          3127mmm 
000011FC                          3128mmm     ENDM
000011FC  60E4                    3129mm     BRA LOOP_208
000011FE                          3130mm EXIT_208
000011FE                          3131mm     ENDM
000011FE                          3132m     ENDM
000011FE                          3133  
000011FE                          3134m     PROGRAM D0,(A0),D2
000011FE  3080                    3135m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001200                          3136m 
00001200                          3137m WAIT_FOR_COMPLETE_210
00001200  3410                    3138m         MOVE.W (A0),D2
00001202                          3139m 
00001202                          3140m         IF.W D2 <NE> D0 THEN
00001202  B440                    3141ms     CMP.W   D0,D2
00001204  6700 0004               3142ms     BEQ _00000013
00001208  60F6                    3143m             BRA WAIT_FOR_COMPLETE_210
0000120A                          3144m         ENDI
0000120A                          3145ms _00000013
0000120A                          3146m         ENDM
0000120A                          3147  
0000120A                          3148m     PROTECT
0000120A  31FC AAAA 2AAA          3149m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001210  31FC 5555 1554          3150m     MOVE.W #$5555,$1554
00001216  31FC A0A0 2AAA          3151m     MOVE.W #$A0A0,$2AAA
0000121C                          3152m     ENDM
0000121C                          3153      
0000121C  6000 F126               3154      BRA MAIN_LOOP
00001220                          3155      
00001220                          3156  X
00001220  45FA 0E7C               3157      LEA STATUS_REGISTER(PC),A2
00001224                          3158m     PRINT_STR A2,D3
00001224                          3159m LOOP_212
00001224  0C12 0000               3160m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001228  6700 0016               3161m     BEQ EXIT_212
0000122C                          3162mm     PRINT_CHAR (A2)+,D3
0000122C                          3163mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000122C                 TRUE     3164mm     IFEQ DEBUG
0000122C  1639 00C00003           3165mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001232  0803 0002               3166mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001236  67F4                    3167mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
00001238  13DA 00C00007           3168mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000123E                          3169mm     ENDC
0000123E                          3170mm 
0000123E                 FALSE    3171mm     IFNE DEBUG
0000123E                          3172mm     ENDC
0000123E                          3173mm 
0000123E                          3174mm     ENDM
0000123E  60E4                    3175m     BRA LOOP_212
00001240                          3176m EXIT_212
00001240                          3177m     ENDM
00001240                          3178  
00001240  40C0                    3179      MOVE SR,D0
00001242                          3180m     PRINT_REG D0,D3,D4,D5,A2
00001242  45FA 0E47               3181m     LEA OX(PC),A2
00001246                          3182mm     PRINT_STR A2,D3
00001246                          3183mm LOOP_215
00001246  0C12 0000               3184mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000124A  6700 0016               3185mm     BEQ EXIT_215
0000124E                          3186mmm     PRINT_CHAR (A2)+,D3
0000124E                          3187mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000124E                 TRUE     3188mmm     IFEQ DEBUG
0000124E  1639 00C00003           3189mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001254  0803 0002               3190mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001258  67F4                    3191mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
0000125A  13DA 00C00007           3192mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001260                          3193mmm     ENDC
00001260                          3194mmm 
00001260                 FALSE    3195mmm     IFNE DEBUG
00001260                          3196mmm     ENDC
00001260                          3197mmm 
00001260                          3198mmm     ENDM
00001260  60E4                    3199mm     BRA LOOP_215
00001262                          3200mm EXIT_215
00001262                          3201mm     ENDM
00001262  7A07                    3202m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001264                          3203m LOOP_214
00001264                          3204mm     BIN2HEX D0,D4,A2
00001264  45FA 0DE4               3205mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001268  E998                    3206mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000126A  1800                    3207mm     MOVE.B D0,D4
0000126C  0284 0000000F           3208mm     ANDI.L #$F,D4
00001272  1832 4000               3209mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001276                          3210mm     ENDM
00001276                          3211mm     PRINT_CHAR D4,D3
00001276                          3212mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001276                 TRUE     3213mm     IFEQ DEBUG
00001276  1639 00C00003           3214mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000127C  0803 0002               3215mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001280  67F4                    3216mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
00001282  13C4 00C00007           3217mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001288                          3218mm     ENDC
00001288                          3219mm 
00001288                 FALSE    3220mm     IFNE DEBUG
00001288                          3221mm     ENDC
00001288                          3222mm 
00001288                          3223mm     ENDM
00001288  57CD FFDA               3224m     DBEQ D5,LOOP_214
0000128C                          3225m     ENDM
0000128C                          3226m     PRINT_CRLF D3,A2
0000128C  45FA 0DF7               3227m     LEA CRLF(PC),A2
00001290                          3228mm     PRINT_STR A2,D3
00001290                          3229mm LOOP_220
00001290  0C12 0000               3230mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001294  6700 0016               3231mm     BEQ EXIT_220
00001298                          3232mmm     PRINT_CHAR (A2)+,D3
00001298                          3233mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001298                 TRUE     3234mmm     IFEQ DEBUG
00001298  1639 00C00003           3235mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000129E  0803 0002               3236mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012A2  67F4                    3237mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
000012A4  13DA 00C00007           3238mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012AA                          3239mmm     ENDC
000012AA                          3240mmm 
000012AA                 FALSE    3241mmm     IFNE DEBUG
000012AA                          3242mmm     ENDC
000012AA                          3243mmm 
000012AA                          3244mmm     ENDM
000012AA  60E4                    3245mm     BRA LOOP_220
000012AC                          3246mm EXIT_220
000012AC                          3247mm     ENDM
000012AC                          3248m     ENDM
000012AC                          3249  
000012AC  45FA 0DEB               3250      LEA STACK_POINTER(PC),A2
000012B0                          3251m     PRINT_STR A2,D3
000012B0                          3252m LOOP_222
000012B0  0C12 0000               3253m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012B4  6700 0016               3254m     BEQ EXIT_222
000012B8                          3255mm     PRINT_CHAR (A2)+,D3
000012B8                          3256mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B8                 TRUE     3257mm     IFEQ DEBUG
000012B8  1639 00C00003           3258mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012BE  0803 0002               3259mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012C2  67F4                    3260mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
000012C4  13DA 00C00007           3261mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012CA                          3262mm     ENDC
000012CA                          3263mm 
000012CA                 FALSE    3264mm     IFNE DEBUG
000012CA                          3265mm     ENDC
000012CA                          3266mm 
000012CA                          3267mm     ENDM
000012CA  60E4                    3268m     BRA LOOP_222
000012CC                          3269m EXIT_222
000012CC                          3270m     ENDM
000012CC                          3271  
000012CC  200F                    3272      MOVE.L SP,D0
000012CE                          3273m     PRINT_REG D0,D3,D4,D5,A2
000012CE  45FA 0DBB               3274m     LEA OX(PC),A2
000012D2                          3275mm     PRINT_STR A2,D3
000012D2                          3276mm LOOP_225
000012D2  0C12 0000               3277mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012D6  6700 0016               3278mm     BEQ EXIT_225
000012DA                          3279mmm     PRINT_CHAR (A2)+,D3
000012DA                          3280mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DA                 TRUE     3281mmm     IFEQ DEBUG
000012DA  1639 00C00003           3282mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012E0  0803 0002               3283mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012E4  67F4                    3284mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
000012E6  13DA 00C00007           3285mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012EC                          3286mmm     ENDC
000012EC                          3287mmm 
000012EC                 FALSE    3288mmm     IFNE DEBUG
000012EC                          3289mmm     ENDC
000012EC                          3290mmm 
000012EC                          3291mmm     ENDM
000012EC  60E4                    3292mm     BRA LOOP_225
000012EE                          3293mm EXIT_225
000012EE                          3294mm     ENDM
000012EE  7A07                    3295m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012F0                          3296m LOOP_224
000012F0                          3297mm     BIN2HEX D0,D4,A2
000012F0  45FA 0D58               3298mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012F4  E998                    3299mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012F6  1800                    3300mm     MOVE.B D0,D4
000012F8  0284 0000000F           3301mm     ANDI.L #$F,D4
000012FE  1832 4000               3302mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001302                          3303mm     ENDM
00001302                          3304mm     PRINT_CHAR D4,D3
00001302                          3305mm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001302                 TRUE     3306mm     IFEQ DEBUG
00001302  1639 00C00003           3307mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001308  0803 0002               3308mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000130C  67F4                    3309mm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
0000130E  13C4 00C00007           3310mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001314                          3311mm     ENDC
00001314                          3312mm 
00001314                 FALSE    3313mm     IFNE DEBUG
00001314                          3314mm     ENDC
00001314                          3315mm 
00001314                          3316mm     ENDM
00001314  57CD FFDA               3317m     DBEQ D5,LOOP_224
00001318                          3318m     ENDM
00001318                          3319m     PRINT_CRLF D3,A2
00001318  45FA 0D6B               3320m     LEA CRLF(PC),A2
0000131C                          3321mm     PRINT_STR A2,D3
0000131C                          3322mm LOOP_230
0000131C  0C12 0000               3323mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001320  6700 0016               3324mm     BEQ EXIT_230
00001324                          3325mmm     PRINT_CHAR (A2)+,D3
00001324                          3326mmm WAIT_FOR_READY_231                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001324                 TRUE     3327mmm     IFEQ DEBUG
00001324  1639 00C00003           3328mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000132A  0803 0002               3329mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000132E  67F4                    3330mmm         BEQ WAIT_FOR_READY_231                      ; NO SPACE, CHECK AGAIN
00001330  13DA 00C00007           3331mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001336                          3332mmm     ENDC
00001336                          3333mmm 
00001336                 FALSE    3334mmm     IFNE DEBUG
00001336                          3335mmm     ENDC
00001336                          3336mmm 
00001336                          3337mmm     ENDM
00001336  60E4                    3338mm     BRA LOOP_230
00001338                          3339mm EXIT_230
00001338                          3340mm     ENDM
00001338                          3341m     ENDM
00001338                          3342  
00001338  6000 F00A               3343      BRA MAIN_LOOP
0000133C                          3344          
0000133C                          3345  EI
0000133C  13FC 0008 00C0000B      3346      MOVE.B #8,DUART_IMR
00001344  027C F8FF               3347      AND.W #$F8FF,SR
00001348  6000 EFFA               3348      BRA MAIN_LOOP
0000134C                          3349      
0000134C                          3350  DI
0000134C  13FC 0000 00C0000B      3351      MOVE.B #0,DUART_IMR
00001354  007C 0700               3352      OR.W #$0700,SR
00001358  6000 EFEA               3353      BRA MAIN_LOOP
0000135C                          3354          
0000135C                          3355  HASH
0000135C                          3356m     PROTECT
0000135C  31FC AAAA 2AAA          3357m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001362  31FC 5555 1554          3358m     MOVE.W #$5555,$1554
00001368  31FC A0A0 2AAA          3359m     MOVE.W #$A0A0,$2AAA
0000136E                          3360m     ENDM
0000136E  6000 EFD4               3361      BRA MAIN_LOOP
00001372                          3362  
00001372                          3363  IB
00001372  227C 00000000           3364      MOVE.L #0, A1   ; length -> A1
00001378  247C 00000000           3365      MOVE.L #0, A2   ; start address -> A2
0000137E  267C 00000000           3366      MOVE.L #0, A3   ; go address -> A3
00001384  287C 00000000           3367      MOVE.L #0, A4   ; start block -> A4
0000138A                          3368  
0000138A  13FC 0038 00A00019      3369      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001392                          3370      
00001392                          3371m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
00001392  13FC 00FF 00A00007      3372m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000139A  103C 0030               3373m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000139E  0000 0006               3374m     ORI.B #IDE_DRIVESEL_REGISTER, D0
000013A2  13C0 00A00019           3375m     MOVE.B D0, MC68230_PORT_C_DATA
000013A8  0200 00EF               3376m     ANDI.B #~MC68230_PORT_C_WRITE, D0
000013AC  13FC 00E0 00A00013      3377m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
000013B4  13C0 00A00019           3378m     MOVE.B D0, MC68230_PORT_C_DATA
000013BA  0000 0010               3379m     ORI.B #MC68230_PORT_C_WRITE, D0
000013BE  13C0 00A00019           3380m     MOVE.B D0, MC68230_PORT_C_DATA
000013C4  13FC 0038 00A00019      3381m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013CC                          3382m     ENDM
000013CC                          3383m     WAIT_DRIVE_READY D0, D1
000013CC                          3384m LOOP_234
000013CC                          3385mm     READ_IDE_STATUS D0, D1
000013CC                          3386mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000013CC  13FC 0000 00A00007      3387mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000013D4  123C 0030               3388mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000013D8  0001 0007               3389mmm     ORI.B #IDE_STATUS_REGISTER, D1
000013DC  13C1 00A00019           3390mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013E2  0201 00DF               3391mmm     ANDI.B #~MC68230_PORT_C_READ, D1
000013E6  13C1 00A00019           3392mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013EC  1039 00A00013           3393mmm     MOVE.B MC68230_PORT_B_DATA, D0
000013F2  0001 0020               3394mmm     ORI.B #MC68230_PORT_C_READ, D1
000013F6  13C1 00A00019           3395mmm     MOVE.B D1, MC68230_PORT_C_DATA
000013FC  13FC 0038 00A00019      3396mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001404                          3397mmm     ENDM
00001404                          3398mm     ENDM
00001404  0800 0006               3399m     BTST #IDE_STATUS_READY, D0
00001408  67C2                    3400m     BEQ LOOP_234
0000140A                          3401m     ENDM
0000140A                          3402          
0000140A                          3403m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
0000140A                          3404mm     WAIT_DRIVE_NOT_BUSY D0, D1
0000140A                          3405mm LOOP_238
0000140A                          3406mmm     READ_IDE_STATUS D0, D1
0000140A                          3407mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
0000140A  13FC 0000 00A00007      3408mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001412  123C 0030               3409mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001416  0001 0007               3410mmmm     ORI.B #IDE_STATUS_REGISTER, D1
0000141A  13C1 00A00019           3411mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001420  0201 00DF               3412mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001424  13C1 00A00019           3413mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000142A  1039 00A00013           3414mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001430  0001 0020               3415mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001434  13C1 00A00019           3416mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000143A  13FC 0038 00A00019      3417mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001442                          3418mmmm     ENDM
00001442                          3419mmm     ENDM
00001442  0800 0007               3420mm     BTST #IDE_STATUS_BUSY, D0
00001446  66C2                    3421mm     BNE LOOP_238
00001448                          3422mm     ENDM
00001448                          3423mm     SET_READ_ADDRESS #0, D0, D1, D2
00001448                          3424mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
00001448  13FC 00FF 00A00007      3425mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001450  103C 0030               3426mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001454  0000 0002               3427mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
00001458  13C0 00A00019           3428mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000145E  0200 00EF               3429mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001462  13FC 0001 00A00013      3430mmm     MOVE.B #1, MC68230_PORT_B_DATA
0000146A  13C0 00A00019           3431mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001470  0000 0010               3432mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001474  13C0 00A00019           3433mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000147A  13FC 0038 00A00019      3434mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001482                          3435mmm     ENDM
00001482  7200                    3436mm     MOVE.L #0,D1
00001484                          3437mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
00001484  13FC 00FF 00A00007      3438mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000148C  103C 0030               3439mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001490  0000 0003               3440mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
00001494  13C0 00A00019           3441mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000149A  0200 00EF               3442mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000149E  13C1 00A00013           3443mmm     MOVE.B D1, MC68230_PORT_B_DATA
000014A4  13C0 00A00019           3444mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014AA  0000 0010               3445mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014AE  13C0 00A00019           3446mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014B4  13FC 0038 00A00019      3447mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014BC                          3448mmm     ENDM
000014BC  E089                    3449mm     LSR.L #8, D1
000014BE                          3450mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
000014BE  13FC 00FF 00A00007      3451mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014C6  103C 0030               3452mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014CA  0000 0004               3453mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
000014CE  13C0 00A00019           3454mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014D4  0200 00EF               3455mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014D8  13C1 00A00013           3456mmm     MOVE.B D1, MC68230_PORT_B_DATA
000014DE  13C0 00A00019           3457mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014E4  0000 0010               3458mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014E8  13C0 00A00019           3459mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014EE  13FC 0038 00A00019      3460mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014F6                          3461mmm     ENDM
000014F6  E089                    3462mm     LSR.L #8, D1                                
000014F8                          3463mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
000014F8  13FC 00FF 00A00007      3464mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001500  103C 0030               3465mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001504  0000 0005               3466mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
00001508  13C0 00A00019           3467mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000150E  0200 00EF               3468mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001512  13C1 00A00013           3469mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001518  13C0 00A00019           3470mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000151E  0000 0010               3471mmm     ORI.B #MC68230_PORT_C_WRITE, D0
00001522  13C0 00A00019           3472mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001528  13FC 0038 00A00019      3473mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001530                          3474mmm     ENDM
00001530  E089                    3475mm     LSR.L #8, D1
00001532                          3476mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
00001532  13FC 0000 00A00007      3477mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000153A  103C 0030               3478mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000153E  0000 0006               3479mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001542  13C0 00A00019           3480mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001548  0200 00DF               3481mmm     ANDI.B #~MC68230_PORT_C_READ, D0
0000154C  13C0 00A00019           3482mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001552  1439 00A00013           3483mmm     MOVE.B MC68230_PORT_B_DATA, D2
00001558  0000 0020               3484mmm     ORI.B #MC68230_PORT_C_READ, D0
0000155C  13C0 00A00019           3485mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001562  13FC 0038 00A00019      3486mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000156A                          3487mmm     ENDM
0000156A  0201 000F               3488mm     ANDI.B #$0F,D1
0000156E  8401                    3489mm     OR.B D1,D2
00001570                          3490mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
00001570  13FC 00FF 00A00007      3491mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001578  103C 0030               3492mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000157C  0000 0006               3493mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
00001580  13C0 00A00019           3494mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001586  0200 00EF               3495mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000158A  13C2 00A00013           3496mmm     MOVE.B D2, MC68230_PORT_B_DATA
00001590  13C0 00A00019           3497mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001596  0000 0010               3498mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000159A  13C0 00A00019           3499mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015A0  13FC 0038 00A00019      3500mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015A8                          3501mmm     ENDM
000015A8                          3502mm     ENDM
000015A8                          3503mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
000015A8                          3504mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
000015A8  13FC 00FF 00A00007      3505mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000015B0  103C 0030               3506mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000015B4  0000 0007               3507mmm     ORI.B #IDE_COMMAND_REGISTER, D0
000015B8  13C0 00A00019           3508mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015BE  0200 00EF               3509mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000015C2  13FC 0020 00A00013      3510mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
000015CA  13C0 00A00019           3511mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015D0  0000 0010               3512mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000015D4  13C0 00A00019           3513mmm     MOVE.B D0, MC68230_PORT_C_DATA
000015DA  13FC 0038 00A00019      3514mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015E2                          3515mmm     ENDM
000015E2                          3516mm     ENDM
000015E2                          3517mm     WAIT_DRIVE_NOT_BUSY D0, D1
000015E2                          3518mm LOOP_250
000015E2                          3519mmm     READ_IDE_STATUS D0, D1
000015E2                          3520mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000015E2  13FC 0000 00A00007      3521mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015EA  123C 0030               3522mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000015EE  0001 0007               3523mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000015F2  13C1 00A00019           3524mmmm     MOVE.B D1, MC68230_PORT_C_DATA
000015F8  0201 00DF               3525mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
000015FC  13C1 00A00019           3526mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001602  1039 00A00013           3527mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001608  0001 0020               3528mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000160C  13C1 00A00019           3529mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001612  13FC 0038 00A00019      3530mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000161A                          3531mmmm     ENDM
0000161A                          3532mmm     ENDM
0000161A  0800 0007               3533mm     BTST #IDE_STATUS_BUSY, D0
0000161E  66C2                    3534mm     BNE LOOP_250
00001620                          3535mm     ENDM
00001620                          3536mm     WAIT_DRIVE_DRQ D0, D1
00001620                          3537mm LOOP_253
00001620                          3538mmm     READ_IDE_STATUS D0, D1
00001620                          3539mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001620  13FC 0000 00A00007      3540mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001628  123C 0030               3541mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
0000162C  0001 0007               3542mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001630  13C1 00A00019           3543mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001636  0201 00DF               3544mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000163A  13C1 00A00019           3545mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001640  1039 00A00013           3546mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001646  0001 0020               3547mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000164A  13C1 00A00019           3548mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001650  13FC 0038 00A00019      3549mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001658                          3550mmmm     ENDM
00001658                          3551mmm     ENDM
00001658  0800 0003               3552mm     BTST #IDE_STATUS_DRQ, D0
0000165C  67C2                    3553mm     BEQ LOOP_253
0000165E                          3554mm     ENDM
0000165E                          3555m     ENDM
0000165E                          3556  
0000165E                          3557m     READ_32 #IDE_DATA_REGISTER, D0, D7          ; num entries in boot table -> D0
0000165E                          3558mm     READ_16 #IDE_DATA_REGISTER, D0, D7
0000165E  13FC 0000 00A00007      3559mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001666  13FC 0000 00A00005      3560mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
0000166E                          3561mm     
0000166E  1E3C 0030               3562mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001672  0007 0000               3563mm     ORI.B #IDE_DATA_REGISTER, D7
00001676  13C7 00A00019           3564mm     MOVE.B D7, MC68230_PORT_C_DATA
0000167C  0207 00DF               3565mm     ANDI.B #~MC68230_PORT_C_READ, D7
00001680  13C7 00A00019           3566mm     MOVE.B D7, MC68230_PORT_C_DATA
00001686  1039 00A00011           3567mm     MOVE.B MC68230_PORT_A_DATA, D0
0000168C  E148                    3568mm     LSL.W #8, D0
0000168E  1039 00A00013           3569mm     MOVE.B MC68230_PORT_B_DATA, D0
00001694  0007 0020               3570mm     ORI.B #MC68230_PORT_C_READ, D7
00001698  13C7 00A00019           3571mm     MOVE.B D7, MC68230_PORT_C_DATA
0000169E  13FC 0038 00A00019      3572mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016A6                          3573mm     ENDM
000016A6  E188                    3574m     LSL.L #8, D0
000016A8  E188                    3575m     LSL.L #8, D0
000016AA                          3576mm     READ_16 #IDE_DATA_REGISTER, D0, D7
000016AA  13FC 0000 00A00007      3577mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000016B2  13FC 0000 00A00005      3578mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000016BA                          3579mm     
000016BA  1E3C 0030               3580mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000016BE  0007 0000               3581mm     ORI.B #IDE_DATA_REGISTER, D7
000016C2  13C7 00A00019           3582mm     MOVE.B D7, MC68230_PORT_C_DATA
000016C8  0207 00DF               3583mm     ANDI.B #~MC68230_PORT_C_READ, D7
000016CC  13C7 00A00019           3584mm     MOVE.B D7, MC68230_PORT_C_DATA
000016D2  1039 00A00011           3585mm     MOVE.B MC68230_PORT_A_DATA, D0
000016D8  E148                    3586mm     LSL.W #8, D0
000016DA  1039 00A00013           3587mm     MOVE.B MC68230_PORT_B_DATA, D0
000016E0  0007 0020               3588mm     ORI.B #MC68230_PORT_C_READ, D7
000016E4  13C7 00A00019           3589mm     MOVE.B D7, MC68230_PORT_C_DATA
000016EA  13FC 0038 00A00019      3590mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016F2                          3591mm     ENDM
000016F2                          3592m     ENDM
000016F2  7200                    3593      MOVE.L #0, D1                               ; current boot table index -> D1
000016F4                          3594      
000016F4                          3595      IF D7 <GT> D1 THEN                          ; check for off the end of the boot table
000016F4  BE41                    3596s     CMP.W   D1,D7
000016F6  6F00 0026               3597s     BLE _00000014
000016FA  41FA 09B4               3598          LEA NOT_FOUND(PC), A0
000016FE                          3599m         PRINT_STR A0, D7
000016FE                          3600m LOOP_259
000016FE  0C10 0000               3601m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001702  6700 0016               3602m     BEQ EXIT_259
00001706                          3603mm     PRINT_CHAR (A0)+,D7
00001706                          3604mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001706                 TRUE     3605mm     IFEQ DEBUG
00001706  1E39 00C00003           3606mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000170C  0807 0002               3607mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001710  67F4                    3608mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
00001712  13D8 00C00007           3609mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001718                          3610mm     ENDC
00001718                          3611mm 
00001718                 FALSE    3612mm     IFNE DEBUG
00001718                          3613mm     ENDC
00001718                          3614mm 
00001718                          3615mm     ENDM
00001718  60E4                    3616m     BRA LOOP_259
0000171A                          3617m EXIT_259
0000171A                          3618m     ENDM
0000171A  6000 EC28               3619          BRA MAIN_LOOP
0000171E                          3620      ENDI
0000171E                          3621s _00000014
0000171E                          3622      
0000171E                          3623      IF A5 <EQ> #1 THEN
0000171E  BAFC 0001               3624s     CMP.W   #1,A5
00001722  6600 0004               3625s     BNE _00000015
00001726  2207                    3626          MOVE.L D7, D1                           ; shorten the boot table to the selected entry  
00001728                          3627      ENDI
00001728                          3628s _00000015
00001728                          3629  
00001728                          3630      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
00001728  143C 0000               3631s     MOVE.B  #0,D2
0000172C  6000 0210               3632s     BRA _20000015
00001730                          3633s _20000014
00001730                          3634          FOR.B D3 = #0 TO #12 DO                 ; words read from this boot table entry -> D2
00001730  163C 0000               3635s     MOVE.B  #0,D3
00001734  6000 01D4               3636s     BRA _20000017
00001738                          3637s _20000016
00001738                          3638m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
00001738                          3639mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001738  13FC 0000 00A00007      3640mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001740  13FC 0000 00A00005      3641mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001748                          3642mm     
00001748  1E3C 0030               3643mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
0000174C  0007 0000               3644mm     ORI.B #IDE_DATA_REGISTER, D7
00001750  13C7 00A00019           3645mm     MOVE.B D7, MC68230_PORT_C_DATA
00001756  0207 00DF               3646mm     ANDI.B #~MC68230_PORT_C_READ, D7
0000175A  13C7 00A00019           3647mm     MOVE.B D7, MC68230_PORT_C_DATA
00001760  1839 00A00011           3648mm     MOVE.B MC68230_PORT_A_DATA, D4
00001766  E14C                    3649mm     LSL.W #8, D4
00001768  1839 00A00013           3650mm     MOVE.B MC68230_PORT_B_DATA, D4
0000176E  0007 0020               3651mm     ORI.B #MC68230_PORT_C_READ, D7
00001772  13C7 00A00019           3652mm     MOVE.B D7, MC68230_PORT_C_DATA
00001778  13FC 0038 00A00019      3653mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001780                          3654mm     ENDM
00001780  E18C                    3655m     LSL.L #8, D4
00001782  E18C                    3656m     LSL.L #8, D4
00001784                          3657mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001784  13FC 0000 00A00007      3658mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000178C  13FC 0000 00A00005      3659mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001794                          3660mm     
00001794  1E3C 0030               3661mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001798  0007 0000               3662mm     ORI.B #IDE_DATA_REGISTER, D7
0000179C  13C7 00A00019           3663mm     MOVE.B D7, MC68230_PORT_C_DATA
000017A2  0207 00DF               3664mm     ANDI.B #~MC68230_PORT_C_READ, D7
000017A6  13C7 00A00019           3665mm     MOVE.B D7, MC68230_PORT_C_DATA
000017AC  1839 00A00011           3666mm     MOVE.B MC68230_PORT_A_DATA, D4
000017B2  E14C                    3667mm     LSL.W #8, D4
000017B4  1839 00A00013           3668mm     MOVE.B MC68230_PORT_B_DATA, D4
000017BA  0007 0020               3669mm     ORI.B #MC68230_PORT_C_READ, D7
000017BE  13C7 00A00019           3670mm     MOVE.B D7, MC68230_PORT_C_DATA
000017C4  13FC 0038 00A00019      3671mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000017CC                          3672mm     ENDM
000017CC                          3673m     ENDM
000017CC                          3674              IF.B D1 <LT> D0 THEN                ; still in the boot table?
000017CC  B200                    3675s     CMP.B   D0,D1
000017CE  6C00 0138               3676s     BGE _00000016
000017D2                          3677  
000017D2                          3678                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
000017D2  B63C 0000               3679s     CMP.B   #0,D3
000017D6  6600 0004               3680s     BNE _00000017
000017DA  1A04                    3681                      MOVE.B D4, D5               ; empty flag -> D5
000017DC                          3682                  ENDI
000017DC                          3683s _00000017
000017DC                          3684                  
000017DC                          3685                  IF.B D5 <NE> #1 THEN            ; not empty
000017DC  BA3C 0001               3686s     CMP.B   #1,D5
000017E0  6700 0126               3687s     BEQ _00000018
000017E4  2245                    3688                      MOVE.L D5, A1               ; preserve the empty flag, we're gonna need D5
000017E6                          3689                      
000017E6                          3690                      IF.B D3 <EQ> #0 THEN        ; first word in boot table, print the index
000017E6  B63C 0000               3691s     CMP.B   #0,D3
000017EA  6600 0044               3692s     BNE _00000019
000017EE                          3693m                         PRINT_REG_4BIT D1, D6, D7, A0   
000017EE  41FA 085A               3694m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000017F2  1E01                    3695m     MOVE.B D1,D7
000017F4  0287 0000000F           3696m     ANDI.L #$F,D7
000017FA  1E30 7000               3697m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
000017FE                          3698mm     PRINT_CHAR D7,D6
000017FE                          3699mm WAIT_FOR_READY_265                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017FE                 TRUE     3700mm     IFEQ DEBUG
000017FE  1C39 00C00003           3701mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00001804  0806 0002               3702mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00001808  67F4                    3703mm         BEQ WAIT_FOR_READY_265                      ; NO SPACE, CHECK AGAIN
0000180A  13C7 00C00007           3704mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001810                          3705mm     ENDC
00001810                          3706mm 
00001810                 FALSE    3707mm     IFNE DEBUG
00001810                          3708mm     ENDC
00001810                          3709mm 
00001810                          3710mm     ENDM
00001810                          3711m     ENDM
00001810  41FA 0891               3712                          LEA INDEX_SEP(PC), A0
00001814                          3713m                         PRINT_STR A0, D7
00001814                          3714m LOOP_266
00001814  0C10 0000               3715m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001818  6700 0016               3716m     BEQ EXIT_266
0000181C                          3717mm     PRINT_CHAR (A0)+,D7
0000181C                          3718mm WAIT_FOR_READY_267                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000181C                 TRUE     3719mm     IFEQ DEBUG
0000181C  1E39 00C00003           3720mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001822  0807 0002               3721mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001826  67F4                    3722mm         BEQ WAIT_FOR_READY_267                      ; NO SPACE, CHECK AGAIN
00001828  13D8 00C00007           3723mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000182E                          3724mm     ENDC
0000182E                          3725mm 
0000182E                 FALSE    3726mm     IFNE DEBUG
0000182E                          3727mm     ENDC
0000182E                          3728mm 
0000182E                          3729mm     ENDM
0000182E  60E4                    3730m     BRA LOOP_266
00001830                          3731m EXIT_266
00001830                          3732m     ENDM
00001830                          3733                      ENDI
00001830                          3734s _00000019
00001830                          3735                              
00001830                          3736                      IF.B D3 <GT> #1 AND.B D3 <LT> #8 THEN   ; str, print it
00001830  B63C 0001               3737s     CMP.B   #1,D3
00001834  6F00 002E               3738s     BLE _0000001A
00001838  B63C 0008               3739s     CMP.B   #8,D3
0000183C  6C00 0026               3740s     BGE _0000001A
00001840                          3741                          FOR.B D6 = #0 TO #3 DO
00001840  1C3C 0000               3742s     MOVE.B  #0,D6
00001844  6000 0018               3743s     BRA _20000019
00001848                          3744s _20000018
00001848  E19C                    3745                              ROL.L #8, D4                    
0000184A                          3746m                             PRINT_CHAR D4, D7
0000184A                          3747m WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000184A                 TRUE     3748m     IFEQ DEBUG
0000184A  1E39 00C00003           3749m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001850  0807 0002               3750m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001854  67F4                    3751m         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
00001856  13C4 00C00007           3752m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000185C                          3753m     ENDC
0000185C                          3754m 
0000185C                 FALSE    3755m     IFNE DEBUG
0000185C                          3756m     ENDC
0000185C                          3757m 
0000185C                          3758m     ENDM
0000185C                          3759                          ENDF
0000185C  5206                    3760s     ADD.B   #1,D6
0000185E                          3761s _20000019
0000185E  BC3C 0003               3762s     CMP.B   #3,D6
00001862  6FE4                    3763s     BLE _20000018
00001864                          3764                      ENDI
00001864                          3765s _0000001A
00001864                          3766  
00001864                          3767                      IF.B D3 <GT> #8 AND.B D3 <LT> #13 THEN
00001864  B63C 0008               3768s     CMP.B   #8,D3
00001868  6F00 009C               3769s     BLE _0000001B
0000186C  B63C 000D               3770s     CMP.B   #13,D3
00001870  6C00 0094               3771s     BGE _0000001B
00001874  41FA 082D               3772                          LEA INDEX_SEP(PC), A0
00001878                          3773m                         PRINT_STR A0, D7
00001878                          3774m LOOP_269
00001878  0C10 0000               3775m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000187C  6700 0016               3776m     BEQ EXIT_269
00001880                          3777mm     PRINT_CHAR (A0)+,D7
00001880                          3778mm WAIT_FOR_READY_270                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001880                 TRUE     3779mm     IFEQ DEBUG
00001880  1E39 00C00003           3780mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001886  0807 0002               3781mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000188A  67F4                    3782mm         BEQ WAIT_FOR_READY_270                      ; NO SPACE, CHECK AGAIN
0000188C  13D8 00C00007           3783mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001892                          3784mm     ENDC
00001892                          3785mm 
00001892                 FALSE    3786mm     IFNE DEBUG
00001892                          3787mm     ENDC
00001892                          3788mm 
00001892                          3789mm     ENDM
00001892  60E4                    3790m     BRA LOOP_269
00001894                          3791m EXIT_269
00001894                          3792m     ENDM
00001894                          3793m                         PRINT_REG D4, D5, D6, D7, A0
00001894  41FA 07F5               3794m     LEA OX(PC),A0
00001898                          3795mm     PRINT_STR A0,D5
00001898                          3796mm LOOP_272
00001898  0C10 0000               3797mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000189C  6700 0016               3798mm     BEQ EXIT_272
000018A0                          3799mmm     PRINT_CHAR (A0)+,D5
000018A0                          3800mmm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018A0                 TRUE     3801mmm     IFEQ DEBUG
000018A0  1A39 00C00003           3802mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000018A6  0805 0002               3803mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000018AA  67F4                    3804mmm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000018AC  13D8 00C00007           3805mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018B2                          3806mmm     ENDC
000018B2                          3807mmm 
000018B2                 FALSE    3808mmm     IFNE DEBUG
000018B2                          3809mmm     ENDC
000018B2                          3810mmm 
000018B2                          3811mmm     ENDM
000018B2  60E4                    3812mm     BRA LOOP_272
000018B4                          3813mm EXIT_272
000018B4                          3814mm     ENDM
000018B4  7E07                    3815m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000018B6                          3816m LOOP_271
000018B6                          3817mm     BIN2HEX D4,D6,A0
000018B6  41FA 0792               3818mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000018BA  E99C                    3819mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000018BC  1C04                    3820mm     MOVE.B D4,D6
000018BE  0286 0000000F           3821mm     ANDI.L #$F,D6
000018C4  1C30 6000               3822mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
000018C8                          3823mm     ENDM
000018C8                          3824mm     PRINT_CHAR D6,D5
000018C8                          3825mm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018C8                 TRUE     3826mm     IFEQ DEBUG
000018C8  1A39 00C00003           3827mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000018CE  0805 0002               3828mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000018D2  67F4                    3829mm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
000018D4  13C6 00C00007           3830mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
000018DA                          3831mm     ENDC
000018DA                          3832mm 
000018DA                 FALSE    3833mm     IFNE DEBUG
000018DA                          3834mm     ENDC
000018DA                          3835mm 
000018DA                          3836mm     ENDM
000018DA  57CF FFDA               3837m     DBEQ D7,LOOP_271
000018DE                          3838m     ENDM
000018DE                          3839  
000018DE                          3840                          IF.B D3 <EQ> #9 THEN
000018DE  B63C 0009               3841s     CMP.B   #9,D3
000018E2  6600 0004               3842s     BNE _0000001C
000018E6  2244                    3843                              MOVE.L D4, A1   ; length -> A1
000018E8                          3844                          ENDI
000018E8                          3845s _0000001C
000018E8                          3846              
000018E8                          3847                          IF.B D3 <EQ> #10 THEN
000018E8  B63C 000A               3848s     CMP.B   #10,D3
000018EC  6600 0004               3849s     BNE _0000001D
000018F0  2444                    3850                              MOVE.L D4, A2   ; start address -> A2
000018F2                          3851                          ENDI
000018F2                          3852s _0000001D
000018F2                          3853  
000018F2                          3854                          IF.B D3 <EQ> #11 THEN
000018F2  B63C 000B               3855s     CMP.B   #11,D3
000018F6  6600 0004               3856s     BNE _0000001E
000018FA  2644                    3857                              MOVE.L D4, A3   ; go address -> A3
000018FC                          3858                          ENDI
000018FC                          3859s _0000001E
000018FC                          3860  
000018FC                          3861                          IF.B D3 <EQ> #12 THEN
000018FC  B63C 000C               3862s     CMP.B   #12,D3
00001900  6600 0004               3863s     BNE _0000001F
00001904  2844                    3864                              MOVE.L D4, A4   ; start block -> A4
00001906                          3865                          ENDI
00001906                          3866s _0000001F
00001906                          3867                      ENDI        
00001906                          3868s _0000001B
00001906                          3869                      
00001906  2A09                    3870                      MOVE.L A1, D5               ; restore the empty flag into D5
00001908                          3871                  ENDI
00001908                          3872s _00000018
00001908                          3873              ENDI            
00001908                          3874s _00000016
00001908                          3875          ENDF
00001908  5203                    3876s     ADD.B   #1,D3
0000190A                          3877s _20000017
0000190A  B63C 000C               3878s     CMP.B   #12,D3
0000190E  6F00 FE28               3879s     BLE _20000016
00001912                          3880  
00001912                          3881          IF.B D5 <NE> #1 THEN                    ; not empty
00001912  BA3C 0001               3882s     CMP.B   #1,D5
00001916  6700 0022               3883s     BEQ _00000020
0000191A                          3884m             PRINT_CRLF D7, A0
0000191A  41FA 0769               3885m     LEA CRLF(PC),A0
0000191E                          3886mm     PRINT_STR A0,D7
0000191E                          3887mm LOOP_277
0000191E  0C10 0000               3888mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001922  6700 0016               3889mm     BEQ EXIT_277
00001926                          3890mmm     PRINT_CHAR (A0)+,D7
00001926                          3891mmm WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001926                 TRUE     3892mmm     IFEQ DEBUG
00001926  1E39 00C00003           3893mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000192C  0807 0002               3894mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001930  67F4                    3895mmm         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
00001932  13D8 00C00007           3896mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001938                          3897mmm     ENDC
00001938                          3898mmm 
00001938                 FALSE    3899mmm     IFNE DEBUG
00001938                          3900mmm     ENDC
00001938                          3901mmm 
00001938                          3902mmm     ENDM
00001938  60E4                    3903mm     BRA LOOP_277
0000193A                          3904mm EXIT_277
0000193A                          3905mm     ENDM
0000193A                          3906m     ENDM
0000193A                          3907          ENDI
0000193A                          3908s _00000020
0000193A                          3909          
0000193A  5281                    3910          ADD.L #1,D1                             ; next boot table index
0000193C                          3911      ENDF
0000193C  5202                    3912s     ADD.B   #1,D2
0000193E                          3913s _20000015
0000193E  B43C 0009               3914s     CMP.B   #9,D2
00001942  6F00 FDEC               3915s     BLE _20000014
00001946                          3916      
00001946                          3917      IF A5 <EQ> #1 THEN                          ; boot
00001946  BAFC 0001               3918s     CMP.W   #1,A5
0000194A  6600 0348               3919s     BNE _00000021
0000194E                          3920  
0000194E                          3921          IF A1 <EQ> #0 THEN                      ; check for boot from empty slot
0000194E  B2FC 0000               3922s     CMP.W   #0,A1
00001952  6600 0026               3923s     BNE _00000022
00001956  41FA 0758               3924              LEA NOT_FOUND(PC), A0
0000195A                          3925m             PRINT_STR A0, D7
0000195A                          3926m LOOP_279
0000195A  0C10 0000               3927m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000195E  6700 0016               3928m     BEQ EXIT_279
00001962                          3929mm     PRINT_CHAR (A0)+,D7
00001962                          3930mm WAIT_FOR_READY_280                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001962                 TRUE     3931mm     IFEQ DEBUG
00001962  1E39 00C00003           3932mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001968  0807 0002               3933mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000196C  67F4                    3934mm         BEQ WAIT_FOR_READY_280                      ; NO SPACE, CHECK AGAIN
0000196E  13D8 00C00007           3935mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001974                          3936mm     ENDC
00001974                          3937mm 
00001974                 FALSE    3938mm     IFNE DEBUG
00001974                          3939mm     ENDC
00001974                          3940mm 
00001974                          3941mm     ENDM
00001974  60E4                    3942m     BRA LOOP_279
00001976                          3943m EXIT_279
00001976                          3944m     ENDM
00001976  6000 E9CC               3945              BRA MAIN_LOOP
0000197A                          3946          ENDI
0000197A                          3947s _00000022
0000197A                          3948  
0000197A  41FA 072B               3949          LEA BOOT(PC), A0
0000197E                          3950m         PRINT_STR A0, D7
0000197E                          3951m LOOP_281
0000197E  0C10 0000               3952m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001982  6700 0016               3953m     BEQ EXIT_281
00001986                          3954mm     PRINT_CHAR (A0)+,D7
00001986                          3955mm WAIT_FOR_READY_282                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001986                 TRUE     3956mm     IFEQ DEBUG
00001986  1E39 00C00003           3957mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000198C  0807 0002               3958mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001990  67F4                    3959mm         BEQ WAIT_FOR_READY_282                      ; NO SPACE, CHECK AGAIN
00001992  13D8 00C00007           3960mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001998                          3961mm     ENDC
00001998                          3962mm 
00001998                 FALSE    3963mm     IFNE DEBUG
00001998                          3964mm     ENDC
00001998                          3965mm 
00001998                          3966mm     ENDM
00001998  60E4                    3967m     BRA LOOP_281
0000199A                          3968m EXIT_281
0000199A                          3969m     ENDM
0000199A                          3970      
0000199A  2009                    3971          MOVE.L A1, D0                           ; length -> D5
0000199C  220C                    3972          MOVE.L A4, D1                           ; start block -> D3
0000199E                          3973  
0000199E                          3974          WHILE.L D0 <GT> #0 DO
0000199E                          3975s _10000016
0000199E  B0BC 00000000           3976s     CMP.L   #0,D0
000019A4  6F00 02CC               3977s     BLE _10000017
000019A8                          3978m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
000019A8                          3979mm     WAIT_DRIVE_NOT_BUSY D5, D6
000019A8                          3980mm LOOP_284
000019A8                          3981mmm     READ_IDE_STATUS D5, D6
000019A8                          3982mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
000019A8  13FC 0000 00A00007      3983mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000019B0  1C3C 0030               3984mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
000019B4  0006 0007               3985mmmm     ORI.B #IDE_STATUS_REGISTER, D6
000019B8  13C6 00A00019           3986mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000019BE  0206 00DF               3987mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
000019C2  13C6 00A00019           3988mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000019C8  1A39 00A00013           3989mmmm     MOVE.B MC68230_PORT_B_DATA, D5
000019CE  0006 0020               3990mmmm     ORI.B #MC68230_PORT_C_READ, D6
000019D2  13C6 00A00019           3991mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000019D8  13FC 0038 00A00019      3992mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019E0                          3993mmmm     ENDM
000019E0                          3994mmm     ENDM
000019E0  0805 0007               3995mm     BTST #IDE_STATUS_BUSY, D5
000019E4  66C2                    3996mm     BNE LOOP_284
000019E6                          3997mm     ENDM
000019E6                          3998mm     SET_READ_ADDRESS D1, D5, D6, D7
000019E6                          3999mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D5
000019E6  13FC 00FF 00A00007      4000mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019EE  1A3C 0030               4001mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019F2  0005 0002               4002mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D5
000019F6  13C5 00A00019           4003mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019FC  0205 00EF               4004mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A00  13FC 0001 00A00013      4005mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001A08  13C5 00A00019           4006mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A0E  0005 0010               4007mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A12  13C5 00A00019           4008mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A18  13FC 0038 00A00019      4009mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A20                          4010mmm     ENDM
00001A20  2C01                    4011mm     MOVE.L D1,D6
00001A22                          4012mmm     WRITE_8 D6, #IDE_LBA_0_7_REGISTER, D5
00001A22  13FC 00FF 00A00007      4013mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A2A  1A3C 0030               4014mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A2E  0005 0003               4015mmm     ORI.B #IDE_LBA_0_7_REGISTER, D5
00001A32  13C5 00A00019           4016mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A38  0205 00EF               4017mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A3C  13C6 00A00013           4018mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A42  13C5 00A00019           4019mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A48  0005 0010               4020mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A4C  13C5 00A00019           4021mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A52  13FC 0038 00A00019      4022mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A5A                          4023mmm     ENDM
00001A5A  E08E                    4024mm     LSR.L #8, D6
00001A5C                          4025mmm     WRITE_8 D6, #IDE_LBA_8_15_REGISTER, D5
00001A5C  13FC 00FF 00A00007      4026mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A64  1A3C 0030               4027mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A68  0005 0004               4028mmm     ORI.B #IDE_LBA_8_15_REGISTER, D5
00001A6C  13C5 00A00019           4029mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A72  0205 00EF               4030mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A76  13C6 00A00013           4031mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001A7C  13C5 00A00019           4032mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A82  0005 0010               4033mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A86  13C5 00A00019           4034mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A8C  13FC 0038 00A00019      4035mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A94                          4036mmm     ENDM
00001A94  E08E                    4037mm     LSR.L #8, D6                                
00001A96                          4038mmm     WRITE_8 D6, #IDE_LBA_16_23_REGISTER, D5
00001A96  13FC 00FF 00A00007      4039mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A9E  1A3C 0030               4040mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001AA2  0005 0005               4041mmm     ORI.B #IDE_LBA_16_23_REGISTER, D5
00001AA6  13C5 00A00019           4042mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AAC  0205 00EF               4043mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001AB0  13C6 00A00013           4044mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001AB6  13C5 00A00019           4045mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001ABC  0005 0010               4046mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001AC0  13C5 00A00019           4047mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AC6  13FC 0038 00A00019      4048mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001ACE                          4049mmm     ENDM
00001ACE  E08E                    4050mm     LSR.L #8, D6
00001AD0                          4051mmm     READ_8 #IDE_DRIVESEL_REGISTER, D7, D5
00001AD0  13FC 0000 00A00007      4052mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001AD8  1A3C 0030               4053mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001ADC  0005 0006               4054mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001AE0  13C5 00A00019           4055mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AE6  0205 00DF               4056mmm     ANDI.B #~MC68230_PORT_C_READ, D5
00001AEA  13C5 00A00019           4057mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AF0  1E39 00A00013           4058mmm     MOVE.B MC68230_PORT_B_DATA, D7
00001AF6  0005 0020               4059mmm     ORI.B #MC68230_PORT_C_READ, D5
00001AFA  13C5 00A00019           4060mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B00  13FC 0038 00A00019      4061mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B08                          4062mmm     ENDM
00001B08  0206 000F               4063mm     ANDI.B #$0F,D6
00001B0C  8E06                    4064mm     OR.B D6,D7
00001B0E                          4065mmm     WRITE_8 D7, #IDE_DRIVESEL_REGISTER, D5
00001B0E  13FC 00FF 00A00007      4066mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001B16  1A3C 0030               4067mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001B1A  0005 0006               4068mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001B1E  13C5 00A00019           4069mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B24  0205 00EF               4070mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001B28  13C7 00A00013           4071mmm     MOVE.B D7, MC68230_PORT_B_DATA
00001B2E  13C5 00A00019           4072mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B34  0005 0010               4073mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001B38  13C5 00A00019           4074mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B3E  13FC 0038 00A00019      4075mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B46                          4076mmm     ENDM
00001B46                          4077mm     ENDM
00001B46                          4078mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D5
00001B46                          4079mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D5
00001B46  13FC 00FF 00A00007      4080mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001B4E  1A3C 0030               4081mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001B52  0005 0007               4082mmm     ORI.B #IDE_COMMAND_REGISTER, D5
00001B56  13C5 00A00019           4083mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B5C  0205 00EF               4084mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001B60  13FC 0020 00A00013      4085mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001B68  13C5 00A00019           4086mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B6E  0005 0010               4087mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001B72  13C5 00A00019           4088mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001B78  13FC 0038 00A00019      4089mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B80                          4090mmm     ENDM
00001B80                          4091mm     ENDM
00001B80                          4092mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001B80                          4093mm LOOP_296
00001B80                          4094mmm     READ_IDE_STATUS D5, D6
00001B80                          4095mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001B80  13FC 0000 00A00007      4096mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B88  1C3C 0030               4097mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001B8C  0006 0007               4098mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001B90  13C6 00A00019           4099mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B96  0206 00DF               4100mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001B9A  13C6 00A00019           4101mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BA0  1A39 00A00013           4102mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001BA6  0006 0020               4103mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001BAA  13C6 00A00019           4104mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BB0  13FC 0038 00A00019      4105mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001BB8                          4106mmmm     ENDM
00001BB8                          4107mmm     ENDM
00001BB8  0805 0007               4108mm     BTST #IDE_STATUS_BUSY, D5
00001BBC  66C2                    4109mm     BNE LOOP_296
00001BBE                          4110mm     ENDM
00001BBE                          4111mm     WAIT_DRIVE_DRQ D5, D6
00001BBE                          4112mm LOOP_299
00001BBE                          4113mmm     READ_IDE_STATUS D5, D6
00001BBE                          4114mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001BBE  13FC 0000 00A00007      4115mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001BC6  1C3C 0030               4116mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001BCA  0006 0007               4117mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001BCE  13C6 00A00019           4118mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BD4  0206 00DF               4119mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001BD8  13C6 00A00019           4120mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BDE  1A39 00A00013           4121mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001BE4  0006 0020               4122mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001BE8  13C6 00A00019           4123mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001BEE  13FC 0038 00A00019      4124mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001BF6                          4125mmmm     ENDM
00001BF6                          4126mmm     ENDM
00001BF6  0805 0003               4127mm     BTST #IDE_STATUS_DRQ, D5
00001BFA  67C2                    4128mm     BEQ LOOP_299
00001BFC                          4129mm     ENDM
00001BFC                          4130m     ENDM
00001BFC                          4131m             PRINT_CHAR #'.', D7
00001BFC                          4132m WAIT_FOR_READY_302                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001BFC                 TRUE     4133m     IFEQ DEBUG
00001BFC  1E39 00C00003           4134m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001C02  0807 0002               4135m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001C06  67F4                    4136m         BEQ WAIT_FOR_READY_302                      ; NO SPACE, CHECK AGAIN
00001C08  13FC 002E 00C00007      4137m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001C10                          4138m     ENDC
00001C10                          4139m 
00001C10                 FALSE    4140m     IFNE DEBUG
00001C10                          4141m     ENDC
00001C10                          4142m 
00001C10                          4143m     ENDM
00001C10                          4144              
00001C10                          4145              FOR.L D2 = #0 TO #255 DO
00001C10  7400                    4146s     MOVE.L  #0,D2
00001C12  6000 0050               4147s     BRA _2000001B
00001C16                          4148s _2000001A
00001C16                          4149m                 READ_16 #IDE_DATA_REGISTER, D2, D7
00001C16  13FC 0000 00A00007      4150m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001C1E  13FC 0000 00A00005      4151m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001C26                          4152m     
00001C26  1E3C 0030               4153m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001C2A  0007 0000               4154m     ORI.B #IDE_DATA_REGISTER, D7
00001C2E  13C7 00A00019           4155m     MOVE.B D7, MC68230_PORT_C_DATA
00001C34  0207 00DF               4156m     ANDI.B #~MC68230_PORT_C_READ, D7
00001C38  13C7 00A00019           4157m     MOVE.B D7, MC68230_PORT_C_DATA
00001C3E  1439 00A00011           4158m     MOVE.B MC68230_PORT_A_DATA, D2
00001C44  E14A                    4159m     LSL.W #8, D2
00001C46  1439 00A00013           4160m     MOVE.B MC68230_PORT_B_DATA, D2
00001C4C  0007 0020               4161m     ORI.B #MC68230_PORT_C_READ, D7
00001C50  13C7 00A00019           4162m     MOVE.B D7, MC68230_PORT_C_DATA
00001C56  13FC 0038 00A00019      4163m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001C5E                          4164m     ENDM
00001C5E  34C2                    4165                  MOVE.W D2,(A2)+
00001C60  5580                    4166                  SUB.L #2, D0
00001C62                          4167              ENDF
00001C62  5282                    4168s     ADD.L   #1,D2
00001C64                          4169s _2000001B
00001C64  B4BC 000000FF           4170s     CMP.L   #255,D2
00001C6A  6FAA                    4171s     BLE _2000001A
00001C6C                          4172          
00001C6C  5281                    4173              ADD.L #1, D1                        ; next block
00001C6E                          4174          ENDW
00001C6E  6000 FD2E               4175s     BRA _10000016
00001C72                          4176s _10000017
00001C72                          4177  
00001C72                          4178m         PRINT_CRLF D3, A6   
00001C72  4DFA 0411               4179m     LEA CRLF(PC),A6
00001C76                          4180mm     PRINT_STR A6,D3
00001C76                          4181mm LOOP_305
00001C76  0C16 0000               4182mm     CMP.B #NULL,(A6)                                ; 0 -> DONE
00001C7A  6700 0016               4183mm     BEQ EXIT_305
00001C7E                          4184mmm     PRINT_CHAR (A6)+,D3
00001C7E                          4185mmm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C7E                 TRUE     4186mmm     IFEQ DEBUG
00001C7E  1639 00C00003           4187mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001C84  0803 0002               4188mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001C88  67F4                    4189mmm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
00001C8A  13DE 00C00007           4190mmm         MOVE.B (A6)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C90                          4191mmm     ENDC
00001C90                          4192mmm 
00001C90                 FALSE    4193mmm     IFNE DEBUG
00001C90                          4194mmm     ENDC
00001C90                          4195mmm 
00001C90                          4196mmm     ENDM
00001C90  60E4                    4197mm     BRA LOOP_305
00001C92                          4198mm EXIT_305
00001C92                          4199mm     ENDM
00001C92                          4200m     ENDM
00001C92                          4201      
00001C92  2E0B                    4202          MOVE.L A3, D7                           ; set go address
00001C94                          4203      ENDI
00001C94                          4204s _00000021
00001C94                          4205      
00001C94  6000 E6AE               4206      BRA MAIN_LOOP
00001C98                          4207  
00001C98                          4208  HEX_DIGIT
00001C98  E98F                    4209      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001C9A                          4210m     HEX2BIN D2,D2,A0
00001C9A  41FA 03BE               4211m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001C9E  0402 0030               4212m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001CA2  C4BC 000000FF           4213m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001CA8  1430 2000               4214m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001CAC                          4215m     ENDM
00001CAC  8E02                    4216      OR.B D2,D7  
00001CAE  6000 E6B4               4217      BRA GET_INPUT
00001CB2                          4218  
00001CB2                          4219  ; exceptions    
00001CB2                          4220  BUS_ERROR_HANDLER
00001CB2                          4221  
00001CB2  41FA 040F               4222      LEA BUS_ERROR(PC),A0
00001CB6                          4223m     PRINT_STR A0,D1
00001CB6                          4224m LOOP_308
00001CB6  0C10 0000               4225m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CBA  6700 0016               4226m     BEQ EXIT_308
00001CBE                          4227mm     PRINT_CHAR (A0)+,D1
00001CBE                          4228mm WAIT_FOR_READY_309                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CBE                 TRUE     4229mm     IFEQ DEBUG
00001CBE  1239 00C00003           4230mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CC4  0801 0002               4231mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CC8  67F4                    4232mm         BEQ WAIT_FOR_READY_309                      ; NO SPACE, CHECK AGAIN
00001CCA  13D8 00C00007           4233mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CD0                          4234mm     ENDC
00001CD0                          4235mm 
00001CD0                 FALSE    4236mm     IFNE DEBUG
00001CD0                          4237mm     ENDC
00001CD0                          4238mm 
00001CD0                          4239mm     ENDM
00001CD0  60E4                    4240m     BRA LOOP_308
00001CD2                          4241m EXIT_308
00001CD2                          4242m     ENDM
00001CD2                          4243  
00001CD2  7000                    4244      MOVE.L #0,D0
00001CD4  3017                    4245      MOVE.W (SP),D0
00001CD6                          4246  
00001CD6  0800 0004               4247      BTST #4,D0
00001CDA  6700 0026               4248      BEQ WRITE
00001CDE                          4249      
00001CDE  41FA 03F8               4250      LEA READING(PC),A0
00001CE2                          4251m     PRINT_STR A0,D1
00001CE2                          4252m LOOP_310
00001CE2  0C10 0000               4253m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CE6  6700 0016               4254m     BEQ EXIT_310
00001CEA                          4255mm     PRINT_CHAR (A0)+,D1
00001CEA                          4256mm WAIT_FOR_READY_311                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CEA                 TRUE     4257mm     IFEQ DEBUG
00001CEA  1239 00C00003           4258mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001CF0  0801 0002               4259mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001CF4  67F4                    4260mm         BEQ WAIT_FOR_READY_311                      ; NO SPACE, CHECK AGAIN
00001CF6  13D8 00C00007           4261mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CFC                          4262mm     ENDC
00001CFC                          4263mm 
00001CFC                 FALSE    4264mm     IFNE DEBUG
00001CFC                          4265mm     ENDC
00001CFC                          4266mm 
00001CFC                          4267mm     ENDM
00001CFC  60E4                    4268m     BRA LOOP_310
00001CFE                          4269m EXIT_310
00001CFE                          4270m     ENDM
00001CFE                          4271  
00001CFE  6000 0022               4272      BRA CONTINUE    
00001D02                          4273  WRITE
00001D02  41FA 03DD               4274      LEA WRITING(PC),A0
00001D06                          4275m     PRINT_STR A0,D1
00001D06                          4276m LOOP_312
00001D06  0C10 0000               4277m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D0A  6700 0016               4278m     BEQ EXIT_312
00001D0E                          4279mm     PRINT_CHAR (A0)+,D1
00001D0E                          4280mm WAIT_FOR_READY_313                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D0E                 TRUE     4281mm     IFEQ DEBUG
00001D0E  1239 00C00003           4282mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001D14  0801 0002               4283mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001D18  67F4                    4284mm         BEQ WAIT_FOR_READY_313                      ; NO SPACE, CHECK AGAIN
00001D1A  13D8 00C00007           4285mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D20                          4286mm     ENDC
00001D20                          4287mm 
00001D20                 FALSE    4288mm     IFNE DEBUG
00001D20                          4289mm     ENDC
00001D20                          4290mm 
00001D20                          4291mm     ENDM
00001D20  60E4                    4292m     BRA LOOP_312
00001D22                          4293m EXIT_312
00001D22                          4294m     ENDM
00001D22                          4295  
00001D22                          4296  CONTINUE
00001D22  222F 0002               4297      MOVE.L 2(SP),D1
00001D26                          4298m     PRINT_REG D1,D2,D3,D4,A0
00001D26  41FA 0363               4299m     LEA OX(PC),A0
00001D2A                          4300mm     PRINT_STR A0,D2
00001D2A                          4301mm LOOP_315
00001D2A  0C10 0000               4302mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D2E  6700 0016               4303mm     BEQ EXIT_315
00001D32                          4304mmm     PRINT_CHAR (A0)+,D2
00001D32                          4305mmm WAIT_FOR_READY_316                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D32                 TRUE     4306mmm     IFEQ DEBUG
00001D32  1439 00C00003           4307mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D38  0802 0002               4308mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D3C  67F4                    4309mmm         BEQ WAIT_FOR_READY_316                      ; NO SPACE, CHECK AGAIN
00001D3E  13D8 00C00007           4310mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D44                          4311mmm     ENDC
00001D44                          4312mmm 
00001D44                 FALSE    4313mmm     IFNE DEBUG
00001D44                          4314mmm     ENDC
00001D44                          4315mmm 
00001D44                          4316mmm     ENDM
00001D44  60E4                    4317mm     BRA LOOP_315
00001D46                          4318mm EXIT_315
00001D46                          4319mm     ENDM
00001D46  7807                    4320m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001D48                          4321m LOOP_314
00001D48                          4322mm     BIN2HEX D1,D3,A0
00001D48  41FA 0300               4323mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001D4C  E999                    4324mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001D4E  1601                    4325mm     MOVE.B D1,D3
00001D50  0283 0000000F           4326mm     ANDI.L #$F,D3
00001D56  1630 3000               4327mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D5A                          4328mm     ENDM
00001D5A                          4329mm     PRINT_CHAR D3,D2
00001D5A                          4330mm WAIT_FOR_READY_318                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D5A                 TRUE     4331mm     IFEQ DEBUG
00001D5A  1439 00C00003           4332mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D60  0802 0002               4333mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D64  67F4                    4334mm         BEQ WAIT_FOR_READY_318                      ; NO SPACE, CHECK AGAIN
00001D66  13C3 00C00007           4335mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D6C                          4336mm     ENDC
00001D6C                          4337mm 
00001D6C                 FALSE    4338mm     IFNE DEBUG
00001D6C                          4339mm     ENDC
00001D6C                          4340mm 
00001D6C                          4341mm     ENDM
00001D6C  57CC FFDA               4342m     DBEQ D4,LOOP_314
00001D70                          4343m     ENDM
00001D70                          4344  
00001D70  41FA 0378               4345      LEA FROM(PC),A0
00001D74                          4346m     PRINT_STR A0,D0
00001D74                          4347m LOOP_319
00001D74  0C10 0000               4348m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D78  6700 0016               4349m     BEQ EXIT_319
00001D7C                          4350mm     PRINT_CHAR (A0)+,D0
00001D7C                          4351mm WAIT_FOR_READY_320                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D7C                 TRUE     4352mm     IFEQ DEBUG
00001D7C  1039 00C00003           4353mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D82  0800 0002               4354mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001D86  67F4                    4355mm         BEQ WAIT_FOR_READY_320                      ; NO SPACE, CHECK AGAIN
00001D88  13D8 00C00007           4356mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D8E                          4357mm     ENDC
00001D8E                          4358mm 
00001D8E                 FALSE    4359mm     IFNE DEBUG
00001D8E                          4360mm     ENDC
00001D8E                          4361mm 
00001D8E                          4362mm     ENDM
00001D8E  60E4                    4363m     BRA LOOP_319
00001D90                          4364m EXIT_319
00001D90                          4365m     ENDM
00001D90                          4366  
00001D90  222F 000A               4367      MOVE.L 10(SP),D1
00001D94                          4368m     PRINT_REG D1,D2,D3,D4,A0
00001D94  41FA 02F5               4369m     LEA OX(PC),A0
00001D98                          4370mm     PRINT_STR A0,D2
00001D98                          4371mm LOOP_322
00001D98  0C10 0000               4372mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D9C  6700 0016               4373mm     BEQ EXIT_322
00001DA0                          4374mmm     PRINT_CHAR (A0)+,D2
00001DA0                          4375mmm WAIT_FOR_READY_323                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DA0                 TRUE     4376mmm     IFEQ DEBUG
00001DA0  1439 00C00003           4377mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001DA6  0802 0002               4378mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001DAA  67F4                    4379mmm         BEQ WAIT_FOR_READY_323                      ; NO SPACE, CHECK AGAIN
00001DAC  13D8 00C00007           4380mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DB2                          4381mmm     ENDC
00001DB2                          4382mmm 
00001DB2                 FALSE    4383mmm     IFNE DEBUG
00001DB2                          4384mmm     ENDC
00001DB2                          4385mmm 
00001DB2                          4386mmm     ENDM
00001DB2  60E4                    4387mm     BRA LOOP_322
00001DB4                          4388mm EXIT_322
00001DB4                          4389mm     ENDM
00001DB4  7807                    4390m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001DB6                          4391m LOOP_321
00001DB6                          4392mm     BIN2HEX D1,D3,A0
00001DB6  41FA 0292               4393mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001DBA  E999                    4394mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001DBC  1601                    4395mm     MOVE.B D1,D3
00001DBE  0283 0000000F           4396mm     ANDI.L #$F,D3
00001DC4  1630 3000               4397mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001DC8                          4398mm     ENDM
00001DC8                          4399mm     PRINT_CHAR D3,D2
00001DC8                          4400mm WAIT_FOR_READY_325                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DC8                 TRUE     4401mm     IFEQ DEBUG
00001DC8  1439 00C00003           4402mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001DCE  0802 0002               4403mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001DD2  67F4                    4404mm         BEQ WAIT_FOR_READY_325                      ; NO SPACE, CHECK AGAIN
00001DD4  13C3 00C00007           4405mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001DDA                          4406mm     ENDC
00001DDA                          4407mm 
00001DDA                 FALSE    4408mm     IFNE DEBUG
00001DDA                          4409mm     ENDC
00001DDA                          4410mm 
00001DDA                          4411mm     ENDM
00001DDA  57CC FFDA               4412m     DBEQ D4,LOOP_321
00001DDE                          4413m     ENDM
00001DDE                          4414m     PRINT_CRLF D0,A0
00001DDE  41FA 02A5               4415m     LEA CRLF(PC),A0
00001DE2                          4416mm     PRINT_STR A0,D0
00001DE2                          4417mm LOOP_327
00001DE2  0C10 0000               4418mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001DE6  6700 0016               4419mm     BEQ EXIT_327
00001DEA                          4420mmm     PRINT_CHAR (A0)+,D0
00001DEA                          4421mmm WAIT_FOR_READY_328                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001DEA                 TRUE     4422mmm     IFEQ DEBUG
00001DEA  1039 00C00003           4423mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001DF0  0800 0002               4424mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001DF4  67F4                    4425mmm         BEQ WAIT_FOR_READY_328                      ; NO SPACE, CHECK AGAIN
00001DF6  13D8 00C00007           4426mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001DFC                          4427mmm     ENDC
00001DFC                          4428mmm 
00001DFC                 FALSE    4429mmm     IFNE DEBUG
00001DFC                          4430mmm     ENDC
00001DFC                          4431mmm 
00001DFC                          4432mmm     ENDM
00001DFC  60E4                    4433mm     BRA LOOP_327
00001DFE                          4434mm EXIT_327
00001DFE                          4435mm     ENDM
00001DFE                          4436m     ENDM
00001DFE                          4437      
00001DFE  207C 00000004           4438      MOVE.L #4,A0
00001E04  4ED0                    4439      JMP (A0)
00001E06                          4440          
00001E06                          4441  ILLEGAL_HANDLER
00001E06  13FC 0007 00E00001      4442      MOVE.B #7,DISPLAY   
00001E0E  207C 00000004           4443      MOVE.L #4,A0
00001E14  4ED0                    4444      JMP (A0)
00001E16                          4445          
00001E16                          4446  UNHANDLED_HANDLER
00001E16  41FA 02D9               4447      LEA UNHANDLED(PC),A0
00001E1A  4EF9 00001E3E           4448      JMP PRINTIT_RTE
00001E20                          4449      
00001E20                          4450  UNINITIALISED_HANDLER
00001E20  41FA 02E5               4451      LEA UNINITIALISED(PC),A0
00001E24  4EF9 00001E3E           4452      JMP PRINTIT_RTE
00001E2A                          4453  
00001E2A                          4454  TICK_HANDLER
00001E2A  1039 00C0001F           4455      MOVE.B DUART_RESET_OPR,D0
00001E30  41FA 028A               4456      LEA TICK(PC),A0
00001E34  4EF9 00001E3E           4457      JMP PRINTIT_RTE
00001E3A                          4458  
00001E3A                          4459  SPURIOUS_HANDLER
00001E3A  41FA 02EA               4460      LEA SPURIOUS(PC),A0
00001E3E                          4461  PRINTIT_RTE
00001E3E                          4462m     PRINT_STR A0,D1
00001E3E                          4463m LOOP_329
00001E3E  0C10 0000               4464m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001E42  6700 0016               4465m     BEQ EXIT_329
00001E46                          4466mm     PRINT_CHAR (A0)+,D1
00001E46                          4467mm WAIT_FOR_READY_330                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001E46                 TRUE     4468mm     IFEQ DEBUG
00001E46  1239 00C00003           4469mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001E4C  0801 0002               4470mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001E50  67F4                    4471mm         BEQ WAIT_FOR_READY_330                      ; NO SPACE, CHECK AGAIN
00001E52  13D8 00C00007           4472mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001E58                          4473mm     ENDC
00001E58                          4474mm 
00001E58                 FALSE    4475mm     IFNE DEBUG
00001E58                          4476mm     ENDC
00001E58                          4477mm 
00001E58                          4478mm     ENDM
00001E58  60E4                    4479m     BRA LOOP_329
00001E5A                          4480m EXIT_329
00001E5A                          4481m     ENDM
00001E5A  4E73                    4482      RTE 
00001E5C                          4483      
00001E5C  FFFF FFFF               4484      SIMHALT                                             ; halt simulator
00001E60                          4485  
00001E60                          4486  ; strings
00001E60= 50 72 65 73 73 20 ...   4487  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001E73= 5B 3F 5D 09 09 09 ...   4488  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001E7F= 5B 76 5D 09 09 09 ...   4489          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001E8E= 78 78 78 78 78 78 ...   4490          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001EA6= 78 78 78 78 78 78 ...   4491          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001EC6= 78 78 78 78 78 78 ...   4492          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001EE7= 78 78 78 78 78 78 ...   4493          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001EF8= 5B 7A 5D 09 09 09 ...   4494          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001F0A= 78 78 78 78 78 78 ...   4495          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001F2E= 78 78 78 78 78 78 ...   4496          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001F50= 23 09 09 09 77 72 ...   4497          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001F6A= 5B 78 5D 09 09 09 ...   4498          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001F81= 5B 49 5D 09 09 09 ...   4499          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001F9A= 5B 6F 5D 09 09 09 ...   4500          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001FB4= 5B 69 5D 09 09 09 ...   4501          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001FCA= 78 78 78 78 78 78 ...   4502          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001FE8= 48 75 68 3F 0D 0A 00    4503  HUH  DC.B 'Huh?',CR,LF,NULL
00001FEF= 20 53 20 72 65 63 ...   4504  READ    DC.B ' S records read, start address = ',NULL
00002011= 57 3A 20 55 6E 6B ...   4505  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00002028= 21 20 43 53 20 66 ...   4506  CS_FAILURE  DC.B '! CS failure at ',NULL
00002039= 21 20 52 41 4D 20 ...   4507  RAM_ERROR   DC.B '! RAM error at: ',NULL
0000204A= 30 31 32 33 34 35 ...   4508  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000205A= 00 01 02 03 04 05 ...   4509  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00002071= 4C 6F 61 64 69 6E ...   4510  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00002085= 0D 0A 00                4511  CRLF    DC.B CR,LF,NULL
00002088= 3E 20 00                4512  PROMPT  DC.B '> ',NULL
0000208B= 30 78 00                4513  ox      DC.B '0x',NULL
0000208E= 20 2D 3E 20 00          4514  to      DC.B ' -> ',NULL
00002093= 20 66 6F 72 20 00       4515  for     DC.B ' for ',NULL
00002099= 53 50 3A 20 00          4516  STACK_POINTER DC.B 'SP: ',NULL
0000209E= 53 52 3A 20 00          4517  STATUS_REGISTER DC.B 'SR: ',NULL
000020A3= 20 3A 20 00             4518  INDEX_SEP DC.B ' : ',NULL
000020A7= 42 6F 6F 74 69 6E ...   4519  BOOT DC.B 'Booting ',NULL
000020B0= 4E 6F 74 20 66 6F ...   4520  NOT_FOUND DC.B 'Not found',CR,LF,NULL
000020BC= 74 69 63 6B 0D 0A 00    4521  TICK DC.B 'tick',CR,LF,NULL
000020C3= 2A 20 42 75 73 2F ...   4522  BUS_ERROR DC.B '* Bus/address error ',NULL
000020D8= 72 65 61 64 69 6E ...   4523  READING DC.B 'reading ',NULL
000020E1= 77 72 69 74 69 6E ...   4524  WRITING DC.B 'writing ',NULL
000020EA= 20 66 72 6F 6D 20 00    4525  FROM DC.B ' from ',NULL
000020F1= 2A 20 55 6E 68 61 ...   4526  UNHANDLED DC.B '* Unhandled interrupt',NULL
00002107= 2A 20 55 6E 69 74 ...   4527  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00002126= 2A 20 53 70 75 72 ...   4528  SPURIOUS DC.B '* Spurious interrupt',NULL
0000213B= 4D 44 46 2D 6D 6F ...   4529  VERSION DC.B 'MDF-mon V1.146 (30/05/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00002159= 00                      4530  END     DC.B 0
0000215A                          4531      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         204A
BOOT                20A7
BUS_ERROR           20C3
BUS_ERROR_HANDLER   1CB2
CONTINUE            1D22
CONTINUE_101        A86
CONTINUE_54         624
CONTINUE_57         674
CONTINUE_60         6B8
CONTINUE_64         73A
CONTINUE_68         79A
CONTINUE_72         804
CONTINUE_76         870
CONTINUE_80         8E6
CONTINUE_84         946
CONTINUE_88         9A6
CR                  D
CRLF                2085
CS_FAILURE          2028
DEBUG               0
DI                  134C
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       B54
DOWNLOAD_DONE       B7E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  133C
END                 2159
EXIT_10             288
EXIT_105            AE4
EXIT_107            B04
EXIT_110            B24
EXIT_115            B6E
EXIT_118            B9E
EXIT_121            BBE
EXIT_125            C08
EXIT_128            C2A
EXIT_133            C74
EXIT_135            CF0
EXIT_138            D14
EXIT_143            D5E
EXIT_15             2D2
EXIT_150            DF0
EXIT_153            E60
EXIT_156            E82
EXIT_160            ECC
EXIT_163            EEE
EXIT_167            F38
EXIT_17             2F2
EXIT_170            F58
EXIT_175            FA2
EXIT_190            10C4
EXIT_193            1128
EXIT_196            1148
EXIT_20             312
EXIT_200            1192
EXIT_203            11B4
EXIT_208            11FE
EXIT_212            1240
EXIT_215            1262
EXIT_22             364
EXIT_220            12AC
EXIT_222            12CC
EXIT_225            12EE
EXIT_230            1338
EXIT_259            171A
EXIT_266            1830
EXIT_269            1894
EXIT_272            18B4
EXIT_277            193A
EXIT_279            1976
EXIT_28             3F0
EXIT_281            199A
EXIT_30             47C
EXIT_305            1C92
EXIT_308            1CD2
EXIT_310            1CFE
EXIT_312            1D22
EXIT_315            1D46
EXIT_319            1D90
EXIT_32             4A8
EXIT_322            1DB4
EXIT_327            1DFE
EXIT_329            1E5A
EXIT_35             4D2
EXIT_45             580
EXIT_5              240
EXIT_52             5F6
EXIT_7              260
EXIT_92             A06
EXIT_94             A26
EXIT_98             A58
FOR                 2093
FROM                20EA
G                   C78
GET_INPUT           364
H                   480
HASH                135C
HELP                1E73
HELPPROMPT          1E60
HEX2BIN             10B
HEX2BIN_LUT         205A
HEX_DIGIT           1C98
HUH                 1FE8
IB                  1372
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1E06
INDEX_SEP           20A3
L                   D6E
LF                  A
LOADING             2071
LOOP_10             26C
LOOP_105            AC8
LOOP_107            AE8
LOOP_109            B26
LOOP_110            B08
LOOP_115            B52
LOOP_118            B82
LOOP_120            BC0
LOOP_121            BA2
LOOP_125            BEC
LOOP_127            C2C
LOOP_128            C0E
LOOP_133            C58
LOOP_135            CD4
LOOP_137            D16
LOOP_138            CF8
LOOP_143            D42
LOOP_15             2B6
LOOP_150            DD4
LOOP_153            E44
LOOP_155            E84
LOOP_156            E66
LOOP_160            EB0
LOOP_162            EF0
LOOP_163            ED2
LOOP_167            F1C
LOOP_169            F5A
LOOP_17             2D6
LOOP_170            F3C
LOOP_175            F86
LOOP_190            10A8
LOOP_193            110C
LOOP_195            114A
LOOP_196            112C
LOOP_20             2F6
LOOP_200            1176
LOOP_202            11B6
LOOP_203            1198
LOOP_208            11E2
LOOP_212            1224
LOOP_214            1264
LOOP_215            1246
LOOP_22             348
LOOP_220            1290
LOOP_222            12B0
LOOP_224            12F0
LOOP_225            12D2
LOOP_230            131C
LOOP_234            13CC
LOOP_238            140A
LOOP_250            15E2
LOOP_253            1620
LOOP_259            16FE
LOOP_266            1814
LOOP_269            1878
LOOP_271            18B6
LOOP_272            1898
LOOP_277            191E
LOOP_279            195A
LOOP_28             3D4
LOOP_281            197E
LOOP_284            19A8
LOOP_296            1B80
LOOP_299            1BBE
LOOP_30             460
LOOP_305            1C76
LOOP_308            1CB6
LOOP_310            1CE2
LOOP_312            1D06
LOOP_314            1D48
LOOP_315            1D2A
LOOP_319            1D74
LOOP_32             48C
LOOP_321            1DB6
LOOP_322            1D98
LOOP_327            1DE2
LOOP_329            1E3E
LOOP_34             4D4
LOOP_35             4B6
LOOP_45             564
LOOP_5              224
LOOP_52             5DA
LOOP_7              244
LOOP_9              28A
LOOP_92             9EA
LOOP_94             A0A
LOOP_98             A3C
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           20B0
NULL                0
OX                  208B
P                   1050
PRINTIT             48C
PRINTIT_RTE         1E3E
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             CFE
PROGRAM_VECTOR      D95
PROMPT              2088
PROTECT             AF0
R                   4AC
RAM                 200000
RAM_ERROR           2039
READ                1FEF
READING             20D8
READ_16             1188
READ_32             13B5
READ_8              E13
READ_CHAR           6DD
READ_IDE_STATUS     1404
RESET               4
ROM                 0
S                   5FE
SEND_COMMAND        1686
SEND_READ_COMMAND_AND_WAIT  16B5
SET_READ_ADDRESS    1524
SPURIOUS            2126
SPURIOUS_HANDLER    1E3A
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       2099
START               104
STATUS_REGISTER     209E
TAB                 9
TICK                20BC
TICK_HANDLER        1E2A
TO                  208E
UNHANDLED           20F1
UNHANDLED_HANDLER   1E16
UNINITIALISED       2107
UNINITIALISED_HANDLER  1E20
UNPROTECT           A29
UNREC               2011
USER                100
V                   488
VECS                8
VERSION             213B
W                   584
WAIT_CHAR           599
WAIT_DRIVE_DRQ      14D4
WAIT_DRIVE_NOT_BUSY  1483
WAIT_DRIVE_READY    1431
WAIT_FOR_COMPLETE_177  FB4
WAIT_FOR_COMPLETE_179  FD6
WAIT_FOR_COMPLETE_180  FE8
WAIT_FOR_COMPLETE_182  1016
WAIT_FOR_COMPLETE_183  1028
WAIT_FOR_COMPLETE_210  1200
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A6A
WAIT_FOR_READY_106  AD0
WAIT_FOR_READY_108  AF0
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  B10
WAIT_FOR_READY_113  B38
WAIT_FOR_READY_116  B5A
WAIT_FOR_READY_119  B8A
WAIT_FOR_READY_122  BAA
WAIT_FOR_READY_124  BD2
WAIT_FOR_READY_126  BF4
WAIT_FOR_READY_129  C16
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_131  C3E
WAIT_FOR_READY_134  C60
WAIT_FOR_READY_136  CDC
WAIT_FOR_READY_139  D00
WAIT_FOR_READY_141  D28
WAIT_FOR_READY_144  D4A
WAIT_FOR_READY_145  D7C
WAIT_FOR_READY_147  D96
WAIT_FOR_READY_151  DDC
WAIT_FOR_READY_154  E4C
WAIT_FOR_READY_157  E6E
WAIT_FOR_READY_159  E96
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  EB8
WAIT_FOR_READY_164  EDA
WAIT_FOR_READY_166  F02
WAIT_FOR_READY_168  F24
WAIT_FOR_READY_171  F44
WAIT_FOR_READY_173  F6C
WAIT_FOR_READY_176  F8E
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_185  105C
WAIT_FOR_READY_187  1076
WAIT_FOR_READY_191  10B0
WAIT_FOR_READY_194  1114
WAIT_FOR_READY_197  1134
WAIT_FOR_READY_199  115C
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  117E
WAIT_FOR_READY_204  11A0
WAIT_FOR_READY_206  11C8
WAIT_FOR_READY_209  11EA
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_213  122C
WAIT_FOR_READY_216  124E
WAIT_FOR_READY_218  1276
WAIT_FOR_READY_221  1298
WAIT_FOR_READY_223  12B8
WAIT_FOR_READY_226  12DA
WAIT_FOR_READY_228  1302
WAIT_FOR_READY_23   350
WAIT_FOR_READY_231  1324
WAIT_FOR_READY_24   364
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_260  1706
WAIT_FOR_READY_265  17FE
WAIT_FOR_READY_267  181C
WAIT_FOR_READY_268  184A
WAIT_FOR_READY_270  1880
WAIT_FOR_READY_273  18A0
WAIT_FOR_READY_275  18C8
WAIT_FOR_READY_278  1926
WAIT_FOR_READY_280  1962
WAIT_FOR_READY_282  1986
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_302  1BFC
WAIT_FOR_READY_306  1C7E
WAIT_FOR_READY_309  1CBE
WAIT_FOR_READY_31   468
WAIT_FOR_READY_311  1CEA
WAIT_FOR_READY_313  1D0E
WAIT_FOR_READY_316  1D32
WAIT_FOR_READY_318  1D5A
WAIT_FOR_READY_320  1D7C
WAIT_FOR_READY_323  1DA0
WAIT_FOR_READY_325  1DC8
WAIT_FOR_READY_328  1DEA
WAIT_FOR_READY_33   494
WAIT_FOR_READY_330  1E46
WAIT_FOR_READY_36   4BE
WAIT_FOR_READY_38   4E6
WAIT_FOR_READY_39   4FC
WAIT_FOR_READY_40   512
WAIT_FOR_READY_41   526
WAIT_FOR_READY_42   53A
WAIT_FOR_READY_43   54E
WAIT_FOR_READY_46   56C
WAIT_FOR_READY_47   58E
WAIT_FOR_READY_49   5A8
WAIT_FOR_READY_53   5E2
WAIT_FOR_READY_54   608
WAIT_FOR_READY_56   642
WAIT_FOR_READY_57   658
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_60   69C
WAIT_FOR_READY_64   71E
WAIT_FOR_READY_68   77E
WAIT_FOR_READY_72   7E8
WAIT_FOR_READY_76   854
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_80   8CA
WAIT_FOR_READY_84   92A
WAIT_FOR_READY_88   98A
WAIT_FOR_READY_93   9F2
WAIT_FOR_READY_95   A12
WAIT_FOR_READY_96   A26
WAIT_FOR_READY_99   A44
WAIT_FOR_SRECORD    608
WRITE               1D02
WRITE_8             FCC
WRITING             20E1
X                   1220
Z                   C7E
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6FE
_00000004           A5C
_00000005           70C
_00000006           8B2
_00000007           83A
_00000008           A5C
_00000009           9E6
_0000000A           A5C
_0000000B           B72
_0000000C           B7E
_0000000D           D5E
_0000000E           FBE
_0000000F           FE0
_00000010           FF2
_00000011           1020
_00000012           1032
_00000013           120A
_00000014           171E
_00000015           1728
_00000016           1908
_00000017           17DC
_00000018           1908
_00000019           1830
_0000001A           1864
_0000001B           1906
_0000001C           18E8
_0000001D           18F2
_0000001E           18FC
_0000001F           1906
_00000020           193A
_00000021           1C94
_00000022           197A
_10000000           692
_10000001           6E8
_10000002           714
_10000003           76A
_10000004           774
_10000005           7CA
_10000006           7DE
_10000007           834
_10000008           83E
_10000009           8AC
_1000000A           84A
_1000000B           8A0
_1000000C           8C0
_1000000D           916
_1000000E           920
_1000000F           976
_10000010           980
_10000011           9D6
_10000012           A60
_10000013           AB6
_10000014           FA2
_10000015           FC4
_10000016           199E
_10000017           1C72
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           58C
_20000005           5D0
_20000006           C90
_20000007           CA0
_20000008           CBA
_20000009           D60
_2000000A           D7A
_2000000B           DBE
_2000000C           E36
_2000000D           E3A
_2000000E           FFA
_2000000F           1034
_20000010           105A
_20000011           109E
_20000012           10FE
_20000013           1102
_20000014           1730
_20000015           193E
_20000016           1738
_20000017           190A
_20000018           1848
_20000019           185E
_2000001A           1C16
_2000001B           1C64
