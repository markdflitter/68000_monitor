00000010 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 25/04/2021 08:23:38

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  ; take advantage of my whole megabyte of memory!
00000000                             9  
00000000                            10  ; other ideas
00000000                            11  ;------------
00000000                            12  ; use DBLoop?
00000000                            13  ; keep track of highest address hit during srec download
00000000                            14  ; implement backspace
00000000                            15  ; fix being able to enter random chars when W'ing
00000000                            16  ; ram check at startup?  Not sure if this is a good idea!
00000000                            17  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            18  
00000000                            19      ORG  $0
00000000                            20  
00000000  =00000000                 21  DEBUG               EQU 0
00000000                            22  
00000000                            23  ; constants
00000000  =00000000                 24  NULL                EQU 0
00000000  =00000009                 25  TAB                 EQU 9
00000000  =0000000D                 26  CR                  EQU 13
00000000  =0000000A                 27  LF                  EQU 10
00000000                            28  
00000000  =00000000                 29  ROM                 EQU $0
00000000  =00200000                 30  RAM                 EQU $200000
00000000                            31  
00000000  =00C00000                 32  DUART_BASE          EQU $C00000
00000000  =00000000                 33  DUART_MRA_          EQU $0
00000000  =00000001                 34  DUART_CSRA_         EQU $1
00000000  =00000001                 35  DUART_SRA_          EQU $1
00000000  =00000002                 36  DUART_CRA_          EQU $2
00000000  =00000003                 37  DUART_TXA_          EQU $3
00000000  =00000003                 38  DUART_RXA_          EQU $3
00000000  =00000004                 39  DUART_ACR_          EQU $4
00000000  =00000005                 40  DUART_IMR_          EQU $5
00000000  =00000008                 41  DUART_MRB_          EQU $8
00000000  =00000009                 42  DUART_CSRB_         EQU $9
00000000  =00000009                 43  DUART_SRB_          EQU $9
00000000  =0000000A                 44  DUART_CRB_          EQU $A
00000000  =0000000B                 45  DUART_TXB_          EQU $B
00000000  =0000000B                 46  DUART_RXB_          EQU $B
00000000  =0000000C                 47  DUART_IVR_          EQU $C
00000000  =0000000D                 48  DUART_OPCR_         EQU $D
00000000  =0000000E                 49  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 50  DUART_RESET_OPR_    EQU $F
00000000                            51  
00000000  =00C00001                 52  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 53  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 54  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 55  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 56  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 57  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            58  
00000000  =00C00011                 59  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 60  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 61  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 62  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 63  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 64  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            65  
00000000  =00C00009                 66  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 67  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 68  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 69  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 70  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 71  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            72  
00000000  =00E00000                 73  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 74  DISPLAY_            EQU $0
00000000  =00E00001                 75  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            76  
00000000                            77  ; macros
00000000                            78  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            79  ; the input register is changed during the process
00000000                            80  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            81  BIN2HEX MACRO
00000000                            82      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            83      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            84      MOVE.B \1,\2
00000000                            85      ANDI.L #$F,\2
00000000                            86      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            87      ENDM
00000000                            88  
00000000                            89  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            90  ; the input register is changed during the process
00000000                            91  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            92  HEX2BIN MACRO
00000000                            93      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            94      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            95      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            96      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            97      ENDM
00000000                            98  
00000000                            99  ; send a single char to the serial port
00000000                           100  ; \1 = char to send, \2 = data register to use for status poll
00000000                           101  ; will stamp on D0 and D1 in debug mode
00000000                           102  PRINT_CHAR MACRO
00000000                           103  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           104      IFEQ DEBUG
00000000                           105          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           106          BTST #2,\2                                  ; check for space to send
00000000                           107          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           108          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           109      ENDC
00000000                           110  
00000000                           111      IFNE DEBUG
00000000                           112          MOVE.B \1,D1
00000000                           113          MOVE.L #6,D0   
00000000                           114          TRAP #15                                    ; write to terminal in simulator
00000000                           115      ENDC
00000000                           116  
00000000                           117      ENDM
00000000                           118  
00000000                           119  ; send CR,LF to the serial port
00000000                           120  ; \1 = data register to use for status poll, /2 = working address register
00000000                           121  PRINT_CRLF MACRO
00000000                           122      LEA CRLF(PC),\2
00000000                           123      PRINT_STR \2,\1
00000000                           124      ENDM
00000000                           125  
00000000                           126  ; send C-style, zero terminated string to the serial port
00000000                           127  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           128  PRINT_STR MACRO
00000000                           129  LOOP\@
00000000                           130      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           131      BEQ EXIT\@
00000000                           132      PRINT_CHAR (\1)+,\2
00000000                           133      BRA LOOP\@
00000000                           134  EXIT\@
00000000                           135      ENDM
00000000                           136    
00000000                           137  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           138  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           139  PRINT_REG MACRO
00000000                           140      LEA ox(PC),\5
00000000                           141      PRINT_STR \5,\2
00000000                           142      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           143  LOOP\@
00000000                           144      BIN2HEX \1,\3,\5
00000000                           145      PRINT_CHAR \3,\2
00000000                           146      DBEQ \4,LOOP\@
00000000                           147      ENDM
00000000                           148  
00000000                           149  ; wait for a char from the serial port
00000000                           150  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           151  ; will stamp on D0 and D1 in debug mode
00000000                           152  WAIT_CHAR MACRO
00000000                           153  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           154      IFEQ DEBUG
00000000                           155          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           156          BTST #0,\2                                  ; check for character
00000000                           157          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           158      ENDC
00000000                           159  
00000000                           160      READ_CHAR \1
00000000                           161  
00000000                           162      IFEQ DEBUG
00000000                           163          PRINT_CHAR \1,\2                            ; echo it back
00000000                           164      ENDC
00000000                           165      ENDM
00000000                           166  
00000000                           167  ; read a char from the serial port - assumes that there is one!
00000000                           168  ; \ 1= data register for read char
00000000                           169  ; will stamp on D0 and D1 in debug mode
00000000                           170  READ_CHAR MACRO
00000000                           171      IFEQ DEBUG
00000000                           172          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           173      ENDC
00000000                           174      IFNE DEBUG
00000000                           175          MOVE.L #5,D0    
00000000                           176          TRAP #15                                    ; read from keyboard in simulator
00000000                           177          MOVE.L D1,\1
00000000                           178      ENDC
00000000                           179  
00000000                           180      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           181      BEQ START
00000000                           182      ENDM
00000000                           183  
00000000                           184  
00000000                           185  ; read data from the download serial port
00000000                           186  ; \ 1= data register for read char
00000000                           187  DOWNLOAD MACRO
00000000                           188  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           189  
00000000                           190      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           193  
00000000                           194      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           195  CONTINUE\@
00000000                           196      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           197      BTST #0,\1                                      ; check for character
00000000                           198      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           199      
00000000                           200      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           201      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           202  
00000000                           203      ENDM
00000000                           204  
00000000                           205  ; unprotect the EEPROM
00000000                           206  UNPROTECT MACRO
00000000                           207      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$8080,$2AAA
00000000                           212      NOP
00000000                           213      MOVE.W #$AAAA,$2AAA
00000000                           214      NOP
00000000                           215      MOVE.W #$5555,$1554
00000000                           216      NOP
00000000                           217      MOVE.W #$2020,$2AAA
00000000                           218      ENDM
00000000                           219      
00000000                           220  ; protect the EEPROM
00000000                           221  PROTECT MACRO
00000000                           222      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           223      MOVE.W #$5555,$1554
00000000                           224      MOVE.W #$A0A0,$2AAA
00000000                           225      ENDM
00000000                           226  
00000000                           227  
00000000                           228  ; read two hex digits from the download serial port and convert to a byte
00000000                           229  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           230  DOWNLOAD_BYTE MACRO
00000000                           231      MOVE.B #2,\4
00000000                           232      WHILE.B \4 <GT> 0 DO
00000000                           233          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           234          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           235          PRINT_CHAR \2,\3
00000000                           236          HEX2BIN \2,\2,\6
00000000                           237          OR.B \2,\1
00000000                           238          SUB.B #1,\4
00000000                           239      ENDW
00000000                           240  
00000000                           241      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           242      MOVE.B \1,\2
00000000                           243      ADD.L \1,\5
00000000                           244  
00000000                           245      ENDM
00000000                           246  
00000000                           247  ; write word to EEPROM
00000000                           248  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           249  PROGRAM MACRO
00000000                           250    MOVE.W \1,\2                                      ; write the data
00000000                           251  
00000000                           252  WAIT_FOR_COMPLETE\@
00000000                           253          MOVE.W \2,\3
00000000                           254  
00000000                           255          IF.W \3 <NE> \1 THEN
00000000                           256              BRA WAIT_FOR_COMPLETE\@
00000000                           257          ENDI
00000000                           258          ENDM
00000000                           259          
00000000                           260  ; register catalogue
00000000                           261  ; D0 - used for simulator I/O
00000000                           262  ; D1 - used for simulator I/O
00000000                           263  ; D2 - read character
00000000                           264  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           265  ; D6 - working register used in R/W
00000000                           266  ; D7 - address accumulator, reset by download
00000000                           267  ; A0 - address of string to print 
00000000                           268  
00000000                           269  ; start vector
00000000= 002FFFFC                 270  STACK   DC.L $2FFFFC                                ; STACK
00000004= 00000010                 271  RESET   DC.L START                                  ; RESET
00000008= 000012CA                 272  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 000012CA                 273          DC.L BUS_ERROR_HANDLER                      ; ADDRESS ERROR
00000010                           274  
00000010                           275  ; start of program  
00000010                           276  START
00000010  13FC 0000 00E00001       277      MOVE.B #0,DISPLAY
00000018                           278  
00000018  2E7C 002FFFFC            279      MOVE.L #$2FFFFC,A7                              ; reset the stack pointer, in case we got here through a bus error
0000001E                           280  
0000001E                           281  ; reset the UART in case of warm start
0000001E  13FC 000A 00C00005       282      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000026  13FC 000A 00C00015       283      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000002E                           284      
0000002E                           285      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000002E  323C 0050                286s     MOVE.W  #$50,D1
00000032  6000 000E                287s     BRA _20000001
00000036                           288s _20000000
00000036  13C1 00C00005            289          MOVE.B D1,DUART_CRA                         ; reset everyting
0000003C  4E71                     290          NOP
0000003E                           291      ENDF
0000003E  0441 0010                292s     SUB.W   #$10,D1
00000042                           293s _20000001
00000042  B27C 0010                294s     CMP.W   #$10,D1
00000046  6CEE                     295s     BGE _20000000
00000048                           296  
00000048                           297      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000048  323C 0050                298s     MOVE.W  #$50,D1
0000004C  6000 000E                299s     BRA _20000003
00000050                           300s _20000002
00000050  13C1 00C00015            301          MOVE.B D1,DUART_CRB                         ; reset everyting
00000056  4E71                     302          NOP
00000058                           303      ENDF
00000058  0441 0010                304s     SUB.W   #$10,D1
0000005C                           305s _20000003
0000005C  B27C 0010                306s     CMP.W   #$10,D1
00000060  6CEE                     307s     BGE _20000002
00000062                           308      
00000062                           309  ;initialise UART
00000062  13FC 0000 00C00009       310      MOVE.B #$0,DUART_ACR
0000006A  13FC 0000 00C0000B       311      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000072  13FC 0000 00C0001B       312      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000007A                           313  
0000007A                           314  ; channel A
0000007A  13FC 0013 00C00001       315      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000082  13FC 0007 00C00001       316      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000008A  13FC 00CC 00C00003       317      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000092  13FC 0005 00C00005       318      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000009A                           319  
0000009A                           320  ; channel B
0000009A  13FC 0013 00C00011       321      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000000A2  13FC 0007 00C00011       322      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000000AA  13FC 00CC 00C00013       323      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000000B2  13FC 0005 00C00015       324      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000000BA                           325  
000000BA                           326m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000000BA                           327m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000BA                 TRUE      328m     IFEQ DEBUG
000000BA  1239 00C00003            329m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000C0  0801 0002                330m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000C4  67F4                     331m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000000C6  13FC 0000 00C00007       332m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000CE                           333m     ENDC
000000CE                           334m 
000000CE                 FALSE     335m     IFNE DEBUG
000000CE                           336m     ENDC
000000CE                           337m 
000000CE                           338m     ENDM
000000CE                           339m     PRINT_CHAR #0,D1
000000CE                           340m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000CE                 TRUE      341m     IFEQ DEBUG
000000CE  1239 00C00003            342m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000D4  0801 0002                343m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000D8  67F4                     344m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000000DA  13FC 0000 00C00007       345m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000E2                           346m     ENDC
000000E2                           347m 
000000E2                 FALSE     348m     IFNE DEBUG
000000E2                           349m     ENDC
000000E2                           350m 
000000E2                           351m     ENDM
000000E2                           352m     PRINT_CHAR #0,D1
000000E2                           353m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000000E2                 TRUE      354m     IFEQ DEBUG
000000E2  1239 00C00003            355m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000000E8  0801 0002                356m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000000EC  67F4                     357m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000000EE  13FC 0000 00C00007       358m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000000F6                           359m     ENDC
000000F6                           360m 
000000F6                 FALSE     361m     IFNE DEBUG
000000F6                           362m     ENDC
000000F6                           363m 
000000F6                           364m     ENDM
000000F6                           365  
000000F6  13FC 0001 00E00001       366      MOVE.B #1,DISPLAY
000000FE                           367      
000000FE                           368m     PRINT_CRLF D1,A0
000000FE  41FA 1491                369m     LEA CRLF(PC),A0
00000102                           370mm     PRINT_STR A0,D1
00000102                           371mm LOOP_5
00000102  0C10 0000                372mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000106  6700 0016                373mm     BEQ EXIT_5
0000010A                           374mmm     PRINT_CHAR (A0)+,D1
0000010A                           375mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000010A                 TRUE      376mmm     IFEQ DEBUG
0000010A  1239 00C00003            377mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000110  0801 0002                378mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000114  67F4                     379mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000116  13D8 00C00007            380mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000011C                           381mmm     ENDC
0000011C                           382mmm 
0000011C                 FALSE     383mmm     IFNE DEBUG
0000011C                           384mmm     ENDC
0000011C                           385mmm 
0000011C                           386mmm     ENDM
0000011C  60E4                     387mm     BRA LOOP_5
0000011E                           388mm EXIT_5
0000011E                           389mm     ENDM
0000011E                           390m     ENDM
0000011E  41FA 14AE                391      LEA VERSION(PC),A0
00000122                           392m     PRINT_STR A0,D3
00000122                           393m LOOP_7
00000122  0C10 0000                394m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000126  6700 0016                395m     BEQ EXIT_7
0000012A                           396mm     PRINT_CHAR (A0)+,D3
0000012A                           397mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000012A                 TRUE      398mm     IFEQ DEBUG
0000012A  1639 00C00003            399mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000130  0803 0002                400mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000134  67F4                     401mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000136  13D8 00C00007            402mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000013C                           403mm     ENDC
0000013C                           404mm 
0000013C                 FALSE     405mm     IFNE DEBUG
0000013C                           406mm     ENDC
0000013C                           407mm 
0000013C                           408mm     ENDM
0000013C  60E4                     409m     BRA LOOP_7
0000013E                           410m EXIT_7
0000013E                           411m     ENDM
0000013E                           412  
0000013E  41F9 000015EC            413      LEA END,A0
00000144  2008                     414      MOVE.L A0,D0
00000146                           415m     PRINT_REG D0,D1,D2,D3,A0
00000146  41FA 144F                416m     LEA OX(PC),A0
0000014A                           417mm     PRINT_STR A0,D1
0000014A                           418mm LOOP_10
0000014A  0C10 0000                419mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000014E  6700 0016                420mm     BEQ EXIT_10
00000152                           421mmm     PRINT_CHAR (A0)+,D1
00000152                           422mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000152                 TRUE      423mmm     IFEQ DEBUG
00000152  1239 00C00003            424mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000158  0801 0002                425mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000015C  67F4                     426mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
0000015E  13D8 00C00007            427mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000164                           428mmm     ENDC
00000164                           429mmm 
00000164                 FALSE     430mmm     IFNE DEBUG
00000164                           431mmm     ENDC
00000164                           432mmm 
00000164                           433mmm     ENDM
00000164  60E4                     434mm     BRA LOOP_10
00000166                           435mm EXIT_10
00000166                           436mm     ENDM
00000166  7607                     437m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000168                           438m LOOP_9
00000168                           439mm     BIN2HEX D0,D2,A0
00000168  41FA 13EC                440mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000016C  E998                     441mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000016E  1400                     442mm     MOVE.B D0,D2
00000170  0282 0000000F            443mm     ANDI.L #$F,D2
00000176  1430 2000                444mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000017A                           445mm     ENDM
0000017A                           446mm     PRINT_CHAR D2,D1
0000017A                           447mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000017A                 TRUE      448mm     IFEQ DEBUG
0000017A  1239 00C00003            449mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000180  0801 0002                450mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000184  67F4                     451mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000186  13C2 00C00007            452mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000018C                           453mm     ENDC
0000018C                           454mm 
0000018C                 FALSE     455mm     IFNE DEBUG
0000018C                           456mm     ENDC
0000018C                           457mm 
0000018C                           458mm     ENDM
0000018C  57CB FFDA                459m     DBEQ D3,LOOP_9
00000190                           460m     ENDM
00000190                           461m     PRINT_CRLF D1,A0
00000190  41FA 13FF                462m     LEA CRLF(PC),A0
00000194                           463mm     PRINT_STR A0,D1
00000194                           464mm LOOP_15
00000194  0C10 0000                465mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000198  6700 0016                466mm     BEQ EXIT_15
0000019C                           467mmm     PRINT_CHAR (A0)+,D1
0000019C                           468mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000019C                 TRUE      469mmm     IFEQ DEBUG
0000019C  1239 00C00003            470mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001A2  0801 0002                471mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001A6  67F4                     472mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000001A8  13D8 00C00007            473mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001AE                           474mmm     ENDC
000001AE                           475mmm 
000001AE                 FALSE     476mmm     IFNE DEBUG
000001AE                           477mmm     ENDC
000001AE                           478mmm 
000001AE                           479mmm     ENDM
000001AE  60E4                     480mm     BRA LOOP_15
000001B0                           481mm EXIT_15
000001B0                           482mm     ENDM
000001B0                           483m     ENDM
000001B0                           484  
000001B0  41FA 121A                485      LEA HELPPROMPT(PC),A0
000001B4                           486m     PRINT_STR A0,D3
000001B4                           487m LOOP_17
000001B4  0C10 0000                488m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001B8  6700 0016                489m     BEQ EXIT_17
000001BC                           490mm     PRINT_CHAR (A0)+,D3
000001BC                           491mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001BC                 TRUE      492mm     IFEQ DEBUG
000001BC  1639 00C00003            493mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001C2  0803 0002                494mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001C6  67F4                     495mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000001C8  13D8 00C00007            496mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001CE                           497mm     ENDC
000001CE                           498mm 
000001CE                 FALSE     499mm     IFNE DEBUG
000001CE                           500mm     ENDC
000001CE                           501mm 
000001CE                           502mm     ENDM
000001CE  60E4                     503m     BRA LOOP_17
000001D0                           504m EXIT_17
000001D0                           505m     ENDM
000001D0                           506  
000001D0                           507m     PRINT_CRLF D3,A0
000001D0  41FA 13BF                508m     LEA CRLF(PC),A0
000001D4                           509mm     PRINT_STR A0,D3
000001D4                           510mm LOOP_20
000001D4  0C10 0000                511mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000001D8  6700 0016                512mm     BEQ EXIT_20
000001DC                           513mmm     PRINT_CHAR (A0)+,D3
000001DC                           514mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001DC                 TRUE      515mmm     IFEQ DEBUG
000001DC  1639 00C00003            516mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000001E2  0803 0002                517mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000001E6  67F4                     518mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
000001E8  13D8 00C00007            519mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000001EE                           520mmm     ENDC
000001EE                           521mmm 
000001EE                 FALSE     522mmm     IFNE DEBUG
000001EE                           523mmm     ENDC
000001EE                           524mmm 
000001EE                           525mmm     ENDM
000001EE  60E4                     526mm     BRA LOOP_20
000001F0                           527mm EXIT_20
000001F0                           528mm     ENDM
000001F0                           529m     ENDM
000001F0                           530  
000001F0  7E00                     531      MOVE.L #0,D7                                    ; address accumulator
000001F2                           532  
000001F2  13FC 0002 00E00001       533      MOVE.B #2,DISPLAY
000001FA                           534  MAIN_LOOP
000001FA  41FA 1398                535      LEA PROMPT(PC),A0
000001FE                           536m     PRINT_STR A0,D3
000001FE                           537m LOOP_22
000001FE  0C10 0000                538m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000202  6700 0016                539m     BEQ EXIT_22
00000206                           540mm     PRINT_CHAR (A0)+,D3
00000206                           541mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000206                 TRUE      542mm     IFEQ DEBUG
00000206  1639 00C00003            543mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000020C  0803 0002                544mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000210  67F4                     545mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000212  13D8 00C00007            546mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000218                           547mm     ENDC
00000218                           548mm 
00000218                 FALSE     549mm     IFNE DEBUG
00000218                           550mm     ENDC
00000218                           551mm 
00000218                           552mm     ENDM
00000218  60E4                     553m     BRA LOOP_22
0000021A                           554m EXIT_22
0000021A                           555m     ENDM
0000021A                           556  
0000021A                           557  GET_INPUT
0000021A                           558m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000021A                           559m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000021A                 TRUE      560m     IFEQ DEBUG
0000021A  1639 00C00003            561m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000220  0803 0000                562m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000224  67F4                     563m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000226                           564m     ENDC
00000226                           565m 
00000226                           566mm     READ_CHAR D2
00000226                 TRUE      567mm     IFEQ DEBUG
00000226  1439 00C00007            568mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000022C                           569mm     ENDC
0000022C                 FALSE     570mm     IFNE DEBUG
0000022C                           571mm     ENDC
0000022C                           572mm 
0000022C  B43C 001B                573mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000230  6700 FDDE                574mm     BEQ START
00000234                           575mm     ENDM
00000234                           576m 
00000234                 TRUE      577m     IFEQ DEBUG
00000234                           578mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000234                           579mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000234                 TRUE      580mm     IFEQ DEBUG
00000234  1639 00C00003            581mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000023A  0803 0002                582mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000023E  67F4                     583mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000240  13C2 00C00007            584mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000246                           585mm     ENDC
00000246                           586mm 
00000246                 FALSE     587mm     IFNE DEBUG
00000246                           588mm     ENDC
00000246                           589mm 
00000246                           590mm     ENDM
00000246                           591m     ENDC
00000246                           592m     ENDM
00000246                           593  
00000246                           594      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000246  B43C 0030                595s     CMP.B   #'0',D2
0000024A  6D00 000E                596s     BLT _00000000
0000024E  B43C 0039                597s     CMP.B   #'9',D2
00000252  6E00 0006                598s     BGT _00000000
00000256  6000 1054                599          BRA HEX_DIGIT
0000025A                           600      ENDI
0000025A                           601s _00000000
0000025A                           602      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000025A  B43C 0041                603s     CMP.B   #'A',D2
0000025E  6D00 000E                604s     BLT _00000001
00000262  B43C 0046                605s     CMP.B   #'F',D2
00000266  6E00 0006                606s     BGT _00000001
0000026A  6000 1040                607          BRA HEX_DIGIT
0000026E                           608      ENDI
0000026E                           609s _00000001
0000026E                           610  
0000026E  B43C 0077                611      CMP.B #'w',D2
00000272  6700 019A                612      BEQ W
00000276                           613  
00000276  B43C 006C                614      CMP.B #'l',D2
0000027A  6700 0A28                615      BEQ L 
0000027E                           616  
0000027E  B43C 0070                617      CMP.B #'p',D2
00000282  6700 0CB6                618      BEQ P
00000286                           619  
00000286  B43C 006D                620      CMP.B #'m',D2
0000028A  6700 0E6C                621      BEQ M
0000028E                           622  
0000028E                           623m     PRINT_CRLF D3,A0
0000028E  41FA 1301                624m     LEA CRLF(PC),A0
00000292                           625mm     PRINT_STR A0,D3
00000292                           626mm LOOP_28
00000292  0C10 0000                627mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000296  6700 0016                628mm     BEQ EXIT_28
0000029A                           629mmm     PRINT_CHAR (A0)+,D3
0000029A                           630mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029A                 TRUE      631mmm     IFEQ DEBUG
0000029A  1639 00C00003            632mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002A0  0803 0002                633mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002A4  67F4                     634mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000002A6  13D8 00C00007            635mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002AC                           636mmm     ENDC
000002AC                           637mmm 
000002AC                 FALSE     638mmm     IFNE DEBUG
000002AC                           639mmm     ENDC
000002AC                           640mmm 
000002AC                           641mmm     ENDM
000002AC  60E4                     642mm     BRA LOOP_28
000002AE                           643mm EXIT_28
000002AE                           644mm     ENDM
000002AE                           645m     ENDM
000002AE                           646   
000002AE  B43C 003F                647      CMP.B #'?',D2
000002B2  6700 0056                648      BEQ H
000002B6                           649   
000002B6  B43C 0076                650      CMP.B #'v',D2
000002BA  6700 0056                651      BEQ V
000002BE                           652      
000002BE  B43C 0072                653      CMP.B #'r',D2
000002C2  6700 0072                654      BEQ R
000002C6                           655  
000002C6  B43C 0073                656      CMP.B #'s',D2
000002CA  6700 01B6                657      BEQ S
000002CE                           658  
000002CE  B43C 0067                659      CMP.B #'g',D2
000002D2  6700 08DA                660      BEQ G   
000002D6                           661  
000002D6  B43C 007A                662      CMP.B #'z',D2
000002DA  6700 08D8                663      BEQ Z   
000002DE                           664  
000002DE  B43C 0078                665      CMP.B #'x',D2
000002E2  6700 0EAC                666      BEQ X
000002E6                           667  
000002E6  41FA 120A                668      LEA HUH(PC),A0
000002EA                           669m     PRINT_STR A0,D3
000002EA                           670m LOOP_30
000002EA  0C10 0000                671m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002EE  6700 0016                672m     BEQ EXIT_30
000002F2                           673mm     PRINT_CHAR (A0)+,D3
000002F2                           674mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002F2                 TRUE      675mm     IFEQ DEBUG
000002F2  1639 00C00003            676mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002F8  0803 0002                677mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002FC  67F4                     678mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
000002FE  13D8 00C00007            679mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000304                           680mm     ENDC
00000304                           681mm 
00000304                 FALSE     682mm     IFNE DEBUG
00000304                           683mm     ENDC
00000304                           684mm 
00000304                           685mm     ENDM
00000304  60E4                     686m     BRA LOOP_30
00000306                           687m EXIT_30
00000306                           688m     ENDM
00000306                           689  
00000306  6000 FEF2                690      BRA MAIN_LOOP
0000030A                           691  
0000030A                           692  ; commands
0000030A                           693  H
0000030A  41FA 10D3                694      LEA HELP(PC),A0
0000030E  6000 0006                695      BRA PRINTSTR
00000312                           696  
00000312                           697  V
00000312  41FA 12BA                698      LEA VERSION(PC),A0
00000316                           699  PRINTSTR
00000316                           700m     PRINT_STR A0,D3    
00000316                           701m LOOP_32
00000316  0C10 0000                702m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000031A  6700 0016                703m     BEQ EXIT_32
0000031E                           704mm     PRINT_CHAR (A0)+,D3
0000031E                           705mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000031E                 TRUE      706mm     IFEQ DEBUG
0000031E  1639 00C00003            707mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000324  0803 0002                708mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000328  67F4                     709mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000032A  13D8 00C00007            710mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000330                           711mm     ENDC
00000330                           712mm 
00000330                 FALSE     713mm     IFNE DEBUG
00000330                           714mm     ENDC
00000330                           715mm 
00000330                           716mm     ENDM
00000330  60E4                     717m     BRA LOOP_32
00000332                           718m EXIT_32
00000332                           719m     ENDM
00000332  6000 FEC6                720      BRA MAIN_LOOP
00000336                           721  
00000336                           722  R
00000336  2047                     723      MOVE.L D7,A0                                    ; address accumulator -> address register
00000338  7E00                     724      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000033A  2410                     725      MOVE.L (A0),D2                                  ; read the memory and print it
0000033C                           726m     PRINT_REG D2,D3,D4,D5,A0
0000033C  41FA 1259                727m     LEA OX(PC),A0
00000340                           728mm     PRINT_STR A0,D3
00000340                           729mm LOOP_35
00000340  0C10 0000                730mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000344  6700 0016                731mm     BEQ EXIT_35
00000348                           732mmm     PRINT_CHAR (A0)+,D3
00000348                           733mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000348                 TRUE      734mmm     IFEQ DEBUG
00000348  1639 00C00003            735mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000034E  0803 0002                736mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000352  67F4                     737mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
00000354  13D8 00C00007            738mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000035A                           739mmm     ENDC
0000035A                           740mmm 
0000035A                 FALSE     741mmm     IFNE DEBUG
0000035A                           742mmm     ENDC
0000035A                           743mmm 
0000035A                           744mmm     ENDM
0000035A  60E4                     745mm     BRA LOOP_35
0000035C                           746mm EXIT_35
0000035C                           747mm     ENDM
0000035C  7A07                     748m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000035E                           749m LOOP_34
0000035E                           750mm     BIN2HEX D2,D4,A0
0000035E  41FA 11F6                751mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000362  E99A                     752mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000364  1802                     753mm     MOVE.B D2,D4
00000366  0284 0000000F            754mm     ANDI.L #$F,D4
0000036C  1830 4000                755mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000370                           756mm     ENDM
00000370                           757mm     PRINT_CHAR D4,D3
00000370                           758mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000370                 TRUE      759mm     IFEQ DEBUG
00000370  1639 00C00003            760mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000376  0803 0002                761mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000037A  67F4                     762mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
0000037C  13C4 00C00007            763mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000382                           764mm     ENDC
00000382                           765mm 
00000382                 FALSE     766mm     IFNE DEBUG
00000382                           767mm     ENDC
00000382                           768mm 
00000382                           769mm     ENDM
00000382  57CD FFDA                770m     DBEQ D5,LOOP_34
00000386                           771m     ENDM
00000386                           772      
00000386                           773m     PRINT_CHAR #32,D3
00000386                           774m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000386                 TRUE      775m     IFEQ DEBUG
00000386  1639 00C00003            776m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000038C  0803 0002                777m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000390  67F4                     778m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000392  13FC 0020 00C00007       779m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000039A                           780m     ENDC
0000039A                           781m 
0000039A                 FALSE     782m     IFNE DEBUG
0000039A                           783m     ENDC
0000039A                           784m 
0000039A                           785m     ENDM
0000039A                           786  
0000039A  E19A                     787      ROL.L #8,D2
0000039C                           788m     PRINT_CHAR D2,D3
0000039C                           789m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000039C                 TRUE      790m     IFEQ DEBUG
0000039C  1639 00C00003            791m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003A2  0803 0002                792m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003A6  67F4                     793m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000003A8  13C2 00C00007            794m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003AE                           795m     ENDC
000003AE                           796m 
000003AE                 FALSE     797m     IFNE DEBUG
000003AE                           798m     ENDC
000003AE                           799m 
000003AE                           800m     ENDM
000003AE  E19A                     801      ROL.L #8,D2
000003B0                           802m     PRINT_CHAR D2,D3
000003B0                           803m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B0                 TRUE      804m     IFEQ DEBUG
000003B0  1639 00C00003            805m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003B6  0803 0002                806m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003BA  67F4                     807m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000003BC  13C2 00C00007            808m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003C2                           809m     ENDC
000003C2                           810m 
000003C2                 FALSE     811m     IFNE DEBUG
000003C2                           812m     ENDC
000003C2                           813m 
000003C2                           814m     ENDM
000003C2  E19A                     815      ROL.L #8,D2
000003C4                           816m     PRINT_CHAR D2,D3
000003C4                           817m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003C4                 TRUE      818m     IFEQ DEBUG
000003C4  1639 00C00003            819m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003CA  0803 0002                820m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003CE  67F4                     821m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000003D0  13C2 00C00007            822m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003D6                           823m     ENDC
000003D6                           824m 
000003D6                 FALSE     825m     IFNE DEBUG
000003D6                           826m     ENDC
000003D6                           827m 
000003D6                           828m     ENDM
000003D6  E19A                     829      ROL.L #8,D2
000003D8                           830m     PRINT_CHAR D2,D3
000003D8                           831m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003D8                 TRUE      832m     IFEQ DEBUG
000003D8  1639 00C00003            833m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003DE  0803 0002                834m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E2  67F4                     835m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
000003E4  13C2 00C00007            836m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000003EA                           837m     ENDC
000003EA                           838m 
000003EA                 FALSE     839m     IFNE DEBUG
000003EA                           840m     ENDC
000003EA                           841m 
000003EA                           842m     ENDM
000003EA                           843  
000003EA                           844m     PRINT_CRLF D3,A0
000003EA  41FA 11A5                845m     LEA CRLF(PC),A0
000003EE                           846mm     PRINT_STR A0,D3
000003EE                           847mm LOOP_45
000003EE  0C10 0000                848mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003F2  6700 0016                849mm     BEQ EXIT_45
000003F6                           850mmm     PRINT_CHAR (A0)+,D3
000003F6                           851mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003F6                 TRUE      852mmm     IFEQ DEBUG
000003F6  1639 00C00003            853mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003FC  0803 0002                854mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000400  67F4                     855mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000402  13D8 00C00007            856mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000408                           857mmm     ENDC
00000408                           858mmm 
00000408                 FALSE     859mmm     IFNE DEBUG
00000408                           860mmm     ENDC
00000408                           861mmm 
00000408                           862mmm     ENDM
00000408  60E4                     863mm     BRA LOOP_45
0000040A                           864mm EXIT_45
0000040A                           865mm     ENDM
0000040A                           866m     ENDM
0000040A                           867      
0000040A  6000 FDEE                868      BRA MAIN_LOOP
0000040E                           869  
0000040E                           870  W
0000040E  3C3C 0007                871      MOVE #7,D6                                      ; 7 bytes left to read
00000412                           872      
00000412                           873  READ_DATA_TO_POKE
00000412  E98D                     874      LSL.L #4,D5                                     ; make what we have so far more significant
00000414                           875m     WAIT_CHAR D2,D3                                 ; next character -> D2
00000414                           876m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000414                 TRUE      877m     IFEQ DEBUG
00000414  1639 00C00003            878m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000041A  0803 0000                879m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000041E  67F4                     880m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000420                           881m     ENDC
00000420                           882m 
00000420                           883mm     READ_CHAR D2
00000420                 TRUE      884mm     IFEQ DEBUG
00000420  1439 00C00007            885mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000426                           886mm     ENDC
00000426                 FALSE     887mm     IFNE DEBUG
00000426                           888mm     ENDC
00000426                           889mm 
00000426  B43C 001B                890mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000042A  6700 FBE4                891mm     BEQ START
0000042E                           892mm     ENDM
0000042E                           893m 
0000042E                 TRUE      894m     IFEQ DEBUG
0000042E                           895mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000042E                           896mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000042E                 TRUE      897mm     IFEQ DEBUG
0000042E  1639 00C00003            898mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000434  0803 0002                899mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000438  67F4                     900mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
0000043A  13C2 00C00007            901mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000440                           902mm     ENDC
00000440                           903mm 
00000440                 FALSE     904mm     IFNE DEBUG
00000440                           905mm     ENDC
00000440                           906mm 
00000440                           907mm     ENDM
00000440                           908m     ENDC
00000440                           909m     ENDM
00000440                           910m     HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000440  41FA 1124                911m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000444  0402 0030                912m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000448  C4BC 000000FF            913m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000044E  1430 2000                914m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000452                           915m     ENDM
00000452  8A02                     916      OR.B D2,D5
00000454  57CE FFBC                917      DBEQ D6,READ_DATA_TO_POKE
00000458                           918      
00000458  2047                     919      MOVE.L D7,A0                                    ; address accumulator -> address register
0000045A  7E00                     920      MOVE.L #0,D7                                    ; clear the now used address accumulator
0000045C                           921      
0000045C  2085                     922      MOVE.L D5,(A0)                                  ; write the data
0000045E                           923  
0000045E                           924m     PRINT_CRLF D3,A0
0000045E  41FA 1131                925m     LEA CRLF(PC),A0
00000462                           926mm     PRINT_STR A0,D3
00000462                           927mm LOOP_52
00000462  0C10 0000                928mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000466  6700 0016                929mm     BEQ EXIT_52
0000046A                           930mmm     PRINT_CHAR (A0)+,D3
0000046A                           931mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000046A                 TRUE      932mmm     IFEQ DEBUG
0000046A  1639 00C00003            933mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000470  0803 0002                934mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000474  67F4                     935mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
00000476  13D8 00C00007            936mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047C                           937mmm     ENDC
0000047C                           938mmm 
0000047C                 FALSE     939mmm     IFNE DEBUG
0000047C                           940mmm     ENDC
0000047C                           941mmm 
0000047C                           942mmm     ENDM
0000047C  60E4                     943mm     BRA LOOP_52
0000047E                           944mm EXIT_52
0000047E                           945mm     ENDM
0000047E                           946m     ENDM
0000047E  6000 FD7A                947      BRA MAIN_LOOP
00000482                           948  
00000482                           949  ; register map for S
00000482                           950  ; A0 - start address
00000482                           951  ; A1 - offset
00000482                           952  ; A2 - next address to write
00000482                           953  ; A3 - next location (jmp)
00000482                           954  ; A4 - Working Address Register
00000482                           955  ; D0 - record count
00000482                           956  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000482                           957  ; D2 - checksum
00000482                           958  ; D3 - data byte count
00000482                           959  ; D4 - read address, moved into A2
00000482                           960  ; D5 - temp
00000482                           961  ; D6 - temp
00000482                           962  ; D7 - temp
00000482                           963  S
00000482  2078 0000                964      MOVE.L 0,A0                                     ; start address -> A0
00000486  2247                     965      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000488                           966      
00000488  7000                     967      MOVE.L #0,D0                                    ; count of records read -> D0
0000048A                           968          
0000048A                           969  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000048A                           970m     DOWNLOAD D1
0000048A                           971m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000048A                           972m 
0000048A  1239 00C00003            973m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000490  0801 0000                974m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000494  6700 0010                975m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000498                           976m 
00000498                           977mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000498                 TRUE      978mm     IFEQ DEBUG
00000498  1239 00C00007            979mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
0000049E                           980mm     ENDC
0000049E                 FALSE     981mm     IFNE DEBUG
0000049E                           982mm     ENDC
0000049E                           983mm 
0000049E  B23C 001B                984mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000004A2  6700 FB6C                985mm     BEQ START
000004A6                           986mm     ENDM
000004A6                           987m CONTINUE_54
000004A6  1239 00C00013            988m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000004AC  0801 0000                989m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000004B0  67D8                     990m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000004B2                           991m     
000004B2  1239 00C00017            992m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000004B8  13C1 00E00001            993m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000004BE                           994m 
000004BE                           995m     ENDM
000004BE  B23C 0053                996      CMP.B #'S',D1                                   ; found S?
000004C2  66C6                     997      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000004C4                           998      
000004C4                           999m     PRINT_CHAR #'S',D5                              ; print the S
000004C4                          1000m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004C4                 TRUE     1001m     IFEQ DEBUG
000004C4  1A39 00C00003           1002m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000004CA  0805 0002               1003m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000004CE  67F4                    1004m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
000004D0  13FC 0053 00C00007      1005m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
000004D8                          1006m     ENDC
000004D8                          1007m 
000004D8                 FALSE    1008m     IFNE DEBUG
000004D8                          1009m     ENDC
000004D8                          1010m 
000004D8                          1011m     ENDM
000004D8  5280                    1012      ADD.L #1,D0                                     ; read another S record, increment count
000004DA                          1013      
000004DA                          1014m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000004DA                          1015m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DA                          1016m 
000004DA  1239 00C00003           1017m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000004E0  0801 0000               1018m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000004E4  6700 0010               1019m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
000004E8                          1020m 
000004E8                          1021mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000004E8                 TRUE     1022mm     IFEQ DEBUG
000004E8  1239 00C00007           1023mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000004EE                          1024mm     ENDC
000004EE                 FALSE    1025mm     IFNE DEBUG
000004EE                          1026mm     ENDC
000004EE                          1027mm 
000004EE  B23C 001B               1028mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000004F2  6700 FB1C               1029mm     BEQ START
000004F6                          1030mm     ENDM
000004F6                          1031m CONTINUE_57
000004F6  1239 00C00013           1032m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000004FC  0801 0000               1033m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000500  67D8                    1034m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
00000502                          1035m     
00000502  1239 00C00017           1036m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000508  13C1 00E00001           1037m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
0000050E                          1038m 
0000050E                          1039m     ENDM
0000050E                          1040m     PRINT_CHAR D1,D5
0000050E                          1041m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050E                 TRUE     1042m     IFEQ DEBUG
0000050E  1A39 00C00003           1043m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000514  0805 0002               1044m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000518  67F4                    1045m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
0000051A  13C1 00C00007           1046m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000520                          1047m     ENDC
00000520                          1048m 
00000520                 FALSE    1049m     IFNE DEBUG
00000520                          1050m     ENDC
00000520                          1051m 
00000520                          1052m     ENDM
00000520                          1053  
00000520  7400                    1054      MOVE.L #0,D2                                    ; clear the checksum
00000522                          1055  
00000522                          1056m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000522  1E3C 0002               1057m     MOVE.B #2,D7
00000526                          1058m     WHILE.B D7 <GT> 0 DO
00000526                          1059ms _10000000
00000526  BE38 0000               1060ms     CMP.B   0,D7
0000052A  6F00 0062               1061ms     BLE _10000001
0000052E  E98B                    1062m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000530                          1063mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000530                          1064mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000530                          1065mm 
00000530  1A39 00C00003           1066mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000536  0805 0000               1067mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000053A  6700 0010               1068mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000053E                          1069mm 
0000053E                          1070mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000053E                 TRUE     1071mmm     IFEQ DEBUG
0000053E  1A39 00C00007           1072mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000544                          1073mmm     ENDC
00000544                 FALSE    1074mmm     IFNE DEBUG
00000544                          1075mmm     ENDC
00000544                          1076mmm 
00000544  BA3C 001B               1077mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000548  6700 FAC6               1078mmm     BEQ START
0000054C                          1079mmm     ENDM
0000054C                          1080mm CONTINUE_61
0000054C  1A39 00C00013           1081mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000552  0805 0000               1082mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000556  67D8                    1083mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000558                          1084mm     
00000558  1A39 00C00017           1085mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000055E  13C5 00E00001           1086mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000564                          1087mm 
00000564                          1088mm     ENDM
00000564                          1089mm         PRINT_CHAR D5,D6
00000564                          1090mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                 TRUE     1091mm     IFEQ DEBUG
00000564  1C39 00C00003           1092mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000056A  0806 0002               1093mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000056E  67F4                    1094mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
00000570  13C5 00C00007           1095mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000576                          1096mm     ENDC
00000576                          1097mm 
00000576                 FALSE    1098mm     IFNE DEBUG
00000576                          1099mm     ENDC
00000576                          1100mm 
00000576                          1101mm     ENDM
00000576                          1102mm         HEX2BIN D5,D5,A4
00000576  49FA 0FEE               1103mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000057A  0405 0030               1104mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057E  CABC 000000FF           1105mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000584  1A34 5000               1106mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000588                          1107mm     ENDM
00000588  8605                    1108m         OR.B D5,D3
0000058A  5307                    1109m         SUB.B #1,D7
0000058C                          1110m     ENDW
0000058C  6098                    1111ms     BRA _10000000
0000058E                          1112ms _10000001
0000058E                          1113m 
0000058E  7A00                    1114m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000590  1A03                    1115m     MOVE.B D3,D5
00000592  D483                    1116m     ADD.L D3,D2
00000594                          1117m 
00000594                          1118m     ENDM
00000594                          1119  
00000594                          1120      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000594  B23C 0030               1121s     CMP.B   #'0',D1
00000598  6600 002A               1122s     BNE.L   _00000002
0000059C                          1123m         PRINT_CRLF D5,A4
0000059C  49FA 0FF3               1124m     LEA CRLF(PC),A4
000005A0                          1125mm     PRINT_STR A4,D5
000005A0                          1126mm LOOP_66
000005A0  0C14 0000               1127mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000005A4  6700 0016               1128mm     BEQ EXIT_66
000005A8                          1129mmm     PRINT_CHAR (A4)+,D5
000005A8                          1130mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A8                 TRUE     1131mmm     IFEQ DEBUG
000005A8  1A39 00C00003           1132mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000005AE  0805 0002               1133mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000005B2  67F4                    1134mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000005B4  13DC 00C00007           1135mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005BA                          1136mmm     ENDC
000005BA                          1137mmm 
000005BA                 FALSE    1138mmm     IFNE DEBUG
000005BA                          1139mmm     ENDC
000005BA                          1140mmm 
000005BA                          1141mmm     ENDM
000005BA  60E4                    1142mm     BRA LOOP_66
000005BC                          1143mm EXIT_66
000005BC                          1144mm     ENDM
000005BC                          1145m     ENDM
000005BC  6000 FECC               1146          BRA WAIT_FOR_SRECORD
000005C0                          1147      ELSE
000005C0  6000 03DE               1148s     BRA _00000003
000005C4                          1149s _00000002
000005C4                          1150          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000005C4  B23C 0031               1151s     CMP.B   #'1',D1
000005C8  6708                    1152s     BEQ.S   _00000004
000005CA  B23C 0032               1153s     CMP.B   #'2',D1
000005CE  6600 01F0               1154s     BNE.L   _00000005
000005D2                          1155s _00000004
000005D2  5783                    1156              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000005D4                          1157  
000005D4  7800                    1158              MOVE.L #0,D4                            ; read two bytes of address
000005D6                          1159m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000005D6  1E3C 0002               1160m     MOVE.B #2,D7
000005DA                          1161m     WHILE.B D7 <GT> 0 DO
000005DA                          1162ms _10000002
000005DA  BE38 0000               1163ms     CMP.B   0,D7
000005DE  6F00 0062               1164ms     BLE _10000003
000005E2  E98C                    1165m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000005E4                          1166mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000005E4                          1167mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E4                          1168mm 
000005E4  1A39 00C00003           1169mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000005EA  0805 0000               1170mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000005EE  6700 0010               1171mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
000005F2                          1172mm 
000005F2                          1173mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000005F2                 TRUE     1174mmm     IFEQ DEBUG
000005F2  1A39 00C00007           1175mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000005F8                          1176mmm     ENDC
000005F8                 FALSE    1177mmm     IFNE DEBUG
000005F8                          1178mmm     ENDC
000005F8                          1179mmm 
000005F8  BA3C 001B               1180mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000005FC  6700 FA12               1181mmm     BEQ START
00000600                          1182mmm     ENDM
00000600                          1183mm CONTINUE_69
00000600  1A39 00C00013           1184mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000606  0805 0000               1185mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000060A  67D8                    1186mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
0000060C                          1187mm     
0000060C  1A39 00C00017           1188mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000612  13C5 00E00001           1189mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000618                          1190mm 
00000618                          1191mm     ENDM
00000618                          1192mm         PRINT_CHAR D5,D6
00000618                          1193mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000618                 TRUE     1194mm     IFEQ DEBUG
00000618  1C39 00C00003           1195mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000061E  0806 0002               1196mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000622  67F4                    1197mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
00000624  13C5 00C00007           1198mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000062A                          1199mm     ENDC
0000062A                          1200mm 
0000062A                 FALSE    1201mm     IFNE DEBUG
0000062A                          1202mm     ENDC
0000062A                          1203mm 
0000062A                          1204mm     ENDM
0000062A                          1205mm         HEX2BIN D5,D5,A4
0000062A  49FA 0F3A               1206mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000062E  0405 0030               1207mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000632  CABC 000000FF           1208mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000638  1A34 5000               1209mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000063C                          1210mm     ENDM
0000063C  8805                    1211m         OR.B D5,D4
0000063E  5307                    1212m         SUB.B #1,D7
00000640                          1213m     ENDW
00000640  6098                    1214ms     BRA _10000002
00000642                          1215ms _10000003
00000642                          1216m 
00000642  7A00                    1217m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000644  1A04                    1218m     MOVE.B D4,D5
00000646  D484                    1219m     ADD.L D4,D2
00000648                          1220m 
00000648                          1221m     ENDM
00000648                          1222m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000648  1E3C 0002               1223m     MOVE.B #2,D7
0000064C                          1224m     WHILE.B D7 <GT> 0 DO
0000064C                          1225ms _10000004
0000064C  BE38 0000               1226ms     CMP.B   0,D7
00000650  6F00 0062               1227ms     BLE _10000005
00000654  E98C                    1228m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000656                          1229mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000656                          1230mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000656                          1231mm 
00000656  1A39 00C00003           1232mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000065C  0805 0000               1233mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000660  6700 0010               1234mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
00000664                          1235mm 
00000664                          1236mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000664                 TRUE     1237mmm     IFEQ DEBUG
00000664  1A39 00C00007           1238mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000066A                          1239mmm     ENDC
0000066A                 FALSE    1240mmm     IFNE DEBUG
0000066A                          1241mmm     ENDC
0000066A                          1242mmm 
0000066A  BA3C 001B               1243mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000066E  6700 F9A0               1244mmm     BEQ START
00000672                          1245mmm     ENDM
00000672                          1246mm CONTINUE_74
00000672  1A39 00C00013           1247mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000678  0805 0000               1248mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000067C  67D8                    1249mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
0000067E                          1250mm     
0000067E  1A39 00C00017           1251mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000684  13C5 00E00001           1252mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000068A                          1253mm 
0000068A                          1254mm     ENDM
0000068A                          1255mm         PRINT_CHAR D5,D6
0000068A                          1256mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000068A                 TRUE     1257mm     IFEQ DEBUG
0000068A  1C39 00C00003           1258mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000690  0806 0002               1259mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000694  67F4                    1260mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
00000696  13C5 00C00007           1261mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000069C                          1262mm     ENDC
0000069C                          1263mm 
0000069C                 FALSE    1264mm     IFNE DEBUG
0000069C                          1265mm     ENDC
0000069C                          1266mm 
0000069C                          1267mm     ENDM
0000069C                          1268mm         HEX2BIN D5,D5,A4
0000069C  49FA 0EC8               1269mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006A0  0405 0030               1270mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006A4  CABC 000000FF           1271mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006AA  1A34 5000               1272mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006AE                          1273mm     ENDM
000006AE  8805                    1274m         OR.B D5,D4
000006B0  5307                    1275m         SUB.B #1,D7
000006B2                          1276m     ENDW
000006B2  6098                    1277ms     BRA _10000004
000006B4                          1278ms _10000005
000006B4                          1279m 
000006B4  7A00                    1280m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006B6  1A04                    1281m     MOVE.B D4,D5
000006B8  D484                    1282m     ADD.L D4,D2
000006BA                          1283m 
000006BA                          1284m     ENDM
000006BA                          1285  
000006BA                          1286              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000006BA  B23C 0032               1287s     CMP.B   #'2',D1
000006BE  6600 0076               1288s     BNE.L   _00000006
000006C2  5383                    1289                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000006C4                          1290m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000006C4  1E3C 0002               1291m     MOVE.B #2,D7
000006C8                          1292m     WHILE.B D7 <GT> 0 DO
000006C8                          1293ms _10000006
000006C8  BE38 0000               1294ms     CMP.B   0,D7
000006CC  6F00 0062               1295ms     BLE _10000007
000006D0  E98C                    1296m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006D2                          1297mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006D2                          1298mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006D2                          1299mm 
000006D2  1A39 00C00003           1300mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006D8  0805 0000               1301mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006DC  6700 0010               1302mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
000006E0                          1303mm 
000006E0                          1304mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006E0                 TRUE     1305mmm     IFEQ DEBUG
000006E0  1A39 00C00007           1306mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000006E6                          1307mmm     ENDC
000006E6                 FALSE    1308mmm     IFNE DEBUG
000006E6                          1309mmm     ENDC
000006E6                          1310mmm 
000006E6  BA3C 001B               1311mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000006EA  6700 F924               1312mmm     BEQ START
000006EE                          1313mmm     ENDM
000006EE                          1314mm CONTINUE_79
000006EE  1A39 00C00013           1315mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006F4  0805 0000               1316mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006F8  67D8                    1317mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
000006FA                          1318mm     
000006FA  1A39 00C00017           1319mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000700  13C5 00E00001           1320mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000706                          1321mm 
00000706                          1322mm     ENDM
00000706                          1323mm         PRINT_CHAR D5,D6
00000706                          1324mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000706                 TRUE     1325mm     IFEQ DEBUG
00000706  1C39 00C00003           1326mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000070C  0806 0002               1327mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000710  67F4                    1328mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
00000712  13C5 00C00007           1329mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000718                          1330mm     ENDC
00000718                          1331mm 
00000718                 FALSE    1332mm     IFNE DEBUG
00000718                          1333mm     ENDC
00000718                          1334mm 
00000718                          1335mm     ENDM
00000718                          1336mm         HEX2BIN D5,D5,A4
00000718  49FA 0E4C               1337mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000071C  0405 0030               1338mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000720  CABC 000000FF           1339mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000726  1A34 5000               1340mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000072A                          1341mm     ENDM
0000072A  8805                    1342m         OR.B D5,D4
0000072C  5307                    1343m         SUB.B #1,D7
0000072E                          1344m     ENDW
0000072E  6098                    1345ms     BRA _10000006
00000730                          1346ms _10000007
00000730                          1347m 
00000730  7A00                    1348m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000732  1A04                    1349m     MOVE.B D4,D5
00000734  D484                    1350m     ADD.L D4,D2
00000736                          1351m 
00000736                          1352m     ENDM
00000736                          1353              ENDI
00000736                          1354s _00000006
00000736                          1355  
00000736  2444                    1356              MOVE.L D4,A2                            ; put the address in an address register
00000738  D5C9                    1357              ADD.L A1,A2                             ; add in the offset
0000073A                          1358  
0000073A                          1359              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
0000073A                          1360s _10000008
0000073A  B63C 0000               1361s     CMP.B   #0,D3
0000073E  6F00 007A               1362s     BLE _10000009
00000742                          1363m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000742  1E3C 0002               1364m     MOVE.B #2,D7
00000746                          1365m     WHILE.B D7 <GT> 0 DO
00000746                          1366ms _1000000A
00000746  BE38 0000               1367ms     CMP.B   0,D7
0000074A  6F00 0062               1368ms     BLE _1000000B
0000074E  E989                    1369m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000750                          1370mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000750                          1371mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000750                          1372mm 
00000750  1A39 00C00003           1373mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000756  0805 0000               1374mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000075A  6700 0010               1375mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
0000075E                          1376mm 
0000075E                          1377mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075E                 TRUE     1378mmm     IFEQ DEBUG
0000075E  1A39 00C00007           1379mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000764                          1380mmm     ENDC
00000764                 FALSE    1381mmm     IFNE DEBUG
00000764                          1382mmm     ENDC
00000764                          1383mmm 
00000764  BA3C 001B               1384mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000768  6700 F8A6               1385mmm     BEQ START
0000076C                          1386mmm     ENDM
0000076C                          1387mm CONTINUE_84
0000076C  1A39 00C00013           1388mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000772  0805 0000               1389mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000776  67D8                    1390mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
00000778                          1391mm     
00000778  1A39 00C00017           1392mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000077E  13C5 00E00001           1393mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000784                          1394mm 
00000784                          1395mm     ENDM
00000784                          1396mm         PRINT_CHAR D5,D6
00000784                          1397mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000784                 TRUE     1398mm     IFEQ DEBUG
00000784  1C39 00C00003           1399mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000078A  0806 0002               1400mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000078E  67F4                    1401mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
00000790  13C5 00C00007           1402mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000796                          1403mm     ENDC
00000796                          1404mm 
00000796                 FALSE    1405mm     IFNE DEBUG
00000796                          1406mm     ENDC
00000796                          1407mm 
00000796                          1408mm     ENDM
00000796                          1409mm         HEX2BIN D5,D5,A4
00000796  49FA 0DCE               1410mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000079A  0405 0030               1411mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000079E  CABC 000000FF           1412mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007A4  1A34 5000               1413mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007A8                          1414mm     ENDM
000007A8  8205                    1415m         OR.B D5,D1
000007AA  5307                    1416m         SUB.B #1,D7
000007AC                          1417m     ENDW
000007AC  6098                    1418ms     BRA _1000000A
000007AE                          1419ms _1000000B
000007AE                          1420m 
000007AE  7A00                    1421m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007B0  1A01                    1422m     MOVE.B D1,D5
000007B2  D481                    1423m     ADD.L D1,D2
000007B4                          1424m 
000007B4                          1425m     ENDM
000007B4                          1426   
000007B4  14C1                    1427                  MOVE.B D1,(A2)+                     ; store it!
000007B6                          1428  
000007B6  5303                    1429                  SUB.B #1,D3                         ; 1 less byte to go
000007B8                          1430              ENDW
000007B8  6080                    1431s     BRA _10000008
000007BA                          1432s _10000009
000007BA                          1433  
000007BA  7200                    1434              MOVE.L #0,D1                            ; not done yet
000007BC                          1435          ELSE
000007BC  6000 01E2               1436s     BRA _00000007
000007C0                          1437s _00000005
000007C0                          1438              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000007C0  B23C 0038               1439s     CMP.B   #'8',D1
000007C4  6600 0164               1440s     BNE.L   _00000008
000007C8  7800                    1441                  MOVE.L #0,D4                        ; read the 24 bit start address
000007CA                          1442m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000007CA  1E3C 0002               1443m     MOVE.B #2,D7
000007CE                          1444m     WHILE.B D7 <GT> 0 DO
000007CE                          1445ms _1000000C
000007CE  BE38 0000               1446ms     CMP.B   0,D7
000007D2  6F00 0062               1447ms     BLE _1000000D
000007D6  E98C                    1448m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000007D8                          1449mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007D8                          1450mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007D8                          1451mm 
000007D8  1A39 00C00003           1452mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007DE  0805 0000               1453mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007E2  6700 0010               1454mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
000007E6                          1455mm 
000007E6                          1456mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007E6                 TRUE     1457mmm     IFEQ DEBUG
000007E6  1A39 00C00007           1458mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007EC                          1459mmm     ENDC
000007EC                 FALSE    1460mmm     IFNE DEBUG
000007EC                          1461mmm     ENDC
000007EC                          1462mmm 
000007EC  BA3C 001B               1463mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007F0  6700 F81E               1464mmm     BEQ START
000007F4                          1465mmm     ENDM
000007F4                          1466mm CONTINUE_89
000007F4  1A39 00C00013           1467mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007FA  0805 0000               1468mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007FE  67D8                    1469mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
00000800                          1470mm     
00000800  1A39 00C00017           1471mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000806  13C5 00E00001           1472mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000080C                          1473mm 
0000080C                          1474mm     ENDM
0000080C                          1475mm         PRINT_CHAR D5,D6
0000080C                          1476mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080C                 TRUE     1477mm     IFEQ DEBUG
0000080C  1C39 00C00003           1478mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000812  0806 0002               1479mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000816  67F4                    1480mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000818  13C5 00C00007           1481mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000081E                          1482mm     ENDC
0000081E                          1483mm 
0000081E                 FALSE    1484mm     IFNE DEBUG
0000081E                          1485mm     ENDC
0000081E                          1486mm 
0000081E                          1487mm     ENDM
0000081E                          1488mm         HEX2BIN D5,D5,A4
0000081E  49FA 0D46               1489mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000822  0405 0030               1490mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000826  CABC 000000FF           1491mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000082C  1A34 5000               1492mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000830                          1493mm     ENDM
00000830  8805                    1494m         OR.B D5,D4
00000832  5307                    1495m         SUB.B #1,D7
00000834                          1496m     ENDW
00000834  6098                    1497ms     BRA _1000000C
00000836                          1498ms _1000000D
00000836                          1499m 
00000836  7A00                    1500m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000838  1A04                    1501m     MOVE.B D4,D5
0000083A  D484                    1502m     ADD.L D4,D2
0000083C                          1503m 
0000083C                          1504m     ENDM
0000083C                          1505m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000083C  1E3C 0002               1506m     MOVE.B #2,D7
00000840                          1507m     WHILE.B D7 <GT> 0 DO
00000840                          1508ms _1000000E
00000840  BE38 0000               1509ms     CMP.B   0,D7
00000844  6F00 0062               1510ms     BLE _1000000F
00000848  E98C                    1511m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000084A                          1512mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000084A                          1513mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000084A                          1514mm 
0000084A  1A39 00C00003           1515mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000850  0805 0000               1516mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000854  6700 0010               1517mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
00000858                          1518mm 
00000858                          1519mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000858                 TRUE     1520mmm     IFEQ DEBUG
00000858  1A39 00C00007           1521mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000085E                          1522mmm     ENDC
0000085E                 FALSE    1523mmm     IFNE DEBUG
0000085E                          1524mmm     ENDC
0000085E                          1525mmm 
0000085E  BA3C 001B               1526mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000862  6700 F7AC               1527mmm     BEQ START
00000866                          1528mmm     ENDM
00000866                          1529mm CONTINUE_94
00000866  1A39 00C00013           1530mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000086C  0805 0000               1531mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000870  67D8                    1532mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
00000872                          1533mm     
00000872  1A39 00C00017           1534mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000878  13C5 00E00001           1535mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000087E                          1536mm 
0000087E                          1537mm     ENDM
0000087E                          1538mm         PRINT_CHAR D5,D6
0000087E                          1539mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000087E                 TRUE     1540mm     IFEQ DEBUG
0000087E  1C39 00C00003           1541mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000884  0806 0002               1542mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000888  67F4                    1543mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
0000088A  13C5 00C00007           1544mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000890                          1545mm     ENDC
00000890                          1546mm 
00000890                 FALSE    1547mm     IFNE DEBUG
00000890                          1548mm     ENDC
00000890                          1549mm 
00000890                          1550mm     ENDM
00000890                          1551mm         HEX2BIN D5,D5,A4
00000890  49FA 0CD4               1552mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000894  0405 0030               1553mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000898  CABC 000000FF           1554mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000089E  1A34 5000               1555mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008A2                          1556mm     ENDM
000008A2  8805                    1557m         OR.B D5,D4
000008A4  5307                    1558m         SUB.B #1,D7
000008A6                          1559m     ENDW
000008A6  6098                    1560ms     BRA _1000000E
000008A8                          1561ms _1000000F
000008A8                          1562m 
000008A8  7A00                    1563m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008AA  1A04                    1564m     MOVE.B D4,D5
000008AC  D484                    1565m     ADD.L D4,D2
000008AE                          1566m 
000008AE                          1567m     ENDM
000008AE                          1568m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000008AE  1E3C 0002               1569m     MOVE.B #2,D7
000008B2                          1570m     WHILE.B D7 <GT> 0 DO
000008B2                          1571ms _10000010
000008B2  BE38 0000               1572ms     CMP.B   0,D7
000008B6  6F00 0062               1573ms     BLE _10000011
000008BA  E98C                    1574m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000008BC                          1575mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000008BC                          1576mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BC                          1577mm 
000008BC  1A39 00C00003           1578mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000008C2  0805 0000               1579mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008C6  6700 0010               1580mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
000008CA                          1581mm 
000008CA                          1582mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000008CA                 TRUE     1583mmm     IFEQ DEBUG
000008CA  1A39 00C00007           1584mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000008D0                          1585mmm     ENDC
000008D0                 FALSE    1586mmm     IFNE DEBUG
000008D0                          1587mmm     ENDC
000008D0                          1588mmm 
000008D0  BA3C 001B               1589mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008D4  6700 F73A               1590mmm     BEQ START
000008D8                          1591mmm     ENDM
000008D8                          1592mm CONTINUE_99
000008D8  1A39 00C00013           1593mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008DE  0805 0000               1594mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008E2  67D8                    1595mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
000008E4                          1596mm     
000008E4  1A39 00C00017           1597mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008EA  13C5 00E00001           1598mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008F0                          1599mm 
000008F0                          1600mm     ENDM
000008F0                          1601mm         PRINT_CHAR D5,D6
000008F0                          1602mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008F0                 TRUE     1603mm     IFEQ DEBUG
000008F0  1C39 00C00003           1604mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008F6  0806 0002               1605mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008FA  67F4                    1606mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
000008FC  13C5 00C00007           1607mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000902                          1608mm     ENDC
00000902                          1609mm 
00000902                 FALSE    1610mm     IFNE DEBUG
00000902                          1611mm     ENDC
00000902                          1612mm 
00000902                          1613mm     ENDM
00000902                          1614mm         HEX2BIN D5,D5,A4
00000902  49FA 0C62               1615mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000906  0405 0030               1616mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000090A  CABC 000000FF           1617mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000910  1A34 5000               1618mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000914                          1619mm     ENDM
00000914  8805                    1620m         OR.B D5,D4
00000916  5307                    1621m         SUB.B #1,D7
00000918                          1622m     ENDW
00000918  6098                    1623ms     BRA _10000010
0000091A                          1624ms _10000011
0000091A                          1625m 
0000091A  7A00                    1626m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000091C  1A04                    1627m     MOVE.B D4,D5
0000091E  D484                    1628m     ADD.L D4,D2
00000920                          1629m 
00000920                          1630m     ENDM
00000920                          1631  
00000920  2044                    1632                  MOVE.L D4,A0                        ; start address -> A0
00000922  D1C9                    1633                  ADD.L A1,A0                         ; add in the offset
00000924                          1634  
00000924  72FF                    1635                  MOVE.L #$FFFFFFFF,D1                ; done
00000926                          1636              ELSE
00000926  6000 0078               1637s     BRA _00000009
0000092A                          1638s _00000008
0000092A                          1639m                 PRINT_CRLF D5,A4
0000092A  49FA 0C65               1640m     LEA CRLF(PC),A4
0000092E                          1641mm     PRINT_STR A4,D5
0000092E                          1642mm LOOP_104
0000092E  0C14 0000               1643mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000932  6700 0016               1644mm     BEQ EXIT_104
00000936                          1645mmm     PRINT_CHAR (A4)+,D5
00000936                          1646mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000936                 TRUE     1647mmm     IFEQ DEBUG
00000936  1A39 00C00003           1648mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000093C  0805 0002               1649mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000940  67F4                    1650mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000942  13DC 00C00007           1651mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000948                          1652mmm     ENDC
00000948                          1653mmm 
00000948                 FALSE    1654mmm     IFNE DEBUG
00000948                          1655mmm     ENDC
00000948                          1656mmm 
00000948                          1657mmm     ENDM
00000948  60E4                    1658mm     BRA LOOP_104
0000094A                          1659mm EXIT_104
0000094A                          1660mm     ENDM
0000094A                          1661m     ENDM
0000094A                          1662  
0000094A  49FA 0BCF               1663                  LEA UNREC(PC),A4                    ; warn for unrecognised type
0000094E                          1664m                 PRINT_STR A4,D5
0000094E                          1665m LOOP_106
0000094E  0C14 0000               1666m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000952  6700 0016               1667m     BEQ EXIT_106
00000956                          1668mm     PRINT_CHAR (A4)+,D5
00000956                          1669mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000956                 TRUE     1670mm     IFEQ DEBUG
00000956  1A39 00C00003           1671mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000095C  0805 0002               1672mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000960  67F4                    1673mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000962  13DC 00C00007           1674mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000968                          1675mm     ENDC
00000968                          1676mm 
00000968                 FALSE    1677mm     IFNE DEBUG
00000968                          1678mm     ENDC
00000968                          1679mm 
00000968                          1680mm     ENDM
00000968  60E4                    1681m     BRA LOOP_106
0000096A                          1682m EXIT_106
0000096A                          1683m     ENDM
0000096A                          1684m                 PRINT_CHAR D1,D5
0000096A                          1685m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000096A                 TRUE     1686m     IFEQ DEBUG
0000096A  1A39 00C00003           1687m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000970  0805 0002               1688m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000974  67F4                    1689m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000976  13C1 00C00007           1690m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000097C                          1691m     ENDC
0000097C                          1692m 
0000097C                 FALSE    1693m     IFNE DEBUG
0000097C                          1694m     ENDC
0000097C                          1695m 
0000097C                          1696m     ENDM
0000097C                          1697m                 PRINT_CRLF D5,A4
0000097C  49FA 0C13               1698m     LEA CRLF(PC),A4
00000980                          1699mm     PRINT_STR A4,D5
00000980                          1700mm LOOP_110
00000980  0C14 0000               1701mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000984  6700 0016               1702mm     BEQ EXIT_110
00000988                          1703mmm     PRINT_CHAR (A4)+,D5
00000988                          1704mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000988                 TRUE     1705mmm     IFEQ DEBUG
00000988  1A39 00C00003           1706mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000098E  0805 0002               1707mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000992  67F4                    1708mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000994  13DC 00C00007           1709mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000099A                          1710mmm     ENDC
0000099A                          1711mmm 
0000099A                 FALSE    1712mmm     IFNE DEBUG
0000099A                          1713mmm     ENDC
0000099A                          1714mmm 
0000099A                          1715mmm     ENDM
0000099A  60E4                    1716mm     BRA LOOP_110
0000099C                          1717mm EXIT_110
0000099C                          1718mm     ENDM
0000099C                          1719m     ENDM
0000099C                          1720  
0000099C  6000 FAEC               1721                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
000009A0                          1722              ENDI
000009A0                          1723s _00000009
000009A0                          1724          ENDI
000009A0                          1725s _00000007
000009A0                          1726      ENDI
000009A0                          1727s _00000003
000009A0                          1728  
000009A0                          1729m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
000009A0  1E3C 0002               1730m     MOVE.B #2,D7
000009A4                          1731m     WHILE.B D7 <GT> 0 DO
000009A4                          1732ms _10000012
000009A4  BE38 0000               1733ms     CMP.B   0,D7
000009A8  6F00 0062               1734ms     BLE _10000013
000009AC  E98C                    1735m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009AE                          1736mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009AE                          1737mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009AE                          1738mm 
000009AE  1A39 00C00003           1739mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009B4  0805 0000               1740mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009B8  6700 0010               1741mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
000009BC                          1742mm 
000009BC                          1743mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009BC                 TRUE     1744mmm     IFEQ DEBUG
000009BC  1A39 00C00007           1745mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C2                          1746mmm     ENDC
000009C2                 FALSE    1747mmm     IFNE DEBUG
000009C2                          1748mmm     ENDC
000009C2                          1749mmm 
000009C2  BA3C 001B               1750mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009C6  6700 F648               1751mmm     BEQ START
000009CA                          1752mmm     ENDM
000009CA                          1753mm CONTINUE_113
000009CA  1A39 00C00013           1754mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D0  0805 0000               1755mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009D4  67D8                    1756mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
000009D6                          1757mm     
000009D6  1A39 00C00017           1758mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009DC  13C5 00E00001           1759mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E2                          1760mm 
000009E2                          1761mm     ENDM
000009E2                          1762mm         PRINT_CHAR D5,D6
000009E2                          1763mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E2                 TRUE     1764mm     IFEQ DEBUG
000009E2  1C39 00C00003           1765mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009E8  0806 0002               1766mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009EC  67F4                    1767mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
000009EE  13C5 00C00007           1768mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009F4                          1769mm     ENDC
000009F4                          1770mm 
000009F4                 FALSE    1771mm     IFNE DEBUG
000009F4                          1772mm     ENDC
000009F4                          1773mm 
000009F4                          1774mm     ENDM
000009F4                          1775mm         HEX2BIN D5,D5,A4
000009F4  49FA 0B70               1776mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009F8  0405 0030               1777mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009FC  CABC 000000FF           1778mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A02  1A34 5000               1779mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A06                          1780mm     ENDM
00000A06  8805                    1781m         OR.B D5,D4
00000A08  5307                    1782m         SUB.B #1,D7
00000A0A                          1783m     ENDW
00000A0A  6098                    1784ms     BRA _10000012
00000A0C                          1785ms _10000013
00000A0C                          1786m 
00000A0C  7A00                    1787m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A0E  1A04                    1788m     MOVE.B D4,D5
00000A10  D484                    1789m     ADD.L D4,D2
00000A12                          1790m 
00000A12                          1791m     ENDM
00000A12                          1792m     PRINT_CRLF D5,A4
00000A12  49FA 0B7D               1793m     LEA CRLF(PC),A4
00000A16                          1794mm     PRINT_STR A4,D5
00000A16                          1795mm LOOP_118
00000A16  0C14 0000               1796mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A1A  6700 0016               1797mm     BEQ EXIT_118
00000A1E                          1798mmm     PRINT_CHAR (A4)+,D5
00000A1E                          1799mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A1E                 TRUE     1800mmm     IFEQ DEBUG
00000A1E  1A39 00C00003           1801mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A24  0805 0002               1802mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A28  67F4                    1803mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000A2A  13DC 00C00007           1804mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A30                          1805mmm     ENDC
00000A30                          1806mmm 
00000A30                 FALSE    1807mmm     IFNE DEBUG
00000A30                          1808mmm     ENDC
00000A30                          1809mmm 
00000A30                          1810mmm     ENDM
00000A30  60E4                    1811mm     BRA LOOP_118
00000A32                          1812mm EXIT_118
00000A32                          1813mm     ENDM
00000A32                          1814m     ENDM
00000A32                          1815  
00000A32                          1816      IF.B D2 <NE> #$FF THEN.L
00000A32  B43C 00FF               1817s     CMP.B   #$FF,D2
00000A36  6700 0090               1818s     BEQ.L   _0000000A
00000A3A  49FA 0AF6               1819          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000A3E                          1820m         PRINT_STR A4,D5
00000A3E                          1821m LOOP_120
00000A3E  0C14 0000               1822m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A42  6700 0016               1823m     BEQ EXIT_120
00000A46                          1824mm     PRINT_CHAR (A4)+,D5
00000A46                          1825mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A46                 TRUE     1826mm     IFEQ DEBUG
00000A46  1A39 00C00003           1827mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A4C  0805 0002               1828mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A50  67F4                    1829mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000A52  13DC 00C00007           1830mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A58                          1831mm     ENDC
00000A58                          1832mm 
00000A58                 FALSE    1833mm     IFNE DEBUG
00000A58                          1834mm     ENDC
00000A58                          1835mm 
00000A58                          1836mm     ENDM
00000A58  60E4                    1837m     BRA LOOP_120
00000A5A                          1838m EXIT_120
00000A5A                          1839m     ENDM
00000A5A                          1840m         PRINT_REG D0,D5,D3,D6,A4
00000A5A  49FA 0B3B               1841m     LEA OX(PC),A4
00000A5E                          1842mm     PRINT_STR A4,D5
00000A5E                          1843mm LOOP_123
00000A5E  0C14 0000               1844mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A62  6700 0016               1845mm     BEQ EXIT_123
00000A66                          1846mmm     PRINT_CHAR (A4)+,D5
00000A66                          1847mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                 TRUE     1848mmm     IFEQ DEBUG
00000A66  1A39 00C00003           1849mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A6C  0805 0002               1850mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A70  67F4                    1851mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000A72  13DC 00C00007           1852mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A78                          1853mmm     ENDC
00000A78                          1854mmm 
00000A78                 FALSE    1855mmm     IFNE DEBUG
00000A78                          1856mmm     ENDC
00000A78                          1857mmm 
00000A78                          1858mmm     ENDM
00000A78  60E4                    1859mm     BRA LOOP_123
00000A7A                          1860mm EXIT_123
00000A7A                          1861mm     ENDM
00000A7A  7C07                    1862m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A7C                          1863m LOOP_122
00000A7C                          1864mm     BIN2HEX D0,D3,A4
00000A7C  49FA 0AD8               1865mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A80  E998                    1866mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A82  1600                    1867mm     MOVE.B D0,D3
00000A84  0283 0000000F           1868mm     ANDI.L #$F,D3
00000A8A  1634 3000               1869mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000A8E                          1870mm     ENDM
00000A8E                          1871mm     PRINT_CHAR D3,D5
00000A8E                          1872mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A8E                 TRUE     1873mm     IFEQ DEBUG
00000A8E  1A39 00C00003           1874mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A94  0805 0002               1875mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A98  67F4                    1876mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000A9A  13C3 00C00007           1877mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AA0                          1878mm     ENDC
00000AA0                          1879mm 
00000AA0                 FALSE    1880mm     IFNE DEBUG
00000AA0                          1881mm     ENDC
00000AA0                          1882mm 
00000AA0                          1883mm     ENDM
00000AA0  57CE FFDA               1884m     DBEQ D6,LOOP_122
00000AA4                          1885m     ENDM
00000AA4                          1886m         PRINT_CRLF D5,A4
00000AA4  49FA 0AEB               1887m     LEA CRLF(PC),A4
00000AA8                          1888mm     PRINT_STR A4,D5
00000AA8                          1889mm LOOP_128
00000AA8  0C14 0000               1890mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000AAC  6700 0016               1891mm     BEQ EXIT_128
00000AB0                          1892mmm     PRINT_CHAR (A4)+,D5
00000AB0                          1893mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AB0                 TRUE     1894mmm     IFEQ DEBUG
00000AB0  1A39 00C00003           1895mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AB6  0805 0002               1896mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ABA  67F4                    1897mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000ABC  13DC 00C00007           1898mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AC2                          1899mmm     ENDC
00000AC2                          1900mmm 
00000AC2                 FALSE    1901mmm     IFNE DEBUG
00000AC2                          1902mmm     ENDC
00000AC2                          1903mmm 
00000AC2                          1904mmm     ENDM
00000AC2  60E4                    1905mm     BRA LOOP_128
00000AC4                          1906mm EXIT_128
00000AC4                          1907mm     ENDM
00000AC4                          1908m     ENDM
00000AC4                          1909          
00000AC4  6000 F734               1910          BRA MAIN_LOOP
00000AC8                          1911      ENDI
00000AC8                          1912s _0000000A
00000AC8                          1913  
00000AC8                          1914      IF D1 <EQ> #0 THEN
00000AC8  B27C 0000               1915s     CMP.W   #0,D1
00000ACC  6600 0006               1916s     BNE _0000000B
00000AD0  6000 F9B8               1917        BRA WAIT_FOR_SRECORD
00000AD4                          1918      ENDI
00000AD4                          1919s _0000000B
00000AD4                          1920  DOWNLOAD_DONE
00000AD4                          1921m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000AD4  43FA 0AC1               1922m     LEA OX(PC),A1
00000AD8                          1923mm     PRINT_STR A1,D5
00000AD8                          1924mm LOOP_131
00000AD8  0C11 0000               1925mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000ADC  6700 0016               1926mm     BEQ EXIT_131
00000AE0                          1927mmm     PRINT_CHAR (A1)+,D5
00000AE0                          1928mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE0                 TRUE     1929mmm     IFEQ DEBUG
00000AE0  1A39 00C00003           1930mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AE6  0805 0002               1931mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AEA  67F4                    1932mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000AEC  13D9 00C00007           1933mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AF2                          1934mmm     ENDC
00000AF2                          1935mmm 
00000AF2                 FALSE    1936mmm     IFNE DEBUG
00000AF2                          1937mmm     ENDC
00000AF2                          1938mmm 
00000AF2                          1939mmm     ENDM
00000AF2  60E4                    1940mm     BRA LOOP_131
00000AF4                          1941mm EXIT_131
00000AF4                          1942mm     ENDM
00000AF4  7407                    1943m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AF6                          1944m LOOP_130
00000AF6                          1945mm     BIN2HEX D0,D6,A1
00000AF6  43FA 0A5E               1946mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AFA  E998                    1947mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AFC  1C00                    1948mm     MOVE.B D0,D6
00000AFE  0286 0000000F           1949mm     ANDI.L #$F,D6
00000B04  1C31 6000               1950mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B08                          1951mm     ENDM
00000B08                          1952mm     PRINT_CHAR D6,D5
00000B08                          1953mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B08                 TRUE     1954mm     IFEQ DEBUG
00000B08  1A39 00C00003           1955mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B0E  0805 0002               1956mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B12  67F4                    1957mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000B14  13C6 00C00007           1958mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B1A                          1959mm     ENDC
00000B1A                          1960mm 
00000B1A                 FALSE    1961mm     IFNE DEBUG
00000B1A                          1962mm     ENDC
00000B1A                          1963mm 
00000B1A                          1964mm     ENDM
00000B1A  57CA FFDA               1965m     DBEQ D2,LOOP_130
00000B1E                          1966m     ENDM
00000B1E  43FA 09D9               1967      LEA READ(PC),A1
00000B22                          1968m     PRINT_STR A1,D5
00000B22                          1969m LOOP_135
00000B22  0C11 0000               1970m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B26  6700 0016               1971m     BEQ EXIT_135
00000B2A                          1972mm     PRINT_CHAR (A1)+,D5
00000B2A                          1973mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B2A                 TRUE     1974mm     IFEQ DEBUG
00000B2A  1A39 00C00003           1975mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B30  0805 0002               1976mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B34  67F4                    1977mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000B36  13D9 00C00007           1978mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B3C                          1979mm     ENDC
00000B3C                          1980mm 
00000B3C                 FALSE    1981mm     IFNE DEBUG
00000B3C                          1982mm     ENDC
00000B3C                          1983mm 
00000B3C                          1984mm     ENDM
00000B3C  60E4                    1985m     BRA LOOP_135
00000B3E                          1986m EXIT_135
00000B3E                          1987m     ENDM
00000B3E  2E08                    1988      MOVE.L A0,D7                                    ; set address accumulator to start address
00000B40                          1989m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000B40  43FA 0A55               1990m     LEA OX(PC),A1
00000B44                          1991mm     PRINT_STR A1,D5
00000B44                          1992mm LOOP_138
00000B44  0C11 0000               1993mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000B48  6700 0016               1994mm     BEQ EXIT_138
00000B4C                          1995mmm     PRINT_CHAR (A1)+,D5
00000B4C                          1996mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B4C                 TRUE     1997mmm     IFEQ DEBUG
00000B4C  1A39 00C00003           1998mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B52  0805 0002               1999mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B56  67F4                    2000mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000B58  13D9 00C00007           2001mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B5E                          2002mmm     ENDC
00000B5E                          2003mmm 
00000B5E                 FALSE    2004mmm     IFNE DEBUG
00000B5E                          2005mmm     ENDC
00000B5E                          2006mmm 
00000B5E                          2007mmm     ENDM
00000B5E  60E4                    2008mm     BRA LOOP_138
00000B60                          2009mm EXIT_138
00000B60                          2010mm     ENDM
00000B60  7407                    2011m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000B62                          2012m LOOP_137
00000B62                          2013mm     BIN2HEX D7,D6,A1
00000B62  43FA 09F2               2014mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000B66  E99F                    2015mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000B68  1C07                    2016mm     MOVE.B D7,D6
00000B6A  0286 0000000F           2017mm     ANDI.L #$F,D6
00000B70  1C31 6000               2018mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B74                          2019mm     ENDM
00000B74                          2020mm     PRINT_CHAR D6,D5
00000B74                          2021mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B74                 TRUE     2022mm     IFEQ DEBUG
00000B74  1A39 00C00003           2023mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B7A  0805 0002               2024mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B7E  67F4                    2025mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000B80  13C6 00C00007           2026mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B86                          2027mm     ENDC
00000B86                          2028mm 
00000B86                 FALSE    2029mm     IFNE DEBUG
00000B86                          2030mm     ENDC
00000B86                          2031mm 
00000B86                          2032mm     ENDM
00000B86  57CA FFDA               2033m     DBEQ D2,LOOP_137
00000B8A                          2034m     ENDM
00000B8A                          2035m     PRINT_CRLF D5,A4
00000B8A  49FA 0A05               2036m     LEA CRLF(PC),A4
00000B8E                          2037mm     PRINT_STR A4,D5
00000B8E                          2038mm LOOP_143
00000B8E  0C14 0000               2039mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B92  6700 0016               2040mm     BEQ EXIT_143
00000B96                          2041mmm     PRINT_CHAR (A4)+,D5
00000B96                          2042mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B96                 TRUE     2043mmm     IFEQ DEBUG
00000B96  1A39 00C00003           2044mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B9C  0805 0002               2045mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BA0  67F4                    2046mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000BA2  13DC 00C00007           2047mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BA8                          2048mmm     ENDC
00000BA8                          2049mmm 
00000BA8                 FALSE    2050mmm     IFNE DEBUG
00000BA8                          2051mmm     ENDC
00000BA8                          2052mmm 
00000BA8                          2053mmm     ENDM
00000BA8  60E4                    2054mm     BRA LOOP_143
00000BAA                          2055mm EXIT_143
00000BAA                          2056mm     ENDM
00000BAA                          2057m     ENDM
00000BAA                          2058  
00000BAA  6000 F64E               2059      BRA MAIN_LOOP
00000BAE                          2060  
00000BAE                          2061  G
00000BAE  2047                    2062      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000BB0  7E00                    2063      MOVE.L #0,D7
00000BB2                          2064  
00000BB2  4ED0                    2065      JMP (A0)
00000BB4                          2066          
00000BB4                          2067  Z
00000BB4  207C 00200000           2068      MOVE.L #RAM,A0                                  ; address of RAM
00000BBA  D1FC 00100000           2069      ADD.L #$100000,A0
00000BC0                          2070  
00000BC0                          2071      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000BC0  7000                    2072s     MOVE.L  #0,D0
00000BC2  6000 0012               2073s     BRA _20000005
00000BC6                          2074s _20000004
00000BC6  2200                    2075          MOVE.L D0,D1                                ; progress update
00000BC8  E089                    2076          LSR.L #8,D1 
00000BCA  E089                    2077          LSR.L #8,D1
00000BCC  13C1 00E00001           2078          MOVE.B D1,DISPLAY
00000BD2                          2079          
00000BD2  2108                    2080          MOVE.L A0,-(A0)
00000BD4                          2081      ENDF
00000BD4  5880                    2082s     ADD.L   #4,D0
00000BD6                          2083s _20000005
00000BD6  B0BC 000FFFFC           2084s     CMP.L   #$FFFFC,D0
00000BDC  6FE8                    2085s     BLE _20000004
00000BDE                          2086  
00000BDE  207C 00200000           2087      MOVE.L #RAM,A0                                  ; address of RAM
00000BE4  D1FC 00100000           2088      ADD.L #$100000,A0
00000BEA                          2089  
00000BEA                          2090      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000BEA  7000                    2091s     MOVE.L  #0,D0
00000BEC  6000 00A8               2092s     BRA _20000007
00000BF0                          2093s _20000006
00000BF0  2200                    2094          MOVE.L D0,D1                                ; progress update
00000BF2  E089                    2095          LSR.L #8,D1
00000BF4  E089                    2096          LSR.L #8,D1
00000BF6  13C1 00E00001           2097          MOVE.B D1,DISPLAY
00000BFC                          2098  
00000BFC  2408                    2099          MOVE.L A0,D2
00000BFE  2220                    2100          MOVE.L -(A0),D1
00000C00                          2101  
00000C00                          2102          IF.L D2 <NE> D1 THEN
00000C00  B481                    2103s     CMP.L   D1,D2
00000C02  6700 0090               2104s     BEQ _0000000C
00000C06  43FA 093C               2105              LEA RAM_ERROR(PC),A1
00000C0A                          2106m             PRINT_STR A1,D1
00000C0A                          2107m LOOP_145
00000C0A  0C11 0000               2108m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C0E  6700 0016               2109m     BEQ EXIT_145
00000C12                          2110mm     PRINT_CHAR (A1)+,D1
00000C12                          2111mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C12                 TRUE     2112mm     IFEQ DEBUG
00000C12  1239 00C00003           2113mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000C18  0801 0002               2114mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000C1C  67F4                    2115mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000C1E  13D9 00C00007           2116mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C24                          2117mm     ENDC
00000C24                          2118mm 
00000C24                 FALSE    2119mm     IFNE DEBUG
00000C24                          2120mm     ENDC
00000C24                          2121mm 
00000C24                          2122mm     ENDM
00000C24  60E4                    2123m     BRA LOOP_145
00000C26                          2124m EXIT_145
00000C26                          2125m     ENDM
00000C26  2208                    2126              MOVE.L A0,D1
00000C28  5981                    2127              SUB.L #4,D1
00000C2A                          2128m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000C2A  43FA 096B               2129m     LEA OX(PC),A1
00000C2E                          2130mm     PRINT_STR A1,D3
00000C2E                          2131mm LOOP_148
00000C2E  0C11 0000               2132mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C32  6700 0016               2133mm     BEQ EXIT_148
00000C36                          2134mmm     PRINT_CHAR (A1)+,D3
00000C36                          2135mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C36                 TRUE     2136mmm     IFEQ DEBUG
00000C36  1639 00C00003           2137mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C3C  0803 0002               2138mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C40  67F4                    2139mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000C42  13D9 00C00007           2140mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C48                          2141mmm     ENDC
00000C48                          2142mmm 
00000C48                 FALSE    2143mmm     IFNE DEBUG
00000C48                          2144mmm     ENDC
00000C48                          2145mmm 
00000C48                          2146mmm     ENDM
00000C48  60E4                    2147mm     BRA LOOP_148
00000C4A                          2148mm EXIT_148
00000C4A                          2149mm     ENDM
00000C4A  7C07                    2150m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C4C                          2151m LOOP_147
00000C4C                          2152mm     BIN2HEX D1,D2,A1
00000C4C  43FA 0908               2153mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C50  E999                    2154mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C52  1401                    2155mm     MOVE.B D1,D2
00000C54  0282 0000000F           2156mm     ANDI.L #$F,D2
00000C5A  1431 2000               2157mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000C5E                          2158mm     ENDM
00000C5E                          2159mm     PRINT_CHAR D2,D3
00000C5E                          2160mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C5E                 TRUE     2161mm     IFEQ DEBUG
00000C5E  1639 00C00003           2162mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C64  0803 0002               2163mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C68  67F4                    2164mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000C6A  13C2 00C00007           2165mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C70                          2166mm     ENDC
00000C70                          2167mm 
00000C70                 FALSE    2168mm     IFNE DEBUG
00000C70                          2169mm     ENDC
00000C70                          2170mm 
00000C70                          2171mm     ENDM
00000C70  57CE FFDA               2172m     DBEQ D6,LOOP_147
00000C74                          2173m     ENDM
00000C74                          2174m             PRINT_CRLF D3,A1
00000C74  43FA 091B               2175m     LEA CRLF(PC),A1
00000C78                          2176mm     PRINT_STR A1,D3
00000C78                          2177mm LOOP_153
00000C78  0C11 0000               2178mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C7C  6700 0016               2179mm     BEQ EXIT_153
00000C80                          2180mmm     PRINT_CHAR (A1)+,D3
00000C80                          2181mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C80                 TRUE     2182mmm     IFEQ DEBUG
00000C80  1639 00C00003           2183mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C86  0803 0002               2184mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C8A  67F4                    2185mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000C8C  13D9 00C00007           2186mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C92                          2187mmm     ENDC
00000C92                          2188mmm 
00000C92                 FALSE    2189mmm     IFNE DEBUG
00000C92                          2190mmm     ENDC
00000C92                          2191mmm 
00000C92                          2192mmm     ENDM
00000C92  60E4                    2193mm     BRA LOOP_153
00000C94                          2194mm EXIT_153
00000C94                          2195mm     ENDM
00000C94                          2196m     ENDM
00000C94                          2197          ENDI 
00000C94                          2198s _0000000C
00000C94                          2199      ENDF
00000C94  5880                    2200s     ADD.L   #4,D0
00000C96                          2201s _20000007
00000C96  B0BC 000FFFFC           2202s     CMP.L   #$FFFFC,D0
00000C9C  6F00 FF52               2203s     BLE _20000006
00000CA0                          2204  
00000CA0  6000 F558               2205      BRA MAIN_LOOP
00000CA4                          2206  
00000CA4                          2207  L
00000CA4  7000                    2208      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000CA6  7200                    2209      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000CA8                          2210  
00000CA8                          2211      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000CA8  343C 0000               2212s     MOVE.W  #0,D2
00000CAC  6000 0046               2213s     BRA _20000009
00000CB0                          2214s _20000008
00000CB0  E989                    2215          LSL.L #4,D1                                 ; make what we have so far more significant
00000CB2                          2216m         WAIT_CHAR D3,D4                             ; next character -> D2
00000CB2                          2217m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB2                 TRUE     2218m     IFEQ DEBUG
00000CB2  1839 00C00003           2219m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CB8  0804 0000               2220m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000CBC  67F4                    2221m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000CBE                          2222m     ENDC
00000CBE                          2223m 
00000CBE                          2224mm     READ_CHAR D3
00000CBE                 TRUE     2225mm     IFEQ DEBUG
00000CBE  1639 00C00007           2226mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000CC4                          2227mm     ENDC
00000CC4                 FALSE    2228mm     IFNE DEBUG
00000CC4                          2229mm     ENDC
00000CC4                          2230mm 
00000CC4  B63C 001B               2231mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000CC8  6700 F346               2232mm     BEQ START
00000CCC                          2233mm     ENDM
00000CCC                          2234m 
00000CCC                 TRUE     2235m     IFEQ DEBUG
00000CCC                          2236mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000CCC                          2237mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                 TRUE     2238mm     IFEQ DEBUG
00000CCC  1839 00C00003           2239mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000CD2  0804 0002               2240mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000CD6  67F4                    2241mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000CD8  13C3 00C00007           2242mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CDE                          2243mm     ENDC
00000CDE                          2244mm 
00000CDE                 FALSE    2245mm     IFNE DEBUG
00000CDE                          2246mm     ENDC
00000CDE                          2247mm 
00000CDE                          2248mm     ENDM
00000CDE                          2249m     ENDC
00000CDE                          2250m     ENDM
00000CDE                          2251m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000CDE  41FA 0886               2252m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000CE2  0403 0030               2253m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CE6  C6BC 000000FF           2254m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000CEC  1630 3000               2255m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CF0                          2256m     ENDM
00000CF0  8203                    2257          OR.B D3,D1
00000CF2                          2258      ENDF
00000CF2  5242                    2259s     ADD.W   #1,D2
00000CF4                          2260s _20000009
00000CF4  B47C 0007               2261s     CMP.W   #7,D2
00000CF8  6FB6                    2262s     BLE _20000008
00000CFA                          2263  
00000CFA  3001                    2264      MOVE.W D1,D0                                    ; extract the LSword for the length
00000CFC  E089                    2265      LSR.L #8,D1                                     ; extract the MSword for the address
00000CFE  E089                    2266      LSR.L #8,D1
00000D00                          2267  
00000D00                          2268m     PRINT_CRLF D2,A1
00000D00  43FA 088F               2269m     LEA CRLF(PC),A1
00000D04                          2270mm     PRINT_STR A1,D2
00000D04                          2271mm LOOP_160
00000D04  0C11 0000               2272mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D08  6700 0016               2273mm     BEQ EXIT_160
00000D0C                          2274mmm     PRINT_CHAR (A1)+,D2
00000D0C                          2275mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D0C                 TRUE     2276mmm     IFEQ DEBUG
00000D0C  1439 00C00003           2277mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D12  0802 0002               2278mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D16  67F4                    2279mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000D18  13D9 00C00007           2280mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D1E                          2281mmm     ENDC
00000D1E                          2282mmm 
00000D1E                 FALSE    2283mmm     IFNE DEBUG
00000D1E                          2284mmm     ENDC
00000D1E                          2285mmm 
00000D1E                          2286mmm     ENDM
00000D1E  60E4                    2287mm     BRA LOOP_160
00000D20                          2288mm EXIT_160
00000D20                          2289mm     ENDM
00000D20                          2290m     ENDM
00000D20                          2291  
00000D20  2041                    2292      MOVE.L D1,A0                                    ; target address
00000D22  2641                    2293      MOVE.L D1,A3                                    ; keep a copy for later
00000D24                          2294  
00000D24  2247                    2295      MOVE.L D7,A1                                    ; address accumulator -> address register
00000D26  7E00                    2296      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000D28                          2297  
00000D28                          2298m     UNPROTECT
00000D28  31FC AAAA 2AAA          2299m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000D2E  4E71                    2300m     NOP
00000D30  31FC 5555 1554          2301m     MOVE.W #$5555,$1554
00000D36  4E71                    2302m     NOP
00000D38  31FC 8080 2AAA          2303m     MOVE.W #$8080,$2AAA
00000D3E  4E71                    2304m     NOP
00000D40  31FC AAAA 2AAA          2305m     MOVE.W #$AAAA,$2AAA
00000D46  4E71                    2306m     NOP
00000D48  31FC 5555 1554          2307m     MOVE.W #$5555,$1554
00000D4E  4E71                    2308m     NOP
00000D50  31FC 2020 2AAA          2309m     MOVE.W #$2020,$2AAA
00000D56                          2310m     ENDM
00000D56                          2311  
00000D56  45FA 0825               2312      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000D5A                          2313m     PRINT_STR A2,D2
00000D5A                          2314m LOOP_163
00000D5A  0C12 0000               2315m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D5E  6700 0016               2316m     BEQ EXIT_163
00000D62                          2317mm     PRINT_CHAR (A2)+,D2
00000D62                          2318mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D62                 TRUE     2319mm     IFEQ DEBUG
00000D62  1439 00C00003           2320mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D68  0802 0002               2321mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D6C  67F4                    2322mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000D6E  13DA 00C00007           2323mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D74                          2324mm     ENDC
00000D74                          2325mm 
00000D74                 FALSE    2326mm     IFNE DEBUG
00000D74                          2327mm     ENDC
00000D74                          2328mm 
00000D74                          2329mm     ENDM
00000D74  60E4                    2330m     BRA LOOP_163
00000D76                          2331m EXIT_163
00000D76                          2332m     ENDM
00000D76                          2333  
00000D76  2409                    2334      MOVE.L A1,D2
00000D78                          2335m     PRINT_REG D2,D3,D4,D5,A2
00000D78  45FA 081D               2336m     LEA OX(PC),A2
00000D7C                          2337mm     PRINT_STR A2,D3
00000D7C                          2338mm LOOP_166
00000D7C  0C12 0000               2339mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D80  6700 0016               2340mm     BEQ EXIT_166
00000D84                          2341mmm     PRINT_CHAR (A2)+,D3
00000D84                          2342mmm WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D84                 TRUE     2343mmm     IFEQ DEBUG
00000D84  1639 00C00003           2344mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D8A  0803 0002               2345mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D8E  67F4                    2346mmm         BEQ WAIT_FOR_READY_167                      ; NO SPACE, CHECK AGAIN
00000D90  13DA 00C00007           2347mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D96                          2348mmm     ENDC
00000D96                          2349mmm 
00000D96                 FALSE    2350mmm     IFNE DEBUG
00000D96                          2351mmm     ENDC
00000D96                          2352mmm 
00000D96                          2353mmm     ENDM
00000D96  60E4                    2354mm     BRA LOOP_166
00000D98                          2355mm EXIT_166
00000D98                          2356mm     ENDM
00000D98  7A07                    2357m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D9A                          2358m LOOP_165
00000D9A                          2359mm     BIN2HEX D2,D4,A2
00000D9A  45FA 07BA               2360mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000D9E  E99A                    2361mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DA0  1802                    2362mm     MOVE.B D2,D4
00000DA2  0284 0000000F           2363mm     ANDI.L #$F,D4
00000DA8  1832 4000               2364mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000DAC                          2365mm     ENDM
00000DAC                          2366mm     PRINT_CHAR D4,D3
00000DAC                          2367mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DAC                 TRUE     2368mm     IFEQ DEBUG
00000DAC  1639 00C00003           2369mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DB2  0803 0002               2370mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DB6  67F4                    2371mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000DB8  13C4 00C00007           2372mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DBE                          2373mm     ENDC
00000DBE                          2374mm 
00000DBE                 FALSE    2375mm     IFNE DEBUG
00000DBE                          2376mm     ENDC
00000DBE                          2377mm 
00000DBE                          2378mm     ENDM
00000DBE  57CD FFDA               2379m     DBEQ D5,LOOP_165
00000DC2                          2380m     ENDM
00000DC2                          2381  
00000DC2  45FA 07D6               2382      LEA TO(PC),A2
00000DC6                          2383m     PRINT_STR A2,D3
00000DC6                          2384m LOOP_170
00000DC6  0C12 0000               2385m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DCA  6700 0016               2386m     BEQ EXIT_170
00000DCE                          2387mm     PRINT_CHAR (A2)+,D3
00000DCE                          2388mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DCE                 TRUE     2389mm     IFEQ DEBUG
00000DCE  1639 00C00003           2390mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DD4  0803 0002               2391mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DD8  67F4                    2392mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000DDA  13DA 00C00007           2393mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DE0                          2394mm     ENDC
00000DE0                          2395mm 
00000DE0                 FALSE    2396mm     IFNE DEBUG
00000DE0                          2397mm     ENDC
00000DE0                          2398mm 
00000DE0                          2399mm     ENDM
00000DE0  60E4                    2400m     BRA LOOP_170
00000DE2                          2401m EXIT_170
00000DE2                          2402m     ENDM
00000DE2                          2403  
00000DE2  2408                    2404      MOVE.L A0,D2
00000DE4                          2405m     PRINT_REG D2,D3,D4,D5,A2
00000DE4  45FA 07B1               2406m     LEA OX(PC),A2
00000DE8                          2407mm     PRINT_STR A2,D3
00000DE8                          2408mm LOOP_173
00000DE8  0C12 0000               2409mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DEC  6700 0016               2410mm     BEQ EXIT_173
00000DF0                          2411mmm     PRINT_CHAR (A2)+,D3
00000DF0                          2412mmm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DF0                 TRUE     2413mmm     IFEQ DEBUG
00000DF0  1639 00C00003           2414mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DF6  0803 0002               2415mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DFA  67F4                    2416mmm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
00000DFC  13DA 00C00007           2417mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E02                          2418mmm     ENDC
00000E02                          2419mmm 
00000E02                 FALSE    2420mmm     IFNE DEBUG
00000E02                          2421mmm     ENDC
00000E02                          2422mmm 
00000E02                          2423mmm     ENDM
00000E02  60E4                    2424mm     BRA LOOP_173
00000E04                          2425mm EXIT_173
00000E04                          2426mm     ENDM
00000E04  7A07                    2427m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E06                          2428m LOOP_172
00000E06                          2429mm     BIN2HEX D2,D4,A2
00000E06  45FA 074E               2430mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E0A  E99A                    2431mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E0C  1802                    2432mm     MOVE.B D2,D4
00000E0E  0284 0000000F           2433mm     ANDI.L #$F,D4
00000E14  1832 4000               2434mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E18                          2435mm     ENDM
00000E18                          2436mm     PRINT_CHAR D4,D3
00000E18                          2437mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E18                 TRUE     2438mm     IFEQ DEBUG
00000E18  1639 00C00003           2439mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E1E  0803 0002               2440mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E22  67F4                    2441mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000E24  13C4 00C00007           2442mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E2A                          2443mm     ENDC
00000E2A                          2444mm 
00000E2A                 FALSE    2445mm     IFNE DEBUG
00000E2A                          2446mm     ENDC
00000E2A                          2447mm 
00000E2A                          2448mm     ENDM
00000E2A  57CD FFDA               2449m     DBEQ D5,LOOP_172
00000E2E                          2450m     ENDM
00000E2E                          2451  
00000E2E                          2452m     PRINT_CRLF D3,A2
00000E2E  45FA 0761               2453m     LEA CRLF(PC),A2
00000E32                          2454mm     PRINT_STR A2,D3
00000E32                          2455mm LOOP_178
00000E32  0C12 0000               2456mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E36  6700 0016               2457mm     BEQ EXIT_178
00000E3A                          2458mmm     PRINT_CHAR (A2)+,D3
00000E3A                          2459mmm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3A                 TRUE     2460mmm     IFEQ DEBUG
00000E3A  1639 00C00003           2461mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E40  0803 0002               2462mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E44  67F4                    2463mmm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00000E46  13DA 00C00007           2464mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E4C                          2465mmm     ENDC
00000E4C                          2466mmm 
00000E4C                 FALSE    2467mmm     IFNE DEBUG
00000E4C                          2468mmm     ENDC
00000E4C                          2469mmm 
00000E4C                          2470mmm     ENDM
00000E4C  60E4                    2471mm     BRA LOOP_178
00000E4E                          2472mm EXIT_178
00000E4E                          2473mm     ENDM
00000E4E                          2474m     ENDM
00000E4E                          2475  
00000E4E                          2476      WHILE D0 <GT> #0 DO
00000E4E                          2477s _10000014
00000E4E  B07C 0000               2478s     CMP.W   #0,D0
00000E52  6F00 001C               2479s     BLE _10000015
00000E56  5580                    2480          SUB.L #2,D0
00000E58                          2481  
00000E58  13D1 00E00001           2482          MOVE.B (A1),DISPLAY
00000E5E                          2483m         PROGRAM (A1),(A0),D2
00000E5E  3091                    2484m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000E60                          2485m 
00000E60                          2486m WAIT_FOR_COMPLETE_180
00000E60  3410                    2487m         MOVE.W (A0),D2
00000E62                          2488m 
00000E62                          2489m         IF.W D2 <NE> (A1) THEN
00000E62  B451                    2490ms     CMP.W   (A1),D2
00000E64  6700 0004               2491ms     BEQ _0000000D
00000E68  60F6                    2492m             BRA WAIT_FOR_COMPLETE_180
00000E6A                          2493m         ENDI
00000E6A                          2494ms _0000000D
00000E6A                          2495m         ENDM
00000E6A                          2496  
00000E6A  5488                    2497          ADD.L #2,A0
00000E6C  5489                    2498          ADD.L #2,A1
00000E6E                          2499      ENDW
00000E6E  60DE                    2500s     BRA _10000014
00000E70                          2501s _10000015
00000E70                          2502                                                      ; we're done, can now update the SP and start vector
00000E70                          2503m     PROGRAM #$FFFC, $2, D2                          ; SP
00000E70  31FC FFFC 0002          2504m   MOVE.W #$FFFC,$2                                      ; WRITE THE DATA
00000E76                          2505m 
00000E76                          2506m WAIT_FOR_COMPLETE_181
00000E76  3438 0002               2507m         MOVE.W $2,D2
00000E7A                          2508m 
00000E7A                          2509m         IF.W D2 <NE> #$FFFC THEN
00000E7A  B47C FFFC               2510ms     CMP.W   #$FFFC,D2
00000E7E  6700 0004               2511ms     BEQ _0000000E
00000E82  60F2                    2512m             BRA WAIT_FOR_COMPLETE_181
00000E84                          2513m         ENDI
00000E84                          2514ms _0000000E
00000E84                          2515m         ENDM
00000E84                          2516m     PROGRAM #$002F, $0, D2          
00000E84  31FC 002F 0000          2517m   MOVE.W #$002F,$0                                      ; WRITE THE DATA
00000E8A                          2518m 
00000E8A                          2519m WAIT_FOR_COMPLETE_182
00000E8A  3438 0000               2520m         MOVE.W $0,D2
00000E8E                          2521m 
00000E8E                          2522m         IF.W D2 <NE> #$002F THEN
00000E8E  B47C 002F               2523ms     CMP.W   #$002F,D2
00000E92  6700 0004               2524ms     BEQ _0000000F
00000E96  60F2                    2525m             BRA WAIT_FOR_COMPLETE_182
00000E98                          2526m         ENDI
00000E98                          2527ms _0000000F
00000E98                          2528m         ENDM
00000E98                          2529  
00000E98                          2530m     PROGRAM D1, $6, D2                              ; PC
00000E98  31C1 0006               2531m   MOVE.W D1,$6                                      ; WRITE THE DATA
00000E9C                          2532m 
00000E9C                          2533m WAIT_FOR_COMPLETE_183
00000E9C  3438 0006               2534m         MOVE.W $6,D2
00000EA0                          2535m 
00000EA0                          2536m         IF.W D2 <NE> D1 THEN
00000EA0  B441                    2537ms     CMP.W   D1,D2
00000EA2  6700 0004               2538ms     BEQ _00000010
00000EA6  60F4                    2539m             BRA WAIT_FOR_COMPLETE_183
00000EA8                          2540m         ENDI
00000EA8                          2541ms _00000010
00000EA8                          2542m         ENDM
00000EA8  E089                    2543      LSR.L #8,D1
00000EAA  E089                    2544      LSR.L #8,D1
00000EAC                          2545m     PROGRAM D1, $4, D2
00000EAC  31C1 0004               2546m   MOVE.W D1,$4                                      ; WRITE THE DATA
00000EB0                          2547m 
00000EB0                          2548m WAIT_FOR_COMPLETE_184
00000EB0  3438 0004               2549m         MOVE.W $4,D2
00000EB4                          2550m 
00000EB4                          2551m         IF.W D2 <NE> D1 THEN
00000EB4  B441                    2552ms     CMP.W   D1,D2
00000EB6  6700 0004               2553ms     BEQ _00000011
00000EBA  60F4                    2554m             BRA WAIT_FOR_COMPLETE_184
00000EBC                          2555m         ENDI
00000EBC                          2556ms _00000011
00000EBC                          2557m         ENDM
00000EBC                          2558      
00000EBC  41F9 000012CA           2559      LEA BUS_ERROR_HANDLER,A0                        ; set the bus error handler - this is deliberately not relative to get the offset from $ORG 
00000EC2  43F8 0010               2560      LEA START,A1
00000EC6  D1CB                    2561      ADD.L A3,A0
00000EC8  91C9                    2562      SUB.L A1,A0 
00000ECA  2008                    2563      MOVE.L A0,D0
00000ECC                          2564m     PROGRAM D0, $A, D2                              ; write it
00000ECC  31C0 000A               2565m   MOVE.W D0,$A                                      ; WRITE THE DATA
00000ED0                          2566m 
00000ED0                          2567m WAIT_FOR_COMPLETE_185
00000ED0  3438 000A               2568m         MOVE.W $A,D2
00000ED4                          2569m 
00000ED4                          2570m         IF.W D2 <NE> D0 THEN
00000ED4  B440                    2571ms     CMP.W   D0,D2
00000ED6  6700 0004               2572ms     BEQ _00000012
00000EDA  60F4                    2573m             BRA WAIT_FOR_COMPLETE_185
00000EDC                          2574m         ENDI
00000EDC                          2575ms _00000012
00000EDC                          2576m         ENDM
00000EDC  E088                    2577      LSR.L #8,D0
00000EDE  E088                    2578      LSR.L #8,D0
00000EE0                          2579m     PROGRAM D0, $8, D2
00000EE0  31C0 0008               2580m   MOVE.W D0,$8                                      ; WRITE THE DATA
00000EE4                          2581m 
00000EE4                          2582m WAIT_FOR_COMPLETE_186
00000EE4  3438 0008               2583m         MOVE.W $8,D2
00000EE8                          2584m 
00000EE8                          2585m         IF.W D2 <NE> D0 THEN
00000EE8  B440                    2586ms     CMP.W   D0,D2
00000EEA  6700 0004               2587ms     BEQ _00000013
00000EEE  60F4                    2588m             BRA WAIT_FOR_COMPLETE_186
00000EF0                          2589m         ENDI
00000EF0                          2590ms _00000013
00000EF0                          2591m         ENDM
00000EF0                          2592  
00000EF0  41F9 000012CA           2593      LEA BUS_ERROR_HANDLER,A0                        ; set the bus error handler - this is deliberately not relative to get the offset from $ORG 
00000EF6  43F8 0010               2594      LEA START,A1
00000EFA  D1CB                    2595      ADD.L A3,A0
00000EFC  91C9                    2596      SUB.L A1,A0 
00000EFE  2008                    2597      MOVE.L A0,D0
00000F00                          2598m     PROGRAM D0, $E, D2                              ; write it
00000F00  31C0 000E               2599m   MOVE.W D0,$E                                      ; WRITE THE DATA
00000F04                          2600m 
00000F04                          2601m WAIT_FOR_COMPLETE_187
00000F04  3438 000E               2602m         MOVE.W $E,D2
00000F08                          2603m 
00000F08                          2604m         IF.W D2 <NE> D0 THEN
00000F08  B440                    2605ms     CMP.W   D0,D2
00000F0A  6700 0004               2606ms     BEQ _00000014
00000F0E  60F4                    2607m             BRA WAIT_FOR_COMPLETE_187
00000F10                          2608m         ENDI
00000F10                          2609ms _00000014
00000F10                          2610m         ENDM
00000F10  E088                    2611      LSR.L #8,D0
00000F12  E088                    2612      LSR.L #8,D0
00000F14                          2613m     PROGRAM D0, $C, D2
00000F14  31C0 000C               2614m   MOVE.W D0,$C                                      ; WRITE THE DATA
00000F18                          2615m 
00000F18                          2616m WAIT_FOR_COMPLETE_188
00000F18  3438 000C               2617m         MOVE.W $C,D2
00000F1C                          2618m 
00000F1C                          2619m         IF.W D2 <NE> D0 THEN
00000F1C  B440                    2620ms     CMP.W   D0,D2
00000F1E  6700 0004               2621ms     BEQ _00000015
00000F22  60F4                    2622m             BRA WAIT_FOR_COMPLETE_188
00000F24                          2623m         ENDI
00000F24                          2624ms _00000015
00000F24                          2625m         ENDM
00000F24                          2626                                                          
00000F24                          2627m     PROTECT
00000F24  31FC AAAA 2AAA          2628m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F2A  31FC 5555 1554          2629m     MOVE.W #$5555,$1554
00000F30  31FC A0A0 2AAA          2630m     MOVE.W #$A0A0,$2AAA
00000F36                          2631m     ENDM
00000F36                          2632  
00000F36  6000 F2C2               2633      BRA MAIN_LOOP
00000F3A                          2634  
00000F3A                          2635  P
00000F3A  7000                    2636      MOVE.L #0,D0                                    ; D0 will be the data to write
00000F3C                          2637  
00000F3C                          2638      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000F3C  323C 0000               2639s     MOVE.W  #0,D1
00000F40  6000 0046               2640s     BRA _2000000B
00000F44                          2641s _2000000A
00000F44  E988                    2642          LSL.L #4,D0                                 ; make what we have so far more significant
00000F46                          2643m         WAIT_CHAR D2,D3                             ; next character -> D2
00000F46                          2644m WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F46                 TRUE     2645m     IFEQ DEBUG
00000F46  1639 00C00003           2646m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F4C  0803 0000               2647m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000F50  67F4                    2648m         BEQ WAIT_FOR_READY_190                      ; NOTHING, CHECK AGAIN
00000F52                          2649m     ENDC
00000F52                          2650m 
00000F52                          2651mm     READ_CHAR D2
00000F52                 TRUE     2652mm     IFEQ DEBUG
00000F52  1439 00C00007           2653mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000F58                          2654mm     ENDC
00000F58                 FALSE    2655mm     IFNE DEBUG
00000F58                          2656mm     ENDC
00000F58                          2657mm 
00000F58  B43C 001B               2658mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000F5C  6700 F0B2               2659mm     BEQ START
00000F60                          2660mm     ENDM
00000F60                          2661m 
00000F60                 TRUE     2662m     IFEQ DEBUG
00000F60                          2663mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000F60                          2664mm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F60                 TRUE     2665mm     IFEQ DEBUG
00000F60  1639 00C00003           2666mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F66  0803 0002               2667mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F6A  67F4                    2668mm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00000F6C  13C2 00C00007           2669mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F72                          2670mm     ENDC
00000F72                          2671mm 
00000F72                 FALSE    2672mm     IFNE DEBUG
00000F72                          2673mm     ENDC
00000F72                          2674mm 
00000F72                          2675mm     ENDM
00000F72                          2676m     ENDC
00000F72                          2677m     ENDM
00000F72                          2678m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000F72  41FA 05F2               2679m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000F76  0402 0030               2680m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000F7A  C4BC 000000FF           2681m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000F80  1430 2000               2682m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000F84                          2683m     ENDM
00000F84  8002                    2684          OR.B D2,D0
00000F86                          2685      ENDF
00000F86  5241                    2686s     ADD.W   #1,D1
00000F88                          2687s _2000000B
00000F88  B27C 0003               2688s     CMP.W   #3,D1
00000F8C  6FB6                    2689s     BLE _2000000A
00000F8E                          2690  
00000F8E                          2691m     PRINT_CRLF D2,A1
00000F8E  43FA 0601               2692m     LEA CRLF(PC),A1
00000F92                          2693mm     PRINT_STR A1,D2
00000F92                          2694mm LOOP_195
00000F92  0C11 0000               2695mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F96  6700 0016               2696mm     BEQ EXIT_195
00000F9A                          2697mmm     PRINT_CHAR (A1)+,D2
00000F9A                          2698mmm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F9A                 TRUE     2699mmm     IFEQ DEBUG
00000F9A  1439 00C00003           2700mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000FA0  0802 0002               2701mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000FA4  67F4                    2702mmm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
00000FA6  13D9 00C00007           2703mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FAC                          2704mmm     ENDC
00000FAC                          2705mmm 
00000FAC                 FALSE    2706mmm     IFNE DEBUG
00000FAC                          2707mmm     ENDC
00000FAC                          2708mmm 
00000FAC                          2709mmm     ENDM
00000FAC  60E4                    2710mm     BRA LOOP_195
00000FAE                          2711mm EXIT_195
00000FAE                          2712mm     ENDM
00000FAE                          2713m     ENDM
00000FAE                          2714  
00000FAE  2047                    2715      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000FB0  7E00                    2716      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000FB2                          2717  
00000FB2                          2718m     UNPROTECT
00000FB2  31FC AAAA 2AAA          2719m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000FB8  4E71                    2720m     NOP
00000FBA  31FC 5555 1554          2721m     MOVE.W #$5555,$1554
00000FC0  4E71                    2722m     NOP
00000FC2  31FC 8080 2AAA          2723m     MOVE.W #$8080,$2AAA
00000FC8  4E71                    2724m     NOP
00000FCA  31FC AAAA 2AAA          2725m     MOVE.W #$AAAA,$2AAA
00000FD0  4E71                    2726m     NOP
00000FD2  31FC 5555 1554          2727m     MOVE.W #$5555,$1554
00000FD8  4E71                    2728m     NOP
00000FDA  31FC 2020 2AAA          2729m     MOVE.W #$2020,$2AAA
00000FE0                          2730m     ENDM
00000FE0                          2731               
00000FE0  45FA 059B               2732      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
00000FE4                          2733m     PRINT_STR A2,D2
00000FE4                          2734m LOOP_198
00000FE4  0C12 0000               2735m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FE8  6700 0016               2736m     BEQ EXIT_198
00000FEC                          2737mm     PRINT_CHAR (A2)+,D2
00000FEC                          2738mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FEC                 TRUE     2739mm     IFEQ DEBUG
00000FEC  1439 00C00003           2740mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000FF2  0802 0002               2741mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000FF6  67F4                    2742mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
00000FF8  13DA 00C00007           2743mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FFE                          2744mm     ENDC
00000FFE                          2745mm 
00000FFE                 FALSE    2746mm     IFNE DEBUG
00000FFE                          2747mm     ENDC
00000FFE                          2748mm 
00000FFE                          2749mm     ENDM
00000FFE  60E4                    2750m     BRA LOOP_198
00001000                          2751m EXIT_198
00001000                          2752m     ENDM
00001000                          2753  
00001000                          2754m     PRINT_REG D0,D3,D4,D5,A2
00001000  45FA 0595               2755m     LEA OX(PC),A2
00001004                          2756mm     PRINT_STR A2,D3
00001004                          2757mm LOOP_201
00001004  0C12 0000               2758mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001008  6700 0016               2759mm     BEQ EXIT_201
0000100C                          2760mmm     PRINT_CHAR (A2)+,D3
0000100C                          2761mmm WAIT_FOR_READY_202                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000100C                 TRUE     2762mmm     IFEQ DEBUG
0000100C  1639 00C00003           2763mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001012  0803 0002               2764mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001016  67F4                    2765mmm         BEQ WAIT_FOR_READY_202                      ; NO SPACE, CHECK AGAIN
00001018  13DA 00C00007           2766mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000101E                          2767mmm     ENDC
0000101E                          2768mmm 
0000101E                 FALSE    2769mmm     IFNE DEBUG
0000101E                          2770mmm     ENDC
0000101E                          2771mmm 
0000101E                          2772mmm     ENDM
0000101E  60E4                    2773mm     BRA LOOP_201
00001020                          2774mm EXIT_201
00001020                          2775mm     ENDM
00001020  7A07                    2776m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001022                          2777m LOOP_200
00001022                          2778mm     BIN2HEX D0,D4,A2
00001022  45FA 0532               2779mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001026  E998                    2780mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001028  1800                    2781mm     MOVE.B D0,D4
0000102A  0284 0000000F           2782mm     ANDI.L #$F,D4
00001030  1832 4000               2783mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001034                          2784mm     ENDM
00001034                          2785mm     PRINT_CHAR D4,D3
00001034                          2786mm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001034                 TRUE     2787mm     IFEQ DEBUG
00001034  1639 00C00003           2788mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000103A  0803 0002               2789mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000103E  67F4                    2790mm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001040  13C4 00C00007           2791mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001046                          2792mm     ENDC
00001046                          2793mm 
00001046                 FALSE    2794mm     IFNE DEBUG
00001046                          2795mm     ENDC
00001046                          2796mm 
00001046                          2797mm     ENDM
00001046  57CD FFDA               2798m     DBEQ D5,LOOP_200
0000104A                          2799m     ENDM
0000104A                          2800  
0000104A  45FA 054E               2801      LEA TO(PC),A2
0000104E                          2802m     PRINT_STR A2,D3
0000104E                          2803m LOOP_205
0000104E  0C12 0000               2804m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001052  6700 0016               2805m     BEQ EXIT_205
00001056                          2806mm     PRINT_CHAR (A2)+,D3
00001056                          2807mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001056                 TRUE     2808mm     IFEQ DEBUG
00001056  1639 00C00003           2809mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000105C  0803 0002               2810mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001060  67F4                    2811mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
00001062  13DA 00C00007           2812mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001068                          2813mm     ENDC
00001068                          2814mm 
00001068                 FALSE    2815mm     IFNE DEBUG
00001068                          2816mm     ENDC
00001068                          2817mm 
00001068                          2818mm     ENDM
00001068  60E4                    2819m     BRA LOOP_205
0000106A                          2820m EXIT_205
0000106A                          2821m     ENDM
0000106A                          2822  
0000106A  2408                    2823      MOVE.L A0,D2
0000106C                          2824m     PRINT_REG D2,D3,D4,D5,A2
0000106C  45FA 0529               2825m     LEA OX(PC),A2
00001070                          2826mm     PRINT_STR A2,D3
00001070                          2827mm LOOP_208
00001070  0C12 0000               2828mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001074  6700 0016               2829mm     BEQ EXIT_208
00001078                          2830mmm     PRINT_CHAR (A2)+,D3
00001078                          2831mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001078                 TRUE     2832mmm     IFEQ DEBUG
00001078  1639 00C00003           2833mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000107E  0803 0002               2834mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001082  67F4                    2835mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
00001084  13DA 00C00007           2836mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000108A                          2837mmm     ENDC
0000108A                          2838mmm 
0000108A                 FALSE    2839mmm     IFNE DEBUG
0000108A                          2840mmm     ENDC
0000108A                          2841mmm 
0000108A                          2842mmm     ENDM
0000108A  60E4                    2843mm     BRA LOOP_208
0000108C                          2844mm EXIT_208
0000108C                          2845mm     ENDM
0000108C  7A07                    2846m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000108E                          2847m LOOP_207
0000108E                          2848mm     BIN2HEX D2,D4,A2
0000108E  45FA 04C6               2849mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001092  E99A                    2850mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001094  1802                    2851mm     MOVE.B D2,D4
00001096  0284 0000000F           2852mm     ANDI.L #$F,D4
0000109C  1832 4000               2853mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000010A0                          2854mm     ENDM
000010A0                          2855mm     PRINT_CHAR D4,D3
000010A0                          2856mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010A0                 TRUE     2857mm     IFEQ DEBUG
000010A0  1639 00C00003           2858mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010A6  0803 0002               2859mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010AA  67F4                    2860mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000010AC  13C4 00C00007           2861mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010B2                          2862mm     ENDC
000010B2                          2863mm 
000010B2                 FALSE    2864mm     IFNE DEBUG
000010B2                          2865mm     ENDC
000010B2                          2866mm 
000010B2                          2867mm     ENDM
000010B2  57CD FFDA               2868m     DBEQ D5,LOOP_207
000010B6                          2869m     ENDM
000010B6                          2870  
000010B6                          2871m     PRINT_CRLF D3,A2
000010B6  45FA 04D9               2872m     LEA CRLF(PC),A2
000010BA                          2873mm     PRINT_STR A2,D3
000010BA                          2874mm LOOP_213
000010BA  0C12 0000               2875mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010BE  6700 0016               2876mm     BEQ EXIT_213
000010C2                          2877mmm     PRINT_CHAR (A2)+,D3
000010C2                          2878mmm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010C2                 TRUE     2879mmm     IFEQ DEBUG
000010C2  1639 00C00003           2880mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010C8  0803 0002               2881mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010CC  67F4                    2882mmm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
000010CE  13DA 00C00007           2883mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010D4                          2884mmm     ENDC
000010D4                          2885mmm 
000010D4                 FALSE    2886mmm     IFNE DEBUG
000010D4                          2887mmm     ENDC
000010D4                          2888mmm 
000010D4                          2889mmm     ENDM
000010D4  60E4                    2890mm     BRA LOOP_213
000010D6                          2891mm EXIT_213
000010D6                          2892mm     ENDM
000010D6                          2893m     ENDM
000010D6                          2894  
000010D6                          2895m     PROGRAM D0,(A0),D2
000010D6  3080                    2896m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010D8                          2897m 
000010D8                          2898m WAIT_FOR_COMPLETE_215
000010D8  3410                    2899m         MOVE.W (A0),D2
000010DA                          2900m 
000010DA                          2901m         IF.W D2 <NE> D0 THEN
000010DA  B440                    2902ms     CMP.W   D0,D2
000010DC  6700 0004               2903ms     BEQ _00000016
000010E0  60F6                    2904m             BRA WAIT_FOR_COMPLETE_215
000010E2                          2905m         ENDI
000010E2                          2906ms _00000016
000010E2                          2907m         ENDM
000010E2                          2908  
000010E2                          2909m     PROTECT
000010E2  31FC AAAA 2AAA          2910m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010E8  31FC 5555 1554          2911m     MOVE.W #$5555,$1554
000010EE  31FC A0A0 2AAA          2912m     MOVE.W #$A0A0,$2AAA
000010F4                          2913m     ENDM
000010F4                          2914  
000010F4  6000 F104               2915      BRA MAIN_LOOP
000010F8                          2916      
000010F8                          2917  M
000010F8  7000                    2918      MOVE.L #0,D0                                        ; D0 will be the length to read            
000010FA  7200                    2919      MOVE.L #0,D1                                        ; D1 will be the address to read 
000010FC                          2920  
000010FC                          2921      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
000010FC  343C 0000               2922s     MOVE.W  #0,D2
00001100  6000 0046               2923s     BRA _2000000D
00001104                          2924s _2000000C
00001104  E989                    2925          LSL.L #4,D1                                     ; make what we have so far more significant
00001106                          2926m         WAIT_CHAR D3,D4                                 ; next character -> D2
00001106                          2927m WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001106                 TRUE     2928m     IFEQ DEBUG
00001106  1839 00C00003           2929m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000110C  0804 0000               2930m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001110  67F4                    2931m         BEQ WAIT_FOR_READY_217                      ; NOTHING, CHECK AGAIN
00001112                          2932m     ENDC
00001112                          2933m 
00001112                          2934mm     READ_CHAR D3
00001112                 TRUE     2935mm     IFEQ DEBUG
00001112  1639 00C00007           2936mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001118                          2937mm     ENDC
00001118                 FALSE    2938mm     IFNE DEBUG
00001118                          2939mm     ENDC
00001118                          2940mm 
00001118  B63C 001B               2941mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
0000111C  6700 EEF2               2942mm     BEQ START
00001120                          2943mm     ENDM
00001120                          2944m 
00001120                 TRUE     2945m     IFEQ DEBUG
00001120                          2946mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001120                          2947mm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001120                 TRUE     2948mm     IFEQ DEBUG
00001120  1839 00C00003           2949mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001126  0804 0002               2950mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
0000112A  67F4                    2951mm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
0000112C  13C3 00C00007           2952mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001132                          2953mm     ENDC
00001132                          2954mm 
00001132                 FALSE    2955mm     IFNE DEBUG
00001132                          2956mm     ENDC
00001132                          2957mm 
00001132                          2958mm     ENDM
00001132                          2959m     ENDC
00001132                          2960m     ENDM
00001132                          2961m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
00001132  41FA 0432               2962m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001136  0403 0030               2963m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000113A  C6BC 000000FF           2964m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00001140  1630 3000               2965m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001144                          2966m     ENDM
00001144  8203                    2967          OR.B D3,D1
00001146                          2968      ENDF
00001146  5242                    2969s     ADD.W   #1,D2
00001148                          2970s _2000000D
00001148  B47C 0007               2971s     CMP.W   #7,D2
0000114C  6FB6                    2972s     BLE _2000000C
0000114E                          2973m     PRINT_CRLF D2,A1
0000114E  43FA 0441               2974m     LEA CRLF(PC),A1
00001152                          2975mm     PRINT_STR A1,D2
00001152                          2976mm LOOP_222
00001152  0C11 0000               2977mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001156  6700 0016               2978mm     BEQ EXIT_222
0000115A                          2979mmm     PRINT_CHAR (A1)+,D2
0000115A                          2980mmm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000115A                 TRUE     2981mmm     IFEQ DEBUG
0000115A  1439 00C00003           2982mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001160  0802 0002               2983mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001164  67F4                    2984mmm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
00001166  13D9 00C00007           2985mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000116C                          2986mmm     ENDC
0000116C                          2987mmm 
0000116C                 FALSE    2988mmm     IFNE DEBUG
0000116C                          2989mmm     ENDC
0000116C                          2990mmm 
0000116C                          2991mmm     ENDM
0000116C  60E4                    2992mm     BRA LOOP_222
0000116E                          2993mm EXIT_222
0000116E                          2994mm     ENDM
0000116E                          2995m     ENDM
0000116E                          2996  
0000116E  3001                    2997      MOVE.W D1,D0                                        ; extract the LSword for the length
00001170  E089                    2998      LSR.L #8,D1                                         ; extract the MSword for the address
00001172  E089                    2999      LSR.L #8,D1
00001174                          3000  
00001174  2241                    3001      MOVE.L D1,A1
00001176                          3002      
00001176  2047                    3003      MOVE.L D7,A0                                        ; address accumulator -> target address register
00001178                          3004      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00001178                          3005  
00001178                          3006      WHILE D0 <GT> #0 DO
00001178                          3007s _10000016
00001178  B07C 0000               3008s     CMP.W   #0,D0
0000117C  6F00 000E               3009s     BLE _10000017
00001180  5580                    3010          SUB.L #2,D0
00001182                          3011  
00001182  13D1 00E00001           3012          MOVE.B (A1),DISPLAY
00001188  30D9                    3013          MOVE.W (A1)+,(A0)+
0000118A                          3014      ENDW
0000118A  60EC                    3015s     BRA _10000016
0000118C                          3016s _10000017
0000118C                          3017      
0000118C  6000 F06C               3018      BRA MAIN_LOOP
00001190                          3019  
00001190                          3020  X
00001190  45FA 0412               3021      LEA STATUS_REGISTER(PC),A2
00001194                          3022m     PRINT_STR A2,D3
00001194                          3023m LOOP_224
00001194  0C12 0000               3024m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001198  6700 0016               3025m     BEQ EXIT_224
0000119C                          3026mm     PRINT_CHAR (A2)+,D3
0000119C                          3027mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000119C                 TRUE     3028mm     IFEQ DEBUG
0000119C  1639 00C00003           3029mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011A2  0803 0002               3030mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011A6  67F4                    3031mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
000011A8  13DA 00C00007           3032mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011AE                          3033mm     ENDC
000011AE                          3034mm 
000011AE                 FALSE    3035mm     IFNE DEBUG
000011AE                          3036mm     ENDC
000011AE                          3037mm 
000011AE                          3038mm     ENDM
000011AE  60E4                    3039m     BRA LOOP_224
000011B0                          3040m EXIT_224
000011B0                          3041m     ENDM
000011B0                          3042  
000011B0  40C0                    3043      MOVE SR,D0
000011B2                          3044m     PRINT_REG D0,D3,D4,D5,A2
000011B2  45FA 03E3               3045m     LEA OX(PC),A2
000011B6                          3046mm     PRINT_STR A2,D3
000011B6                          3047mm LOOP_227
000011B6  0C12 0000               3048mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011BA  6700 0016               3049mm     BEQ EXIT_227
000011BE                          3050mmm     PRINT_CHAR (A2)+,D3
000011BE                          3051mmm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011BE                 TRUE     3052mmm     IFEQ DEBUG
000011BE  1639 00C00003           3053mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011C4  0803 0002               3054mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011C8  67F4                    3055mmm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
000011CA  13DA 00C00007           3056mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011D0                          3057mmm     ENDC
000011D0                          3058mmm 
000011D0                 FALSE    3059mmm     IFNE DEBUG
000011D0                          3060mmm     ENDC
000011D0                          3061mmm 
000011D0                          3062mmm     ENDM
000011D0  60E4                    3063mm     BRA LOOP_227
000011D2                          3064mm EXIT_227
000011D2                          3065mm     ENDM
000011D2  7A07                    3066m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011D4                          3067m LOOP_226
000011D4                          3068mm     BIN2HEX D0,D4,A2
000011D4  45FA 0380               3069mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011D8  E998                    3070mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011DA  1800                    3071mm     MOVE.B D0,D4
000011DC  0284 0000000F           3072mm     ANDI.L #$F,D4
000011E2  1832 4000               3073mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011E6                          3074mm     ENDM
000011E6                          3075mm     PRINT_CHAR D4,D3
000011E6                          3076mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011E6                 TRUE     3077mm     IFEQ DEBUG
000011E6  1639 00C00003           3078mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011EC  0803 0002               3079mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011F0  67F4                    3080mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
000011F2  13C4 00C00007           3081mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011F8                          3082mm     ENDC
000011F8                          3083mm 
000011F8                 FALSE    3084mm     IFNE DEBUG
000011F8                          3085mm     ENDC
000011F8                          3086mm 
000011F8                          3087mm     ENDM
000011F8  57CD FFDA               3088m     DBEQ D5,LOOP_226
000011FC                          3089m     ENDM
000011FC                          3090m     PRINT_CRLF D3,A2
000011FC  45FA 0393               3091m     LEA CRLF(PC),A2
00001200                          3092mm     PRINT_STR A2,D3
00001200                          3093mm LOOP_232
00001200  0C12 0000               3094mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001204  6700 0016               3095mm     BEQ EXIT_232
00001208                          3096mmm     PRINT_CHAR (A2)+,D3
00001208                          3097mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001208                 TRUE     3098mmm     IFEQ DEBUG
00001208  1639 00C00003           3099mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000120E  0803 0002               3100mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001212  67F4                    3101mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001214  13DA 00C00007           3102mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000121A                          3103mmm     ENDC
0000121A                          3104mmm 
0000121A                 FALSE    3105mmm     IFNE DEBUG
0000121A                          3106mmm     ENDC
0000121A                          3107mmm 
0000121A                          3108mmm     ENDM
0000121A  60E4                    3109mm     BRA LOOP_232
0000121C                          3110mm EXIT_232
0000121C                          3111mm     ENDM
0000121C                          3112m     ENDM
0000121C                          3113  
0000121C  45FA 0381               3114      LEA STACK_POINTER(PC),A2
00001220                          3115m     PRINT_STR A2,D3
00001220                          3116m LOOP_234
00001220  0C12 0000               3117m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001224  6700 0016               3118m     BEQ EXIT_234
00001228                          3119mm     PRINT_CHAR (A2)+,D3
00001228                          3120mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001228                 TRUE     3121mm     IFEQ DEBUG
00001228  1639 00C00003           3122mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000122E  0803 0002               3123mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001232  67F4                    3124mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
00001234  13DA 00C00007           3125mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000123A                          3126mm     ENDC
0000123A                          3127mm 
0000123A                 FALSE    3128mm     IFNE DEBUG
0000123A                          3129mm     ENDC
0000123A                          3130mm 
0000123A                          3131mm     ENDM
0000123A  60E4                    3132m     BRA LOOP_234
0000123C                          3133m EXIT_234
0000123C                          3134m     ENDM
0000123C                          3135  
0000123C  200F                    3136      MOVE.L SP,D0
0000123E                          3137m     PRINT_REG D0,D3,D4,D5,A2
0000123E  45FA 0357               3138m     LEA OX(PC),A2
00001242                          3139mm     PRINT_STR A2,D3
00001242                          3140mm LOOP_237
00001242  0C12 0000               3141mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001246  6700 0016               3142mm     BEQ EXIT_237
0000124A                          3143mmm     PRINT_CHAR (A2)+,D3
0000124A                          3144mmm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000124A                 TRUE     3145mmm     IFEQ DEBUG
0000124A  1639 00C00003           3146mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001250  0803 0002               3147mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001254  67F4                    3148mmm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
00001256  13DA 00C00007           3149mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000125C                          3150mmm     ENDC
0000125C                          3151mmm 
0000125C                 FALSE    3152mmm     IFNE DEBUG
0000125C                          3153mmm     ENDC
0000125C                          3154mmm 
0000125C                          3155mmm     ENDM
0000125C  60E4                    3156mm     BRA LOOP_237
0000125E                          3157mm EXIT_237
0000125E                          3158mm     ENDM
0000125E  7A07                    3159m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001260                          3160m LOOP_236
00001260                          3161mm     BIN2HEX D0,D4,A2
00001260  45FA 02F4               3162mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001264  E998                    3163mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001266  1800                    3164mm     MOVE.B D0,D4
00001268  0284 0000000F           3165mm     ANDI.L #$F,D4
0000126E  1832 4000               3166mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001272                          3167mm     ENDM
00001272                          3168mm     PRINT_CHAR D4,D3
00001272                          3169mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001272                 TRUE     3170mm     IFEQ DEBUG
00001272  1639 00C00003           3171mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001278  0803 0002               3172mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000127C  67F4                    3173mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
0000127E  13C4 00C00007           3174mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001284                          3175mm     ENDC
00001284                          3176mm 
00001284                 FALSE    3177mm     IFNE DEBUG
00001284                          3178mm     ENDC
00001284                          3179mm 
00001284                          3180mm     ENDM
00001284  57CD FFDA               3181m     DBEQ D5,LOOP_236
00001288                          3182m     ENDM
00001288                          3183m     PRINT_CRLF D3,A2
00001288  45FA 0307               3184m     LEA CRLF(PC),A2
0000128C                          3185mm     PRINT_STR A2,D3
0000128C                          3186mm LOOP_242
0000128C  0C12 0000               3187mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001290  6700 0016               3188mm     BEQ EXIT_242
00001294                          3189mmm     PRINT_CHAR (A2)+,D3
00001294                          3190mmm WAIT_FOR_READY_243                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001294                 TRUE     3191mmm     IFEQ DEBUG
00001294  1639 00C00003           3192mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000129A  0803 0002               3193mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000129E  67F4                    3194mmm         BEQ WAIT_FOR_READY_243                      ; NO SPACE, CHECK AGAIN
000012A0  13DA 00C00007           3195mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012A6                          3196mmm     ENDC
000012A6                          3197mmm 
000012A6                 FALSE    3198mmm     IFNE DEBUG
000012A6                          3199mmm     ENDC
000012A6                          3200mmm 
000012A6                          3201mmm     ENDM
000012A6  60E4                    3202mm     BRA LOOP_242
000012A8                          3203mm EXIT_242
000012A8                          3204mm     ENDM
000012A8                          3205m     ENDM
000012A8                          3206  
000012A8  6000 EF50               3207      BRA MAIN_LOOP
000012AC                          3208  
000012AC                          3209          
000012AC                          3210  HEX_DIGIT
000012AC  E98F                    3211      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000012AE                          3212m     HEX2BIN D2,D2,A0
000012AE  41FA 02B6               3213m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000012B2  0402 0030               3214m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000012B6  C4BC 000000FF           3215m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000012BC  1430 2000               3216m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000012C0                          3217m     ENDM
000012C0  8E02                    3218      OR.B D2,D7  
000012C2  6000 EF56               3219      BRA GET_INPUT
000012C6                          3220  
000012C6  FFFF FFFF               3221      SIMHALT                                             ; halt simulator
000012CA                          3222  
000012CA                          3223  ; exceptions
000012CA                          3224  BUS_ERROR_HANDLER
000012CA                          3225  
000012CA  41FA 02DD               3226      LEA BUS_ERROR(PC),A0
000012CE                          3227m     PRINT_STR A0,D0
000012CE                          3228m LOOP_245
000012CE  0C10 0000               3229m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000012D2  6700 0016               3230m     BEQ EXIT_245
000012D6                          3231mm     PRINT_CHAR (A0)+,D0
000012D6                          3232mm WAIT_FOR_READY_246                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012D6                 TRUE     3233mm     IFEQ DEBUG
000012D6  1039 00C00003           3234mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000012DC  0800 0002               3235mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000012E0  67F4                    3236mm         BEQ WAIT_FOR_READY_246                      ; NO SPACE, CHECK AGAIN
000012E2  13D8 00C00007           3237mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012E8                          3238mm     ENDC
000012E8                          3239mm 
000012E8                 FALSE    3240mm     IFNE DEBUG
000012E8                          3241mm     ENDC
000012E8                          3242mm 
000012E8                          3243mm     ENDM
000012E8  60E4                    3244m     BRA LOOP_245
000012EA                          3245m EXIT_245
000012EA                          3246m     ENDM
000012EA                          3247      
000012EA  222F 0002               3248      MOVE.L 2(SP),D1
000012EE                          3249m     PRINT_REG D1,D2,D3,D4,A0
000012EE  41FA 02A7               3250m     LEA OX(PC),A0
000012F2                          3251mm     PRINT_STR A0,D2
000012F2                          3252mm LOOP_248
000012F2  0C10 0000               3253mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000012F6  6700 0016               3254mm     BEQ EXIT_248
000012FA                          3255mmm     PRINT_CHAR (A0)+,D2
000012FA                          3256mmm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012FA                 TRUE     3257mmm     IFEQ DEBUG
000012FA  1439 00C00003           3258mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001300  0802 0002               3259mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001304  67F4                    3260mmm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
00001306  13D8 00C00007           3261mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000130C                          3262mmm     ENDC
0000130C                          3263mmm 
0000130C                 FALSE    3264mmm     IFNE DEBUG
0000130C                          3265mmm     ENDC
0000130C                          3266mmm 
0000130C                          3267mmm     ENDM
0000130C  60E4                    3268mm     BRA LOOP_248
0000130E                          3269mm EXIT_248
0000130E                          3270mm     ENDM
0000130E  7807                    3271m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001310                          3272m LOOP_247
00001310                          3273mm     BIN2HEX D1,D3,A0
00001310  41FA 0244               3274mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001314  E999                    3275mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001316  1601                    3276mm     MOVE.B D1,D3
00001318  0283 0000000F           3277mm     ANDI.L #$F,D3
0000131E  1630 3000               3278mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001322                          3279mm     ENDM
00001322                          3280mm     PRINT_CHAR D3,D2
00001322                          3281mm WAIT_FOR_READY_251                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001322                 TRUE     3282mm     IFEQ DEBUG
00001322  1439 00C00003           3283mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001328  0802 0002               3284mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000132C  67F4                    3285mm         BEQ WAIT_FOR_READY_251                      ; NO SPACE, CHECK AGAIN
0000132E  13C3 00C00007           3286mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001334                          3287mm     ENDC
00001334                          3288mm 
00001334                 FALSE    3289mm     IFNE DEBUG
00001334                          3290mm     ENDC
00001334                          3291mm 
00001334                          3292mm     ENDM
00001334  57CC FFDA               3293m     DBEQ D4,LOOP_247
00001338                          3294m     ENDM
00001338                          3295  
00001338  41FA 028D               3296      LEA FROM(PC),A0
0000133C                          3297m     PRINT_STR A0,D0
0000133C                          3298m LOOP_252
0000133C  0C10 0000               3299m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001340  6700 0016               3300m     BEQ EXIT_252
00001344                          3301mm     PRINT_CHAR (A0)+,D0
00001344                          3302mm WAIT_FOR_READY_253                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001344                 TRUE     3303mm     IFEQ DEBUG
00001344  1039 00C00003           3304mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000134A  0800 0002               3305mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000134E  67F4                    3306mm         BEQ WAIT_FOR_READY_253                      ; NO SPACE, CHECK AGAIN
00001350  13D8 00C00007           3307mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001356                          3308mm     ENDC
00001356                          3309mm 
00001356                 FALSE    3310mm     IFNE DEBUG
00001356                          3311mm     ENDC
00001356                          3312mm 
00001356                          3313mm     ENDM
00001356  60E4                    3314m     BRA LOOP_252
00001358                          3315m EXIT_252
00001358                          3316m     ENDM
00001358                          3317  
00001358  222F 000A               3318      MOVE.L 10(SP),D1
0000135C                          3319m     PRINT_REG D1,D2,D3,D4,A0
0000135C  41FA 0239               3320m     LEA OX(PC),A0
00001360                          3321mm     PRINT_STR A0,D2
00001360                          3322mm LOOP_255
00001360  0C10 0000               3323mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001364  6700 0016               3324mm     BEQ EXIT_255
00001368                          3325mmm     PRINT_CHAR (A0)+,D2
00001368                          3326mmm WAIT_FOR_READY_256                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001368                 TRUE     3327mmm     IFEQ DEBUG
00001368  1439 00C00003           3328mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000136E  0802 0002               3329mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001372  67F4                    3330mmm         BEQ WAIT_FOR_READY_256                      ; NO SPACE, CHECK AGAIN
00001374  13D8 00C00007           3331mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000137A                          3332mmm     ENDC
0000137A                          3333mmm 
0000137A                 FALSE    3334mmm     IFNE DEBUG
0000137A                          3335mmm     ENDC
0000137A                          3336mmm 
0000137A                          3337mmm     ENDM
0000137A  60E4                    3338mm     BRA LOOP_255
0000137C                          3339mm EXIT_255
0000137C                          3340mm     ENDM
0000137C  7807                    3341m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000137E                          3342m LOOP_254
0000137E                          3343mm     BIN2HEX D1,D3,A0
0000137E  41FA 01D6               3344mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001382  E999                    3345mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001384  1601                    3346mm     MOVE.B D1,D3
00001386  0283 0000000F           3347mm     ANDI.L #$F,D3
0000138C  1630 3000               3348mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001390                          3349mm     ENDM
00001390                          3350mm     PRINT_CHAR D3,D2
00001390                          3351mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001390                 TRUE     3352mm     IFEQ DEBUG
00001390  1439 00C00003           3353mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001396  0802 0002               3354mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000139A  67F4                    3355mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
0000139C  13C3 00C00007           3356mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000013A2                          3357mm     ENDC
000013A2                          3358mm 
000013A2                 FALSE    3359mm     IFNE DEBUG
000013A2                          3360mm     ENDC
000013A2                          3361mm 
000013A2                          3362mm     ENDM
000013A2  57CC FFDA               3363m     DBEQ D4,LOOP_254
000013A6                          3364m     ENDM
000013A6                          3365m     PRINT_CRLF D0,A0
000013A6  41FA 01E9               3366m     LEA CRLF(PC),A0
000013AA                          3367mm     PRINT_STR A0,D0
000013AA                          3368mm LOOP_260
000013AA  0C10 0000               3369mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000013AE  6700 0016               3370mm     BEQ EXIT_260
000013B2                          3371mmm     PRINT_CHAR (A0)+,D0
000013B2                          3372mmm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013B2                 TRUE     3373mmm     IFEQ DEBUG
000013B2  1039 00C00003           3374mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000013B8  0800 0002               3375mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000013BC  67F4                    3376mmm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000013BE  13D8 00C00007           3377mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013C4                          3378mmm     ENDC
000013C4                          3379mmm 
000013C4                 FALSE    3380mmm     IFNE DEBUG
000013C4                          3381mmm     ENDC
000013C4                          3382mmm 
000013C4                          3383mmm     ENDM
000013C4  60E4                    3384mm     BRA LOOP_260
000013C6                          3385mm EXIT_260
000013C6                          3386mm     ENDM
000013C6                          3387m     ENDM
000013C6                          3388      
000013C6  2078 0004               3389      MOVE.L 4,A0
000013CA  4ED0                    3390      JMP (A0)
000013CC                          3391          
000013CC                          3392  ; strings
000013CC= 50 72 65 73 73 20 ...   3393  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
000013DF= 5B 3F 5D 09 09 09 ...   3394  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
000013EB= 5B 76 5D 09 09 09 ...   3395          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
000013FA= 78 78 78 78 78 78 ...   3396          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001412= 78 78 78 78 78 78 ...   3397          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001432= 78 78 78 78 78 78 ...   3398          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001453= 78 78 78 78 78 78 ...   3399          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001464= 5B 7A 5D 09 09 09 ...   3400          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001476= 78 78 78 78 78 78 ...   3401          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001497= 78 78 78 78 78 78 ...   3402          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000014B6= 78 78 78 78 78 78 ...   3403          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
000014DA= 5B 78 5D 09 09 09 ...   3404          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF,NULL
000014F2= 48 75 68 3F 0D 0A 00    3405  HUH  DC.B 'Huh?',CR,LF,NULL
000014F9= 20 53 20 72 65 63 ...   3406  READ    DC.B ' S records read, start address = ',NULL
0000151B= 57 3A 20 55 6E 6B ...   3407  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001532= 57 3A 20 43 53 20 ...   3408  CS_FAILURE  DC.B 'W: CS failure at ',NULL
00001544= 57 3A 20 52 41 4D ...   3409  RAM_ERROR   DC.B 'W: RAM error at: ',NULL
00001556= 30 31 32 33 34 35 ...   3410  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001566= 00 01 02 03 04 05 ...   3411  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
0000157D= 4C 6F 61 64 69 6E ...   3412  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001591= 0D 0A 00                3413  CRLF    DC.B CR,LF,NULL
00001594= 3E 20 00                3414  PROMPT  DC.B '> ',NULL
00001597= 30 78 00                3415  ox      DC.B '0x',NULL
0000159A= 20 2D 3E 20 00          3416  to      DC.B ' -> ',NULL
0000159F= 53 50 3A 20 00          3417  STACK_POINTER DC.B 'SP: ',NULL
000015A4= 53 52 3A 20 00          3418  STATUS_REGISTER DC.B 'SR: ',NULL
000015A9= 42 75 73 2F 61 64 ...   3419  BUS_ERROR DC.B 'Bus/address error at address ',NULL 
000015C7= 20 66 72 6F 6D 20 00    3420  FROM DC.B ' from ',NULL
000015CE= 4D 44 46 2D 6D 6F ...   3421  VERSION DC.B 'MDF-mon V1.101 (25/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
000015EC= 00                      3422  END     DC.B 0
000015ED                          3423      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1556
BUS_ERROR           15A9
BUS_ERROR_HANDLER   12CA
CONTINUE_113        9CA
CONTINUE_54         4A6
CONTINUE_57         4F6
CONTINUE_61         54C
CONTINUE_69         600
CONTINUE_74         672
CONTINUE_79         6EE
CONTINUE_84         76C
CONTINUE_89         7F4
CONTINUE_94         866
CONTINUE_99         8D8
CR                  D
CRLF                1591
CS_FAILURE          1532
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       AD4
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 15EC
EXIT_10             166
EXIT_104            94A
EXIT_106            96A
EXIT_110            99C
EXIT_118            A32
EXIT_120            A5A
EXIT_123            A7A
EXIT_128            AC4
EXIT_131            AF4
EXIT_135            B3E
EXIT_138            B60
EXIT_143            BAA
EXIT_145            C26
EXIT_148            C4A
EXIT_15             1B0
EXIT_153            C94
EXIT_160            D20
EXIT_163            D76
EXIT_166            D98
EXIT_17             1D0
EXIT_170            DE2
EXIT_173            E04
EXIT_178            E4E
EXIT_195            FAE
EXIT_198            1000
EXIT_20             1F0
EXIT_201            1020
EXIT_205            106A
EXIT_208            108C
EXIT_213            10D6
EXIT_22             21A
EXIT_222            116E
EXIT_224            11B0
EXIT_227            11D2
EXIT_232            121C
EXIT_234            123C
EXIT_237            125E
EXIT_242            12A8
EXIT_245            12EA
EXIT_248            130E
EXIT_252            1358
EXIT_255            137C
EXIT_260            13C6
EXIT_28             2AE
EXIT_30             306
EXIT_32             332
EXIT_35             35C
EXIT_45             40A
EXIT_5              11E
EXIT_52             47E
EXIT_66             5BC
EXIT_7              13E
FROM                15C7
G                   BAE
GET_INPUT           21A
H                   30A
HELP                13DF
HELPPROMPT          13CC
HEX2BIN             10B
HEX2BIN_LUT         1566
HEX_DIGIT           12AC
HUH                 14F2
L                   CA4
LF                  A
LOADING             157D
LOOP_10             14A
LOOP_104            92E
LOOP_106            94E
LOOP_110            980
LOOP_118            A16
LOOP_120            A3E
LOOP_122            A7C
LOOP_123            A5E
LOOP_128            AA8
LOOP_130            AF6
LOOP_131            AD8
LOOP_135            B22
LOOP_137            B62
LOOP_138            B44
LOOP_143            B8E
LOOP_145            C0A
LOOP_147            C4C
LOOP_148            C2E
LOOP_15             194
LOOP_153            C78
LOOP_160            D04
LOOP_163            D5A
LOOP_165            D9A
LOOP_166            D7C
LOOP_17             1B4
LOOP_170            DC6
LOOP_172            E06
LOOP_173            DE8
LOOP_178            E32
LOOP_195            F92
LOOP_198            FE4
LOOP_20             1D4
LOOP_200            1022
LOOP_201            1004
LOOP_205            104E
LOOP_207            108E
LOOP_208            1070
LOOP_213            10BA
LOOP_22             1FE
LOOP_222            1152
LOOP_224            1194
LOOP_226            11D4
LOOP_227            11B6
LOOP_232            1200
LOOP_234            1220
LOOP_236            1260
LOOP_237            1242
LOOP_242            128C
LOOP_245            12CE
LOOP_247            1310
LOOP_248            12F2
LOOP_252            133C
LOOP_254            137E
LOOP_255            1360
LOOP_260            13AA
LOOP_28             292
LOOP_30             2EA
LOOP_32             316
LOOP_34             35E
LOOP_35             340
LOOP_45             3EE
LOOP_5              102
LOOP_52             462
LOOP_66             5A0
LOOP_7              122
LOOP_9              168
M                   10F8
MAIN_LOOP           1FA
NULL                0
OX                  1597
P                   F3A
PRINTSTR            316
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROMPT              1594
PROTECT             A40
R                   336
RAM                 200000
RAM_ERROR           1544
READ                14F9
READ_CHAR           62D
READ_DATA_TO_POKE   412
RESET               4
ROM                 0
S                   482
STACK               0
STACK_POINTER       159F
START               10
STATUS_REGISTER     15A4
TAB                 9
TO                  159A
UNPROTECT           979
UNREC               151B
V                   312
VECS                8
VERSION             15CE
W                   40E
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_180  E60
WAIT_FOR_COMPLETE_181  E76
WAIT_FOR_COMPLETE_182  E8A
WAIT_FOR_COMPLETE_183  E9C
WAIT_FOR_COMPLETE_184  EB0
WAIT_FOR_COMPLETE_185  ED0
WAIT_FOR_COMPLETE_186  EE4
WAIT_FOR_COMPLETE_187  F04
WAIT_FOR_COMPLETE_188  F18
WAIT_FOR_COMPLETE_215  10D8
WAIT_FOR_READY_1    BA
WAIT_FOR_READY_101  8F0
WAIT_FOR_READY_105  936
WAIT_FOR_READY_107  956
WAIT_FOR_READY_108  96A
WAIT_FOR_READY_11   152
WAIT_FOR_READY_111  988
WAIT_FOR_READY_113  9AE
WAIT_FOR_READY_115  9E2
WAIT_FOR_READY_119  A1E
WAIT_FOR_READY_121  A46
WAIT_FOR_READY_124  A66
WAIT_FOR_READY_126  A8E
WAIT_FOR_READY_129  AB0
WAIT_FOR_READY_13   17A
WAIT_FOR_READY_132  AE0
WAIT_FOR_READY_134  B08
WAIT_FOR_READY_136  B2A
WAIT_FOR_READY_139  B4C
WAIT_FOR_READY_141  B74
WAIT_FOR_READY_144  B96
WAIT_FOR_READY_146  C12
WAIT_FOR_READY_149  C36
WAIT_FOR_READY_151  C5E
WAIT_FOR_READY_154  C80
WAIT_FOR_READY_155  CB2
WAIT_FOR_READY_157  CCC
WAIT_FOR_READY_16   19C
WAIT_FOR_READY_161  D0C
WAIT_FOR_READY_164  D62
WAIT_FOR_READY_167  D84
WAIT_FOR_READY_169  DAC
WAIT_FOR_READY_171  DCE
WAIT_FOR_READY_174  DF0
WAIT_FOR_READY_176  E18
WAIT_FOR_READY_179  E3A
WAIT_FOR_READY_18   1BC
WAIT_FOR_READY_190  F46
WAIT_FOR_READY_192  F60
WAIT_FOR_READY_196  F9A
WAIT_FOR_READY_199  FEC
WAIT_FOR_READY_2    CE
WAIT_FOR_READY_202  100C
WAIT_FOR_READY_204  1034
WAIT_FOR_READY_206  1056
WAIT_FOR_READY_209  1078
WAIT_FOR_READY_21   1DC
WAIT_FOR_READY_211  10A0
WAIT_FOR_READY_214  10C2
WAIT_FOR_READY_217  1106
WAIT_FOR_READY_219  1120
WAIT_FOR_READY_223  115A
WAIT_FOR_READY_225  119C
WAIT_FOR_READY_228  11BE
WAIT_FOR_READY_23   206
WAIT_FOR_READY_230  11E6
WAIT_FOR_READY_233  1208
WAIT_FOR_READY_235  1228
WAIT_FOR_READY_238  124A
WAIT_FOR_READY_24   21A
WAIT_FOR_READY_240  1272
WAIT_FOR_READY_243  1294
WAIT_FOR_READY_246  12D6
WAIT_FOR_READY_249  12FA
WAIT_FOR_READY_251  1322
WAIT_FOR_READY_253  1344
WAIT_FOR_READY_256  1368
WAIT_FOR_READY_258  1390
WAIT_FOR_READY_26   234
WAIT_FOR_READY_261  13B2
WAIT_FOR_READY_29   29A
WAIT_FOR_READY_3    E2
WAIT_FOR_READY_31   2F2
WAIT_FOR_READY_33   31E
WAIT_FOR_READY_36   348
WAIT_FOR_READY_38   370
WAIT_FOR_READY_39   386
WAIT_FOR_READY_40   39C
WAIT_FOR_READY_41   3B0
WAIT_FOR_READY_42   3C4
WAIT_FOR_READY_43   3D8
WAIT_FOR_READY_46   3F6
WAIT_FOR_READY_47   414
WAIT_FOR_READY_49   42E
WAIT_FOR_READY_53   46A
WAIT_FOR_READY_54   48A
WAIT_FOR_READY_56   4C4
WAIT_FOR_READY_57   4DA
WAIT_FOR_READY_59   50E
WAIT_FOR_READY_6    10A
WAIT_FOR_READY_61   530
WAIT_FOR_READY_63   564
WAIT_FOR_READY_67   5A8
WAIT_FOR_READY_69   5E4
WAIT_FOR_READY_71   618
WAIT_FOR_READY_74   656
WAIT_FOR_READY_76   68A
WAIT_FOR_READY_79   6D2
WAIT_FOR_READY_8    12A
WAIT_FOR_READY_81   706
WAIT_FOR_READY_84   750
WAIT_FOR_READY_86   784
WAIT_FOR_READY_89   7D8
WAIT_FOR_READY_91   80C
WAIT_FOR_READY_94   84A
WAIT_FOR_READY_96   87E
WAIT_FOR_READY_99   8BC
WAIT_FOR_SRECORD    48A
X                   1190
Z                   BB4
_00000000           25A
_00000001           26E
_00000002           5C4
_00000003           9A0
_00000004           5D2
_00000005           7C0
_00000006           736
_00000007           9A0
_00000008           92A
_00000009           9A0
_0000000A           AC8
_0000000B           AD4
_0000000C           C94
_0000000D           E6A
_0000000E           E84
_0000000F           E98
_00000010           EA8
_00000011           EBC
_00000012           EDC
_00000013           EF0
_00000014           F10
_00000015           F24
_00000016           10E2
_10000000           526
_10000001           58E
_10000002           5DA
_10000003           642
_10000004           64C
_10000005           6B4
_10000006           6C8
_10000007           730
_10000008           73A
_10000009           7BA
_1000000A           746
_1000000B           7AE
_1000000C           7CE
_1000000D           836
_1000000E           840
_1000000F           8A8
_10000010           8B2
_10000011           91A
_10000012           9A4
_10000013           A0C
_10000014           E4E
_10000015           E70
_10000016           1178
_10000017           118C
_20000000           36
_20000001           42
_20000002           50
_20000003           5C
_20000004           BC6
_20000005           BD6
_20000006           BF0
_20000007           C96
_20000008           CB0
_20000009           CF4
_2000000A           F44
_2000000B           F88
_2000000C           1104
_2000000D           1148
