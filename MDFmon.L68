00000400 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/04/2021 12:27:13

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00C00000                 22  DUART_BASE          EQU $C00000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000006                 31  DUART_CTUR_         EQU $6
00000000  =00000007                 32  DUART_CTLR_         EQU $7
00000000  =00000008                 33  DUART_MRB_          EQU $8
00000000  =00000009                 34  DUART_CSRB_         EQU $9
00000000  =00000009                 35  DUART_SRB_          EQU $9
00000000  =0000000A                 36  DUART_CRB_          EQU $A
00000000  =0000000B                 37  DUART_TXB_          EQU $B
00000000  =0000000B                 38  DUART_RXB_          EQU $B
00000000  =0000000C                 39  DUART_IVR_          EQU $C
00000000  =0000000D                 40  DUART_OPCR_         EQU $D
00000000  =0000000E                 41  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 42  DUART_RESET_OPR_    EQU $F
00000000                            43  
00000000  =00C00001                 44  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 45  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 46  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 47  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 48  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 49  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            50  
00000000  =00C00011                 51  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 52  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 53  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 54  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 55  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 56  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            57  
00000000  =00C00009                 58  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 59  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 60  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 61  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 62  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 63  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 64  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 65  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            66  
00000000  =00E00000                 67  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 68  DISPLAY_            EQU $0
00000000  =00E00001                 69  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            77      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78      MOVE.B \1,\2
00000000                            79      ANDI.L #$F,\2
00000000                            80      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            81      ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            88      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            89      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            90      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           100          BTST #2,\2                                  ; check for space to send
00000000                           101          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           102          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           103      ENDC
00000000                           104  
00000000                           105      IFNE DEBUG
00000000                           106          MOVE.B \1,D1
00000000                           107          MOVE.L #6,D0   
00000000                           108          TRAP #15                                    ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll, /2 = working address register
00000000                           115  PRINT_CRLF MACRO
00000000                           116      LEA CRLF(PC),\2
00000000                           117      PRINT_STR \2,\1
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      BRA LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           133  PRINT_REG MACRO
00000000                           134      LEA ox(PC),\5
00000000                           135      PRINT_STR \5,\2
00000000                           136      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142  
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           148      IFEQ DEBUG
00000000                           149          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           150          BTST #0,\2                                  ; check for character
00000000                           151          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           152      ENDC
00000000                           153  
00000000                           154      READ_CHAR \1
00000000                           155  
00000000                           156      IFEQ DEBUG
00000000                           157          PRINT_CHAR \1,\2                            ; echo it back
00000000                           158      ENDC
00000000                           159      ENDM
00000000                           160  
00000000                           161  ; read a char from the serial port - assumes that there is one!
00000000                           162  ; \ 1= data register for read char
00000000                           163  ; will stamp on D0 and D1 in debug mode
00000000                           164  READ_CHAR MACRO
00000000                           165      IFEQ DEBUG
00000000                           166          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           167      ENDC
00000000                           168      IFNE DEBUG
00000000                           169          MOVE.L #5,D0    
00000000                           170          TRAP #15                                    ; read from keyboard in simulator
00000000                           171          MOVE.L D1,\1
00000000                           172      ENDC
00000000                           173  
00000000                           174      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           175      BEQ START
00000000                           176      ENDM
00000000                           177  
00000000                           178  
00000000                           179  ; read data from the download serial port
00000000                           180  ; \ 1= data register for read char
00000000                           181  DOWNLOAD MACRO
00000000                           182  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           183  
00000000                           184      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           185      BTST #0,\1                                      ; check for character
00000000                           186      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           187  
00000000                           188      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           189  CONTINUE\@
00000000                           190      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           193      
00000000                           194      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           195      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           196  
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; unprotect the EEPROM
00000000                           200  UNPROTECT MACRO
00000000                           201      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           202      NOP
00000000                           203      MOVE.W #$5555,$1554
00000000                           204      NOP
00000000                           205      MOVE.W #$8080,$2AAA
00000000                           206      NOP
00000000                           207      MOVE.W #$AAAA,$2AAA
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$2020,$2AAA
00000000                           212      ENDM
00000000                           213      
00000000                           214  ; protect the EEPROM
00000000                           215  PROTECT MACRO
00000000                           216      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           217      MOVE.W #$5555,$1554
00000000                           218      MOVE.W #$A0A0,$2AAA
00000000                           219      ENDM
00000000                           220  
00000000                           221  
00000000                           222  ; read two hex digits from the download serial port and convert to a byte
00000000                           223  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           224  DOWNLOAD_BYTE MACRO
00000000                           225      MOVE.B #2,\4
00000000                           226      WHILE.B \4 <GT> 0 DO
00000000                           227          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           228          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           229          PRINT_CHAR \2,\3
00000000                           230          HEX2BIN \2,\2,\6
00000000                           231          OR.B \2,\1
00000000                           232          SUB.B #1,\4
00000000                           233      ENDW
00000000                           234  
00000000                           235      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           236      MOVE.B \1,\2
00000000                           237      ADD.L \1,\5
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; write word to EEPROM
00000000                           242  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           243  PROGRAM MACRO
00000000                           244    MOVE.W \1,\2                                      ; write the data
00000000                           245  
00000000                           246  WAIT_FOR_COMPLETE\@
00000000                           247          MOVE.W \2,\3
00000000                           248  
00000000                           249          IF.W \3 <NE> \1 THEN
00000000                           250              BRA WAIT_FOR_COMPLETE\@
00000000                           251          ENDI
00000000                           252          ENDM
00000000                           253          
00000000                           254  ; program vector to EEPROM
00000000                           255  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           256  PROGRAM_VECTOR MACRO
00000000                           257      ADD.L #2,\2
00000000                           258      PROGRAM \1, (\2), \3                                ; write it
00000000                           259      LSR.L #8,\1
00000000                           260      LSR.L #8,\1
00000000                           261      SUB.L #2,\2
00000000                           262      PROGRAM \1, (\2), \3
00000000                           263      ENDM
00000000                           264  
00000000                           265  
00000000                           266  ; register catalogue
00000000                           267  ; D0 - used for simulator I/O
00000000                           268  ; D1 - used for simulator I/O
00000000                           269  ; D2 - read character
00000000                           270  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           271  ; D6 - working register used in R/W
00000000                           272  ; D7 - address accumulator, reset by download
00000000                           273  ; A0 - address of string to print 
00000000                           274  
00000000                           275  ; start vector
00000000= 002E0000                 276  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000400                 277  RESET   DC.L START                              ; RESET
00000008= 00001978                 278  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 00001978                 279          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001ACC                 280          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 00001ADC                 281          DC.L UNHANDLED_HANDLER
00000018= 00001ADC                 282          DC.L UNHANDLED_HANDLER
0000001C= 00001ADC                 283          DC.L UNHANDLED_HANDLER
00000020= 00001ADC                 284          DC.L UNHANDLED_HANDLER
00000024= 00001ADC                 285          DC.L UNHANDLED_HANDLER
00000028= 00001ADC                 286          DC.L UNHANDLED_HANDLER
0000002C= 00001ADC                 287          DC.L UNHANDLED_HANDLER
00000030= 00001ADC                 288          DC.L UNHANDLED_HANDLER
00000034= 00001ADC                 289          DC.L UNHANDLED_HANDLER
00000038= 00001ADC                 290          DC.L UNHANDLED_HANDLER
0000003C= 00001ADC                 291          DC.L UNHANDLED_HANDLER
00000040= 00001ADC                 292          DC.L UNHANDLED_HANDLER
00000044= 00001ADC                 293          DC.L UNHANDLED_HANDLER
00000048= 00001ADC                 294          DC.L UNHANDLED_HANDLER
0000004C= 00001ADC                 295          DC.L UNHANDLED_HANDLER
00000050= 00001ADC                 296          DC.L UNHANDLED_HANDLER
00000054= 00001ADC                 297          DC.L UNHANDLED_HANDLER
00000058= 00001ADC                 298          DC.L UNHANDLED_HANDLER
0000005C= 00001ADC                 299          DC.L UNHANDLED_HANDLER
00000060= 00001B20                 300          DC.L SPURIOUS_HANDLER
00000064= 00001ADC                 301          DC.L UNHANDLED_HANDLER
00000068= 00001ADC                 302          DC.L UNHANDLED_HANDLER
0000006C= 00001ADC                 303          DC.L UNHANDLED_HANDLER
00000070= 00001ADC                 304          DC.L UNHANDLED_HANDLER
00000074= 00001ADC                 305          DC.L UNHANDLED_HANDLER
00000078= 00001ADC                 306          DC.L UNHANDLED_HANDLER
0000007C= 00001ADC                 307          DC.L UNHANDLED_HANDLER
00000080= 00001ADC                 308          DC.L UNHANDLED_HANDLER
00000084= 00001ADC                 309          DC.L UNHANDLED_HANDLER
00000088= 00001ADC                 310          DC.L UNHANDLED_HANDLER
0000008C= 00001ADC                 311          DC.L UNHANDLED_HANDLER
00000090= 00001ADC                 312          DC.L UNHANDLED_HANDLER
00000094= 00001ADC                 313          DC.L UNHANDLED_HANDLER
00000098= 00001ADC                 314          DC.L UNHANDLED_HANDLER
0000009C= 00001ADC                 315          DC.L UNHANDLED_HANDLER
000000A0= 00001ADC                 316          DC.L UNHANDLED_HANDLER
000000A4= 00001ADC                 317          DC.L UNHANDLED_HANDLER
000000A8= 00001ADC                 318          DC.L UNHANDLED_HANDLER
000000AC= 00001ADC                 319          DC.L UNHANDLED_HANDLER
000000B0= 00001ADC                 320          DC.L UNHANDLED_HANDLER
000000B4= 00001ADC                 321          DC.L UNHANDLED_HANDLER
000000B8= 00001ADC                 322          DC.L UNHANDLED_HANDLER
000000BC= 00001ADC                 323          DC.L UNHANDLED_HANDLER
000000C0= 00001ADC                 324          DC.L UNHANDLED_HANDLER
000000C4= 00001ADC                 325          DC.L UNHANDLED_HANDLER
000000C8= 00001ADC                 326          DC.L UNHANDLED_HANDLER
000000CC= 00001ADC                 327          DC.L UNHANDLED_HANDLER
000000D0= 00001ADC                 328          DC.L UNHANDLED_HANDLER
000000D4= 00001ADC                 329          DC.L UNHANDLED_HANDLER
000000D8= 00001ADC                 330          DC.L UNHANDLED_HANDLER 
000000DC= 00001ADC                 331          DC.L UNHANDLED_HANDLER
000000E0= 00001ADC                 332          DC.L UNHANDLED_HANDLER
000000E4= 00001ADC                 333          DC.L UNHANDLED_HANDLER 
000000E8= 00001ADC                 334          DC.L UNHANDLED_HANDLER 
000000EC= 00001ADC                 335          DC.L UNHANDLED_HANDLER
000000F0= 00001ADC                 336          DC.L UNHANDLED_HANDLER 
000000F4= 00001ADC                 337          DC.L UNHANDLED_HANDLER 
000000F8= 00001ADC                 338          DC.L UNHANDLED_HANDLER 
000000FC= 00001ADC                 339          DC.L UNHANDLED_HANDLER
00000100= 00001B42                 340  USER    DC.L TICK_HANDLER
00000104= 00001ADC                 341          DC.L UNHANDLED_HANDLER 
00000108= 00001ADC                 342          DC.L UNHANDLED_HANDLER 
0000010C= 00001ADC                 343          DC.L UNHANDLED_HANDLER 
00000110= 00001ADC                 344          DC.L UNHANDLED_HANDLER 
00000114= 00001ADC                 345          DC.L UNHANDLED_HANDLER 
00000118= 00001ADC                 346          DC.L UNHANDLED_HANDLER 
0000011C= 00001ADC                 347          DC.L UNHANDLED_HANDLER
00000120= 00001ADC                 348          DC.L UNHANDLED_HANDLER
00000124= 00001ADC                 349          DC.L UNHANDLED_HANDLER
00000128= 00001ADC                 350          DC.L UNHANDLED_HANDLER
0000012C= 00001ADC                 351          DC.L UNHANDLED_HANDLER
00000130= 00001ADC                 352          DC.L UNHANDLED_HANDLER
00000134= 00001ADC                 353          DC.L UNHANDLED_HANDLER
00000138= 00001ADC                 354          DC.L UNHANDLED_HANDLER
0000013C= 00001ADC                 355          DC.L UNHANDLED_HANDLER
00000140= 00001ADC                 356          DC.L UNHANDLED_HANDLER
00000144= 00001ADC                 357          DC.L UNHANDLED_HANDLER
00000148= 00001ADC                 358          DC.L UNHANDLED_HANDLER
0000014C= 00001ADC                 359          DC.L UNHANDLED_HANDLER
00000150= 00001ADC                 360          DC.L UNHANDLED_HANDLER
00000154= 00001ADC                 361          DC.L UNHANDLED_HANDLER
00000158= 00001ADC                 362          DC.L UNHANDLED_HANDLER
0000015C= 00001ADC                 363          DC.L UNHANDLED_HANDLER
00000160= 00001ADC                 364          DC.L UNHANDLED_HANDLER
00000164= 00001ADC                 365          DC.L UNHANDLED_HANDLER
00000168= 00001ADC                 366          DC.L UNHANDLED_HANDLER
0000016C= 00001ADC                 367          DC.L UNHANDLED_HANDLER
00000170= 00001ADC                 368          DC.L UNHANDLED_HANDLER
00000174= 00001ADC                 369          DC.L UNHANDLED_HANDLER
00000178= 00001ADC                 370          DC.L UNHANDLED_HANDLER
0000017C= 00001ADC                 371          DC.L UNHANDLED_HANDLER
00000180= 00001ADC                 372          DC.L UNHANDLED_HANDLER
00000184= 00001ADC                 373          DC.L UNHANDLED_HANDLER
00000188= 00001ADC                 374          DC.L UNHANDLED_HANDLER
0000018C= 00001ADC                 375          DC.L UNHANDLED_HANDLER
00000190= 00001ADC                 376          DC.L UNHANDLED_HANDLER
00000194= 00001ADC                 377          DC.L UNHANDLED_HANDLER
00000198= 00001ADC                 378          DC.L UNHANDLED_HANDLER
0000019C= 00001ADC                 379          DC.L UNHANDLED_HANDLER
000001A0= 00001ADC                 380          DC.L UNHANDLED_HANDLER
000001A4= 00001ADC                 381          DC.L UNHANDLED_HANDLER
000001A8= 00001ADC                 382          DC.L UNHANDLED_HANDLER
000001AC= 00001ADC                 383          DC.L UNHANDLED_HANDLER
000001B0= 00001ADC                 384          DC.L UNHANDLED_HANDLER
000001B4= 00001ADC                 385          DC.L UNHANDLED_HANDLER
000001B8= 00001ADC                 386          DC.L UNHANDLED_HANDLER
000001BC= 00001ADC                 387          DC.L UNHANDLED_HANDLER
000001C0= 00001ADC                 388          DC.L UNHANDLED_HANDLER
000001C4= 00001ADC                 389          DC.L UNHANDLED_HANDLER
000001C8= 00001ADC                 390          DC.L UNHANDLED_HANDLER
000001CC= 00001ADC                 391          DC.L UNHANDLED_HANDLER
000001D0= 00001ADC                 392          DC.L UNHANDLED_HANDLER
000001D4= 00001ADC                 393          DC.L UNHANDLED_HANDLER
000001D8= 00001ADC                 394          DC.L UNHANDLED_HANDLER
000001DC= 00001ADC                 395          DC.L UNHANDLED_HANDLER
000001E0= 00001ADC                 396          DC.L UNHANDLED_HANDLER
000001E4= 00001ADC                 397          DC.L UNHANDLED_HANDLER
000001E8= 00001ADC                 398          DC.L UNHANDLED_HANDLER
000001EC= 00001ADC                 399          DC.L UNHANDLED_HANDLER
000001F0= 00001ADC                 400          DC.L UNHANDLED_HANDLER
000001F4= 00001ADC                 401          DC.L UNHANDLED_HANDLER
000001F8= 00001ADC                 402          DC.L UNHANDLED_HANDLER
000001FC= 00001ADC                 403          DC.L UNHANDLED_HANDLER
00000200= 00001ADC                 404          DC.L UNHANDLED_HANDLER
00000204= 00001ADC                 405          DC.L UNHANDLED_HANDLER
00000208= 00001ADC                 406          DC.L UNHANDLED_HANDLER
0000020C= 00001ADC                 407          DC.L UNHANDLED_HANDLER
00000210= 00001ADC                 408          DC.L UNHANDLED_HANDLER
00000214= 00001ADC                 409          DC.L UNHANDLED_HANDLER
00000218= 00001ADC                 410          DC.L UNHANDLED_HANDLER
0000021C= 00001ADC                 411          DC.L UNHANDLED_HANDLER
00000220= 00001ADC                 412          DC.L UNHANDLED_HANDLER
00000224= 00001ADC                 413          DC.L UNHANDLED_HANDLER
00000228= 00001ADC                 414          DC.L UNHANDLED_HANDLER
0000022C= 00001ADC                 415          DC.L UNHANDLED_HANDLER
00000230= 00001ADC                 416          DC.L UNHANDLED_HANDLER
00000234= 00001ADC                 417          DC.L UNHANDLED_HANDLER
00000238= 00001ADC                 418          DC.L UNHANDLED_HANDLER
0000023C= 00001ADC                 419          DC.L UNHANDLED_HANDLER
00000240= 00001ADC                 420          DC.L UNHANDLED_HANDLER
00000244= 00001ADC                 421          DC.L UNHANDLED_HANDLER
00000248= 00001ADC                 422          DC.L UNHANDLED_HANDLER
0000024C= 00001ADC                 423          DC.L UNHANDLED_HANDLER
00000250= 00001ADC                 424          DC.L UNHANDLED_HANDLER
00000254= 00001ADC                 425          DC.L UNHANDLED_HANDLER
00000258= 00001ADC                 426          DC.L UNHANDLED_HANDLER
0000025C= 00001ADC                 427          DC.L UNHANDLED_HANDLER
00000260= 00001ADC                 428          DC.L UNHANDLED_HANDLER
00000264= 00001ADC                 429          DC.L UNHANDLED_HANDLER
00000268= 00001ADC                 430          DC.L UNHANDLED_HANDLER
0000026C= 00001ADC                 431          DC.L UNHANDLED_HANDLER
00000270= 00001ADC                 432          DC.L UNHANDLED_HANDLER
00000274= 00001ADC                 433          DC.L UNHANDLED_HANDLER
00000278= 00001ADC                 434          DC.L UNHANDLED_HANDLER
0000027C= 00001ADC                 435          DC.L UNHANDLED_HANDLER
00000280= 00001ADC                 436          DC.L UNHANDLED_HANDLER
00000284= 00001ADC                 437          DC.L UNHANDLED_HANDLER
00000288= 00001ADC                 438          DC.L UNHANDLED_HANDLER
0000028C= 00001ADC                 439          DC.L UNHANDLED_HANDLER
00000290= 00001ADC                 440          DC.L UNHANDLED_HANDLER
00000294= 00001ADC                 441          DC.L UNHANDLED_HANDLER
00000298= 00001ADC                 442          DC.L UNHANDLED_HANDLER
0000029C= 00001ADC                 443          DC.L UNHANDLED_HANDLER
000002A0= 00001ADC                 444          DC.L UNHANDLED_HANDLER
000002A4= 00001ADC                 445          DC.L UNHANDLED_HANDLER
000002A8= 00001ADC                 446          DC.L UNHANDLED_HANDLER
000002AC= 00001ADC                 447          DC.L UNHANDLED_HANDLER
000002B0= 00001ADC                 448          DC.L UNHANDLED_HANDLER
000002B4= 00001ADC                 449          DC.L UNHANDLED_HANDLER
000002B8= 00001ADC                 450          DC.L UNHANDLED_HANDLER
000002BC= 00001ADC                 451          DC.L UNHANDLED_HANDLER
000002C0= 00001ADC                 452          DC.L UNHANDLED_HANDLER
000002C4= 00001ADC                 453          DC.L UNHANDLED_HANDLER
000002C8= 00001ADC                 454          DC.L UNHANDLED_HANDLER
000002CC= 00001ADC                 455          DC.L UNHANDLED_HANDLER
000002D0= 00001ADC                 456          DC.L UNHANDLED_HANDLER
000002D4= 00001ADC                 457          DC.L UNHANDLED_HANDLER
000002D8= 00001ADC                 458          DC.L UNHANDLED_HANDLER
000002DC= 00001ADC                 459          DC.L UNHANDLED_HANDLER
000002E0= 00001ADC                 460          DC.L UNHANDLED_HANDLER
000002E4= 00001ADC                 461          DC.L UNHANDLED_HANDLER
000002E8= 00001ADC                 462          DC.L UNHANDLED_HANDLER
000002EC= 00001ADC                 463          DC.L UNHANDLED_HANDLER
000002F0= 00001ADC                 464          DC.L UNHANDLED_HANDLER
000002F4= 00001ADC                 465          DC.L UNHANDLED_HANDLER
000002F8= 00001ADC                 466          DC.L UNHANDLED_HANDLER
000002FC= 00001ADC                 467          DC.L UNHANDLED_HANDLER
00000300= 00001ADC                 468          DC.L UNHANDLED_HANDLER
00000304= 00001ADC                 469          DC.L UNHANDLED_HANDLER
00000308= 00001ADC                 470          DC.L UNHANDLED_HANDLER
0000030C= 00001ADC                 471          DC.L UNHANDLED_HANDLER
00000310= 00001ADC                 472          DC.L UNHANDLED_HANDLER
00000314= 00001ADC                 473          DC.L UNHANDLED_HANDLER
00000318= 00001ADC                 474          DC.L UNHANDLED_HANDLER
0000031C= 00001ADC                 475          DC.L UNHANDLED_HANDLER
00000320= 00001ADC                 476          DC.L UNHANDLED_HANDLER
00000324= 00001ADC                 477          DC.L UNHANDLED_HANDLER
00000328= 00001ADC                 478          DC.L UNHANDLED_HANDLER
0000032C= 00001ADC                 479          DC.L UNHANDLED_HANDLER
00000330= 00001ADC                 480          DC.L UNHANDLED_HANDLER
00000334= 00001ADC                 481          DC.L UNHANDLED_HANDLER
00000338= 00001ADC                 482          DC.L UNHANDLED_HANDLER
0000033C= 00001ADC                 483          DC.L UNHANDLED_HANDLER
00000340= 00001ADC                 484          DC.L UNHANDLED_HANDLER
00000344= 00001ADC                 485          DC.L UNHANDLED_HANDLER
00000348= 00001ADC                 486          DC.L UNHANDLED_HANDLER
0000034C= 00001ADC                 487          DC.L UNHANDLED_HANDLER
00000350= 00001ADC                 488          DC.L UNHANDLED_HANDLER
00000354= 00001ADC                 489          DC.L UNHANDLED_HANDLER
00000358= 00001ADC                 490          DC.L UNHANDLED_HANDLER
0000035C= 00001ADC                 491          DC.L UNHANDLED_HANDLER
00000360= 00001ADC                 492          DC.L UNHANDLED_HANDLER
00000364= 00001ADC                 493          DC.L UNHANDLED_HANDLER
00000368= 00001ADC                 494          DC.L UNHANDLED_HANDLER
0000036C= 00001ADC                 495          DC.L UNHANDLED_HANDLER
00000370= 00001ADC                 496          DC.L UNHANDLED_HANDLER
00000374= 00001ADC                 497          DC.L UNHANDLED_HANDLER
00000378= 00001ADC                 498          DC.L UNHANDLED_HANDLER
0000037C= 00001ADC                 499          DC.L UNHANDLED_HANDLER
00000380= 00001ADC                 500          DC.L UNHANDLED_HANDLER
00000384= 00001ADC                 501          DC.L UNHANDLED_HANDLER
00000388= 00001ADC                 502          DC.L UNHANDLED_HANDLER
0000038C= 00001ADC                 503          DC.L UNHANDLED_HANDLER
00000390= 00001ADC                 504          DC.L UNHANDLED_HANDLER
00000394= 00001ADC                 505          DC.L UNHANDLED_HANDLER
00000398= 00001ADC                 506          DC.L UNHANDLED_HANDLER
0000039C= 00001ADC                 507          DC.L UNHANDLED_HANDLER
000003A0= 00001ADC                 508          DC.L UNHANDLED_HANDLER
000003A4= 00001ADC                 509          DC.L UNHANDLED_HANDLER
000003A8= 00001ADC                 510          DC.L UNHANDLED_HANDLER
000003AC= 00001ADC                 511          DC.L UNHANDLED_HANDLER
000003B0= 00001ADC                 512          DC.L UNHANDLED_HANDLER
000003B4= 00001ADC                 513          DC.L UNHANDLED_HANDLER
000003B8= 00001ADC                 514          DC.L UNHANDLED_HANDLER
000003BC= 00001ADC                 515          DC.L UNHANDLED_HANDLER
000003C0= 00001ADC                 516          DC.L UNHANDLED_HANDLER
000003C4= 00001ADC                 517          DC.L UNHANDLED_HANDLER
000003C8= 00001ADC                 518          DC.L UNHANDLED_HANDLER
000003CC= 00001ADC                 519          DC.L UNHANDLED_HANDLER
000003D0= 00001ADC                 520          DC.L UNHANDLED_HANDLER
000003D4= 00001ADC                 521          DC.L UNHANDLED_HANDLER
000003D8= 00001ADC                 522          DC.L UNHANDLED_HANDLER
000003DC= 00001ADC                 523          DC.L UNHANDLED_HANDLER
000003E0= 00001ADC                 524          DC.L UNHANDLED_HANDLER
000003E4= 00001ADC                 525          DC.L UNHANDLED_HANDLER
000003E8= 00001ADC                 526          DC.L UNHANDLED_HANDLER
000003EC= 00001ADC                 527          DC.L UNHANDLED_HANDLER
000003F0= 00001ADC                 528          DC.L UNHANDLED_HANDLER
000003F4= 00001ADC                 529          DC.L UNHANDLED_HANDLER
000003F8= 00001ADC                 530          DC.L UNHANDLED_HANDLER
000003FC= 00001ADC                 531          DC.L UNHANDLED_HANDLER
00000400                           532  ; start of program  
00000400                           533  START
00000400  2E7C 002E0000            534      MOVE.L #STACK_ADDRESS,A7
00000406  13FC 0000 00E00001       535      MOVE.B #0,DISPLAY
0000040E                           536  
0000040E  7000                     537      MOVE.L #0,D0
00000410  1039 00C00019            538      MOVE.B DUART_IVR,D0                             ; warm start?
00000416                           539  
00000416                           540  ; reset the UART in case of warm start
00000416  13FC 000A 00C00005       541      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
0000041E  13FC 000A 00C00015       542      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000426                           543      
00000426                           544      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000426  323C 0050                545s     MOVE.W  #$50,D1
0000042A  6000 000E                546s     BRA _20000001
0000042E                           547s _20000000
0000042E  13C1 00C00005            548          MOVE.B D1,DUART_CRA                         ; reset everyting
00000434  4E71                     549          NOP
00000436                           550      ENDF
00000436  0441 0010                551s     SUB.W   #$10,D1
0000043A                           552s _20000001
0000043A  B27C 0010                553s     CMP.W   #$10,D1
0000043E  6CEE                     554s     BGE _20000000
00000440                           555  
00000440                           556      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000440  323C 0050                557s     MOVE.W  #$50,D1
00000444  6000 000E                558s     BRA _20000003
00000448                           559s _20000002
00000448  13C1 00C00015            560          MOVE.B D1,DUART_CRB                         ; reset everyting
0000044E  4E71                     561          NOP
00000450                           562      ENDF
00000450  0441 0010                563s     SUB.W   #$10,D1
00000454                           564s _20000003
00000454  B27C 0010                565s     CMP.W   #$10,D1
00000458  6CEE                     566s     BGE _20000002
0000045A                           567      
0000045A                           568  ;initialise UART
0000045A  13FC 0000 00C0000B       569      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000462  13FC 00FF 00C0000D       570      MOVE.B #$FF,DUART_CTUR
0000046A  13FC 00FF 00C0000F       571      MOVE.B #$FF,DUART_CTLR
00000472  13FC 0070 00C00009       572      MOVE.B #$70,DUART_ACR
0000047A  13FC 0004 00C0001B       573      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000482                           574  
00000482                           575  ; channel A
00000482  13FC 0013 00C00001       576      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000048A  13FC 0007 00C00001       577      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000492  13FC 0066 00C00003       578      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000049A  13FC 0005 00C00005       579      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000004A2                           580  
000004A2                           581  ; channel B
000004A2  13FC 0013 00C00011       582      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000004AA  13FC 0007 00C00011       583      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000004B2  13FC 0066 00C00013       584      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000004BA  13FC 0005 00C00015       585      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000004C2  13FC 0040 00C00019       586      MOVE.B #64,DUART_IVR
000004CA                           587  
000004CA                           588m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000004CA                           589m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CA                 TRUE      590m     IFEQ DEBUG
000004CA  1239 00C00003            591m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004D0  0801 0002                592m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004D4  67F4                     593m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000004D6  13FC 0000 00C00007       594m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004DE                           595m     ENDC
000004DE                           596m 
000004DE                 FALSE     597m     IFNE DEBUG
000004DE                           598m     ENDC
000004DE                           599m 
000004DE                           600m     ENDM
000004DE                           601m     PRINT_CHAR #0,D1
000004DE                           602m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DE                 TRUE      603m     IFEQ DEBUG
000004DE  1239 00C00003            604m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004E4  0801 0002                605m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004E8  67F4                     606m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000004EA  13FC 0000 00C00007       607m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F2                           608m     ENDC
000004F2                           609m 
000004F2                 FALSE     610m     IFNE DEBUG
000004F2                           611m     ENDC
000004F2                           612m 
000004F2                           613m     ENDM
000004F2                           614m     PRINT_CHAR #0,D1
000004F2                           615m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F2                 TRUE      616m     IFEQ DEBUG
000004F2  1239 00C00003            617m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004F8  0801 0002                618m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004FC  67F4                     619m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000004FE  13FC 0000 00C00007       620m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000506                           621m     ENDC
00000506                           622m 
00000506                 FALSE     623m     IFNE DEBUG
00000506                           624m     ENDC
00000506                           625m 
00000506                           626m     ENDM
00000506                           627      
00000506                           628      IF D0 <EQ> #$0F THEN
00000506  B07C 000F                629s     CMP.W   #$0F,D0
0000050A  6600 002C                630s     BNE _00000000
0000050E  1039 00C00005            631          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000514                           632  
00000514  41FA 1945                633          LEA COLD_START(PC),A0
00000518                           634m         PRINT_STR A0,D0
00000518                           635m LOOP_4
00000518  0C10 0000                636m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000051C  6700 0016                637m     BEQ EXIT_4
00000520                           638mm     PRINT_CHAR (A0)+,D0
00000520                           639mm WAIT_FOR_READY_5                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000520                 TRUE      640mm     IFEQ DEBUG
00000520  1039 00C00003            641mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00000526  0800 0002                642mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000052A  67F4                     643mm         BEQ WAIT_FOR_READY_5                        ; NO SPACE, CHECK AGAIN
0000052C  13D8 00C00007            644mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000532                           645mm     ENDC
00000532                           646mm 
00000532                 FALSE     647mm     IFNE DEBUG
00000532                           648mm     ENDC
00000532                           649mm 
00000532                           650mm     ENDM
00000532  60E4                     651m     BRA LOOP_4
00000534                           652m EXIT_4
00000534                           653m     ENDM
00000534                           654      ELSE
00000534  6000 0022                655s     BRA _00000001
00000538                           656s _00000000
00000538  41FA 1935                657          LEA WARM_START(PC),A0
0000053C                           658m         PRINT_STR A0,D0
0000053C                           659m LOOP_6
0000053C  0C10 0000                660m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000540  6700 0016                661m     BEQ EXIT_6
00000544                           662mm     PRINT_CHAR (A0)+,D0
00000544                           663mm WAIT_FOR_READY_7                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000544                 TRUE      664mm     IFEQ DEBUG
00000544  1039 00C00003            665mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000054A  0800 0002                666mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000054E  67F4                     667mm         BEQ WAIT_FOR_READY_7                        ; NO SPACE, CHECK AGAIN
00000550  13D8 00C00007            668mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000556                           669mm     ENDC
00000556                           670mm 
00000556                 FALSE     671mm     IFNE DEBUG
00000556                           672mm     ENDC
00000556                           673mm 
00000556                           674mm     ENDM
00000556  60E4                     675m     BRA LOOP_6
00000558                           676m EXIT_6
00000558                           677m     ENDM
00000558                           678      ENDI
00000558                           679s _00000001
00000558                           680  
00000558  13FC 0001 00E00001       681      MOVE.B #1,DISPLAY
00000560                           682      
00000560                           683m     PRINT_CRLF D1,A0
00000560  41FA 185B                684m     LEA CRLF(PC),A0
00000564                           685mm     PRINT_STR A0,D1
00000564                           686mm LOOP_9
00000564  0C10 0000                687mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016                688mm     BEQ EXIT_9
0000056C                           689mmm     PRINT_CHAR (A0)+,D1
0000056C                           690mmm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE      691mmm     IFEQ DEBUG
0000056C  1239 00C00003            692mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000572  0801 0002                693mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                     694mmm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007            695mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                           696mmm     ENDC
0000057E                           697mmm 
0000057E                 FALSE     698mmm     IFNE DEBUG
0000057E                           699mmm     ENDC
0000057E                           700mmm 
0000057E                           701mmm     ENDM
0000057E  60E4                     702mm     BRA LOOP_9
00000580                           703mm EXIT_9
00000580                           704mm     ENDM
00000580                           705m     ENDM
00000580  41FA 1901                706      LEA VERSION(PC),A0
00000584                           707m     PRINT_STR A0,D3
00000584                           708m LOOP_11
00000584  0C10 0000                709m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000588  6700 0016                710m     BEQ EXIT_11
0000058C                           711mm     PRINT_CHAR (A0)+,D3
0000058C                           712mm WAIT_FOR_READY_12                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058C                 TRUE      713mm     IFEQ DEBUG
0000058C  1639 00C00003            714mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000592  0803 0002                715mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000596  67F4                     716mm         BEQ WAIT_FOR_READY_12                       ; NO SPACE, CHECK AGAIN
00000598  13D8 00C00007            717mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000059E                           718mm     ENDC
0000059E                           719mm 
0000059E                 FALSE     720mm     IFNE DEBUG
0000059E                           721mm     ENDC
0000059E                           722mm 
0000059E                           723mm     ENDM
0000059E  60E4                     724m     BRA LOOP_11
000005A0                           725m EXIT_11
000005A0                           726m     ENDM
000005A0                           727  
000005A0  41F9 00001EA1            728      LEA END,A0
000005A6  2008                     729      MOVE.L A0,D0
000005A8                           730m     PRINT_REG D0,D1,D2,D3,A0
000005A8  41FA 1819                731m     LEA OX(PC),A0
000005AC                           732mm     PRINT_STR A0,D1
000005AC                           733mm LOOP_14
000005AC  0C10 0000                734mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005B0  6700 0016                735mm     BEQ EXIT_14
000005B4                           736mmm     PRINT_CHAR (A0)+,D1
000005B4                           737mmm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B4                 TRUE      738mmm     IFEQ DEBUG
000005B4  1239 00C00003            739mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000005BA  0801 0002                740mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000005BE  67F4                     741mmm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
000005C0  13D8 00C00007            742mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005C6                           743mmm     ENDC
000005C6                           744mmm 
000005C6                 FALSE     745mmm     IFNE DEBUG
000005C6                           746mmm     ENDC
000005C6                           747mmm 
000005C6                           748mmm     ENDM
000005C6  60E4                     749mm     BRA LOOP_14
000005C8                           750mm EXIT_14
000005C8                           751mm     ENDM
000005C8  7607                     752m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000005CA                           753m LOOP_13
000005CA                           754mm     BIN2HEX D0,D2,A0
000005CA  41FA 1773                755mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005CE  E998                     756mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000005D0  1400                     757mm     MOVE.B D0,D2
000005D2  0282 0000000F            758mm     ANDI.L #$F,D2
000005D8  1430 2000                759mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000005DC                           760mm     ENDM
000005DC                           761mm     PRINT_CHAR D2,D1
000005DC                           762mm WAIT_FOR_READY_17                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005DC                 TRUE      763mm     IFEQ DEBUG
000005DC  1239 00C00003            764mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000005E2  0801 0002                765mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000005E6  67F4                     766mm         BEQ WAIT_FOR_READY_17                       ; NO SPACE, CHECK AGAIN
000005E8  13C2 00C00007            767mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005EE                           768mm     ENDC
000005EE                           769mm 
000005EE                 FALSE     770mm     IFNE DEBUG
000005EE                           771mm     ENDC
000005EE                           772mm 
000005EE                           773mm     ENDM
000005EE  57CB FFDA                774m     DBEQ D3,LOOP_13
000005F2                           775m     ENDM
000005F2                           776m     PRINT_CRLF D1,A0
000005F2  41FA 17C9                777m     LEA CRLF(PC),A0
000005F6                           778mm     PRINT_STR A0,D1
000005F6                           779mm LOOP_19
000005F6  0C10 0000                780mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005FA  6700 0016                781mm     BEQ EXIT_19
000005FE                           782mmm     PRINT_CHAR (A0)+,D1
000005FE                           783mmm WAIT_FOR_READY_20                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005FE                 TRUE      784mmm     IFEQ DEBUG
000005FE  1239 00C00003            785mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000604  0801 0002                786mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000608  67F4                     787mmm         BEQ WAIT_FOR_READY_20                       ; NO SPACE, CHECK AGAIN
0000060A  13D8 00C00007            788mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000610                           789mmm     ENDC
00000610                           790mmm 
00000610                 FALSE     791mmm     IFNE DEBUG
00000610                           792mmm     ENDC
00000610                           793mmm 
00000610                           794mmm     ENDM
00000610  60E4                     795mm     BRA LOOP_19
00000612                           796mm EXIT_19
00000612                           797mm     ENDM
00000612                           798m     ENDM
00000612                           799  
00000612  41FA 1556                800      LEA HELPPROMPT(PC),A0
00000616                           801m     PRINT_STR A0,D3
00000616                           802m LOOP_21
00000616  0C10 0000                803m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000061A  6700 0016                804m     BEQ EXIT_21
0000061E                           805mm     PRINT_CHAR (A0)+,D3
0000061E                           806mm WAIT_FOR_READY_22                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000061E                 TRUE      807mm     IFEQ DEBUG
0000061E  1639 00C00003            808mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000624  0803 0002                809mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000628  67F4                     810mm         BEQ WAIT_FOR_READY_22                       ; NO SPACE, CHECK AGAIN
0000062A  13D8 00C00007            811mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000630                           812mm     ENDC
00000630                           813mm 
00000630                 FALSE     814mm     IFNE DEBUG
00000630                           815mm     ENDC
00000630                           816mm 
00000630                           817mm     ENDM
00000630  60E4                     818m     BRA LOOP_21
00000632                           819m EXIT_21
00000632                           820m     ENDM
00000632                           821  
00000632                           822m     PRINT_CRLF D3,A0
00000632  41FA 1789                823m     LEA CRLF(PC),A0
00000636                           824mm     PRINT_STR A0,D3
00000636                           825mm LOOP_24
00000636  0C10 0000                826mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000063A  6700 0016                827mm     BEQ EXIT_24
0000063E                           828mmm     PRINT_CHAR (A0)+,D3
0000063E                           829mmm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063E                 TRUE      830mmm     IFEQ DEBUG
0000063E  1639 00C00003            831mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000644  0803 0002                832mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000648  67F4                     833mmm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
0000064A  13D8 00C00007            834mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000650                           835mmm     ENDC
00000650                           836mmm 
00000650                 FALSE     837mmm     IFNE DEBUG
00000650                           838mmm     ENDC
00000650                           839mmm 
00000650                           840mmm     ENDM
00000650  60E4                     841mm     BRA LOOP_24
00000652                           842mm EXIT_24
00000652                           843mm     ENDM
00000652                           844m     ENDM
00000652                           845  
00000652  7E00                     846      MOVE.L #0,D7                                    ; address accumulator
00000654                           847  
00000654  13FC 0002 00E00001       848      MOVE.B #2,DISPLAY
0000065C                           849      
0000065C                           850  MAIN_LOOP
0000065C  41FA 1762                851      LEA PROMPT(PC),A0
00000660                           852m     PRINT_STR A0,D3
00000660                           853m LOOP_26
00000660  0C10 0000                854m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000664  6700 0016                855m     BEQ EXIT_26
00000668                           856mm     PRINT_CHAR (A0)+,D3
00000668                           857mm WAIT_FOR_READY_27                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000668                 TRUE      858mm     IFEQ DEBUG
00000668  1639 00C00003            859mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000066E  0803 0002                860mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000672  67F4                     861mm         BEQ WAIT_FOR_READY_27                       ; NO SPACE, CHECK AGAIN
00000674  13D8 00C00007            862mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000067A                           863mm     ENDC
0000067A                           864mm 
0000067A                 FALSE     865mm     IFNE DEBUG
0000067A                           866mm     ENDC
0000067A                           867mm 
0000067A                           868mm     ENDM
0000067A  60E4                     869m     BRA LOOP_26
0000067C                           870m EXIT_26
0000067C                           871m     ENDM
0000067C                           872  
0000067C                           873  GET_INPUT
0000067C                           874m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000067C                           875m WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000067C                 TRUE      876m     IFEQ DEBUG
0000067C  1639 00C00003            877m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000682  0803 0000                878m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000686  67F4                     879m         BEQ WAIT_FOR_READY_28                       ; NOTHING, CHECK AGAIN
00000688                           880m     ENDC
00000688                           881m 
00000688                           882mm     READ_CHAR D2
00000688                 TRUE      883mm     IFEQ DEBUG
00000688  1439 00C00007            884mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000068E                           885mm     ENDC
0000068E                 FALSE     886mm     IFNE DEBUG
0000068E                           887mm     ENDC
0000068E                           888mm 
0000068E  B43C 001B                889mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000692  6700 FD6C                890mm     BEQ START
00000696                           891mm     ENDM
00000696                           892m 
00000696                 TRUE      893m     IFEQ DEBUG
00000696                           894mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000696                           895mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000696                 TRUE      896mm     IFEQ DEBUG
00000696  1639 00C00003            897mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000069C  0803 0002                898mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000006A0  67F4                     899mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000006A2  13C2 00C00007            900mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006A8                           901mm     ENDC
000006A8                           902mm 
000006A8                 FALSE     903mm     IFNE DEBUG
000006A8                           904mm     ENDC
000006A8                           905mm 
000006A8                           906mm     ENDM
000006A8                           907m     ENDC
000006A8                           908m     ENDM
000006A8                           909  
000006A8                           910      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000006A8  B43C 0030                911s     CMP.B   #'0',D2
000006AC  6D00 000E                912s     BLT _00000002
000006B0  B43C 0039                913s     CMP.B   #'9',D2
000006B4  6E00 0006                914s     BGT _00000002
000006B8  6000 12A0                915          BRA HEX_DIGIT
000006BC                           916      ENDI
000006BC                           917s _00000002
000006BC                           918      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000006BC  B43C 0041                919s     CMP.B   #'A',D2
000006C0  6D00 000E                920s     BLT _00000003
000006C4  B43C 0046                921s     CMP.B   #'F',D2
000006C8  6E00 0006                922s     BGT _00000003
000006CC  6000 128C                923          BRA HEX_DIGIT
000006D0                           924      ENDI
000006D0                           925s _00000003
000006D0                           926  
000006D0  B43C 0077                927      CMP.B #'w',D2
000006D4  6700 01B2                928      BEQ W
000006D8                           929  
000006D8  B43C 006C                930      CMP.B #'l',D2
000006DC  6700 0A48                931      BEQ L 
000006E0                           932  
000006E0  B43C 0070                933      CMP.B #'p',D2
000006E4  6700 0EBA                934      BEQ P
000006E8                           935  
000006E8  B43C 006D                936      CMP.B #'m',D2
000006EC  6700 1082                937      BEQ M
000006F0                           938  
000006F0                           939m     PRINT_CRLF D3,A0
000006F0  41FA 16CB                940m     LEA CRLF(PC),A0
000006F4                           941mm     PRINT_STR A0,D3
000006F4                           942mm LOOP_32
000006F4  0C10 0000                943mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000006F8  6700 0016                944mm     BEQ EXIT_32
000006FC                           945mmm     PRINT_CHAR (A0)+,D3
000006FC                           946mmm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006FC                 TRUE      947mmm     IFEQ DEBUG
000006FC  1639 00C00003            948mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000702  0803 0002                949mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000706  67F4                     950mmm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000708  13D8 00C00007            951mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000070E                           952mmm     ENDC
0000070E                           953mmm 
0000070E                 FALSE     954mmm     IFNE DEBUG
0000070E                           955mmm     ENDC
0000070E                           956mmm 
0000070E                           957mmm     ENDM
0000070E  60E4                     958mm     BRA LOOP_32
00000710                           959mm EXIT_32
00000710                           960mm     ENDM
00000710                           961m     ENDM
00000710                           962   
00000710  B43C 003F                963      CMP.B #'?',D2
00000714  6700 006E                964      BEQ H
00000718                           965   
00000718  B43C 0076                966      CMP.B #'v',D2
0000071C  6700 006E                967      BEQ V
00000720                           968      
00000720  B43C 0072                969      CMP.B #'r',D2
00000724  6700 008A                970      BEQ R
00000728                           971  
00000728  B43C 0073                972      CMP.B #'s',D2
0000072C  6700 01D6                973      BEQ S
00000730                           974  
00000730  B43C 0067                975      CMP.B #'g',D2
00000734  6700 08FA                976      BEQ G   
00000738                           977  
00000738  B43C 007A                978      CMP.B #'z',D2
0000073C  6700 08F8                979      BEQ Z   
00000740                           980  
00000740  B43C 0078                981      CMP.B #'x',D2
00000744  6700 10C2                982      BEQ X
00000748                           983  
00000748  B43C 0069                984      CMP.B #'i',D2
0000074C  6700 11D6                985      BEQ I
00000750                           986  
00000750  B43C 006F                987      CMP.B #'o',D2
00000754  6700 11DE                988      BEQ O
00000758                           989  
00000758  B43C 0023                990      CMP.B #'#',D2
0000075C  6700 11E6                991      BEQ HASH
00000760                           992  
00000760  41FA 157B                993      LEA HUH(PC),A0
00000764                           994m     PRINT_STR A0,D3
00000764                           995m LOOP_34
00000764  0C10 0000                996m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000768  6700 0016                997m     BEQ EXIT_34
0000076C                           998mm     PRINT_CHAR (A0)+,D3
0000076C                           999mm WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076C                 TRUE     1000mm     IFEQ DEBUG
0000076C  1639 00C00003           1001mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000772  0803 0002               1002mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000776  67F4                    1003mm         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
00000778  13D8 00C00007           1004mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000077E                          1005mm     ENDC
0000077E                          1006mm 
0000077E                 FALSE    1007mm     IFNE DEBUG
0000077E                          1008mm     ENDC
0000077E                          1009mm 
0000077E                          1010mm     ENDM
0000077E  60E4                    1011m     BRA LOOP_34
00000780                          1012m EXIT_34
00000780                          1013m     ENDM
00000780                          1014  
00000780  6000 FEDA               1015      BRA MAIN_LOOP
00000784                          1016  
00000784                          1017  ; commands
00000784                          1018  H
00000784  41FA 13F7               1019      LEA HELP(PC),A0
00000788  6000 0006               1020      BRA PRINTSTR
0000078C                          1021  
0000078C                          1022  V
0000078C  41FA 16F5               1023      LEA VERSION(PC),A0
00000790                          1024  PRINTSTR
00000790                          1025m     PRINT_STR A0,D3    
00000790                          1026m LOOP_36
00000790  0C10 0000               1027m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000794  6700 0016               1028m     BEQ EXIT_36
00000798                          1029mm     PRINT_CHAR (A0)+,D3
00000798                          1030mm WAIT_FOR_READY_37                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                 TRUE     1031mm     IFEQ DEBUG
00000798  1639 00C00003           1032mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000079E  0803 0002               1033mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007A2  67F4                    1034mm         BEQ WAIT_FOR_READY_37                       ; NO SPACE, CHECK AGAIN
000007A4  13D8 00C00007           1035mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007AA                          1036mm     ENDC
000007AA                          1037mm 
000007AA                 FALSE    1038mm     IFNE DEBUG
000007AA                          1039mm     ENDC
000007AA                          1040mm 
000007AA                          1041mm     ENDM
000007AA  60E4                    1042m     BRA LOOP_36
000007AC                          1043m EXIT_36
000007AC                          1044m     ENDM
000007AC  6000 FEAE               1045      BRA MAIN_LOOP
000007B0                          1046  
000007B0                          1047  R
000007B0  2047                    1048      MOVE.L D7,A0                                    ; address accumulator -> address register
000007B2  7E00                    1049      MOVE.L #0,D7                                    ;clear the now used address accumulator
000007B4  2410                    1050      MOVE.L (A0),D2                                  ; read the memory and print it
000007B6                          1051m     PRINT_REG D2,D3,D4,D5,A0
000007B6  41FA 160B               1052m     LEA OX(PC),A0
000007BA                          1053mm     PRINT_STR A0,D3
000007BA                          1054mm LOOP_39
000007BA  0C10 0000               1055mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000007BE  6700 0016               1056mm     BEQ EXIT_39
000007C2                          1057mmm     PRINT_CHAR (A0)+,D3
000007C2                          1058mmm WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C2                 TRUE     1059mmm     IFEQ DEBUG
000007C2  1639 00C00003           1060mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007C8  0803 0002               1061mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007CC  67F4                    1062mmm         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000007CE  13D8 00C00007           1063mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007D4                          1064mmm     ENDC
000007D4                          1065mmm 
000007D4                 FALSE    1066mmm     IFNE DEBUG
000007D4                          1067mmm     ENDC
000007D4                          1068mmm 
000007D4                          1069mmm     ENDM
000007D4  60E4                    1070mm     BRA LOOP_39
000007D6                          1071mm EXIT_39
000007D6                          1072mm     ENDM
000007D6  7A07                    1073m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000007D8                          1074m LOOP_38
000007D8                          1075mm     BIN2HEX D2,D4,A0
000007D8  41FA 1565               1076mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000007DC  E99A                    1077mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000007DE  1802                    1078mm     MOVE.B D2,D4
000007E0  0284 0000000F           1079mm     ANDI.L #$F,D4
000007E6  1830 4000               1080mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000007EA                          1081mm     ENDM
000007EA                          1082mm     PRINT_CHAR D4,D3
000007EA                          1083mm WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007EA                 TRUE     1084mm     IFEQ DEBUG
000007EA  1639 00C00003           1085mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007F0  0803 0002               1086mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007F4  67F4                    1087mm         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000007F6  13C4 00C00007           1088mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007FC                          1089mm     ENDC
000007FC                          1090mm 
000007FC                 FALSE    1091mm     IFNE DEBUG
000007FC                          1092mm     ENDC
000007FC                          1093mm 
000007FC                          1094mm     ENDM
000007FC  57CD FFDA               1095m     DBEQ D5,LOOP_38
00000800                          1096m     ENDM
00000800                          1097      
00000800                          1098m     PRINT_CHAR #32,D3
00000800                          1099m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000800                 TRUE     1100m     IFEQ DEBUG
00000800  1639 00C00003           1101m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000806  0803 0002               1102m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000080A  67F4                    1103m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000080C  13FC 0020 00C00007      1104m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000814                          1105m     ENDC
00000814                          1106m 
00000814                 FALSE    1107m     IFNE DEBUG
00000814                          1108m     ENDC
00000814                          1109m 
00000814                          1110m     ENDM
00000814                          1111  
00000814  E19A                    1112      ROL.L #8,D2
00000816                          1113m     PRINT_CHAR D2,D3
00000816                          1114m WAIT_FOR_READY_44                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000816                 TRUE     1115m     IFEQ DEBUG
00000816  1639 00C00003           1116m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000081C  0803 0002               1117m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000820  67F4                    1118m         BEQ WAIT_FOR_READY_44                       ; NO SPACE, CHECK AGAIN
00000822  13C2 00C00007           1119m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000828                          1120m     ENDC
00000828                          1121m 
00000828                 FALSE    1122m     IFNE DEBUG
00000828                          1123m     ENDC
00000828                          1124m 
00000828                          1125m     ENDM
00000828  E19A                    1126      ROL.L #8,D2
0000082A                          1127m     PRINT_CHAR D2,D3
0000082A                          1128m WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082A                 TRUE     1129m     IFEQ DEBUG
0000082A  1639 00C00003           1130m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000830  0803 0002               1131m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000834  67F4                    1132m         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
00000836  13C2 00C00007           1133m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000083C                          1134m     ENDC
0000083C                          1135m 
0000083C                 FALSE    1136m     IFNE DEBUG
0000083C                          1137m     ENDC
0000083C                          1138m 
0000083C                          1139m     ENDM
0000083C  E19A                    1140      ROL.L #8,D2
0000083E                          1141m     PRINT_CHAR D2,D3
0000083E                          1142m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083E                 TRUE     1143m     IFEQ DEBUG
0000083E  1639 00C00003           1144m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000844  0803 0002               1145m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000848  67F4                    1146m         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
0000084A  13C2 00C00007           1147m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000850                          1148m     ENDC
00000850                          1149m 
00000850                 FALSE    1150m     IFNE DEBUG
00000850                          1151m     ENDC
00000850                          1152m 
00000850                          1153m     ENDM
00000850  E19A                    1154      ROL.L #8,D2
00000852                          1155m     PRINT_CHAR D2,D3
00000852                          1156m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000852                 TRUE     1157m     IFEQ DEBUG
00000852  1639 00C00003           1158m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000858  0803 0002               1159m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000085C  67F4                    1160m         BEQ WAIT_FOR_READY_47                       ; NO SPACE, CHECK AGAIN
0000085E  13C2 00C00007           1161m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000864                          1162m     ENDC
00000864                          1163m 
00000864                 FALSE    1164m     IFNE DEBUG
00000864                          1165m     ENDC
00000864                          1166m 
00000864                          1167m     ENDM
00000864                          1168  
00000864                          1169m     PRINT_CRLF D3,A0
00000864  41FA 1557               1170m     LEA CRLF(PC),A0
00000868                          1171mm     PRINT_STR A0,D3
00000868                          1172mm LOOP_49
00000868  0C10 0000               1173mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000086C  6700 0016               1174mm     BEQ EXIT_49
00000870                          1175mmm     PRINT_CHAR (A0)+,D3
00000870                          1176mmm WAIT_FOR_READY_50                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1177mmm     IFEQ DEBUG
00000870  1639 00C00003           1178mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000876  0803 0002               1179mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1180mmm         BEQ WAIT_FOR_READY_50                       ; NO SPACE, CHECK AGAIN
0000087C  13D8 00C00007           1181mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000882                          1182mmm     ENDC
00000882                          1183mmm 
00000882                 FALSE    1184mmm     IFNE DEBUG
00000882                          1185mmm     ENDC
00000882                          1186mmm 
00000882                          1187mmm     ENDM
00000882  60E4                    1188mm     BRA LOOP_49
00000884                          1189mm EXIT_49
00000884                          1190mm     ENDM
00000884                          1191m     ENDM
00000884                          1192      
00000884  6000 FDD6               1193      BRA MAIN_LOOP
00000888                          1194  
00000888                          1195  W
00000888                          1196      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000888  3C3C 0000               1197s     MOVE.W  #0,D6
0000088C  6000 0046               1198s     BRA _20000005
00000890                          1199s _20000004
00000890  E98D                    1200          LSL.L #4,D5                                     ; make what we have so far more significant
00000892                          1201m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000892                          1202m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000892                 TRUE     1203m     IFEQ DEBUG
00000892  1639 00C00003           1204m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000898  0803 0000               1205m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000089C  67F4                    1206m         BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
0000089E                          1207m     ENDC
0000089E                          1208m 
0000089E                          1209mm     READ_CHAR D2
0000089E                 TRUE     1210mm     IFEQ DEBUG
0000089E  1439 00C00007           1211mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000008A4                          1212mm     ENDC
000008A4                 FALSE    1213mm     IFNE DEBUG
000008A4                          1214mm     ENDC
000008A4                          1215mm 
000008A4  B43C 001B               1216mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000008A8  6700 FB56               1217mm     BEQ START
000008AC                          1218mm     ENDM
000008AC                          1219m 
000008AC                 TRUE     1220m     IFEQ DEBUG
000008AC                          1221mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000008AC                          1222mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AC                 TRUE     1223mm     IFEQ DEBUG
000008AC  1639 00C00003           1224mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000008B2  0803 0002               1225mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000008B6  67F4                    1226mm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000008B8  13C2 00C00007           1227mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008BE                          1228mm     ENDC
000008BE                          1229mm 
000008BE                 FALSE    1230mm     IFNE DEBUG
000008BE                          1231mm     ENDC
000008BE                          1232mm 
000008BE                          1233mm     ENDM
000008BE                          1234m     ENDC
000008BE                          1235m     ENDM
000008BE                          1236m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000008BE  41FA 148F               1237m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000008C2  0402 0030               1238m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008C6  C4BC 000000FF           1239m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000008CC  1430 2000               1240m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000008D0                          1241m     ENDM
000008D0  8A02                    1242          OR.B D2,D5
000008D2                          1243      ENDF
000008D2  5246                    1244s     ADD.W   #1,D6
000008D4                          1245s _20000005
000008D4  BC7C 0007               1246s     CMP.W   #7,D6
000008D8  6FB6                    1247s     BLE _20000004
000008DA                          1248  
000008DA                          1249m     PRINT_CRLF D3,A0
000008DA  41FA 14E1               1250m     LEA CRLF(PC),A0
000008DE                          1251mm     PRINT_STR A0,D3
000008DE                          1252mm LOOP_56
000008DE  0C10 0000               1253mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000008E2  6700 0016               1254mm     BEQ EXIT_56
000008E6                          1255mmm     PRINT_CHAR (A0)+,D3
000008E6                          1256mmm WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                 TRUE     1257mmm     IFEQ DEBUG
000008E6  1639 00C00003           1258mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000008EC  0803 0002               1259mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000008F0  67F4                    1260mmm         BEQ WAIT_FOR_READY_57                       ; NO SPACE, CHECK AGAIN
000008F2  13D8 00C00007           1261mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008F8                          1262mmm     ENDC
000008F8                          1263mmm 
000008F8                 FALSE    1264mmm     IFNE DEBUG
000008F8                          1265mmm     ENDC
000008F8                          1266mmm 
000008F8                          1267mmm     ENDM
000008F8  60E4                    1268mm     BRA LOOP_56
000008FA                          1269mm EXIT_56
000008FA                          1270mm     ENDM
000008FA                          1271m     ENDM
000008FA                          1272  
000008FA  2047                    1273      MOVE.L D7,A0                                    ; address accumulator -> address register
000008FC  7E00                    1274      MOVE.L #0,D7                                    ; clear the now used address accumulator
000008FE                          1275  
000008FE  2085                    1276      MOVE.L D5,(A0)                                  ; write the data
00000900                          1277  
00000900  6000 FD5A               1278      BRA MAIN_LOOP
00000904                          1279  
00000904                          1280  ; register map for S
00000904                          1281  ; A0 - start address
00000904                          1282  ; A1 - offset
00000904                          1283  ; A2 - next address to write
00000904                          1284  ; A3 - next location (jmp)
00000904                          1285  ; A4 - Working Address Register
00000904                          1286  ; D0 - record count
00000904                          1287  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000904                          1288  ; D2 - checksum
00000904                          1289  ; D3 - data byte count
00000904                          1290  ; D4 - read address, moved into A2
00000904                          1291  ; D5 - temp
00000904                          1292  ; D6 - temp
00000904                          1293  ; D7 - temp
00000904                          1294  S
00000904  2078 0000               1295      MOVE.L 0,A0                                     ; start address -> A0
00000908  2247                    1296      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000090A                          1297      
0000090A  7000                    1298      MOVE.L #0,D0                                    ; count of records read -> D0
0000090C                          1299          
0000090C                          1300  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000090C                          1301m     DOWNLOAD D1
0000090C                          1302m WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090C                          1303m 
0000090C  1239 00C00003           1304m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000912  0801 0000               1305m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000916  6700 0010               1306m     BEQ CONTINUE_58                                 ; NOTHING, CONTINUE
0000091A                          1307m 
0000091A                          1308mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000091A                 TRUE     1309mm     IFEQ DEBUG
0000091A  1239 00C00007           1310mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000920                          1311mm     ENDC
00000920                 FALSE    1312mm     IFNE DEBUG
00000920                          1313mm     ENDC
00000920                          1314mm 
00000920  B23C 001B               1315mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000924  6700 FADA               1316mm     BEQ START
00000928                          1317mm     ENDM
00000928                          1318m CONTINUE_58
00000928  1239 00C00013           1319m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000092E  0801 0000               1320m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000932  67D8                    1321m     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000934                          1322m     
00000934  1239 00C00017           1323m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000093A  13C1 00E00001           1324m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000940                          1325m 
00000940                          1326m     ENDM
00000940  B23C 0053               1327      CMP.B #'S',D1                                   ; found S?
00000944  66C6                    1328      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000946                          1329      
00000946                          1330m     PRINT_CHAR #'S',D5                              ; print the S
00000946                          1331m WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000946                 TRUE     1332m     IFEQ DEBUG
00000946  1A39 00C00003           1333m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000094C  0805 0002               1334m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000950  67F4                    1335m         BEQ WAIT_FOR_READY_60                       ; NO SPACE, CHECK AGAIN
00000952  13FC 0053 00C00007      1336m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000095A                          1337m     ENDC
0000095A                          1338m 
0000095A                 FALSE    1339m     IFNE DEBUG
0000095A                          1340m     ENDC
0000095A                          1341m 
0000095A                          1342m     ENDM
0000095A  5280                    1343      ADD.L #1,D0                                     ; read another S record, increment count
0000095C                          1344      
0000095C                          1345m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000095C                          1346m WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                          1347m 
0000095C  1239 00C00003           1348m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000962  0801 0000               1349m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000966  6700 0010               1350m     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000096A                          1351m 
0000096A                          1352mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000096A                 TRUE     1353mm     IFEQ DEBUG
0000096A  1239 00C00007           1354mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000970                          1355mm     ENDC
00000970                 FALSE    1356mm     IFNE DEBUG
00000970                          1357mm     ENDC
00000970                          1358mm 
00000970  B23C 001B               1359mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000974  6700 FA8A               1360mm     BEQ START
00000978                          1361mm     ENDM
00000978                          1362m CONTINUE_61
00000978  1239 00C00013           1363m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000097E  0801 0000               1364m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000982  67D8                    1365m     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000984                          1366m     
00000984  1239 00C00017           1367m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000098A  13C1 00E00001           1368m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000990                          1369m 
00000990                          1370m     ENDM
00000990                          1371m     PRINT_CHAR D1,D5
00000990                          1372m WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000990                 TRUE     1373m     IFEQ DEBUG
00000990  1A39 00C00003           1374m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000996  0805 0002               1375m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000099A  67F4                    1376m         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
0000099C  13C1 00C00007           1377m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009A2                          1378m     ENDC
000009A2                          1379m 
000009A2                 FALSE    1380m     IFNE DEBUG
000009A2                          1381m     ENDC
000009A2                          1382m 
000009A2                          1383m     ENDM
000009A2                          1384  
000009A2  7400                    1385      MOVE.L #0,D2                                    ; clear the checksum
000009A4                          1386  
000009A4                          1387m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
000009A4  1E3C 0002               1388m     MOVE.B #2,D7
000009A8                          1389m     WHILE.B D7 <GT> 0 DO
000009A8                          1390ms _10000000
000009A8  BE38 0000               1391ms     CMP.B   0,D7
000009AC  6F00 0062               1392ms     BLE _10000001
000009B0  E98B                    1393m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B2                          1394mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B2                          1395mm WAIT_FOR_READY_65                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B2                          1396mm 
000009B2  1A39 00C00003           1397mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009B8  0805 0000               1398mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009BC  6700 0010               1399mm     BEQ CONTINUE_65                                 ; NOTHING, CONTINUE
000009C0                          1400mm 
000009C0                          1401mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C0                 TRUE     1402mmm     IFEQ DEBUG
000009C0  1A39 00C00007           1403mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C6                          1404mmm     ENDC
000009C6                 FALSE    1405mmm     IFNE DEBUG
000009C6                          1406mmm     ENDC
000009C6                          1407mmm 
000009C6  BA3C 001B               1408mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CA  6700 FA34               1409mmm     BEQ START
000009CE                          1410mmm     ENDM
000009CE                          1411mm CONTINUE_65
000009CE  1A39 00C00013           1412mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D4  0805 0000               1413mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009D8  67D8                    1414mm     BEQ WAIT_FOR_READY_65                           ; NOTHING, CHECK AGAIN
000009DA                          1415mm     
000009DA  1A39 00C00017           1416mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E0  13C5 00E00001           1417mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E6                          1418mm 
000009E6                          1419mm     ENDM
000009E6                          1420mm         PRINT_CHAR D5,D6
000009E6                          1421mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1422mm     IFEQ DEBUG
000009E6  1C39 00C00003           1423mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009EC  0806 0002               1424mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1425mm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000009F2  13C5 00C00007           1426mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009F8                          1427mm     ENDC
000009F8                          1428mm 
000009F8                 FALSE    1429mm     IFNE DEBUG
000009F8                          1430mm     ENDC
000009F8                          1431mm 
000009F8                          1432mm     ENDM
000009F8                          1433mm         HEX2BIN D5,D5,A4
000009F8  49FA 1355               1434mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009FC  0405 0030               1435mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A00  CABC 000000FF           1436mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A06  1A34 5000               1437mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0A                          1438mm     ENDM
00000A0A  8605                    1439m         OR.B D5,D3
00000A0C  5307                    1440m         SUB.B #1,D7
00000A0E                          1441m     ENDW
00000A0E  6098                    1442ms     BRA _10000000
00000A10                          1443ms _10000001
00000A10                          1444m 
00000A10  7A00                    1445m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A12  1A03                    1446m     MOVE.B D3,D5
00000A14  D483                    1447m     ADD.L D3,D2
00000A16                          1448m 
00000A16                          1449m     ENDM
00000A16                          1450  
00000A16                          1451      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000A16  B23C 0030               1452s     CMP.B   #'0',D1
00000A1A  6600 002A               1453s     BNE.L   _00000004
00000A1E                          1454m         PRINT_CRLF D5,A4
00000A1E  49FA 139D               1455m     LEA CRLF(PC),A4
00000A22                          1456mm     PRINT_STR A4,D5
00000A22                          1457mm LOOP_70
00000A22  0C14 0000               1458mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A26  6700 0016               1459mm     BEQ EXIT_70
00000A2A                          1460mmm     PRINT_CHAR (A4)+,D5
00000A2A                          1461mmm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2A                 TRUE     1462mmm     IFEQ DEBUG
00000A2A  1A39 00C00003           1463mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A30  0805 0002               1464mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A34  67F4                    1465mmm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
00000A36  13DC 00C00007           1466mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A3C                          1467mmm     ENDC
00000A3C                          1468mmm 
00000A3C                 FALSE    1469mmm     IFNE DEBUG
00000A3C                          1470mmm     ENDC
00000A3C                          1471mmm 
00000A3C                          1472mmm     ENDM
00000A3C  60E4                    1473mm     BRA LOOP_70
00000A3E                          1474mm EXIT_70
00000A3E                          1475mm     ENDM
00000A3E                          1476m     ENDM
00000A3E  6000 FECC               1477          BRA WAIT_FOR_SRECORD
00000A42                          1478      ELSE
00000A42  6000 03DE               1479s     BRA _00000005
00000A46                          1480s _00000004
00000A46                          1481          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
00000A46  B23C 0031               1482s     CMP.B   #'1',D1
00000A4A  6708                    1483s     BEQ.S   _00000006
00000A4C  B23C 0032               1484s     CMP.B   #'2',D1
00000A50  6600 01F0               1485s     BNE.L   _00000007
00000A54                          1486s _00000006
00000A54  5783                    1487              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000A56                          1488  
00000A56  7800                    1489              MOVE.L #0,D4                            ; read two bytes of address
00000A58                          1490m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000A58  1E3C 0002               1491m     MOVE.B #2,D7
00000A5C                          1492m     WHILE.B D7 <GT> 0 DO
00000A5C                          1493ms _10000002
00000A5C  BE38 0000               1494ms     CMP.B   0,D7
00000A60  6F00 0062               1495ms     BLE _10000003
00000A64  E98C                    1496m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A66                          1497mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A66                          1498mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                          1499mm 
00000A66  1A39 00C00003           1500mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A6C  0805 0000               1501mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A70  6700 0010               1502mm     BEQ CONTINUE_73                                 ; NOTHING, CONTINUE
00000A74                          1503mm 
00000A74                          1504mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A74                 TRUE     1505mmm     IFEQ DEBUG
00000A74  1A39 00C00007           1506mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A7A                          1507mmm     ENDC
00000A7A                 FALSE    1508mmm     IFNE DEBUG
00000A7A                          1509mmm     ENDC
00000A7A                          1510mmm 
00000A7A  BA3C 001B               1511mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A7E  6700 F980               1512mmm     BEQ START
00000A82                          1513mmm     ENDM
00000A82                          1514mm CONTINUE_73
00000A82  1A39 00C00013           1515mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A88  0805 0000               1516mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A8C  67D8                    1517mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
00000A8E                          1518mm     
00000A8E  1A39 00C00017           1519mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A94  13C5 00E00001           1520mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A9A                          1521mm 
00000A9A                          1522mm     ENDM
00000A9A                          1523mm         PRINT_CHAR D5,D6
00000A9A                          1524mm WAIT_FOR_READY_75                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9A                 TRUE     1525mm     IFEQ DEBUG
00000A9A  1C39 00C00003           1526mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000AA0  0806 0002               1527mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000AA4  67F4                    1528mm         BEQ WAIT_FOR_READY_75                       ; NO SPACE, CHECK AGAIN
00000AA6  13C5 00C00007           1529mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AAC                          1530mm     ENDC
00000AAC                          1531mm 
00000AAC                 FALSE    1532mm     IFNE DEBUG
00000AAC                          1533mm     ENDC
00000AAC                          1534mm 
00000AAC                          1535mm     ENDM
00000AAC                          1536mm         HEX2BIN D5,D5,A4
00000AAC  49FA 12A1               1537mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000AB0  0405 0030               1538mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AB4  CABC 000000FF           1539mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000ABA  1A34 5000               1540mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000ABE                          1541mm     ENDM
00000ABE  8805                    1542m         OR.B D5,D4
00000AC0  5307                    1543m         SUB.B #1,D7
00000AC2                          1544m     ENDW
00000AC2  6098                    1545ms     BRA _10000002
00000AC4                          1546ms _10000003
00000AC4                          1547m 
00000AC4  7A00                    1548m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AC6  1A04                    1549m     MOVE.B D4,D5
00000AC8  D484                    1550m     ADD.L D4,D2
00000ACA                          1551m 
00000ACA                          1552m     ENDM
00000ACA                          1553m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000ACA  1E3C 0002               1554m     MOVE.B #2,D7
00000ACE                          1555m     WHILE.B D7 <GT> 0 DO
00000ACE                          1556ms _10000004
00000ACE  BE38 0000               1557ms     CMP.B   0,D7
00000AD2  6F00 0062               1558ms     BLE _10000005
00000AD6  E98C                    1559m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000AD8                          1560mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000AD8                          1561mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                          1562mm 
00000AD8  1A39 00C00003           1563mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000ADE  0805 0000               1564mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AE2  6700 0010               1565mm     BEQ CONTINUE_78                                 ; NOTHING, CONTINUE
00000AE6                          1566mm 
00000AE6                          1567mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AE6                 TRUE     1568mmm     IFEQ DEBUG
00000AE6  1A39 00C00007           1569mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000AEC                          1570mmm     ENDC
00000AEC                 FALSE    1571mmm     IFNE DEBUG
00000AEC                          1572mmm     ENDC
00000AEC                          1573mmm 
00000AEC  BA3C 001B               1574mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000AF0  6700 F90E               1575mmm     BEQ START
00000AF4                          1576mmm     ENDM
00000AF4                          1577mm CONTINUE_78
00000AF4  1A39 00C00013           1578mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000AFA  0805 0000               1579mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AFE  67D8                    1580mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
00000B00                          1581mm     
00000B00  1A39 00C00017           1582mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B06  13C5 00E00001           1583mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B0C                          1584mm 
00000B0C                          1585mm     ENDM
00000B0C                          1586mm         PRINT_CHAR D5,D6
00000B0C                          1587mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0C                 TRUE     1588mm     IFEQ DEBUG
00000B0C  1C39 00C00003           1589mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B12  0806 0002               1590mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B16  67F4                    1591mm         BEQ WAIT_FOR_READY_80                       ; NO SPACE, CHECK AGAIN
00000B18  13C5 00C00007           1592mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B1E                          1593mm     ENDC
00000B1E                          1594mm 
00000B1E                 FALSE    1595mm     IFNE DEBUG
00000B1E                          1596mm     ENDC
00000B1E                          1597mm 
00000B1E                          1598mm     ENDM
00000B1E                          1599mm         HEX2BIN D5,D5,A4
00000B1E  49FA 122F               1600mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B22  0405 0030               1601mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B26  CABC 000000FF           1602mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B2C  1A34 5000               1603mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B30                          1604mm     ENDM
00000B30  8805                    1605m         OR.B D5,D4
00000B32  5307                    1606m         SUB.B #1,D7
00000B34                          1607m     ENDW
00000B34  6098                    1608ms     BRA _10000004
00000B36                          1609ms _10000005
00000B36                          1610m 
00000B36  7A00                    1611m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B38  1A04                    1612m     MOVE.B D4,D5
00000B3A  D484                    1613m     ADD.L D4,D2
00000B3C                          1614m 
00000B3C                          1615m     ENDM
00000B3C                          1616  
00000B3C                          1617              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000B3C  B23C 0032               1618s     CMP.B   #'2',D1
00000B40  6600 0076               1619s     BNE.L   _00000008
00000B44  5383                    1620                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000B46                          1621m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000B46  1E3C 0002               1622m     MOVE.B #2,D7
00000B4A                          1623m     WHILE.B D7 <GT> 0 DO
00000B4A                          1624ms _10000006
00000B4A  BE38 0000               1625ms     CMP.B   0,D7
00000B4E  6F00 0062               1626ms     BLE _10000007
00000B52  E98C                    1627m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B54                          1628mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B54                          1629mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B54                          1630mm 
00000B54  1A39 00C00003           1631mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B5A  0805 0000               1632mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B5E  6700 0010               1633mm     BEQ CONTINUE_83                                 ; NOTHING, CONTINUE
00000B62                          1634mm 
00000B62                          1635mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B62                 TRUE     1636mmm     IFEQ DEBUG
00000B62  1A39 00C00007           1637mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B68                          1638mmm     ENDC
00000B68                 FALSE    1639mmm     IFNE DEBUG
00000B68                          1640mmm     ENDC
00000B68                          1641mmm 
00000B68  BA3C 001B               1642mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B6C  6700 F892               1643mmm     BEQ START
00000B70                          1644mmm     ENDM
00000B70                          1645mm CONTINUE_83
00000B70  1A39 00C00013           1646mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B76  0805 0000               1647mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B7A  67D8                    1648mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
00000B7C                          1649mm     
00000B7C  1A39 00C00017           1650mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B82  13C5 00E00001           1651mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B88                          1652mm 
00000B88                          1653mm     ENDM
00000B88                          1654mm         PRINT_CHAR D5,D6
00000B88                          1655mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     1656mm     IFEQ DEBUG
00000B88  1C39 00C00003           1657mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B8E  0806 0002               1658mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    1659mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000B94  13C5 00C00007           1660mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B9A                          1661mm     ENDC
00000B9A                          1662mm 
00000B9A                 FALSE    1663mm     IFNE DEBUG
00000B9A                          1664mm     ENDC
00000B9A                          1665mm 
00000B9A                          1666mm     ENDM
00000B9A                          1667mm         HEX2BIN D5,D5,A4
00000B9A  49FA 11B3               1668mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B9E  0405 0030               1669mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BA2  CABC 000000FF           1670mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000BA8  1A34 5000               1671mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BAC                          1672mm     ENDM
00000BAC  8805                    1673m         OR.B D5,D4
00000BAE  5307                    1674m         SUB.B #1,D7
00000BB0                          1675m     ENDW
00000BB0  6098                    1676ms     BRA _10000006
00000BB2                          1677ms _10000007
00000BB2                          1678m 
00000BB2  7A00                    1679m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000BB4  1A04                    1680m     MOVE.B D4,D5
00000BB6  D484                    1681m     ADD.L D4,D2
00000BB8                          1682m 
00000BB8                          1683m     ENDM
00000BB8                          1684              ENDI
00000BB8                          1685s _00000008
00000BB8                          1686  
00000BB8  2444                    1687              MOVE.L D4,A2                            ; put the address in an address register
00000BBA  D5C9                    1688              ADD.L A1,A2                             ; add in the offset
00000BBC                          1689  
00000BBC                          1690              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000BBC                          1691s _10000008
00000BBC  B63C 0000               1692s     CMP.B   #0,D3
00000BC0  6F00 007A               1693s     BLE _10000009
00000BC4                          1694m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000BC4  1E3C 0002               1695m     MOVE.B #2,D7
00000BC8                          1696m     WHILE.B D7 <GT> 0 DO
00000BC8                          1697ms _1000000A
00000BC8  BE38 0000               1698ms     CMP.B   0,D7
00000BCC  6F00 0062               1699ms     BLE _1000000B
00000BD0  E989                    1700m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000BD2                          1701mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000BD2                          1702mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                          1703mm 
00000BD2  1A39 00C00003           1704mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000BD8  0805 0000               1705mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BDC  6700 0010               1706mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
00000BE0                          1707mm 
00000BE0                          1708mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000BE0                 TRUE     1709mmm     IFEQ DEBUG
00000BE0  1A39 00C00007           1710mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000BE6                          1711mmm     ENDC
00000BE6                 FALSE    1712mmm     IFNE DEBUG
00000BE6                          1713mmm     ENDC
00000BE6                          1714mmm 
00000BE6  BA3C 001B               1715mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000BEA  6700 F814               1716mmm     BEQ START
00000BEE                          1717mmm     ENDM
00000BEE                          1718mm CONTINUE_88
00000BEE  1A39 00C00013           1719mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000BF4  0805 0000               1720mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BF8  67D8                    1721mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
00000BFA                          1722mm     
00000BFA  1A39 00C00017           1723mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C00  13C5 00E00001           1724mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C06                          1725mm 
00000C06                          1726mm     ENDM
00000C06                          1727mm         PRINT_CHAR D5,D6
00000C06                          1728mm WAIT_FOR_READY_90                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C06                 TRUE     1729mm     IFEQ DEBUG
00000C06  1C39 00C00003           1730mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C0C  0806 0002               1731mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C10  67F4                    1732mm         BEQ WAIT_FOR_READY_90                       ; NO SPACE, CHECK AGAIN
00000C12  13C5 00C00007           1733mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C18                          1734mm     ENDC
00000C18                          1735mm 
00000C18                 FALSE    1736mm     IFNE DEBUG
00000C18                          1737mm     ENDC
00000C18                          1738mm 
00000C18                          1739mm     ENDM
00000C18                          1740mm         HEX2BIN D5,D5,A4
00000C18  49FA 1135               1741mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000C1C  0405 0030               1742mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C20  CABC 000000FF           1743mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000C26  1A34 5000               1744mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C2A                          1745mm     ENDM
00000C2A  8205                    1746m         OR.B D5,D1
00000C2C  5307                    1747m         SUB.B #1,D7
00000C2E                          1748m     ENDW
00000C2E  6098                    1749ms     BRA _1000000A
00000C30                          1750ms _1000000B
00000C30                          1751m 
00000C30  7A00                    1752m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000C32  1A01                    1753m     MOVE.B D1,D5
00000C34  D481                    1754m     ADD.L D1,D2
00000C36                          1755m 
00000C36                          1756m     ENDM
00000C36                          1757   
00000C36  14C1                    1758                  MOVE.B D1,(A2)+                     ; store it!
00000C38                          1759  
00000C38  5303                    1760                  SUB.B #1,D3                         ; 1 less byte to go
00000C3A                          1761              ENDW
00000C3A  6080                    1762s     BRA _10000008
00000C3C                          1763s _10000009
00000C3C                          1764  
00000C3C  7200                    1765              MOVE.L #0,D1                            ; not done yet
00000C3E                          1766          ELSE
00000C3E  6000 01E2               1767s     BRA _00000009
00000C42                          1768s _00000007
00000C42                          1769              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000C42  B23C 0038               1770s     CMP.B   #'8',D1
00000C46  6600 0164               1771s     BNE.L   _0000000A
00000C4A  7800                    1772                  MOVE.L #0,D4                        ; read the 24 bit start address
00000C4C                          1773m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000C4C  1E3C 0002               1774m     MOVE.B #2,D7
00000C50                          1775m     WHILE.B D7 <GT> 0 DO
00000C50                          1776ms _1000000C
00000C50  BE38 0000               1777ms     CMP.B   0,D7
00000C54  6F00 0062               1778ms     BLE _1000000D
00000C58  E98C                    1779m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000C5A                          1780mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000C5A                          1781mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C5A                          1782mm 
00000C5A  1A39 00C00003           1783mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000C60  0805 0000               1784mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C64  6700 0010               1785mm     BEQ CONTINUE_93                                 ; NOTHING, CONTINUE
00000C68                          1786mm 
00000C68                          1787mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000C68                 TRUE     1788mmm     IFEQ DEBUG
00000C68  1A39 00C00007           1789mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000C6E                          1790mmm     ENDC
00000C6E                 FALSE    1791mmm     IFNE DEBUG
00000C6E                          1792mmm     ENDC
00000C6E                          1793mmm 
00000C6E  BA3C 001B               1794mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000C72  6700 F78C               1795mmm     BEQ START
00000C76                          1796mmm     ENDM
00000C76                          1797mm CONTINUE_93
00000C76  1A39 00C00013           1798mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000C7C  0805 0000               1799mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C80  67D8                    1800mm     BEQ WAIT_FOR_READY_93                           ; NOTHING, CHECK AGAIN
00000C82                          1801mm     
00000C82  1A39 00C00017           1802mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C88  13C5 00E00001           1803mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C8E                          1804mm 
00000C8E                          1805mm     ENDM
00000C8E                          1806mm         PRINT_CHAR D5,D6
00000C8E                          1807mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     1808mm     IFEQ DEBUG
00000C8E  1C39 00C00003           1809mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C94  0806 0002               1810mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    1811mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000C9A  13C5 00C00007           1812mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CA0                          1813mm     ENDC
00000CA0                          1814mm 
00000CA0                 FALSE    1815mm     IFNE DEBUG
00000CA0                          1816mm     ENDC
00000CA0                          1817mm 
00000CA0                          1818mm     ENDM
00000CA0                          1819mm         HEX2BIN D5,D5,A4
00000CA0  49FA 10AD               1820mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000CA4  0405 0030               1821mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CA8  CABC 000000FF           1822mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000CAE  1A34 5000               1823mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CB2                          1824mm     ENDM
00000CB2  8805                    1825m         OR.B D5,D4
00000CB4  5307                    1826m         SUB.B #1,D7
00000CB6                          1827m     ENDW
00000CB6  6098                    1828ms     BRA _1000000C
00000CB8                          1829ms _1000000D
00000CB8                          1830m 
00000CB8  7A00                    1831m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000CBA  1A04                    1832m     MOVE.B D4,D5
00000CBC  D484                    1833m     ADD.L D4,D2
00000CBE                          1834m 
00000CBE                          1835m     ENDM
00000CBE                          1836m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000CBE  1E3C 0002               1837m     MOVE.B #2,D7
00000CC2                          1838m     WHILE.B D7 <GT> 0 DO
00000CC2                          1839ms _1000000E
00000CC2  BE38 0000               1840ms     CMP.B   0,D7
00000CC6  6F00 0062               1841ms     BLE _1000000F
00000CCA  E98C                    1842m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000CCC                          1843mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000CCC                          1844mm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                          1845mm 
00000CCC  1A39 00C00003           1846mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000CD2  0805 0000               1847mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CD6  6700 0010               1848mm     BEQ CONTINUE_98                                 ; NOTHING, CONTINUE
00000CDA                          1849mm 
00000CDA                          1850mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000CDA                 TRUE     1851mmm     IFEQ DEBUG
00000CDA  1A39 00C00007           1852mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000CE0                          1853mmm     ENDC
00000CE0                 FALSE    1854mmm     IFNE DEBUG
00000CE0                          1855mmm     ENDC
00000CE0                          1856mmm 
00000CE0  BA3C 001B               1857mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000CE4  6700 F71A               1858mmm     BEQ START
00000CE8                          1859mmm     ENDM
00000CE8                          1860mm CONTINUE_98
00000CE8  1A39 00C00013           1861mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000CEE  0805 0000               1862mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CF2  67D8                    1863mm     BEQ WAIT_FOR_READY_98                           ; NOTHING, CHECK AGAIN
00000CF4                          1864mm     
00000CF4  1A39 00C00017           1865mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000CFA  13C5 00E00001           1866mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000D00                          1867mm 
00000D00                          1868mm     ENDM
00000D00                          1869mm         PRINT_CHAR D5,D6
00000D00                          1870mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     1871mm     IFEQ DEBUG
00000D00  1C39 00C00003           1872mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000D06  0806 0002               1873mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    1874mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000D0C  13C5 00C00007           1875mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D12                          1876mm     ENDC
00000D12                          1877mm 
00000D12                 FALSE    1878mm     IFNE DEBUG
00000D12                          1879mm     ENDC
00000D12                          1880mm 
00000D12                          1881mm     ENDM
00000D12                          1882mm         HEX2BIN D5,D5,A4
00000D12  49FA 103B               1883mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000D16  0405 0030               1884mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D1A  CABC 000000FF           1885mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D20  1A34 5000               1886mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D24                          1887mm     ENDM
00000D24  8805                    1888m         OR.B D5,D4
00000D26  5307                    1889m         SUB.B #1,D7
00000D28                          1890m     ENDW
00000D28  6098                    1891ms     BRA _1000000E
00000D2A                          1892ms _1000000F
00000D2A                          1893m 
00000D2A  7A00                    1894m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D2C  1A04                    1895m     MOVE.B D4,D5
00000D2E  D484                    1896m     ADD.L D4,D2
00000D30                          1897m 
00000D30                          1898m     ENDM
00000D30                          1899m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000D30  1E3C 0002               1900m     MOVE.B #2,D7
00000D34                          1901m     WHILE.B D7 <GT> 0 DO
00000D34                          1902ms _10000010
00000D34  BE38 0000               1903ms     CMP.B   0,D7
00000D38  6F00 0062               1904ms     BLE _10000011
00000D3C  E98C                    1905m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000D3E                          1906mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000D3E                          1907mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                          1908mm 
00000D3E  1A39 00C00003           1909mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000D44  0805 0000               1910mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000D48  6700 0010               1911mm     BEQ CONTINUE_103                                    ; NOTHING, CONTINUE
00000D4C                          1912mm 
00000D4C                          1913mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000D4C                 TRUE     1914mmm     IFEQ DEBUG
00000D4C  1A39 00C00007           1915mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000D52                          1916mmm     ENDC
00000D52                 FALSE    1917mmm     IFNE DEBUG
00000D52                          1918mmm     ENDC
00000D52                          1919mmm 
00000D52  BA3C 001B               1920mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000D56  6700 F6A8               1921mmm     BEQ START
00000D5A                          1922mmm     ENDM
00000D5A                          1923mm CONTINUE_103
00000D5A  1A39 00C00013           1924mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000D60  0805 0000               1925mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000D64  67D8                    1926mm     BEQ WAIT_FOR_READY_103                          ; NOTHING, CHECK AGAIN
00000D66                          1927mm     
00000D66  1A39 00C00017           1928mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000D6C  13C5 00E00001           1929mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000D72                          1930mm 
00000D72                          1931mm     ENDM
00000D72                          1932mm         PRINT_CHAR D5,D6
00000D72                          1933mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     1934mm     IFEQ DEBUG
00000D72  1C39 00C00003           1935mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000D78  0806 0002               1936mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    1937mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000D7E  13C5 00C00007           1938mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D84                          1939mm     ENDC
00000D84                          1940mm 
00000D84                 FALSE    1941mm     IFNE DEBUG
00000D84                          1942mm     ENDC
00000D84                          1943mm 
00000D84                          1944mm     ENDM
00000D84                          1945mm         HEX2BIN D5,D5,A4
00000D84  49FA 0FC9               1946mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000D88  0405 0030               1947mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D8C  CABC 000000FF           1948mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D92  1A34 5000               1949mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D96                          1950mm     ENDM
00000D96  8805                    1951m         OR.B D5,D4
00000D98  5307                    1952m         SUB.B #1,D7
00000D9A                          1953m     ENDW
00000D9A  6098                    1954ms     BRA _10000010
00000D9C                          1955ms _10000011
00000D9C                          1956m 
00000D9C  7A00                    1957m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D9E  1A04                    1958m     MOVE.B D4,D5
00000DA0  D484                    1959m     ADD.L D4,D2
00000DA2                          1960m 
00000DA2                          1961m     ENDM
00000DA2                          1962  
00000DA2  2044                    1963                  MOVE.L D4,A0                        ; start address -> A0
00000DA4  D1C9                    1964                  ADD.L A1,A0                         ; add in the offset
00000DA6                          1965  
00000DA6  72FF                    1966                  MOVE.L #$FFFFFFFF,D1                ; done
00000DA8                          1967              ELSE
00000DA8  6000 0078               1968s     BRA _0000000B
00000DAC                          1969s _0000000A
00000DAC                          1970m                 PRINT_CRLF D5,A4
00000DAC  49FA 100F               1971m     LEA CRLF(PC),A4
00000DB0                          1972mm     PRINT_STR A4,D5
00000DB0                          1973mm LOOP_108
00000DB0  0C14 0000               1974mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000DB4  6700 0016               1975mm     BEQ EXIT_108
00000DB8                          1976mmm     PRINT_CHAR (A4)+,D5
00000DB8                          1977mmm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB8                 TRUE     1978mmm     IFEQ DEBUG
00000DB8  1A39 00C00003           1979mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DBE  0805 0002               1980mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DC2  67F4                    1981mmm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000DC4  13DC 00C00007           1982mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DCA                          1983mmm     ENDC
00000DCA                          1984mmm 
00000DCA                 FALSE    1985mmm     IFNE DEBUG
00000DCA                          1986mmm     ENDC
00000DCA                          1987mmm 
00000DCA                          1988mmm     ENDM
00000DCA  60E4                    1989mm     BRA LOOP_108
00000DCC                          1990mm EXIT_108
00000DCC                          1991mm     ENDM
00000DCC                          1992m     ENDM
00000DCC                          1993  
00000DCC  49FA 0F38               1994                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000DD0                          1995m                 PRINT_STR A4,D5
00000DD0                          1996m LOOP_110
00000DD0  0C14 0000               1997m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000DD4  6700 0016               1998m     BEQ EXIT_110
00000DD8                          1999mm     PRINT_CHAR (A4)+,D5
00000DD8                          2000mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD8                 TRUE     2001mm     IFEQ DEBUG
00000DD8  1A39 00C00003           2002mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DDE  0805 0002               2003mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DE2  67F4                    2004mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000DE4  13DC 00C00007           2005mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DEA                          2006mm     ENDC
00000DEA                          2007mm 
00000DEA                 FALSE    2008mm     IFNE DEBUG
00000DEA                          2009mm     ENDC
00000DEA                          2010mm 
00000DEA                          2011mm     ENDM
00000DEA  60E4                    2012m     BRA LOOP_110
00000DEC                          2013m EXIT_110
00000DEC                          2014m     ENDM
00000DEC                          2015m                 PRINT_CHAR D1,D5
00000DEC                          2016m WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEC                 TRUE     2017m     IFEQ DEBUG
00000DEC  1A39 00C00003           2018m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DF2  0805 0002               2019m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DF6  67F4                    2020m         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000DF8  13C1 00C00007           2021m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DFE                          2022m     ENDC
00000DFE                          2023m 
00000DFE                 FALSE    2024m     IFNE DEBUG
00000DFE                          2025m     ENDC
00000DFE                          2026m 
00000DFE                          2027m     ENDM
00000DFE                          2028m                 PRINT_CRLF D5,A4
00000DFE  49FA 0FBD               2029m     LEA CRLF(PC),A4
00000E02                          2030mm     PRINT_STR A4,D5
00000E02                          2031mm LOOP_114
00000E02  0C14 0000               2032mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E06  6700 0016               2033mm     BEQ EXIT_114
00000E0A                          2034mmm     PRINT_CHAR (A4)+,D5
00000E0A                          2035mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E0A                 TRUE     2036mmm     IFEQ DEBUG
00000E0A  1A39 00C00003           2037mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E10  0805 0002               2038mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E14  67F4                    2039mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000E16  13DC 00C00007           2040mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E1C                          2041mmm     ENDC
00000E1C                          2042mmm 
00000E1C                 FALSE    2043mmm     IFNE DEBUG
00000E1C                          2044mmm     ENDC
00000E1C                          2045mmm 
00000E1C                          2046mmm     ENDM
00000E1C  60E4                    2047mm     BRA LOOP_114
00000E1E                          2048mm EXIT_114
00000E1E                          2049mm     ENDM
00000E1E                          2050m     ENDM
00000E1E                          2051  
00000E1E  6000 FAEC               2052                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000E22                          2053              ENDI
00000E22                          2054s _0000000B
00000E22                          2055          ENDI
00000E22                          2056s _00000009
00000E22                          2057      ENDI
00000E22                          2058s _00000005
00000E22                          2059  
00000E22                          2060m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000E22  1E3C 0002               2061m     MOVE.B #2,D7
00000E26                          2062m     WHILE.B D7 <GT> 0 DO
00000E26                          2063ms _10000012
00000E26  BE38 0000               2064ms     CMP.B   0,D7
00000E2A  6F00 0062               2065ms     BLE _10000013
00000E2E  E98C                    2066m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000E30                          2067mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000E30                          2068mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E30                          2069mm 
00000E30  1A39 00C00003           2070mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000E36  0805 0000               2071mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000E3A  6700 0010               2072mm     BEQ CONTINUE_117                                    ; NOTHING, CONTINUE
00000E3E                          2073mm 
00000E3E                          2074mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000E3E                 TRUE     2075mmm     IFEQ DEBUG
00000E3E  1A39 00C00007           2076mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000E44                          2077mmm     ENDC
00000E44                 FALSE    2078mmm     IFNE DEBUG
00000E44                          2079mmm     ENDC
00000E44                          2080mmm 
00000E44  BA3C 001B               2081mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000E48  6700 F5B6               2082mmm     BEQ START
00000E4C                          2083mmm     ENDM
00000E4C                          2084mm CONTINUE_117
00000E4C  1A39 00C00013           2085mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000E52  0805 0000               2086mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000E56  67D8                    2087mm     BEQ WAIT_FOR_READY_117                          ; NOTHING, CHECK AGAIN
00000E58                          2088mm     
00000E58  1A39 00C00017           2089mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000E5E  13C5 00E00001           2090mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000E64                          2091mm 
00000E64                          2092mm     ENDM
00000E64                          2093mm         PRINT_CHAR D5,D6
00000E64                          2094mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E64                 TRUE     2095mm     IFEQ DEBUG
00000E64  1C39 00C00003           2096mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000E6A  0806 0002               2097mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000E6E  67F4                    2098mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000E70  13C5 00C00007           2099mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E76                          2100mm     ENDC
00000E76                          2101mm 
00000E76                 FALSE    2102mm     IFNE DEBUG
00000E76                          2103mm     ENDC
00000E76                          2104mm 
00000E76                          2105mm     ENDM
00000E76                          2106mm         HEX2BIN D5,D5,A4
00000E76  49FA 0ED7               2107mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000E7A  0405 0030               2108mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E7E  CABC 000000FF           2109mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000E84  1A34 5000               2110mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E88                          2111mm     ENDM
00000E88  8805                    2112m         OR.B D5,D4
00000E8A  5307                    2113m         SUB.B #1,D7
00000E8C                          2114m     ENDW
00000E8C  6098                    2115ms     BRA _10000012
00000E8E                          2116ms _10000013
00000E8E                          2117m 
00000E8E  7A00                    2118m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000E90  1A04                    2119m     MOVE.B D4,D5
00000E92  D484                    2120m     ADD.L D4,D2
00000E94                          2121m 
00000E94                          2122m     ENDM
00000E94                          2123m     PRINT_CRLF D5,A4
00000E94  49FA 0F27               2124m     LEA CRLF(PC),A4
00000E98                          2125mm     PRINT_STR A4,D5
00000E98                          2126mm LOOP_122
00000E98  0C14 0000               2127mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E9C  6700 0016               2128mm     BEQ EXIT_122
00000EA0                          2129mmm     PRINT_CHAR (A4)+,D5
00000EA0                          2130mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA0                 TRUE     2131mmm     IFEQ DEBUG
00000EA0  1A39 00C00003           2132mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EA6  0805 0002               2133mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EAA  67F4                    2134mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000EAC  13DC 00C00007           2135mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB2                          2136mmm     ENDC
00000EB2                          2137mmm 
00000EB2                 FALSE    2138mmm     IFNE DEBUG
00000EB2                          2139mmm     ENDC
00000EB2                          2140mmm 
00000EB2                          2141mmm     ENDM
00000EB2  60E4                    2142mm     BRA LOOP_122
00000EB4                          2143mm EXIT_122
00000EB4                          2144mm     ENDM
00000EB4                          2145m     ENDM
00000EB4                          2146  
00000EB4                          2147      IF.B D2 <NE> #$FF THEN.L
00000EB4  B43C 00FF               2148s     CMP.B   #$FF,D2
00000EB8  6700 0090               2149s     BEQ.L   _0000000C
00000EBC  49FA 0E5F               2150          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000EC0                          2151m         PRINT_STR A4,D5
00000EC0                          2152m LOOP_124
00000EC0  0C14 0000               2153m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EC4  6700 0016               2154m     BEQ EXIT_124
00000EC8                          2155mm     PRINT_CHAR (A4)+,D5
00000EC8                          2156mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2157mm     IFEQ DEBUG
00000EC8  1A39 00C00003           2158mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ECE  0805 0002               2159mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ED2  67F4                    2160mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000ED4  13DC 00C00007           2161mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EDA                          2162mm     ENDC
00000EDA                          2163mm 
00000EDA                 FALSE    2164mm     IFNE DEBUG
00000EDA                          2165mm     ENDC
00000EDA                          2166mm 
00000EDA                          2167mm     ENDM
00000EDA  60E4                    2168m     BRA LOOP_124
00000EDC                          2169m EXIT_124
00000EDC                          2170m     ENDM
00000EDC                          2171m         PRINT_REG D0,D5,D3,D6,A4
00000EDC  49FA 0EE5               2172m     LEA OX(PC),A4
00000EE0                          2173mm     PRINT_STR A4,D5
00000EE0                          2174mm LOOP_127
00000EE0  0C14 0000               2175mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EE4  6700 0016               2176mm     BEQ EXIT_127
00000EE8                          2177mmm     PRINT_CHAR (A4)+,D5
00000EE8                          2178mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EE8                 TRUE     2179mmm     IFEQ DEBUG
00000EE8  1A39 00C00003           2180mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EEE  0805 0002               2181mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EF2  67F4                    2182mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000EF4  13DC 00C00007           2183mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFA                          2184mmm     ENDC
00000EFA                          2185mmm 
00000EFA                 FALSE    2186mmm     IFNE DEBUG
00000EFA                          2187mmm     ENDC
00000EFA                          2188mmm 
00000EFA                          2189mmm     ENDM
00000EFA  60E4                    2190mm     BRA LOOP_127
00000EFC                          2191mm EXIT_127
00000EFC                          2192mm     ENDM
00000EFC  7C07                    2193m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EFE                          2194m LOOP_126
00000EFE                          2195mm     BIN2HEX D0,D3,A4
00000EFE  49FA 0E3F               2196mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000F02  E998                    2197mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F04  1600                    2198mm     MOVE.B D0,D3
00000F06  0283 0000000F           2199mm     ANDI.L #$F,D3
00000F0C  1634 3000               2200mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000F10                          2201mm     ENDM
00000F10                          2202mm     PRINT_CHAR D3,D5
00000F10                          2203mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F10                 TRUE     2204mm     IFEQ DEBUG
00000F10  1A39 00C00003           2205mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F16  0805 0002               2206mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F1A  67F4                    2207mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000F1C  13C3 00C00007           2208mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F22                          2209mm     ENDC
00000F22                          2210mm 
00000F22                 FALSE    2211mm     IFNE DEBUG
00000F22                          2212mm     ENDC
00000F22                          2213mm 
00000F22                          2214mm     ENDM
00000F22  57CE FFDA               2215m     DBEQ D6,LOOP_126
00000F26                          2216m     ENDM
00000F26                          2217m         PRINT_CRLF D5,A4
00000F26  49FA 0E95               2218m     LEA CRLF(PC),A4
00000F2A                          2219mm     PRINT_STR A4,D5
00000F2A                          2220mm LOOP_132
00000F2A  0C14 0000               2221mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000F2E  6700 0016               2222mm     BEQ EXIT_132
00000F32                          2223mmm     PRINT_CHAR (A4)+,D5
00000F32                          2224mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F32                 TRUE     2225mmm     IFEQ DEBUG
00000F32  1A39 00C00003           2226mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F38  0805 0002               2227mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F3C  67F4                    2228mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000F3E  13DC 00C00007           2229mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F44                          2230mmm     ENDC
00000F44                          2231mmm 
00000F44                 FALSE    2232mmm     IFNE DEBUG
00000F44                          2233mmm     ENDC
00000F44                          2234mmm 
00000F44                          2235mmm     ENDM
00000F44  60E4                    2236mm     BRA LOOP_132
00000F46                          2237mm EXIT_132
00000F46                          2238mm     ENDM
00000F46                          2239m     ENDM
00000F46                          2240          
00000F46  6000 F714               2241          BRA MAIN_LOOP
00000F4A                          2242      ENDI
00000F4A                          2243s _0000000C
00000F4A                          2244  
00000F4A                          2245      IF D1 <EQ> #0 THEN
00000F4A  B27C 0000               2246s     CMP.W   #0,D1
00000F4E  6600 0006               2247s     BNE _0000000D
00000F52  6000 F9B8               2248        BRA WAIT_FOR_SRECORD
00000F56                          2249      ENDI
00000F56                          2250s _0000000D
00000F56                          2251  DOWNLOAD_DONE
00000F56                          2252m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000F56  43FA 0E6B               2253m     LEA OX(PC),A1
00000F5A                          2254mm     PRINT_STR A1,D5
00000F5A                          2255mm LOOP_135
00000F5A  0C11 0000               2256mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F5E  6700 0016               2257mm     BEQ EXIT_135
00000F62                          2258mmm     PRINT_CHAR (A1)+,D5
00000F62                          2259mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F62                 TRUE     2260mmm     IFEQ DEBUG
00000F62  1A39 00C00003           2261mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F68  0805 0002               2262mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F6C  67F4                    2263mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000F6E  13D9 00C00007           2264mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F74                          2265mmm     ENDC
00000F74                          2266mmm 
00000F74                 FALSE    2267mmm     IFNE DEBUG
00000F74                          2268mmm     ENDC
00000F74                          2269mmm 
00000F74                          2270mmm     ENDM
00000F74  60E4                    2271mm     BRA LOOP_135
00000F76                          2272mm EXIT_135
00000F76                          2273mm     ENDM
00000F76  7407                    2274m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F78                          2275m LOOP_134
00000F78                          2276mm     BIN2HEX D0,D6,A1
00000F78  43FA 0DC5               2277mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000F7C  E998                    2278mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F7E  1C00                    2279mm     MOVE.B D0,D6
00000F80  0286 0000000F           2280mm     ANDI.L #$F,D6
00000F86  1C31 6000               2281mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000F8A                          2282mm     ENDM
00000F8A                          2283mm     PRINT_CHAR D6,D5
00000F8A                          2284mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F8A                 TRUE     2285mm     IFEQ DEBUG
00000F8A  1A39 00C00003           2286mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F90  0805 0002               2287mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F94  67F4                    2288mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000F96  13C6 00C00007           2289mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F9C                          2290mm     ENDC
00000F9C                          2291mm 
00000F9C                 FALSE    2292mm     IFNE DEBUG
00000F9C                          2293mm     ENDC
00000F9C                          2294mm 
00000F9C                          2295mm     ENDM
00000F9C  57CA FFDA               2296m     DBEQ D2,LOOP_134
00000FA0                          2297m     ENDM
00000FA0  43FA 0D42               2298      LEA READ(PC),A1
00000FA4                          2299m     PRINT_STR A1,D5
00000FA4                          2300m LOOP_139
00000FA4  0C11 0000               2301m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FA8  6700 0016               2302m     BEQ EXIT_139
00000FAC                          2303mm     PRINT_CHAR (A1)+,D5
00000FAC                          2304mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FAC                 TRUE     2305mm     IFEQ DEBUG
00000FAC  1A39 00C00003           2306mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FB2  0805 0002               2307mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000FB6  67F4                    2308mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000FB8  13D9 00C00007           2309mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FBE                          2310mm     ENDC
00000FBE                          2311mm 
00000FBE                 FALSE    2312mm     IFNE DEBUG
00000FBE                          2313mm     ENDC
00000FBE                          2314mm 
00000FBE                          2315mm     ENDM
00000FBE  60E4                    2316m     BRA LOOP_139
00000FC0                          2317m EXIT_139
00000FC0                          2318m     ENDM
00000FC0  2E08                    2319      MOVE.L A0,D7                                    ; set address accumulator to start address
00000FC2                          2320m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000FC2  43FA 0DFF               2321m     LEA OX(PC),A1
00000FC6                          2322mm     PRINT_STR A1,D5
00000FC6                          2323mm LOOP_142
00000FC6  0C11 0000               2324mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FCA  6700 0016               2325mm     BEQ EXIT_142
00000FCE                          2326mmm     PRINT_CHAR (A1)+,D5
00000FCE                          2327mmm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FCE                 TRUE     2328mmm     IFEQ DEBUG
00000FCE  1A39 00C00003           2329mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FD4  0805 0002               2330mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000FD8  67F4                    2331mmm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000FDA  13D9 00C00007           2332mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FE0                          2333mmm     ENDC
00000FE0                          2334mmm 
00000FE0                 FALSE    2335mmm     IFNE DEBUG
00000FE0                          2336mmm     ENDC
00000FE0                          2337mmm 
00000FE0                          2338mmm     ENDM
00000FE0  60E4                    2339mm     BRA LOOP_142
00000FE2                          2340mm EXIT_142
00000FE2                          2341mm     ENDM
00000FE2  7407                    2342m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FE4                          2343m LOOP_141
00000FE4                          2344mm     BIN2HEX D7,D6,A1
00000FE4  43FA 0D59               2345mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000FE8  E99F                    2346mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FEA  1C07                    2347mm     MOVE.B D7,D6
00000FEC  0286 0000000F           2348mm     ANDI.L #$F,D6
00000FF2  1C31 6000               2349mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000FF6                          2350mm     ENDM
00000FF6                          2351mm     PRINT_CHAR D6,D5
00000FF6                          2352mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FF6                 TRUE     2353mm     IFEQ DEBUG
00000FF6  1A39 00C00003           2354mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FFC  0805 0002               2355mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001000  67F4                    2356mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00001002  13C6 00C00007           2357mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001008                          2358mm     ENDC
00001008                          2359mm 
00001008                 FALSE    2360mm     IFNE DEBUG
00001008                          2361mm     ENDC
00001008                          2362mm 
00001008                          2363mm     ENDM
00001008  57CA FFDA               2364m     DBEQ D2,LOOP_141
0000100C                          2365m     ENDM
0000100C                          2366m     PRINT_CRLF D5,A4
0000100C  49FA 0DAF               2367m     LEA CRLF(PC),A4
00001010                          2368mm     PRINT_STR A4,D5
00001010                          2369mm LOOP_147
00001010  0C14 0000               2370mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00001014  6700 0016               2371mm     BEQ EXIT_147
00001018                          2372mmm     PRINT_CHAR (A4)+,D5
00001018                          2373mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001018                 TRUE     2374mmm     IFEQ DEBUG
00001018  1A39 00C00003           2375mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000101E  0805 0002               2376mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001022  67F4                    2377mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00001024  13DC 00C00007           2378mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000102A                          2379mmm     ENDC
0000102A                          2380mmm 
0000102A                 FALSE    2381mmm     IFNE DEBUG
0000102A                          2382mmm     ENDC
0000102A                          2383mmm 
0000102A                          2384mmm     ENDM
0000102A  60E4                    2385mm     BRA LOOP_147
0000102C                          2386mm EXIT_147
0000102C                          2387mm     ENDM
0000102C                          2388m     ENDM
0000102C                          2389  
0000102C  6000 F62E               2390      BRA MAIN_LOOP
00001030                          2391  
00001030                          2392  G
00001030  2047                    2393      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00001032  7E00                    2394      MOVE.L #0,D7
00001034                          2395  
00001034  4ED0                    2396      JMP (A0)
00001036                          2397          
00001036                          2398  Z
00001036  207C 00200000           2399      MOVE.L #RAM,A0                                  ; address of RAM
0000103C  D1FC 00100000           2400      ADD.L #$100000,A0
00001042                          2401  
00001042                          2402      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00001042  7000                    2403s     MOVE.L  #0,D0
00001044  6000 0012               2404s     BRA _20000007
00001048                          2405s _20000006
00001048  2200                    2406          MOVE.L D0,D1                                ; progress update
0000104A  E089                    2407          LSR.L #8,D1 
0000104C  E089                    2408          LSR.L #8,D1
0000104E  13C1 00E00001           2409          MOVE.B D1,DISPLAY
00001054                          2410          
00001054  2108                    2411          MOVE.L A0,-(A0)
00001056                          2412      ENDF
00001056  5880                    2413s     ADD.L   #4,D0
00001058                          2414s _20000007
00001058  B0BC 000FFFFC           2415s     CMP.L   #$FFFFC,D0
0000105E  6FE8                    2416s     BLE _20000006
00001060                          2417  
00001060  207C 00200000           2418      MOVE.L #RAM,A0                                  ; address of RAM
00001066  D1FC 00100000           2419      ADD.L #$100000,A0
0000106C                          2420  
0000106C                          2421      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
0000106C  7000                    2422s     MOVE.L  #0,D0
0000106E  6000 00A8               2423s     BRA _20000009
00001072                          2424s _20000008
00001072  2200                    2425          MOVE.L D0,D1                                ; progress update
00001074  E089                    2426          LSR.L #8,D1
00001076  E089                    2427          LSR.L #8,D1
00001078  13C1 00E00001           2428          MOVE.B D1,DISPLAY
0000107E                          2429  
0000107E  2408                    2430          MOVE.L A0,D2
00001080  2220                    2431          MOVE.L -(A0),D1
00001082                          2432  
00001082                          2433          IF.L D2 <NE> D1 THEN
00001082  B481                    2434s     CMP.L   D1,D2
00001084  6700 0090               2435s     BEQ _0000000E
00001088  43FA 0CA4               2436              LEA RAM_ERROR(PC),A1
0000108C                          2437m             PRINT_STR A1,D1
0000108C                          2438m LOOP_149
0000108C  0C11 0000               2439m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001090  6700 0016               2440m     BEQ EXIT_149
00001094                          2441mm     PRINT_CHAR (A1)+,D1
00001094                          2442mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001094                 TRUE     2443mm     IFEQ DEBUG
00001094  1239 00C00003           2444mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000109A  0801 0002               2445mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000109E  67F4                    2446mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
000010A0  13D9 00C00007           2447mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010A6                          2448mm     ENDC
000010A6                          2449mm 
000010A6                 FALSE    2450mm     IFNE DEBUG
000010A6                          2451mm     ENDC
000010A6                          2452mm 
000010A6                          2453mm     ENDM
000010A6  60E4                    2454m     BRA LOOP_149
000010A8                          2455m EXIT_149
000010A8                          2456m     ENDM
000010A8  2208                    2457              MOVE.L A0,D1
000010AA  5981                    2458              SUB.L #4,D1
000010AC                          2459m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
000010AC  43FA 0D15               2460m     LEA OX(PC),A1
000010B0                          2461mm     PRINT_STR A1,D3
000010B0                          2462mm LOOP_152
000010B0  0C11 0000               2463mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010B4  6700 0016               2464mm     BEQ EXIT_152
000010B8                          2465mmm     PRINT_CHAR (A1)+,D3
000010B8                          2466mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010B8                 TRUE     2467mmm     IFEQ DEBUG
000010B8  1639 00C00003           2468mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010BE  0803 0002               2469mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010C2  67F4                    2470mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
000010C4  13D9 00C00007           2471mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010CA                          2472mmm     ENDC
000010CA                          2473mmm 
000010CA                 FALSE    2474mmm     IFNE DEBUG
000010CA                          2475mmm     ENDC
000010CA                          2476mmm 
000010CA                          2477mmm     ENDM
000010CA  60E4                    2478mm     BRA LOOP_152
000010CC                          2479mm EXIT_152
000010CC                          2480mm     ENDM
000010CC  7C07                    2481m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010CE                          2482m LOOP_151
000010CE                          2483mm     BIN2HEX D1,D2,A1
000010CE  43FA 0C6F               2484mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
000010D2  E999                    2485mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010D4  1401                    2486mm     MOVE.B D1,D2
000010D6  0282 0000000F           2487mm     ANDI.L #$F,D2
000010DC  1431 2000               2488mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000010E0                          2489mm     ENDM
000010E0                          2490mm     PRINT_CHAR D2,D3
000010E0                          2491mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010E0                 TRUE     2492mm     IFEQ DEBUG
000010E0  1639 00C00003           2493mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010E6  0803 0002               2494mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010EA  67F4                    2495mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
000010EC  13C2 00C00007           2496mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010F2                          2497mm     ENDC
000010F2                          2498mm 
000010F2                 FALSE    2499mm     IFNE DEBUG
000010F2                          2500mm     ENDC
000010F2                          2501mm 
000010F2                          2502mm     ENDM
000010F2  57CE FFDA               2503m     DBEQ D6,LOOP_151
000010F6                          2504m     ENDM
000010F6                          2505m             PRINT_CRLF D3,A1
000010F6  43FA 0CC5               2506m     LEA CRLF(PC),A1
000010FA                          2507mm     PRINT_STR A1,D3
000010FA                          2508mm LOOP_157
000010FA  0C11 0000               2509mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010FE  6700 0016               2510mm     BEQ EXIT_157
00001102                          2511mmm     PRINT_CHAR (A1)+,D3
00001102                          2512mmm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001102                 TRUE     2513mmm     IFEQ DEBUG
00001102  1639 00C00003           2514mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001108  0803 0002               2515mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000110C  67F4                    2516mmm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
0000110E  13D9 00C00007           2517mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001114                          2518mmm     ENDC
00001114                          2519mmm 
00001114                 FALSE    2520mmm     IFNE DEBUG
00001114                          2521mmm     ENDC
00001114                          2522mmm 
00001114                          2523mmm     ENDM
00001114  60E4                    2524mm     BRA LOOP_157
00001116                          2525mm EXIT_157
00001116                          2526mm     ENDM
00001116                          2527m     ENDM
00001116                          2528          ENDI 
00001116                          2529s _0000000E
00001116                          2530      ENDF
00001116  5880                    2531s     ADD.L   #4,D0
00001118                          2532s _20000009
00001118  B0BC 000FFFFC           2533s     CMP.L   #$FFFFC,D0
0000111E  6F00 FF52               2534s     BLE _20000008
00001122                          2535  
00001122  6000 F538               2536      BRA MAIN_LOOP
00001126                          2537  
00001126                          2538  L
00001126  7000                    2539      MOVE.L #0,D0                                    ; D0 will be the length to write               
00001128  7200                    2540      MOVE.L #0,D1                                    ; D1 will be the address to write 
0000112A                          2541  
0000112A                          2542      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
0000112A  343C 0000               2543s     MOVE.W  #0,D2
0000112E  6000 0046               2544s     BRA _2000000B
00001132                          2545s _2000000A
00001132  E989                    2546          LSL.L #4,D1                                 ; make what we have so far more significant
00001134                          2547m         WAIT_CHAR D3,D4                             ; next character -> D2
00001134                          2548m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001134                 TRUE     2549m     IFEQ DEBUG
00001134  1839 00C00003           2550m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000113A  0804 0000               2551m         BTST #0,D4                                  ; CHECK FOR CHARACTER
0000113E  67F4                    2552m         BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00001140                          2553m     ENDC
00001140                          2554m 
00001140                          2555mm     READ_CHAR D3
00001140                 TRUE     2556mm     IFEQ DEBUG
00001140  1639 00C00007           2557mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001146                          2558mm     ENDC
00001146                 FALSE    2559mm     IFNE DEBUG
00001146                          2560mm     ENDC
00001146                          2561mm 
00001146  B63C 001B               2562mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
0000114A  6700 F2B4               2563mm     BEQ START
0000114E                          2564mm     ENDM
0000114E                          2565m 
0000114E                 TRUE     2566m     IFEQ DEBUG
0000114E                          2567mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
0000114E                          2568mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000114E                 TRUE     2569mm     IFEQ DEBUG
0000114E  1839 00C00003           2570mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001154  0804 0002               2571mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001158  67F4                    2572mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
0000115A  13C3 00C00007           2573mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001160                          2574mm     ENDC
00001160                          2575mm 
00001160                 FALSE    2576mm     IFNE DEBUG
00001160                          2577mm     ENDC
00001160                          2578mm 
00001160                          2579mm     ENDM
00001160                          2580m     ENDC
00001160                          2581m     ENDM
00001160                          2582m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00001160  41FA 0BED               2583m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001164  0403 0030               2584m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001168  C6BC 000000FF           2585m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
0000116E  1630 3000               2586m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001172                          2587m     ENDM
00001172  8203                    2588          OR.B D3,D1
00001174                          2589      ENDF
00001174  5242                    2590s     ADD.W   #1,D2
00001176                          2591s _2000000B
00001176  B47C 0007               2592s     CMP.W   #7,D2
0000117A  6FB6                    2593s     BLE _2000000A
0000117C                          2594  
0000117C  3001                    2595      MOVE.W D1,D0                                    ; extract the LSword for the length 
0000117E  0480 00000400           2596      SUB.L #START,D0                                 ; remove the vector table from the length
00001184  E089                    2597      LSR.L #8,D1                                     ; extract the MSword for the address
00001186  E089                    2598      LSR.L #8,D1
00001188                          2599  
00001188                          2600m     PRINT_CRLF D2,A1
00001188  43FA 0C33               2601m     LEA CRLF(PC),A1
0000118C                          2602mm     PRINT_STR A1,D2
0000118C                          2603mm LOOP_164
0000118C  0C11 0000               2604mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001190  6700 0016               2605mm     BEQ EXIT_164
00001194                          2606mmm     PRINT_CHAR (A1)+,D2
00001194                          2607mmm WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001194                 TRUE     2608mmm     IFEQ DEBUG
00001194  1439 00C00003           2609mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000119A  0802 0002               2610mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000119E  67F4                    2611mmm         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
000011A0  13D9 00C00007           2612mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011A6                          2613mmm     ENDC
000011A6                          2614mmm 
000011A6                 FALSE    2615mmm     IFNE DEBUG
000011A6                          2616mmm     ENDC
000011A6                          2617mmm 
000011A6                          2618mmm     ENDM
000011A6  60E4                    2619mm     BRA LOOP_164
000011A8                          2620mm EXIT_164
000011A8                          2621mm     ENDM
000011A8                          2622m     ENDM
000011A8                          2623  
000011A8  2041                    2624      MOVE.L D1,A0                                    ; target address
000011AA  2641                    2625      MOVE.L D1,A3                                    ; keep a copy for later
000011AC                          2626  
000011AC  2247                    2627      MOVE.L D7,A1                                    ; address accumulator -> address register
000011AE  D3FC 00000400           2628      ADD.L #START,A1                                 ; skip the vectors
000011B4  2847                    2629      MOVE.L D7,A4                                    ; keep a clean copy for later
000011B6  7E00                    2630      MOVE.L #0,D7                                    ; clear the now used address accumulator
000011B8                          2631  
000011B8                          2632m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000011B8  31FC AAAA 2AAA          2633m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000011BE  4E71                    2634m     NOP
000011C0  31FC 5555 1554          2635m     MOVE.W #$5555,$1554
000011C6  4E71                    2636m     NOP
000011C8  31FC 8080 2AAA          2637m     MOVE.W #$8080,$2AAA
000011CE  4E71                    2638m     NOP
000011D0  31FC AAAA 2AAA          2639m     MOVE.W #$AAAA,$2AAA
000011D6  4E71                    2640m     NOP
000011D8  31FC 5555 1554          2641m     MOVE.W #$5555,$1554
000011DE  4E71                    2642m     NOP
000011E0  31FC 2020 2AAA          2643m     MOVE.W #$2020,$2AAA
000011E6                          2644m     ENDM
000011E6                          2645                              
000011E6                          2646      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000011E6  3E3C 0000               2647s     MOVE.W  #$0,D7
000011EA  6000 0006               2648s     BRA _2000000D
000011EE                          2649s _2000000C
000011EE  4E71                    2650          NOP
000011F0                          2651      ENDF
000011F0  5247                    2652s     ADD.W   #1,D7
000011F2                          2653s _2000000D
000011F2  BE7C FFFF               2654s     CMP.W   #$FFFFFFFF,D7
000011F6  6FF6                    2655s     BLE _2000000C
000011F8                          2656  
000011F8  45FA 0B6C               2657      LEA LOADING(PC),A2
000011FC                          2658m     PRINT_STR A2,D2
000011FC                          2659m LOOP_167
000011FC  0C12 0000               2660m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001200  6700 0016               2661m     BEQ EXIT_167
00001204                          2662mm     PRINT_CHAR (A2)+,D2
00001204                          2663mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001204                 TRUE     2664mm     IFEQ DEBUG
00001204  1439 00C00003           2665mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000120A  0802 0002               2666mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000120E  67F4                    2667mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00001210  13DA 00C00007           2668mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001216                          2669mm     ENDC
00001216                          2670mm 
00001216                 FALSE    2671mm     IFNE DEBUG
00001216                          2672mm     ENDC
00001216                          2673mm 
00001216                          2674mm     ENDM
00001216  60E4                    2675m     BRA LOOP_167
00001218                          2676m EXIT_167
00001218                          2677m     ENDM
00001218                          2678      
00001218  45FA 0B60               2679      LEA CODE(PC),A2
0000121C                          2680m     PRINT_STR A2,D2
0000121C                          2681m LOOP_169
0000121C  0C12 0000               2682m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001220  6700 0016               2683m     BEQ EXIT_169
00001224                          2684mm     PRINT_CHAR (A2)+,D2
00001224                          2685mm WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001224                 TRUE     2686mm     IFEQ DEBUG
00001224  1439 00C00003           2687mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000122A  0802 0002               2688mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000122E  67F4                    2689mm         BEQ WAIT_FOR_READY_170                      ; NO SPACE, CHECK AGAIN
00001230  13DA 00C00007           2690mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001236                          2691mm     ENDC
00001236                          2692mm 
00001236                 FALSE    2693mm     IFNE DEBUG
00001236                          2694mm     ENDC
00001236                          2695mm 
00001236                          2696mm     ENDM
00001236  60E4                    2697m     BRA LOOP_169
00001238                          2698m EXIT_169
00001238                          2699m     ENDM
00001238                          2700      
00001238  2409                    2701      MOVE.L A1,D2
0000123A                          2702m     PRINT_REG D2,D3,D4,D5,A2
0000123A  45FA 0B87               2703m     LEA OX(PC),A2
0000123E                          2704mm     PRINT_STR A2,D3
0000123E                          2705mm LOOP_172
0000123E  0C12 0000               2706mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001242  6700 0016               2707mm     BEQ EXIT_172
00001246                          2708mmm     PRINT_CHAR (A2)+,D3
00001246                          2709mmm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001246                 TRUE     2710mmm     IFEQ DEBUG
00001246  1639 00C00003           2711mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000124C  0803 0002               2712mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001250  67F4                    2713mmm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00001252  13DA 00C00007           2714mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001258                          2715mmm     ENDC
00001258                          2716mmm 
00001258                 FALSE    2717mmm     IFNE DEBUG
00001258                          2718mmm     ENDC
00001258                          2719mmm 
00001258                          2720mmm     ENDM
00001258  60E4                    2721mm     BRA LOOP_172
0000125A                          2722mm EXIT_172
0000125A                          2723mm     ENDM
0000125A  7A07                    2724m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000125C                          2725m LOOP_171
0000125C                          2726mm     BIN2HEX D2,D4,A2
0000125C  45FA 0AE1               2727mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001260  E99A                    2728mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001262  1802                    2729mm     MOVE.B D2,D4
00001264  0284 0000000F           2730mm     ANDI.L #$F,D4
0000126A  1832 4000               2731mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000126E                          2732mm     ENDM
0000126E                          2733mm     PRINT_CHAR D4,D3
0000126E                          2734mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000126E                 TRUE     2735mm     IFEQ DEBUG
0000126E  1639 00C00003           2736mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001274  0803 0002               2737mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001278  67F4                    2738mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
0000127A  13C4 00C00007           2739mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001280                          2740mm     ENDC
00001280                          2741mm 
00001280                 FALSE    2742mm     IFNE DEBUG
00001280                          2743mm     ENDC
00001280                          2744mm 
00001280                          2745mm     ENDM
00001280  57CD FFDA               2746m     DBEQ D5,LOOP_171
00001284                          2747m     ENDM
00001284                          2748  
00001284  45FA 0B40               2749      LEA TO(PC),A2
00001288                          2750m     PRINT_STR A2,D3
00001288                          2751m LOOP_176
00001288  0C12 0000               2752m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000128C  6700 0016               2753m     BEQ EXIT_176
00001290                          2754mm     PRINT_CHAR (A2)+,D3
00001290                          2755mm WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001290                 TRUE     2756mm     IFEQ DEBUG
00001290  1639 00C00003           2757mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001296  0803 0002               2758mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000129A  67F4                    2759mm         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
0000129C  13DA 00C00007           2760mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012A2                          2761mm     ENDC
000012A2                          2762mm 
000012A2                 FALSE    2763mm     IFNE DEBUG
000012A2                          2764mm     ENDC
000012A2                          2765mm 
000012A2                          2766mm     ENDM
000012A2  60E4                    2767m     BRA LOOP_176
000012A4                          2768m EXIT_176
000012A4                          2769m     ENDM
000012A4                          2770  
000012A4  2408                    2771      MOVE.L A0,D2
000012A6                          2772m     PRINT_REG D2,D3,D4,D5,A2
000012A6  45FA 0B1B               2773m     LEA OX(PC),A2
000012AA                          2774mm     PRINT_STR A2,D3
000012AA                          2775mm LOOP_179
000012AA  0C12 0000               2776mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012AE  6700 0016               2777mm     BEQ EXIT_179
000012B2                          2778mmm     PRINT_CHAR (A2)+,D3
000012B2                          2779mmm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B2                 TRUE     2780mmm     IFEQ DEBUG
000012B2  1639 00C00003           2781mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B8  0803 0002               2782mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012BC  67F4                    2783mmm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
000012BE  13DA 00C00007           2784mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012C4                          2785mmm     ENDC
000012C4                          2786mmm 
000012C4                 FALSE    2787mmm     IFNE DEBUG
000012C4                          2788mmm     ENDC
000012C4                          2789mmm 
000012C4                          2790mmm     ENDM
000012C4  60E4                    2791mm     BRA LOOP_179
000012C6                          2792mm EXIT_179
000012C6                          2793mm     ENDM
000012C6  7A07                    2794m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012C8                          2795m LOOP_178
000012C8                          2796mm     BIN2HEX D2,D4,A2
000012C8  45FA 0A75               2797mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012CC  E99A                    2798mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012CE  1802                    2799mm     MOVE.B D2,D4
000012D0  0284 0000000F           2800mm     ANDI.L #$F,D4
000012D6  1832 4000               2801mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000012DA                          2802mm     ENDM
000012DA                          2803mm     PRINT_CHAR D4,D3
000012DA                          2804mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012DA                 TRUE     2805mm     IFEQ DEBUG
000012DA  1639 00C00003           2806mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012E0  0803 0002               2807mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012E4  67F4                    2808mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
000012E6  13C4 00C00007           2809mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012EC                          2810mm     ENDC
000012EC                          2811mm 
000012EC                 FALSE    2812mm     IFNE DEBUG
000012EC                          2813mm     ENDC
000012EC                          2814mm 
000012EC                          2815mm     ENDM
000012EC  57CD FFDA               2816m     DBEQ D5,LOOP_178
000012F0                          2817m     ENDM
000012F0                          2818  
000012F0  45FA 0AD9               2819      LEA FOR(PC),A2
000012F4                          2820m     PRINT_STR A2,D3
000012F4                          2821m LOOP_183
000012F4  0C12 0000               2822m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012F8  6700 0016               2823m     BEQ EXIT_183
000012FC                          2824mm     PRINT_CHAR (A2)+,D3
000012FC                          2825mm WAIT_FOR_READY_184                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012FC                 TRUE     2826mm     IFEQ DEBUG
000012FC  1639 00C00003           2827mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001302  0803 0002               2828mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001306  67F4                    2829mm         BEQ WAIT_FOR_READY_184                      ; NO SPACE, CHECK AGAIN
00001308  13DA 00C00007           2830mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000130E                          2831mm     ENDC
0000130E                          2832mm 
0000130E                 FALSE    2833mm     IFNE DEBUG
0000130E                          2834mm     ENDC
0000130E                          2835mm 
0000130E                          2836mm     ENDM
0000130E  60E4                    2837m     BRA LOOP_183
00001310                          2838m EXIT_183
00001310                          2839m     ENDM
00001310                          2840m     PRINT_REG D0,D3,D4,D5,A2
00001310  45FA 0AB1               2841m     LEA OX(PC),A2
00001314                          2842mm     PRINT_STR A2,D3
00001314                          2843mm LOOP_186
00001314  0C12 0000               2844mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001318  6700 0016               2845mm     BEQ EXIT_186
0000131C                          2846mmm     PRINT_CHAR (A2)+,D3
0000131C                          2847mmm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000131C                 TRUE     2848mmm     IFEQ DEBUG
0000131C  1639 00C00003           2849mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001322  0803 0002               2850mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001326  67F4                    2851mmm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
00001328  13DA 00C00007           2852mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000132E                          2853mmm     ENDC
0000132E                          2854mmm 
0000132E                 FALSE    2855mmm     IFNE DEBUG
0000132E                          2856mmm     ENDC
0000132E                          2857mmm 
0000132E                          2858mmm     ENDM
0000132E  60E4                    2859mm     BRA LOOP_186
00001330                          2860mm EXIT_186
00001330                          2861mm     ENDM
00001330  7A07                    2862m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001332                          2863m LOOP_185
00001332                          2864mm     BIN2HEX D0,D4,A2
00001332  45FA 0A0B               2865mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001336  E998                    2866mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001338  1800                    2867mm     MOVE.B D0,D4
0000133A  0284 0000000F           2868mm     ANDI.L #$F,D4
00001340  1832 4000               2869mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001344                          2870mm     ENDM
00001344                          2871mm     PRINT_CHAR D4,D3
00001344                          2872mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001344                 TRUE     2873mm     IFEQ DEBUG
00001344  1639 00C00003           2874mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000134A  0803 0002               2875mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000134E  67F4                    2876mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
00001350  13C4 00C00007           2877mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001356                          2878mm     ENDC
00001356                          2879mm 
00001356                 FALSE    2880mm     IFNE DEBUG
00001356                          2881mm     ENDC
00001356                          2882mm 
00001356                          2883mm     ENDM
00001356  57CD FFDA               2884m     DBEQ D5,LOOP_185
0000135A                          2885m     ENDM
0000135A                          2886  
0000135A                          2887m     PRINT_CRLF D3,A2
0000135A  45FA 0A61               2888m     LEA CRLF(PC),A2
0000135E                          2889mm     PRINT_STR A2,D3
0000135E                          2890mm LOOP_191
0000135E  0C12 0000               2891mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001362  6700 0016               2892mm     BEQ EXIT_191
00001366                          2893mmm     PRINT_CHAR (A2)+,D3
00001366                          2894mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001366                 TRUE     2895mmm     IFEQ DEBUG
00001366  1639 00C00003           2896mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000136C  0803 0002               2897mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001370  67F4                    2898mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00001372  13DA 00C00007           2899mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001378                          2900mmm     ENDC
00001378                          2901mmm 
00001378                 FALSE    2902mmm     IFNE DEBUG
00001378                          2903mmm     ENDC
00001378                          2904mmm 
00001378                          2905mmm     ENDM
00001378  60E4                    2906mm     BRA LOOP_191
0000137A                          2907mm EXIT_191
0000137A                          2908mm     ENDM
0000137A                          2909m     ENDM
0000137A                          2910  
0000137A                          2911      WHILE D0 <GT> #0 DO
0000137A                          2912s _10000014
0000137A  B07C 0000               2913s     CMP.W   #0,D0
0000137E  6F00 001C               2914s     BLE _10000015
00001382  5580                    2915          SUB.L #2,D0
00001384                          2916  
00001384  13D1 00E00001           2917          MOVE.B (A1),DISPLAY
0000138A                          2918m         PROGRAM (A1),(A0),D2
0000138A  3091                    2919m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
0000138C                          2920m 
0000138C                          2921m WAIT_FOR_COMPLETE_193
0000138C  3410                    2922m         MOVE.W (A0),D2
0000138E                          2923m 
0000138E                          2924m         IF.W D2 <NE> (A1) THEN
0000138E  B451                    2925ms     CMP.W   (A1),D2
00001390  6700 0004               2926ms     BEQ _0000000F
00001394  60F6                    2927m             BRA WAIT_FOR_COMPLETE_193
00001396                          2928m         ENDI
00001396                          2929ms _0000000F
00001396                          2930m         ENDM
00001396                          2931          
00001396                          2932          ;PRINT_CHAR #'.',D7
00001396                          2933          
00001396  5488                    2934          ADD.L #2,A0
00001398  5489                    2935          ADD.L #2,A1
0000139A                          2936      ENDW
0000139A  60DE                    2937s     BRA _10000014
0000139C                          2938s _10000015
0000139C                          2939  
0000139C  45FA 09EB               2940      LEA SP(PC),A2
000013A0                          2941m     PRINT_STR A2,D2
000013A0                          2942m LOOP_194
000013A0  0C12 0000               2943m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013A4  6700 0016               2944m     BEQ EXIT_194
000013A8                          2945mm     PRINT_CHAR (A2)+,D2
000013A8                          2946mm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013A8                 TRUE     2947mm     IFEQ DEBUG
000013A8  1439 00C00003           2948mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013AE  0802 0002               2949mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013B2  67F4                    2950mm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
000013B4  13DA 00C00007           2951mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013BA                          2952mm     ENDC
000013BA                          2953mm 
000013BA                 FALSE    2954mm     IFNE DEBUG
000013BA                          2955mm     ENDC
000013BA                          2956mm 
000013BA                          2957mm     ENDM
000013BA  60E4                    2958m     BRA LOOP_194
000013BC                          2959m EXIT_194
000013BC                          2960m     ENDM
000013BC                          2961      
000013BC  41F8 0000               2962      LEA STACK,A0
000013C0  D1CC                    2963      ADD.L A4,A0
000013C2  2010                    2964      MOVE.L (A0),D0
000013C4                          2965m     PRINT_REG D0,D2,D3,D4,A3
000013C4  47FA 09FD               2966m     LEA OX(PC),A3
000013C8                          2967mm     PRINT_STR A3,D2
000013C8                          2968mm LOOP_197
000013C8  0C13 0000               2969mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000013CC  6700 0016               2970mm     BEQ EXIT_197
000013D0                          2971mmm     PRINT_CHAR (A3)+,D2
000013D0                          2972mmm WAIT_FOR_READY_198                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013D0                 TRUE     2973mmm     IFEQ DEBUG
000013D0  1439 00C00003           2974mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013D6  0802 0002               2975mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013DA  67F4                    2976mmm         BEQ WAIT_FOR_READY_198                      ; NO SPACE, CHECK AGAIN
000013DC  13DB 00C00007           2977mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013E2                          2978mmm     ENDC
000013E2                          2979mmm 
000013E2                 FALSE    2980mmm     IFNE DEBUG
000013E2                          2981mmm     ENDC
000013E2                          2982mmm 
000013E2                          2983mmm     ENDM
000013E2  60E4                    2984mm     BRA LOOP_197
000013E4                          2985mm EXIT_197
000013E4                          2986mm     ENDM
000013E4  7807                    2987m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000013E6                          2988m LOOP_196
000013E6                          2989mm     BIN2HEX D0,D3,A3
000013E6  47FA 0957               2990mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000013EA  E998                    2991mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000013EC  1600                    2992mm     MOVE.B D0,D3
000013EE  0283 0000000F           2993mm     ANDI.L #$F,D3
000013F4  1633 3000               2994mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000013F8                          2995mm     ENDM
000013F8                          2996mm     PRINT_CHAR D3,D2
000013F8                          2997mm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013F8                 TRUE     2998mm     IFEQ DEBUG
000013F8  1439 00C00003           2999mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013FE  0802 0002               3000mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001402  67F4                    3001mm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
00001404  13C3 00C00007           3002mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000140A                          3003mm     ENDC
0000140A                          3004mm 
0000140A                 FALSE    3005mm     IFNE DEBUG
0000140A                          3006mm     ENDC
0000140A                          3007mm 
0000140A                          3008mm     ENDM
0000140A  57CC FFDA               3009m     DBEQ D4,LOOP_196
0000140E                          3010m     ENDM
0000140E                          3011m     PRINT_CRLF D2,A2
0000140E  45FA 09AD               3012m     LEA CRLF(PC),A2
00001412                          3013mm     PRINT_STR A2,D2
00001412                          3014mm LOOP_202
00001412  0C12 0000               3015mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001416  6700 0016               3016mm     BEQ EXIT_202
0000141A                          3017mmm     PRINT_CHAR (A2)+,D2
0000141A                          3018mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000141A                 TRUE     3019mmm     IFEQ DEBUG
0000141A  1439 00C00003           3020mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001420  0802 0002               3021mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001424  67F4                    3022mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00001426  13DA 00C00007           3023mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000142C                          3024mmm     ENDC
0000142C                          3025mmm 
0000142C                 FALSE    3026mmm     IFNE DEBUG
0000142C                          3027mmm     ENDC
0000142C                          3028mmm 
0000142C                          3029mmm     ENDM
0000142C  60E4                    3030mm     BRA LOOP_202
0000142E                          3031mm EXIT_202
0000142E                          3032mm     ENDM
0000142E                          3033m     ENDM
0000142E                          3034      
0000142E  207C 00000000           3035      MOVE.L #0,A0
00001434                          3036m     PROGRAM_VECTOR D0,A0,D2
00001434  5488                    3037m     ADD.L #2,A0
00001436                          3038mm     PROGRAM D0, (A0), D2                                ; WRITE IT
00001436  3080                    3039mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001438                          3040mm 
00001438                          3041mm WAIT_FOR_COMPLETE_205
00001438  3410                    3042mm         MOVE.W (A0),D2
0000143A                          3043mm 
0000143A                          3044mm         IF.W D2 <NE> D0 THEN
0000143A  B440                    3045mms     CMP.W   D0,D2
0000143C  6700 0004               3046mms     BEQ _00000010
00001440  60F6                    3047mm             BRA WAIT_FOR_COMPLETE_205
00001442                          3048mm         ENDI
00001442                          3049mms _00000010
00001442                          3050mm         ENDM
00001442  E088                    3051m     LSR.L #8,D0
00001444  E088                    3052m     LSR.L #8,D0
00001446  5588                    3053m     SUB.L #2,A0
00001448                          3054mm     PROGRAM D0, (A0), D2
00001448  3080                    3055mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000144A                          3056mm 
0000144A                          3057mm WAIT_FOR_COMPLETE_206
0000144A  3410                    3058mm         MOVE.W (A0),D2
0000144C                          3059mm 
0000144C                          3060mm         IF.W D2 <NE> D0 THEN
0000144C  B440                    3061mms     CMP.W   D0,D2
0000144E  6700 0004               3062mms     BEQ _00000011
00001452  60F6                    3063mm             BRA WAIT_FOR_COMPLETE_206
00001454                          3064mm         ENDI
00001454                          3065mms _00000011
00001454                          3066mm         ENDM
00001454                          3067m     ENDM
00001454                          3068      
00001454  45FA 0955               3069      LEA VECTORS(PC),A2
00001458                          3070m     PRINT_STR A2,D2
00001458                          3071m LOOP_207
00001458  0C12 0000               3072m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000145C  6700 0016               3073m     BEQ EXIT_207
00001460                          3074mm     PRINT_CHAR (A2)+,D2
00001460                          3075mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001460                 TRUE     3076mm     IFEQ DEBUG
00001460  1439 00C00003           3077mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001466  0802 0002               3078mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000146A  67F4                    3079mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
0000146C  13DA 00C00007           3080mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001472                          3081mm     ENDC
00001472                          3082mm 
00001472                 FALSE    3083mm     IFNE DEBUG
00001472                          3084mm     ENDC
00001472                          3085mm 
00001472                          3086mm     ENDM
00001472  60E4                    3087m     BRA LOOP_207
00001474                          3088m EXIT_207
00001474                          3089m     ENDM
00001474                          3090  
00001474                          3091      FOR A0 = #RESET TO #START-4 BY #4 DO
00001474  307C 0004               3092s     MOVE.W  #RESET,A0
00001478  6000 0108               3093s     BRA _2000000F
0000147C                          3094s _2000000E
0000147C                          3095  
0000147C  2248                    3096          MOVE.L A0,A1
0000147E  D3CC                    3097          ADD.L A4,A1
00001480                          3098              
00001480  2011                    3099          MOVE.L (A1),D0  
00001482  D081                    3100          ADD.L D1,D0
00001484  0480 00000400           3101          SUB.L #START,D0
0000148A                          3102m         PRINT_REG D0,D2,D3,D4,A3
0000148A  47FA 0937               3103m     LEA OX(PC),A3
0000148E                          3104mm     PRINT_STR A3,D2
0000148E                          3105mm LOOP_210
0000148E  0C13 0000               3106mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001492  6700 0016               3107mm     BEQ EXIT_210
00001496                          3108mmm     PRINT_CHAR (A3)+,D2
00001496                          3109mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001496                 TRUE     3110mmm     IFEQ DEBUG
00001496  1439 00C00003           3111mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000149C  0802 0002               3112mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014A0  67F4                    3113mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000014A2  13DB 00C00007           3114mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014A8                          3115mmm     ENDC
000014A8                          3116mmm 
000014A8                 FALSE    3117mmm     IFNE DEBUG
000014A8                          3118mmm     ENDC
000014A8                          3119mmm 
000014A8                          3120mmm     ENDM
000014A8  60E4                    3121mm     BRA LOOP_210
000014AA                          3122mm EXIT_210
000014AA                          3123mm     ENDM
000014AA  7807                    3124m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014AC                          3125m LOOP_209
000014AC                          3126mm     BIN2HEX D0,D3,A3
000014AC  47FA 0891               3127mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000014B0  E998                    3128mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014B2  1600                    3129mm     MOVE.B D0,D3
000014B4  0283 0000000F           3130mm     ANDI.L #$F,D3
000014BA  1633 3000               3131mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000014BE                          3132mm     ENDM
000014BE                          3133mm     PRINT_CHAR D3,D2
000014BE                          3134mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014BE                 TRUE     3135mm     IFEQ DEBUG
000014BE  1439 00C00003           3136mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014C4  0802 0002               3137mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014C8  67F4                    3138mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
000014CA  13C3 00C00007           3139mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014D0                          3140mm     ENDC
000014D0                          3141mm 
000014D0                 FALSE    3142mm     IFNE DEBUG
000014D0                          3143mm     ENDC
000014D0                          3144mm 
000014D0                          3145mm     ENDM
000014D0  57CC FFDA               3146m     DBEQ D4,LOOP_209
000014D4                          3147m     ENDM
000014D4                          3148  
000014D4  47FA 08F0               3149          LEA TO(PC),A3
000014D8                          3150m         PRINT_STR A3,D3
000014D8                          3151m LOOP_214
000014D8  0C13 0000               3152m     CMP.B #NULL,(A3)                                ; 0 -> DONE
000014DC  6700 0016               3153m     BEQ EXIT_214
000014E0                          3154mm     PRINT_CHAR (A3)+,D3
000014E0                          3155mm WAIT_FOR_READY_215                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014E0                 TRUE     3156mm     IFEQ DEBUG
000014E0  1639 00C00003           3157mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000014E6  0803 0002               3158mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000014EA  67F4                    3159mm         BEQ WAIT_FOR_READY_215                      ; NO SPACE, CHECK AGAIN
000014EC  13DB 00C00007           3160mm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014F2                          3161mm     ENDC
000014F2                          3162mm 
000014F2                 FALSE    3163mm     IFNE DEBUG
000014F2                          3164mm     ENDC
000014F2                          3165mm 
000014F2                          3166mm     ENDM
000014F2  60E4                    3167m     BRA LOOP_214
000014F4                          3168m EXIT_214
000014F4                          3169m     ENDM
000014F4                          3170  
000014F4  2408                    3171          MOVE.L A0,D2
000014F6                          3172m         PRINT_REG D2,D3,D4,D5,A3
000014F6  47FA 08CB               3173m     LEA OX(PC),A3
000014FA                          3174mm     PRINT_STR A3,D3
000014FA                          3175mm LOOP_217
000014FA  0C13 0000               3176mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000014FE  6700 0016               3177mm     BEQ EXIT_217
00001502                          3178mmm     PRINT_CHAR (A3)+,D3
00001502                          3179mmm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001502                 TRUE     3180mmm     IFEQ DEBUG
00001502  1639 00C00003           3181mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001508  0803 0002               3182mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000150C  67F4                    3183mmm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
0000150E  13DB 00C00007           3184mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001514                          3185mmm     ENDC
00001514                          3186mmm 
00001514                 FALSE    3187mmm     IFNE DEBUG
00001514                          3188mmm     ENDC
00001514                          3189mmm 
00001514                          3190mmm     ENDM
00001514  60E4                    3191mm     BRA LOOP_217
00001516                          3192mm EXIT_217
00001516                          3193mm     ENDM
00001516  7A07                    3194m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001518                          3195m LOOP_216
00001518                          3196mm     BIN2HEX D2,D4,A3
00001518  47FA 0825               3197mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
0000151C  E99A                    3198mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000151E  1802                    3199mm     MOVE.B D2,D4
00001520  0284 0000000F           3200mm     ANDI.L #$F,D4
00001526  1833 4000               3201mm     MOVE.B 0(A3,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000152A                          3202mm     ENDM
0000152A                          3203mm     PRINT_CHAR D4,D3
0000152A                          3204mm WAIT_FOR_READY_220                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000152A                 TRUE     3205mm     IFEQ DEBUG
0000152A  1639 00C00003           3206mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001530  0803 0002               3207mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001534  67F4                    3208mm         BEQ WAIT_FOR_READY_220                      ; NO SPACE, CHECK AGAIN
00001536  13C4 00C00007           3209mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000153C                          3210mm     ENDC
0000153C                          3211mm 
0000153C                 FALSE    3212mm     IFNE DEBUG
0000153C                          3213mm     ENDC
0000153C                          3214mm 
0000153C                          3215mm     ENDM
0000153C  57CD FFDA               3216m     DBEQ D5,LOOP_216
00001540                          3217m     ENDM
00001540                          3218          
00001540                          3219m         PRINT_CRLF D2,A3
00001540  47FA 087B               3220m     LEA CRLF(PC),A3
00001544                          3221mm     PRINT_STR A3,D2
00001544                          3222mm LOOP_222
00001544  0C13 0000               3223mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001548  6700 0016               3224mm     BEQ EXIT_222
0000154C                          3225mmm     PRINT_CHAR (A3)+,D2
0000154C                          3226mmm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000154C                 TRUE     3227mmm     IFEQ DEBUG
0000154C  1439 00C00003           3228mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001552  0802 0002               3229mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001556  67F4                    3230mmm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
00001558  13DB 00C00007           3231mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000155E                          3232mmm     ENDC
0000155E                          3233mmm 
0000155E                 FALSE    3234mmm     IFNE DEBUG
0000155E                          3235mmm     ENDC
0000155E                          3236mmm 
0000155E                          3237mmm     ENDM
0000155E  60E4                    3238mm     BRA LOOP_222
00001560                          3239mm EXIT_222
00001560                          3240mm     ENDM
00001560                          3241m     ENDM
00001560                          3242          
00001560                          3243m         PROGRAM_VECTOR D0,A0,D2
00001560  5488                    3244m     ADD.L #2,A0
00001562                          3245mm     PROGRAM D0, (A0), D2                                ; WRITE IT
00001562  3080                    3246mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001564                          3247mm 
00001564                          3248mm WAIT_FOR_COMPLETE_225
00001564  3410                    3249mm         MOVE.W (A0),D2
00001566                          3250mm 
00001566                          3251mm         IF.W D2 <NE> D0 THEN
00001566  B440                    3252mms     CMP.W   D0,D2
00001568  6700 0004               3253mms     BEQ _00000012
0000156C  60F6                    3254mm             BRA WAIT_FOR_COMPLETE_225
0000156E                          3255mm         ENDI
0000156E                          3256mms _00000012
0000156E                          3257mm         ENDM
0000156E  E088                    3258m     LSR.L #8,D0
00001570  E088                    3259m     LSR.L #8,D0
00001572  5588                    3260m     SUB.L #2,A0
00001574                          3261mm     PROGRAM D0, (A0), D2
00001574  3080                    3262mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001576                          3263mm 
00001576                          3264mm WAIT_FOR_COMPLETE_226
00001576  3410                    3265mm         MOVE.W (A0),D2
00001578                          3266mm 
00001578                          3267mm         IF.W D2 <NE> D0 THEN
00001578  B440                    3268mms     CMP.W   D0,D2
0000157A  6700 0004               3269mms     BEQ _00000013
0000157E  60F6                    3270mm             BRA WAIT_FOR_COMPLETE_226
00001580                          3271mm         ENDI
00001580                          3272mms _00000013
00001580                          3273mm         ENDM
00001580                          3274m     ENDM
00001580                          3275      ENDF
00001580  5848                    3276s     ADD.W   #4,A0
00001582                          3277s _2000000F
00001582  B0FC 03FC               3278s     CMP.W   #START-4,A0
00001586  6F00 FEF4               3279s     BLE _2000000E
0000158A                          3280                                          
0000158A                          3281m     PROTECT
0000158A  31FC AAAA 2AAA          3282m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001590  31FC 5555 1554          3283m     MOVE.W #$5555,$1554
00001596  31FC A0A0 2AAA          3284m     MOVE.W #$A0A0,$2AAA
0000159C                          3285m     ENDM
0000159C                          3286  
0000159C  6000 F0BE               3287      BRA MAIN_LOOP
000015A0                          3288      
000015A0                          3289  P
000015A0  7000                    3290      MOVE.L #0,D0                                    ; D0 will be the data to write
000015A2                          3291  
000015A2                          3292      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000015A2  323C 0000               3293s     MOVE.W  #0,D1
000015A6  6000 0046               3294s     BRA _20000011
000015AA                          3295s _20000010
000015AA  E988                    3296          LSL.L #4,D0                                 ; make what we have so far more significant
000015AC                          3297m         WAIT_CHAR D2,D3                             ; next character -> D2
000015AC                          3298m WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015AC                 TRUE     3299m     IFEQ DEBUG
000015AC  1639 00C00003           3300m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000015B2  0803 0000               3301m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000015B6  67F4                    3302m         BEQ WAIT_FOR_READY_228                      ; NOTHING, CHECK AGAIN
000015B8                          3303m     ENDC
000015B8                          3304m 
000015B8                          3305mm     READ_CHAR D2
000015B8                 TRUE     3306mm     IFEQ DEBUG
000015B8  1439 00C00007           3307mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000015BE                          3308mm     ENDC
000015BE                 FALSE    3309mm     IFNE DEBUG
000015BE                          3310mm     ENDC
000015BE                          3311mm 
000015BE  B43C 001B               3312mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000015C2  6700 EE3C               3313mm     BEQ START
000015C6                          3314mm     ENDM
000015C6                          3315m 
000015C6                 TRUE     3316m     IFEQ DEBUG
000015C6                          3317mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000015C6                          3318mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015C6                 TRUE     3319mm     IFEQ DEBUG
000015C6  1639 00C00003           3320mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000015CC  0803 0002               3321mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000015D0  67F4                    3322mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
000015D2  13C2 00C00007           3323mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000015D8                          3324mm     ENDC
000015D8                          3325mm 
000015D8                 FALSE    3326mm     IFNE DEBUG
000015D8                          3327mm     ENDC
000015D8                          3328mm 
000015D8                          3329mm     ENDM
000015D8                          3330m     ENDC
000015D8                          3331m     ENDM
000015D8                          3332m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
000015D8  41FA 0775               3333m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000015DC  0402 0030               3334m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000015E0  C4BC 000000FF           3335m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000015E6  1430 2000               3336m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000015EA                          3337m     ENDM
000015EA  8002                    3338          OR.B D2,D0
000015EC                          3339      ENDF
000015EC  5241                    3340s     ADD.W   #1,D1
000015EE                          3341s _20000011
000015EE  B27C 0003               3342s     CMP.W   #3,D1
000015F2  6FB6                    3343s     BLE _20000010
000015F4                          3344  
000015F4                          3345m     PRINT_CRLF D2,A1
000015F4  43FA 07C7               3346m     LEA CRLF(PC),A1
000015F8                          3347mm     PRINT_STR A1,D2
000015F8                          3348mm LOOP_233
000015F8  0C11 0000               3349mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000015FC  6700 0016               3350mm     BEQ EXIT_233
00001600                          3351mmm     PRINT_CHAR (A1)+,D2
00001600                          3352mmm WAIT_FOR_READY_234                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001600                 TRUE     3353mmm     IFEQ DEBUG
00001600  1439 00C00003           3354mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001606  0802 0002               3355mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000160A  67F4                    3356mmm         BEQ WAIT_FOR_READY_234                      ; NO SPACE, CHECK AGAIN
0000160C  13D9 00C00007           3357mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001612                          3358mmm     ENDC
00001612                          3359mmm 
00001612                 FALSE    3360mmm     IFNE DEBUG
00001612                          3361mmm     ENDC
00001612                          3362mmm 
00001612                          3363mmm     ENDM
00001612  60E4                    3364mm     BRA LOOP_233
00001614                          3365mm EXIT_233
00001614                          3366mm     ENDM
00001614                          3367m     ENDM
00001614                          3368  
00001614  2047                    3369      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001616  7E00                    3370      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001618                          3371  
00001618                          3372m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00001618  31FC AAAA 2AAA          3373m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000161E  4E71                    3374m     NOP
00001620  31FC 5555 1554          3375m     MOVE.W #$5555,$1554
00001626  4E71                    3376m     NOP
00001628  31FC 8080 2AAA          3377m     MOVE.W #$8080,$2AAA
0000162E  4E71                    3378m     NOP
00001630  31FC AAAA 2AAA          3379m     MOVE.W #$AAAA,$2AAA
00001636  4E71                    3380m     NOP
00001638  31FC 5555 1554          3381m     MOVE.W #$5555,$1554
0000163E  4E71                    3382m     NOP
00001640  31FC 2020 2AAA          3383m     MOVE.W #$2020,$2AAA
00001646                          3384m     ENDM
00001646                          3385                              
00001646                          3386      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001646  3E3C 0000               3387s     MOVE.W  #$0,D7
0000164A  6000 0006               3388s     BRA _20000013
0000164E                          3389s _20000012
0000164E  4E71                    3390          NOP
00001650                          3391      ENDF
00001650  5247                    3392s     ADD.W   #1,D7
00001652                          3393s _20000013
00001652  BE7C FFFF               3394s     CMP.W   #$FFFFFFFF,D7
00001656  6FF6                    3395s     BLE _20000012
00001658                          3396               
00001658  45FA 070C               3397      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000165C                          3398m     PRINT_STR A2,D2
0000165C                          3399m LOOP_236
0000165C  0C12 0000               3400m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001660  6700 0016               3401m     BEQ EXIT_236
00001664                          3402mm     PRINT_CHAR (A2)+,D2
00001664                          3403mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001664                 TRUE     3404mm     IFEQ DEBUG
00001664  1439 00C00003           3405mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000166A  0802 0002               3406mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000166E  67F4                    3407mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
00001670  13DA 00C00007           3408mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001676                          3409mm     ENDC
00001676                          3410mm 
00001676                 FALSE    3411mm     IFNE DEBUG
00001676                          3412mm     ENDC
00001676                          3413mm 
00001676                          3414mm     ENDM
00001676  60E4                    3415m     BRA LOOP_236
00001678                          3416m EXIT_236
00001678                          3417m     ENDM
00001678                          3418  
00001678                          3419m     PRINT_REG D0,D3,D4,D5,A2
00001678  45FA 0749               3420m     LEA OX(PC),A2
0000167C                          3421mm     PRINT_STR A2,D3
0000167C                          3422mm LOOP_239
0000167C  0C12 0000               3423mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001680  6700 0016               3424mm     BEQ EXIT_239
00001684                          3425mmm     PRINT_CHAR (A2)+,D3
00001684                          3426mmm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001684                 TRUE     3427mmm     IFEQ DEBUG
00001684  1639 00C00003           3428mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000168A  0803 0002               3429mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000168E  67F4                    3430mmm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
00001690  13DA 00C00007           3431mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001696                          3432mmm     ENDC
00001696                          3433mmm 
00001696                 FALSE    3434mmm     IFNE DEBUG
00001696                          3435mmm     ENDC
00001696                          3436mmm 
00001696                          3437mmm     ENDM
00001696  60E4                    3438mm     BRA LOOP_239
00001698                          3439mm EXIT_239
00001698                          3440mm     ENDM
00001698  7A07                    3441m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000169A                          3442m LOOP_238
0000169A                          3443mm     BIN2HEX D0,D4,A2
0000169A  45FA 06A3               3444mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000169E  E998                    3445mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000016A0  1800                    3446mm     MOVE.B D0,D4
000016A2  0284 0000000F           3447mm     ANDI.L #$F,D4
000016A8  1832 4000               3448mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000016AC                          3449mm     ENDM
000016AC                          3450mm     PRINT_CHAR D4,D3
000016AC                          3451mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016AC                 TRUE     3452mm     IFEQ DEBUG
000016AC  1639 00C00003           3453mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016B2  0803 0002               3454mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016B6  67F4                    3455mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
000016B8  13C4 00C00007           3456mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000016BE                          3457mm     ENDC
000016BE                          3458mm 
000016BE                 FALSE    3459mm     IFNE DEBUG
000016BE                          3460mm     ENDC
000016BE                          3461mm 
000016BE                          3462mm     ENDM
000016BE  57CD FFDA               3463m     DBEQ D5,LOOP_238
000016C2                          3464m     ENDM
000016C2                          3465  
000016C2  45FA 0702               3466      LEA TO(PC),A2
000016C6                          3467m     PRINT_STR A2,D3
000016C6                          3468m LOOP_243
000016C6  0C12 0000               3469m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016CA  6700 0016               3470m     BEQ EXIT_243
000016CE                          3471mm     PRINT_CHAR (A2)+,D3
000016CE                          3472mm WAIT_FOR_READY_244                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016CE                 TRUE     3473mm     IFEQ DEBUG
000016CE  1639 00C00003           3474mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016D4  0803 0002               3475mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016D8  67F4                    3476mm         BEQ WAIT_FOR_READY_244                      ; NO SPACE, CHECK AGAIN
000016DA  13DA 00C00007           3477mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016E0                          3478mm     ENDC
000016E0                          3479mm 
000016E0                 FALSE    3480mm     IFNE DEBUG
000016E0                          3481mm     ENDC
000016E0                          3482mm 
000016E0                          3483mm     ENDM
000016E0  60E4                    3484m     BRA LOOP_243
000016E2                          3485m EXIT_243
000016E2                          3486m     ENDM
000016E2                          3487  
000016E2  2408                    3488      MOVE.L A0,D2
000016E4                          3489m     PRINT_REG D2,D3,D4,D5,A2
000016E4  45FA 06DD               3490m     LEA OX(PC),A2
000016E8                          3491mm     PRINT_STR A2,D3
000016E8                          3492mm LOOP_246
000016E8  0C12 0000               3493mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016EC  6700 0016               3494mm     BEQ EXIT_246
000016F0                          3495mmm     PRINT_CHAR (A2)+,D3
000016F0                          3496mmm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016F0                 TRUE     3497mmm     IFEQ DEBUG
000016F0  1639 00C00003           3498mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016F6  0803 0002               3499mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016FA  67F4                    3500mmm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
000016FC  13DA 00C00007           3501mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001702                          3502mmm     ENDC
00001702                          3503mmm 
00001702                 FALSE    3504mmm     IFNE DEBUG
00001702                          3505mmm     ENDC
00001702                          3506mmm 
00001702                          3507mmm     ENDM
00001702  60E4                    3508mm     BRA LOOP_246
00001704                          3509mm EXIT_246
00001704                          3510mm     ENDM
00001704  7A07                    3511m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001706                          3512m LOOP_245
00001706                          3513mm     BIN2HEX D2,D4,A2
00001706  45FA 0637               3514mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000170A  E99A                    3515mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000170C  1802                    3516mm     MOVE.B D2,D4
0000170E  0284 0000000F           3517mm     ANDI.L #$F,D4
00001714  1832 4000               3518mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001718                          3519mm     ENDM
00001718                          3520mm     PRINT_CHAR D4,D3
00001718                          3521mm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001718                 TRUE     3522mm     IFEQ DEBUG
00001718  1639 00C00003           3523mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000171E  0803 0002               3524mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001722  67F4                    3525mm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
00001724  13C4 00C00007           3526mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000172A                          3527mm     ENDC
0000172A                          3528mm 
0000172A                 FALSE    3529mm     IFNE DEBUG
0000172A                          3530mm     ENDC
0000172A                          3531mm 
0000172A                          3532mm     ENDM
0000172A  57CD FFDA               3533m     DBEQ D5,LOOP_245
0000172E                          3534m     ENDM
0000172E                          3535  
0000172E                          3536m     PRINT_CRLF D3,A2
0000172E  45FA 068D               3537m     LEA CRLF(PC),A2
00001732                          3538mm     PRINT_STR A2,D3
00001732                          3539mm LOOP_251
00001732  0C12 0000               3540mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001736  6700 0016               3541mm     BEQ EXIT_251
0000173A                          3542mmm     PRINT_CHAR (A2)+,D3
0000173A                          3543mmm WAIT_FOR_READY_252                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000173A                 TRUE     3544mmm     IFEQ DEBUG
0000173A  1639 00C00003           3545mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001740  0803 0002               3546mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001744  67F4                    3547mmm         BEQ WAIT_FOR_READY_252                      ; NO SPACE, CHECK AGAIN
00001746  13DA 00C00007           3548mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000174C                          3549mmm     ENDC
0000174C                          3550mmm 
0000174C                 FALSE    3551mmm     IFNE DEBUG
0000174C                          3552mmm     ENDC
0000174C                          3553mmm 
0000174C                          3554mmm     ENDM
0000174C  60E4                    3555mm     BRA LOOP_251
0000174E                          3556mm EXIT_251
0000174E                          3557mm     ENDM
0000174E                          3558m     ENDM
0000174E                          3559  
0000174E                          3560m     PROGRAM D0,(A0),D2
0000174E  3080                    3561m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001750                          3562m 
00001750                          3563m WAIT_FOR_COMPLETE_253
00001750  3410                    3564m         MOVE.W (A0),D2
00001752                          3565m 
00001752                          3566m         IF.W D2 <NE> D0 THEN
00001752  B440                    3567ms     CMP.W   D0,D2
00001754  6700 0004               3568ms     BEQ _00000014
00001758  60F6                    3569m             BRA WAIT_FOR_COMPLETE_253
0000175A                          3570m         ENDI
0000175A                          3571ms _00000014
0000175A                          3572m         ENDM
0000175A                          3573  
0000175A                          3574m     PROTECT
0000175A  31FC AAAA 2AAA          3575m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001760  31FC 5555 1554          3576m     MOVE.W #$5555,$1554
00001766  31FC A0A0 2AAA          3577m     MOVE.W #$A0A0,$2AAA
0000176C                          3578m     ENDM
0000176C                          3579  
0000176C  6000 EEEE               3580      BRA MAIN_LOOP
00001770                          3581      
00001770                          3582  M
00001770  7000                    3583      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001772  7200                    3584      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001774                          3585  
00001774                          3586      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001774  343C 0000               3587s     MOVE.W  #0,D2
00001778  6000 0046               3588s     BRA _20000015
0000177C                          3589s _20000014
0000177C  E989                    3590          LSL.L #4,D1                                     ; make what we have so far more significant
0000177E                          3591m         WAIT_CHAR D3,D4                                 ; next character -> D2
0000177E                          3592m WAIT_FOR_READY_255                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000177E                 TRUE     3593m     IFEQ DEBUG
0000177E  1839 00C00003           3594m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001784  0804 0000               3595m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001788  67F4                    3596m         BEQ WAIT_FOR_READY_255                      ; NOTHING, CHECK AGAIN
0000178A                          3597m     ENDC
0000178A                          3598m 
0000178A                          3599mm     READ_CHAR D3
0000178A                 TRUE     3600mm     IFEQ DEBUG
0000178A  1639 00C00007           3601mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001790                          3602mm     ENDC
00001790                 FALSE    3603mm     IFNE DEBUG
00001790                          3604mm     ENDC
00001790                          3605mm 
00001790  B63C 001B               3606mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001794  6700 EC6A               3607mm     BEQ START
00001798                          3608mm     ENDM
00001798                          3609m 
00001798                 TRUE     3610m     IFEQ DEBUG
00001798                          3611mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001798                          3612mm WAIT_FOR_READY_257                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001798                 TRUE     3613mm     IFEQ DEBUG
00001798  1839 00C00003           3614mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000179E  0804 0002               3615mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
000017A2  67F4                    3616mm         BEQ WAIT_FOR_READY_257                      ; NO SPACE, CHECK AGAIN
000017A4  13C3 00C00007           3617mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017AA                          3618mm     ENDC
000017AA                          3619mm 
000017AA                 FALSE    3620mm     IFNE DEBUG
000017AA                          3621mm     ENDC
000017AA                          3622mm 
000017AA                          3623mm     ENDM
000017AA                          3624m     ENDC
000017AA                          3625m     ENDM
000017AA                          3626m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
000017AA  41FA 05A3               3627m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000017AE  0403 0030               3628m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000017B2  C6BC 000000FF           3629m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
000017B8  1630 3000               3630m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
000017BC                          3631m     ENDM
000017BC  8203                    3632          OR.B D3,D1
000017BE                          3633      ENDF
000017BE  5242                    3634s     ADD.W   #1,D2
000017C0                          3635s _20000015
000017C0  B47C 0007               3636s     CMP.W   #7,D2
000017C4  6FB6                    3637s     BLE _20000014
000017C6                          3638m     PRINT_CRLF D2,A1
000017C6  43FA 05F5               3639m     LEA CRLF(PC),A1
000017CA                          3640mm     PRINT_STR A1,D2
000017CA                          3641mm LOOP_260
000017CA  0C11 0000               3642mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000017CE  6700 0016               3643mm     BEQ EXIT_260
000017D2                          3644mmm     PRINT_CHAR (A1)+,D2
000017D2                          3645mmm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017D2                 TRUE     3646mmm     IFEQ DEBUG
000017D2  1439 00C00003           3647mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000017D8  0802 0002               3648mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000017DC  67F4                    3649mmm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000017DE  13D9 00C00007           3650mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017E4                          3651mmm     ENDC
000017E4                          3652mmm 
000017E4                 FALSE    3653mmm     IFNE DEBUG
000017E4                          3654mmm     ENDC
000017E4                          3655mmm 
000017E4                          3656mmm     ENDM
000017E4  60E4                    3657mm     BRA LOOP_260
000017E6                          3658mm EXIT_260
000017E6                          3659mm     ENDM
000017E6                          3660m     ENDM
000017E6                          3661  
000017E6  3001                    3662      MOVE.W D1,D0                                        ; extract the LSword for the length
000017E8  E089                    3663      LSR.L #8,D1                                         ; extract the MSword for the address
000017EA  E089                    3664      LSR.L #8,D1
000017EC                          3665  
000017EC  2241                    3666      MOVE.L D1,A1
000017EE                          3667      
000017EE  2047                    3668      MOVE.L D7,A0                                        ; address accumulator -> target address register
000017F0                          3669      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
000017F0                          3670  
000017F0                          3671      WHILE D0 <GT> #0 DO
000017F0                          3672s _10000016
000017F0  B07C 0000               3673s     CMP.W   #0,D0
000017F4  6F00 000E               3674s     BLE _10000017
000017F8  5580                    3675          SUB.L #2,D0
000017FA                          3676  
000017FA  13D1 00E00001           3677          MOVE.B (A1),DISPLAY
00001800  30D9                    3678          MOVE.W (A1)+,(A0)+
00001802                          3679      ENDW
00001802  60EC                    3680s     BRA _10000016
00001804                          3681s _10000017
00001804                          3682      
00001804  6000 EE56               3683      BRA MAIN_LOOP
00001808                          3684  
00001808                          3685  X
00001808  45FA 05CC               3686      LEA STATUS_REGISTER(PC),A2
0000180C                          3687m     PRINT_STR A2,D3
0000180C                          3688m LOOP_262
0000180C  0C12 0000               3689m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001810  6700 0016               3690m     BEQ EXIT_262
00001814                          3691mm     PRINT_CHAR (A2)+,D3
00001814                          3692mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001814                 TRUE     3693mm     IFEQ DEBUG
00001814  1639 00C00003           3694mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000181A  0803 0002               3695mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000181E  67F4                    3696mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
00001820  13DA 00C00007           3697mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001826                          3698mm     ENDC
00001826                          3699mm 
00001826                 FALSE    3700mm     IFNE DEBUG
00001826                          3701mm     ENDC
00001826                          3702mm 
00001826                          3703mm     ENDM
00001826  60E4                    3704m     BRA LOOP_262
00001828                          3705m EXIT_262
00001828                          3706m     ENDM
00001828                          3707  
00001828  40C0                    3708      MOVE SR,D0
0000182A                          3709m     PRINT_REG D0,D3,D4,D5,A2
0000182A  45FA 0597               3710m     LEA OX(PC),A2
0000182E                          3711mm     PRINT_STR A2,D3
0000182E                          3712mm LOOP_265
0000182E  0C12 0000               3713mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001832  6700 0016               3714mm     BEQ EXIT_265
00001836                          3715mmm     PRINT_CHAR (A2)+,D3
00001836                          3716mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001836                 TRUE     3717mmm     IFEQ DEBUG
00001836  1639 00C00003           3718mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000183C  0803 0002               3719mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001840  67F4                    3720mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
00001842  13DA 00C00007           3721mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001848                          3722mmm     ENDC
00001848                          3723mmm 
00001848                 FALSE    3724mmm     IFNE DEBUG
00001848                          3725mmm     ENDC
00001848                          3726mmm 
00001848                          3727mmm     ENDM
00001848  60E4                    3728mm     BRA LOOP_265
0000184A                          3729mm EXIT_265
0000184A                          3730mm     ENDM
0000184A  7A07                    3731m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000184C                          3732m LOOP_264
0000184C                          3733mm     BIN2HEX D0,D4,A2
0000184C  45FA 04F1               3734mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001850  E998                    3735mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001852  1800                    3736mm     MOVE.B D0,D4
00001854  0284 0000000F           3737mm     ANDI.L #$F,D4
0000185A  1832 4000               3738mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000185E                          3739mm     ENDM
0000185E                          3740mm     PRINT_CHAR D4,D3
0000185E                          3741mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000185E                 TRUE     3742mm     IFEQ DEBUG
0000185E  1639 00C00003           3743mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001864  0803 0002               3744mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001868  67F4                    3745mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
0000186A  13C4 00C00007           3746mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001870                          3747mm     ENDC
00001870                          3748mm 
00001870                 FALSE    3749mm     IFNE DEBUG
00001870                          3750mm     ENDC
00001870                          3751mm 
00001870                          3752mm     ENDM
00001870  57CD FFDA               3753m     DBEQ D5,LOOP_264
00001874                          3754m     ENDM
00001874                          3755m     PRINT_CRLF D3,A2
00001874  45FA 0547               3756m     LEA CRLF(PC),A2
00001878                          3757mm     PRINT_STR A2,D3
00001878                          3758mm LOOP_270
00001878  0C12 0000               3759mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000187C  6700 0016               3760mm     BEQ EXIT_270
00001880                          3761mmm     PRINT_CHAR (A2)+,D3
00001880                          3762mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001880                 TRUE     3763mmm     IFEQ DEBUG
00001880  1639 00C00003           3764mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001886  0803 0002               3765mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000188A  67F4                    3766mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
0000188C  13DA 00C00007           3767mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001892                          3768mmm     ENDC
00001892                          3769mmm 
00001892                 FALSE    3770mmm     IFNE DEBUG
00001892                          3771mmm     ENDC
00001892                          3772mmm 
00001892                          3773mmm     ENDM
00001892  60E4                    3774mm     BRA LOOP_270
00001894                          3775mm EXIT_270
00001894                          3776mm     ENDM
00001894                          3777m     ENDM
00001894                          3778  
00001894  45FA 053B               3779      LEA STACK_POINTER(PC),A2
00001898                          3780m     PRINT_STR A2,D3
00001898                          3781m LOOP_272
00001898  0C12 0000               3782m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000189C  6700 0016               3783m     BEQ EXIT_272
000018A0                          3784mm     PRINT_CHAR (A2)+,D3
000018A0                          3785mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018A0                 TRUE     3786mm     IFEQ DEBUG
000018A0  1639 00C00003           3787mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000018A6  0803 0002               3788mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000018AA  67F4                    3789mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000018AC  13DA 00C00007           3790mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018B2                          3791mm     ENDC
000018B2                          3792mm 
000018B2                 FALSE    3793mm     IFNE DEBUG
000018B2                          3794mm     ENDC
000018B2                          3795mm 
000018B2                          3796mm     ENDM
000018B2  60E4                    3797m     BRA LOOP_272
000018B4                          3798m EXIT_272
000018B4                          3799m     ENDM
000018B4                          3800  
000018B4  200F                    3801      MOVE.L SP,D0
000018B6                          3802m     PRINT_REG D0,D3,D4,D5,A2
000018B6  45FA 050B               3803m     LEA OX(PC),A2
000018BA                          3804mm     PRINT_STR A2,D3
000018BA                          3805mm LOOP_275
000018BA  0C12 0000               3806mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000018BE  6700 0016               3807mm     BEQ EXIT_275
000018C2                          3808mmm     PRINT_CHAR (A2)+,D3
000018C2                          3809mmm WAIT_FOR_READY_276                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018C2                 TRUE     3810mmm     IFEQ DEBUG
000018C2  1639 00C00003           3811mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000018C8  0803 0002               3812mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000018CC  67F4                    3813mmm         BEQ WAIT_FOR_READY_276                      ; NO SPACE, CHECK AGAIN
000018CE  13DA 00C00007           3814mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018D4                          3815mmm     ENDC
000018D4                          3816mmm 
000018D4                 FALSE    3817mmm     IFNE DEBUG
000018D4                          3818mmm     ENDC
000018D4                          3819mmm 
000018D4                          3820mmm     ENDM
000018D4  60E4                    3821mm     BRA LOOP_275
000018D6                          3822mm EXIT_275
000018D6                          3823mm     ENDM
000018D6  7A07                    3824m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000018D8                          3825m LOOP_274
000018D8                          3826mm     BIN2HEX D0,D4,A2
000018D8  45FA 0465               3827mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000018DC  E998                    3828mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000018DE  1800                    3829mm     MOVE.B D0,D4
000018E0  0284 0000000F           3830mm     ANDI.L #$F,D4
000018E6  1832 4000               3831mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000018EA                          3832mm     ENDM
000018EA                          3833mm     PRINT_CHAR D4,D3
000018EA                          3834mm WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018EA                 TRUE     3835mm     IFEQ DEBUG
000018EA  1639 00C00003           3836mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000018F0  0803 0002               3837mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000018F4  67F4                    3838mm         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
000018F6  13C4 00C00007           3839mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000018FC                          3840mm     ENDC
000018FC                          3841mm 
000018FC                 FALSE    3842mm     IFNE DEBUG
000018FC                          3843mm     ENDC
000018FC                          3844mm 
000018FC                          3845mm     ENDM
000018FC  57CD FFDA               3846m     DBEQ D5,LOOP_274
00001900                          3847m     ENDM
00001900                          3848m     PRINT_CRLF D3,A2
00001900  45FA 04BB               3849m     LEA CRLF(PC),A2
00001904                          3850mm     PRINT_STR A2,D3
00001904                          3851mm LOOP_280
00001904  0C12 0000               3852mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001908  6700 0016               3853mm     BEQ EXIT_280
0000190C                          3854mmm     PRINT_CHAR (A2)+,D3
0000190C                          3855mmm WAIT_FOR_READY_281                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000190C                 TRUE     3856mmm     IFEQ DEBUG
0000190C  1639 00C00003           3857mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001912  0803 0002               3858mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001916  67F4                    3859mmm         BEQ WAIT_FOR_READY_281                      ; NO SPACE, CHECK AGAIN
00001918  13DA 00C00007           3860mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000191E                          3861mmm     ENDC
0000191E                          3862mmm 
0000191E                 FALSE    3863mmm     IFNE DEBUG
0000191E                          3864mmm     ENDC
0000191E                          3865mmm 
0000191E                          3866mmm     ENDM
0000191E  60E4                    3867mm     BRA LOOP_280
00001920                          3868mm EXIT_280
00001920                          3869mm     ENDM
00001920                          3870m     ENDM
00001920                          3871  
00001920  6000 ED3A               3872      BRA MAIN_LOOP
00001924                          3873  
00001924                          3874          
00001924                          3875  I
00001924  13FC 0008 00C0000B      3876      MOVE.B #8,DUART_IMR
0000192C  027C F8FF               3877      AND.W #$F8FF,SR
00001930  6000 ED2A               3878      BRA MAIN_LOOP
00001934                          3879      
00001934                          3880  O
00001934  13FC 0000 00C0000B      3881      MOVE.B #0,DUART_IMR
0000193C  007C 0700               3882      OR.W #$0700,SR
00001940  6000 ED1A               3883      BRA MAIN_LOOP
00001944                          3884          
00001944                          3885  HASH
00001944                          3886m     PROTECT
00001944  31FC AAAA 2AAA          3887m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000194A  31FC 5555 1554          3888m     MOVE.W #$5555,$1554
00001950  31FC A0A0 2AAA          3889m     MOVE.W #$A0A0,$2AAA
00001956                          3890m     ENDM
00001956  6000 ED04               3891      BRA MAIN_LOOP
0000195A                          3892  
0000195A                          3893  
0000195A                          3894  
0000195A                          3895  HEX_DIGIT
0000195A  E98F                    3896      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
0000195C                          3897m     HEX2BIN D2,D2,A0
0000195C  41FA 03F1               3898m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001960  0402 0030               3899m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001964  C4BC 000000FF           3900m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000196A  1430 2000               3901m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000196E                          3902m     ENDM
0000196E  8E02                    3903      OR.B D2,D7  
00001970  6000 ED0A               3904      BRA GET_INPUT
00001974                          3905  
00001974  FFFF FFFF               3906      SIMHALT                                             ; halt simulator
00001978                          3907  
00001978                          3908  ; exceptions    
00001978                          3909  BUS_ERROR_HANDLER
00001978                          3910  
00001978  41FA 0468               3911      LEA BUS_ERROR(PC),A0
0000197C                          3912m     PRINT_STR A0,D1
0000197C                          3913m LOOP_284
0000197C  0C10 0000               3914m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001980  6700 0016               3915m     BEQ EXIT_284
00001984                          3916mm     PRINT_CHAR (A0)+,D1
00001984                          3917mm WAIT_FOR_READY_285                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001984                 TRUE     3918mm     IFEQ DEBUG
00001984  1239 00C00003           3919mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000198A  0801 0002               3920mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000198E  67F4                    3921mm         BEQ WAIT_FOR_READY_285                      ; NO SPACE, CHECK AGAIN
00001990  13D8 00C00007           3922mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001996                          3923mm     ENDC
00001996                          3924mm 
00001996                 FALSE    3925mm     IFNE DEBUG
00001996                          3926mm     ENDC
00001996                          3927mm 
00001996                          3928mm     ENDM
00001996  60E4                    3929m     BRA LOOP_284
00001998                          3930m EXIT_284
00001998                          3931m     ENDM
00001998                          3932  
00001998  7000                    3933      MOVE.L #0,D0
0000199A  3017                    3934      MOVE.W (SP),D0
0000199C                          3935  
0000199C  0800 0004               3936      BTST #4,D0
000019A0  6700 0026               3937      BEQ WRITE
000019A4                          3938      
000019A4  41FA 0451               3939      LEA READING(PC),A0
000019A8                          3940m     PRINT_STR A0,D1
000019A8                          3941m LOOP_286
000019A8  0C10 0000               3942m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019AC  6700 0016               3943m     BEQ EXIT_286
000019B0                          3944mm     PRINT_CHAR (A0)+,D1
000019B0                          3945mm WAIT_FOR_READY_287                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019B0                 TRUE     3946mm     IFEQ DEBUG
000019B0  1239 00C00003           3947mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000019B6  0801 0002               3948mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000019BA  67F4                    3949mm         BEQ WAIT_FOR_READY_287                      ; NO SPACE, CHECK AGAIN
000019BC  13D8 00C00007           3950mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019C2                          3951mm     ENDC
000019C2                          3952mm 
000019C2                 FALSE    3953mm     IFNE DEBUG
000019C2                          3954mm     ENDC
000019C2                          3955mm 
000019C2                          3956mm     ENDM
000019C2  60E4                    3957m     BRA LOOP_286
000019C4                          3958m EXIT_286
000019C4                          3959m     ENDM
000019C4                          3960  
000019C4  6000 0022               3961      BRA CONTINUE    
000019C8                          3962  WRITE
000019C8  41FA 0436               3963      LEA WRITING(PC),A0
000019CC                          3964m     PRINT_STR A0,D1
000019CC                          3965m LOOP_288
000019CC  0C10 0000               3966m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019D0  6700 0016               3967m     BEQ EXIT_288
000019D4                          3968mm     PRINT_CHAR (A0)+,D1
000019D4                          3969mm WAIT_FOR_READY_289                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019D4                 TRUE     3970mm     IFEQ DEBUG
000019D4  1239 00C00003           3971mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000019DA  0801 0002               3972mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000019DE  67F4                    3973mm         BEQ WAIT_FOR_READY_289                      ; NO SPACE, CHECK AGAIN
000019E0  13D8 00C00007           3974mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019E6                          3975mm     ENDC
000019E6                          3976mm 
000019E6                 FALSE    3977mm     IFNE DEBUG
000019E6                          3978mm     ENDC
000019E6                          3979mm 
000019E6                          3980mm     ENDM
000019E6  60E4                    3981m     BRA LOOP_288
000019E8                          3982m EXIT_288
000019E8                          3983m     ENDM
000019E8                          3984  
000019E8                          3985  CONTINUE
000019E8  222F 0002               3986      MOVE.L 2(SP),D1
000019EC                          3987m     PRINT_REG D1,D2,D3,D4,A0
000019EC  41FA 03D5               3988m     LEA OX(PC),A0
000019F0                          3989mm     PRINT_STR A0,D2
000019F0                          3990mm LOOP_291
000019F0  0C10 0000               3991mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019F4  6700 0016               3992mm     BEQ EXIT_291
000019F8                          3993mmm     PRINT_CHAR (A0)+,D2
000019F8                          3994mmm WAIT_FOR_READY_292                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019F8                 TRUE     3995mmm     IFEQ DEBUG
000019F8  1439 00C00003           3996mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019FE  0802 0002               3997mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A02  67F4                    3998mmm         BEQ WAIT_FOR_READY_292                      ; NO SPACE, CHECK AGAIN
00001A04  13D8 00C00007           3999mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A0A                          4000mmm     ENDC
00001A0A                          4001mmm 
00001A0A                 FALSE    4002mmm     IFNE DEBUG
00001A0A                          4003mmm     ENDC
00001A0A                          4004mmm 
00001A0A                          4005mmm     ENDM
00001A0A  60E4                    4006mm     BRA LOOP_291
00001A0C                          4007mm EXIT_291
00001A0C                          4008mm     ENDM
00001A0C  7807                    4009m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A0E                          4010m LOOP_290
00001A0E                          4011mm     BIN2HEX D1,D3,A0
00001A0E  41FA 032F               4012mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A12  E999                    4013mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A14  1601                    4014mm     MOVE.B D1,D3
00001A16  0283 0000000F           4015mm     ANDI.L #$F,D3
00001A1C  1630 3000               4016mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A20                          4017mm     ENDM
00001A20                          4018mm     PRINT_CHAR D3,D2
00001A20                          4019mm WAIT_FOR_READY_294                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A20                 TRUE     4020mm     IFEQ DEBUG
00001A20  1439 00C00003           4021mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A26  0802 0002               4022mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A2A  67F4                    4023mm         BEQ WAIT_FOR_READY_294                      ; NO SPACE, CHECK AGAIN
00001A2C  13C3 00C00007           4024mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001A32                          4025mm     ENDC
00001A32                          4026mm 
00001A32                 FALSE    4027mm     IFNE DEBUG
00001A32                          4028mm     ENDC
00001A32                          4029mm 
00001A32                          4030mm     ENDM
00001A32  57CC FFDA               4031m     DBEQ D4,LOOP_290
00001A36                          4032m     ENDM
00001A36                          4033  
00001A36  41FA 03D1               4034      LEA FROM(PC),A0
00001A3A                          4035m     PRINT_STR A0,D0
00001A3A                          4036m LOOP_295
00001A3A  0C10 0000               4037m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A3E  6700 0016               4038m     BEQ EXIT_295
00001A42                          4039mm     PRINT_CHAR (A0)+,D0
00001A42                          4040mm WAIT_FOR_READY_296                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A42                 TRUE     4041mm     IFEQ DEBUG
00001A42  1039 00C00003           4042mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001A48  0800 0002               4043mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001A4C  67F4                    4044mm         BEQ WAIT_FOR_READY_296                      ; NO SPACE, CHECK AGAIN
00001A4E  13D8 00C00007           4045mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A54                          4046mm     ENDC
00001A54                          4047mm 
00001A54                 FALSE    4048mm     IFNE DEBUG
00001A54                          4049mm     ENDC
00001A54                          4050mm 
00001A54                          4051mm     ENDM
00001A54  60E4                    4052m     BRA LOOP_295
00001A56                          4053m EXIT_295
00001A56                          4054m     ENDM
00001A56                          4055  
00001A56  222F 000A               4056      MOVE.L 10(SP),D1
00001A5A                          4057m     PRINT_REG D1,D2,D3,D4,A0
00001A5A  41FA 0367               4058m     LEA OX(PC),A0
00001A5E                          4059mm     PRINT_STR A0,D2
00001A5E                          4060mm LOOP_298
00001A5E  0C10 0000               4061mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A62  6700 0016               4062mm     BEQ EXIT_298
00001A66                          4063mmm     PRINT_CHAR (A0)+,D2
00001A66                          4064mmm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A66                 TRUE     4065mmm     IFEQ DEBUG
00001A66  1439 00C00003           4066mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A6C  0802 0002               4067mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A70  67F4                    4068mmm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001A72  13D8 00C00007           4069mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A78                          4070mmm     ENDC
00001A78                          4071mmm 
00001A78                 FALSE    4072mmm     IFNE DEBUG
00001A78                          4073mmm     ENDC
00001A78                          4074mmm 
00001A78                          4075mmm     ENDM
00001A78  60E4                    4076mm     BRA LOOP_298
00001A7A                          4077mm EXIT_298
00001A7A                          4078mm     ENDM
00001A7A  7807                    4079m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A7C                          4080m LOOP_297
00001A7C                          4081mm     BIN2HEX D1,D3,A0
00001A7C  41FA 02C1               4082mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A80  E999                    4083mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A82  1601                    4084mm     MOVE.B D1,D3
00001A84  0283 0000000F           4085mm     ANDI.L #$F,D3
00001A8A  1630 3000               4086mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A8E                          4087mm     ENDM
00001A8E                          4088mm     PRINT_CHAR D3,D2
00001A8E                          4089mm WAIT_FOR_READY_301                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A8E                 TRUE     4090mm     IFEQ DEBUG
00001A8E  1439 00C00003           4091mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A94  0802 0002               4092mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A98  67F4                    4093mm         BEQ WAIT_FOR_READY_301                      ; NO SPACE, CHECK AGAIN
00001A9A  13C3 00C00007           4094mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001AA0                          4095mm     ENDC
00001AA0                          4096mm 
00001AA0                 FALSE    4097mm     IFNE DEBUG
00001AA0                          4098mm     ENDC
00001AA0                          4099mm 
00001AA0                          4100mm     ENDM
00001AA0  57CC FFDA               4101m     DBEQ D4,LOOP_297
00001AA4                          4102m     ENDM
00001AA4                          4103m     PRINT_CRLF D0,A0
00001AA4  41FA 0317               4104m     LEA CRLF(PC),A0
00001AA8                          4105mm     PRINT_STR A0,D0
00001AA8                          4106mm LOOP_303
00001AA8  0C10 0000               4107mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001AAC  6700 0016               4108mm     BEQ EXIT_303
00001AB0                          4109mmm     PRINT_CHAR (A0)+,D0
00001AB0                          4110mmm WAIT_FOR_READY_304                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001AB0                 TRUE     4111mmm     IFEQ DEBUG
00001AB0  1039 00C00003           4112mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001AB6  0800 0002               4113mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001ABA  67F4                    4114mmm         BEQ WAIT_FOR_READY_304                      ; NO SPACE, CHECK AGAIN
00001ABC  13D8 00C00007           4115mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AC2                          4116mmm     ENDC
00001AC2                          4117mmm 
00001AC2                 FALSE    4118mmm     IFNE DEBUG
00001AC2                          4119mmm     ENDC
00001AC2                          4120mmm 
00001AC2                          4121mmm     ENDM
00001AC2  60E4                    4122mm     BRA LOOP_303
00001AC4                          4123mm EXIT_303
00001AC4                          4124mm     ENDM
00001AC4                          4125m     ENDM
00001AC4                          4126      
00001AC4  207C 00000004           4127      MOVE.L #4,A0
00001ACA  4ED0                    4128      JMP (A0)
00001ACC                          4129          
00001ACC                          4130  ILLEGAL_HANDLER
00001ACC  13FC 0007 00E00001      4131      MOVE.B #7,DISPLAY   
00001AD4                          4132      
00001AD4  207C 00000004           4133      MOVE.L #4,A0
00001ADA  4ED0                    4134      JMP (A0)
00001ADC                          4135          
00001ADC                          4136  UNHANDLED_HANDLER
00001ADC  41FA 0332               4137      LEA UNHANDLED(PC),A0
00001AE0                          4138m     PRINT_STR A0,D1
00001AE0                          4139m LOOP_305
00001AE0  0C10 0000               4140m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001AE4  6700 0016               4141m     BEQ EXIT_305
00001AE8                          4142mm     PRINT_CHAR (A0)+,D1
00001AE8                          4143mm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001AE8                 TRUE     4144mm     IFEQ DEBUG
00001AE8  1239 00C00003           4145mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001AEE  0801 0002               4146mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001AF2  67F4                    4147mm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
00001AF4  13D8 00C00007           4148mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AFA                          4149mm     ENDC
00001AFA                          4150mm 
00001AFA                 FALSE    4151mm     IFNE DEBUG
00001AFA                          4152mm     ENDC
00001AFA                          4153mm 
00001AFA                          4154mm     ENDM
00001AFA  60E4                    4155m     BRA LOOP_305
00001AFC                          4156m EXIT_305
00001AFC                          4157m     ENDM
00001AFC                          4158  
00001AFC  4E73                    4159      RTE 
00001AFE                          4160      
00001AFE                          4161  UNINITIALISED_HANDLER
00001AFE  41FA 0326               4162      LEA UNINITIALISED(PC),A0
00001B02                          4163m     PRINT_STR A0,D1
00001B02                          4164m LOOP_307
00001B02  0C10 0000               4165m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001B06  6700 0016               4166m     BEQ EXIT_307
00001B0A                          4167mm     PRINT_CHAR (A0)+,D1
00001B0A                          4168mm WAIT_FOR_READY_308                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B0A                 TRUE     4169mm     IFEQ DEBUG
00001B0A  1239 00C00003           4170mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001B10  0801 0002               4171mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001B14  67F4                    4172mm         BEQ WAIT_FOR_READY_308                      ; NO SPACE, CHECK AGAIN
00001B16  13D8 00C00007           4173mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001B1C                          4174mm     ENDC
00001B1C                          4175mm 
00001B1C                 FALSE    4176mm     IFNE DEBUG
00001B1C                          4177mm     ENDC
00001B1C                          4178mm 
00001B1C                          4179mm     ENDM
00001B1C  60E4                    4180m     BRA LOOP_307
00001B1E                          4181m EXIT_307
00001B1E                          4182m     ENDM
00001B1E                          4183  
00001B1E  4E73                    4184      RTE 
00001B20                          4185  
00001B20                          4186  SPURIOUS_HANDLER
00001B20  41FA 0324               4187      LEA SPURIOUS(PC),A0
00001B24                          4188m     PRINT_STR A0,D1
00001B24                          4189m LOOP_309
00001B24  0C10 0000               4190m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001B28  6700 0016               4191m     BEQ EXIT_309
00001B2C                          4192mm     PRINT_CHAR (A0)+,D1
00001B2C                          4193mm WAIT_FOR_READY_310                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B2C                 TRUE     4194mm     IFEQ DEBUG
00001B2C  1239 00C00003           4195mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001B32  0801 0002               4196mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001B36  67F4                    4197mm         BEQ WAIT_FOR_READY_310                      ; NO SPACE, CHECK AGAIN
00001B38  13D8 00C00007           4198mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001B3E                          4199mm     ENDC
00001B3E                          4200mm 
00001B3E                 FALSE    4201mm     IFNE DEBUG
00001B3E                          4202mm     ENDC
00001B3E                          4203mm 
00001B3E                          4204mm     ENDM
00001B3E  60E4                    4205m     BRA LOOP_309
00001B40                          4206m EXIT_309
00001B40                          4207m     ENDM
00001B40                          4208  
00001B40  4E73                    4209      RTE 
00001B42                          4210      
00001B42                          4211  TICK_HANDLER
00001B42  41FA 0297               4212      LEA TICK(PC),A0
00001B46                          4213m     PRINT_STR A0,D1
00001B46                          4214m LOOP_311
00001B46  0C10 0000               4215m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001B4A  6700 0016               4216m     BEQ EXIT_311
00001B4E                          4217mm     PRINT_CHAR (A0)+,D1
00001B4E                          4218mm WAIT_FOR_READY_312                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B4E                 TRUE     4219mm     IFEQ DEBUG
00001B4E  1239 00C00003           4220mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001B54  0801 0002               4221mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001B58  67F4                    4222mm         BEQ WAIT_FOR_READY_312                      ; NO SPACE, CHECK AGAIN
00001B5A  13D8 00C00007           4223mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001B60                          4224mm     ENDC
00001B60                          4225mm 
00001B60                 FALSE    4226mm     IFNE DEBUG
00001B60                          4227mm     ENDC
00001B60                          4228mm 
00001B60                          4229mm     ENDM
00001B60  60E4                    4230m     BRA LOOP_311
00001B62                          4231m EXIT_311
00001B62                          4232m     ENDM
00001B62                          4233      
00001B62  1039 00C0001F           4234      MOVE.B DUART_RESET_OPR,D0
00001B68  4E73                    4235      RTE 
00001B6A                          4236  
00001B6A                          4237  ; strings
00001B6A= 50 72 65 73 73 20 ...   4238  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001B7D= 5B 3F 5D 09 09 09 ...   4239  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001B89= 5B 76 5D 09 09 09 ...   4240          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001B98= 78 78 78 78 78 78 ...   4241          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001BB0= 78 78 78 78 78 78 ...   4242          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001BD0= 78 78 78 78 78 78 ...   4243          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001BF1= 78 78 78 78 78 78 ...   4244          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001C02= 5B 7A 5D 09 09 09 ...   4245          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001C14= 78 78 78 78 78 78 ...   4246          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001C35= 78 78 78 78 78 78 ...   4247          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
00001C54= 78 78 78 78 78 78 ...   4248          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001C78= 23 09 09 09 77 72 ...   4249          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001C92= 5B 78 5D 09 09 09 ...   4250          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001CA9= 5B 69 5D 09 09 09 ...   4251          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001CC2= 5B 6F 5D 09 09 09 ...   4252          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
00001CDD= 48 75 68 3F 0D 0A 00    4253  HUH  DC.B 'Huh?',CR,LF,NULL
00001CE4= 20 53 20 72 65 63 ...   4254  READ    DC.B ' S records read, start address = ',NULL
00001D06= 57 3A 20 55 6E 6B ...   4255  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001D1D= 21 20 43 53 20 66 ...   4256  CS_FAILURE  DC.B '! CS failure at ',NULL
00001D2E= 21 20 52 41 4D 20 ...   4257  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001D3F= 30 31 32 33 34 35 ...   4258  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001D4F= 00 01 02 03 04 05 ...   4259  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001D66= 4C 6F 61 64 69 6E ...   4260  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001D7A= 57 72 69 74 69 6E ...   4261  CODE        DC.B 'Writing code: ',NULL
00001D89= 53 65 74 74 69 6E ...   4262  SP      DC.B 'Setting initial stack pointer to ',NULL
00001DAB= 57 72 69 74 69 6E ...   4263  VECTORS DC.B 'Writing vectors',CR,LF,NULL
00001DBD= 0D 0A 00                4264  CRLF    DC.B CR,LF,NULL
00001DC0= 3E 20 00                4265  PROMPT  DC.B '> ',NULL
00001DC3= 30 78 00                4266  ox      DC.B '0x',NULL
00001DC6= 20 2D 3E 20 00          4267  to      DC.B ' -> ',NULL
00001DCB= 20 66 6F 72 20 00       4268  for     DC.B ' for ',NULL
00001DD1= 53 50 3A 20 00          4269  STACK_POINTER DC.B 'SP: ',NULL
00001DD6= 53 52 3A 20 00          4270  STATUS_REGISTER DC.B 'SR: ',NULL
00001DDB= 74 69 63 6B 0D 0A 00    4271  TICK DC.B 'tick',CR,LF,NULL
00001DE2= 2A 20 42 75 73 2F ...   4272  BUS_ERROR DC.B '* Bus/address error ',NULL
00001DF7= 72 65 61 64 69 6E ...   4273  READING DC.B 'reading ',NULL
00001E00= 77 72 69 74 69 6E ...   4274  WRITING DC.B 'writing ',NULL
00001E09= 20 66 72 6F 6D 20 00    4275  FROM DC.B ' from ',NULL
00001E10= 2A 20 55 6E 68 61 ...   4276  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001E26= 2A 20 20 55 6E 69 ...   4277  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
00001E46= 2A 20 53 70 75 72 ...   4278  SPURIOUS DC.B '* Spurious interrupt',NULL
00001E5B= 43 6F 6C 64 20 73 ...   4279  COLD_START DC.B 'Cold start - brrr',CR,LF,NULL
00001E6F= 57 61 72 6D 20 73 ...   4280  WARM_START DC.B 'Warm start - phew',CR,LF,NULL
00001E83= 4D 44 46 2D 6D 6F ...   4281  VERSION DC.B 'MDF-mon V1.128 (30/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001EA1= 00                      4282  END     DC.B 0
00001EA2                          4283      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1D3F
BUS_ERROR           1DE2
BUS_ERROR_HANDLER   1978
CODE                1D7A
COLD_START          1E5B
CONTINUE            19E8
CONTINUE_103        D5A
CONTINUE_117        E4C
CONTINUE_58         928
CONTINUE_61         978
CONTINUE_65         9CE
CONTINUE_73         A82
CONTINUE_78         AF4
CONTINUE_83         B70
CONTINUE_88         BEE
CONTINUE_93         C76
CONTINUE_98         CE8
CR                  D
CRLF                1DBD
CS_FAILURE          1D1D
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       F56
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1EA1
EXIT_108            DCC
EXIT_11             5A0
EXIT_110            DEC
EXIT_114            E1E
EXIT_122            EB4
EXIT_124            EDC
EXIT_127            EFC
EXIT_132            F46
EXIT_135            F76
EXIT_139            FC0
EXIT_14             5C8
EXIT_142            FE2
EXIT_147            102C
EXIT_149            10A8
EXIT_152            10CC
EXIT_157            1116
EXIT_164            11A8
EXIT_167            1218
EXIT_169            1238
EXIT_172            125A
EXIT_176            12A4
EXIT_179            12C6
EXIT_183            1310
EXIT_186            1330
EXIT_19             612
EXIT_191            137A
EXIT_194            13BC
EXIT_197            13E4
EXIT_202            142E
EXIT_207            1474
EXIT_21             632
EXIT_210            14AA
EXIT_214            14F4
EXIT_217            1516
EXIT_222            1560
EXIT_233            1614
EXIT_236            1678
EXIT_239            1698
EXIT_24             652
EXIT_243            16E2
EXIT_246            1704
EXIT_251            174E
EXIT_26             67C
EXIT_260            17E6
EXIT_262            1828
EXIT_265            184A
EXIT_270            1894
EXIT_272            18B4
EXIT_275            18D6
EXIT_280            1920
EXIT_284            1998
EXIT_286            19C4
EXIT_288            19E8
EXIT_291            1A0C
EXIT_295            1A56
EXIT_298            1A7A
EXIT_303            1AC4
EXIT_305            1AFC
EXIT_307            1B1E
EXIT_309            1B40
EXIT_311            1B62
EXIT_32             710
EXIT_34             780
EXIT_36             7AC
EXIT_39             7D6
EXIT_4              534
EXIT_49             884
EXIT_56             8FA
EXIT_6              558
EXIT_70             A3E
EXIT_9              580
FOR                 1DCB
FROM                1E09
G                   1030
GET_INPUT           67C
H                   784
HASH                1944
HELP                1B7D
HELPPROMPT          1B6A
HEX2BIN             10B
HEX2BIN_LUT         1D4F
HEX_DIGIT           195A
HUH                 1CDD
I                   1924
ILLEGAL_HANDLER     1ACC
L                   1126
LF                  A
LOADING             1D66
LOOP_108            DB0
LOOP_11             584
LOOP_110            DD0
LOOP_114            E02
LOOP_122            E98
LOOP_124            EC0
LOOP_126            EFE
LOOP_127            EE0
LOOP_13             5CA
LOOP_132            F2A
LOOP_134            F78
LOOP_135            F5A
LOOP_139            FA4
LOOP_14             5AC
LOOP_141            FE4
LOOP_142            FC6
LOOP_147            1010
LOOP_149            108C
LOOP_151            10CE
LOOP_152            10B0
LOOP_157            10FA
LOOP_164            118C
LOOP_167            11FC
LOOP_169            121C
LOOP_171            125C
LOOP_172            123E
LOOP_176            1288
LOOP_178            12C8
LOOP_179            12AA
LOOP_183            12F4
LOOP_185            1332
LOOP_186            1314
LOOP_19             5F6
LOOP_191            135E
LOOP_194            13A0
LOOP_196            13E6
LOOP_197            13C8
LOOP_202            1412
LOOP_207            1458
LOOP_209            14AC
LOOP_21             616
LOOP_210            148E
LOOP_214            14D8
LOOP_216            1518
LOOP_217            14FA
LOOP_222            1544
LOOP_233            15F8
LOOP_236            165C
LOOP_238            169A
LOOP_239            167C
LOOP_24             636
LOOP_243            16C6
LOOP_245            1706
LOOP_246            16E8
LOOP_251            1732
LOOP_26             660
LOOP_260            17CA
LOOP_262            180C
LOOP_264            184C
LOOP_265            182E
LOOP_270            1878
LOOP_272            1898
LOOP_274            18D8
LOOP_275            18BA
LOOP_280            1904
LOOP_284            197C
LOOP_286            19A8
LOOP_288            19CC
LOOP_290            1A0E
LOOP_291            19F0
LOOP_295            1A3A
LOOP_297            1A7C
LOOP_298            1A5E
LOOP_303            1AA8
LOOP_305            1AE0
LOOP_307            1B02
LOOP_309            1B24
LOOP_311            1B46
LOOP_32             6F4
LOOP_34             764
LOOP_36             790
LOOP_38             7D8
LOOP_39             7BA
LOOP_4              518
LOOP_49             868
LOOP_56             8DE
LOOP_6              53C
LOOP_70             A22
LOOP_9              564
M                   1770
MAIN_LOOP           65C
NULL                0
O                   1934
OX                  1DC3
P                   15A0
PRINTSTR            790
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1DC0
PROTECT             A40
R                   7B0
RAM                 200000
RAM_ERROR           1D2E
READ                1CE4
READING             1DF7
READ_CHAR           62D
RESET               4
ROM                 0
S                   904
SP                  1D89
SPURIOUS            1E46
SPURIOUS_HANDLER    1B20
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1DD1
START               400
STATUS_REGISTER     1DD6
TAB                 9
TICK                1DDB
TICK_HANDLER        1B42
TO                  1DC6
UNHANDLED           1E10
UNHANDLED_HANDLER   1ADC
UNINITIALISED       1E26
UNINITIALISED_HANDLER  1AFE
UNPROTECT           979
UNREC               1D06
USER                100
V                   78C
VECS                8
VECTORS             1DAB
VERSION             1E83
W                   888
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_193  138C
WAIT_FOR_COMPLETE_205  1438
WAIT_FOR_COMPLETE_206  144A
WAIT_FOR_COMPLETE_225  1564
WAIT_FOR_COMPLETE_226  1576
WAIT_FOR_COMPLETE_253  1750
WAIT_FOR_READY_1    4CA
WAIT_FOR_READY_10   56C
WAIT_FOR_READY_100  D00
WAIT_FOR_READY_103  D3E
WAIT_FOR_READY_105  D72
WAIT_FOR_READY_109  DB8
WAIT_FOR_READY_111  DD8
WAIT_FOR_READY_112  DEC
WAIT_FOR_READY_115  E0A
WAIT_FOR_READY_117  E30
WAIT_FOR_READY_119  E64
WAIT_FOR_READY_12   58C
WAIT_FOR_READY_123  EA0
WAIT_FOR_READY_125  EC8
WAIT_FOR_READY_128  EE8
WAIT_FOR_READY_130  F10
WAIT_FOR_READY_133  F32
WAIT_FOR_READY_136  F62
WAIT_FOR_READY_138  F8A
WAIT_FOR_READY_140  FAC
WAIT_FOR_READY_143  FCE
WAIT_FOR_READY_145  FF6
WAIT_FOR_READY_148  1018
WAIT_FOR_READY_15   5B4
WAIT_FOR_READY_150  1094
WAIT_FOR_READY_153  10B8
WAIT_FOR_READY_155  10E0
WAIT_FOR_READY_158  1102
WAIT_FOR_READY_159  1134
WAIT_FOR_READY_161  114E
WAIT_FOR_READY_165  1194
WAIT_FOR_READY_168  1204
WAIT_FOR_READY_17   5DC
WAIT_FOR_READY_170  1224
WAIT_FOR_READY_173  1246
WAIT_FOR_READY_175  126E
WAIT_FOR_READY_177  1290
WAIT_FOR_READY_180  12B2
WAIT_FOR_READY_182  12DA
WAIT_FOR_READY_184  12FC
WAIT_FOR_READY_187  131C
WAIT_FOR_READY_189  1344
WAIT_FOR_READY_192  1366
WAIT_FOR_READY_195  13A8
WAIT_FOR_READY_198  13D0
WAIT_FOR_READY_2    4DE
WAIT_FOR_READY_20   5FE
WAIT_FOR_READY_200  13F8
WAIT_FOR_READY_203  141A
WAIT_FOR_READY_208  1460
WAIT_FOR_READY_211  1496
WAIT_FOR_READY_213  14BE
WAIT_FOR_READY_215  14E0
WAIT_FOR_READY_218  1502
WAIT_FOR_READY_22   61E
WAIT_FOR_READY_220  152A
WAIT_FOR_READY_223  154C
WAIT_FOR_READY_228  15AC
WAIT_FOR_READY_230  15C6
WAIT_FOR_READY_234  1600
WAIT_FOR_READY_237  1664
WAIT_FOR_READY_240  1684
WAIT_FOR_READY_242  16AC
WAIT_FOR_READY_244  16CE
WAIT_FOR_READY_247  16F0
WAIT_FOR_READY_249  1718
WAIT_FOR_READY_25   63E
WAIT_FOR_READY_252  173A
WAIT_FOR_READY_255  177E
WAIT_FOR_READY_257  1798
WAIT_FOR_READY_261  17D2
WAIT_FOR_READY_263  1814
WAIT_FOR_READY_266  1836
WAIT_FOR_READY_268  185E
WAIT_FOR_READY_27   668
WAIT_FOR_READY_271  1880
WAIT_FOR_READY_273  18A0
WAIT_FOR_READY_276  18C2
WAIT_FOR_READY_278  18EA
WAIT_FOR_READY_28   67C
WAIT_FOR_READY_281  190C
WAIT_FOR_READY_285  1984
WAIT_FOR_READY_287  19B0
WAIT_FOR_READY_289  19D4
WAIT_FOR_READY_292  19F8
WAIT_FOR_READY_294  1A20
WAIT_FOR_READY_296  1A42
WAIT_FOR_READY_299  1A66
WAIT_FOR_READY_3    4F2
WAIT_FOR_READY_30   696
WAIT_FOR_READY_301  1A8E
WAIT_FOR_READY_304  1AB0
WAIT_FOR_READY_306  1AE8
WAIT_FOR_READY_308  1B0A
WAIT_FOR_READY_310  1B2C
WAIT_FOR_READY_312  1B4E
WAIT_FOR_READY_33   6FC
WAIT_FOR_READY_35   76C
WAIT_FOR_READY_37   798
WAIT_FOR_READY_40   7C2
WAIT_FOR_READY_42   7EA
WAIT_FOR_READY_43   800
WAIT_FOR_READY_44   816
WAIT_FOR_READY_45   82A
WAIT_FOR_READY_46   83E
WAIT_FOR_READY_47   852
WAIT_FOR_READY_5    520
WAIT_FOR_READY_50   870
WAIT_FOR_READY_51   892
WAIT_FOR_READY_53   8AC
WAIT_FOR_READY_57   8E6
WAIT_FOR_READY_58   90C
WAIT_FOR_READY_60   946
WAIT_FOR_READY_61   95C
WAIT_FOR_READY_63   990
WAIT_FOR_READY_65   9B2
WAIT_FOR_READY_67   9E6
WAIT_FOR_READY_7    544
WAIT_FOR_READY_71   A2A
WAIT_FOR_READY_73   A66
WAIT_FOR_READY_75   A9A
WAIT_FOR_READY_78   AD8
WAIT_FOR_READY_80   B0C
WAIT_FOR_READY_83   B54
WAIT_FOR_READY_85   B88
WAIT_FOR_READY_88   BD2
WAIT_FOR_READY_90   C06
WAIT_FOR_READY_93   C5A
WAIT_FOR_READY_95   C8E
WAIT_FOR_READY_98   CCC
WAIT_FOR_SRECORD    90C
WARM_START          1E6F
WRITE               19C8
WRITING             1E00
X                   1808
Z                   1036
_00000000           538
_00000001           558
_00000002           6BC
_00000003           6D0
_00000004           A46
_00000005           E22
_00000006           A54
_00000007           C42
_00000008           BB8
_00000009           E22
_0000000A           DAC
_0000000B           E22
_0000000C           F4A
_0000000D           F56
_0000000E           1116
_0000000F           1396
_00000010           1442
_00000011           1454
_00000012           156E
_00000013           1580
_00000014           175A
_10000000           9A8
_10000001           A10
_10000002           A5C
_10000003           AC4
_10000004           ACE
_10000005           B36
_10000006           B4A
_10000007           BB2
_10000008           BBC
_10000009           C3C
_1000000A           BC8
_1000000B           C30
_1000000C           C50
_1000000D           CB8
_1000000E           CC2
_1000000F           D2A
_10000010           D34
_10000011           D9C
_10000012           E26
_10000013           E8E
_10000014           137A
_10000015           139C
_10000016           17F0
_10000017           1804
_20000000           42E
_20000001           43A
_20000002           448
_20000003           454
_20000004           890
_20000005           8D4
_20000006           1048
_20000007           1058
_20000008           1072
_20000009           1118
_2000000A           1132
_2000000B           1176
_2000000C           11EE
_2000000D           11F2
_2000000E           147C
_2000000F           1582
_20000010           15AA
_20000011           15EE
_20000012           164E
_20000013           1652
_20000014           177C
_20000015           17C0
