00000400 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/04/2021 12:21:23

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00C00000                 22  DUART_BASE          EQU $C00000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000006                 31  DUART_CTUR_         EQU $6
00000000  =00000007                 32  DUART_CTLR_         EQU $7
00000000  =00000008                 33  DUART_MRB_          EQU $8
00000000  =00000009                 34  DUART_CSRB_         EQU $9
00000000  =00000009                 35  DUART_SRB_          EQU $9
00000000  =0000000A                 36  DUART_CRB_          EQU $A
00000000  =0000000B                 37  DUART_TXB_          EQU $B
00000000  =0000000B                 38  DUART_RXB_          EQU $B
00000000  =0000000C                 39  DUART_IVR_          EQU $C
00000000  =0000000D                 40  DUART_OPCR_         EQU $D
00000000  =0000000E                 41  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 42  DUART_RESET_OPR_    EQU $F
00000000                            43  
00000000  =00C00001                 44  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 45  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 46  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 47  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 48  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 49  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            50  
00000000  =00C00011                 51  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 52  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 53  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 54  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 55  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 56  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            57  
00000000  =00C00009                 58  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 59  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 60  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 61  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 62  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 63  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 64  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 65  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            66  
00000000  =00E00000                 67  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 68  DISPLAY_            EQU $0
00000000  =00E00001                 69  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            77      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78      MOVE.B \1,\2
00000000                            79      ANDI.L #$F,\2
00000000                            80      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            81      ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            88      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            89      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            90      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           100          BTST #2,\2                                  ; check for space to send
00000000                           101          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           102          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           103      ENDC
00000000                           104  
00000000                           105      IFNE DEBUG
00000000                           106          MOVE.B \1,D1
00000000                           107          MOVE.L #6,D0   
00000000                           108          TRAP #15                                    ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll, /2 = working address register
00000000                           115  PRINT_CRLF MACRO
00000000                           116      LEA CRLF(PC),\2
00000000                           117      PRINT_STR \2,\1
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      BRA LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           133  PRINT_REG MACRO
00000000                           134      LEA ox(PC),\5
00000000                           135      PRINT_STR \5,\2
00000000                           136      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142  
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           148      IFEQ DEBUG
00000000                           149          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           150          BTST #0,\2                                  ; check for character
00000000                           151          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           152      ENDC
00000000                           153  
00000000                           154      READ_CHAR \1
00000000                           155  
00000000                           156      IFEQ DEBUG
00000000                           157          PRINT_CHAR \1,\2                            ; echo it back
00000000                           158      ENDC
00000000                           159      ENDM
00000000                           160  
00000000                           161  ; read a char from the serial port - assumes that there is one!
00000000                           162  ; \ 1= data register for read char
00000000                           163  ; will stamp on D0 and D1 in debug mode
00000000                           164  READ_CHAR MACRO
00000000                           165      IFEQ DEBUG
00000000                           166          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           167      ENDC
00000000                           168      IFNE DEBUG
00000000                           169          MOVE.L #5,D0    
00000000                           170          TRAP #15                                    ; read from keyboard in simulator
00000000                           171          MOVE.L D1,\1
00000000                           172      ENDC
00000000                           173  
00000000                           174      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           175      BEQ START
00000000                           176      ENDM
00000000                           177  
00000000                           178  
00000000                           179  ; read data from the download serial port
00000000                           180  ; \ 1= data register for read char
00000000                           181  DOWNLOAD MACRO
00000000                           182  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           183  
00000000                           184      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           185      BTST #0,\1                                      ; check for character
00000000                           186      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           187  
00000000                           188      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           189  CONTINUE\@
00000000                           190      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           193      
00000000                           194      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           195      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           196  
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; unprotect the EEPROM
00000000                           200  UNPROTECT MACRO
00000000                           201      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           202      NOP
00000000                           203      MOVE.W #$5555,$1554
00000000                           204      NOP
00000000                           205      MOVE.W #$8080,$2AAA
00000000                           206      NOP
00000000                           207      MOVE.W #$AAAA,$2AAA
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$2020,$2AAA
00000000                           212      ENDM
00000000                           213      
00000000                           214  ; protect the EEPROM
00000000                           215  PROTECT MACRO
00000000                           216      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           217      MOVE.W #$5555,$1554
00000000                           218      MOVE.W #$A0A0,$2AAA
00000000                           219      ENDM
00000000                           220  
00000000                           221  
00000000                           222  ; read two hex digits from the download serial port and convert to a byte
00000000                           223  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           224  DOWNLOAD_BYTE MACRO
00000000                           225      MOVE.B #2,\4
00000000                           226      WHILE.B \4 <GT> 0 DO
00000000                           227          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           228          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           229          PRINT_CHAR \2,\3
00000000                           230          HEX2BIN \2,\2,\6
00000000                           231          OR.B \2,\1
00000000                           232          SUB.B #1,\4
00000000                           233      ENDW
00000000                           234  
00000000                           235      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           236      MOVE.B \1,\2
00000000                           237      ADD.L \1,\5
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; write word to EEPROM
00000000                           242  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           243  PROGRAM MACRO
00000000                           244    MOVE.W \1,\2                                      ; write the data
00000000                           245  
00000000                           246  WAIT_FOR_COMPLETE\@
00000000                           247          MOVE.W \2,\3
00000000                           248  
00000000                           249          IF.W \3 <NE> \1 THEN
00000000                           250              BRA WAIT_FOR_COMPLETE\@
00000000                           251          ENDI
00000000                           252          ENDM
00000000                           253          
00000000                           254  ; program vector to EEPROM
00000000                           255  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           256  PROGRAM_VECTOR MACRO
00000000                           257      ADD.L #2,\2
00000000                           258      PROGRAM \1, (\2), \3                                ; write it
00000000                           259      LSR.L #8,\1
00000000                           260      LSR.L #8,\1
00000000                           261      SUB.L #2,\2
00000000                           262      PROGRAM \1, (\2), \3
00000000                           263      ENDM
00000000                           264  
00000000                           265  
00000000                           266  ; register catalogue
00000000                           267  ; D0 - used for simulator I/O
00000000                           268  ; D1 - used for simulator I/O
00000000                           269  ; D2 - read character
00000000                           270  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           271  ; D6 - working register used in R/W
00000000                           272  ; D7 - address accumulator, reset by download
00000000                           273  ; A0 - address of string to print 
00000000                           274  
00000000                           275  ; start vector
00000000= 002E0000                 276  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000400                 277  RESET   DC.L START                              ; RESET
00000008= 00001908                 278  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 00001908                 279          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001A5C                 280          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 00001A6C                 281          DC.L UNHANDLED_HANDLER
00000018= 00001A6C                 282          DC.L UNHANDLED_HANDLER
0000001C= 00001A6C                 283          DC.L UNHANDLED_HANDLER
00000020= 00001A6C                 284          DC.L UNHANDLED_HANDLER
00000024= 00001A6C                 285          DC.L UNHANDLED_HANDLER
00000028= 00001A6C                 286          DC.L UNHANDLED_HANDLER
0000002C= 00001A6C                 287          DC.L UNHANDLED_HANDLER
00000030= 00001A6C                 288          DC.L UNHANDLED_HANDLER
00000034= 00001A6C                 289          DC.L UNHANDLED_HANDLER
00000038= 00001A6C                 290          DC.L UNHANDLED_HANDLER
0000003C= 00001A6C                 291          DC.L UNHANDLED_HANDLER
00000040= 00001A6C                 292          DC.L UNHANDLED_HANDLER
00000044= 00001A6C                 293          DC.L UNHANDLED_HANDLER
00000048= 00001A6C                 294          DC.L UNHANDLED_HANDLER
0000004C= 00001A6C                 295          DC.L UNHANDLED_HANDLER
00000050= 00001A6C                 296          DC.L UNHANDLED_HANDLER
00000054= 00001A6C                 297          DC.L UNHANDLED_HANDLER
00000058= 00001A6C                 298          DC.L UNHANDLED_HANDLER
0000005C= 00001A6C                 299          DC.L UNHANDLED_HANDLER
00000060= 00001AB0                 300          DC.L SPURIOUS_HANDLER
00000064= 00001A6C                 301          DC.L UNHANDLED_HANDLER
00000068= 00001A6C                 302          DC.L UNHANDLED_HANDLER
0000006C= 00001A6C                 303          DC.L UNHANDLED_HANDLER
00000070= 00001A6C                 304          DC.L UNHANDLED_HANDLER
00000074= 00001A6C                 305          DC.L UNHANDLED_HANDLER
00000078= 00001A6C                 306          DC.L UNHANDLED_HANDLER
0000007C= 00001A6C                 307          DC.L UNHANDLED_HANDLER
00000080= 00001A6C                 308          DC.L UNHANDLED_HANDLER
00000084= 00001A6C                 309          DC.L UNHANDLED_HANDLER
00000088= 00001A6C                 310          DC.L UNHANDLED_HANDLER
0000008C= 00001A6C                 311          DC.L UNHANDLED_HANDLER
00000090= 00001A6C                 312          DC.L UNHANDLED_HANDLER
00000094= 00001A6C                 313          DC.L UNHANDLED_HANDLER
00000098= 00001A6C                 314          DC.L UNHANDLED_HANDLER
0000009C= 00001A6C                 315          DC.L UNHANDLED_HANDLER
000000A0= 00001A6C                 316          DC.L UNHANDLED_HANDLER
000000A4= 00001A6C                 317          DC.L UNHANDLED_HANDLER
000000A8= 00001A6C                 318          DC.L UNHANDLED_HANDLER
000000AC= 00001A6C                 319          DC.L UNHANDLED_HANDLER
000000B0= 00001A6C                 320          DC.L UNHANDLED_HANDLER
000000B4= 00001A6C                 321          DC.L UNHANDLED_HANDLER
000000B8= 00001A6C                 322          DC.L UNHANDLED_HANDLER
000000BC= 00001A6C                 323          DC.L UNHANDLED_HANDLER
000000C0= 00001A6C                 324          DC.L UNHANDLED_HANDLER
000000C4= 00001A6C                 325          DC.L UNHANDLED_HANDLER
000000C8= 00001A6C                 326          DC.L UNHANDLED_HANDLER
000000CC= 00001A6C                 327          DC.L UNHANDLED_HANDLER
000000D0= 00001A6C                 328          DC.L UNHANDLED_HANDLER
000000D4= 00001A6C                 329          DC.L UNHANDLED_HANDLER
000000D8= 00001A6C                 330          DC.L UNHANDLED_HANDLER 
000000DC= 00001A6C                 331          DC.L UNHANDLED_HANDLER
000000E0= 00001A6C                 332          DC.L UNHANDLED_HANDLER
000000E4= 00001A6C                 333          DC.L UNHANDLED_HANDLER 
000000E8= 00001A6C                 334          DC.L UNHANDLED_HANDLER 
000000EC= 00001A6C                 335          DC.L UNHANDLED_HANDLER
000000F0= 00001A6C                 336          DC.L UNHANDLED_HANDLER 
000000F4= 00001A6C                 337          DC.L UNHANDLED_HANDLER 
000000F8= 00001A6C                 338          DC.L UNHANDLED_HANDLER 
000000FC= 00001A6C                 339          DC.L UNHANDLED_HANDLER
00000100= 00001AD2                 340  USER    DC.L TICK_HANDLER
00000104= 00001A6C                 341          DC.L UNHANDLED_HANDLER 
00000108= 00001A6C                 342          DC.L UNHANDLED_HANDLER 
0000010C= 00001A6C                 343          DC.L UNHANDLED_HANDLER 
00000110= 00001A6C                 344          DC.L UNHANDLED_HANDLER 
00000114= 00001A6C                 345          DC.L UNHANDLED_HANDLER 
00000118= 00001A6C                 346          DC.L UNHANDLED_HANDLER 
0000011C= 00001A6C                 347          DC.L UNHANDLED_HANDLER
00000120= 00001A6C                 348          DC.L UNHANDLED_HANDLER
00000124= 00001A6C                 349          DC.L UNHANDLED_HANDLER
00000128= 00001A6C                 350          DC.L UNHANDLED_HANDLER
0000012C= 00001A6C                 351          DC.L UNHANDLED_HANDLER
00000130= 00001A6C                 352          DC.L UNHANDLED_HANDLER
00000134= 00001A6C                 353          DC.L UNHANDLED_HANDLER
00000138= 00001A6C                 354          DC.L UNHANDLED_HANDLER
0000013C= 00001A6C                 355          DC.L UNHANDLED_HANDLER
00000140= 00001A6C                 356          DC.L UNHANDLED_HANDLER
00000144= 00001A6C                 357          DC.L UNHANDLED_HANDLER
00000148= 00001A6C                 358          DC.L UNHANDLED_HANDLER
0000014C= 00001A6C                 359          DC.L UNHANDLED_HANDLER
00000150= 00001A6C                 360          DC.L UNHANDLED_HANDLER
00000154= 00001A6C                 361          DC.L UNHANDLED_HANDLER
00000158= 00001A6C                 362          DC.L UNHANDLED_HANDLER
0000015C= 00001A6C                 363          DC.L UNHANDLED_HANDLER
00000160= 00001A6C                 364          DC.L UNHANDLED_HANDLER
00000164= 00001A6C                 365          DC.L UNHANDLED_HANDLER
00000168= 00001A6C                 366          DC.L UNHANDLED_HANDLER
0000016C= 00001A6C                 367          DC.L UNHANDLED_HANDLER
00000170= 00001A6C                 368          DC.L UNHANDLED_HANDLER
00000174= 00001A6C                 369          DC.L UNHANDLED_HANDLER
00000178= 00001A6C                 370          DC.L UNHANDLED_HANDLER
0000017C= 00001A6C                 371          DC.L UNHANDLED_HANDLER
00000180= 00001A6C                 372          DC.L UNHANDLED_HANDLER
00000184= 00001A6C                 373          DC.L UNHANDLED_HANDLER
00000188= 00001A6C                 374          DC.L UNHANDLED_HANDLER
0000018C= 00001A6C                 375          DC.L UNHANDLED_HANDLER
00000190= 00001A6C                 376          DC.L UNHANDLED_HANDLER
00000194= 00001A6C                 377          DC.L UNHANDLED_HANDLER
00000198= 00001A6C                 378          DC.L UNHANDLED_HANDLER
0000019C= 00001A6C                 379          DC.L UNHANDLED_HANDLER
000001A0= 00001A6C                 380          DC.L UNHANDLED_HANDLER
000001A4= 00001A6C                 381          DC.L UNHANDLED_HANDLER
000001A8= 00001A6C                 382          DC.L UNHANDLED_HANDLER
000001AC= 00001A6C                 383          DC.L UNHANDLED_HANDLER
000001B0= 00001A6C                 384          DC.L UNHANDLED_HANDLER
000001B4= 00001A6C                 385          DC.L UNHANDLED_HANDLER
000001B8= 00001A6C                 386          DC.L UNHANDLED_HANDLER
000001BC= 00001A6C                 387          DC.L UNHANDLED_HANDLER
000001C0= 00001A6C                 388          DC.L UNHANDLED_HANDLER
000001C4= 00001A6C                 389          DC.L UNHANDLED_HANDLER
000001C8= 00001A6C                 390          DC.L UNHANDLED_HANDLER
000001CC= 00001A6C                 391          DC.L UNHANDLED_HANDLER
000001D0= 00001A6C                 392          DC.L UNHANDLED_HANDLER
000001D4= 00001A6C                 393          DC.L UNHANDLED_HANDLER
000001D8= 00001A6C                 394          DC.L UNHANDLED_HANDLER
000001DC= 00001A6C                 395          DC.L UNHANDLED_HANDLER
000001E0= 00001A6C                 396          DC.L UNHANDLED_HANDLER
000001E4= 00001A6C                 397          DC.L UNHANDLED_HANDLER
000001E8= 00001A6C                 398          DC.L UNHANDLED_HANDLER
000001EC= 00001A6C                 399          DC.L UNHANDLED_HANDLER
000001F0= 00001A6C                 400          DC.L UNHANDLED_HANDLER
000001F4= 00001A6C                 401          DC.L UNHANDLED_HANDLER
000001F8= 00001A6C                 402          DC.L UNHANDLED_HANDLER
000001FC= 00001A6C                 403          DC.L UNHANDLED_HANDLER
00000200= 00001A6C                 404          DC.L UNHANDLED_HANDLER
00000204= 00001A6C                 405          DC.L UNHANDLED_HANDLER
00000208= 00001A6C                 406          DC.L UNHANDLED_HANDLER
0000020C= 00001A6C                 407          DC.L UNHANDLED_HANDLER
00000210= 00001A6C                 408          DC.L UNHANDLED_HANDLER
00000214= 00001A6C                 409          DC.L UNHANDLED_HANDLER
00000218= 00001A6C                 410          DC.L UNHANDLED_HANDLER
0000021C= 00001A6C                 411          DC.L UNHANDLED_HANDLER
00000220= 00001A6C                 412          DC.L UNHANDLED_HANDLER
00000224= 00001A6C                 413          DC.L UNHANDLED_HANDLER
00000228= 00001A6C                 414          DC.L UNHANDLED_HANDLER
0000022C= 00001A6C                 415          DC.L UNHANDLED_HANDLER
00000230= 00001A6C                 416          DC.L UNHANDLED_HANDLER
00000234= 00001A6C                 417          DC.L UNHANDLED_HANDLER
00000238= 00001A6C                 418          DC.L UNHANDLED_HANDLER
0000023C= 00001A6C                 419          DC.L UNHANDLED_HANDLER
00000240= 00001A6C                 420          DC.L UNHANDLED_HANDLER
00000244= 00001A6C                 421          DC.L UNHANDLED_HANDLER
00000248= 00001A6C                 422          DC.L UNHANDLED_HANDLER
0000024C= 00001A6C                 423          DC.L UNHANDLED_HANDLER
00000250= 00001A6C                 424          DC.L UNHANDLED_HANDLER
00000254= 00001A6C                 425          DC.L UNHANDLED_HANDLER
00000258= 00001A6C                 426          DC.L UNHANDLED_HANDLER
0000025C= 00001A6C                 427          DC.L UNHANDLED_HANDLER
00000260= 00001A6C                 428          DC.L UNHANDLED_HANDLER
00000264= 00001A6C                 429          DC.L UNHANDLED_HANDLER
00000268= 00001A6C                 430          DC.L UNHANDLED_HANDLER
0000026C= 00001A6C                 431          DC.L UNHANDLED_HANDLER
00000270= 00001A6C                 432          DC.L UNHANDLED_HANDLER
00000274= 00001A6C                 433          DC.L UNHANDLED_HANDLER
00000278= 00001A6C                 434          DC.L UNHANDLED_HANDLER
0000027C= 00001A6C                 435          DC.L UNHANDLED_HANDLER
00000280= 00001A6C                 436          DC.L UNHANDLED_HANDLER
00000284= 00001A6C                 437          DC.L UNHANDLED_HANDLER
00000288= 00001A6C                 438          DC.L UNHANDLED_HANDLER
0000028C= 00001A6C                 439          DC.L UNHANDLED_HANDLER
00000290= 00001A6C                 440          DC.L UNHANDLED_HANDLER
00000294= 00001A6C                 441          DC.L UNHANDLED_HANDLER
00000298= 00001A6C                 442          DC.L UNHANDLED_HANDLER
0000029C= 00001A6C                 443          DC.L UNHANDLED_HANDLER
000002A0= 00001A6C                 444          DC.L UNHANDLED_HANDLER
000002A4= 00001A6C                 445          DC.L UNHANDLED_HANDLER
000002A8= 00001A6C                 446          DC.L UNHANDLED_HANDLER
000002AC= 00001A6C                 447          DC.L UNHANDLED_HANDLER
000002B0= 00001A6C                 448          DC.L UNHANDLED_HANDLER
000002B4= 00001A6C                 449          DC.L UNHANDLED_HANDLER
000002B8= 00001A6C                 450          DC.L UNHANDLED_HANDLER
000002BC= 00001A6C                 451          DC.L UNHANDLED_HANDLER
000002C0= 00001A6C                 452          DC.L UNHANDLED_HANDLER
000002C4= 00001A6C                 453          DC.L UNHANDLED_HANDLER
000002C8= 00001A6C                 454          DC.L UNHANDLED_HANDLER
000002CC= 00001A6C                 455          DC.L UNHANDLED_HANDLER
000002D0= 00001A6C                 456          DC.L UNHANDLED_HANDLER
000002D4= 00001A6C                 457          DC.L UNHANDLED_HANDLER
000002D8= 00001A6C                 458          DC.L UNHANDLED_HANDLER
000002DC= 00001A6C                 459          DC.L UNHANDLED_HANDLER
000002E0= 00001A6C                 460          DC.L UNHANDLED_HANDLER
000002E4= 00001A6C                 461          DC.L UNHANDLED_HANDLER
000002E8= 00001A6C                 462          DC.L UNHANDLED_HANDLER
000002EC= 00001A6C                 463          DC.L UNHANDLED_HANDLER
000002F0= 00001A6C                 464          DC.L UNHANDLED_HANDLER
000002F4= 00001A6C                 465          DC.L UNHANDLED_HANDLER
000002F8= 00001A6C                 466          DC.L UNHANDLED_HANDLER
000002FC= 00001A6C                 467          DC.L UNHANDLED_HANDLER
00000300= 00001A6C                 468          DC.L UNHANDLED_HANDLER
00000304= 00001A6C                 469          DC.L UNHANDLED_HANDLER
00000308= 00001A6C                 470          DC.L UNHANDLED_HANDLER
0000030C= 00001A6C                 471          DC.L UNHANDLED_HANDLER
00000310= 00001A6C                 472          DC.L UNHANDLED_HANDLER
00000314= 00001A6C                 473          DC.L UNHANDLED_HANDLER
00000318= 00001A6C                 474          DC.L UNHANDLED_HANDLER
0000031C= 00001A6C                 475          DC.L UNHANDLED_HANDLER
00000320= 00001A6C                 476          DC.L UNHANDLED_HANDLER
00000324= 00001A6C                 477          DC.L UNHANDLED_HANDLER
00000328= 00001A6C                 478          DC.L UNHANDLED_HANDLER
0000032C= 00001A6C                 479          DC.L UNHANDLED_HANDLER
00000330= 00001A6C                 480          DC.L UNHANDLED_HANDLER
00000334= 00001A6C                 481          DC.L UNHANDLED_HANDLER
00000338= 00001A6C                 482          DC.L UNHANDLED_HANDLER
0000033C= 00001A6C                 483          DC.L UNHANDLED_HANDLER
00000340= 00001A6C                 484          DC.L UNHANDLED_HANDLER
00000344= 00001A6C                 485          DC.L UNHANDLED_HANDLER
00000348= 00001A6C                 486          DC.L UNHANDLED_HANDLER
0000034C= 00001A6C                 487          DC.L UNHANDLED_HANDLER
00000350= 00001A6C                 488          DC.L UNHANDLED_HANDLER
00000354= 00001A6C                 489          DC.L UNHANDLED_HANDLER
00000358= 00001A6C                 490          DC.L UNHANDLED_HANDLER
0000035C= 00001A6C                 491          DC.L UNHANDLED_HANDLER
00000360= 00001A6C                 492          DC.L UNHANDLED_HANDLER
00000364= 00001A6C                 493          DC.L UNHANDLED_HANDLER
00000368= 00001A6C                 494          DC.L UNHANDLED_HANDLER
0000036C= 00001A6C                 495          DC.L UNHANDLED_HANDLER
00000370= 00001A6C                 496          DC.L UNHANDLED_HANDLER
00000374= 00001A6C                 497          DC.L UNHANDLED_HANDLER
00000378= 00001A6C                 498          DC.L UNHANDLED_HANDLER
0000037C= 00001A6C                 499          DC.L UNHANDLED_HANDLER
00000380= 00001A6C                 500          DC.L UNHANDLED_HANDLER
00000384= 00001A6C                 501          DC.L UNHANDLED_HANDLER
00000388= 00001A6C                 502          DC.L UNHANDLED_HANDLER
0000038C= 00001A6C                 503          DC.L UNHANDLED_HANDLER
00000390= 00001A6C                 504          DC.L UNHANDLED_HANDLER
00000394= 00001A6C                 505          DC.L UNHANDLED_HANDLER
00000398= 00001A6C                 506          DC.L UNHANDLED_HANDLER
0000039C= 00001A6C                 507          DC.L UNHANDLED_HANDLER
000003A0= 00001A6C                 508          DC.L UNHANDLED_HANDLER
000003A4= 00001A6C                 509          DC.L UNHANDLED_HANDLER
000003A8= 00001A6C                 510          DC.L UNHANDLED_HANDLER
000003AC= 00001A6C                 511          DC.L UNHANDLED_HANDLER
000003B0= 00001A6C                 512          DC.L UNHANDLED_HANDLER
000003B4= 00001A6C                 513          DC.L UNHANDLED_HANDLER
000003B8= 00001A6C                 514          DC.L UNHANDLED_HANDLER
000003BC= 00001A6C                 515          DC.L UNHANDLED_HANDLER
000003C0= 00001A6C                 516          DC.L UNHANDLED_HANDLER
000003C4= 00001A6C                 517          DC.L UNHANDLED_HANDLER
000003C8= 00001A6C                 518          DC.L UNHANDLED_HANDLER
000003CC= 00001A6C                 519          DC.L UNHANDLED_HANDLER
000003D0= 00001A6C                 520          DC.L UNHANDLED_HANDLER
000003D4= 00001A6C                 521          DC.L UNHANDLED_HANDLER
000003D8= 00001A6C                 522          DC.L UNHANDLED_HANDLER
000003DC= 00001A6C                 523          DC.L UNHANDLED_HANDLER
000003E0= 00001A6C                 524          DC.L UNHANDLED_HANDLER
000003E4= 00001A6C                 525          DC.L UNHANDLED_HANDLER
000003E8= 00001A6C                 526          DC.L UNHANDLED_HANDLER
000003EC= 00001A6C                 527          DC.L UNHANDLED_HANDLER
000003F0= 00001A6C                 528          DC.L UNHANDLED_HANDLER
000003F4= 00001A6C                 529          DC.L UNHANDLED_HANDLER
000003F8= 00001A6C                 530          DC.L UNHANDLED_HANDLER
000003FC= 00001A6C                 531          DC.L UNHANDLED_HANDLER
00000400                           532  ; start of program  
00000400                           533  START
00000400  2E7C 002E0000            534      MOVE.L #STACK_ADDRESS,A7
00000406  13FC 0000 00E00001       535      MOVE.B #0,DISPLAY
0000040E                           536  
0000040E  7000                     537      MOVE.L #0,D0
00000410  1039 00C00019            538      MOVE.B DUART_IVR,D0                             ; warm start?
00000416                           539  
00000416                           540  ; reset the UART in case of warm start
00000416  13FC 000A 00C00005       541      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
0000041E  13FC 000A 00C00015       542      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
00000426                           543      
00000426                           544      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000426  323C 0050                545s     MOVE.W  #$50,D1
0000042A  6000 000E                546s     BRA _20000001
0000042E                           547s _20000000
0000042E  13C1 00C00005            548          MOVE.B D1,DUART_CRA                         ; reset everyting
00000434  4E71                     549          NOP
00000436                           550      ENDF
00000436  0441 0010                551s     SUB.W   #$10,D1
0000043A                           552s _20000001
0000043A  B27C 0010                553s     CMP.W   #$10,D1
0000043E  6CEE                     554s     BGE _20000000
00000440                           555  
00000440                           556      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000440  323C 0050                557s     MOVE.W  #$50,D1
00000444  6000 000E                558s     BRA _20000003
00000448                           559s _20000002
00000448  13C1 00C00015            560          MOVE.B D1,DUART_CRB                         ; reset everyting
0000044E  4E71                     561          NOP
00000450                           562      ENDF
00000450  0441 0010                563s     SUB.W   #$10,D1
00000454                           564s _20000003
00000454  B27C 0010                565s     CMP.W   #$10,D1
00000458  6CEE                     566s     BGE _20000002
0000045A                           567      
0000045A                           568  ;initialise UART
0000045A  13FC 0000 00C0000B       569      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000462  13FC 00FF 00C0000D       570      MOVE.B #$FF,DUART_CTUR
0000046A  13FC 00FF 00C0000F       571      MOVE.B #$FF,DUART_CTLR
00000472  13FC 0070 00C00009       572      MOVE.B #$70,DUART_ACR
0000047A  13FC 0004 00C0001B       573      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000482                           574  
00000482                           575  ; channel A
00000482  13FC 0013 00C00001       576      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000048A  13FC 0007 00C00001       577      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000492  13FC 0066 00C00003       578      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000049A  13FC 0005 00C00005       579      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000004A2                           580  
000004A2                           581  ; channel B
000004A2  13FC 0013 00C00011       582      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000004AA  13FC 0007 00C00011       583      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000004B2  13FC 0066 00C00013       584      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000004BA  13FC 0005 00C00015       585      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000004C2  13FC 0040 00C00019       586      MOVE.B #64,DUART_IVR
000004CA                           587  
000004CA                           588m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000004CA                           589m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CA                 TRUE      590m     IFEQ DEBUG
000004CA  1239 00C00003            591m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004D0  0801 0002                592m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004D4  67F4                     593m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000004D6  13FC 0000 00C00007       594m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004DE                           595m     ENDC
000004DE                           596m 
000004DE                 FALSE     597m     IFNE DEBUG
000004DE                           598m     ENDC
000004DE                           599m 
000004DE                           600m     ENDM
000004DE                           601m     PRINT_CHAR #0,D1
000004DE                           602m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004DE                 TRUE      603m     IFEQ DEBUG
000004DE  1239 00C00003            604m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004E4  0801 0002                605m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004E8  67F4                     606m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000004EA  13FC 0000 00C00007       607m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F2                           608m     ENDC
000004F2                           609m 
000004F2                 FALSE     610m     IFNE DEBUG
000004F2                           611m     ENDC
000004F2                           612m 
000004F2                           613m     ENDM
000004F2                           614m     PRINT_CHAR #0,D1
000004F2                           615m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F2                 TRUE      616m     IFEQ DEBUG
000004F2  1239 00C00003            617m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004F8  0801 0002                618m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004FC  67F4                     619m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000004FE  13FC 0000 00C00007       620m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000506                           621m     ENDC
00000506                           622m 
00000506                 FALSE     623m     IFNE DEBUG
00000506                           624m     ENDC
00000506                           625m 
00000506                           626m     ENDM
00000506                           627      
00000506                           628      IF D0 <EQ> #$0F THEN
00000506  B07C 000F                629s     CMP.W   #$0F,D0
0000050A  6600 002C                630s     BNE _00000000
0000050E  1039 00C00005            631          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000514                           632  
00000514  41FA 18CF                633          LEA COLD_START(PC),A0
00000518                           634m         PRINT_STR A0,D0
00000518                           635m LOOP_4
00000518  0C10 0000                636m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000051C  6700 0016                637m     BEQ EXIT_4
00000520                           638mm     PRINT_CHAR (A0)+,D0
00000520                           639mm WAIT_FOR_READY_5                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000520                 TRUE      640mm     IFEQ DEBUG
00000520  1039 00C00003            641mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00000526  0800 0002                642mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000052A  67F4                     643mm         BEQ WAIT_FOR_READY_5                        ; NO SPACE, CHECK AGAIN
0000052C  13D8 00C00007            644mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000532                           645mm     ENDC
00000532                           646mm 
00000532                 FALSE     647mm     IFNE DEBUG
00000532                           648mm     ENDC
00000532                           649mm 
00000532                           650mm     ENDM
00000532  60E4                     651m     BRA LOOP_4
00000534                           652m EXIT_4
00000534                           653m     ENDM
00000534                           654      ELSE
00000534  6000 0022                655s     BRA _00000001
00000538                           656s _00000000
00000538  41FA 18BF                657          LEA WARM_START(PC),A0
0000053C                           658m         PRINT_STR A0,D0
0000053C                           659m LOOP_6
0000053C  0C10 0000                660m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000540  6700 0016                661m     BEQ EXIT_6
00000544                           662mm     PRINT_CHAR (A0)+,D0
00000544                           663mm WAIT_FOR_READY_7                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000544                 TRUE      664mm     IFEQ DEBUG
00000544  1039 00C00003            665mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
0000054A  0800 0002                666mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000054E  67F4                     667mm         BEQ WAIT_FOR_READY_7                        ; NO SPACE, CHECK AGAIN
00000550  13D8 00C00007            668mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000556                           669mm     ENDC
00000556                           670mm 
00000556                 FALSE     671mm     IFNE DEBUG
00000556                           672mm     ENDC
00000556                           673mm 
00000556                           674mm     ENDM
00000556  60E4                     675m     BRA LOOP_6
00000558                           676m EXIT_6
00000558                           677m     ENDM
00000558                           678      ENDI
00000558                           679s _00000001
00000558                           680  
00000558  13FC 0001 00E00001       681      MOVE.B #1,DISPLAY
00000560                           682      
00000560                           683m     PRINT_CRLF D1,A0
00000560  41FA 17EB                684m     LEA CRLF(PC),A0
00000564                           685mm     PRINT_STR A0,D1
00000564                           686mm LOOP_9
00000564  0C10 0000                687mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016                688mm     BEQ EXIT_9
0000056C                           689mmm     PRINT_CHAR (A0)+,D1
0000056C                           690mmm WAIT_FOR_READY_10                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE      691mmm     IFEQ DEBUG
0000056C  1239 00C00003            692mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000572  0801 0002                693mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                     694mmm         BEQ WAIT_FOR_READY_10                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007            695mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                           696mmm     ENDC
0000057E                           697mmm 
0000057E                 FALSE     698mmm     IFNE DEBUG
0000057E                           699mmm     ENDC
0000057E                           700mmm 
0000057E                           701mmm     ENDM
0000057E  60E4                     702mm     BRA LOOP_9
00000580                           703mm EXIT_9
00000580                           704mm     ENDM
00000580                           705m     ENDM
00000580  41FA 188B                706      LEA VERSION(PC),A0
00000584                           707m     PRINT_STR A0,D3
00000584                           708m LOOP_11
00000584  0C10 0000                709m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000588  6700 0016                710m     BEQ EXIT_11
0000058C                           711mm     PRINT_CHAR (A0)+,D3
0000058C                           712mm WAIT_FOR_READY_12                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058C                 TRUE      713mm     IFEQ DEBUG
0000058C  1639 00C00003            714mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000592  0803 0002                715mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000596  67F4                     716mm         BEQ WAIT_FOR_READY_12                       ; NO SPACE, CHECK AGAIN
00000598  13D8 00C00007            717mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000059E                           718mm     ENDC
0000059E                           719mm 
0000059E                 FALSE     720mm     IFNE DEBUG
0000059E                           721mm     ENDC
0000059E                           722mm 
0000059E                           723mm     ENDM
0000059E  60E4                     724m     BRA LOOP_11
000005A0                           725m EXIT_11
000005A0                           726m     ENDM
000005A0                           727  
000005A0  41F9 00001E2B            728      LEA END,A0
000005A6  2008                     729      MOVE.L A0,D0
000005A8                           730m     PRINT_REG D0,D1,D2,D3,A0
000005A8  41FA 17A9                731m     LEA OX(PC),A0
000005AC                           732mm     PRINT_STR A0,D1
000005AC                           733mm LOOP_14
000005AC  0C10 0000                734mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005B0  6700 0016                735mm     BEQ EXIT_14
000005B4                           736mmm     PRINT_CHAR (A0)+,D1
000005B4                           737mmm WAIT_FOR_READY_15                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005B4                 TRUE      738mmm     IFEQ DEBUG
000005B4  1239 00C00003            739mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000005BA  0801 0002                740mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000005BE  67F4                     741mmm         BEQ WAIT_FOR_READY_15                       ; NO SPACE, CHECK AGAIN
000005C0  13D8 00C00007            742mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005C6                           743mmm     ENDC
000005C6                           744mmm 
000005C6                 FALSE     745mmm     IFNE DEBUG
000005C6                           746mmm     ENDC
000005C6                           747mmm 
000005C6                           748mmm     ENDM
000005C6  60E4                     749mm     BRA LOOP_14
000005C8                           750mm EXIT_14
000005C8                           751mm     ENDM
000005C8  7607                     752m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000005CA                           753m LOOP_13
000005CA                           754mm     BIN2HEX D0,D2,A0
000005CA  41FA 1703                755mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005CE  E998                     756mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000005D0  1400                     757mm     MOVE.B D0,D2
000005D2  0282 0000000F            758mm     ANDI.L #$F,D2
000005D8  1430 2000                759mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000005DC                           760mm     ENDM
000005DC                           761mm     PRINT_CHAR D2,D1
000005DC                           762mm WAIT_FOR_READY_17                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005DC                 TRUE      763mm     IFEQ DEBUG
000005DC  1239 00C00003            764mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000005E2  0801 0002                765mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000005E6  67F4                     766mm         BEQ WAIT_FOR_READY_17                       ; NO SPACE, CHECK AGAIN
000005E8  13C2 00C00007            767mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005EE                           768mm     ENDC
000005EE                           769mm 
000005EE                 FALSE     770mm     IFNE DEBUG
000005EE                           771mm     ENDC
000005EE                           772mm 
000005EE                           773mm     ENDM
000005EE  57CB FFDA                774m     DBEQ D3,LOOP_13
000005F2                           775m     ENDM
000005F2                           776m     PRINT_CRLF D1,A0
000005F2  41FA 1759                777m     LEA CRLF(PC),A0
000005F6                           778mm     PRINT_STR A0,D1
000005F6                           779mm LOOP_19
000005F6  0C10 0000                780mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005FA  6700 0016                781mm     BEQ EXIT_19
000005FE                           782mmm     PRINT_CHAR (A0)+,D1
000005FE                           783mmm WAIT_FOR_READY_20                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005FE                 TRUE      784mmm     IFEQ DEBUG
000005FE  1239 00C00003            785mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000604  0801 0002                786mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000608  67F4                     787mmm         BEQ WAIT_FOR_READY_20                       ; NO SPACE, CHECK AGAIN
0000060A  13D8 00C00007            788mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000610                           789mmm     ENDC
00000610                           790mmm 
00000610                 FALSE     791mmm     IFNE DEBUG
00000610                           792mmm     ENDC
00000610                           793mmm 
00000610                           794mmm     ENDM
00000610  60E4                     795mm     BRA LOOP_19
00000612                           796mm EXIT_19
00000612                           797mm     ENDM
00000612                           798m     ENDM
00000612                           799  
00000612  41FA 14E6                800      LEA HELPPROMPT(PC),A0
00000616                           801m     PRINT_STR A0,D3
00000616                           802m LOOP_21
00000616  0C10 0000                803m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000061A  6700 0016                804m     BEQ EXIT_21
0000061E                           805mm     PRINT_CHAR (A0)+,D3
0000061E                           806mm WAIT_FOR_READY_22                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000061E                 TRUE      807mm     IFEQ DEBUG
0000061E  1639 00C00003            808mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000624  0803 0002                809mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000628  67F4                     810mm         BEQ WAIT_FOR_READY_22                       ; NO SPACE, CHECK AGAIN
0000062A  13D8 00C00007            811mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000630                           812mm     ENDC
00000630                           813mm 
00000630                 FALSE     814mm     IFNE DEBUG
00000630                           815mm     ENDC
00000630                           816mm 
00000630                           817mm     ENDM
00000630  60E4                     818m     BRA LOOP_21
00000632                           819m EXIT_21
00000632                           820m     ENDM
00000632                           821  
00000632                           822m     PRINT_CRLF D3,A0
00000632  41FA 1719                823m     LEA CRLF(PC),A0
00000636                           824mm     PRINT_STR A0,D3
00000636                           825mm LOOP_24
00000636  0C10 0000                826mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000063A  6700 0016                827mm     BEQ EXIT_24
0000063E                           828mmm     PRINT_CHAR (A0)+,D3
0000063E                           829mmm WAIT_FOR_READY_25                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063E                 TRUE      830mmm     IFEQ DEBUG
0000063E  1639 00C00003            831mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000644  0803 0002                832mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000648  67F4                     833mmm         BEQ WAIT_FOR_READY_25                       ; NO SPACE, CHECK AGAIN
0000064A  13D8 00C00007            834mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000650                           835mmm     ENDC
00000650                           836mmm 
00000650                 FALSE     837mmm     IFNE DEBUG
00000650                           838mmm     ENDC
00000650                           839mmm 
00000650                           840mmm     ENDM
00000650  60E4                     841mm     BRA LOOP_24
00000652                           842mm EXIT_24
00000652                           843mm     ENDM
00000652                           844m     ENDM
00000652                           845  
00000652  7E00                     846      MOVE.L #0,D7                                    ; address accumulator
00000654                           847  
00000654  13FC 0002 00E00001       848      MOVE.B #2,DISPLAY
0000065C                           849      
0000065C                           850  MAIN_LOOP
0000065C  41FA 16F2                851      LEA PROMPT(PC),A0
00000660                           852m     PRINT_STR A0,D3
00000660                           853m LOOP_26
00000660  0C10 0000                854m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000664  6700 0016                855m     BEQ EXIT_26
00000668                           856mm     PRINT_CHAR (A0)+,D3
00000668                           857mm WAIT_FOR_READY_27                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000668                 TRUE      858mm     IFEQ DEBUG
00000668  1639 00C00003            859mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000066E  0803 0002                860mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000672  67F4                     861mm         BEQ WAIT_FOR_READY_27                       ; NO SPACE, CHECK AGAIN
00000674  13D8 00C00007            862mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000067A                           863mm     ENDC
0000067A                           864mm 
0000067A                 FALSE     865mm     IFNE DEBUG
0000067A                           866mm     ENDC
0000067A                           867mm 
0000067A                           868mm     ENDM
0000067A  60E4                     869m     BRA LOOP_26
0000067C                           870m EXIT_26
0000067C                           871m     ENDM
0000067C                           872  
0000067C                           873  GET_INPUT
0000067C                           874m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000067C                           875m WAIT_FOR_READY_28                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000067C                 TRUE      876m     IFEQ DEBUG
0000067C  1639 00C00003            877m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000682  0803 0000                878m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000686  67F4                     879m         BEQ WAIT_FOR_READY_28                       ; NOTHING, CHECK AGAIN
00000688                           880m     ENDC
00000688                           881m 
00000688                           882mm     READ_CHAR D2
00000688                 TRUE      883mm     IFEQ DEBUG
00000688  1439 00C00007            884mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000068E                           885mm     ENDC
0000068E                 FALSE     886mm     IFNE DEBUG
0000068E                           887mm     ENDC
0000068E                           888mm 
0000068E  B43C 001B                889mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000692  6700 FD6C                890mm     BEQ START
00000696                           891mm     ENDM
00000696                           892m 
00000696                 TRUE      893m     IFEQ DEBUG
00000696                           894mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000696                           895mm WAIT_FOR_READY_30                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000696                 TRUE      896mm     IFEQ DEBUG
00000696  1639 00C00003            897mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000069C  0803 0002                898mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000006A0  67F4                     899mm         BEQ WAIT_FOR_READY_30                       ; NO SPACE, CHECK AGAIN
000006A2  13C2 00C00007            900mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006A8                           901mm     ENDC
000006A8                           902mm 
000006A8                 FALSE     903mm     IFNE DEBUG
000006A8                           904mm     ENDC
000006A8                           905mm 
000006A8                           906mm     ENDM
000006A8                           907m     ENDC
000006A8                           908m     ENDM
000006A8                           909  
000006A8                           910      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
000006A8  B43C 0030                911s     CMP.B   #'0',D2
000006AC  6D00 000E                912s     BLT _00000002
000006B0  B43C 0039                913s     CMP.B   #'9',D2
000006B4  6E00 0006                914s     BGT _00000002
000006B8  6000 1230                915          BRA HEX_DIGIT
000006BC                           916      ENDI
000006BC                           917s _00000002
000006BC                           918      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000006BC  B43C 0041                919s     CMP.B   #'A',D2
000006C0  6D00 000E                920s     BLT _00000003
000006C4  B43C 0046                921s     CMP.B   #'F',D2
000006C8  6E00 0006                922s     BGT _00000003
000006CC  6000 121C                923          BRA HEX_DIGIT
000006D0                           924      ENDI
000006D0                           925s _00000003
000006D0                           926  
000006D0  B43C 0077                927      CMP.B #'w',D2
000006D4  6700 01B2                928      BEQ W
000006D8                           929  
000006D8  B43C 006C                930      CMP.B #'l',D2
000006DC  6700 0A48                931      BEQ L 
000006E0                           932  
000006E0  B43C 0070                933      CMP.B #'p',D2
000006E4  6700 0E4A                934      BEQ P
000006E8                           935  
000006E8  B43C 006D                936      CMP.B #'m',D2
000006EC  6700 1012                937      BEQ M
000006F0                           938  
000006F0                           939m     PRINT_CRLF D3,A0
000006F0  41FA 165B                940m     LEA CRLF(PC),A0
000006F4                           941mm     PRINT_STR A0,D3
000006F4                           942mm LOOP_32
000006F4  0C10 0000                943mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000006F8  6700 0016                944mm     BEQ EXIT_32
000006FC                           945mmm     PRINT_CHAR (A0)+,D3
000006FC                           946mmm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006FC                 TRUE      947mmm     IFEQ DEBUG
000006FC  1639 00C00003            948mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000702  0803 0002                949mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000706  67F4                     950mmm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
00000708  13D8 00C00007            951mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000070E                           952mmm     ENDC
0000070E                           953mmm 
0000070E                 FALSE     954mmm     IFNE DEBUG
0000070E                           955mmm     ENDC
0000070E                           956mmm 
0000070E                           957mmm     ENDM
0000070E  60E4                     958mm     BRA LOOP_32
00000710                           959mm EXIT_32
00000710                           960mm     ENDM
00000710                           961m     ENDM
00000710                           962   
00000710  B43C 003F                963      CMP.B #'?',D2
00000714  6700 006E                964      BEQ H
00000718                           965   
00000718  B43C 0076                966      CMP.B #'v',D2
0000071C  6700 006E                967      BEQ V
00000720                           968      
00000720  B43C 0072                969      CMP.B #'r',D2
00000724  6700 008A                970      BEQ R
00000728                           971  
00000728  B43C 0073                972      CMP.B #'s',D2
0000072C  6700 01D6                973      BEQ S
00000730                           974  
00000730  B43C 0067                975      CMP.B #'g',D2
00000734  6700 08FA                976      BEQ G   
00000738                           977  
00000738  B43C 007A                978      CMP.B #'z',D2
0000073C  6700 08F8                979      BEQ Z   
00000740                           980  
00000740  B43C 0078                981      CMP.B #'x',D2
00000744  6700 1052                982      BEQ X
00000748                           983  
00000748  B43C 0069                984      CMP.B #'i',D2
0000074C  6700 1166                985      BEQ I
00000750                           986  
00000750  B43C 006F                987      CMP.B #'o',D2
00000754  6700 116E                988      BEQ O
00000758                           989  
00000758  B43C 0023                990      CMP.B #'#',D2
0000075C  6700 1176                991      BEQ HASH
00000760                           992  
00000760  41FA 150B                993      LEA HUH(PC),A0
00000764                           994m     PRINT_STR A0,D3
00000764                           995m LOOP_34
00000764  0C10 0000                996m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000768  6700 0016                997m     BEQ EXIT_34
0000076C                           998mm     PRINT_CHAR (A0)+,D3
0000076C                           999mm WAIT_FOR_READY_35                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000076C                 TRUE     1000mm     IFEQ DEBUG
0000076C  1639 00C00003           1001mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000772  0803 0002               1002mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000776  67F4                    1003mm         BEQ WAIT_FOR_READY_35                       ; NO SPACE, CHECK AGAIN
00000778  13D8 00C00007           1004mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000077E                          1005mm     ENDC
0000077E                          1006mm 
0000077E                 FALSE    1007mm     IFNE DEBUG
0000077E                          1008mm     ENDC
0000077E                          1009mm 
0000077E                          1010mm     ENDM
0000077E  60E4                    1011m     BRA LOOP_34
00000780                          1012m EXIT_34
00000780                          1013m     ENDM
00000780                          1014  
00000780  6000 FEDA               1015      BRA MAIN_LOOP
00000784                          1016  
00000784                          1017  ; commands
00000784                          1018  H
00000784  41FA 1387               1019      LEA HELP(PC),A0
00000788  6000 0006               1020      BRA PRINTSTR
0000078C                          1021  
0000078C                          1022  V
0000078C  41FA 167F               1023      LEA VERSION(PC),A0
00000790                          1024  PRINTSTR
00000790                          1025m     PRINT_STR A0,D3    
00000790                          1026m LOOP_36
00000790  0C10 0000               1027m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000794  6700 0016               1028m     BEQ EXIT_36
00000798                          1029mm     PRINT_CHAR (A0)+,D3
00000798                          1030mm WAIT_FOR_READY_37                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000798                 TRUE     1031mm     IFEQ DEBUG
00000798  1639 00C00003           1032mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000079E  0803 0002               1033mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007A2  67F4                    1034mm         BEQ WAIT_FOR_READY_37                       ; NO SPACE, CHECK AGAIN
000007A4  13D8 00C00007           1035mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007AA                          1036mm     ENDC
000007AA                          1037mm 
000007AA                 FALSE    1038mm     IFNE DEBUG
000007AA                          1039mm     ENDC
000007AA                          1040mm 
000007AA                          1041mm     ENDM
000007AA  60E4                    1042m     BRA LOOP_36
000007AC                          1043m EXIT_36
000007AC                          1044m     ENDM
000007AC  6000 FEAE               1045      BRA MAIN_LOOP
000007B0                          1046  
000007B0                          1047  R
000007B0  2047                    1048      MOVE.L D7,A0                                    ; address accumulator -> address register
000007B2  7E00                    1049      MOVE.L #0,D7                                    ;clear the now used address accumulator
000007B4  2410                    1050      MOVE.L (A0),D2                                  ; read the memory and print it
000007B6                          1051m     PRINT_REG D2,D3,D4,D5,A0
000007B6  41FA 159B               1052m     LEA OX(PC),A0
000007BA                          1053mm     PRINT_STR A0,D3
000007BA                          1054mm LOOP_39
000007BA  0C10 0000               1055mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000007BE  6700 0016               1056mm     BEQ EXIT_39
000007C2                          1057mmm     PRINT_CHAR (A0)+,D3
000007C2                          1058mmm WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C2                 TRUE     1059mmm     IFEQ DEBUG
000007C2  1639 00C00003           1060mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007C8  0803 0002               1061mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007CC  67F4                    1062mmm         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000007CE  13D8 00C00007           1063mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007D4                          1064mmm     ENDC
000007D4                          1065mmm 
000007D4                 FALSE    1066mmm     IFNE DEBUG
000007D4                          1067mmm     ENDC
000007D4                          1068mmm 
000007D4                          1069mmm     ENDM
000007D4  60E4                    1070mm     BRA LOOP_39
000007D6                          1071mm EXIT_39
000007D6                          1072mm     ENDM
000007D6  7A07                    1073m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000007D8                          1074m LOOP_38
000007D8                          1075mm     BIN2HEX D2,D4,A0
000007D8  41FA 14F5               1076mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000007DC  E99A                    1077mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000007DE  1802                    1078mm     MOVE.B D2,D4
000007E0  0284 0000000F           1079mm     ANDI.L #$F,D4
000007E6  1830 4000               1080mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000007EA                          1081mm     ENDM
000007EA                          1082mm     PRINT_CHAR D4,D3
000007EA                          1083mm WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007EA                 TRUE     1084mm     IFEQ DEBUG
000007EA  1639 00C00003           1085mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007F0  0803 0002               1086mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007F4  67F4                    1087mm         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000007F6  13C4 00C00007           1088mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007FC                          1089mm     ENDC
000007FC                          1090mm 
000007FC                 FALSE    1091mm     IFNE DEBUG
000007FC                          1092mm     ENDC
000007FC                          1093mm 
000007FC                          1094mm     ENDM
000007FC  57CD FFDA               1095m     DBEQ D5,LOOP_38
00000800                          1096m     ENDM
00000800                          1097      
00000800                          1098m     PRINT_CHAR #32,D3
00000800                          1099m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000800                 TRUE     1100m     IFEQ DEBUG
00000800  1639 00C00003           1101m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000806  0803 0002               1102m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000080A  67F4                    1103m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000080C  13FC 0020 00C00007      1104m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000814                          1105m     ENDC
00000814                          1106m 
00000814                 FALSE    1107m     IFNE DEBUG
00000814                          1108m     ENDC
00000814                          1109m 
00000814                          1110m     ENDM
00000814                          1111  
00000814  E19A                    1112      ROL.L #8,D2
00000816                          1113m     PRINT_CHAR D2,D3
00000816                          1114m WAIT_FOR_READY_44                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000816                 TRUE     1115m     IFEQ DEBUG
00000816  1639 00C00003           1116m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000081C  0803 0002               1117m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000820  67F4                    1118m         BEQ WAIT_FOR_READY_44                       ; NO SPACE, CHECK AGAIN
00000822  13C2 00C00007           1119m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000828                          1120m     ENDC
00000828                          1121m 
00000828                 FALSE    1122m     IFNE DEBUG
00000828                          1123m     ENDC
00000828                          1124m 
00000828                          1125m     ENDM
00000828  E19A                    1126      ROL.L #8,D2
0000082A                          1127m     PRINT_CHAR D2,D3
0000082A                          1128m WAIT_FOR_READY_45                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000082A                 TRUE     1129m     IFEQ DEBUG
0000082A  1639 00C00003           1130m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000830  0803 0002               1131m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000834  67F4                    1132m         BEQ WAIT_FOR_READY_45                       ; NO SPACE, CHECK AGAIN
00000836  13C2 00C00007           1133m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000083C                          1134m     ENDC
0000083C                          1135m 
0000083C                 FALSE    1136m     IFNE DEBUG
0000083C                          1137m     ENDC
0000083C                          1138m 
0000083C                          1139m     ENDM
0000083C  E19A                    1140      ROL.L #8,D2
0000083E                          1141m     PRINT_CHAR D2,D3
0000083E                          1142m WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000083E                 TRUE     1143m     IFEQ DEBUG
0000083E  1639 00C00003           1144m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000844  0803 0002               1145m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000848  67F4                    1146m         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
0000084A  13C2 00C00007           1147m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000850                          1148m     ENDC
00000850                          1149m 
00000850                 FALSE    1150m     IFNE DEBUG
00000850                          1151m     ENDC
00000850                          1152m 
00000850                          1153m     ENDM
00000850  E19A                    1154      ROL.L #8,D2
00000852                          1155m     PRINT_CHAR D2,D3
00000852                          1156m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000852                 TRUE     1157m     IFEQ DEBUG
00000852  1639 00C00003           1158m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000858  0803 0002               1159m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000085C  67F4                    1160m         BEQ WAIT_FOR_READY_47                       ; NO SPACE, CHECK AGAIN
0000085E  13C2 00C00007           1161m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000864                          1162m     ENDC
00000864                          1163m 
00000864                 FALSE    1164m     IFNE DEBUG
00000864                          1165m     ENDC
00000864                          1166m 
00000864                          1167m     ENDM
00000864                          1168  
00000864                          1169m     PRINT_CRLF D3,A0
00000864  41FA 14E7               1170m     LEA CRLF(PC),A0
00000868                          1171mm     PRINT_STR A0,D3
00000868                          1172mm LOOP_49
00000868  0C10 0000               1173mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000086C  6700 0016               1174mm     BEQ EXIT_49
00000870                          1175mmm     PRINT_CHAR (A0)+,D3
00000870                          1176mmm WAIT_FOR_READY_50                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000870                 TRUE     1177mmm     IFEQ DEBUG
00000870  1639 00C00003           1178mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000876  0803 0002               1179mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000087A  67F4                    1180mmm         BEQ WAIT_FOR_READY_50                       ; NO SPACE, CHECK AGAIN
0000087C  13D8 00C00007           1181mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000882                          1182mmm     ENDC
00000882                          1183mmm 
00000882                 FALSE    1184mmm     IFNE DEBUG
00000882                          1185mmm     ENDC
00000882                          1186mmm 
00000882                          1187mmm     ENDM
00000882  60E4                    1188mm     BRA LOOP_49
00000884                          1189mm EXIT_49
00000884                          1190mm     ENDM
00000884                          1191m     ENDM
00000884                          1192      
00000884  6000 FDD6               1193      BRA MAIN_LOOP
00000888                          1194  
00000888                          1195  W
00000888                          1196      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000888  3C3C 0000               1197s     MOVE.W  #0,D6
0000088C  6000 0046               1198s     BRA _20000005
00000890                          1199s _20000004
00000890  E98D                    1200          LSL.L #4,D5                                     ; make what we have so far more significant
00000892                          1201m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000892                          1202m WAIT_FOR_READY_51                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000892                 TRUE     1203m     IFEQ DEBUG
00000892  1639 00C00003           1204m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000898  0803 0000               1205m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000089C  67F4                    1206m         BEQ WAIT_FOR_READY_51                       ; NOTHING, CHECK AGAIN
0000089E                          1207m     ENDC
0000089E                          1208m 
0000089E                          1209mm     READ_CHAR D2
0000089E                 TRUE     1210mm     IFEQ DEBUG
0000089E  1439 00C00007           1211mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000008A4                          1212mm     ENDC
000008A4                 FALSE    1213mm     IFNE DEBUG
000008A4                          1214mm     ENDC
000008A4                          1215mm 
000008A4  B43C 001B               1216mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000008A8  6700 FB56               1217mm     BEQ START
000008AC                          1218mm     ENDM
000008AC                          1219m 
000008AC                 TRUE     1220m     IFEQ DEBUG
000008AC                          1221mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000008AC                          1222mm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008AC                 TRUE     1223mm     IFEQ DEBUG
000008AC  1639 00C00003           1224mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000008B2  0803 0002               1225mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000008B6  67F4                    1226mm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000008B8  13C2 00C00007           1227mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008BE                          1228mm     ENDC
000008BE                          1229mm 
000008BE                 FALSE    1230mm     IFNE DEBUG
000008BE                          1231mm     ENDC
000008BE                          1232mm 
000008BE                          1233mm     ENDM
000008BE                          1234m     ENDC
000008BE                          1235m     ENDM
000008BE                          1236m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000008BE  41FA 141F               1237m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000008C2  0402 0030               1238m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008C6  C4BC 000000FF           1239m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000008CC  1430 2000               1240m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000008D0                          1241m     ENDM
000008D0  8A02                    1242          OR.B D2,D5
000008D2                          1243      ENDF
000008D2  5246                    1244s     ADD.W   #1,D6
000008D4                          1245s _20000005
000008D4  BC7C 0007               1246s     CMP.W   #7,D6
000008D8  6FB6                    1247s     BLE _20000004
000008DA                          1248  
000008DA                          1249m     PRINT_CRLF D3,A0
000008DA  41FA 1471               1250m     LEA CRLF(PC),A0
000008DE                          1251mm     PRINT_STR A0,D3
000008DE                          1252mm LOOP_56
000008DE  0C10 0000               1253mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000008E2  6700 0016               1254mm     BEQ EXIT_56
000008E6                          1255mmm     PRINT_CHAR (A0)+,D3
000008E6                          1256mmm WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008E6                 TRUE     1257mmm     IFEQ DEBUG
000008E6  1639 00C00003           1258mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000008EC  0803 0002               1259mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000008F0  67F4                    1260mmm         BEQ WAIT_FOR_READY_57                       ; NO SPACE, CHECK AGAIN
000008F2  13D8 00C00007           1261mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008F8                          1262mmm     ENDC
000008F8                          1263mmm 
000008F8                 FALSE    1264mmm     IFNE DEBUG
000008F8                          1265mmm     ENDC
000008F8                          1266mmm 
000008F8                          1267mmm     ENDM
000008F8  60E4                    1268mm     BRA LOOP_56
000008FA                          1269mm EXIT_56
000008FA                          1270mm     ENDM
000008FA                          1271m     ENDM
000008FA                          1272  
000008FA  2047                    1273      MOVE.L D7,A0                                    ; address accumulator -> address register
000008FC  7E00                    1274      MOVE.L #0,D7                                    ; clear the now used address accumulator
000008FE                          1275  
000008FE  2085                    1276      MOVE.L D5,(A0)                                  ; write the data
00000900                          1277  
00000900  6000 FD5A               1278      BRA MAIN_LOOP
00000904                          1279  
00000904                          1280  ; register map for S
00000904                          1281  ; A0 - start address
00000904                          1282  ; A1 - offset
00000904                          1283  ; A2 - next address to write
00000904                          1284  ; A3 - next location (jmp)
00000904                          1285  ; A4 - Working Address Register
00000904                          1286  ; D0 - record count
00000904                          1287  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
00000904                          1288  ; D2 - checksum
00000904                          1289  ; D3 - data byte count
00000904                          1290  ; D4 - read address, moved into A2
00000904                          1291  ; D5 - temp
00000904                          1292  ; D6 - temp
00000904                          1293  ; D7 - temp
00000904                          1294  S
00000904  2078 0000               1295      MOVE.L 0,A0                                     ; start address -> A0
00000908  2247                    1296      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
0000090A                          1297      
0000090A  7000                    1298      MOVE.L #0,D0                                    ; count of records read -> D0
0000090C                          1299          
0000090C                          1300  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
0000090C                          1301m     DOWNLOAD D1
0000090C                          1302m WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090C                          1303m 
0000090C  1239 00C00003           1304m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000912  0801 0000               1305m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000916  6700 0010               1306m     BEQ CONTINUE_58                                 ; NOTHING, CONTINUE
0000091A                          1307m 
0000091A                          1308mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000091A                 TRUE     1309mm     IFEQ DEBUG
0000091A  1239 00C00007           1310mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000920                          1311mm     ENDC
00000920                 FALSE    1312mm     IFNE DEBUG
00000920                          1313mm     ENDC
00000920                          1314mm 
00000920  B23C 001B               1315mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000924  6700 FADA               1316mm     BEQ START
00000928                          1317mm     ENDM
00000928                          1318m CONTINUE_58
00000928  1239 00C00013           1319m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000092E  0801 0000               1320m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000932  67D8                    1321m     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000934                          1322m     
00000934  1239 00C00017           1323m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000093A  13C1 00E00001           1324m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000940                          1325m 
00000940                          1326m     ENDM
00000940  B23C 0053               1327      CMP.B #'S',D1                                   ; found S?
00000944  66C6                    1328      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000946                          1329      
00000946                          1330m     PRINT_CHAR #'S',D5                              ; print the S
00000946                          1331m WAIT_FOR_READY_60                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000946                 TRUE     1332m     IFEQ DEBUG
00000946  1A39 00C00003           1333m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000094C  0805 0002               1334m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000950  67F4                    1335m         BEQ WAIT_FOR_READY_60                       ; NO SPACE, CHECK AGAIN
00000952  13FC 0053 00C00007      1336m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000095A                          1337m     ENDC
0000095A                          1338m 
0000095A                 FALSE    1339m     IFNE DEBUG
0000095A                          1340m     ENDC
0000095A                          1341m 
0000095A                          1342m     ENDM
0000095A  5280                    1343      ADD.L #1,D0                                     ; read another S record, increment count
0000095C                          1344      
0000095C                          1345m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000095C                          1346m WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                          1347m 
0000095C  1239 00C00003           1348m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000962  0801 0000               1349m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000966  6700 0010               1350m     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
0000096A                          1351m 
0000096A                          1352mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000096A                 TRUE     1353mm     IFEQ DEBUG
0000096A  1239 00C00007           1354mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000970                          1355mm     ENDC
00000970                 FALSE    1356mm     IFNE DEBUG
00000970                          1357mm     ENDC
00000970                          1358mm 
00000970  B23C 001B               1359mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
00000974  6700 FA8A               1360mm     BEQ START
00000978                          1361mm     ENDM
00000978                          1362m CONTINUE_61
00000978  1239 00C00013           1363m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000097E  0801 0000               1364m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000982  67D8                    1365m     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000984                          1366m     
00000984  1239 00C00017           1367m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
0000098A  13C1 00E00001           1368m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000990                          1369m 
00000990                          1370m     ENDM
00000990                          1371m     PRINT_CHAR D1,D5
00000990                          1372m WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000990                 TRUE     1373m     IFEQ DEBUG
00000990  1A39 00C00003           1374m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000996  0805 0002               1375m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
0000099A  67F4                    1376m         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
0000099C  13C1 00C00007           1377m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009A2                          1378m     ENDC
000009A2                          1379m 
000009A2                 FALSE    1380m     IFNE DEBUG
000009A2                          1381m     ENDC
000009A2                          1382m 
000009A2                          1383m     ENDM
000009A2                          1384  
000009A2  7400                    1385      MOVE.L #0,D2                                    ; clear the checksum
000009A4                          1386  
000009A4                          1387m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
000009A4  1E3C 0002               1388m     MOVE.B #2,D7
000009A8                          1389m     WHILE.B D7 <GT> 0 DO
000009A8                          1390ms _10000000
000009A8  BE38 0000               1391ms     CMP.B   0,D7
000009AC  6F00 0062               1392ms     BLE _10000001
000009B0  E98B                    1393m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
000009B2                          1394mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009B2                          1395mm WAIT_FOR_READY_65                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B2                          1396mm 
000009B2  1A39 00C00003           1397mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009B8  0805 0000               1398mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009BC  6700 0010               1399mm     BEQ CONTINUE_65                                 ; NOTHING, CONTINUE
000009C0                          1400mm 
000009C0                          1401mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009C0                 TRUE     1402mmm     IFEQ DEBUG
000009C0  1A39 00C00007           1403mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009C6                          1404mmm     ENDC
000009C6                 FALSE    1405mmm     IFNE DEBUG
000009C6                          1406mmm     ENDC
000009C6                          1407mmm 
000009C6  BA3C 001B               1408mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009CA  6700 FA34               1409mmm     BEQ START
000009CE                          1410mmm     ENDM
000009CE                          1411mm CONTINUE_65
000009CE  1A39 00C00013           1412mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009D4  0805 0000               1413mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009D8  67D8                    1414mm     BEQ WAIT_FOR_READY_65                           ; NOTHING, CHECK AGAIN
000009DA                          1415mm     
000009DA  1A39 00C00017           1416mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009E0  13C5 00E00001           1417mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009E6                          1418mm 
000009E6                          1419mm     ENDM
000009E6                          1420mm         PRINT_CHAR D5,D6
000009E6                          1421mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009E6                 TRUE     1422mm     IFEQ DEBUG
000009E6  1C39 00C00003           1423mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009EC  0806 0002               1424mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009F0  67F4                    1425mm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000009F2  13C5 00C00007           1426mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009F8                          1427mm     ENDC
000009F8                          1428mm 
000009F8                 FALSE    1429mm     IFNE DEBUG
000009F8                          1430mm     ENDC
000009F8                          1431mm 
000009F8                          1432mm     ENDM
000009F8                          1433mm         HEX2BIN D5,D5,A4
000009F8  49FA 12E5               1434mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009FC  0405 0030               1435mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A00  CABC 000000FF           1436mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A06  1A34 5000               1437mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A0A                          1438mm     ENDM
00000A0A  8605                    1439m         OR.B D5,D3
00000A0C  5307                    1440m         SUB.B #1,D7
00000A0E                          1441m     ENDW
00000A0E  6098                    1442ms     BRA _10000000
00000A10                          1443ms _10000001
00000A10                          1444m 
00000A10  7A00                    1445m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A12  1A03                    1446m     MOVE.B D3,D5
00000A14  D483                    1447m     ADD.L D3,D2
00000A16                          1448m 
00000A16                          1449m     ENDM
00000A16                          1450  
00000A16                          1451      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
00000A16  B23C 0030               1452s     CMP.B   #'0',D1
00000A1A  6600 002A               1453s     BNE.L   _00000004
00000A1E                          1454m         PRINT_CRLF D5,A4
00000A1E  49FA 132D               1455m     LEA CRLF(PC),A4
00000A22                          1456mm     PRINT_STR A4,D5
00000A22                          1457mm LOOP_70
00000A22  0C14 0000               1458mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A26  6700 0016               1459mm     BEQ EXIT_70
00000A2A                          1460mmm     PRINT_CHAR (A4)+,D5
00000A2A                          1461mmm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2A                 TRUE     1462mmm     IFEQ DEBUG
00000A2A  1A39 00C00003           1463mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A30  0805 0002               1464mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A34  67F4                    1465mmm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
00000A36  13DC 00C00007           1466mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A3C                          1467mmm     ENDC
00000A3C                          1468mmm 
00000A3C                 FALSE    1469mmm     IFNE DEBUG
00000A3C                          1470mmm     ENDC
00000A3C                          1471mmm 
00000A3C                          1472mmm     ENDM
00000A3C  60E4                    1473mm     BRA LOOP_70
00000A3E                          1474mm EXIT_70
00000A3E                          1475mm     ENDM
00000A3E                          1476m     ENDM
00000A3E  6000 FECC               1477          BRA WAIT_FOR_SRECORD
00000A42                          1478      ELSE
00000A42  6000 03DE               1479s     BRA _00000005
00000A46                          1480s _00000004
00000A46                          1481          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
00000A46  B23C 0031               1482s     CMP.B   #'1',D1
00000A4A  6708                    1483s     BEQ.S   _00000006
00000A4C  B23C 0032               1484s     CMP.B   #'2',D1
00000A50  6600 01F0               1485s     BNE.L   _00000007
00000A54                          1486s _00000006
00000A54  5783                    1487              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
00000A56                          1488  
00000A56  7800                    1489              MOVE.L #0,D4                            ; read two bytes of address
00000A58                          1490m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000A58  1E3C 0002               1491m     MOVE.B #2,D7
00000A5C                          1492m     WHILE.B D7 <GT> 0 DO
00000A5C                          1493ms _10000002
00000A5C  BE38 0000               1494ms     CMP.B   0,D7
00000A60  6F00 0062               1495ms     BLE _10000003
00000A64  E98C                    1496m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A66                          1497mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A66                          1498mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A66                          1499mm 
00000A66  1A39 00C00003           1500mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A6C  0805 0000               1501mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A70  6700 0010               1502mm     BEQ CONTINUE_73                                 ; NOTHING, CONTINUE
00000A74                          1503mm 
00000A74                          1504mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A74                 TRUE     1505mmm     IFEQ DEBUG
00000A74  1A39 00C00007           1506mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A7A                          1507mmm     ENDC
00000A7A                 FALSE    1508mmm     IFNE DEBUG
00000A7A                          1509mmm     ENDC
00000A7A                          1510mmm 
00000A7A  BA3C 001B               1511mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A7E  6700 F980               1512mmm     BEQ START
00000A82                          1513mmm     ENDM
00000A82                          1514mm CONTINUE_73
00000A82  1A39 00C00013           1515mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A88  0805 0000               1516mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A8C  67D8                    1517mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
00000A8E                          1518mm     
00000A8E  1A39 00C00017           1519mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A94  13C5 00E00001           1520mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A9A                          1521mm 
00000A9A                          1522mm     ENDM
00000A9A                          1523mm         PRINT_CHAR D5,D6
00000A9A                          1524mm WAIT_FOR_READY_75                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9A                 TRUE     1525mm     IFEQ DEBUG
00000A9A  1C39 00C00003           1526mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000AA0  0806 0002               1527mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000AA4  67F4                    1528mm         BEQ WAIT_FOR_READY_75                       ; NO SPACE, CHECK AGAIN
00000AA6  13C5 00C00007           1529mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AAC                          1530mm     ENDC
00000AAC                          1531mm 
00000AAC                 FALSE    1532mm     IFNE DEBUG
00000AAC                          1533mm     ENDC
00000AAC                          1534mm 
00000AAC                          1535mm     ENDM
00000AAC                          1536mm         HEX2BIN D5,D5,A4
00000AAC  49FA 1231               1537mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000AB0  0405 0030               1538mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000AB4  CABC 000000FF           1539mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000ABA  1A34 5000               1540mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000ABE                          1541mm     ENDM
00000ABE  8805                    1542m         OR.B D5,D4
00000AC0  5307                    1543m         SUB.B #1,D7
00000AC2                          1544m     ENDW
00000AC2  6098                    1545ms     BRA _10000002
00000AC4                          1546ms _10000003
00000AC4                          1547m 
00000AC4  7A00                    1548m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AC6  1A04                    1549m     MOVE.B D4,D5
00000AC8  D484                    1550m     ADD.L D4,D2
00000ACA                          1551m 
00000ACA                          1552m     ENDM
00000ACA                          1553m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000ACA  1E3C 0002               1554m     MOVE.B #2,D7
00000ACE                          1555m     WHILE.B D7 <GT> 0 DO
00000ACE                          1556ms _10000004
00000ACE  BE38 0000               1557ms     CMP.B   0,D7
00000AD2  6F00 0062               1558ms     BLE _10000005
00000AD6  E98C                    1559m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000AD8                          1560mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000AD8                          1561mm WAIT_FOR_READY_78                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AD8                          1562mm 
00000AD8  1A39 00C00003           1563mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000ADE  0805 0000               1564mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AE2  6700 0010               1565mm     BEQ CONTINUE_78                                 ; NOTHING, CONTINUE
00000AE6                          1566mm 
00000AE6                          1567mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AE6                 TRUE     1568mmm     IFEQ DEBUG
00000AE6  1A39 00C00007           1569mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000AEC                          1570mmm     ENDC
00000AEC                 FALSE    1571mmm     IFNE DEBUG
00000AEC                          1572mmm     ENDC
00000AEC                          1573mmm 
00000AEC  BA3C 001B               1574mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000AF0  6700 F90E               1575mmm     BEQ START
00000AF4                          1576mmm     ENDM
00000AF4                          1577mm CONTINUE_78
00000AF4  1A39 00C00013           1578mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000AFA  0805 0000               1579mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AFE  67D8                    1580mm     BEQ WAIT_FOR_READY_78                           ; NOTHING, CHECK AGAIN
00000B00                          1581mm     
00000B00  1A39 00C00017           1582mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B06  13C5 00E00001           1583mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B0C                          1584mm 
00000B0C                          1585mm     ENDM
00000B0C                          1586mm         PRINT_CHAR D5,D6
00000B0C                          1587mm WAIT_FOR_READY_80                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0C                 TRUE     1588mm     IFEQ DEBUG
00000B0C  1C39 00C00003           1589mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B12  0806 0002               1590mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B16  67F4                    1591mm         BEQ WAIT_FOR_READY_80                       ; NO SPACE, CHECK AGAIN
00000B18  13C5 00C00007           1592mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B1E                          1593mm     ENDC
00000B1E                          1594mm 
00000B1E                 FALSE    1595mm     IFNE DEBUG
00000B1E                          1596mm     ENDC
00000B1E                          1597mm 
00000B1E                          1598mm     ENDM
00000B1E                          1599mm         HEX2BIN D5,D5,A4
00000B1E  49FA 11BF               1600mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B22  0405 0030               1601mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B26  CABC 000000FF           1602mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B2C  1A34 5000               1603mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B30                          1604mm     ENDM
00000B30  8805                    1605m         OR.B D5,D4
00000B32  5307                    1606m         SUB.B #1,D7
00000B34                          1607m     ENDW
00000B34  6098                    1608ms     BRA _10000004
00000B36                          1609ms _10000005
00000B36                          1610m 
00000B36  7A00                    1611m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B38  1A04                    1612m     MOVE.B D4,D5
00000B3A  D484                    1613m     ADD.L D4,D2
00000B3C                          1614m 
00000B3C                          1615m     ENDM
00000B3C                          1616  
00000B3C                          1617              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000B3C  B23C 0032               1618s     CMP.B   #'2',D1
00000B40  6600 0076               1619s     BNE.L   _00000008
00000B44  5383                    1620                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000B46                          1621m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000B46  1E3C 0002               1622m     MOVE.B #2,D7
00000B4A                          1623m     WHILE.B D7 <GT> 0 DO
00000B4A                          1624ms _10000006
00000B4A  BE38 0000               1625ms     CMP.B   0,D7
00000B4E  6F00 0062               1626ms     BLE _10000007
00000B52  E98C                    1627m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B54                          1628mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B54                          1629mm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B54                          1630mm 
00000B54  1A39 00C00003           1631mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B5A  0805 0000               1632mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B5E  6700 0010               1633mm     BEQ CONTINUE_83                                 ; NOTHING, CONTINUE
00000B62                          1634mm 
00000B62                          1635mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B62                 TRUE     1636mmm     IFEQ DEBUG
00000B62  1A39 00C00007           1637mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B68                          1638mmm     ENDC
00000B68                 FALSE    1639mmm     IFNE DEBUG
00000B68                          1640mmm     ENDC
00000B68                          1641mmm 
00000B68  BA3C 001B               1642mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B6C  6700 F892               1643mmm     BEQ START
00000B70                          1644mmm     ENDM
00000B70                          1645mm CONTINUE_83
00000B70  1A39 00C00013           1646mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B76  0805 0000               1647mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B7A  67D8                    1648mm     BEQ WAIT_FOR_READY_83                           ; NOTHING, CHECK AGAIN
00000B7C                          1649mm     
00000B7C  1A39 00C00017           1650mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B82  13C5 00E00001           1651mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B88                          1652mm 
00000B88                          1653mm     ENDM
00000B88                          1654mm         PRINT_CHAR D5,D6
00000B88                          1655mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B88                 TRUE     1656mm     IFEQ DEBUG
00000B88  1C39 00C00003           1657mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B8E  0806 0002               1658mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B92  67F4                    1659mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000B94  13C5 00C00007           1660mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B9A                          1661mm     ENDC
00000B9A                          1662mm 
00000B9A                 FALSE    1663mm     IFNE DEBUG
00000B9A                          1664mm     ENDC
00000B9A                          1665mm 
00000B9A                          1666mm     ENDM
00000B9A                          1667mm         HEX2BIN D5,D5,A4
00000B9A  49FA 1143               1668mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B9E  0405 0030               1669mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000BA2  CABC 000000FF           1670mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000BA8  1A34 5000               1671mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BAC                          1672mm     ENDM
00000BAC  8805                    1673m         OR.B D5,D4
00000BAE  5307                    1674m         SUB.B #1,D7
00000BB0                          1675m     ENDW
00000BB0  6098                    1676ms     BRA _10000006
00000BB2                          1677ms _10000007
00000BB2                          1678m 
00000BB2  7A00                    1679m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000BB4  1A04                    1680m     MOVE.B D4,D5
00000BB6  D484                    1681m     ADD.L D4,D2
00000BB8                          1682m 
00000BB8                          1683m     ENDM
00000BB8                          1684              ENDI
00000BB8                          1685s _00000008
00000BB8                          1686  
00000BB8  2444                    1687              MOVE.L D4,A2                            ; put the address in an address register
00000BBA  D5C9                    1688              ADD.L A1,A2                             ; add in the offset
00000BBC                          1689  
00000BBC                          1690              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000BBC                          1691s _10000008
00000BBC  B63C 0000               1692s     CMP.B   #0,D3
00000BC0  6F00 007A               1693s     BLE _10000009
00000BC4                          1694m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000BC4  1E3C 0002               1695m     MOVE.B #2,D7
00000BC8                          1696m     WHILE.B D7 <GT> 0 DO
00000BC8                          1697ms _1000000A
00000BC8  BE38 0000               1698ms     CMP.B   0,D7
00000BCC  6F00 0062               1699ms     BLE _1000000B
00000BD0  E989                    1700m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000BD2                          1701mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000BD2                          1702mm WAIT_FOR_READY_88                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD2                          1703mm 
00000BD2  1A39 00C00003           1704mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000BD8  0805 0000               1705mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BDC  6700 0010               1706mm     BEQ CONTINUE_88                                 ; NOTHING, CONTINUE
00000BE0                          1707mm 
00000BE0                          1708mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000BE0                 TRUE     1709mmm     IFEQ DEBUG
00000BE0  1A39 00C00007           1710mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000BE6                          1711mmm     ENDC
00000BE6                 FALSE    1712mmm     IFNE DEBUG
00000BE6                          1713mmm     ENDC
00000BE6                          1714mmm 
00000BE6  BA3C 001B               1715mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000BEA  6700 F814               1716mmm     BEQ START
00000BEE                          1717mmm     ENDM
00000BEE                          1718mm CONTINUE_88
00000BEE  1A39 00C00013           1719mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000BF4  0805 0000               1720mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BF8  67D8                    1721mm     BEQ WAIT_FOR_READY_88                           ; NOTHING, CHECK AGAIN
00000BFA                          1722mm     
00000BFA  1A39 00C00017           1723mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C00  13C5 00E00001           1724mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C06                          1725mm 
00000C06                          1726mm     ENDM
00000C06                          1727mm         PRINT_CHAR D5,D6
00000C06                          1728mm WAIT_FOR_READY_90                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C06                 TRUE     1729mm     IFEQ DEBUG
00000C06  1C39 00C00003           1730mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C0C  0806 0002               1731mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C10  67F4                    1732mm         BEQ WAIT_FOR_READY_90                       ; NO SPACE, CHECK AGAIN
00000C12  13C5 00C00007           1733mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C18                          1734mm     ENDC
00000C18                          1735mm 
00000C18                 FALSE    1736mm     IFNE DEBUG
00000C18                          1737mm     ENDC
00000C18                          1738mm 
00000C18                          1739mm     ENDM
00000C18                          1740mm         HEX2BIN D5,D5,A4
00000C18  49FA 10C5               1741mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000C1C  0405 0030               1742mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C20  CABC 000000FF           1743mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000C26  1A34 5000               1744mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C2A                          1745mm     ENDM
00000C2A  8205                    1746m         OR.B D5,D1
00000C2C  5307                    1747m         SUB.B #1,D7
00000C2E                          1748m     ENDW
00000C2E  6098                    1749ms     BRA _1000000A
00000C30                          1750ms _1000000B
00000C30                          1751m 
00000C30  7A00                    1752m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000C32  1A01                    1753m     MOVE.B D1,D5
00000C34  D481                    1754m     ADD.L D1,D2
00000C36                          1755m 
00000C36                          1756m     ENDM
00000C36                          1757   
00000C36  14C1                    1758                  MOVE.B D1,(A2)+                     ; store it!
00000C38                          1759  
00000C38  5303                    1760                  SUB.B #1,D3                         ; 1 less byte to go
00000C3A                          1761              ENDW
00000C3A  6080                    1762s     BRA _10000008
00000C3C                          1763s _10000009
00000C3C                          1764  
00000C3C  7200                    1765              MOVE.L #0,D1                            ; not done yet
00000C3E                          1766          ELSE
00000C3E  6000 01E2               1767s     BRA _00000009
00000C42                          1768s _00000007
00000C42                          1769              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000C42  B23C 0038               1770s     CMP.B   #'8',D1
00000C46  6600 0164               1771s     BNE.L   _0000000A
00000C4A  7800                    1772                  MOVE.L #0,D4                        ; read the 24 bit start address
00000C4C                          1773m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000C4C  1E3C 0002               1774m     MOVE.B #2,D7
00000C50                          1775m     WHILE.B D7 <GT> 0 DO
00000C50                          1776ms _1000000C
00000C50  BE38 0000               1777ms     CMP.B   0,D7
00000C54  6F00 0062               1778ms     BLE _1000000D
00000C58  E98C                    1779m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000C5A                          1780mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000C5A                          1781mm WAIT_FOR_READY_93                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C5A                          1782mm 
00000C5A  1A39 00C00003           1783mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000C60  0805 0000               1784mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C64  6700 0010               1785mm     BEQ CONTINUE_93                                 ; NOTHING, CONTINUE
00000C68                          1786mm 
00000C68                          1787mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000C68                 TRUE     1788mmm     IFEQ DEBUG
00000C68  1A39 00C00007           1789mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000C6E                          1790mmm     ENDC
00000C6E                 FALSE    1791mmm     IFNE DEBUG
00000C6E                          1792mmm     ENDC
00000C6E                          1793mmm 
00000C6E  BA3C 001B               1794mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000C72  6700 F78C               1795mmm     BEQ START
00000C76                          1796mmm     ENDM
00000C76                          1797mm CONTINUE_93
00000C76  1A39 00C00013           1798mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000C7C  0805 0000               1799mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C80  67D8                    1800mm     BEQ WAIT_FOR_READY_93                           ; NOTHING, CHECK AGAIN
00000C82                          1801mm     
00000C82  1A39 00C00017           1802mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C88  13C5 00E00001           1803mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C8E                          1804mm 
00000C8E                          1805mm     ENDM
00000C8E                          1806mm         PRINT_CHAR D5,D6
00000C8E                          1807mm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C8E                 TRUE     1808mm     IFEQ DEBUG
00000C8E  1C39 00C00003           1809mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C94  0806 0002               1810mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C98  67F4                    1811mm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
00000C9A  13C5 00C00007           1812mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CA0                          1813mm     ENDC
00000CA0                          1814mm 
00000CA0                 FALSE    1815mm     IFNE DEBUG
00000CA0                          1816mm     ENDC
00000CA0                          1817mm 
00000CA0                          1818mm     ENDM
00000CA0                          1819mm         HEX2BIN D5,D5,A4
00000CA0  49FA 103D               1820mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000CA4  0405 0030               1821mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000CA8  CABC 000000FF           1822mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000CAE  1A34 5000               1823mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000CB2                          1824mm     ENDM
00000CB2  8805                    1825m         OR.B D5,D4
00000CB4  5307                    1826m         SUB.B #1,D7
00000CB6                          1827m     ENDW
00000CB6  6098                    1828ms     BRA _1000000C
00000CB8                          1829ms _1000000D
00000CB8                          1830m 
00000CB8  7A00                    1831m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000CBA  1A04                    1832m     MOVE.B D4,D5
00000CBC  D484                    1833m     ADD.L D4,D2
00000CBE                          1834m 
00000CBE                          1835m     ENDM
00000CBE                          1836m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000CBE  1E3C 0002               1837m     MOVE.B #2,D7
00000CC2                          1838m     WHILE.B D7 <GT> 0 DO
00000CC2                          1839ms _1000000E
00000CC2  BE38 0000               1840ms     CMP.B   0,D7
00000CC6  6F00 0062               1841ms     BLE _1000000F
00000CCA  E98C                    1842m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000CCC                          1843mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000CCC                          1844mm WAIT_FOR_READY_98                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CCC                          1845mm 
00000CCC  1A39 00C00003           1846mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000CD2  0805 0000               1847mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CD6  6700 0010               1848mm     BEQ CONTINUE_98                                 ; NOTHING, CONTINUE
00000CDA                          1849mm 
00000CDA                          1850mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000CDA                 TRUE     1851mmm     IFEQ DEBUG
00000CDA  1A39 00C00007           1852mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000CE0                          1853mmm     ENDC
00000CE0                 FALSE    1854mmm     IFNE DEBUG
00000CE0                          1855mmm     ENDC
00000CE0                          1856mmm 
00000CE0  BA3C 001B               1857mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000CE4  6700 F71A               1858mmm     BEQ START
00000CE8                          1859mmm     ENDM
00000CE8                          1860mm CONTINUE_98
00000CE8  1A39 00C00013           1861mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000CEE  0805 0000               1862mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CF2  67D8                    1863mm     BEQ WAIT_FOR_READY_98                           ; NOTHING, CHECK AGAIN
00000CF4                          1864mm     
00000CF4  1A39 00C00017           1865mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000CFA  13C5 00E00001           1866mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000D00                          1867mm 
00000D00                          1868mm     ENDM
00000D00                          1869mm         PRINT_CHAR D5,D6
00000D00                          1870mm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D00                 TRUE     1871mm     IFEQ DEBUG
00000D00  1C39 00C00003           1872mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000D06  0806 0002               1873mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000D0A  67F4                    1874mm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
00000D0C  13C5 00C00007           1875mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D12                          1876mm     ENDC
00000D12                          1877mm 
00000D12                 FALSE    1878mm     IFNE DEBUG
00000D12                          1879mm     ENDC
00000D12                          1880mm 
00000D12                          1881mm     ENDM
00000D12                          1882mm         HEX2BIN D5,D5,A4
00000D12  49FA 0FCB               1883mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000D16  0405 0030               1884mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D1A  CABC 000000FF           1885mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D20  1A34 5000               1886mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D24                          1887mm     ENDM
00000D24  8805                    1888m         OR.B D5,D4
00000D26  5307                    1889m         SUB.B #1,D7
00000D28                          1890m     ENDW
00000D28  6098                    1891ms     BRA _1000000E
00000D2A                          1892ms _1000000F
00000D2A                          1893m 
00000D2A  7A00                    1894m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D2C  1A04                    1895m     MOVE.B D4,D5
00000D2E  D484                    1896m     ADD.L D4,D2
00000D30                          1897m 
00000D30                          1898m     ENDM
00000D30                          1899m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000D30  1E3C 0002               1900m     MOVE.B #2,D7
00000D34                          1901m     WHILE.B D7 <GT> 0 DO
00000D34                          1902ms _10000010
00000D34  BE38 0000               1903ms     CMP.B   0,D7
00000D38  6F00 0062               1904ms     BLE _10000011
00000D3C  E98C                    1905m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000D3E                          1906mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000D3E                          1907mm WAIT_FOR_READY_103                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D3E                          1908mm 
00000D3E  1A39 00C00003           1909mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000D44  0805 0000               1910mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000D48  6700 0010               1911mm     BEQ CONTINUE_103                                    ; NOTHING, CONTINUE
00000D4C                          1912mm 
00000D4C                          1913mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000D4C                 TRUE     1914mmm     IFEQ DEBUG
00000D4C  1A39 00C00007           1915mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000D52                          1916mmm     ENDC
00000D52                 FALSE    1917mmm     IFNE DEBUG
00000D52                          1918mmm     ENDC
00000D52                          1919mmm 
00000D52  BA3C 001B               1920mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000D56  6700 F6A8               1921mmm     BEQ START
00000D5A                          1922mmm     ENDM
00000D5A                          1923mm CONTINUE_103
00000D5A  1A39 00C00013           1924mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000D60  0805 0000               1925mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000D64  67D8                    1926mm     BEQ WAIT_FOR_READY_103                          ; NOTHING, CHECK AGAIN
00000D66                          1927mm     
00000D66  1A39 00C00017           1928mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000D6C  13C5 00E00001           1929mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000D72                          1930mm 
00000D72                          1931mm     ENDM
00000D72                          1932mm         PRINT_CHAR D5,D6
00000D72                          1933mm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D72                 TRUE     1934mm     IFEQ DEBUG
00000D72  1C39 00C00003           1935mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000D78  0806 0002               1936mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000D7C  67F4                    1937mm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000D7E  13C5 00C00007           1938mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D84                          1939mm     ENDC
00000D84                          1940mm 
00000D84                 FALSE    1941mm     IFNE DEBUG
00000D84                          1942mm     ENDC
00000D84                          1943mm 
00000D84                          1944mm     ENDM
00000D84                          1945mm         HEX2BIN D5,D5,A4
00000D84  49FA 0F59               1946mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000D88  0405 0030               1947mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D8C  CABC 000000FF           1948mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D92  1A34 5000               1949mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D96                          1950mm     ENDM
00000D96  8805                    1951m         OR.B D5,D4
00000D98  5307                    1952m         SUB.B #1,D7
00000D9A                          1953m     ENDW
00000D9A  6098                    1954ms     BRA _10000010
00000D9C                          1955ms _10000011
00000D9C                          1956m 
00000D9C  7A00                    1957m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D9E  1A04                    1958m     MOVE.B D4,D5
00000DA0  D484                    1959m     ADD.L D4,D2
00000DA2                          1960m 
00000DA2                          1961m     ENDM
00000DA2                          1962  
00000DA2  2044                    1963                  MOVE.L D4,A0                        ; start address -> A0
00000DA4  D1C9                    1964                  ADD.L A1,A0                         ; add in the offset
00000DA6                          1965  
00000DA6  72FF                    1966                  MOVE.L #$FFFFFFFF,D1                ; done
00000DA8                          1967              ELSE
00000DA8  6000 0078               1968s     BRA _0000000B
00000DAC                          1969s _0000000A
00000DAC                          1970m                 PRINT_CRLF D5,A4
00000DAC  49FA 0F9F               1971m     LEA CRLF(PC),A4
00000DB0                          1972mm     PRINT_STR A4,D5
00000DB0                          1973mm LOOP_108
00000DB0  0C14 0000               1974mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000DB4  6700 0016               1975mm     BEQ EXIT_108
00000DB8                          1976mmm     PRINT_CHAR (A4)+,D5
00000DB8                          1977mmm WAIT_FOR_READY_109                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB8                 TRUE     1978mmm     IFEQ DEBUG
00000DB8  1A39 00C00003           1979mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DBE  0805 0002               1980mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DC2  67F4                    1981mmm         BEQ WAIT_FOR_READY_109                      ; NO SPACE, CHECK AGAIN
00000DC4  13DC 00C00007           1982mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DCA                          1983mmm     ENDC
00000DCA                          1984mmm 
00000DCA                 FALSE    1985mmm     IFNE DEBUG
00000DCA                          1986mmm     ENDC
00000DCA                          1987mmm 
00000DCA                          1988mmm     ENDM
00000DCA  60E4                    1989mm     BRA LOOP_108
00000DCC                          1990mm EXIT_108
00000DCC                          1991mm     ENDM
00000DCC                          1992m     ENDM
00000DCC                          1993  
00000DCC  49FA 0EC8               1994                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000DD0                          1995m                 PRINT_STR A4,D5
00000DD0                          1996m LOOP_110
00000DD0  0C14 0000               1997m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000DD4  6700 0016               1998m     BEQ EXIT_110
00000DD8                          1999mm     PRINT_CHAR (A4)+,D5
00000DD8                          2000mm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD8                 TRUE     2001mm     IFEQ DEBUG
00000DD8  1A39 00C00003           2002mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DDE  0805 0002               2003mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DE2  67F4                    2004mm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000DE4  13DC 00C00007           2005mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DEA                          2006mm     ENDC
00000DEA                          2007mm 
00000DEA                 FALSE    2008mm     IFNE DEBUG
00000DEA                          2009mm     ENDC
00000DEA                          2010mm 
00000DEA                          2011mm     ENDM
00000DEA  60E4                    2012m     BRA LOOP_110
00000DEC                          2013m EXIT_110
00000DEC                          2014m     ENDM
00000DEC                          2015m                 PRINT_CHAR D1,D5
00000DEC                          2016m WAIT_FOR_READY_112                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEC                 TRUE     2017m     IFEQ DEBUG
00000DEC  1A39 00C00003           2018m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000DF2  0805 0002               2019m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000DF6  67F4                    2020m         BEQ WAIT_FOR_READY_112                      ; NO SPACE, CHECK AGAIN
00000DF8  13C1 00C00007           2021m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DFE                          2022m     ENDC
00000DFE                          2023m 
00000DFE                 FALSE    2024m     IFNE DEBUG
00000DFE                          2025m     ENDC
00000DFE                          2026m 
00000DFE                          2027m     ENDM
00000DFE                          2028m                 PRINT_CRLF D5,A4
00000DFE  49FA 0F4D               2029m     LEA CRLF(PC),A4
00000E02                          2030mm     PRINT_STR A4,D5
00000E02                          2031mm LOOP_114
00000E02  0C14 0000               2032mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E06  6700 0016               2033mm     BEQ EXIT_114
00000E0A                          2034mmm     PRINT_CHAR (A4)+,D5
00000E0A                          2035mmm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E0A                 TRUE     2036mmm     IFEQ DEBUG
00000E0A  1A39 00C00003           2037mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E10  0805 0002               2038mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E14  67F4                    2039mmm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000E16  13DC 00C00007           2040mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E1C                          2041mmm     ENDC
00000E1C                          2042mmm 
00000E1C                 FALSE    2043mmm     IFNE DEBUG
00000E1C                          2044mmm     ENDC
00000E1C                          2045mmm 
00000E1C                          2046mmm     ENDM
00000E1C  60E4                    2047mm     BRA LOOP_114
00000E1E                          2048mm EXIT_114
00000E1E                          2049mm     ENDM
00000E1E                          2050m     ENDM
00000E1E                          2051  
00000E1E  6000 FAEC               2052                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000E22                          2053              ENDI
00000E22                          2054s _0000000B
00000E22                          2055          ENDI
00000E22                          2056s _00000009
00000E22                          2057      ENDI
00000E22                          2058s _00000005
00000E22                          2059  
00000E22                          2060m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000E22  1E3C 0002               2061m     MOVE.B #2,D7
00000E26                          2062m     WHILE.B D7 <GT> 0 DO
00000E26                          2063ms _10000012
00000E26  BE38 0000               2064ms     CMP.B   0,D7
00000E2A  6F00 0062               2065ms     BLE _10000013
00000E2E  E98C                    2066m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000E30                          2067mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000E30                          2068mm WAIT_FOR_READY_117                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E30                          2069mm 
00000E30  1A39 00C00003           2070mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000E36  0805 0000               2071mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000E3A  6700 0010               2072mm     BEQ CONTINUE_117                                    ; NOTHING, CONTINUE
00000E3E                          2073mm 
00000E3E                          2074mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000E3E                 TRUE     2075mmm     IFEQ DEBUG
00000E3E  1A39 00C00007           2076mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000E44                          2077mmm     ENDC
00000E44                 FALSE    2078mmm     IFNE DEBUG
00000E44                          2079mmm     ENDC
00000E44                          2080mmm 
00000E44  BA3C 001B               2081mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000E48  6700 F5B6               2082mmm     BEQ START
00000E4C                          2083mmm     ENDM
00000E4C                          2084mm CONTINUE_117
00000E4C  1A39 00C00013           2085mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000E52  0805 0000               2086mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000E56  67D8                    2087mm     BEQ WAIT_FOR_READY_117                          ; NOTHING, CHECK AGAIN
00000E58                          2088mm     
00000E58  1A39 00C00017           2089mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000E5E  13C5 00E00001           2090mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000E64                          2091mm 
00000E64                          2092mm     ENDM
00000E64                          2093mm         PRINT_CHAR D5,D6
00000E64                          2094mm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E64                 TRUE     2095mm     IFEQ DEBUG
00000E64  1C39 00C00003           2096mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000E6A  0806 0002               2097mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000E6E  67F4                    2098mm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000E70  13C5 00C00007           2099mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E76                          2100mm     ENDC
00000E76                          2101mm 
00000E76                 FALSE    2102mm     IFNE DEBUG
00000E76                          2103mm     ENDC
00000E76                          2104mm 
00000E76                          2105mm     ENDM
00000E76                          2106mm         HEX2BIN D5,D5,A4
00000E76  49FA 0E67               2107mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000E7A  0405 0030               2108mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E7E  CABC 000000FF           2109mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000E84  1A34 5000               2110mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E88                          2111mm     ENDM
00000E88  8805                    2112m         OR.B D5,D4
00000E8A  5307                    2113m         SUB.B #1,D7
00000E8C                          2114m     ENDW
00000E8C  6098                    2115ms     BRA _10000012
00000E8E                          2116ms _10000013
00000E8E                          2117m 
00000E8E  7A00                    2118m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000E90  1A04                    2119m     MOVE.B D4,D5
00000E92  D484                    2120m     ADD.L D4,D2
00000E94                          2121m 
00000E94                          2122m     ENDM
00000E94                          2123m     PRINT_CRLF D5,A4
00000E94  49FA 0EB7               2124m     LEA CRLF(PC),A4
00000E98                          2125mm     PRINT_STR A4,D5
00000E98                          2126mm LOOP_122
00000E98  0C14 0000               2127mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E9C  6700 0016               2128mm     BEQ EXIT_122
00000EA0                          2129mmm     PRINT_CHAR (A4)+,D5
00000EA0                          2130mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA0                 TRUE     2131mmm     IFEQ DEBUG
00000EA0  1A39 00C00003           2132mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EA6  0805 0002               2133mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EAA  67F4                    2134mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000EAC  13DC 00C00007           2135mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EB2                          2136mmm     ENDC
00000EB2                          2137mmm 
00000EB2                 FALSE    2138mmm     IFNE DEBUG
00000EB2                          2139mmm     ENDC
00000EB2                          2140mmm 
00000EB2                          2141mmm     ENDM
00000EB2  60E4                    2142mm     BRA LOOP_122
00000EB4                          2143mm EXIT_122
00000EB4                          2144mm     ENDM
00000EB4                          2145m     ENDM
00000EB4                          2146  
00000EB4                          2147      IF.B D2 <NE> #$FF THEN.L
00000EB4  B43C 00FF               2148s     CMP.B   #$FF,D2
00000EB8  6700 0090               2149s     BEQ.L   _0000000C
00000EBC  49FA 0DEF               2150          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000EC0                          2151m         PRINT_STR A4,D5
00000EC0                          2152m LOOP_124
00000EC0  0C14 0000               2153m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EC4  6700 0016               2154m     BEQ EXIT_124
00000EC8                          2155mm     PRINT_CHAR (A4)+,D5
00000EC8                          2156mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EC8                 TRUE     2157mm     IFEQ DEBUG
00000EC8  1A39 00C00003           2158mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000ECE  0805 0002               2159mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ED2  67F4                    2160mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000ED4  13DC 00C00007           2161mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EDA                          2162mm     ENDC
00000EDA                          2163mm 
00000EDA                 FALSE    2164mm     IFNE DEBUG
00000EDA                          2165mm     ENDC
00000EDA                          2166mm 
00000EDA                          2167mm     ENDM
00000EDA  60E4                    2168m     BRA LOOP_124
00000EDC                          2169m EXIT_124
00000EDC                          2170m     ENDM
00000EDC                          2171m         PRINT_REG D0,D5,D3,D6,A4
00000EDC  49FA 0E75               2172m     LEA OX(PC),A4
00000EE0                          2173mm     PRINT_STR A4,D5
00000EE0                          2174mm LOOP_127
00000EE0  0C14 0000               2175mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EE4  6700 0016               2176mm     BEQ EXIT_127
00000EE8                          2177mmm     PRINT_CHAR (A4)+,D5
00000EE8                          2178mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EE8                 TRUE     2179mmm     IFEQ DEBUG
00000EE8  1A39 00C00003           2180mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EEE  0805 0002               2181mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EF2  67F4                    2182mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000EF4  13DC 00C00007           2183mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EFA                          2184mmm     ENDC
00000EFA                          2185mmm 
00000EFA                 FALSE    2186mmm     IFNE DEBUG
00000EFA                          2187mmm     ENDC
00000EFA                          2188mmm 
00000EFA                          2189mmm     ENDM
00000EFA  60E4                    2190mm     BRA LOOP_127
00000EFC                          2191mm EXIT_127
00000EFC                          2192mm     ENDM
00000EFC  7C07                    2193m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EFE                          2194m LOOP_126
00000EFE                          2195mm     BIN2HEX D0,D3,A4
00000EFE  49FA 0DCF               2196mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000F02  E998                    2197mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F04  1600                    2198mm     MOVE.B D0,D3
00000F06  0283 0000000F           2199mm     ANDI.L #$F,D3
00000F0C  1634 3000               2200mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000F10                          2201mm     ENDM
00000F10                          2202mm     PRINT_CHAR D3,D5
00000F10                          2203mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F10                 TRUE     2204mm     IFEQ DEBUG
00000F10  1A39 00C00003           2205mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F16  0805 0002               2206mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F1A  67F4                    2207mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000F1C  13C3 00C00007           2208mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F22                          2209mm     ENDC
00000F22                          2210mm 
00000F22                 FALSE    2211mm     IFNE DEBUG
00000F22                          2212mm     ENDC
00000F22                          2213mm 
00000F22                          2214mm     ENDM
00000F22  57CE FFDA               2215m     DBEQ D6,LOOP_126
00000F26                          2216m     ENDM
00000F26                          2217m         PRINT_CRLF D5,A4
00000F26  49FA 0E25               2218m     LEA CRLF(PC),A4
00000F2A                          2219mm     PRINT_STR A4,D5
00000F2A                          2220mm LOOP_132
00000F2A  0C14 0000               2221mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000F2E  6700 0016               2222mm     BEQ EXIT_132
00000F32                          2223mmm     PRINT_CHAR (A4)+,D5
00000F32                          2224mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F32                 TRUE     2225mmm     IFEQ DEBUG
00000F32  1A39 00C00003           2226mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F38  0805 0002               2227mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F3C  67F4                    2228mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000F3E  13DC 00C00007           2229mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F44                          2230mmm     ENDC
00000F44                          2231mmm 
00000F44                 FALSE    2232mmm     IFNE DEBUG
00000F44                          2233mmm     ENDC
00000F44                          2234mmm 
00000F44                          2235mmm     ENDM
00000F44  60E4                    2236mm     BRA LOOP_132
00000F46                          2237mm EXIT_132
00000F46                          2238mm     ENDM
00000F46                          2239m     ENDM
00000F46                          2240          
00000F46  6000 F714               2241          BRA MAIN_LOOP
00000F4A                          2242      ENDI
00000F4A                          2243s _0000000C
00000F4A                          2244  
00000F4A                          2245      IF D1 <EQ> #0 THEN
00000F4A  B27C 0000               2246s     CMP.W   #0,D1
00000F4E  6600 0006               2247s     BNE _0000000D
00000F52  6000 F9B8               2248        BRA WAIT_FOR_SRECORD
00000F56                          2249      ENDI
00000F56                          2250s _0000000D
00000F56                          2251  DOWNLOAD_DONE
00000F56                          2252m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000F56  43FA 0DFB               2253m     LEA OX(PC),A1
00000F5A                          2254mm     PRINT_STR A1,D5
00000F5A                          2255mm LOOP_135
00000F5A  0C11 0000               2256mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F5E  6700 0016               2257mm     BEQ EXIT_135
00000F62                          2258mmm     PRINT_CHAR (A1)+,D5
00000F62                          2259mmm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F62                 TRUE     2260mmm     IFEQ DEBUG
00000F62  1A39 00C00003           2261mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F68  0805 0002               2262mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F6C  67F4                    2263mmm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000F6E  13D9 00C00007           2264mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F74                          2265mmm     ENDC
00000F74                          2266mmm 
00000F74                 FALSE    2267mmm     IFNE DEBUG
00000F74                          2268mmm     ENDC
00000F74                          2269mmm 
00000F74                          2270mmm     ENDM
00000F74  60E4                    2271mm     BRA LOOP_135
00000F76                          2272mm EXIT_135
00000F76                          2273mm     ENDM
00000F76  7407                    2274m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F78                          2275m LOOP_134
00000F78                          2276mm     BIN2HEX D0,D6,A1
00000F78  43FA 0D55               2277mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000F7C  E998                    2278mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F7E  1C00                    2279mm     MOVE.B D0,D6
00000F80  0286 0000000F           2280mm     ANDI.L #$F,D6
00000F86  1C31 6000               2281mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000F8A                          2282mm     ENDM
00000F8A                          2283mm     PRINT_CHAR D6,D5
00000F8A                          2284mm WAIT_FOR_READY_138                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F8A                 TRUE     2285mm     IFEQ DEBUG
00000F8A  1A39 00C00003           2286mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F90  0805 0002               2287mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F94  67F4                    2288mm         BEQ WAIT_FOR_READY_138                      ; NO SPACE, CHECK AGAIN
00000F96  13C6 00C00007           2289mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F9C                          2290mm     ENDC
00000F9C                          2291mm 
00000F9C                 FALSE    2292mm     IFNE DEBUG
00000F9C                          2293mm     ENDC
00000F9C                          2294mm 
00000F9C                          2295mm     ENDM
00000F9C  57CA FFDA               2296m     DBEQ D2,LOOP_134
00000FA0                          2297m     ENDM
00000FA0  43FA 0CD2               2298      LEA READ(PC),A1
00000FA4                          2299m     PRINT_STR A1,D5
00000FA4                          2300m LOOP_139
00000FA4  0C11 0000               2301m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FA8  6700 0016               2302m     BEQ EXIT_139
00000FAC                          2303mm     PRINT_CHAR (A1)+,D5
00000FAC                          2304mm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FAC                 TRUE     2305mm     IFEQ DEBUG
00000FAC  1A39 00C00003           2306mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FB2  0805 0002               2307mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000FB6  67F4                    2308mm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000FB8  13D9 00C00007           2309mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FBE                          2310mm     ENDC
00000FBE                          2311mm 
00000FBE                 FALSE    2312mm     IFNE DEBUG
00000FBE                          2313mm     ENDC
00000FBE                          2314mm 
00000FBE                          2315mm     ENDM
00000FBE  60E4                    2316m     BRA LOOP_139
00000FC0                          2317m EXIT_139
00000FC0                          2318m     ENDM
00000FC0  2E08                    2319      MOVE.L A0,D7                                    ; set address accumulator to start address
00000FC2                          2320m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000FC2  43FA 0D8F               2321m     LEA OX(PC),A1
00000FC6                          2322mm     PRINT_STR A1,D5
00000FC6                          2323mm LOOP_142
00000FC6  0C11 0000               2324mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FCA  6700 0016               2325mm     BEQ EXIT_142
00000FCE                          2326mmm     PRINT_CHAR (A1)+,D5
00000FCE                          2327mmm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FCE                 TRUE     2328mmm     IFEQ DEBUG
00000FCE  1A39 00C00003           2329mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FD4  0805 0002               2330mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000FD8  67F4                    2331mmm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000FDA  13D9 00C00007           2332mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FE0                          2333mmm     ENDC
00000FE0                          2334mmm 
00000FE0                 FALSE    2335mmm     IFNE DEBUG
00000FE0                          2336mmm     ENDC
00000FE0                          2337mmm 
00000FE0                          2338mmm     ENDM
00000FE0  60E4                    2339mm     BRA LOOP_142
00000FE2                          2340mm EXIT_142
00000FE2                          2341mm     ENDM
00000FE2  7407                    2342m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FE4                          2343m LOOP_141
00000FE4                          2344mm     BIN2HEX D7,D6,A1
00000FE4  43FA 0CE9               2345mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000FE8  E99F                    2346mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FEA  1C07                    2347mm     MOVE.B D7,D6
00000FEC  0286 0000000F           2348mm     ANDI.L #$F,D6
00000FF2  1C31 6000               2349mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000FF6                          2350mm     ENDM
00000FF6                          2351mm     PRINT_CHAR D6,D5
00000FF6                          2352mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FF6                 TRUE     2353mm     IFEQ DEBUG
00000FF6  1A39 00C00003           2354mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000FFC  0805 0002               2355mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001000  67F4                    2356mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00001002  13C6 00C00007           2357mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001008                          2358mm     ENDC
00001008                          2359mm 
00001008                 FALSE    2360mm     IFNE DEBUG
00001008                          2361mm     ENDC
00001008                          2362mm 
00001008                          2363mm     ENDM
00001008  57CA FFDA               2364m     DBEQ D2,LOOP_141
0000100C                          2365m     ENDM
0000100C                          2366m     PRINT_CRLF D5,A4
0000100C  49FA 0D3F               2367m     LEA CRLF(PC),A4
00001010                          2368mm     PRINT_STR A4,D5
00001010                          2369mm LOOP_147
00001010  0C14 0000               2370mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00001014  6700 0016               2371mm     BEQ EXIT_147
00001018                          2372mmm     PRINT_CHAR (A4)+,D5
00001018                          2373mmm WAIT_FOR_READY_148                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001018                 TRUE     2374mmm     IFEQ DEBUG
00001018  1A39 00C00003           2375mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000101E  0805 0002               2376mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00001022  67F4                    2377mmm         BEQ WAIT_FOR_READY_148                      ; NO SPACE, CHECK AGAIN
00001024  13DC 00C00007           2378mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000102A                          2379mmm     ENDC
0000102A                          2380mmm 
0000102A                 FALSE    2381mmm     IFNE DEBUG
0000102A                          2382mmm     ENDC
0000102A                          2383mmm 
0000102A                          2384mmm     ENDM
0000102A  60E4                    2385mm     BRA LOOP_147
0000102C                          2386mm EXIT_147
0000102C                          2387mm     ENDM
0000102C                          2388m     ENDM
0000102C                          2389  
0000102C  6000 F62E               2390      BRA MAIN_LOOP
00001030                          2391  
00001030                          2392  G
00001030  2047                    2393      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00001032  7E00                    2394      MOVE.L #0,D7
00001034                          2395  
00001034  4ED0                    2396      JMP (A0)
00001036                          2397          
00001036                          2398  Z
00001036  207C 00200000           2399      MOVE.L #RAM,A0                                  ; address of RAM
0000103C  D1FC 00100000           2400      ADD.L #$100000,A0
00001042                          2401  
00001042                          2402      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00001042  7000                    2403s     MOVE.L  #0,D0
00001044  6000 0012               2404s     BRA _20000007
00001048                          2405s _20000006
00001048  2200                    2406          MOVE.L D0,D1                                ; progress update
0000104A  E089                    2407          LSR.L #8,D1 
0000104C  E089                    2408          LSR.L #8,D1
0000104E  13C1 00E00001           2409          MOVE.B D1,DISPLAY
00001054                          2410          
00001054  2108                    2411          MOVE.L A0,-(A0)
00001056                          2412      ENDF
00001056  5880                    2413s     ADD.L   #4,D0
00001058                          2414s _20000007
00001058  B0BC 000FFFFC           2415s     CMP.L   #$FFFFC,D0
0000105E  6FE8                    2416s     BLE _20000006
00001060                          2417  
00001060  207C 00200000           2418      MOVE.L #RAM,A0                                  ; address of RAM
00001066  D1FC 00100000           2419      ADD.L #$100000,A0
0000106C                          2420  
0000106C                          2421      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
0000106C  7000                    2422s     MOVE.L  #0,D0
0000106E  6000 00A8               2423s     BRA _20000009
00001072                          2424s _20000008
00001072  2200                    2425          MOVE.L D0,D1                                ; progress update
00001074  E089                    2426          LSR.L #8,D1
00001076  E089                    2427          LSR.L #8,D1
00001078  13C1 00E00001           2428          MOVE.B D1,DISPLAY
0000107E                          2429  
0000107E  2408                    2430          MOVE.L A0,D2
00001080  2220                    2431          MOVE.L -(A0),D1
00001082                          2432  
00001082                          2433          IF.L D2 <NE> D1 THEN
00001082  B481                    2434s     CMP.L   D1,D2
00001084  6700 0090               2435s     BEQ _0000000E
00001088  43FA 0C34               2436              LEA RAM_ERROR(PC),A1
0000108C                          2437m             PRINT_STR A1,D1
0000108C                          2438m LOOP_149
0000108C  0C11 0000               2439m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001090  6700 0016               2440m     BEQ EXIT_149
00001094                          2441mm     PRINT_CHAR (A1)+,D1
00001094                          2442mm WAIT_FOR_READY_150                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001094                 TRUE     2443mm     IFEQ DEBUG
00001094  1239 00C00003           2444mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000109A  0801 0002               2445mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000109E  67F4                    2446mm         BEQ WAIT_FOR_READY_150                      ; NO SPACE, CHECK AGAIN
000010A0  13D9 00C00007           2447mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010A6                          2448mm     ENDC
000010A6                          2449mm 
000010A6                 FALSE    2450mm     IFNE DEBUG
000010A6                          2451mm     ENDC
000010A6                          2452mm 
000010A6                          2453mm     ENDM
000010A6  60E4                    2454m     BRA LOOP_149
000010A8                          2455m EXIT_149
000010A8                          2456m     ENDM
000010A8  2208                    2457              MOVE.L A0,D1
000010AA  5981                    2458              SUB.L #4,D1
000010AC                          2459m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
000010AC  43FA 0CA5               2460m     LEA OX(PC),A1
000010B0                          2461mm     PRINT_STR A1,D3
000010B0                          2462mm LOOP_152
000010B0  0C11 0000               2463mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010B4  6700 0016               2464mm     BEQ EXIT_152
000010B8                          2465mmm     PRINT_CHAR (A1)+,D3
000010B8                          2466mmm WAIT_FOR_READY_153                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010B8                 TRUE     2467mmm     IFEQ DEBUG
000010B8  1639 00C00003           2468mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010BE  0803 0002               2469mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010C2  67F4                    2470mmm         BEQ WAIT_FOR_READY_153                      ; NO SPACE, CHECK AGAIN
000010C4  13D9 00C00007           2471mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010CA                          2472mmm     ENDC
000010CA                          2473mmm 
000010CA                 FALSE    2474mmm     IFNE DEBUG
000010CA                          2475mmm     ENDC
000010CA                          2476mmm 
000010CA                          2477mmm     ENDM
000010CA  60E4                    2478mm     BRA LOOP_152
000010CC                          2479mm EXIT_152
000010CC                          2480mm     ENDM
000010CC  7C07                    2481m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010CE                          2482m LOOP_151
000010CE                          2483mm     BIN2HEX D1,D2,A1
000010CE  43FA 0BFF               2484mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
000010D2  E999                    2485mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010D4  1401                    2486mm     MOVE.B D1,D2
000010D6  0282 0000000F           2487mm     ANDI.L #$F,D2
000010DC  1431 2000               2488mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
000010E0                          2489mm     ENDM
000010E0                          2490mm     PRINT_CHAR D2,D3
000010E0                          2491mm WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010E0                 TRUE     2492mm     IFEQ DEBUG
000010E0  1639 00C00003           2493mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010E6  0803 0002               2494mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010EA  67F4                    2495mm         BEQ WAIT_FOR_READY_155                      ; NO SPACE, CHECK AGAIN
000010EC  13C2 00C00007           2496mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010F2                          2497mm     ENDC
000010F2                          2498mm 
000010F2                 FALSE    2499mm     IFNE DEBUG
000010F2                          2500mm     ENDC
000010F2                          2501mm 
000010F2                          2502mm     ENDM
000010F2  57CE FFDA               2503m     DBEQ D6,LOOP_151
000010F6                          2504m     ENDM
000010F6                          2505m             PRINT_CRLF D3,A1
000010F6  43FA 0C55               2506m     LEA CRLF(PC),A1
000010FA                          2507mm     PRINT_STR A1,D3
000010FA                          2508mm LOOP_157
000010FA  0C11 0000               2509mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
000010FE  6700 0016               2510mm     BEQ EXIT_157
00001102                          2511mmm     PRINT_CHAR (A1)+,D3
00001102                          2512mmm WAIT_FOR_READY_158                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001102                 TRUE     2513mmm     IFEQ DEBUG
00001102  1639 00C00003           2514mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001108  0803 0002               2515mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000110C  67F4                    2516mmm         BEQ WAIT_FOR_READY_158                      ; NO SPACE, CHECK AGAIN
0000110E  13D9 00C00007           2517mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001114                          2518mmm     ENDC
00001114                          2519mmm 
00001114                 FALSE    2520mmm     IFNE DEBUG
00001114                          2521mmm     ENDC
00001114                          2522mmm 
00001114                          2523mmm     ENDM
00001114  60E4                    2524mm     BRA LOOP_157
00001116                          2525mm EXIT_157
00001116                          2526mm     ENDM
00001116                          2527m     ENDM
00001116                          2528          ENDI 
00001116                          2529s _0000000E
00001116                          2530      ENDF
00001116  5880                    2531s     ADD.L   #4,D0
00001118                          2532s _20000009
00001118  B0BC 000FFFFC           2533s     CMP.L   #$FFFFC,D0
0000111E  6F00 FF52               2534s     BLE _20000008
00001122                          2535  
00001122  6000 F538               2536      BRA MAIN_LOOP
00001126                          2537  
00001126                          2538  L
00001126  7000                    2539      MOVE.L #0,D0                                    ; D0 will be the length to write               
00001128  7200                    2540      MOVE.L #0,D1                                    ; D1 will be the address to write 
0000112A                          2541  
0000112A                          2542      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
0000112A  343C 0000               2543s     MOVE.W  #0,D2
0000112E  6000 0046               2544s     BRA _2000000B
00001132                          2545s _2000000A
00001132  E989                    2546          LSL.L #4,D1                                 ; make what we have so far more significant
00001134                          2547m         WAIT_CHAR D3,D4                             ; next character -> D2
00001134                          2548m WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001134                 TRUE     2549m     IFEQ DEBUG
00001134  1839 00C00003           2550m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000113A  0804 0000               2551m         BTST #0,D4                                  ; CHECK FOR CHARACTER
0000113E  67F4                    2552m         BEQ WAIT_FOR_READY_159                      ; NOTHING, CHECK AGAIN
00001140                          2553m     ENDC
00001140                          2554m 
00001140                          2555mm     READ_CHAR D3
00001140                 TRUE     2556mm     IFEQ DEBUG
00001140  1639 00C00007           2557mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001146                          2558mm     ENDC
00001146                 FALSE    2559mm     IFNE DEBUG
00001146                          2560mm     ENDC
00001146                          2561mm 
00001146  B63C 001B               2562mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
0000114A  6700 F2B4               2563mm     BEQ START
0000114E                          2564mm     ENDM
0000114E                          2565m 
0000114E                 TRUE     2566m     IFEQ DEBUG
0000114E                          2567mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
0000114E                          2568mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000114E                 TRUE     2569mm     IFEQ DEBUG
0000114E  1839 00C00003           2570mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001154  0804 0002               2571mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001158  67F4                    2572mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
0000115A  13C3 00C00007           2573mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001160                          2574mm     ENDC
00001160                          2575mm 
00001160                 FALSE    2576mm     IFNE DEBUG
00001160                          2577mm     ENDC
00001160                          2578mm 
00001160                          2579mm     ENDM
00001160                          2580m     ENDC
00001160                          2581m     ENDM
00001160                          2582m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00001160  41FA 0B7D               2583m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001164  0403 0030               2584m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001168  C6BC 000000FF           2585m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
0000116E  1630 3000               2586m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00001172                          2587m     ENDM
00001172  8203                    2588          OR.B D3,D1
00001174                          2589      ENDF
00001174  5242                    2590s     ADD.W   #1,D2
00001176                          2591s _2000000B
00001176  B47C 0007               2592s     CMP.W   #7,D2
0000117A  6FB6                    2593s     BLE _2000000A
0000117C                          2594  
0000117C  3001                    2595      MOVE.W D1,D0                                    ; extract the LSword for the length
0000117E  E089                    2596      LSR.L #8,D1                                     ; extract the MSword for the address
00001180  E089                    2597      LSR.L #8,D1
00001182                          2598  
00001182                          2599m     PRINT_CRLF D2,A1
00001182  43FA 0BC9               2600m     LEA CRLF(PC),A1
00001186                          2601mm     PRINT_STR A1,D2
00001186                          2602mm LOOP_164
00001186  0C11 0000               2603mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000118A  6700 0016               2604mm     BEQ EXIT_164
0000118E                          2605mmm     PRINT_CHAR (A1)+,D2
0000118E                          2606mmm WAIT_FOR_READY_165                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000118E                 TRUE     2607mmm     IFEQ DEBUG
0000118E  1439 00C00003           2608mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001194  0802 0002               2609mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001198  67F4                    2610mmm         BEQ WAIT_FOR_READY_165                      ; NO SPACE, CHECK AGAIN
0000119A  13D9 00C00007           2611mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011A0                          2612mmm     ENDC
000011A0                          2613mmm 
000011A0                 FALSE    2614mmm     IFNE DEBUG
000011A0                          2615mmm     ENDC
000011A0                          2616mmm 
000011A0                          2617mmm     ENDM
000011A0  60E4                    2618mm     BRA LOOP_164
000011A2                          2619mm EXIT_164
000011A2                          2620mm     ENDM
000011A2                          2621m     ENDM
000011A2                          2622  
000011A2  2041                    2623      MOVE.L D1,A0                                    ; target address
000011A4  2641                    2624      MOVE.L D1,A3                                    ; keep a copy for later
000011A6                          2625  
000011A6  2247                    2626      MOVE.L D7,A1                                    ; address accumulator -> address register
000011A8  D3FC 00000400           2627      ADD.L #START,A1                                 ; skip the vectors
000011AE  2847                    2628      MOVE.L D7,A4                                    ; keep a clean copy for later
000011B0  7E00                    2629      MOVE.L #0,D7                                    ; clear the now used address accumulator
000011B2                          2630  
000011B2                          2631m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000011B2  31FC AAAA 2AAA          2632m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000011B8  4E71                    2633m     NOP
000011BA  31FC 5555 1554          2634m     MOVE.W #$5555,$1554
000011C0  4E71                    2635m     NOP
000011C2  31FC 8080 2AAA          2636m     MOVE.W #$8080,$2AAA
000011C8  4E71                    2637m     NOP
000011CA  31FC AAAA 2AAA          2638m     MOVE.W #$AAAA,$2AAA
000011D0  4E71                    2639m     NOP
000011D2  31FC 5555 1554          2640m     MOVE.W #$5555,$1554
000011D8  4E71                    2641m     NOP
000011DA  31FC 2020 2AAA          2642m     MOVE.W #$2020,$2AAA
000011E0                          2643m     ENDM
000011E0                          2644                              
000011E0                          2645      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000011E0  3E3C 0000               2646s     MOVE.W  #$0,D7
000011E4  6000 0006               2647s     BRA _2000000D
000011E8                          2648s _2000000C
000011E8  4E71                    2649          NOP
000011EA                          2650      ENDF
000011EA  5247                    2651s     ADD.W   #1,D7
000011EC                          2652s _2000000D
000011EC  BE7C FFFF               2653s     CMP.W   #$FFFFFFFF,D7
000011F0  6FF6                    2654s     BLE _2000000C
000011F2                          2655  
000011F2  45FA 0B02               2656      LEA LOADING(PC),A2
000011F6                          2657m     PRINT_STR A2,D2
000011F6                          2658m LOOP_167
000011F6  0C12 0000               2659m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011FA  6700 0016               2660m     BEQ EXIT_167
000011FE                          2661mm     PRINT_CHAR (A2)+,D2
000011FE                          2662mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011FE                 TRUE     2663mm     IFEQ DEBUG
000011FE  1439 00C00003           2664mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001204  0802 0002               2665mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001208  67F4                    2666mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
0000120A  13DA 00C00007           2667mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001210                          2668mm     ENDC
00001210                          2669mm 
00001210                 FALSE    2670mm     IFNE DEBUG
00001210                          2671mm     ENDC
00001210                          2672mm 
00001210                          2673mm     ENDM
00001210  60E4                    2674m     BRA LOOP_167
00001212                          2675m EXIT_167
00001212                          2676m     ENDM
00001212                          2677      
00001212                          2678  
00001212  45FA 0AF6               2679      LEA CODE(PC),A2
00001216                          2680m     PRINT_STR A2,D2
00001216                          2681m LOOP_169
00001216  0C12 0000               2682m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000121A  6700 0016               2683m     BEQ EXIT_169
0000121E                          2684mm     PRINT_CHAR (A2)+,D2
0000121E                          2685mm WAIT_FOR_READY_170                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000121E                 TRUE     2686mm     IFEQ DEBUG
0000121E  1439 00C00003           2687mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001224  0802 0002               2688mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001228  67F4                    2689mm         BEQ WAIT_FOR_READY_170                      ; NO SPACE, CHECK AGAIN
0000122A  13DA 00C00007           2690mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001230                          2691mm     ENDC
00001230                          2692mm 
00001230                 FALSE    2693mm     IFNE DEBUG
00001230                          2694mm     ENDC
00001230                          2695mm 
00001230                          2696mm     ENDM
00001230  60E4                    2697m     BRA LOOP_169
00001232                          2698m EXIT_169
00001232                          2699m     ENDM
00001232                          2700      
00001232  2409                    2701      MOVE.L A1,D2
00001234                          2702m     PRINT_REG D2,D3,D4,D5,A2
00001234  45FA 0B1D               2703m     LEA OX(PC),A2
00001238                          2704mm     PRINT_STR A2,D3
00001238                          2705mm LOOP_172
00001238  0C12 0000               2706mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000123C  6700 0016               2707mm     BEQ EXIT_172
00001240                          2708mmm     PRINT_CHAR (A2)+,D3
00001240                          2709mmm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001240                 TRUE     2710mmm     IFEQ DEBUG
00001240  1639 00C00003           2711mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001246  0803 0002               2712mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000124A  67F4                    2713mmm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
0000124C  13DA 00C00007           2714mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001252                          2715mmm     ENDC
00001252                          2716mmm 
00001252                 FALSE    2717mmm     IFNE DEBUG
00001252                          2718mmm     ENDC
00001252                          2719mmm 
00001252                          2720mmm     ENDM
00001252  60E4                    2721mm     BRA LOOP_172
00001254                          2722mm EXIT_172
00001254                          2723mm     ENDM
00001254  7A07                    2724m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001256                          2725m LOOP_171
00001256                          2726mm     BIN2HEX D2,D4,A2
00001256  45FA 0A77               2727mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000125A  E99A                    2728mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000125C  1802                    2729mm     MOVE.B D2,D4
0000125E  0284 0000000F           2730mm     ANDI.L #$F,D4
00001264  1832 4000               2731mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001268                          2732mm     ENDM
00001268                          2733mm     PRINT_CHAR D4,D3
00001268                          2734mm WAIT_FOR_READY_175                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001268                 TRUE     2735mm     IFEQ DEBUG
00001268  1639 00C00003           2736mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000126E  0803 0002               2737mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001272  67F4                    2738mm         BEQ WAIT_FOR_READY_175                      ; NO SPACE, CHECK AGAIN
00001274  13C4 00C00007           2739mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000127A                          2740mm     ENDC
0000127A                          2741mm 
0000127A                 FALSE    2742mm     IFNE DEBUG
0000127A                          2743mm     ENDC
0000127A                          2744mm 
0000127A                          2745mm     ENDM
0000127A  57CD FFDA               2746m     DBEQ D5,LOOP_171
0000127E                          2747m     ENDM
0000127E                          2748  
0000127E  45FA 0AD6               2749      LEA TO(PC),A2
00001282                          2750m     PRINT_STR A2,D3
00001282                          2751m LOOP_176
00001282  0C12 0000               2752m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001286  6700 0016               2753m     BEQ EXIT_176
0000128A                          2754mm     PRINT_CHAR (A2)+,D3
0000128A                          2755mm WAIT_FOR_READY_177                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000128A                 TRUE     2756mm     IFEQ DEBUG
0000128A  1639 00C00003           2757mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001290  0803 0002               2758mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001294  67F4                    2759mm         BEQ WAIT_FOR_READY_177                      ; NO SPACE, CHECK AGAIN
00001296  13DA 00C00007           2760mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000129C                          2761mm     ENDC
0000129C                          2762mm 
0000129C                 FALSE    2763mm     IFNE DEBUG
0000129C                          2764mm     ENDC
0000129C                          2765mm 
0000129C                          2766mm     ENDM
0000129C  60E4                    2767m     BRA LOOP_176
0000129E                          2768m EXIT_176
0000129E                          2769m     ENDM
0000129E                          2770  
0000129E  2408                    2771      MOVE.L A0,D2
000012A0                          2772m     PRINT_REG D2,D3,D4,D5,A2
000012A0  45FA 0AB1               2773m     LEA OX(PC),A2
000012A4                          2774mm     PRINT_STR A2,D3
000012A4                          2775mm LOOP_179
000012A4  0C12 0000               2776mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012A8  6700 0016               2777mm     BEQ EXIT_179
000012AC                          2778mmm     PRINT_CHAR (A2)+,D3
000012AC                          2779mmm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012AC                 TRUE     2780mmm     IFEQ DEBUG
000012AC  1639 00C00003           2781mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012B2  0803 0002               2782mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012B6  67F4                    2783mmm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
000012B8  13DA 00C00007           2784mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012BE                          2785mmm     ENDC
000012BE                          2786mmm 
000012BE                 FALSE    2787mmm     IFNE DEBUG
000012BE                          2788mmm     ENDC
000012BE                          2789mmm 
000012BE                          2790mmm     ENDM
000012BE  60E4                    2791mm     BRA LOOP_179
000012C0                          2792mm EXIT_179
000012C0                          2793mm     ENDM
000012C0  7A07                    2794m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012C2                          2795m LOOP_178
000012C2                          2796mm     BIN2HEX D2,D4,A2
000012C2  45FA 0A0B               2797mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012C6  E99A                    2798mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012C8  1802                    2799mm     MOVE.B D2,D4
000012CA  0284 0000000F           2800mm     ANDI.L #$F,D4
000012D0  1832 4000               2801mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000012D4                          2802mm     ENDM
000012D4                          2803mm     PRINT_CHAR D4,D3
000012D4                          2804mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012D4                 TRUE     2805mm     IFEQ DEBUG
000012D4  1639 00C00003           2806mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012DA  0803 0002               2807mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012DE  67F4                    2808mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
000012E0  13C4 00C00007           2809mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012E6                          2810mm     ENDC
000012E6                          2811mm 
000012E6                 FALSE    2812mm     IFNE DEBUG
000012E6                          2813mm     ENDC
000012E6                          2814mm 
000012E6                          2815mm     ENDM
000012E6  57CD FFDA               2816m     DBEQ D5,LOOP_178
000012EA                          2817m     ENDM
000012EA                          2818  
000012EA                          2819m     PRINT_CRLF D3,A2
000012EA  45FA 0A61               2820m     LEA CRLF(PC),A2
000012EE                          2821mm     PRINT_STR A2,D3
000012EE                          2822mm LOOP_184
000012EE  0C12 0000               2823mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012F2  6700 0016               2824mm     BEQ EXIT_184
000012F6                          2825mmm     PRINT_CHAR (A2)+,D3
000012F6                          2826mmm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012F6                 TRUE     2827mmm     IFEQ DEBUG
000012F6  1639 00C00003           2828mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012FC  0803 0002               2829mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001300  67F4                    2830mmm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00001302  13DA 00C00007           2831mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001308                          2832mmm     ENDC
00001308                          2833mmm 
00001308                 FALSE    2834mmm     IFNE DEBUG
00001308                          2835mmm     ENDC
00001308                          2836mmm 
00001308                          2837mmm     ENDM
00001308  60E4                    2838mm     BRA LOOP_184
0000130A                          2839mm EXIT_184
0000130A                          2840mm     ENDM
0000130A                          2841m     ENDM
0000130A                          2842  
0000130A                          2843      WHILE D0 <GT> #0 DO
0000130A                          2844s _10000014
0000130A  B07C 0000               2845s     CMP.W   #0,D0
0000130E  6F00 001C               2846s     BLE _10000015
00001312  5580                    2847          SUB.L #2,D0
00001314                          2848  
00001314  13D1 00E00001           2849          MOVE.B (A1),DISPLAY
0000131A                          2850m         PROGRAM (A1),(A0),D2
0000131A  3091                    2851m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
0000131C                          2852m 
0000131C                          2853m WAIT_FOR_COMPLETE_186
0000131C  3410                    2854m         MOVE.W (A0),D2
0000131E                          2855m 
0000131E                          2856m         IF.W D2 <NE> (A1) THEN
0000131E  B451                    2857ms     CMP.W   (A1),D2
00001320  6700 0004               2858ms     BEQ _0000000F
00001324  60F6                    2859m             BRA WAIT_FOR_COMPLETE_186
00001326                          2860m         ENDI
00001326                          2861ms _0000000F
00001326                          2862m         ENDM
00001326                          2863          
00001326                          2864          ;PRINT_CHAR #'.',D7
00001326                          2865          
00001326  5488                    2866          ADD.L #2,A0
00001328  5489                    2867          ADD.L #2,A1
0000132A                          2868      ENDW
0000132A  60DE                    2869s     BRA _10000014
0000132C                          2870s _10000015
0000132C                          2871  
0000132C  45FA 09EB               2872      LEA SP(PC),A2
00001330                          2873m     PRINT_STR A2,D2
00001330                          2874m LOOP_187
00001330  0C12 0000               2875m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001334  6700 0016               2876m     BEQ EXIT_187
00001338                          2877mm     PRINT_CHAR (A2)+,D2
00001338                          2878mm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001338                 TRUE     2879mm     IFEQ DEBUG
00001338  1439 00C00003           2880mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000133E  0802 0002               2881mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001342  67F4                    2882mm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
00001344  13DA 00C00007           2883mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000134A                          2884mm     ENDC
0000134A                          2885mm 
0000134A                 FALSE    2886mm     IFNE DEBUG
0000134A                          2887mm     ENDC
0000134A                          2888mm 
0000134A                          2889mm     ENDM
0000134A  60E4                    2890m     BRA LOOP_187
0000134C                          2891m EXIT_187
0000134C                          2892m     ENDM
0000134C                          2893      
0000134C  41F8 0000               2894      LEA STACK,A0
00001350  D1CC                    2895      ADD.L A4,A0
00001352  2010                    2896      MOVE.L (A0),D0
00001354                          2897m     PRINT_REG D0,D2,D3,D4,A3
00001354  47FA 09FD               2898m     LEA OX(PC),A3
00001358                          2899mm     PRINT_STR A3,D2
00001358                          2900mm LOOP_190
00001358  0C13 0000               2901mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000135C  6700 0016               2902mm     BEQ EXIT_190
00001360                          2903mmm     PRINT_CHAR (A3)+,D2
00001360                          2904mmm WAIT_FOR_READY_191                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001360                 TRUE     2905mmm     IFEQ DEBUG
00001360  1439 00C00003           2906mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001366  0802 0002               2907mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000136A  67F4                    2908mmm         BEQ WAIT_FOR_READY_191                      ; NO SPACE, CHECK AGAIN
0000136C  13DB 00C00007           2909mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001372                          2910mmm     ENDC
00001372                          2911mmm 
00001372                 FALSE    2912mmm     IFNE DEBUG
00001372                          2913mmm     ENDC
00001372                          2914mmm 
00001372                          2915mmm     ENDM
00001372  60E4                    2916mm     BRA LOOP_190
00001374                          2917mm EXIT_190
00001374                          2918mm     ENDM
00001374  7807                    2919m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001376                          2920m LOOP_189
00001376                          2921mm     BIN2HEX D0,D3,A3
00001376  47FA 0957               2922mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
0000137A  E998                    2923mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000137C  1600                    2924mm     MOVE.B D0,D3
0000137E  0283 0000000F           2925mm     ANDI.L #$F,D3
00001384  1633 3000               2926mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001388                          2927mm     ENDM
00001388                          2928mm     PRINT_CHAR D3,D2
00001388                          2929mm WAIT_FOR_READY_193                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001388                 TRUE     2930mm     IFEQ DEBUG
00001388  1439 00C00003           2931mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000138E  0802 0002               2932mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001392  67F4                    2933mm         BEQ WAIT_FOR_READY_193                      ; NO SPACE, CHECK AGAIN
00001394  13C3 00C00007           2934mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000139A                          2935mm     ENDC
0000139A                          2936mm 
0000139A                 FALSE    2937mm     IFNE DEBUG
0000139A                          2938mm     ENDC
0000139A                          2939mm 
0000139A                          2940mm     ENDM
0000139A  57CC FFDA               2941m     DBEQ D4,LOOP_189
0000139E                          2942m     ENDM
0000139E                          2943m     PRINT_CRLF D2,A2
0000139E  45FA 09AD               2944m     LEA CRLF(PC),A2
000013A2                          2945mm     PRINT_STR A2,D2
000013A2                          2946mm LOOP_195
000013A2  0C12 0000               2947mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013A6  6700 0016               2948mm     BEQ EXIT_195
000013AA                          2949mmm     PRINT_CHAR (A2)+,D2
000013AA                          2950mmm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013AA                 TRUE     2951mmm     IFEQ DEBUG
000013AA  1439 00C00003           2952mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013B0  0802 0002               2953mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013B4  67F4                    2954mmm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
000013B6  13DA 00C00007           2955mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013BC                          2956mmm     ENDC
000013BC                          2957mmm 
000013BC                 FALSE    2958mmm     IFNE DEBUG
000013BC                          2959mmm     ENDC
000013BC                          2960mmm 
000013BC                          2961mmm     ENDM
000013BC  60E4                    2962mm     BRA LOOP_195
000013BE                          2963mm EXIT_195
000013BE                          2964mm     ENDM
000013BE                          2965m     ENDM
000013BE                          2966      
000013BE  207C 00000000           2967      MOVE.L #0,A0
000013C4                          2968m     PROGRAM_VECTOR D0,A0,D2
000013C4  5488                    2969m     ADD.L #2,A0
000013C6                          2970mm     PROGRAM D0, (A0), D2                                ; WRITE IT
000013C6  3080                    2971mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000013C8                          2972mm 
000013C8                          2973mm WAIT_FOR_COMPLETE_198
000013C8  3410                    2974mm         MOVE.W (A0),D2
000013CA                          2975mm 
000013CA                          2976mm         IF.W D2 <NE> D0 THEN
000013CA  B440                    2977mms     CMP.W   D0,D2
000013CC  6700 0004               2978mms     BEQ _00000010
000013D0  60F6                    2979mm             BRA WAIT_FOR_COMPLETE_198
000013D2                          2980mm         ENDI
000013D2                          2981mms _00000010
000013D2                          2982mm         ENDM
000013D2  E088                    2983m     LSR.L #8,D0
000013D4  E088                    2984m     LSR.L #8,D0
000013D6  5588                    2985m     SUB.L #2,A0
000013D8                          2986mm     PROGRAM D0, (A0), D2
000013D8  3080                    2987mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000013DA                          2988mm 
000013DA                          2989mm WAIT_FOR_COMPLETE_199
000013DA  3410                    2990mm         MOVE.W (A0),D2
000013DC                          2991mm 
000013DC                          2992mm         IF.W D2 <NE> D0 THEN
000013DC  B440                    2993mms     CMP.W   D0,D2
000013DE  6700 0004               2994mms     BEQ _00000011
000013E2  60F6                    2995mm             BRA WAIT_FOR_COMPLETE_199
000013E4                          2996mm         ENDI
000013E4                          2997mms _00000011
000013E4                          2998mm         ENDM
000013E4                          2999m     ENDM
000013E4                          3000      
000013E4  45FA 0955               3001      LEA VECTORS(PC),A2
000013E8                          3002m     PRINT_STR A2,D2
000013E8                          3003m LOOP_200
000013E8  0C12 0000               3004m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013EC  6700 0016               3005m     BEQ EXIT_200
000013F0                          3006mm     PRINT_CHAR (A2)+,D2
000013F0                          3007mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013F0                 TRUE     3008mm     IFEQ DEBUG
000013F0  1439 00C00003           3009mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013F6  0802 0002               3010mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013FA  67F4                    3011mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
000013FC  13DA 00C00007           3012mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001402                          3013mm     ENDC
00001402                          3014mm 
00001402                 FALSE    3015mm     IFNE DEBUG
00001402                          3016mm     ENDC
00001402                          3017mm 
00001402                          3018mm     ENDM
00001402  60E4                    3019m     BRA LOOP_200
00001404                          3020m EXIT_200
00001404                          3021m     ENDM
00001404                          3022  
00001404                          3023      FOR A0 = #RESET TO #START-4 BY #4 DO
00001404  307C 0004               3024s     MOVE.W  #RESET,A0
00001408  6000 0108               3025s     BRA _2000000F
0000140C                          3026s _2000000E
0000140C                          3027  
0000140C  2248                    3028          MOVE.L A0,A1
0000140E  D3CC                    3029          ADD.L A4,A1
00001410                          3030              
00001410  2011                    3031          MOVE.L (A1),D0  
00001412  D081                    3032          ADD.L D1,D0
00001414  0480 00000400           3033          SUB.L #START,D0
0000141A                          3034m         PRINT_REG D0,D2,D3,D4,A3
0000141A  47FA 0937               3035m     LEA OX(PC),A3
0000141E                          3036mm     PRINT_STR A3,D2
0000141E                          3037mm LOOP_203
0000141E  0C13 0000               3038mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001422  6700 0016               3039mm     BEQ EXIT_203
00001426                          3040mmm     PRINT_CHAR (A3)+,D2
00001426                          3041mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001426                 TRUE     3042mmm     IFEQ DEBUG
00001426  1439 00C00003           3043mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000142C  0802 0002               3044mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001430  67F4                    3045mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001432  13DB 00C00007           3046mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001438                          3047mmm     ENDC
00001438                          3048mmm 
00001438                 FALSE    3049mmm     IFNE DEBUG
00001438                          3050mmm     ENDC
00001438                          3051mmm 
00001438                          3052mmm     ENDM
00001438  60E4                    3053mm     BRA LOOP_203
0000143A                          3054mm EXIT_203
0000143A                          3055mm     ENDM
0000143A  7807                    3056m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000143C                          3057m LOOP_202
0000143C                          3058mm     BIN2HEX D0,D3,A3
0000143C  47FA 0891               3059mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
00001440  E998                    3060mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001442  1600                    3061mm     MOVE.B D0,D3
00001444  0283 0000000F           3062mm     ANDI.L #$F,D3
0000144A  1633 3000               3063mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000144E                          3064mm     ENDM
0000144E                          3065mm     PRINT_CHAR D3,D2
0000144E                          3066mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000144E                 TRUE     3067mm     IFEQ DEBUG
0000144E  1439 00C00003           3068mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001454  0802 0002               3069mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001458  67F4                    3070mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
0000145A  13C3 00C00007           3071mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001460                          3072mm     ENDC
00001460                          3073mm 
00001460                 FALSE    3074mm     IFNE DEBUG
00001460                          3075mm     ENDC
00001460                          3076mm 
00001460                          3077mm     ENDM
00001460  57CC FFDA               3078m     DBEQ D4,LOOP_202
00001464                          3079m     ENDM
00001464                          3080  
00001464  47FA 08F0               3081          LEA TO(PC),A3
00001468                          3082m         PRINT_STR A3,D3
00001468                          3083m LOOP_207
00001468  0C13 0000               3084m     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000146C  6700 0016               3085m     BEQ EXIT_207
00001470                          3086mm     PRINT_CHAR (A3)+,D3
00001470                          3087mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001470                 TRUE     3088mm     IFEQ DEBUG
00001470  1639 00C00003           3089mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001476  0803 0002               3090mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000147A  67F4                    3091mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
0000147C  13DB 00C00007           3092mm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001482                          3093mm     ENDC
00001482                          3094mm 
00001482                 FALSE    3095mm     IFNE DEBUG
00001482                          3096mm     ENDC
00001482                          3097mm 
00001482                          3098mm     ENDM
00001482  60E4                    3099m     BRA LOOP_207
00001484                          3100m EXIT_207
00001484                          3101m     ENDM
00001484                          3102  
00001484  2408                    3103          MOVE.L A0,D2
00001486                          3104m         PRINT_REG D2,D3,D4,D5,A3
00001486  47FA 08CB               3105m     LEA OX(PC),A3
0000148A                          3106mm     PRINT_STR A3,D3
0000148A                          3107mm LOOP_210
0000148A  0C13 0000               3108mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000148E  6700 0016               3109mm     BEQ EXIT_210
00001492                          3110mmm     PRINT_CHAR (A3)+,D3
00001492                          3111mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001492                 TRUE     3112mmm     IFEQ DEBUG
00001492  1639 00C00003           3113mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001498  0803 0002               3114mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000149C  67F4                    3115mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0000149E  13DB 00C00007           3116mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014A4                          3117mmm     ENDC
000014A4                          3118mmm 
000014A4                 FALSE    3119mmm     IFNE DEBUG
000014A4                          3120mmm     ENDC
000014A4                          3121mmm 
000014A4                          3122mmm     ENDM
000014A4  60E4                    3123mm     BRA LOOP_210
000014A6                          3124mm EXIT_210
000014A6                          3125mm     ENDM
000014A6  7A07                    3126m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014A8                          3127m LOOP_209
000014A8                          3128mm     BIN2HEX D2,D4,A3
000014A8  47FA 0825               3129mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000014AC  E99A                    3130mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014AE  1802                    3131mm     MOVE.B D2,D4
000014B0  0284 0000000F           3132mm     ANDI.L #$F,D4
000014B6  1833 4000               3133mm     MOVE.B 0(A3,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000014BA                          3134mm     ENDM
000014BA                          3135mm     PRINT_CHAR D4,D3
000014BA                          3136mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014BA                 TRUE     3137mm     IFEQ DEBUG
000014BA  1639 00C00003           3138mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000014C0  0803 0002               3139mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000014C4  67F4                    3140mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
000014C6  13C4 00C00007           3141mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014CC                          3142mm     ENDC
000014CC                          3143mm 
000014CC                 FALSE    3144mm     IFNE DEBUG
000014CC                          3145mm     ENDC
000014CC                          3146mm 
000014CC                          3147mm     ENDM
000014CC  57CD FFDA               3148m     DBEQ D5,LOOP_209
000014D0                          3149m     ENDM
000014D0                          3150          
000014D0                          3151m         PRINT_CRLF D2,A3
000014D0  47FA 087B               3152m     LEA CRLF(PC),A3
000014D4                          3153mm     PRINT_STR A3,D2
000014D4                          3154mm LOOP_215
000014D4  0C13 0000               3155mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000014D8  6700 0016               3156mm     BEQ EXIT_215
000014DC                          3157mmm     PRINT_CHAR (A3)+,D2
000014DC                          3158mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014DC                 TRUE     3159mmm     IFEQ DEBUG
000014DC  1439 00C00003           3160mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014E2  0802 0002               3161mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014E6  67F4                    3162mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
000014E8  13DB 00C00007           3163mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014EE                          3164mmm     ENDC
000014EE                          3165mmm 
000014EE                 FALSE    3166mmm     IFNE DEBUG
000014EE                          3167mmm     ENDC
000014EE                          3168mmm 
000014EE                          3169mmm     ENDM
000014EE  60E4                    3170mm     BRA LOOP_215
000014F0                          3171mm EXIT_215
000014F0                          3172mm     ENDM
000014F0                          3173m     ENDM
000014F0                          3174          
000014F0                          3175m         PROGRAM_VECTOR D0,A0,D2
000014F0  5488                    3176m     ADD.L #2,A0
000014F2                          3177mm     PROGRAM D0, (A0), D2                                ; WRITE IT
000014F2  3080                    3178mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000014F4                          3179mm 
000014F4                          3180mm WAIT_FOR_COMPLETE_218
000014F4  3410                    3181mm         MOVE.W (A0),D2
000014F6                          3182mm 
000014F6                          3183mm         IF.W D2 <NE> D0 THEN
000014F6  B440                    3184mms     CMP.W   D0,D2
000014F8  6700 0004               3185mms     BEQ _00000012
000014FC  60F6                    3186mm             BRA WAIT_FOR_COMPLETE_218
000014FE                          3187mm         ENDI
000014FE                          3188mms _00000012
000014FE                          3189mm         ENDM
000014FE  E088                    3190m     LSR.L #8,D0
00001500  E088                    3191m     LSR.L #8,D0
00001502  5588                    3192m     SUB.L #2,A0
00001504                          3193mm     PROGRAM D0, (A0), D2
00001504  3080                    3194mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001506                          3195mm 
00001506                          3196mm WAIT_FOR_COMPLETE_219
00001506  3410                    3197mm         MOVE.W (A0),D2
00001508                          3198mm 
00001508                          3199mm         IF.W D2 <NE> D0 THEN
00001508  B440                    3200mms     CMP.W   D0,D2
0000150A  6700 0004               3201mms     BEQ _00000013
0000150E  60F6                    3202mm             BRA WAIT_FOR_COMPLETE_219
00001510                          3203mm         ENDI
00001510                          3204mms _00000013
00001510                          3205mm         ENDM
00001510                          3206m     ENDM
00001510                          3207      ENDF
00001510  5848                    3208s     ADD.W   #4,A0
00001512                          3209s _2000000F
00001512  B0FC 03FC               3210s     CMP.W   #START-4,A0
00001516  6F00 FEF4               3211s     BLE _2000000E
0000151A                          3212                                          
0000151A                          3213m     PROTECT
0000151A  31FC AAAA 2AAA          3214m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001520  31FC 5555 1554          3215m     MOVE.W #$5555,$1554
00001526  31FC A0A0 2AAA          3216m     MOVE.W #$A0A0,$2AAA
0000152C                          3217m     ENDM
0000152C                          3218  
0000152C  6000 F12E               3219      BRA MAIN_LOOP
00001530                          3220      
00001530                          3221  P
00001530  7000                    3222      MOVE.L #0,D0                                    ; D0 will be the data to write
00001532                          3223  
00001532                          3224      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00001532  323C 0000               3225s     MOVE.W  #0,D1
00001536  6000 0046               3226s     BRA _20000011
0000153A                          3227s _20000010
0000153A  E988                    3228          LSL.L #4,D0                                 ; make what we have so far more significant
0000153C                          3229m         WAIT_CHAR D2,D3                             ; next character -> D2
0000153C                          3230m WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000153C                 TRUE     3231m     IFEQ DEBUG
0000153C  1639 00C00003           3232m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001542  0803 0000               3233m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001546  67F4                    3234m         BEQ WAIT_FOR_READY_221                      ; NOTHING, CHECK AGAIN
00001548                          3235m     ENDC
00001548                          3236m 
00001548                          3237mm     READ_CHAR D2
00001548                 TRUE     3238mm     IFEQ DEBUG
00001548  1439 00C00007           3239mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000154E                          3240mm     ENDC
0000154E                 FALSE    3241mm     IFNE DEBUG
0000154E                          3242mm     ENDC
0000154E                          3243mm 
0000154E  B43C 001B               3244mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001552  6700 EEAC               3245mm     BEQ START
00001556                          3246mm     ENDM
00001556                          3247m 
00001556                 TRUE     3248m     IFEQ DEBUG
00001556                          3249mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001556                          3250mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001556                 TRUE     3251mm     IFEQ DEBUG
00001556  1639 00C00003           3252mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000155C  0803 0002               3253mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001560  67F4                    3254mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
00001562  13C2 00C00007           3255mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001568                          3256mm     ENDC
00001568                          3257mm 
00001568                 FALSE    3258mm     IFNE DEBUG
00001568                          3259mm     ENDC
00001568                          3260mm 
00001568                          3261mm     ENDM
00001568                          3262m     ENDC
00001568                          3263m     ENDM
00001568                          3264m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001568  41FA 0775               3265m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000156C  0402 0030               3266m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001570  C4BC 000000FF           3267m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001576  1430 2000               3268m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000157A                          3269m     ENDM
0000157A  8002                    3270          OR.B D2,D0
0000157C                          3271      ENDF
0000157C  5241                    3272s     ADD.W   #1,D1
0000157E                          3273s _20000011
0000157E  B27C 0003               3274s     CMP.W   #3,D1
00001582  6FB6                    3275s     BLE _20000010
00001584                          3276  
00001584                          3277m     PRINT_CRLF D2,A1
00001584  43FA 07C7               3278m     LEA CRLF(PC),A1
00001588                          3279mm     PRINT_STR A1,D2
00001588                          3280mm LOOP_226
00001588  0C11 0000               3281mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000158C  6700 0016               3282mm     BEQ EXIT_226
00001590                          3283mmm     PRINT_CHAR (A1)+,D2
00001590                          3284mmm WAIT_FOR_READY_227                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001590                 TRUE     3285mmm     IFEQ DEBUG
00001590  1439 00C00003           3286mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001596  0802 0002               3287mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000159A  67F4                    3288mmm         BEQ WAIT_FOR_READY_227                      ; NO SPACE, CHECK AGAIN
0000159C  13D9 00C00007           3289mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015A2                          3290mmm     ENDC
000015A2                          3291mmm 
000015A2                 FALSE    3292mmm     IFNE DEBUG
000015A2                          3293mmm     ENDC
000015A2                          3294mmm 
000015A2                          3295mmm     ENDM
000015A2  60E4                    3296mm     BRA LOOP_226
000015A4                          3297mm EXIT_226
000015A4                          3298mm     ENDM
000015A4                          3299m     ENDM
000015A4                          3300  
000015A4  2047                    3301      MOVE.L D7,A0                                    ; address accumulator -> target address register
000015A6  7E00                    3302      MOVE.L #0,D7                                    ; clear the now used address accumulator
000015A8                          3303  
000015A8                          3304m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
000015A8  31FC AAAA 2AAA          3305m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
000015AE  4E71                    3306m     NOP
000015B0  31FC 5555 1554          3307m     MOVE.W #$5555,$1554
000015B6  4E71                    3308m     NOP
000015B8  31FC 8080 2AAA          3309m     MOVE.W #$8080,$2AAA
000015BE  4E71                    3310m     NOP
000015C0  31FC AAAA 2AAA          3311m     MOVE.W #$AAAA,$2AAA
000015C6  4E71                    3312m     NOP
000015C8  31FC 5555 1554          3313m     MOVE.W #$5555,$1554
000015CE  4E71                    3314m     NOP
000015D0  31FC 2020 2AAA          3315m     MOVE.W #$2020,$2AAA
000015D6                          3316m     ENDM
000015D6                          3317                              
000015D6                          3318      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
000015D6  3E3C 0000               3319s     MOVE.W  #$0,D7
000015DA  6000 0006               3320s     BRA _20000013
000015DE                          3321s _20000012
000015DE  4E71                    3322          NOP
000015E0                          3323      ENDF
000015E0  5247                    3324s     ADD.W   #1,D7
000015E2                          3325s _20000013
000015E2  BE7C FFFF               3326s     CMP.W   #$FFFFFFFF,D7
000015E6  6FF6                    3327s     BLE _20000012
000015E8                          3328               
000015E8  45FA 070C               3329      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
000015EC                          3330m     PRINT_STR A2,D2
000015EC                          3331m LOOP_229
000015EC  0C12 0000               3332m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000015F0  6700 0016               3333m     BEQ EXIT_229
000015F4                          3334mm     PRINT_CHAR (A2)+,D2
000015F4                          3335mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015F4                 TRUE     3336mm     IFEQ DEBUG
000015F4  1439 00C00003           3337mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000015FA  0802 0002               3338mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000015FE  67F4                    3339mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
00001600  13DA 00C00007           3340mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001606                          3341mm     ENDC
00001606                          3342mm 
00001606                 FALSE    3343mm     IFNE DEBUG
00001606                          3344mm     ENDC
00001606                          3345mm 
00001606                          3346mm     ENDM
00001606  60E4                    3347m     BRA LOOP_229
00001608                          3348m EXIT_229
00001608                          3349m     ENDM
00001608                          3350  
00001608                          3351m     PRINT_REG D0,D3,D4,D5,A2
00001608  45FA 0749               3352m     LEA OX(PC),A2
0000160C                          3353mm     PRINT_STR A2,D3
0000160C                          3354mm LOOP_232
0000160C  0C12 0000               3355mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001610  6700 0016               3356mm     BEQ EXIT_232
00001614                          3357mmm     PRINT_CHAR (A2)+,D3
00001614                          3358mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001614                 TRUE     3359mmm     IFEQ DEBUG
00001614  1639 00C00003           3360mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000161A  0803 0002               3361mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000161E  67F4                    3362mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
00001620  13DA 00C00007           3363mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001626                          3364mmm     ENDC
00001626                          3365mmm 
00001626                 FALSE    3366mmm     IFNE DEBUG
00001626                          3367mmm     ENDC
00001626                          3368mmm 
00001626                          3369mmm     ENDM
00001626  60E4                    3370mm     BRA LOOP_232
00001628                          3371mm EXIT_232
00001628                          3372mm     ENDM
00001628  7A07                    3373m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000162A                          3374m LOOP_231
0000162A                          3375mm     BIN2HEX D0,D4,A2
0000162A  45FA 06A3               3376mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000162E  E998                    3377mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001630  1800                    3378mm     MOVE.B D0,D4
00001632  0284 0000000F           3379mm     ANDI.L #$F,D4
00001638  1832 4000               3380mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000163C                          3381mm     ENDM
0000163C                          3382mm     PRINT_CHAR D4,D3
0000163C                          3383mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000163C                 TRUE     3384mm     IFEQ DEBUG
0000163C  1639 00C00003           3385mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001642  0803 0002               3386mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001646  67F4                    3387mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
00001648  13C4 00C00007           3388mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000164E                          3389mm     ENDC
0000164E                          3390mm 
0000164E                 FALSE    3391mm     IFNE DEBUG
0000164E                          3392mm     ENDC
0000164E                          3393mm 
0000164E                          3394mm     ENDM
0000164E  57CD FFDA               3395m     DBEQ D5,LOOP_231
00001652                          3396m     ENDM
00001652                          3397  
00001652  45FA 0702               3398      LEA TO(PC),A2
00001656                          3399m     PRINT_STR A2,D3
00001656                          3400m LOOP_236
00001656  0C12 0000               3401m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000165A  6700 0016               3402m     BEQ EXIT_236
0000165E                          3403mm     PRINT_CHAR (A2)+,D3
0000165E                          3404mm WAIT_FOR_READY_237                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000165E                 TRUE     3405mm     IFEQ DEBUG
0000165E  1639 00C00003           3406mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001664  0803 0002               3407mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001668  67F4                    3408mm         BEQ WAIT_FOR_READY_237                      ; NO SPACE, CHECK AGAIN
0000166A  13DA 00C00007           3409mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001670                          3410mm     ENDC
00001670                          3411mm 
00001670                 FALSE    3412mm     IFNE DEBUG
00001670                          3413mm     ENDC
00001670                          3414mm 
00001670                          3415mm     ENDM
00001670  60E4                    3416m     BRA LOOP_236
00001672                          3417m EXIT_236
00001672                          3418m     ENDM
00001672                          3419  
00001672  2408                    3420      MOVE.L A0,D2
00001674                          3421m     PRINT_REG D2,D3,D4,D5,A2
00001674  45FA 06DD               3422m     LEA OX(PC),A2
00001678                          3423mm     PRINT_STR A2,D3
00001678                          3424mm LOOP_239
00001678  0C12 0000               3425mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000167C  6700 0016               3426mm     BEQ EXIT_239
00001680                          3427mmm     PRINT_CHAR (A2)+,D3
00001680                          3428mmm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001680                 TRUE     3429mmm     IFEQ DEBUG
00001680  1639 00C00003           3430mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001686  0803 0002               3431mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000168A  67F4                    3432mmm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
0000168C  13DA 00C00007           3433mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001692                          3434mmm     ENDC
00001692                          3435mmm 
00001692                 FALSE    3436mmm     IFNE DEBUG
00001692                          3437mmm     ENDC
00001692                          3438mmm 
00001692                          3439mmm     ENDM
00001692  60E4                    3440mm     BRA LOOP_239
00001694                          3441mm EXIT_239
00001694                          3442mm     ENDM
00001694  7A07                    3443m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001696                          3444m LOOP_238
00001696                          3445mm     BIN2HEX D2,D4,A2
00001696  45FA 0637               3446mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000169A  E99A                    3447mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000169C  1802                    3448mm     MOVE.B D2,D4
0000169E  0284 0000000F           3449mm     ANDI.L #$F,D4
000016A4  1832 4000               3450mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000016A8                          3451mm     ENDM
000016A8                          3452mm     PRINT_CHAR D4,D3
000016A8                          3453mm WAIT_FOR_READY_242                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016A8                 TRUE     3454mm     IFEQ DEBUG
000016A8  1639 00C00003           3455mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016AE  0803 0002               3456mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016B2  67F4                    3457mm         BEQ WAIT_FOR_READY_242                      ; NO SPACE, CHECK AGAIN
000016B4  13C4 00C00007           3458mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000016BA                          3459mm     ENDC
000016BA                          3460mm 
000016BA                 FALSE    3461mm     IFNE DEBUG
000016BA                          3462mm     ENDC
000016BA                          3463mm 
000016BA                          3464mm     ENDM
000016BA  57CD FFDA               3465m     DBEQ D5,LOOP_238
000016BE                          3466m     ENDM
000016BE                          3467  
000016BE                          3468m     PRINT_CRLF D3,A2
000016BE  45FA 068D               3469m     LEA CRLF(PC),A2
000016C2                          3470mm     PRINT_STR A2,D3
000016C2                          3471mm LOOP_244
000016C2  0C12 0000               3472mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016C6  6700 0016               3473mm     BEQ EXIT_244
000016CA                          3474mmm     PRINT_CHAR (A2)+,D3
000016CA                          3475mmm WAIT_FOR_READY_245                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016CA                 TRUE     3476mmm     IFEQ DEBUG
000016CA  1639 00C00003           3477mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016D0  0803 0002               3478mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016D4  67F4                    3479mmm         BEQ WAIT_FOR_READY_245                      ; NO SPACE, CHECK AGAIN
000016D6  13DA 00C00007           3480mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016DC                          3481mmm     ENDC
000016DC                          3482mmm 
000016DC                 FALSE    3483mmm     IFNE DEBUG
000016DC                          3484mmm     ENDC
000016DC                          3485mmm 
000016DC                          3486mmm     ENDM
000016DC  60E4                    3487mm     BRA LOOP_244
000016DE                          3488mm EXIT_244
000016DE                          3489mm     ENDM
000016DE                          3490m     ENDM
000016DE                          3491  
000016DE                          3492m     PROGRAM D0,(A0),D2
000016DE  3080                    3493m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000016E0                          3494m 
000016E0                          3495m WAIT_FOR_COMPLETE_246
000016E0  3410                    3496m         MOVE.W (A0),D2
000016E2                          3497m 
000016E2                          3498m         IF.W D2 <NE> D0 THEN
000016E2  B440                    3499ms     CMP.W   D0,D2
000016E4  6700 0004               3500ms     BEQ _00000014
000016E8  60F6                    3501m             BRA WAIT_FOR_COMPLETE_246
000016EA                          3502m         ENDI
000016EA                          3503ms _00000014
000016EA                          3504m         ENDM
000016EA                          3505  
000016EA                          3506m     PROTECT
000016EA  31FC AAAA 2AAA          3507m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000016F0  31FC 5555 1554          3508m     MOVE.W #$5555,$1554
000016F6  31FC A0A0 2AAA          3509m     MOVE.W #$A0A0,$2AAA
000016FC                          3510m     ENDM
000016FC                          3511  
000016FC  6000 EF5E               3512      BRA MAIN_LOOP
00001700                          3513      
00001700                          3514  M
00001700  7000                    3515      MOVE.L #0,D0                                        ; D0 will be the length to read            
00001702  7200                    3516      MOVE.L #0,D1                                        ; D1 will be the address to read 
00001704                          3517  
00001704                          3518      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00001704  343C 0000               3519s     MOVE.W  #0,D2
00001708  6000 0046               3520s     BRA _20000015
0000170C                          3521s _20000014
0000170C  E989                    3522          LSL.L #4,D1                                     ; make what we have so far more significant
0000170E                          3523m         WAIT_CHAR D3,D4                                 ; next character -> D2
0000170E                          3524m WAIT_FOR_READY_248                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000170E                 TRUE     3525m     IFEQ DEBUG
0000170E  1839 00C00003           3526m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00001714  0804 0000               3527m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00001718  67F4                    3528m         BEQ WAIT_FOR_READY_248                      ; NOTHING, CHECK AGAIN
0000171A                          3529m     ENDC
0000171A                          3530m 
0000171A                          3531mm     READ_CHAR D3
0000171A                 TRUE     3532mm     IFEQ DEBUG
0000171A  1639 00C00007           3533mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00001720                          3534mm     ENDC
00001720                 FALSE    3535mm     IFNE DEBUG
00001720                          3536mm     ENDC
00001720                          3537mm 
00001720  B63C 001B               3538mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00001724  6700 ECDA               3539mm     BEQ START
00001728                          3540mm     ENDM
00001728                          3541m 
00001728                 TRUE     3542m     IFEQ DEBUG
00001728                          3543mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00001728                          3544mm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001728                 TRUE     3545mm     IFEQ DEBUG
00001728  1839 00C00003           3546mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
0000172E  0804 0002               3547mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00001732  67F4                    3548mm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
00001734  13C3 00C00007           3549mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000173A                          3550mm     ENDC
0000173A                          3551mm 
0000173A                 FALSE    3552mm     IFNE DEBUG
0000173A                          3553mm     ENDC
0000173A                          3554mm 
0000173A                          3555mm     ENDM
0000173A                          3556m     ENDC
0000173A                          3557m     ENDM
0000173A                          3558m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
0000173A  41FA 05A3               3559m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000173E  0403 0030               3560m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001742  C6BC 000000FF           3561m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00001748  1630 3000               3562m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
0000174C                          3563m     ENDM
0000174C  8203                    3564          OR.B D3,D1
0000174E                          3565      ENDF
0000174E  5242                    3566s     ADD.W   #1,D2
00001750                          3567s _20000015
00001750  B47C 0007               3568s     CMP.W   #7,D2
00001754  6FB6                    3569s     BLE _20000014
00001756                          3570m     PRINT_CRLF D2,A1
00001756  43FA 05F5               3571m     LEA CRLF(PC),A1
0000175A                          3572mm     PRINT_STR A1,D2
0000175A                          3573mm LOOP_253
0000175A  0C11 0000               3574mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000175E  6700 0016               3575mm     BEQ EXIT_253
00001762                          3576mmm     PRINT_CHAR (A1)+,D2
00001762                          3577mmm WAIT_FOR_READY_254                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001762                 TRUE     3578mmm     IFEQ DEBUG
00001762  1439 00C00003           3579mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001768  0802 0002               3580mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000176C  67F4                    3581mmm         BEQ WAIT_FOR_READY_254                      ; NO SPACE, CHECK AGAIN
0000176E  13D9 00C00007           3582mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001774                          3583mmm     ENDC
00001774                          3584mmm 
00001774                 FALSE    3585mmm     IFNE DEBUG
00001774                          3586mmm     ENDC
00001774                          3587mmm 
00001774                          3588mmm     ENDM
00001774  60E4                    3589mm     BRA LOOP_253
00001776                          3590mm EXIT_253
00001776                          3591mm     ENDM
00001776                          3592m     ENDM
00001776                          3593  
00001776  3001                    3594      MOVE.W D1,D0                                        ; extract the LSword for the length
00001778  E089                    3595      LSR.L #8,D1                                         ; extract the MSword for the address
0000177A  E089                    3596      LSR.L #8,D1
0000177C                          3597  
0000177C  2241                    3598      MOVE.L D1,A1
0000177E                          3599      
0000177E  2047                    3600      MOVE.L D7,A0                                        ; address accumulator -> target address register
00001780                          3601      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
00001780                          3602  
00001780                          3603      WHILE D0 <GT> #0 DO
00001780                          3604s _10000016
00001780  B07C 0000               3605s     CMP.W   #0,D0
00001784  6F00 000E               3606s     BLE _10000017
00001788  5580                    3607          SUB.L #2,D0
0000178A                          3608  
0000178A  13D1 00E00001           3609          MOVE.B (A1),DISPLAY
00001790  30D9                    3610          MOVE.W (A1)+,(A0)+
00001792                          3611      ENDW
00001792  60EC                    3612s     BRA _10000016
00001794                          3613s _10000017
00001794                          3614      
00001794  6000 EEC6               3615      BRA MAIN_LOOP
00001798                          3616  
00001798                          3617  X
00001798  45FA 05C6               3618      LEA STATUS_REGISTER(PC),A2
0000179C                          3619m     PRINT_STR A2,D3
0000179C                          3620m LOOP_255
0000179C  0C12 0000               3621m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000017A0  6700 0016               3622m     BEQ EXIT_255
000017A4                          3623mm     PRINT_CHAR (A2)+,D3
000017A4                          3624mm WAIT_FOR_READY_256                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017A4                 TRUE     3625mm     IFEQ DEBUG
000017A4  1639 00C00003           3626mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000017AA  0803 0002               3627mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000017AE  67F4                    3628mm         BEQ WAIT_FOR_READY_256                      ; NO SPACE, CHECK AGAIN
000017B0  13DA 00C00007           3629mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017B6                          3630mm     ENDC
000017B6                          3631mm 
000017B6                 FALSE    3632mm     IFNE DEBUG
000017B6                          3633mm     ENDC
000017B6                          3634mm 
000017B6                          3635mm     ENDM
000017B6  60E4                    3636m     BRA LOOP_255
000017B8                          3637m EXIT_255
000017B8                          3638m     ENDM
000017B8                          3639  
000017B8  40C0                    3640      MOVE SR,D0
000017BA                          3641m     PRINT_REG D0,D3,D4,D5,A2
000017BA  45FA 0597               3642m     LEA OX(PC),A2
000017BE                          3643mm     PRINT_STR A2,D3
000017BE                          3644mm LOOP_258
000017BE  0C12 0000               3645mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000017C2  6700 0016               3646mm     BEQ EXIT_258
000017C6                          3647mmm     PRINT_CHAR (A2)+,D3
000017C6                          3648mmm WAIT_FOR_READY_259                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017C6                 TRUE     3649mmm     IFEQ DEBUG
000017C6  1639 00C00003           3650mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000017CC  0803 0002               3651mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000017D0  67F4                    3652mmm         BEQ WAIT_FOR_READY_259                      ; NO SPACE, CHECK AGAIN
000017D2  13DA 00C00007           3653mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017D8                          3654mmm     ENDC
000017D8                          3655mmm 
000017D8                 FALSE    3656mmm     IFNE DEBUG
000017D8                          3657mmm     ENDC
000017D8                          3658mmm 
000017D8                          3659mmm     ENDM
000017D8  60E4                    3660mm     BRA LOOP_258
000017DA                          3661mm EXIT_258
000017DA                          3662mm     ENDM
000017DA  7A07                    3663m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000017DC                          3664m LOOP_257
000017DC                          3665mm     BIN2HEX D0,D4,A2
000017DC  45FA 04F1               3666mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000017E0  E998                    3667mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000017E2  1800                    3668mm     MOVE.B D0,D4
000017E4  0284 0000000F           3669mm     ANDI.L #$F,D4
000017EA  1832 4000               3670mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000017EE                          3671mm     ENDM
000017EE                          3672mm     PRINT_CHAR D4,D3
000017EE                          3673mm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017EE                 TRUE     3674mm     IFEQ DEBUG
000017EE  1639 00C00003           3675mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000017F4  0803 0002               3676mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000017F8  67F4                    3677mm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
000017FA  13C4 00C00007           3678mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001800                          3679mm     ENDC
00001800                          3680mm 
00001800                 FALSE    3681mm     IFNE DEBUG
00001800                          3682mm     ENDC
00001800                          3683mm 
00001800                          3684mm     ENDM
00001800  57CD FFDA               3685m     DBEQ D5,LOOP_257
00001804                          3686m     ENDM
00001804                          3687m     PRINT_CRLF D3,A2
00001804  45FA 0547               3688m     LEA CRLF(PC),A2
00001808                          3689mm     PRINT_STR A2,D3
00001808                          3690mm LOOP_263
00001808  0C12 0000               3691mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000180C  6700 0016               3692mm     BEQ EXIT_263
00001810                          3693mmm     PRINT_CHAR (A2)+,D3
00001810                          3694mmm WAIT_FOR_READY_264                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001810                 TRUE     3695mmm     IFEQ DEBUG
00001810  1639 00C00003           3696mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001816  0803 0002               3697mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000181A  67F4                    3698mmm         BEQ WAIT_FOR_READY_264                      ; NO SPACE, CHECK AGAIN
0000181C  13DA 00C00007           3699mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001822                          3700mmm     ENDC
00001822                          3701mmm 
00001822                 FALSE    3702mmm     IFNE DEBUG
00001822                          3703mmm     ENDC
00001822                          3704mmm 
00001822                          3705mmm     ENDM
00001822  60E4                    3706mm     BRA LOOP_263
00001824                          3707mm EXIT_263
00001824                          3708mm     ENDM
00001824                          3709m     ENDM
00001824                          3710  
00001824  45FA 0535               3711      LEA STACK_POINTER(PC),A2
00001828                          3712m     PRINT_STR A2,D3
00001828                          3713m LOOP_265
00001828  0C12 0000               3714m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000182C  6700 0016               3715m     BEQ EXIT_265
00001830                          3716mm     PRINT_CHAR (A2)+,D3
00001830                          3717mm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001830                 TRUE     3718mm     IFEQ DEBUG
00001830  1639 00C00003           3719mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001836  0803 0002               3720mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000183A  67F4                    3721mm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
0000183C  13DA 00C00007           3722mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001842                          3723mm     ENDC
00001842                          3724mm 
00001842                 FALSE    3725mm     IFNE DEBUG
00001842                          3726mm     ENDC
00001842                          3727mm 
00001842                          3728mm     ENDM
00001842  60E4                    3729m     BRA LOOP_265
00001844                          3730m EXIT_265
00001844                          3731m     ENDM
00001844                          3732  
00001844  200F                    3733      MOVE.L SP,D0
00001846                          3734m     PRINT_REG D0,D3,D4,D5,A2
00001846  45FA 050B               3735m     LEA OX(PC),A2
0000184A                          3736mm     PRINT_STR A2,D3
0000184A                          3737mm LOOP_268
0000184A  0C12 0000               3738mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000184E  6700 0016               3739mm     BEQ EXIT_268
00001852                          3740mmm     PRINT_CHAR (A2)+,D3
00001852                          3741mmm WAIT_FOR_READY_269                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001852                 TRUE     3742mmm     IFEQ DEBUG
00001852  1639 00C00003           3743mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001858  0803 0002               3744mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000185C  67F4                    3745mmm         BEQ WAIT_FOR_READY_269                      ; NO SPACE, CHECK AGAIN
0000185E  13DA 00C00007           3746mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001864                          3747mmm     ENDC
00001864                          3748mmm 
00001864                 FALSE    3749mmm     IFNE DEBUG
00001864                          3750mmm     ENDC
00001864                          3751mmm 
00001864                          3752mmm     ENDM
00001864  60E4                    3753mm     BRA LOOP_268
00001866                          3754mm EXIT_268
00001866                          3755mm     ENDM
00001866  7A07                    3756m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001868                          3757m LOOP_267
00001868                          3758mm     BIN2HEX D0,D4,A2
00001868  45FA 0465               3759mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000186C  E998                    3760mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000186E  1800                    3761mm     MOVE.B D0,D4
00001870  0284 0000000F           3762mm     ANDI.L #$F,D4
00001876  1832 4000               3763mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000187A                          3764mm     ENDM
0000187A                          3765mm     PRINT_CHAR D4,D3
0000187A                          3766mm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000187A                 TRUE     3767mm     IFEQ DEBUG
0000187A  1639 00C00003           3768mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001880  0803 0002               3769mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001884  67F4                    3770mm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
00001886  13C4 00C00007           3771mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000188C                          3772mm     ENDC
0000188C                          3773mm 
0000188C                 FALSE    3774mm     IFNE DEBUG
0000188C                          3775mm     ENDC
0000188C                          3776mm 
0000188C                          3777mm     ENDM
0000188C  57CD FFDA               3778m     DBEQ D5,LOOP_267
00001890                          3779m     ENDM
00001890                          3780m     PRINT_CRLF D3,A2
00001890  45FA 04BB               3781m     LEA CRLF(PC),A2
00001894                          3782mm     PRINT_STR A2,D3
00001894                          3783mm LOOP_273
00001894  0C12 0000               3784mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001898  6700 0016               3785mm     BEQ EXIT_273
0000189C                          3786mmm     PRINT_CHAR (A2)+,D3
0000189C                          3787mmm WAIT_FOR_READY_274                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000189C                 TRUE     3788mmm     IFEQ DEBUG
0000189C  1639 00C00003           3789mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000018A2  0803 0002               3790mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000018A6  67F4                    3791mmm         BEQ WAIT_FOR_READY_274                      ; NO SPACE, CHECK AGAIN
000018A8  13DA 00C00007           3792mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018AE                          3793mmm     ENDC
000018AE                          3794mmm 
000018AE                 FALSE    3795mmm     IFNE DEBUG
000018AE                          3796mmm     ENDC
000018AE                          3797mmm 
000018AE                          3798mmm     ENDM
000018AE  60E4                    3799mm     BRA LOOP_273
000018B0                          3800mm EXIT_273
000018B0                          3801mm     ENDM
000018B0                          3802m     ENDM
000018B0                          3803  
000018B0  6000 EDAA               3804      BRA MAIN_LOOP
000018B4                          3805  
000018B4                          3806          
000018B4                          3807  I
000018B4  13FC 0008 00C0000B      3808      MOVE.B #8,DUART_IMR
000018BC  027C F8FF               3809      AND.W #$F8FF,SR
000018C0  6000 ED9A               3810      BRA MAIN_LOOP
000018C4                          3811      
000018C4                          3812  O
000018C4  13FC 0000 00C0000B      3813      MOVE.B #0,DUART_IMR
000018CC  007C 0700               3814      OR.W #$0700,SR
000018D0  6000 ED8A               3815      BRA MAIN_LOOP
000018D4                          3816          
000018D4                          3817  HASH
000018D4                          3818m     PROTECT
000018D4  31FC AAAA 2AAA          3819m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000018DA  31FC 5555 1554          3820m     MOVE.W #$5555,$1554
000018E0  31FC A0A0 2AAA          3821m     MOVE.W #$A0A0,$2AAA
000018E6                          3822m     ENDM
000018E6  6000 ED74               3823      BRA MAIN_LOOP
000018EA                          3824  
000018EA                          3825  
000018EA                          3826  
000018EA                          3827  HEX_DIGIT
000018EA  E98F                    3828      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000018EC                          3829m     HEX2BIN D2,D2,A0
000018EC  41FA 03F1               3830m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000018F0  0402 0030               3831m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000018F4  C4BC 000000FF           3832m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000018FA  1430 2000               3833m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000018FE                          3834m     ENDM
000018FE  8E02                    3835      OR.B D2,D7  
00001900  6000 ED7A               3836      BRA GET_INPUT
00001904                          3837  
00001904  FFFF FFFF               3838      SIMHALT                                             ; halt simulator
00001908                          3839  
00001908                          3840  ; exceptions    
00001908                          3841  BUS_ERROR_HANDLER
00001908                          3842  
00001908  41FA 0462               3843      LEA BUS_ERROR(PC),A0
0000190C                          3844m     PRINT_STR A0,D1
0000190C                          3845m LOOP_277
0000190C  0C10 0000               3846m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001910  6700 0016               3847m     BEQ EXIT_277
00001914                          3848mm     PRINT_CHAR (A0)+,D1
00001914                          3849mm WAIT_FOR_READY_278                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001914                 TRUE     3850mm     IFEQ DEBUG
00001914  1239 00C00003           3851mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000191A  0801 0002               3852mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000191E  67F4                    3853mm         BEQ WAIT_FOR_READY_278                      ; NO SPACE, CHECK AGAIN
00001920  13D8 00C00007           3854mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001926                          3855mm     ENDC
00001926                          3856mm 
00001926                 FALSE    3857mm     IFNE DEBUG
00001926                          3858mm     ENDC
00001926                          3859mm 
00001926                          3860mm     ENDM
00001926  60E4                    3861m     BRA LOOP_277
00001928                          3862m EXIT_277
00001928                          3863m     ENDM
00001928                          3864  
00001928  7000                    3865      MOVE.L #0,D0
0000192A  3017                    3866      MOVE.W (SP),D0
0000192C                          3867  
0000192C  0800 0004               3868      BTST #4,D0
00001930  6700 0026               3869      BEQ WRITE
00001934                          3870      
00001934  41FA 044B               3871      LEA READING(PC),A0
00001938                          3872m     PRINT_STR A0,D1
00001938                          3873m LOOP_279
00001938  0C10 0000               3874m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000193C  6700 0016               3875m     BEQ EXIT_279
00001940                          3876mm     PRINT_CHAR (A0)+,D1
00001940                          3877mm WAIT_FOR_READY_280                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001940                 TRUE     3878mm     IFEQ DEBUG
00001940  1239 00C00003           3879mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001946  0801 0002               3880mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000194A  67F4                    3881mm         BEQ WAIT_FOR_READY_280                      ; NO SPACE, CHECK AGAIN
0000194C  13D8 00C00007           3882mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001952                          3883mm     ENDC
00001952                          3884mm 
00001952                 FALSE    3885mm     IFNE DEBUG
00001952                          3886mm     ENDC
00001952                          3887mm 
00001952                          3888mm     ENDM
00001952  60E4                    3889m     BRA LOOP_279
00001954                          3890m EXIT_279
00001954                          3891m     ENDM
00001954                          3892  
00001954  6000 0022               3893      BRA CONTINUE    
00001958                          3894  WRITE
00001958  41FA 0430               3895      LEA WRITING(PC),A0
0000195C                          3896m     PRINT_STR A0,D1
0000195C                          3897m LOOP_281
0000195C  0C10 0000               3898m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001960  6700 0016               3899m     BEQ EXIT_281
00001964                          3900mm     PRINT_CHAR (A0)+,D1
00001964                          3901mm WAIT_FOR_READY_282                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001964                 TRUE     3902mm     IFEQ DEBUG
00001964  1239 00C00003           3903mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000196A  0801 0002               3904mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000196E  67F4                    3905mm         BEQ WAIT_FOR_READY_282                      ; NO SPACE, CHECK AGAIN
00001970  13D8 00C00007           3906mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001976                          3907mm     ENDC
00001976                          3908mm 
00001976                 FALSE    3909mm     IFNE DEBUG
00001976                          3910mm     ENDC
00001976                          3911mm 
00001976                          3912mm     ENDM
00001976  60E4                    3913m     BRA LOOP_281
00001978                          3914m EXIT_281
00001978                          3915m     ENDM
00001978                          3916  
00001978                          3917  CONTINUE
00001978  222F 0002               3918      MOVE.L 2(SP),D1
0000197C                          3919m     PRINT_REG D1,D2,D3,D4,A0
0000197C  41FA 03D5               3920m     LEA OX(PC),A0
00001980                          3921mm     PRINT_STR A0,D2
00001980                          3922mm LOOP_284
00001980  0C10 0000               3923mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001984  6700 0016               3924mm     BEQ EXIT_284
00001988                          3925mmm     PRINT_CHAR (A0)+,D2
00001988                          3926mmm WAIT_FOR_READY_285                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001988                 TRUE     3927mmm     IFEQ DEBUG
00001988  1439 00C00003           3928mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000198E  0802 0002               3929mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001992  67F4                    3930mmm         BEQ WAIT_FOR_READY_285                      ; NO SPACE, CHECK AGAIN
00001994  13D8 00C00007           3931mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000199A                          3932mmm     ENDC
0000199A                          3933mmm 
0000199A                 FALSE    3934mmm     IFNE DEBUG
0000199A                          3935mmm     ENDC
0000199A                          3936mmm 
0000199A                          3937mmm     ENDM
0000199A  60E4                    3938mm     BRA LOOP_284
0000199C                          3939mm EXIT_284
0000199C                          3940mm     ENDM
0000199C  7807                    3941m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000199E                          3942m LOOP_283
0000199E                          3943mm     BIN2HEX D1,D3,A0
0000199E  41FA 032F               3944mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000019A2  E999                    3945mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000019A4  1601                    3946mm     MOVE.B D1,D3
000019A6  0283 0000000F           3947mm     ANDI.L #$F,D3
000019AC  1630 3000               3948mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000019B0                          3949mm     ENDM
000019B0                          3950mm     PRINT_CHAR D3,D2
000019B0                          3951mm WAIT_FOR_READY_287                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019B0                 TRUE     3952mm     IFEQ DEBUG
000019B0  1439 00C00003           3953mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019B6  0802 0002               3954mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000019BA  67F4                    3955mm         BEQ WAIT_FOR_READY_287                      ; NO SPACE, CHECK AGAIN
000019BC  13C3 00C00007           3956mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000019C2                          3957mm     ENDC
000019C2                          3958mm 
000019C2                 FALSE    3959mm     IFNE DEBUG
000019C2                          3960mm     ENDC
000019C2                          3961mm 
000019C2                          3962mm     ENDM
000019C2  57CC FFDA               3963m     DBEQ D4,LOOP_283
000019C6                          3964m     ENDM
000019C6                          3965  
000019C6  41FA 03CB               3966      LEA FROM(PC),A0
000019CA                          3967m     PRINT_STR A0,D0
000019CA                          3968m LOOP_288
000019CA  0C10 0000               3969m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019CE  6700 0016               3970m     BEQ EXIT_288
000019D2                          3971mm     PRINT_CHAR (A0)+,D0
000019D2                          3972mm WAIT_FOR_READY_289                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019D2                 TRUE     3973mm     IFEQ DEBUG
000019D2  1039 00C00003           3974mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000019D8  0800 0002               3975mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000019DC  67F4                    3976mm         BEQ WAIT_FOR_READY_289                      ; NO SPACE, CHECK AGAIN
000019DE  13D8 00C00007           3977mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000019E4                          3978mm     ENDC
000019E4                          3979mm 
000019E4                 FALSE    3980mm     IFNE DEBUG
000019E4                          3981mm     ENDC
000019E4                          3982mm 
000019E4                          3983mm     ENDM
000019E4  60E4                    3984m     BRA LOOP_288
000019E6                          3985m EXIT_288
000019E6                          3986m     ENDM
000019E6                          3987  
000019E6  222F 000A               3988      MOVE.L 10(SP),D1
000019EA                          3989m     PRINT_REG D1,D2,D3,D4,A0
000019EA  41FA 0367               3990m     LEA OX(PC),A0
000019EE                          3991mm     PRINT_STR A0,D2
000019EE                          3992mm LOOP_291
000019EE  0C10 0000               3993mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000019F2  6700 0016               3994mm     BEQ EXIT_291
000019F6                          3995mmm     PRINT_CHAR (A0)+,D2
000019F6                          3996mmm WAIT_FOR_READY_292                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000019F6                 TRUE     3997mmm     IFEQ DEBUG
000019F6  1439 00C00003           3998mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000019FC  0802 0002               3999mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A00  67F4                    4000mmm         BEQ WAIT_FOR_READY_292                      ; NO SPACE, CHECK AGAIN
00001A02  13D8 00C00007           4001mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A08                          4002mmm     ENDC
00001A08                          4003mmm 
00001A08                 FALSE    4004mmm     IFNE DEBUG
00001A08                          4005mmm     ENDC
00001A08                          4006mmm 
00001A08                          4007mmm     ENDM
00001A08  60E4                    4008mm     BRA LOOP_291
00001A0A                          4009mm EXIT_291
00001A0A                          4010mm     ENDM
00001A0A  7807                    4011m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001A0C                          4012m LOOP_290
00001A0C                          4013mm     BIN2HEX D1,D3,A0
00001A0C  41FA 02C1               4014mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001A10  E999                    4015mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001A12  1601                    4016mm     MOVE.B D1,D3
00001A14  0283 0000000F           4017mm     ANDI.L #$F,D3
00001A1A  1630 3000               4018mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001A1E                          4019mm     ENDM
00001A1E                          4020mm     PRINT_CHAR D3,D2
00001A1E                          4021mm WAIT_FOR_READY_294                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A1E                 TRUE     4022mm     IFEQ DEBUG
00001A1E  1439 00C00003           4023mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001A24  0802 0002               4024mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001A28  67F4                    4025mm         BEQ WAIT_FOR_READY_294                      ; NO SPACE, CHECK AGAIN
00001A2A  13C3 00C00007           4026mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001A30                          4027mm     ENDC
00001A30                          4028mm 
00001A30                 FALSE    4029mm     IFNE DEBUG
00001A30                          4030mm     ENDC
00001A30                          4031mm 
00001A30                          4032mm     ENDM
00001A30  57CC FFDA               4033m     DBEQ D4,LOOP_290
00001A34                          4034m     ENDM
00001A34                          4035m     PRINT_CRLF D0,A0
00001A34  41FA 0317               4036m     LEA CRLF(PC),A0
00001A38                          4037mm     PRINT_STR A0,D0
00001A38                          4038mm LOOP_296
00001A38  0C10 0000               4039mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A3C  6700 0016               4040mm     BEQ EXIT_296
00001A40                          4041mmm     PRINT_CHAR (A0)+,D0
00001A40                          4042mmm WAIT_FOR_READY_297                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A40                 TRUE     4043mmm     IFEQ DEBUG
00001A40  1039 00C00003           4044mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001A46  0800 0002               4045mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001A4A  67F4                    4046mmm         BEQ WAIT_FOR_READY_297                      ; NO SPACE, CHECK AGAIN
00001A4C  13D8 00C00007           4047mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A52                          4048mmm     ENDC
00001A52                          4049mmm 
00001A52                 FALSE    4050mmm     IFNE DEBUG
00001A52                          4051mmm     ENDC
00001A52                          4052mmm 
00001A52                          4053mmm     ENDM
00001A52  60E4                    4054mm     BRA LOOP_296
00001A54                          4055mm EXIT_296
00001A54                          4056mm     ENDM
00001A54                          4057m     ENDM
00001A54                          4058      
00001A54  207C 00000004           4059      MOVE.L #4,A0
00001A5A  4ED0                    4060      JMP (A0)
00001A5C                          4061          
00001A5C                          4062  ILLEGAL_HANDLER
00001A5C  13FC 0007 00E00001      4063      MOVE.B #7,DISPLAY   
00001A64                          4064      
00001A64  207C 00000004           4065      MOVE.L #4,A0
00001A6A  4ED0                    4066      JMP (A0)
00001A6C                          4067          
00001A6C                          4068  UNHANDLED_HANDLER
00001A6C  41FA 032C               4069      LEA UNHANDLED(PC),A0
00001A70                          4070m     PRINT_STR A0,D1
00001A70                          4071m LOOP_298
00001A70  0C10 0000               4072m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A74  6700 0016               4073m     BEQ EXIT_298
00001A78                          4074mm     PRINT_CHAR (A0)+,D1
00001A78                          4075mm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A78                 TRUE     4076mm     IFEQ DEBUG
00001A78  1239 00C00003           4077mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001A7E  0801 0002               4078mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001A82  67F4                    4079mm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001A84  13D8 00C00007           4080mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001A8A                          4081mm     ENDC
00001A8A                          4082mm 
00001A8A                 FALSE    4083mm     IFNE DEBUG
00001A8A                          4084mm     ENDC
00001A8A                          4085mm 
00001A8A                          4086mm     ENDM
00001A8A  60E4                    4087m     BRA LOOP_298
00001A8C                          4088m EXIT_298
00001A8C                          4089m     ENDM
00001A8C                          4090  
00001A8C  4E73                    4091      RTE 
00001A8E                          4092      
00001A8E                          4093  UNINITIALISED_HANDLER
00001A8E  41FA 0320               4094      LEA UNINITIALISED(PC),A0
00001A92                          4095m     PRINT_STR A0,D1
00001A92                          4096m LOOP_300
00001A92  0C10 0000               4097m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001A96  6700 0016               4098m     BEQ EXIT_300
00001A9A                          4099mm     PRINT_CHAR (A0)+,D1
00001A9A                          4100mm WAIT_FOR_READY_301                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001A9A                 TRUE     4101mm     IFEQ DEBUG
00001A9A  1239 00C00003           4102mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001AA0  0801 0002               4103mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001AA4  67F4                    4104mm         BEQ WAIT_FOR_READY_301                      ; NO SPACE, CHECK AGAIN
00001AA6  13D8 00C00007           4105mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AAC                          4106mm     ENDC
00001AAC                          4107mm 
00001AAC                 FALSE    4108mm     IFNE DEBUG
00001AAC                          4109mm     ENDC
00001AAC                          4110mm 
00001AAC                          4111mm     ENDM
00001AAC  60E4                    4112m     BRA LOOP_300
00001AAE                          4113m EXIT_300
00001AAE                          4114m     ENDM
00001AAE                          4115  
00001AAE  4E73                    4116      RTE 
00001AB0                          4117  
00001AB0                          4118  SPURIOUS_HANDLER
00001AB0  41FA 031E               4119      LEA SPURIOUS(PC),A0
00001AB4                          4120m     PRINT_STR A0,D1
00001AB4                          4121m LOOP_302
00001AB4  0C10 0000               4122m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001AB8  6700 0016               4123m     BEQ EXIT_302
00001ABC                          4124mm     PRINT_CHAR (A0)+,D1
00001ABC                          4125mm WAIT_FOR_READY_303                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001ABC                 TRUE     4126mm     IFEQ DEBUG
00001ABC  1239 00C00003           4127mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001AC2  0801 0002               4128mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001AC6  67F4                    4129mm         BEQ WAIT_FOR_READY_303                      ; NO SPACE, CHECK AGAIN
00001AC8  13D8 00C00007           4130mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001ACE                          4131mm     ENDC
00001ACE                          4132mm 
00001ACE                 FALSE    4133mm     IFNE DEBUG
00001ACE                          4134mm     ENDC
00001ACE                          4135mm 
00001ACE                          4136mm     ENDM
00001ACE  60E4                    4137m     BRA LOOP_302
00001AD0                          4138m EXIT_302
00001AD0                          4139m     ENDM
00001AD0                          4140  
00001AD0  4E73                    4141      RTE 
00001AD2                          4142      
00001AD2                          4143  TICK_HANDLER
00001AD2  41FA 0291               4144      LEA TICK(PC),A0
00001AD6                          4145m     PRINT_STR A0,D1
00001AD6                          4146m LOOP_304
00001AD6  0C10 0000               4147m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001ADA  6700 0016               4148m     BEQ EXIT_304
00001ADE                          4149mm     PRINT_CHAR (A0)+,D1
00001ADE                          4150mm WAIT_FOR_READY_305                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001ADE                 TRUE     4151mm     IFEQ DEBUG
00001ADE  1239 00C00003           4152mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001AE4  0801 0002               4153mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001AE8  67F4                    4154mm         BEQ WAIT_FOR_READY_305                      ; NO SPACE, CHECK AGAIN
00001AEA  13D8 00C00007           4155mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001AF0                          4156mm     ENDC
00001AF0                          4157mm 
00001AF0                 FALSE    4158mm     IFNE DEBUG
00001AF0                          4159mm     ENDC
00001AF0                          4160mm 
00001AF0                          4161mm     ENDM
00001AF0  60E4                    4162m     BRA LOOP_304
00001AF2                          4163m EXIT_304
00001AF2                          4164m     ENDM
00001AF2                          4165      
00001AF2  1039 00C0001F           4166      MOVE.B DUART_RESET_OPR,D0
00001AF8  4E73                    4167      RTE 
00001AFA                          4168  
00001AFA                          4169  ; strings
00001AFA= 50 72 65 73 73 20 ...   4170  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001B0D= 5B 3F 5D 09 09 09 ...   4171  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001B19= 5B 76 5D 09 09 09 ...   4172          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001B28= 78 78 78 78 78 78 ...   4173          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001B40= 78 78 78 78 78 78 ...   4174          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001B60= 78 78 78 78 78 78 ...   4175          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001B81= 78 78 78 78 78 78 ...   4176          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001B92= 5B 7A 5D 09 09 09 ...   4177          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001BA4= 78 78 78 78 78 78 ...   4178          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
00001BC5= 78 78 78 78 78 78 ...   4179          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
00001BE4= 78 78 78 78 78 78 ...   4180          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001C08= 23 09 09 09 77 72 ...   4181          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001C22= 5B 78 5D 09 09 09 ...   4182          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001C39= 5B 69 5D 09 09 09 ...   4183          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001C52= 5B 6F 5D 09 09 09 ...   4184          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
00001C6D= 48 75 68 3F 0D 0A 00    4185  HUH  DC.B 'Huh?',CR,LF,NULL
00001C74= 20 53 20 72 65 63 ...   4186  READ    DC.B ' S records read, start address = ',NULL
00001C96= 57 3A 20 55 6E 6B ...   4187  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001CAD= 21 20 43 53 20 66 ...   4188  CS_FAILURE  DC.B '! CS failure at ',NULL
00001CBE= 21 20 52 41 4D 20 ...   4189  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001CCF= 30 31 32 33 34 35 ...   4190  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001CDF= 00 01 02 03 04 05 ...   4191  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001CF6= 4C 6F 61 64 69 6E ...   4192  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001D0A= 57 72 69 74 69 6E ...   4193  CODE        DC.B 'Writing code: ',NULL
00001D19= 53 65 74 74 69 6E ...   4194  SP      DC.B 'Setting initial stack pointer to ',NULL
00001D3B= 57 72 69 74 69 6E ...   4195  VECTORS DC.B 'Writing vectors',CR,LF,NULL
00001D4D= 0D 0A 00                4196  CRLF    DC.B CR,LF,NULL
00001D50= 3E 20 00                4197  PROMPT  DC.B '> ',NULL
00001D53= 30 78 00                4198  ox      DC.B '0x',NULL
00001D56= 20 2D 3E 20 00          4199  to      DC.B ' -> ',NULL
00001D5B= 53 50 3A 20 00          4200  STACK_POINTER DC.B 'SP: ',NULL
00001D60= 53 52 3A 20 00          4201  STATUS_REGISTER DC.B 'SR: ',NULL
00001D65= 74 69 63 6B 0D 0A 00    4202  TICK DC.B 'tick',CR,LF,NULL
00001D6C= 2A 20 42 75 73 2F ...   4203  BUS_ERROR DC.B '* Bus/address error ',NULL
00001D81= 72 65 61 64 69 6E ...   4204  READING DC.B 'reading ',NULL
00001D8A= 77 72 69 74 69 6E ...   4205  WRITING DC.B 'writing ',NULL
00001D93= 20 66 72 6F 6D 20 00    4206  FROM DC.B ' from ',NULL
00001D9A= 2A 20 55 6E 68 61 ...   4207  UNHANDLED DC.B '* Unhandled interrupt',NULL
00001DB0= 2A 20 20 55 6E 69 ...   4208  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
00001DD0= 2A 20 53 70 75 72 ...   4209  SPURIOUS DC.B '* Spurious interrupt',NULL
00001DE5= 43 6F 6C 64 20 73 ...   4210  COLD_START DC.B 'Cold start - brrr',CR,LF,NULL
00001DF9= 57 61 72 6D 20 73 ...   4211  WARM_START DC.B 'Warm start - phew',CR,LF,NULL
00001E0D= 4D 44 46 2D 6D 6F ...   4212  VERSION DC.B 'MDF-mon V1.126 (30/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001E2B= 00                      4213  END     DC.B 0
00001E2C                          4214      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1CCF
BUS_ERROR           1D6C
BUS_ERROR_HANDLER   1908
CODE                1D0A
COLD_START          1DE5
CONTINUE            1978
CONTINUE_103        D5A
CONTINUE_117        E4C
CONTINUE_58         928
CONTINUE_61         978
CONTINUE_65         9CE
CONTINUE_73         A82
CONTINUE_78         AF4
CONTINUE_83         B70
CONTINUE_88         BEE
CONTINUE_93         C76
CONTINUE_98         CE8
CR                  D
CRLF                1D4D
CS_FAILURE          1CAD
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       F56
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1E2B
EXIT_108            DCC
EXIT_11             5A0
EXIT_110            DEC
EXIT_114            E1E
EXIT_122            EB4
EXIT_124            EDC
EXIT_127            EFC
EXIT_132            F46
EXIT_135            F76
EXIT_139            FC0
EXIT_14             5C8
EXIT_142            FE2
EXIT_147            102C
EXIT_149            10A8
EXIT_152            10CC
EXIT_157            1116
EXIT_164            11A2
EXIT_167            1212
EXIT_169            1232
EXIT_172            1254
EXIT_176            129E
EXIT_179            12C0
EXIT_184            130A
EXIT_187            134C
EXIT_19             612
EXIT_190            1374
EXIT_195            13BE
EXIT_200            1404
EXIT_203            143A
EXIT_207            1484
EXIT_21             632
EXIT_210            14A6
EXIT_215            14F0
EXIT_226            15A4
EXIT_229            1608
EXIT_232            1628
EXIT_236            1672
EXIT_239            1694
EXIT_24             652
EXIT_244            16DE
EXIT_253            1776
EXIT_255            17B8
EXIT_258            17DA
EXIT_26             67C
EXIT_263            1824
EXIT_265            1844
EXIT_268            1866
EXIT_273            18B0
EXIT_277            1928
EXIT_279            1954
EXIT_281            1978
EXIT_284            199C
EXIT_288            19E6
EXIT_291            1A0A
EXIT_296            1A54
EXIT_298            1A8C
EXIT_300            1AAE
EXIT_302            1AD0
EXIT_304            1AF2
EXIT_32             710
EXIT_34             780
EXIT_36             7AC
EXIT_39             7D6
EXIT_4              534
EXIT_49             884
EXIT_56             8FA
EXIT_6              558
EXIT_70             A3E
EXIT_9              580
FROM                1D93
G                   1030
GET_INPUT           67C
H                   784
HASH                18D4
HELP                1B0D
HELPPROMPT          1AFA
HEX2BIN             10B
HEX2BIN_LUT         1CDF
HEX_DIGIT           18EA
HUH                 1C6D
I                   18B4
ILLEGAL_HANDLER     1A5C
L                   1126
LF                  A
LOADING             1CF6
LOOP_108            DB0
LOOP_11             584
LOOP_110            DD0
LOOP_114            E02
LOOP_122            E98
LOOP_124            EC0
LOOP_126            EFE
LOOP_127            EE0
LOOP_13             5CA
LOOP_132            F2A
LOOP_134            F78
LOOP_135            F5A
LOOP_139            FA4
LOOP_14             5AC
LOOP_141            FE4
LOOP_142            FC6
LOOP_147            1010
LOOP_149            108C
LOOP_151            10CE
LOOP_152            10B0
LOOP_157            10FA
LOOP_164            1186
LOOP_167            11F6
LOOP_169            1216
LOOP_171            1256
LOOP_172            1238
LOOP_176            1282
LOOP_178            12C2
LOOP_179            12A4
LOOP_184            12EE
LOOP_187            1330
LOOP_189            1376
LOOP_19             5F6
LOOP_190            1358
LOOP_195            13A2
LOOP_200            13E8
LOOP_202            143C
LOOP_203            141E
LOOP_207            1468
LOOP_209            14A8
LOOP_21             616
LOOP_210            148A
LOOP_215            14D4
LOOP_226            1588
LOOP_229            15EC
LOOP_231            162A
LOOP_232            160C
LOOP_236            1656
LOOP_238            1696
LOOP_239            1678
LOOP_24             636
LOOP_244            16C2
LOOP_253            175A
LOOP_255            179C
LOOP_257            17DC
LOOP_258            17BE
LOOP_26             660
LOOP_263            1808
LOOP_265            1828
LOOP_267            1868
LOOP_268            184A
LOOP_273            1894
LOOP_277            190C
LOOP_279            1938
LOOP_281            195C
LOOP_283            199E
LOOP_284            1980
LOOP_288            19CA
LOOP_290            1A0C
LOOP_291            19EE
LOOP_296            1A38
LOOP_298            1A70
LOOP_300            1A92
LOOP_302            1AB4
LOOP_304            1AD6
LOOP_32             6F4
LOOP_34             764
LOOP_36             790
LOOP_38             7D8
LOOP_39             7BA
LOOP_4              518
LOOP_49             868
LOOP_56             8DE
LOOP_6              53C
LOOP_70             A22
LOOP_9              564
M                   1700
MAIN_LOOP           65C
NULL                0
O                   18C4
OX                  1D53
P                   1530
PRINTSTR            790
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1D50
PROTECT             A40
R                   7B0
RAM                 200000
RAM_ERROR           1CBE
READ                1C74
READING             1D81
READ_CHAR           62D
RESET               4
ROM                 0
S                   904
SP                  1D19
SPURIOUS            1DD0
SPURIOUS_HANDLER    1AB0
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1D5B
START               400
STATUS_REGISTER     1D60
TAB                 9
TICK                1D65
TICK_HANDLER        1AD2
TO                  1D56
UNHANDLED           1D9A
UNHANDLED_HANDLER   1A6C
UNINITIALISED       1DB0
UNINITIALISED_HANDLER  1A8E
UNPROTECT           979
UNREC               1C96
USER                100
V                   78C
VECS                8
VECTORS             1D3B
VERSION             1E0D
W                   888
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_186  131C
WAIT_FOR_COMPLETE_198  13C8
WAIT_FOR_COMPLETE_199  13DA
WAIT_FOR_COMPLETE_218  14F4
WAIT_FOR_COMPLETE_219  1506
WAIT_FOR_COMPLETE_246  16E0
WAIT_FOR_READY_1    4CA
WAIT_FOR_READY_10   56C
WAIT_FOR_READY_100  D00
WAIT_FOR_READY_103  D3E
WAIT_FOR_READY_105  D72
WAIT_FOR_READY_109  DB8
WAIT_FOR_READY_111  DD8
WAIT_FOR_READY_112  DEC
WAIT_FOR_READY_115  E0A
WAIT_FOR_READY_117  E30
WAIT_FOR_READY_119  E64
WAIT_FOR_READY_12   58C
WAIT_FOR_READY_123  EA0
WAIT_FOR_READY_125  EC8
WAIT_FOR_READY_128  EE8
WAIT_FOR_READY_130  F10
WAIT_FOR_READY_133  F32
WAIT_FOR_READY_136  F62
WAIT_FOR_READY_138  F8A
WAIT_FOR_READY_140  FAC
WAIT_FOR_READY_143  FCE
WAIT_FOR_READY_145  FF6
WAIT_FOR_READY_148  1018
WAIT_FOR_READY_15   5B4
WAIT_FOR_READY_150  1094
WAIT_FOR_READY_153  10B8
WAIT_FOR_READY_155  10E0
WAIT_FOR_READY_158  1102
WAIT_FOR_READY_159  1134
WAIT_FOR_READY_161  114E
WAIT_FOR_READY_165  118E
WAIT_FOR_READY_168  11FE
WAIT_FOR_READY_17   5DC
WAIT_FOR_READY_170  121E
WAIT_FOR_READY_173  1240
WAIT_FOR_READY_175  1268
WAIT_FOR_READY_177  128A
WAIT_FOR_READY_180  12AC
WAIT_FOR_READY_182  12D4
WAIT_FOR_READY_185  12F6
WAIT_FOR_READY_188  1338
WAIT_FOR_READY_191  1360
WAIT_FOR_READY_193  1388
WAIT_FOR_READY_196  13AA
WAIT_FOR_READY_2    4DE
WAIT_FOR_READY_20   5FE
WAIT_FOR_READY_201  13F0
WAIT_FOR_READY_204  1426
WAIT_FOR_READY_206  144E
WAIT_FOR_READY_208  1470
WAIT_FOR_READY_211  1492
WAIT_FOR_READY_213  14BA
WAIT_FOR_READY_216  14DC
WAIT_FOR_READY_22   61E
WAIT_FOR_READY_221  153C
WAIT_FOR_READY_223  1556
WAIT_FOR_READY_227  1590
WAIT_FOR_READY_230  15F4
WAIT_FOR_READY_233  1614
WAIT_FOR_READY_235  163C
WAIT_FOR_READY_237  165E
WAIT_FOR_READY_240  1680
WAIT_FOR_READY_242  16A8
WAIT_FOR_READY_245  16CA
WAIT_FOR_READY_248  170E
WAIT_FOR_READY_25   63E
WAIT_FOR_READY_250  1728
WAIT_FOR_READY_254  1762
WAIT_FOR_READY_256  17A4
WAIT_FOR_READY_259  17C6
WAIT_FOR_READY_261  17EE
WAIT_FOR_READY_264  1810
WAIT_FOR_READY_266  1830
WAIT_FOR_READY_269  1852
WAIT_FOR_READY_27   668
WAIT_FOR_READY_271  187A
WAIT_FOR_READY_274  189C
WAIT_FOR_READY_278  1914
WAIT_FOR_READY_28   67C
WAIT_FOR_READY_280  1940
WAIT_FOR_READY_282  1964
WAIT_FOR_READY_285  1988
WAIT_FOR_READY_287  19B0
WAIT_FOR_READY_289  19D2
WAIT_FOR_READY_292  19F6
WAIT_FOR_READY_294  1A1E
WAIT_FOR_READY_297  1A40
WAIT_FOR_READY_299  1A78
WAIT_FOR_READY_3    4F2
WAIT_FOR_READY_30   696
WAIT_FOR_READY_301  1A9A
WAIT_FOR_READY_303  1ABC
WAIT_FOR_READY_305  1ADE
WAIT_FOR_READY_33   6FC
WAIT_FOR_READY_35   76C
WAIT_FOR_READY_37   798
WAIT_FOR_READY_40   7C2
WAIT_FOR_READY_42   7EA
WAIT_FOR_READY_43   800
WAIT_FOR_READY_44   816
WAIT_FOR_READY_45   82A
WAIT_FOR_READY_46   83E
WAIT_FOR_READY_47   852
WAIT_FOR_READY_5    520
WAIT_FOR_READY_50   870
WAIT_FOR_READY_51   892
WAIT_FOR_READY_53   8AC
WAIT_FOR_READY_57   8E6
WAIT_FOR_READY_58   90C
WAIT_FOR_READY_60   946
WAIT_FOR_READY_61   95C
WAIT_FOR_READY_63   990
WAIT_FOR_READY_65   9B2
WAIT_FOR_READY_67   9E6
WAIT_FOR_READY_7    544
WAIT_FOR_READY_71   A2A
WAIT_FOR_READY_73   A66
WAIT_FOR_READY_75   A9A
WAIT_FOR_READY_78   AD8
WAIT_FOR_READY_80   B0C
WAIT_FOR_READY_83   B54
WAIT_FOR_READY_85   B88
WAIT_FOR_READY_88   BD2
WAIT_FOR_READY_90   C06
WAIT_FOR_READY_93   C5A
WAIT_FOR_READY_95   C8E
WAIT_FOR_READY_98   CCC
WAIT_FOR_SRECORD    90C
WARM_START          1DF9
WRITE               1958
WRITING             1D8A
X                   1798
Z                   1036
_00000000           538
_00000001           558
_00000002           6BC
_00000003           6D0
_00000004           A46
_00000005           E22
_00000006           A54
_00000007           C42
_00000008           BB8
_00000009           E22
_0000000A           DAC
_0000000B           E22
_0000000C           F4A
_0000000D           F56
_0000000E           1116
_0000000F           1326
_00000010           13D2
_00000011           13E4
_00000012           14FE
_00000013           1510
_00000014           16EA
_10000000           9A8
_10000001           A10
_10000002           A5C
_10000003           AC4
_10000004           ACE
_10000005           B36
_10000006           B4A
_10000007           BB2
_10000008           BBC
_10000009           C3C
_1000000A           BC8
_1000000B           C30
_1000000C           C50
_1000000D           CB8
_1000000E           CC2
_1000000F           D2A
_10000010           D34
_10000011           D9C
_10000012           E26
_10000013           E8E
_10000014           130A
_10000015           132C
_10000016           1780
_10000017           1794
_20000000           42E
_20000001           43A
_20000002           448
_20000003           454
_20000004           890
_20000005           8D4
_20000006           1048
_20000007           1058
_20000008           1072
_20000009           1118
_2000000A           1132
_2000000B           1176
_2000000C           11E8
_2000000D           11EC
_2000000E           140C
_2000000F           1512
_20000010           153A
_20000011           157E
_20000012           15DE
_20000013           15E2
_20000014           170C
_20000015           1750
