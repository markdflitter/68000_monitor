00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/09/2021 18:35:39

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00A00000                 22  MC68230_BASE        EQU $A00000
00000000  =00000000                 23  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 24  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 25  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 26  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 27  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 28  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 29  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 30  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 31  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 32  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 33  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 34  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 35  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 36  MC68230_STATUS_             EQU $D
00000000                            37  
00000000  =00A00001                 38  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 39  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 40  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 41  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 42  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 43  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 44  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            45  
00000000  =00A0000B                 46  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 47  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 48  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 49  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 50  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 51  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 52  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 53  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 54  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 55  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 56  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 57  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            58  
00000000  =00000020                 59  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 60  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 61  MC68230_PORT_C_CS           EQU $08
00000000                            62  
00000000  =00000000                 63  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 64  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 65  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 66  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 67  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 68  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 69  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            70  
00000000  =00000007                 71  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 72  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            73  
00000000  =00000007                 74  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 75  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 76  IDE_STATUS_READY            EQU 6
00000000  =00000003                 77  IDE_STATUS_DRQ              EQU 3
00000000                            78  
00000000  =00C00000                 79  DUART_BASE          EQU $C00000
00000000  =00000000                 80  DUART_MRA_          EQU $0
00000000  =00000001                 81  DUART_CSRA_         EQU $1
00000000  =00000001                 82  DUART_SRA_          EQU $1
00000000  =00000002                 83  DUART_CRA_          EQU $2
00000000  =00000003                 84  DUART_TXA_          EQU $3
00000000  =00000003                 85  DUART_RXA_          EQU $3
00000000  =00000004                 86  DUART_ACR_          EQU $4
00000000  =00000005                 87  DUART_IMR_          EQU $5
00000000  =00000006                 88  DUART_CTUR_         EQU $6
00000000  =00000007                 89  DUART_CTLR_         EQU $7
00000000  =00000008                 90  DUART_MRB_          EQU $8
00000000  =00000009                 91  DUART_CSRB_         EQU $9
00000000  =00000009                 92  DUART_SRB_          EQU $9
00000000  =0000000A                 93  DUART_CRB_          EQU $A
00000000  =0000000B                 94  DUART_TXB_          EQU $B
00000000  =0000000B                 95  DUART_RXB_          EQU $B
00000000  =0000000C                 96  DUART_IVR_          EQU $C
00000000  =0000000D                 97  DUART_OPCR_         EQU $D
00000000  =0000000E                 98  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 99  DUART_RESET_OPR_    EQU $F
00000000                           100  
00000000  =00C00001                101  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                102  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                103  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                104  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                105  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                106  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           107  
00000000  =00C00011                108  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                109  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                110  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                111  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                112  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                113  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           114  
00000000  =00C00009                115  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                116  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                117  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                118  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                119  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                120  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                121  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                122  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           123  
00000000  =00E00000                124  DISPLAY_BASE        EQU $E00000
00000000  =00000000                125  DISPLAY_            EQU $0
00000000  =00E00001                126  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           127  
00000000                           128  ; macros
00000000                           129  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           130  ; the input register is changed during the process
00000000                           131  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           132  BIN2HEX MACRO
00000000                           133      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           134      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           135      MOVE.B \1,\2
00000000                           136      ANDI.L #$F,\2
00000000                           137      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           138      ENDM
00000000                           139  
00000000                           140  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           141  ; the input register is changed during the process
00000000                           142  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           143  HEX2BIN MACRO
00000000                           144      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           145      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           146      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           147      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           148      ENDM
00000000                           149  
00000000                           150  ; send a single char to the serial port
00000000                           151  ; \1 = char to send, \2 = data register to use for status poll
00000000                           152  ; will stamp on D0 and D1 in debug mode
00000000                           153  PRINT_CHAR MACRO
00000000                           154  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           155      IFEQ DEBUG
00000000                           156          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           157          BTST #2,\2                                  ; check for space to send
00000000                           158          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           159          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           160      ENDC
00000000                           161  
00000000                           162      IFNE DEBUG
00000000                           163          MOVE.B \1,D1
00000000                           164          MOVE.L #6,D0   
00000000                           165          TRAP #15                                    ; write to terminal in simulator
00000000                           166      ENDC
00000000                           167  
00000000                           168      ENDM
00000000                           169  
00000000                           170  ; send CR,LF to the serial port
00000000                           171  ; \1 = data register to use for status poll, /2 = working address register
00000000                           172  PRINT_CRLF MACRO
00000000                           173      LEA CRLF(PC),\2
00000000                           174      PRINT_STR \2,\1
00000000                           175      ENDM
00000000                           176  
00000000                           177  ; send C-style, zero terminated string to the serial port
00000000                           178  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           179  PRINT_STR MACRO
00000000                           180  LOOP\@
00000000                           181      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           182      BEQ EXIT\@
00000000                           183      PRINT_CHAR (\1)+,\2
00000000                           184      BRA LOOP\@
00000000                           185  EXIT\@
00000000                           186      ENDM
00000000                           187    
00000000                           188  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           189  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           190  PRINT_REG_4BIT MACRO
00000000                           191      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           192      MOVE.B \1,\3
00000000                           193      ANDI.L #$F,\3
00000000                           194      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           195      PRINT_CHAR \3,\2
00000000                           196      ENDM
00000000                           197  
00000000                           198  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           199  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           200  PRINT_REG MACRO
00000000                           201      LEA ox(PC),\5
00000000                           202      PRINT_STR \5,\2
00000000                           203      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           204  LOOP\@
00000000                           205      BIN2HEX \1,\3,\5
00000000                           206      PRINT_CHAR \3,\2
00000000                           207      DBEQ \4,LOOP\@
00000000                           208      ENDM
00000000                           209  
00000000                           210  ; wait for a char from the serial port
00000000                           211  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           212  ; will stamp on D0 and D1 in debug mode
00000000                           213  WAIT_CHAR MACRO
00000000                           214  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           215      IFEQ DEBUG
00000000                           216          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           217          BTST #0,\2                                  ; check for character
00000000                           218          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           219      ENDC
00000000                           220  
00000000                           221      READ_CHAR \1
00000000                           222  
00000000                           223      IFEQ DEBUG
00000000                           224          PRINT_CHAR \1,\2                            ; echo it back
00000000                           225      ENDC
00000000                           226      ENDM
00000000                           227  
00000000                           228  ; read a char from the serial port - assumes that there is one!
00000000                           229  ; \ 1= data register for read char
00000000                           230  ; will stamp on D0 and D1 in debug mode
00000000                           231  READ_CHAR MACRO
00000000                           232      IFEQ DEBUG
00000000                           233          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           234      ENDC
00000000                           235      IFNE DEBUG
00000000                           236          MOVE.L #5,D0    
00000000                           237          TRAP #15                                    ; read from keyboard in simulator
00000000                           238          MOVE.L D1,\1
00000000                           239      ENDC
00000000                           240  
00000000                           241      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           242      BEQ START
00000000                           243      ENDM
00000000                           244  
00000000                           245  
00000000                           246  ; read data from the download serial port
00000000                           247  ; \ 1= data register for read char
00000000                           248  DOWNLOAD MACRO
00000000                           249  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           250  
00000000                           251  ;   MOVE.B DUART_SRA,\1                             ; check for command
00000000                           252  ;   BTST #0,\1                                      ; check for character
00000000                           253  ;   BEQ CONTINUE\@                                  ; nothing, continue
00000000                           254  
00000000                           255  ;   READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           256  CONTINUE\@
00000000                           257  ;   MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           258      MOVE.B DUART_SRA,\1                             ; read download status register
00000000                           259      BTST #0,\1                                      ; check for character
00000000                           260      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           261      
00000000                           262  ;   MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           263      MOVE.B DUART_RXA,\1                             ; got a character, read it
00000000                           264      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           265  
00000000                           266      ENDM
00000000                           267  
00000000                           268  ; read two hex digits from the download serial port and convert to a byte
00000000                           269  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           270  DOWNLOAD_BYTE MACRO
00000000                           271      MOVE.B #2,\4
00000000                           272      WHILE.B \4 <GT> 0 DO
00000000                           273          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           274          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           275          ;PRINT_CHAR \2,\3
00000000                           276          HEX2BIN \2,\2,\6
00000000                           277          OR.B \2,\1
00000000                           278          SUB.B #1,\4
00000000                           279      ENDW
00000000                           280  
00000000                           281      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           282      MOVE.B \1,\2
00000000                           283      ADD.L \1,\5
00000000                           284  
00000000                           285      ENDM
00000000                           286  
00000000                           287  ; unprotect the EEPROM
00000000                           288  UNPROTECT MACRO
00000000                           289      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           290      NOP
00000000                           291      MOVE.W #$5555,$1554
00000000                           292      NOP
00000000                           293      MOVE.W #$8080,$2AAA
00000000                           294      NOP
00000000                           295      MOVE.W #$AAAA,$2AAA
00000000                           296      NOP
00000000                           297      MOVE.W #$5555,$1554
00000000                           298      NOP
00000000                           299      MOVE.W #$2020,$2AAA
00000000                           300      ENDM
00000000                           301      
00000000                           302  ; protect the EEPROM
00000000                           303  PROTECT MACRO
00000000                           304      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           305      MOVE.W #$5555,$1554
00000000                           306      MOVE.W #$A0A0,$2AAA
00000000                           307      ENDM
00000000                           308  ; write word to EEPROM
00000000                           309  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           310  PROGRAM MACRO
00000000                           311    MOVE.W \1,\2                                      ; write the data
00000000                           312  
00000000                           313  WAIT_FOR_COMPLETE\@
00000000                           314          MOVE.W \2,\3
00000000                           315  
00000000                           316          IF.W \3 <NE> \1 THEN
00000000                           317              BRA WAIT_FOR_COMPLETE\@
00000000                           318          ENDI
00000000                           319          ENDM
00000000                           320          
00000000                           321  ; program vector to EEPROM
00000000                           322  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           323  PROGRAM_VECTOR MACRO
00000000                           324      ADD.L #2,\2
00000000                           325      PROGRAM \1, (\2), \3                            ; write it
00000000                           326      LSR.L #8,\1
00000000                           327      LSR.L #8,\1
00000000                           328      SUB.L #2,\2
00000000                           329      PROGRAM \1, (\2), \3
00000000                           330      ENDM
00000000                           331  
00000000                           332  ; read an ide register
00000000                           333  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           334  READ_8 MACRO
00000000                           335      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           336      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           337      ORI.B \1, \3
00000000                           338      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           339      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           340      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           341      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           342      ORI.B #MC68230_PORT_C_READ, \3
00000000                           343      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           344      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           345      ENDM
00000000                           346      
00000000                           347  ; write an ide register
00000000                           348  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           349  WRITE_8 MACRO
00000000                           350      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           351      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           352      ORI.B \2, \3
00000000                           353      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           354      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           355      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           356      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           357      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           358      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           359      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           360      ENDM
00000000                           361  
00000000                           362  ; read ide data
00000000                           363  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           364  READ_16 MACRO
00000000                           365      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           366      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           367      
00000000                           368      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           369      ORI.B \1, \3
00000000                           370      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           371      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           372      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           373      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           374      LSL.W #8, \2
00000000                           375      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           376      ORI.B #MC68230_PORT_C_READ, \3
00000000                           377      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           378      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           379      ENDM
00000000                           380      
00000000                           381  ; read ide data
00000000                           382  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           383  READ_32 MACRO
00000000                           384      READ_16 \1, \2, \3
00000000                           385      LSL.L #8, \2
00000000                           386      LSL.L #8, \2
00000000                           387      READ_16 \1, \2, \3
00000000                           388      ENDM
00000000                           389          
00000000                           390  ; read ide status
00000000                           391  ;\1 = data register for result, \2 = working data register 
00000000                           392  READ_IDE_STATUS MACRO   
00000000                           393      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           394      ENDM
00000000                           395      
00000000                           396  ; wait for ide drive to be ready
00000000                           397  ;\1 = working data register 1, \2 = working data register 2
00000000                           398  WAIT_DRIVE_READY MACRO
00000000                           399  LOOP\@
00000000                           400      READ_IDE_STATUS \1, \2
00000000                           401      BTST #IDE_STATUS_READY, \1
00000000                           402      BEQ LOOP\@
00000000                           403      ENDM
00000000                           404      
00000000                           405  ; wait for ide drive to be not busy
00000000                           406  ;\1 = working data register 1, \2 = working data register 2
00000000                           407  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           408  LOOP\@
00000000                           409      READ_IDE_STATUS \1, \2
00000000                           410      BTST #IDE_STATUS_BUSY, \1
00000000                           411      BNE LOOP\@
00000000                           412      ENDM
00000000                           413      
00000000                           414  ; wait for ide drive to have data for us
00000000                           415  ;\1 = working data register 1, \2 = working data register 2
00000000                           416  WAIT_DRIVE_DRQ MACRO
00000000                           417  LOOP\@
00000000                           418      READ_IDE_STATUS \1, \2
00000000                           419      BTST #IDE_STATUS_DRQ, \1
00000000                           420      BEQ LOOP\@
00000000                           421      ENDM
00000000                           422      
00000000                           423  ; prepare to send a read command
00000000                           424  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           425  SET_READ_ADDRESS MACRO
00000000                           426      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           427      MOVE.L \1,\3
00000000                           428      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           429      LSR.L #8, \3
00000000                           430      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           431      LSR.L #8, \3                                
00000000                           432      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           433      LSR.L #8, \3
00000000                           434      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           435      ANDI.B #$0F,\3
00000000                           436      OR.B \3,\4
00000000                           437      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           438      ENDM
00000000                           439  
00000000                           440  ; send command
00000000                           441  ; \1 = command, \2 = working data register 1,
00000000                           442  SEND_COMMAND MACRO
00000000                           443      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           444      ENDM
00000000                           445      
00000000                           446  ; send read command and wait
00000000                           447  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           448  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           449      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           450      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           451      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           452      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           453      WAIT_DRIVE_DRQ \2, \3
00000000                           454      ENDM
00000000                           455  
00000000                           456  ; register catalogue
00000000                           457  ; D0 - used for simulator I/O
00000000                           458  ; D1 - used for simulator I/O
00000000                           459  ; D2 - read character
00000000                           460  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           461  ; D6 - working register used in R/W
00000000                           462  ; D7 - address accumulator, reset by download
00000000                           463  ; A0 - address of string to print 
00000000                           464  
00000000                           465  ; start vector
00000000= 002E0000                 466  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 467  RESET   DC.L START                              ; RESET
00000008= 00001BF2                 468  VECS    DC.L BUS_ERROR_HANDLER                  ; BUS ERROR
0000000C= 00001BF2                 469          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 00001D46                 470          DC.L ILLEGAL_HANDLER                    ; ILLEGAL INSTRUCTION
00000014= 00001D56                 471          DC.L UNHANDLED_HANDLER
00000018= 00001D56                 472          DC.L UNHANDLED_HANDLER
0000001C= 00001D56                 473          DC.L UNHANDLED_HANDLER
00000020= 00001D56                 474          DC.L UNHANDLED_HANDLER
00000024= 00001D56                 475          DC.L UNHANDLED_HANDLER
00000028= 00001D56                 476          DC.L UNHANDLED_HANDLER
0000002C= 00001D56                 477          DC.L UNHANDLED_HANDLER
00000030= 00001D56                 478          DC.L UNHANDLED_HANDLER
00000034= 00001D56                 479          DC.L UNHANDLED_HANDLER
00000038= 00001D56                 480          DC.L UNHANDLED_HANDLER
0000003C= 00001D56                 481          DC.L UNHANDLED_HANDLER
00000040= 00001D56                 482          DC.L UNHANDLED_HANDLER
00000044= 00001D56                 483          DC.L UNHANDLED_HANDLER
00000048= 00001D56                 484          DC.L UNHANDLED_HANDLER
0000004C= 00001D56                 485          DC.L UNHANDLED_HANDLER
00000050= 00001D56                 486          DC.L UNHANDLED_HANDLER
00000054= 00001D56                 487          DC.L UNHANDLED_HANDLER
00000058= 00001D56                 488          DC.L UNHANDLED_HANDLER
0000005C= 00001D56                 489          DC.L UNHANDLED_HANDLER
00000060= 00001D7A                 490          DC.L SPURIOUS_HANDLER
00000064= 00001D56                 491          DC.L UNHANDLED_HANDLER
00000068= 00001D56                 492          DC.L UNHANDLED_HANDLER
0000006C= 00001D56                 493          DC.L UNHANDLED_HANDLER
00000070= 00001D56                 494          DC.L UNHANDLED_HANDLER
00000074= 00001D56                 495          DC.L UNHANDLED_HANDLER
00000078= 00001D56                 496          DC.L UNHANDLED_HANDLER
0000007C= 00001D56                 497          DC.L UNHANDLED_HANDLER
00000080= 00001D56                 498          DC.L UNHANDLED_HANDLER
00000084= 00001D56                 499          DC.L UNHANDLED_HANDLER
00000088= 00001D56                 500          DC.L UNHANDLED_HANDLER
0000008C= 00001D56                 501          DC.L UNHANDLED_HANDLER
00000090= 00001D56                 502          DC.L UNHANDLED_HANDLER
00000094= 00001D56                 503          DC.L UNHANDLED_HANDLER
00000098= 00001D56                 504          DC.L UNHANDLED_HANDLER
0000009C= 00001D56                 505          DC.L UNHANDLED_HANDLER
000000A0= 00001D56                 506          DC.L UNHANDLED_HANDLER
000000A4= 00001D56                 507          DC.L UNHANDLED_HANDLER
000000A8= 00001D56                 508          DC.L UNHANDLED_HANDLER
000000AC= 00001D56                 509          DC.L UNHANDLED_HANDLER
000000B0= 00001D56                 510          DC.L UNHANDLED_HANDLER
000000B4= 00001D56                 511          DC.L UNHANDLED_HANDLER
000000B8= 00001D56                 512          DC.L UNHANDLED_HANDLER
000000BC= 00001D56                 513          DC.L UNHANDLED_HANDLER
000000C0= 00001D56                 514          DC.L UNHANDLED_HANDLER
000000C4= 00001D56                 515          DC.L UNHANDLED_HANDLER
000000C8= 00001D56                 516          DC.L UNHANDLED_HANDLER
000000CC= 00001D56                 517          DC.L UNHANDLED_HANDLER
000000D0= 00001D56                 518          DC.L UNHANDLED_HANDLER
000000D4= 00001D56                 519          DC.L UNHANDLED_HANDLER
000000D8= 00001D56                 520          DC.L UNHANDLED_HANDLER 
000000DC= 00001D56                 521          DC.L UNHANDLED_HANDLER
000000E0= 00001D56                 522          DC.L UNHANDLED_HANDLER
000000E4= 00001D56                 523          DC.L UNHANDLED_HANDLER 
000000E8= 00001D56                 524          DC.L UNHANDLED_HANDLER 
000000EC= 00001D56                 525          DC.L UNHANDLED_HANDLER
000000F0= 00001D56                 526          DC.L UNHANDLED_HANDLER 
000000F4= 00001D56                 527          DC.L UNHANDLED_HANDLER 
000000F8= 00001D56                 528          DC.L UNHANDLED_HANDLER 
000000FC= 00001D56                 529          DC.L UNHANDLED_HANDLER
00000100= 00001D6A                 530  USER    DC.L TICK_HANDLER
00000104                           531      ; start of program  
00000104                           532  START
00000104  2E7C 002E0000            533      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       534      MOVE.B #0,DISPLAY
00000112                           535  
00000112  7000                     536      MOVE.L #0,D0
00000114  1039 00C00019            537      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           538  
0000011A                           539  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       540      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       541      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           542      
0000012A                           543      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                544s     MOVE.W  #$50,D1
0000012E  6000 000E                545s     BRA _20000001
00000132                           546s _20000000
00000132  13C1 00C00005            547          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     548          NOP
0000013A                           549      ENDF
0000013A  0441 0010                550s     SUB.W   #$10,D1
0000013E                           551s _20000001
0000013E  B27C 0010                552s     CMP.W   #$10,D1
00000142  6CEE                     553s     BGE _20000000
00000144                           554  
00000144                           555      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                556s     MOVE.W  #$50,D1
00000148  6000 000E                557s     BRA _20000003
0000014C                           558s _20000002
0000014C  13C1 00C00015            559          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     560          NOP
00000154                           561      ENDF
00000154  0441 0010                562s     SUB.W   #$10,D1
00000158                           563s _20000003
00000158  B27C 0010                564s     CMP.W   #$10,D1
0000015C  6CEE                     565s     BGE _20000002
0000015E                           566      
0000015E                           567  ;initialise UART
0000015E  13FC 0000 00C0000B       568      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       569      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       570      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       571      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       572      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           573  
00000186                           574  ; channel A
00000186  13FC 0013 00C00001       575      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       576      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       577      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       578      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           579  
000001A6                           580  ; channel B
000001A6  13FC 0013 00C00011       581      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       582      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       583      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       584      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       585      MOVE.B #64,DUART_IVR
000001CE                           586  
000001CE                           587m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           588m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      589m     IFEQ DEBUG
000001CE  1239 00C00003            590m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                591m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     592m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       593m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           594m     ENDC
000001E2                           595m 
000001E2                 FALSE     596m     IFNE DEBUG
000001E2                           597m     ENDC
000001E2                           598m 
000001E2                           599m     ENDM
000001E2                           600m     PRINT_CHAR #0,D1
000001E2                           601m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      602m     IFEQ DEBUG
000001E2  1239 00C00003            603m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                604m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     605m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       606m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           607m     ENDC
000001F6                           608m 
000001F6                 FALSE     609m     IFNE DEBUG
000001F6                           610m     ENDC
000001F6                           611m 
000001F6                           612m     ENDM
000001F6                           613m     PRINT_CHAR #0,D1
000001F6                           614m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      615m     IFEQ DEBUG
000001F6  1239 00C00003            616m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                617m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     618m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       619m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           620m     ENDC
0000020A                           621m 
0000020A                 FALSE     622m     IFNE DEBUG
0000020A                           623m     ENDC
0000020A                           624m 
0000020A                           625m     ENDM
0000020A                           626      
0000020A                           627      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                628s     CMP.W   #$0F,D0
0000020E  6600 0008                629s     BNE _00000000
00000212  1039 00C00005            630          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           631      ENDI
00000218                           632s _00000000
00000218                           633  
00000218  13FC 0001 00E00001       634      MOVE.B #1,DISPLAY
00000220                           635      
00000220                           636m     PRINT_CRLF D1,A0
00000220  41FA 1DA3                637m     LEA CRLF(PC),A0
00000224                           638mm     PRINT_STR A0,D1
00000224                           639mm LOOP_5
00000224  0C10 0000                640mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                641mm     BEQ EXIT_5
0000022C                           642mmm     PRINT_CHAR (A0)+,D1
0000022C                           643mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      644mmm     IFEQ DEBUG
0000022C  1239 00C00003            645mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                646mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     647mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            648mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           649mmm     ENDC
0000023E                           650mmm 
0000023E                 FALSE     651mmm     IFNE DEBUG
0000023E                           652mmm     ENDC
0000023E                           653mmm 
0000023E                           654mmm     ENDM
0000023E  60E4                     655mm     BRA LOOP_5
00000240                           656mm EXIT_5
00000240                           657mm     ENDM
00000240                           658m     ENDM
00000240  41FA 1E38                659      LEA VERSION(PC),A0
00000244                           660m     PRINT_STR A0,D3
00000244                           661m LOOP_7
00000244  0C10 0000                662m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                663m     BEQ EXIT_7
0000024C                           664mm     PRINT_CHAR (A0)+,D3
0000024C                           665mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      666mm     IFEQ DEBUG
0000024C  1639 00C00003            667mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                668mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     669mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            670mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           671mm     ENDC
0000025E                           672mm 
0000025E                 FALSE     673mm     IFNE DEBUG
0000025E                           674mm     ENDC
0000025E                           675mm 
0000025E                           676mm     ENDM
0000025E  60E4                     677m     BRA LOOP_7
00000260                           678m EXIT_7
00000260                           679m     ENDM
00000260                           680  
00000260  41F9 00002098            681      LEA END,A0
00000266  2008                     682      MOVE.L A0,D0
00000268                           683m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1D61                684m     LEA OX(PC),A0
0000026C                           685mm     PRINT_STR A0,D1
0000026C                           686mm LOOP_10
0000026C  0C10 0000                687mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                688mm     BEQ EXIT_10
00000274                           689mmm     PRINT_CHAR (A0)+,D1
00000274                           690mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      691mmm     IFEQ DEBUG
00000274  1239 00C00003            692mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                693mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     694mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            695mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           696mmm     ENDC
00000286                           697mmm 
00000286                 FALSE     698mmm     IFNE DEBUG
00000286                           699mmm     ENDC
00000286                           700mmm 
00000286                           701mmm     ENDM
00000286  60E4                     702mm     BRA LOOP_10
00000288                           703mm EXIT_10
00000288                           704mm     ENDM
00000288  7607                     705m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           706m LOOP_9
0000028A                           707mm     BIN2HEX D0,D2,A0
0000028A  41FA 1CFE                708mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     709mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     710mm     MOVE.B D0,D2
00000292  0282 0000000F            711mm     ANDI.L #$F,D2
00000298  1430 2000                712mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           713mm     ENDM
0000029C                           714mm     PRINT_CHAR D2,D1
0000029C                           715mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      716mm     IFEQ DEBUG
0000029C  1239 00C00003            717mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                718mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     719mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            720mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           721mm     ENDC
000002AE                           722mm 
000002AE                 FALSE     723mm     IFNE DEBUG
000002AE                           724mm     ENDC
000002AE                           725mm 
000002AE                           726mm     ENDM
000002AE  57CB FFDA                727m     DBEQ D3,LOOP_9
000002B2                           728m     ENDM
000002B2                           729m     PRINT_CRLF D1,A0
000002B2  41FA 1D11                730m     LEA CRLF(PC),A0
000002B6                           731mm     PRINT_STR A0,D1
000002B6                           732mm LOOP_15
000002B6  0C10 0000                733mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                734mm     BEQ EXIT_15
000002BE                           735mmm     PRINT_CHAR (A0)+,D1
000002BE                           736mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      737mmm     IFEQ DEBUG
000002BE  1239 00C00003            738mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                739mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     740mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            741mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           742mmm     ENDC
000002D0                           743mmm 
000002D0                 FALSE     744mmm     IFNE DEBUG
000002D0                           745mmm     ENDC
000002D0                           746mmm 
000002D0                           747mmm     ENDM
000002D0  60E4                     748mm     BRA LOOP_15
000002D2                           749mm EXIT_15
000002D2                           750mm     ENDM
000002D2                           751m     ENDM
000002D2                           752  
000002D2  41FA 1ACC                753      LEA HELPPROMPT(PC),A0
000002D6                           754m     PRINT_STR A0,D3
000002D6                           755m LOOP_17
000002D6  0C10 0000                756m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                757m     BEQ EXIT_17
000002DE                           758mm     PRINT_CHAR (A0)+,D3
000002DE                           759mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      760mm     IFEQ DEBUG
000002DE  1639 00C00003            761mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                762mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     763mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            764mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           765mm     ENDC
000002F0                           766mm 
000002F0                 FALSE     767mm     IFNE DEBUG
000002F0                           768mm     ENDC
000002F0                           769mm 
000002F0                           770mm     ENDM
000002F0  60E4                     771m     BRA LOOP_17
000002F2                           772m EXIT_17
000002F2                           773m     ENDM
000002F2                           774  
000002F2                           775m     PRINT_CRLF D3,A0
000002F2  41FA 1CD1                776m     LEA CRLF(PC),A0
000002F6                           777mm     PRINT_STR A0,D3
000002F6                           778mm LOOP_20
000002F6  0C10 0000                779mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                780mm     BEQ EXIT_20
000002FE                           781mmm     PRINT_CHAR (A0)+,D3
000002FE                           782mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      783mmm     IFEQ DEBUG
000002FE  1639 00C00003            784mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                785mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     786mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            787mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           788mmm     ENDC
00000310                           789mmm 
00000310                 FALSE     790mmm     IFNE DEBUG
00000310                           791mmm     ENDC
00000310                           792mmm 
00000310                           793mmm     ENDM
00000310  60E4                     794mm     BRA LOOP_20
00000312                           795mm EXIT_20
00000312                           796mm     ENDM
00000312                           797m     ENDM
00000312                           798  
00000312  7E00                     799      MOVE.L #0,D7                                    ; address accumulator
00000314                           800  
00000314  13FC 0002 00E00001       801      MOVE.B #2,DISPLAY
0000031C                           802      
0000031C  13FC 0000 00A00001       803      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000324  13FC 0040 00A0000D       804      MOVE.B #$40, MC68230_PORT_A_CONTROL
0000032C  13FC 0040 00A0000F       805      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000334  13FC 00FF 00A00009       806      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
0000033C                           807      
0000033C  13FC 0003 00E00001       808      MOVE.B #3,DISPLAY
00000344                           809      
00000344                           810      
00000344                           811  MAIN_LOOP
00000344  41FA 1C82                812      LEA PROMPT(PC),A0
00000348                           813m     PRINT_STR A0,D3
00000348                           814m LOOP_22
00000348  0C10 0000                815m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000034C  6700 0016                816m     BEQ EXIT_22
00000350                           817mm     PRINT_CHAR (A0)+,D3
00000350                           818mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000350                 TRUE      819mm     IFEQ DEBUG
00000350  1639 00C00003            820mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000356  0803 0002                821mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000035A  67F4                     822mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
0000035C  13D8 00C00007            823mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000362                           824mm     ENDC
00000362                           825mm 
00000362                 FALSE     826mm     IFNE DEBUG
00000362                           827mm     ENDC
00000362                           828mm 
00000362                           829mm     ENDM
00000362  60E4                     830m     BRA LOOP_22
00000364                           831m EXIT_22
00000364                           832m     ENDM
00000364                           833  
00000364                           834  GET_INPUT
00000364                           835m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
00000364                           836m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000364                 TRUE      837m     IFEQ DEBUG
00000364  1639 00C00003            838m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000036A  0803 0000                839m         BTST #0,D3                                  ; CHECK FOR CHARACTER
0000036E  67F4                     840m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000370                           841m     ENDC
00000370                           842m 
00000370                           843mm     READ_CHAR D2
00000370                 TRUE      844mm     IFEQ DEBUG
00000370  1439 00C00007            845mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000376                           846mm     ENDC
00000376                 FALSE     847mm     IFNE DEBUG
00000376                           848mm     ENDC
00000376                           849mm 
00000376  B43C 001B                850mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000037A  6700 FD88                851mm     BEQ START
0000037E                           852mm     ENDM
0000037E                           853m 
0000037E                 TRUE      854m     IFEQ DEBUG
0000037E                           855mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
0000037E                           856mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000037E                 TRUE      857mm     IFEQ DEBUG
0000037E  1639 00C00003            858mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000384  0803 0002                859mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000388  67F4                     860mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
0000038A  13C2 00C00007            861mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000390                           862mm     ENDC
00000390                           863mm 
00000390                 FALSE     864mm     IFNE DEBUG
00000390                           865mm     ENDC
00000390                           866mm 
00000390                           867mm     ENDM
00000390                           868m     ENDC
00000390                           869m     ENDM
00000390                           870  
00000390                           871      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000390  B43C 0030                872s     CMP.B   #'0',D2
00000394  6D00 000E                873s     BLT _00000001
00000398  B43C 0039                874s     CMP.B   #'9',D2
0000039C  6E00 0006                875s     BGT _00000001
000003A0  6000 1836                876          BRA HEX_DIGIT
000003A4                           877      ENDI
000003A4                           878s _00000001
000003A4                           879      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
000003A4  B43C 0041                880s     CMP.B   #'A',D2
000003A8  6D00 000E                881s     BLT _00000002
000003AC  B43C 0046                882s     CMP.B   #'F',D2
000003B0  6E00 0006                883s     BGT _00000002
000003B4  6000 1822                884          BRA HEX_DIGIT
000003B8                           885      ENDI
000003B8                           886s _00000002
000003B8                           887  
000003B8  B43C 0077                888      CMP.B #'w',D2
000003BC  6700 01C6                889      BEQ W
000003C0                           890  
000003C0  B43C 006C                891      CMP.B #'l',D2
000003C4  6700 0874                892      BEQ L 
000003C8                           893  
000003C8  B43C 0070                894      CMP.B #'p',D2
000003CC  6700 0BA4                895      BEQ P
000003D0                           896  
000003D0                           897m     PRINT_CRLF D3,A0
000003D0  41FA 1BF3                898m     LEA CRLF(PC),A0
000003D4                           899mm     PRINT_STR A0,D3
000003D4                           900mm LOOP_28
000003D4  0C10 0000                901mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003D8  6700 0016                902mm     BEQ EXIT_28
000003DC                           903mmm     PRINT_CHAR (A0)+,D3
000003DC                           904mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003DC                 TRUE      905mmm     IFEQ DEBUG
000003DC  1639 00C00003            906mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003E2  0803 0002                907mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003E6  67F4                     908mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003E8  13D8 00C00007            909mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003EE                           910mmm     ENDC
000003EE                           911mmm 
000003EE                 FALSE     912mmm     IFNE DEBUG
000003EE                           913mmm     ENDC
000003EE                           914mmm 
000003EE                           915mmm     ENDM
000003EE  60E4                     916mm     BRA LOOP_28
000003F0                           917mm EXIT_28
000003F0                           918mm     ENDM
000003F0                           919m     ENDM
000003F0                           920   
000003F0  B43C 003F                921      CMP.B #'?',D2
000003F4  6700 008A                922      BEQ H
000003F8                           923   
000003F8  B43C 0076                924      CMP.B #'v',D2
000003FC  6700 008A                925      BEQ V
00000400                           926      
00000400  B43C 0072                927      CMP.B #'r',D2
00000404  6700 00A6                928      BEQ R
00000408                           929  
00000408  B43C 0073                930      CMP.B #'s',D2
0000040C  6700 01F0                931      BEQ S
00000410                           932  
00000410  B43C 0067                933      CMP.B #'g',D2
00000414  6700 072E                934      BEQ G   
00000418                           935  
00000418  B43C 007A                936      CMP.B #'z',D2
0000041C  6700 072C                937      BEQ Z   
00000420                           938  
00000420  B43C 0078                939      CMP.B #'x',D2
00000424  6700 0D1C                940      BEQ X
00000428                           941  
00000428  B43C 0049                942      CMP.B #'I',D2
0000042C  6700 0E30                943      BEQ EI
00000430                           944  
00000430  B43C 006F                945      CMP.B #'o',D2
00000434  6700 0E38                946      BEQ DI
00000438                           947  
00000438  B43C 0023                948      CMP.B #'#',D2
0000043C  6700 0E40                949      BEQ HASH
00000440                           950  
00000440  B43C 0069                951      CMP.B #'i',D2
00000444  2A7C 00000000            952      MOVE.L #0, A5               ; not boot
0000044A  6700 0E48                953      BEQ IB
0000044E                           954  
0000044E  B43C 0062                955      CMP.B #'b',D2
00000452  2A7C 00000001            956      MOVE.L #1, A5               ; boot
00000458  6700 0E3A                957      BEQ IB
0000045C                           958  
0000045C  41FA 1ACA                959      LEA HUH(PC),A0
00000460                           960m     PRINT_STR A0,D3
00000460                           961m LOOP_30
00000460  0C10 0000                962m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000464  6700 0016                963m     BEQ EXIT_30
00000468                           964mm     PRINT_CHAR (A0)+,D3
00000468                           965mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000468                 TRUE      966mm     IFEQ DEBUG
00000468  1639 00C00003            967mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000046E  0803 0002                968mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000472  67F4                     969mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000474  13D8 00C00007            970mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000047A                           971mm     ENDC
0000047A                           972mm 
0000047A                 FALSE     973mm     IFNE DEBUG
0000047A                           974mm     ENDC
0000047A                           975mm 
0000047A                           976mm     ENDM
0000047A  60E4                     977m     BRA LOOP_30
0000047C                           978m EXIT_30
0000047C                           979m     ENDM
0000047C                           980  
0000047C  6000 FEC6                981      BRA MAIN_LOOP
00000480                           982  
00000480                           983  ; commands
00000480                           984  H
00000480  41FA 1931                985      LEA HELP(PC),A0
00000484  6000 0006                986      BRA PRINTIT
00000488                           987  
00000488                           988  V
00000488  41FA 1BF0                989      LEA VERSION(PC),A0
0000048C                           990  PRINTIT
0000048C                           991m     PRINT_STR A0,D3    
0000048C                           992m LOOP_32
0000048C  0C10 0000                993m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000490  6700 0016                994m     BEQ EXIT_32
00000494                           995mm     PRINT_CHAR (A0)+,D3
00000494                           996mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000494                 TRUE      997mm     IFEQ DEBUG
00000494  1639 00C00003            998mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000049A  0803 0002                999mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000049E  67F4                    1000mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
000004A0  13D8 00C00007           1001mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004A6                          1002mm     ENDC
000004A6                          1003mm 
000004A6                 FALSE    1004mm     IFNE DEBUG
000004A6                          1005mm     ENDC
000004A6                          1006mm 
000004A6                          1007mm     ENDM
000004A6  60E4                    1008m     BRA LOOP_32
000004A8                          1009m EXIT_32
000004A8                          1010m     ENDM
000004A8  6000 FE9A               1011      BRA MAIN_LOOP
000004AC                          1012  
000004AC                          1013  R
000004AC  2047                    1014      MOVE.L D7,A0                                    ; address accumulator -> address register
000004AE  7E00                    1015      MOVE.L #0,D7                                    ;clear the now used address accumulator
000004B0  2410                    1016      MOVE.L (A0),D2                                  ; read the memory and print it
000004B2                          1017m     PRINT_REG D2,D3,D4,D5,A0
000004B2  41FA 1B17               1018m     LEA OX(PC),A0
000004B6                          1019mm     PRINT_STR A0,D3
000004B6                          1020mm LOOP_35
000004B6  0C10 0000               1021mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004BA  6700 0016               1022mm     BEQ EXIT_35
000004BE                          1023mmm     PRINT_CHAR (A0)+,D3
000004BE                          1024mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                 TRUE     1025mmm     IFEQ DEBUG
000004BE  1639 00C00003           1026mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004C4  0803 0002               1027mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C8  67F4                    1028mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
000004CA  13D8 00C00007           1029mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000004D0                          1030mmm     ENDC
000004D0                          1031mmm 
000004D0                 FALSE    1032mmm     IFNE DEBUG
000004D0                          1033mmm     ENDC
000004D0                          1034mmm 
000004D0                          1035mmm     ENDM
000004D0  60E4                    1036mm     BRA LOOP_35
000004D2                          1037mm EXIT_35
000004D2                          1038mm     ENDM
000004D2  7A07                    1039m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000004D4                          1040m LOOP_34
000004D4                          1041mm     BIN2HEX D2,D4,A0
000004D4  41FA 1AB4               1042mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000004D8  E99A                    1043mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000004DA  1802                    1044mm     MOVE.B D2,D4
000004DC  0284 0000000F           1045mm     ANDI.L #$F,D4
000004E2  1830 4000               1046mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004E6                          1047mm     ENDM
000004E6                          1048mm     PRINT_CHAR D4,D3
000004E6                          1049mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E6                 TRUE     1050mm     IFEQ DEBUG
000004E6  1639 00C00003           1051mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004EC  0803 0002               1052mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004F0  67F4                    1053mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004F2  13C4 00C00007           1054mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F8                          1055mm     ENDC
000004F8                          1056mm 
000004F8                 FALSE    1057mm     IFNE DEBUG
000004F8                          1058mm     ENDC
000004F8                          1059mm 
000004F8                          1060mm     ENDM
000004F8  57CD FFDA               1061m     DBEQ D5,LOOP_34
000004FC                          1062m     ENDM
000004FC                          1063      
000004FC                          1064m     PRINT_CHAR #32,D3
000004FC                          1065m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FC                 TRUE     1066m     IFEQ DEBUG
000004FC  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000502  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000506  67F4                    1069m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000508  13FC 0020 00C00007      1070m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
00000510                          1071m     ENDC
00000510                          1072m 
00000510                 FALSE    1073m     IFNE DEBUG
00000510                          1074m     ENDC
00000510                          1075m 
00000510                          1076m     ENDM
00000510                          1077  
00000510  E19A                    1078      ROL.L #8,D2
00000512                          1079m     PRINT_CHAR D2,D3
00000512                          1080m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000512                 TRUE     1081m     IFEQ DEBUG
00000512  1639 00C00003           1082m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000518  0803 0002               1083m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000051C  67F4                    1084m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
0000051E  13C2 00C00007           1085m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000524                          1086m     ENDC
00000524                          1087m 
00000524                 FALSE    1088m     IFNE DEBUG
00000524                          1089m     ENDC
00000524                          1090m 
00000524                          1091m     ENDM
00000524  E19A                    1092      ROL.L #8,D2
00000526                          1093m     PRINT_CHAR D2,D3
00000526                          1094m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000526                 TRUE     1095m     IFEQ DEBUG
00000526  1639 00C00003           1096m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052C  0803 0002               1097m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000530  67F4                    1098m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
00000532  13C2 00C00007           1099m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000538                          1100m     ENDC
00000538                          1101m 
00000538                 FALSE    1102m     IFNE DEBUG
00000538                          1103m     ENDC
00000538                          1104m 
00000538                          1105m     ENDM
00000538  E19A                    1106      ROL.L #8,D2
0000053A                          1107m     PRINT_CHAR D2,D3
0000053A                          1108m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000053A                 TRUE     1109m     IFEQ DEBUG
0000053A  1639 00C00003           1110m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000540  0803 0002               1111m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000544  67F4                    1112m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000546  13C2 00C00007           1113m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000054C                          1114m     ENDC
0000054C                          1115m 
0000054C                 FALSE    1116m     IFNE DEBUG
0000054C                          1117m     ENDC
0000054C                          1118m 
0000054C                          1119m     ENDM
0000054C  E19A                    1120      ROL.L #8,D2
0000054E                          1121m     PRINT_CHAR D2,D3
0000054E                          1122m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054E                 TRUE     1123m     IFEQ DEBUG
0000054E  1639 00C00003           1124m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000554  0803 0002               1125m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000558  67F4                    1126m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
0000055A  13C2 00C00007           1127m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000560                          1128m     ENDC
00000560                          1129m 
00000560                 FALSE    1130m     IFNE DEBUG
00000560                          1131m     ENDC
00000560                          1132m 
00000560                          1133m     ENDM
00000560                          1134  
00000560                          1135m     PRINT_CRLF D3,A0
00000560  41FA 1A63               1136m     LEA CRLF(PC),A0
00000564                          1137mm     PRINT_STR A0,D3
00000564                          1138mm LOOP_45
00000564  0C10 0000               1139mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000568  6700 0016               1140mm     BEQ EXIT_45
0000056C                          1141mmm     PRINT_CHAR (A0)+,D3
0000056C                          1142mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056C                 TRUE     1143mmm     IFEQ DEBUG
0000056C  1639 00C00003           1144mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000572  0803 0002               1145mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000576  67F4                    1146mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000578  13D8 00C00007           1147mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000057E                          1148mmm     ENDC
0000057E                          1149mmm 
0000057E                 FALSE    1150mmm     IFNE DEBUG
0000057E                          1151mmm     ENDC
0000057E                          1152mmm 
0000057E                          1153mmm     ENDM
0000057E  60E4                    1154mm     BRA LOOP_45
00000580                          1155mm EXIT_45
00000580                          1156mm     ENDM
00000580                          1157m     ENDM
00000580                          1158      
00000580  6000 FDC2               1159      BRA MAIN_LOOP
00000584                          1160  
00000584                          1161  W
00000584                          1162      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000584  3C3C 0000               1163s     MOVE.W  #0,D6
00000588  6000 0046               1164s     BRA _20000005
0000058C                          1165s _20000004
0000058C  E98D                    1166          LSL.L #4,D5                                     ; make what we have so far more significant
0000058E                          1167m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000058E                          1168m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058E                 TRUE     1169m     IFEQ DEBUG
0000058E  1639 00C00003           1170m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000594  0803 0000               1171m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000598  67F4                    1172m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
0000059A                          1173m     ENDC
0000059A                          1174m 
0000059A                          1175mm     READ_CHAR D2
0000059A                 TRUE     1176mm     IFEQ DEBUG
0000059A  1439 00C00007           1177mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000005A0                          1178mm     ENDC
000005A0                 FALSE    1179mm     IFNE DEBUG
000005A0                          1180mm     ENDC
000005A0                          1181mm 
000005A0  B43C 001B               1182mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000005A4  6700 FB5E               1183mm     BEQ START
000005A8                          1184mm     ENDM
000005A8                          1185m 
000005A8                 TRUE     1186m     IFEQ DEBUG
000005A8                          1187mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000005A8                          1188mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005A8                 TRUE     1189mm     IFEQ DEBUG
000005A8  1639 00C00003           1190mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005AE  0803 0002               1191mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B2  67F4                    1192mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
000005B4  13C2 00C00007           1193mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000005BA                          1194mm     ENDC
000005BA                          1195mm 
000005BA                 FALSE    1196mm     IFNE DEBUG
000005BA                          1197mm     ENDC
000005BA                          1198mm 
000005BA                          1199mm     ENDM
000005BA                          1200m     ENDC
000005BA                          1201m     ENDM
000005BA                          1202m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
000005BA  41FA 19DE               1203m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000005BE  0402 0030               1204m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000005C2  C4BC 000000FF           1205m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
000005C8  1430 2000               1206m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
000005CC                          1207m     ENDM
000005CC  8A02                    1208          OR.B D2,D5
000005CE                          1209      ENDF
000005CE  5246                    1210s     ADD.W   #1,D6
000005D0                          1211s _20000005
000005D0  BC7C 0007               1212s     CMP.W   #7,D6
000005D4  6FB6                    1213s     BLE _20000004
000005D6                          1214  
000005D6                          1215m     PRINT_CRLF D3,A0
000005D6  41FA 19ED               1216m     LEA CRLF(PC),A0
000005DA                          1217mm     PRINT_STR A0,D3
000005DA                          1218mm LOOP_52
000005DA  0C10 0000               1219mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005DE  6700 0016               1220mm     BEQ EXIT_52
000005E2                          1221mmm     PRINT_CHAR (A0)+,D3
000005E2                          1222mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005E2                 TRUE     1223mmm     IFEQ DEBUG
000005E2  1639 00C00003           1224mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005E8  0803 0002               1225mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005EC  67F4                    1226mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005EE  13D8 00C00007           1227mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005F4                          1228mmm     ENDC
000005F4                          1229mmm 
000005F4                 FALSE    1230mmm     IFNE DEBUG
000005F4                          1231mmm     ENDC
000005F4                          1232mmm 
000005F4                          1233mmm     ENDM
000005F4  60E4                    1234mm     BRA LOOP_52
000005F6                          1235mm EXIT_52
000005F6                          1236mm     ENDM
000005F6                          1237m     ENDM
000005F6                          1238  
000005F6  2047                    1239      MOVE.L D7,A0                                    ; address accumulator -> address register
000005F8                          1240  
000005F8  2085                    1241      MOVE.L D5,(A0)                                  ; write the data
000005FA                          1242  
000005FA  6000 FD48               1243      BRA MAIN_LOOP
000005FE                          1244  
000005FE                          1245  ; register map for S
000005FE                          1246  ; A0 - start address
000005FE                          1247  ; A1 - offset
000005FE                          1248  ; A2 - next address to write
000005FE                          1249  ; A3 - next location (jmp)
000005FE                          1250  ; A4 - Working Address Register
000005FE                          1251  ; D0 - record count
000005FE                          1252  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005FE                          1253  ; D2 - checksum
000005FE                          1254  ; D3 - data byte count
000005FE                          1255  ; D4 - read address, moved into A2
000005FE                          1256  ; D5 - temp
000005FE                          1257  ; D6 - temp
000005FE                          1258  ; D7 - temp
000005FE                          1259  S
000005FE  2078 0000               1260      MOVE.L 0,A0                                     ; start address -> A0
00000602  2247                    1261      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000604  7E00                    1262      MOVE.L #0,D7
00000606  7000                    1263      MOVE.L #0,D0                                    ; count of records read -> D0
00000608                          1264          
00000608                          1265  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000608                          1266m     DOWNLOAD D1
00000608                          1267m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000608                          1268m 
00000608                          1269m ;   MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000608                          1270m ;   BTST #0,D1                                      ; CHECK FOR CHARACTER
00000608                          1271m ;   BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000608                          1272m 
00000608                          1273m ;   READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000608                          1274m CONTINUE_54
00000608                          1275m ;   MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000608  1239 00C00003           1276m     MOVE.B DUART_SRA,D1                             ; READ DOWNLOAD STATUS REGISTER
0000060E  0801 0000               1277m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000612  67F4                    1278m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
00000614                          1279m     
00000614                          1280m ;   MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000614  1239 00C00007           1281m     MOVE.B DUART_RXA,D1                             ; GOT A CHARACTER, READ IT
0000061A  13C1 00E00001           1282m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000620                          1283m 
00000620                          1284m     ENDM
00000620  B23C 0053               1285      CMP.B #'S',D1                                   ; found S?
00000624  66E2                    1286      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
00000626                          1287      
00000626                          1288m     PRINT_CHAR #'.',D5                              ; print a progress indicator
00000626                          1289m WAIT_FOR_READY_55                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000626                 TRUE     1290m     IFEQ DEBUG
00000626  1A39 00C00003           1291m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000062C  0805 0002               1292m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000630  67F4                    1293m         BEQ WAIT_FOR_READY_55                       ; NO SPACE, CHECK AGAIN
00000632  13FC 002E 00C00007      1294m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
0000063A                          1295m     ENDC
0000063A                          1296m 
0000063A                 FALSE    1297m     IFNE DEBUG
0000063A                          1298m     ENDC
0000063A                          1299m 
0000063A                          1300m     ENDM
0000063A                          1301      ;PRINT_CHAR #'S',D5                             ; print the S
0000063A  5280                    1302      ADD.L #1,D0                                     ; read another S record, increment count
0000063C                          1303      
0000063C                          1304m     DOWNLOAD D1                                     ; read the record identifier and echo it back
0000063C                          1305m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000063C                          1306m 
0000063C                          1307m ;   MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000063C                          1308m ;   BTST #0,D1                                      ; CHECK FOR CHARACTER
0000063C                          1309m ;   BEQ CONTINUE_56                                 ; NOTHING, CONTINUE
0000063C                          1310m 
0000063C                          1311m ;   READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
0000063C                          1312m CONTINUE_56
0000063C                          1313m ;   MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
0000063C  1239 00C00003           1314m     MOVE.B DUART_SRA,D1                             ; READ DOWNLOAD STATUS REGISTER
00000642  0801 0000               1315m     BTST #0,D1                                      ; CHECK FOR CHARACTER
00000646  67F4                    1316m     BEQ WAIT_FOR_READY_56                           ; NOTHING, CHECK AGAIN
00000648                          1317m     
00000648                          1318m ;   MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000648  1239 00C00007           1319m     MOVE.B DUART_RXA,D1                             ; GOT A CHARACTER, READ IT
0000064E  13C1 00E00001           1320m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000654                          1321m 
00000654                          1322m     ENDM
00000654                          1323      ;PRINT_CHAR D1,D5
00000654                          1324  
00000654  7400                    1325      MOVE.L #0,D2                                    ; clear the checksum
00000656                          1326  
00000656                          1327m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
00000656  1E3C 0002               1328m     MOVE.B #2,D7
0000065A                          1329m     WHILE.B D7 <GT> 0 DO
0000065A                          1330ms _10000000
0000065A  BE38 0000               1331ms     CMP.B   0,D7
0000065E  6F00 0034               1332ms     BLE _10000001
00000662  E98B                    1333m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000664                          1334mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000664                          1335mm WAIT_FOR_READY_58                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000664                          1336mm 
00000664                          1337mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000664                          1338mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
00000664                          1339mm ;   BEQ CONTINUE_58                                 ; NOTHING, CONTINUE
00000664                          1340mm 
00000664                          1341mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000664                          1342mm CONTINUE_58
00000664                          1343mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000664  1A39 00C00003           1344mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
0000066A  0805 0000               1345mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000066E  67F4                    1346mm     BEQ WAIT_FOR_READY_58                           ; NOTHING, CHECK AGAIN
00000670                          1347mm     
00000670                          1348mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000670  1A39 00C00007           1349mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000676  13C5 00E00001           1350mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000067C                          1351mm 
0000067C                          1352mm     ENDM
0000067C                          1353m         ;PRINT_CHAR D5,D6
0000067C                          1354mm         HEX2BIN D5,D5,A4
0000067C  49FA 191C               1355mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000680  0405 0030               1356mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000684  CABC 000000FF           1357mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000068A  1A34 5000               1358mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000068E                          1359mm     ENDM
0000068E  8605                    1360m         OR.B D5,D3
00000690  5307                    1361m         SUB.B #1,D7
00000692                          1362m     ENDW
00000692  60C6                    1363ms     BRA _10000000
00000694                          1364ms _10000001
00000694                          1365m 
00000694  7A00                    1366m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000696  1A03                    1367m     MOVE.B D3,D5
00000698  D483                    1368m     ADD.L D3,D2
0000069A                          1369m 
0000069A                          1370m     ENDM
0000069A                          1371  
0000069A                          1372      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000069A  B23C 0030               1373s     CMP.B   #'0',D1
0000069E  6600 000A               1374s     BNE.L   _00000003
000006A2                          1375          ;PRINT_CRLF D5,A4
000006A2  6000 FF64               1376          BRA WAIT_FOR_SRECORD
000006A6                          1377      ELSE
000006A6  6000 029C               1378s     BRA _00000004
000006AA                          1379s _00000003
000006AA                          1380          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006AA  B23C 0031               1381s     CMP.B   #'1',D1
000006AE  6708                    1382s     BEQ.S   _00000005
000006B0  B23C 0032               1383s     CMP.B   #'2',D1
000006B4  6600 0138               1384s     BNE.L   _00000006
000006B8                          1385s _00000005
000006B8  5783                    1386              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000006BA                          1387  
000006BA  7800                    1388              MOVE.L #0,D4                            ; read two bytes of address
000006BC                          1389m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000006BC  1E3C 0002               1390m     MOVE.B #2,D7
000006C0                          1391m     WHILE.B D7 <GT> 0 DO
000006C0                          1392ms _10000002
000006C0  BE38 0000               1393ms     CMP.B   0,D7
000006C4  6F00 0034               1394ms     BLE _10000003
000006C8  E98C                    1395m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000006CA                          1396mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000006CA                          1397mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006CA                          1398mm 
000006CA                          1399mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000006CA                          1400mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
000006CA                          1401mm ;   BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
000006CA                          1402mm 
000006CA                          1403mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000006CA                          1404mm CONTINUE_61
000006CA                          1405mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000006CA  1A39 00C00003           1406mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000006D0  0805 0000               1407mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000006D4  67F4                    1408mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
000006D6                          1409mm     
000006D6                          1410mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000006D6  1A39 00C00007           1411mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000006DC  13C5 00E00001           1412mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000006E2                          1413mm 
000006E2                          1414mm     ENDM
000006E2                          1415m         ;PRINT_CHAR D5,D6
000006E2                          1416mm         HEX2BIN D5,D5,A4
000006E2  49FA 18B6               1417mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006E6  0405 0030               1418mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006EA  CABC 000000FF           1419mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006F0  1A34 5000               1420mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006F4                          1421mm     ENDM
000006F4  8805                    1422m         OR.B D5,D4
000006F6  5307                    1423m         SUB.B #1,D7
000006F8                          1424m     ENDW
000006F8  60C6                    1425ms     BRA _10000002
000006FA                          1426ms _10000003
000006FA                          1427m 
000006FA  7A00                    1428m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006FC  1A04                    1429m     MOVE.B D4,D5
000006FE  D484                    1430m     ADD.L D4,D2
00000700                          1431m 
00000700                          1432m     ENDM
00000700                          1433m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000700  1E3C 0002               1434m     MOVE.B #2,D7
00000704                          1435m     WHILE.B D7 <GT> 0 DO
00000704                          1436ms _10000004
00000704  BE38 0000               1437ms     CMP.B   0,D7
00000708  6F00 0034               1438ms     BLE _10000005
0000070C  E98C                    1439m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000070E                          1440mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000070E                          1441mm WAIT_FOR_READY_64                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000070E                          1442mm 
0000070E                          1443mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000070E                          1444mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000070E                          1445mm ;   BEQ CONTINUE_64                                 ; NOTHING, CONTINUE
0000070E                          1446mm 
0000070E                          1447mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000070E                          1448mm CONTINUE_64
0000070E                          1449mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000070E  1A39 00C00003           1450mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000714  0805 0000               1451mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000718  67F4                    1452mm     BEQ WAIT_FOR_READY_64                           ; NOTHING, CHECK AGAIN
0000071A                          1453mm     
0000071A                          1454mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000071A  1A39 00C00007           1455mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000720  13C5 00E00001           1456mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000726                          1457mm 
00000726                          1458mm     ENDM
00000726                          1459m         ;PRINT_CHAR D5,D6
00000726                          1460mm         HEX2BIN D5,D5,A4
00000726  49FA 1872               1461mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000072A  0405 0030               1462mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000072E  CABC 000000FF           1463mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000734  1A34 5000               1464mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000738                          1465mm     ENDM
00000738  8805                    1466m         OR.B D5,D4
0000073A  5307                    1467m         SUB.B #1,D7
0000073C                          1468m     ENDW
0000073C  60C6                    1469ms     BRA _10000004
0000073E                          1470ms _10000005
0000073E                          1471m 
0000073E  7A00                    1472m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000740  1A04                    1473m     MOVE.B D4,D5
00000742  D484                    1474m     ADD.L D4,D2
00000744                          1475m 
00000744                          1476m     ENDM
00000744                          1477  
00000744                          1478              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000744  B23C 0032               1479s     CMP.B   #'2',D1
00000748  6600 0048               1480s     BNE.L   _00000007
0000074C  5383                    1481                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
0000074E                          1482m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
0000074E  1E3C 0002               1483m     MOVE.B #2,D7
00000752                          1484m     WHILE.B D7 <GT> 0 DO
00000752                          1485ms _10000006
00000752  BE38 0000               1486ms     CMP.B   0,D7
00000756  6F00 0034               1487ms     BLE _10000007
0000075A  E98C                    1488m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000075C                          1489mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000075C                          1490mm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000075C                          1491mm 
0000075C                          1492mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000075C                          1493mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000075C                          1494mm ;   BEQ CONTINUE_67                                 ; NOTHING, CONTINUE
0000075C                          1495mm 
0000075C                          1496mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000075C                          1497mm CONTINUE_67
0000075C                          1498mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000075C  1A39 00C00003           1499mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000762  0805 0000               1500mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000766  67F4                    1501mm     BEQ WAIT_FOR_READY_67                           ; NOTHING, CHECK AGAIN
00000768                          1502mm     
00000768                          1503mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000768  1A39 00C00007           1504mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
0000076E  13C5 00E00001           1505mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000774                          1506mm 
00000774                          1507mm     ENDM
00000774                          1508m         ;PRINT_CHAR D5,D6
00000774                          1509mm         HEX2BIN D5,D5,A4
00000774  49FA 1824               1510mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000778  0405 0030               1511mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000077C  CABC 000000FF           1512mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000782  1A34 5000               1513mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000786                          1514mm     ENDM
00000786  8805                    1515m         OR.B D5,D4
00000788  5307                    1516m         SUB.B #1,D7
0000078A                          1517m     ENDW
0000078A  60C6                    1518ms     BRA _10000006
0000078C                          1519ms _10000007
0000078C                          1520m 
0000078C  7A00                    1521m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000078E  1A04                    1522m     MOVE.B D4,D5
00000790  D484                    1523m     ADD.L D4,D2
00000792                          1524m 
00000792                          1525m     ENDM
00000792                          1526              ENDI
00000792                          1527s _00000007
00000792                          1528  
00000792  2444                    1529              MOVE.L D4,A2                            ; put the address in an address register
00000794  D5C9                    1530              ADD.L A1,A2                             ; add in the offset
00000796                          1531  
00000796                          1532              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000796                          1533s _10000008
00000796  B63C 0000               1534s     CMP.B   #0,D3
0000079A  6F00 004C               1535s     BLE _10000009
0000079E                          1536m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
0000079E  1E3C 0002               1537m     MOVE.B #2,D7
000007A2                          1538m     WHILE.B D7 <GT> 0 DO
000007A2                          1539ms _1000000A
000007A2  BE38 0000               1540ms     CMP.B   0,D7
000007A6  6F00 0034               1541ms     BLE _1000000B
000007AA  E989                    1542m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
000007AC                          1543mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000007AC                          1544mm WAIT_FOR_READY_70                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007AC                          1545mm 
000007AC                          1546mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000007AC                          1547mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
000007AC                          1548mm ;   BEQ CONTINUE_70                                 ; NOTHING, CONTINUE
000007AC                          1549mm 
000007AC                          1550mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000007AC                          1551mm CONTINUE_70
000007AC                          1552mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007AC  1A39 00C00003           1553mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
000007B2  0805 0000               1554mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007B6  67F4                    1555mm     BEQ WAIT_FOR_READY_70                           ; NOTHING, CHECK AGAIN
000007B8                          1556mm     
000007B8                          1557mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007B8  1A39 00C00007           1558mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000007BE  13C5 00E00001           1559mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007C4                          1560mm 
000007C4                          1561mm     ENDM
000007C4                          1562m         ;PRINT_CHAR D5,D6
000007C4                          1563mm         HEX2BIN D5,D5,A4
000007C4  49FA 17D4               1564mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007C8  0405 0030               1565mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007CC  CABC 000000FF           1566mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007D2  1A34 5000               1567mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007D6                          1568mm     ENDM
000007D6  8205                    1569m         OR.B D5,D1
000007D8  5307                    1570m         SUB.B #1,D7
000007DA                          1571m     ENDW
000007DA  60C6                    1572ms     BRA _1000000A
000007DC                          1573ms _1000000B
000007DC                          1574m 
000007DC  7A00                    1575m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007DE  1A01                    1576m     MOVE.B D1,D5
000007E0  D481                    1577m     ADD.L D1,D2
000007E2                          1578m 
000007E2                          1579m     ENDM
000007E2                          1580   
000007E2  14C1                    1581                  MOVE.B D1,(A2)+                     ; store it!
000007E4                          1582  
000007E4  5303                    1583                  SUB.B #1,D3                         ; 1 less byte to go
000007E6                          1584              ENDW
000007E6  60AE                    1585s     BRA _10000008
000007E8                          1586s _10000009
000007E8                          1587  
000007E8  7200                    1588              MOVE.L #0,D1                            ; not done yet
000007EA                          1589          ELSE
000007EA  6000 0158               1590s     BRA _00000008
000007EE                          1591s _00000006
000007EE                          1592              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000007EE  B23C 0038               1593s     CMP.B   #'8',D1
000007F2  6600 00DA               1594s     BNE.L   _00000009
000007F6  7800                    1595                  MOVE.L #0,D4                        ; read the 24 bit start address
000007F8                          1596m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
000007F8  1E3C 0002               1597m     MOVE.B #2,D7
000007FC                          1598m     WHILE.B D7 <GT> 0 DO
000007FC                          1599ms _1000000C
000007FC  BE38 0000               1600ms     CMP.B   0,D7
00000800  6F00 0034               1601ms     BLE _1000000D
00000804  E98C                    1602m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000806                          1603mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000806                          1604mm WAIT_FOR_READY_73                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000806                          1605mm 
00000806                          1606mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000806                          1607mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
00000806                          1608mm ;   BEQ CONTINUE_73                                 ; NOTHING, CONTINUE
00000806                          1609mm 
00000806                          1610mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000806                          1611mm CONTINUE_73
00000806                          1612mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000806  1A39 00C00003           1613mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
0000080C  0805 0000               1614mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000810  67F4                    1615mm     BEQ WAIT_FOR_READY_73                           ; NOTHING, CHECK AGAIN
00000812                          1616mm     
00000812                          1617mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000812  1A39 00C00007           1618mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000818  13C5 00E00001           1619mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000081E                          1620mm 
0000081E                          1621mm     ENDM
0000081E                          1622m         ;PRINT_CHAR D5,D6
0000081E                          1623mm         HEX2BIN D5,D5,A4
0000081E  49FA 177A               1624mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000822  0405 0030               1625mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000826  CABC 000000FF           1626mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000082C  1A34 5000               1627mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000830                          1628mm     ENDM
00000830  8805                    1629m         OR.B D5,D4
00000832  5307                    1630m         SUB.B #1,D7
00000834                          1631m     ENDW
00000834  60C6                    1632ms     BRA _1000000C
00000836                          1633ms _1000000D
00000836                          1634m 
00000836  7A00                    1635m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000838  1A04                    1636m     MOVE.B D4,D5
0000083A  D484                    1637m     ADD.L D4,D2
0000083C                          1638m 
0000083C                          1639m     ENDM
0000083C                          1640m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
0000083C  1E3C 0002               1641m     MOVE.B #2,D7
00000840                          1642m     WHILE.B D7 <GT> 0 DO
00000840                          1643ms _1000000E
00000840  BE38 0000               1644ms     CMP.B   0,D7
00000844  6F00 0034               1645ms     BLE _1000000F
00000848  E98C                    1646m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000084A                          1647mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000084A                          1648mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000084A                          1649mm 
0000084A                          1650mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000084A                          1651mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000084A                          1652mm ;   BEQ CONTINUE_76                                 ; NOTHING, CONTINUE
0000084A                          1653mm 
0000084A                          1654mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000084A                          1655mm CONTINUE_76
0000084A                          1656mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000084A  1A39 00C00003           1657mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000850  0805 0000               1658mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000854  67F4                    1659mm     BEQ WAIT_FOR_READY_76                           ; NOTHING, CHECK AGAIN
00000856                          1660mm     
00000856                          1661mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000856  1A39 00C00007           1662mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
0000085C  13C5 00E00001           1663mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000862                          1664mm 
00000862                          1665mm     ENDM
00000862                          1666m         ;PRINT_CHAR D5,D6
00000862                          1667mm         HEX2BIN D5,D5,A4
00000862  49FA 1736               1668mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000866  0405 0030               1669mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000086A  CABC 000000FF           1670mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000870  1A34 5000               1671mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000874                          1672mm     ENDM
00000874  8805                    1673m         OR.B D5,D4
00000876  5307                    1674m         SUB.B #1,D7
00000878                          1675m     ENDW
00000878  60C6                    1676ms     BRA _1000000E
0000087A                          1677ms _1000000F
0000087A                          1678m 
0000087A  7A00                    1679m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000087C  1A04                    1680m     MOVE.B D4,D5
0000087E  D484                    1681m     ADD.L D4,D2
00000880                          1682m 
00000880                          1683m     ENDM
00000880                          1684m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000880  1E3C 0002               1685m     MOVE.B #2,D7
00000884                          1686m     WHILE.B D7 <GT> 0 DO
00000884                          1687ms _10000010
00000884  BE38 0000               1688ms     CMP.B   0,D7
00000888  6F00 0034               1689ms     BLE _10000011
0000088C  E98C                    1690m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000088E                          1691mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000088E                          1692mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088E                          1693mm 
0000088E                          1694mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000088E                          1695mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
0000088E                          1696mm ;   BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000088E                          1697mm 
0000088E                          1698mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000088E                          1699mm CONTINUE_79
0000088E                          1700mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000088E  1A39 00C00003           1701mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000894  0805 0000               1702mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000898  67F4                    1703mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
0000089A                          1704mm     
0000089A                          1705mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000089A  1A39 00C00007           1706mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
000008A0  13C5 00E00001           1707mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008A6                          1708mm 
000008A6                          1709mm     ENDM
000008A6                          1710m         ;PRINT_CHAR D5,D6
000008A6                          1711mm         HEX2BIN D5,D5,A4
000008A6  49FA 16F2               1712mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008AA  0405 0030               1713mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008AE  CABC 000000FF           1714mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008B4  1A34 5000               1715mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008B8                          1716mm     ENDM
000008B8  8805                    1717m         OR.B D5,D4
000008BA  5307                    1718m         SUB.B #1,D7
000008BC                          1719m     ENDW
000008BC  60C6                    1720ms     BRA _10000010
000008BE                          1721ms _10000011
000008BE                          1722m 
000008BE  7A00                    1723m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008C0  1A04                    1724m     MOVE.B D4,D5
000008C2  D484                    1725m     ADD.L D4,D2
000008C4                          1726m 
000008C4                          1727m     ENDM
000008C4                          1728  
000008C4  2044                    1729                  MOVE.L D4,A0                        ; start address -> A0
000008C6  D1C9                    1730                  ADD.L A1,A0                         ; add in the offset
000008C8                          1731  
000008C8  72FF                    1732                  MOVE.L #$FFFFFFFF,D1                ; done
000008CA                          1733              ELSE
000008CA  6000 0078               1734s     BRA _0000000A
000008CE                          1735s _00000009
000008CE                          1736m                 PRINT_CRLF D5,A4
000008CE  49FA 16F5               1737m     LEA CRLF(PC),A4
000008D2                          1738mm     PRINT_STR A4,D5
000008D2                          1739mm LOOP_82
000008D2  0C14 0000               1740mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008D6  6700 0016               1741mm     BEQ EXIT_82
000008DA                          1742mmm     PRINT_CHAR (A4)+,D5
000008DA                          1743mmm WAIT_FOR_READY_83                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008DA                 TRUE     1744mmm     IFEQ DEBUG
000008DA  1A39 00C00003           1745mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008E0  0805 0002               1746mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008E4  67F4                    1747mmm         BEQ WAIT_FOR_READY_83                       ; NO SPACE, CHECK AGAIN
000008E6  13DC 00C00007           1748mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000008EC                          1749mmm     ENDC
000008EC                          1750mmm 
000008EC                 FALSE    1751mmm     IFNE DEBUG
000008EC                          1752mmm     ENDC
000008EC                          1753mmm 
000008EC                          1754mmm     ENDM
000008EC  60E4                    1755mm     BRA LOOP_82
000008EE                          1756mm EXIT_82
000008EE                          1757mm     ENDM
000008EE                          1758m     ENDM
000008EE                          1759  
000008EE  49FA 1661               1760                  LEA UNREC(PC),A4                    ; warn for unrecognised type
000008F2                          1761m                 PRINT_STR A4,D5
000008F2                          1762m LOOP_84
000008F2  0C14 0000               1763m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000008F6  6700 0016               1764m     BEQ EXIT_84
000008FA                          1765mm     PRINT_CHAR (A4)+,D5
000008FA                          1766mm WAIT_FOR_READY_85                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008FA                 TRUE     1767mm     IFEQ DEBUG
000008FA  1A39 00C00003           1768mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000900  0805 0002               1769mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000904  67F4                    1770mm         BEQ WAIT_FOR_READY_85                       ; NO SPACE, CHECK AGAIN
00000906  13DC 00C00007           1771mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000090C                          1772mm     ENDC
0000090C                          1773mm 
0000090C                 FALSE    1774mm     IFNE DEBUG
0000090C                          1775mm     ENDC
0000090C                          1776mm 
0000090C                          1777mm     ENDM
0000090C  60E4                    1778m     BRA LOOP_84
0000090E                          1779m EXIT_84
0000090E                          1780m     ENDM
0000090E                          1781m                 PRINT_CHAR D1,D5
0000090E                          1782m WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000090E                 TRUE     1783m     IFEQ DEBUG
0000090E  1A39 00C00003           1784m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000914  0805 0002               1785m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000918  67F4                    1786m         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
0000091A  13C1 00C00007           1787m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000920                          1788m     ENDC
00000920                          1789m 
00000920                 FALSE    1790m     IFNE DEBUG
00000920                          1791m     ENDC
00000920                          1792m 
00000920                          1793m     ENDM
00000920                          1794m                 PRINT_CRLF D5,A4
00000920  49FA 16A3               1795m     LEA CRLF(PC),A4
00000924                          1796mm     PRINT_STR A4,D5
00000924                          1797mm LOOP_88
00000924  0C14 0000               1798mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000928  6700 0016               1799mm     BEQ EXIT_88
0000092C                          1800mmm     PRINT_CHAR (A4)+,D5
0000092C                          1801mmm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000092C                 TRUE     1802mmm     IFEQ DEBUG
0000092C  1A39 00C00003           1803mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000932  0805 0002               1804mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000936  67F4                    1805mmm         BEQ WAIT_FOR_READY_89                       ; NO SPACE, CHECK AGAIN
00000938  13DC 00C00007           1806mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000093E                          1807mmm     ENDC
0000093E                          1808mmm 
0000093E                 FALSE    1809mmm     IFNE DEBUG
0000093E                          1810mmm     ENDC
0000093E                          1811mmm 
0000093E                          1812mmm     ENDM
0000093E  60E4                    1813mm     BRA LOOP_88
00000940                          1814mm EXIT_88
00000940                          1815mm     ENDM
00000940                          1816m     ENDM
00000940                          1817  
00000940  6000 FCC6               1818                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000944                          1819              ENDI
00000944                          1820s _0000000A
00000944                          1821          ENDI
00000944                          1822s _00000008
00000944                          1823      ENDI
00000944                          1824s _00000004
00000944                          1825  
00000944                          1826m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000944  1E3C 0002               1827m     MOVE.B #2,D7
00000948                          1828m     WHILE.B D7 <GT> 0 DO
00000948                          1829ms _10000012
00000948  BE38 0000               1830ms     CMP.B   0,D7
0000094C  6F00 0034               1831ms     BLE _10000013
00000950  E98C                    1832m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000952                          1833mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000952                          1834mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000952                          1835mm 
00000952                          1836mm ;   MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000952                          1837mm ;   BTST #0,D5                                      ; CHECK FOR CHARACTER
00000952                          1838mm ;   BEQ CONTINUE_91                                 ; NOTHING, CONTINUE
00000952                          1839mm 
00000952                          1840mm ;   READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000952                          1841mm CONTINUE_91
00000952                          1842mm ;   MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000952  1A39 00C00003           1843mm     MOVE.B DUART_SRA,D5                             ; READ DOWNLOAD STATUS REGISTER
00000958  0805 0000               1844mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000095C  67F4                    1845mm     BEQ WAIT_FOR_READY_91                           ; NOTHING, CHECK AGAIN
0000095E                          1846mm     
0000095E                          1847mm ;   MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000095E  1A39 00C00007           1848mm     MOVE.B DUART_RXA,D5                             ; GOT A CHARACTER, READ IT
00000964  13C5 00E00001           1849mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000096A                          1850mm 
0000096A                          1851mm     ENDM
0000096A                          1852m         ;PRINT_CHAR D5,D6
0000096A                          1853mm         HEX2BIN D5,D5,A4
0000096A  49FA 162E               1854mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000096E  0405 0030               1855mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000972  CABC 000000FF           1856mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000978  1A34 5000               1857mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000097C                          1858mm     ENDM
0000097C  8805                    1859m         OR.B D5,D4
0000097E  5307                    1860m         SUB.B #1,D7
00000980                          1861m     ENDW
00000980  60C6                    1862ms     BRA _10000012
00000982                          1863ms _10000013
00000982                          1864m 
00000982  7A00                    1865m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000984  1A04                    1866m     MOVE.B D4,D5
00000986  D484                    1867m     ADD.L D4,D2
00000988                          1868m 
00000988                          1869m     ENDM
00000988                          1870  
00000988                          1871      IF.B D2 <NE> #$FF THEN.L
00000988  B43C 00FF               1872s     CMP.B   #$FF,D2
0000098C  6700 00B0               1873s     BEQ.L   _0000000B
00000990                          1874m         PRINT_CRLF D5,A4
00000990  49FA 1633               1875m     LEA CRLF(PC),A4
00000994                          1876mm     PRINT_STR A4,D5
00000994                          1877mm LOOP_94
00000994  0C14 0000               1878mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000998  6700 0016               1879mm     BEQ EXIT_94
0000099C                          1880mmm     PRINT_CHAR (A4)+,D5
0000099C                          1881mmm WAIT_FOR_READY_95                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000099C                 TRUE     1882mmm     IFEQ DEBUG
0000099C  1A39 00C00003           1883mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A2  0805 0002               1884mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009A6  67F4                    1885mmm         BEQ WAIT_FOR_READY_95                       ; NO SPACE, CHECK AGAIN
000009A8  13DC 00C00007           1886mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009AE                          1887mmm     ENDC
000009AE                          1888mmm 
000009AE                 FALSE    1889mmm     IFNE DEBUG
000009AE                          1890mmm     ENDC
000009AE                          1891mmm 
000009AE                          1892mmm     ENDM
000009AE  60E4                    1893mm     BRA LOOP_94
000009B0                          1894mm EXIT_94
000009B0                          1895mm     ENDM
000009B0                          1896m     ENDM
000009B0  49FA 15B6               1897          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
000009B4                          1898m         PRINT_STR A4,D5
000009B4                          1899m LOOP_96
000009B4  0C14 0000               1900m     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009B8  6700 0016               1901m     BEQ EXIT_96
000009BC                          1902mm     PRINT_CHAR (A4)+,D5
000009BC                          1903mm WAIT_FOR_READY_97                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009BC                 TRUE     1904mm     IFEQ DEBUG
000009BC  1A39 00C00003           1905mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009C2  0805 0002               1906mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009C6  67F4                    1907mm         BEQ WAIT_FOR_READY_97                       ; NO SPACE, CHECK AGAIN
000009C8  13DC 00C00007           1908mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009CE                          1909mm     ENDC
000009CE                          1910mm 
000009CE                 FALSE    1911mm     IFNE DEBUG
000009CE                          1912mm     ENDC
000009CE                          1913mm 
000009CE                          1914mm     ENDM
000009CE  60E4                    1915m     BRA LOOP_96
000009D0                          1916m EXIT_96
000009D0                          1917m     ENDM
000009D0                          1918m         PRINT_REG D0,D5,D3,D6,A4
000009D0  49FA 15F9               1919m     LEA OX(PC),A4
000009D4                          1920mm     PRINT_STR A4,D5
000009D4                          1921mm LOOP_99
000009D4  0C14 0000               1922mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000009D8  6700 0016               1923mm     BEQ EXIT_99
000009DC                          1924mmm     PRINT_CHAR (A4)+,D5
000009DC                          1925mmm WAIT_FOR_READY_100                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009DC                 TRUE     1926mmm     IFEQ DEBUG
000009DC  1A39 00C00003           1927mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009E2  0805 0002               1928mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009E6  67F4                    1929mmm         BEQ WAIT_FOR_READY_100                      ; NO SPACE, CHECK AGAIN
000009E8  13DC 00C00007           1930mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009EE                          1931mmm     ENDC
000009EE                          1932mmm 
000009EE                 FALSE    1933mmm     IFNE DEBUG
000009EE                          1934mmm     ENDC
000009EE                          1935mmm 
000009EE                          1936mmm     ENDM
000009EE  60E4                    1937mm     BRA LOOP_99
000009F0                          1938mm EXIT_99
000009F0                          1939mm     ENDM
000009F0  7C07                    1940m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000009F2                          1941m LOOP_98
000009F2                          1942mm     BIN2HEX D0,D3,A4
000009F2  49FA 1596               1943mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009F6  E998                    1944mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000009F8  1600                    1945mm     MOVE.B D0,D3
000009FA  0283 0000000F           1946mm     ANDI.L #$F,D3
00000A00  1634 3000               1947mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000A04                          1948mm     ENDM
00000A04                          1949mm     PRINT_CHAR D3,D5
00000A04                          1950mm WAIT_FOR_READY_102                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A04                 TRUE     1951mm     IFEQ DEBUG
00000A04  1A39 00C00003           1952mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A0A  0805 0002               1953mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A0E  67F4                    1954mm         BEQ WAIT_FOR_READY_102                      ; NO SPACE, CHECK AGAIN
00000A10  13C3 00C00007           1955mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A16                          1956mm     ENDC
00000A16                          1957mm 
00000A16                 FALSE    1958mm     IFNE DEBUG
00000A16                          1959mm     ENDC
00000A16                          1960mm 
00000A16                          1961mm     ENDM
00000A16  57CE FFDA               1962m     DBEQ D6,LOOP_98
00000A1A                          1963m     ENDM
00000A1A                          1964m         PRINT_CRLF D5,A4
00000A1A  49FA 15A9               1965m     LEA CRLF(PC),A4
00000A1E                          1966mm     PRINT_STR A4,D5
00000A1E                          1967mm LOOP_104
00000A1E  0C14 0000               1968mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A22  6700 0016               1969mm     BEQ EXIT_104
00000A26                          1970mmm     PRINT_CHAR (A4)+,D5
00000A26                          1971mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A26                 TRUE     1972mmm     IFEQ DEBUG
00000A26  1A39 00C00003           1973mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A2C  0805 0002               1974mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A30  67F4                    1975mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A32  13DC 00C00007           1976mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A38                          1977mmm     ENDC
00000A38                          1978mmm 
00000A38                 FALSE    1979mmm     IFNE DEBUG
00000A38                          1980mmm     ENDC
00000A38                          1981mmm 
00000A38                          1982mmm     ENDM
00000A38  60E4                    1983mm     BRA LOOP_104
00000A3A                          1984mm EXIT_104
00000A3A                          1985mm     ENDM
00000A3A                          1986m     ENDM
00000A3A                          1987          
00000A3A  6000 F908               1988          BRA MAIN_LOOP
00000A3E                          1989      ENDI
00000A3E                          1990s _0000000B
00000A3E                          1991  
00000A3E                          1992      IF D1 <EQ> #0 THEN
00000A3E  B27C 0000               1993s     CMP.W   #0,D1
00000A42  6600 0006               1994s     BNE _0000000C
00000A46  6000 FBC0               1995        BRA WAIT_FOR_SRECORD
00000A4A                          1996      ENDI
00000A4A                          1997s _0000000C
00000A4A                          1998  DOWNLOAD_DONE
00000A4A                          1999m     PRINT_CRLF D5,A4
00000A4A  49FA 1579               2000m     LEA CRLF(PC),A4
00000A4E                          2001mm     PRINT_STR A4,D5
00000A4E                          2002mm LOOP_107
00000A4E  0C14 0000               2003mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A52  6700 0016               2004mm     BEQ EXIT_107
00000A56                          2005mmm     PRINT_CHAR (A4)+,D5
00000A56                          2006mmm WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A56                 TRUE     2007mmm     IFEQ DEBUG
00000A56  1A39 00C00003           2008mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A5C  0805 0002               2009mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A60  67F4                    2010mmm         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000A62  13DC 00C00007           2011mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A68                          2012mmm     ENDC
00000A68                          2013mmm 
00000A68                 FALSE    2014mmm     IFNE DEBUG
00000A68                          2015mmm     ENDC
00000A68                          2016mmm 
00000A68                          2017mmm     ENDM
00000A68  60E4                    2018mm     BRA LOOP_107
00000A6A                          2019mm EXIT_107
00000A6A                          2020mm     ENDM
00000A6A                          2021m     ENDM
00000A6A                          2022m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000A6A  43FA 155F               2023m     LEA OX(PC),A1
00000A6E                          2024mm     PRINT_STR A1,D5
00000A6E                          2025mm LOOP_110
00000A6E  0C11 0000               2026mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000A72  6700 0016               2027mm     BEQ EXIT_110
00000A76                          2028mmm     PRINT_CHAR (A1)+,D5
00000A76                          2029mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A76                 TRUE     2030mmm     IFEQ DEBUG
00000A76  1A39 00C00003           2031mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A7C  0805 0002               2032mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A80  67F4                    2033mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000A82  13D9 00C00007           2034mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A88                          2035mmm     ENDC
00000A88                          2036mmm 
00000A88                 FALSE    2037mmm     IFNE DEBUG
00000A88                          2038mmm     ENDC
00000A88                          2039mmm 
00000A88                          2040mmm     ENDM
00000A88  60E4                    2041mm     BRA LOOP_110
00000A8A                          2042mm EXIT_110
00000A8A                          2043mm     ENDM
00000A8A  7407                    2044m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000A8C                          2045m LOOP_109
00000A8C                          2046mm     BIN2HEX D0,D6,A1
00000A8C  43FA 14FC               2047mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000A90  E998                    2048mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000A92  1C00                    2049mm     MOVE.B D0,D6
00000A94  0286 0000000F           2050mm     ANDI.L #$F,D6
00000A9A  1C31 6000               2051mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000A9E                          2052mm     ENDM
00000A9E                          2053mm     PRINT_CHAR D6,D5
00000A9E                          2054mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A9E                 TRUE     2055mm     IFEQ DEBUG
00000A9E  1A39 00C00003           2056mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AA4  0805 0002               2057mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AA8  67F4                    2058mm         BEQ WAIT_FOR_READY_113                      ; NO SPACE, CHECK AGAIN
00000AAA  13C6 00C00007           2059mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AB0                          2060mm     ENDC
00000AB0                          2061mm 
00000AB0                 FALSE    2062mm     IFNE DEBUG
00000AB0                          2063mm     ENDC
00000AB0                          2064mm 
00000AB0                          2065mm     ENDM
00000AB0  57CA FFDA               2066m     DBEQ D2,LOOP_109
00000AB4                          2067m     ENDM
00000AB4  43FA 1479               2068      LEA READ(PC),A1
00000AB8                          2069m     PRINT_STR A1,D5
00000AB8                          2070m LOOP_114
00000AB8  0C11 0000               2071m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000ABC  6700 0016               2072m     BEQ EXIT_114
00000AC0                          2073mm     PRINT_CHAR (A1)+,D5
00000AC0                          2074mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC0                 TRUE     2075mm     IFEQ DEBUG
00000AC0  1A39 00C00003           2076mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC6  0805 0002               2077mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACA  67F4                    2078mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000ACC  13D9 00C00007           2079mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD2                          2080mm     ENDC
00000AD2                          2081mm 
00000AD2                 FALSE    2082mm     IFNE DEBUG
00000AD2                          2083mm     ENDC
00000AD2                          2084mm 
00000AD2                          2085mm     ENDM
00000AD2  60E4                    2086m     BRA LOOP_114
00000AD4                          2087m EXIT_114
00000AD4                          2088m     ENDM
00000AD4  2E08                    2089      MOVE.L A0,D7                                    ; set address accumulator to start address
00000AD6                          2090m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000AD6  43FA 14F3               2091m     LEA OX(PC),A1
00000ADA                          2092mm     PRINT_STR A1,D5
00000ADA                          2093mm LOOP_117
00000ADA  0C11 0000               2094mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000ADE  6700 0016               2095mm     BEQ EXIT_117
00000AE2                          2096mmm     PRINT_CHAR (A1)+,D5
00000AE2                          2097mmm WAIT_FOR_READY_118                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE2                 TRUE     2098mmm     IFEQ DEBUG
00000AE2  1A39 00C00003           2099mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AE8  0805 0002               2100mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AEC  67F4                    2101mmm         BEQ WAIT_FOR_READY_118                      ; NO SPACE, CHECK AGAIN
00000AEE  13D9 00C00007           2102mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AF4                          2103mmm     ENDC
00000AF4                          2104mmm 
00000AF4                 FALSE    2105mmm     IFNE DEBUG
00000AF4                          2106mmm     ENDC
00000AF4                          2107mmm 
00000AF4                          2108mmm     ENDM
00000AF4  60E4                    2109mm     BRA LOOP_117
00000AF6                          2110mm EXIT_117
00000AF6                          2111mm     ENDM
00000AF6  7407                    2112m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000AF8                          2113m LOOP_116
00000AF8                          2114mm     BIN2HEX D7,D6,A1
00000AF8  43FA 1490               2115mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000AFC  E99F                    2116mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000AFE  1C07                    2117mm     MOVE.B D7,D6
00000B00  0286 0000000F           2118mm     ANDI.L #$F,D6
00000B06  1C31 6000               2119mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000B0A                          2120mm     ENDM
00000B0A                          2121mm     PRINT_CHAR D6,D5
00000B0A                          2122mm WAIT_FOR_READY_120                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B0A                 TRUE     2123mm     IFEQ DEBUG
00000B0A  1A39 00C00003           2124mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B10  0805 0002               2125mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B14  67F4                    2126mm         BEQ WAIT_FOR_READY_120                      ; NO SPACE, CHECK AGAIN
00000B16  13C6 00C00007           2127mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B1C                          2128mm     ENDC
00000B1C                          2129mm 
00000B1C                 FALSE    2130mm     IFNE DEBUG
00000B1C                          2131mm     ENDC
00000B1C                          2132mm 
00000B1C                          2133mm     ENDM
00000B1C  57CA FFDA               2134m     DBEQ D2,LOOP_116
00000B20                          2135m     ENDM
00000B20                          2136m     PRINT_CRLF D5,A4
00000B20  49FA 14A3               2137m     LEA CRLF(PC),A4
00000B24                          2138mm     PRINT_STR A4,D5
00000B24                          2139mm LOOP_122
00000B24  0C14 0000               2140mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B28  6700 0016               2141mm     BEQ EXIT_122
00000B2C                          2142mmm     PRINT_CHAR (A4)+,D5
00000B2C                          2143mmm WAIT_FOR_READY_123                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B2C                 TRUE     2144mmm     IFEQ DEBUG
00000B2C  1A39 00C00003           2145mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B32  0805 0002               2146mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B36  67F4                    2147mmm         BEQ WAIT_FOR_READY_123                      ; NO SPACE, CHECK AGAIN
00000B38  13DC 00C00007           2148mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B3E                          2149mmm     ENDC
00000B3E                          2150mmm 
00000B3E                 FALSE    2151mmm     IFNE DEBUG
00000B3E                          2152mmm     ENDC
00000B3E                          2153mmm 
00000B3E                          2154mmm     ENDM
00000B3E  60E4                    2155mm     BRA LOOP_122
00000B40                          2156mm EXIT_122
00000B40                          2157mm     ENDM
00000B40                          2158m     ENDM
00000B40                          2159  
00000B40  6000 F802               2160      BRA MAIN_LOOP
00000B44                          2161  
00000B44                          2162  G
00000B44  2047                    2163      MOVE.L D7,A0                                    ; grab the address accumulator and then clear it
00000B46  7E00                    2164      MOVE.L #0,D7
00000B48                          2165  
00000B48  4ED0                    2166      JMP (A0)
00000B4A                          2167          
00000B4A                          2168  Z
00000B4A  207C 00200000           2169      MOVE.L #RAM,A0                                  ; address of RAM
00000B50  D1FC 00100000           2170      ADD.L #$100000,A0
00000B56                          2171  
00000B56                          2172      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000B56  7000                    2173s     MOVE.L  #0,D0
00000B58  6000 0012               2174s     BRA _20000007
00000B5C                          2175s _20000006
00000B5C  2200                    2176          MOVE.L D0,D1                                ; progress update
00000B5E  E089                    2177          LSR.L #8,D1 
00000B60  E089                    2178          LSR.L #8,D1
00000B62  13C1 00E00001           2179          MOVE.B D1,DISPLAY
00000B68                          2180          
00000B68  2108                    2181          MOVE.L A0,-(A0)
00000B6A                          2182      ENDF
00000B6A  5880                    2183s     ADD.L   #4,D0
00000B6C                          2184s _20000007
00000B6C  B0BC 000FFFFC           2185s     CMP.L   #$FFFFC,D0
00000B72  6FE8                    2186s     BLE _20000006
00000B74                          2187  
00000B74  207C 00200000           2188      MOVE.L #RAM,A0                                  ; address of RAM
00000B7A  D1FC 00100000           2189      ADD.L #$100000,A0
00000B80                          2190  
00000B80                          2191      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000B80  7000                    2192s     MOVE.L  #0,D0
00000B82  6000 00A8               2193s     BRA _20000009
00000B86                          2194s _20000008
00000B86  2200                    2195          MOVE.L D0,D1                                ; progress update
00000B88  E089                    2196          LSR.L #8,D1
00000B8A  E089                    2197          LSR.L #8,D1
00000B8C  13C1 00E00001           2198          MOVE.B D1,DISPLAY
00000B92                          2199  
00000B92  2408                    2200          MOVE.L A0,D2
00000B94  2220                    2201          MOVE.L -(A0),D1
00000B96                          2202  
00000B96                          2203          IF.L D2 <NE> D1 THEN
00000B96  B481                    2204s     CMP.L   D1,D2
00000B98  6700 0090               2205s     BEQ _0000000D
00000B9C  43FA 13DB               2206              LEA RAM_ERROR(PC),A1
00000BA0                          2207m             PRINT_STR A1,D1
00000BA0                          2208m LOOP_124
00000BA0  0C11 0000               2209m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BA4  6700 0016               2210m     BEQ EXIT_124
00000BA8                          2211mm     PRINT_CHAR (A1)+,D1
00000BA8                          2212mm WAIT_FOR_READY_125                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA8                 TRUE     2213mm     IFEQ DEBUG
00000BA8  1239 00C00003           2214mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000BAE  0801 0002               2215mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000BB2  67F4                    2216mm         BEQ WAIT_FOR_READY_125                      ; NO SPACE, CHECK AGAIN
00000BB4  13D9 00C00007           2217mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BBA                          2218mm     ENDC
00000BBA                          2219mm 
00000BBA                 FALSE    2220mm     IFNE DEBUG
00000BBA                          2221mm     ENDC
00000BBA                          2222mm 
00000BBA                          2223mm     ENDM
00000BBA  60E4                    2224m     BRA LOOP_124
00000BBC                          2225m EXIT_124
00000BBC                          2226m     ENDM
00000BBC  2208                    2227              MOVE.L A0,D1
00000BBE  5981                    2228              SUB.L #4,D1
00000BC0                          2229m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000BC0  43FA 1409               2230m     LEA OX(PC),A1
00000BC4                          2231mm     PRINT_STR A1,D3
00000BC4                          2232mm LOOP_127
00000BC4  0C11 0000               2233mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000BC8  6700 0016               2234mm     BEQ EXIT_127
00000BCC                          2235mmm     PRINT_CHAR (A1)+,D3
00000BCC                          2236mmm WAIT_FOR_READY_128                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BCC                 TRUE     2237mmm     IFEQ DEBUG
00000BCC  1639 00C00003           2238mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BD2  0803 0002               2239mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BD6  67F4                    2240mmm         BEQ WAIT_FOR_READY_128                      ; NO SPACE, CHECK AGAIN
00000BD8  13D9 00C00007           2241mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BDE                          2242mmm     ENDC
00000BDE                          2243mmm 
00000BDE                 FALSE    2244mmm     IFNE DEBUG
00000BDE                          2245mmm     ENDC
00000BDE                          2246mmm 
00000BDE                          2247mmm     ENDM
00000BDE  60E4                    2248mm     BRA LOOP_127
00000BE0                          2249mm EXIT_127
00000BE0                          2250mm     ENDM
00000BE0  7C07                    2251m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BE2                          2252m LOOP_126
00000BE2                          2253mm     BIN2HEX D1,D2,A1
00000BE2  43FA 13A6               2254mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000BE6  E999                    2255mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BE8  1401                    2256mm     MOVE.B D1,D2
00000BEA  0282 0000000F           2257mm     ANDI.L #$F,D2
00000BF0  1431 2000               2258mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000BF4                          2259mm     ENDM
00000BF4                          2260mm     PRINT_CHAR D2,D3
00000BF4                          2261mm WAIT_FOR_READY_130                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BF4                 TRUE     2262mm     IFEQ DEBUG
00000BF4  1639 00C00003           2263mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000BFA  0803 0002               2264mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000BFE  67F4                    2265mm         BEQ WAIT_FOR_READY_130                      ; NO SPACE, CHECK AGAIN
00000C00  13C2 00C00007           2266mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C06                          2267mm     ENDC
00000C06                          2268mm 
00000C06                 FALSE    2269mm     IFNE DEBUG
00000C06                          2270mm     ENDC
00000C06                          2271mm 
00000C06                          2272mm     ENDM
00000C06  57CE FFDA               2273m     DBEQ D6,LOOP_126
00000C0A                          2274m     ENDM
00000C0A                          2275m             PRINT_CRLF D3,A1
00000C0A  43FA 13B9               2276m     LEA CRLF(PC),A1
00000C0E                          2277mm     PRINT_STR A1,D3
00000C0E                          2278mm LOOP_132
00000C0E  0C11 0000               2279mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C12  6700 0016               2280mm     BEQ EXIT_132
00000C16                          2281mmm     PRINT_CHAR (A1)+,D3
00000C16                          2282mmm WAIT_FOR_READY_133                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C16                 TRUE     2283mmm     IFEQ DEBUG
00000C16  1639 00C00003           2284mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000C1C  0803 0002               2285mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000C20  67F4                    2286mmm         BEQ WAIT_FOR_READY_133                      ; NO SPACE, CHECK AGAIN
00000C22  13D9 00C00007           2287mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C28                          2288mmm     ENDC
00000C28                          2289mmm 
00000C28                 FALSE    2290mmm     IFNE DEBUG
00000C28                          2291mmm     ENDC
00000C28                          2292mmm 
00000C28                          2293mmm     ENDM
00000C28  60E4                    2294mm     BRA LOOP_132
00000C2A                          2295mm EXIT_132
00000C2A                          2296mm     ENDM
00000C2A                          2297m     ENDM
00000C2A                          2298          ENDI 
00000C2A                          2299s _0000000D
00000C2A                          2300      ENDF
00000C2A  5880                    2301s     ADD.L   #4,D0
00000C2C                          2302s _20000009
00000C2C  B0BC 000FFFFC           2303s     CMP.L   #$FFFFC,D0
00000C32  6F00 FF52               2304s     BLE _20000008
00000C36                          2305  
00000C36  6000 F70C               2306      BRA MAIN_LOOP
00000C3A                          2307  
00000C3A                          2308  L
00000C3A  7000                    2309      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000C3C  7200                    2310      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000C3E                          2311  
00000C3E                          2312      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000C3E  343C 0000               2313s     MOVE.W  #0,D2
00000C42  6000 0046               2314s     BRA _2000000B
00000C46                          2315s _2000000A
00000C46  E989                    2316          LSL.L #4,D1                                 ; make what we have so far more significant
00000C48                          2317m         WAIT_CHAR D3,D4                             ; next character -> D2
00000C48                          2318m WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C48                 TRUE     2319m     IFEQ DEBUG
00000C48  1839 00C00003           2320m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C4E  0804 0000               2321m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000C52  67F4                    2322m         BEQ WAIT_FOR_READY_134                      ; NOTHING, CHECK AGAIN
00000C54                          2323m     ENDC
00000C54                          2324m 
00000C54                          2325mm     READ_CHAR D3
00000C54                 TRUE     2326mm     IFEQ DEBUG
00000C54  1639 00C00007           2327mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000C5A                          2328mm     ENDC
00000C5A                 FALSE    2329mm     IFNE DEBUG
00000C5A                          2330mm     ENDC
00000C5A                          2331mm 
00000C5A  B63C 001B               2332mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000C5E  6700 F4A4               2333mm     BEQ START
00000C62                          2334mm     ENDM
00000C62                          2335m 
00000C62                 TRUE     2336m     IFEQ DEBUG
00000C62                          2337mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000C62                          2338mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C62                 TRUE     2339mm     IFEQ DEBUG
00000C62  1839 00C00003           2340mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000C68  0804 0002               2341mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000C6C  67F4                    2342mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C6E  13C3 00C00007           2343mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C74                          2344mm     ENDC
00000C74                          2345mm 
00000C74                 FALSE    2346mm     IFNE DEBUG
00000C74                          2347mm     ENDC
00000C74                          2348mm 
00000C74                          2349mm     ENDM
00000C74                          2350m     ENDC
00000C74                          2351m     ENDM
00000C74                          2352m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000C74  41FA 1324               2353m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000C78  0403 0030               2354m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C7C  C6BC 000000FF           2355m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000C82  1630 3000               2356m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C86                          2357m     ENDM
00000C86  8203                    2358          OR.B D3,D1
00000C88                          2359      ENDF
00000C88  5242                    2360s     ADD.W   #1,D2
00000C8A                          2361s _2000000B
00000C8A  B47C 0007               2362s     CMP.W   #7,D2
00000C8E  6FB6                    2363s     BLE _2000000A
00000C90                          2364  
00000C90  3001                    2365      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000C92  0480 00000104           2366      SUB.L #START,D0                                 ; remove the vector table from the length
00000C98  E089                    2367      LSR.L #8,D1                                     ; extract the MSword for the address
00000C9A  E089                    2368      LSR.L #8,D1
00000C9C                          2369  
00000C9C                          2370m     PRINT_CRLF D2,A1
00000C9C  43FA 1327               2371m     LEA CRLF(PC),A1
00000CA0                          2372mm     PRINT_STR A1,D2
00000CA0                          2373mm LOOP_139
00000CA0  0C11 0000               2374mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000CA4  6700 0016               2375mm     BEQ EXIT_139
00000CA8                          2376mmm     PRINT_CHAR (A1)+,D2
00000CA8                          2377mmm WAIT_FOR_READY_140                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CA8                 TRUE     2378mmm     IFEQ DEBUG
00000CA8  1439 00C00003           2379mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000CAE  0802 0002               2380mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000CB2  67F4                    2381mmm         BEQ WAIT_FOR_READY_140                      ; NO SPACE, CHECK AGAIN
00000CB4  13D9 00C00007           2382mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CBA                          2383mmm     ENDC
00000CBA                          2384mmm 
00000CBA                 FALSE    2385mmm     IFNE DEBUG
00000CBA                          2386mmm     ENDC
00000CBA                          2387mmm 
00000CBA                          2388mmm     ENDM
00000CBA  60E4                    2389mm     BRA LOOP_139
00000CBC                          2390mm EXIT_139
00000CBC                          2391mm     ENDM
00000CBC                          2392m     ENDM
00000CBC                          2393  
00000CBC  2041                    2394      MOVE.L D1,A0                                    ; target address
00000CBE  2641                    2395      MOVE.L D1,A3                                    ; keep a copy for later
00000CC0                          2396  
00000CC0  2247                    2397      MOVE.L D7,A1                                    ; address accumulator -> address register
00000CC2  D3FC 00000104           2398      ADD.L #START,A1                                 ; skip the vectors
00000CC8  2847                    2399      MOVE.L D7,A4                                    ; keep a clean copy for later
00000CCA  7E00                    2400      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000CCC                          2401  
00000CCC                          2402m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000CCC  31FC AAAA 2AAA          2403m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000CD2  4E71                    2404m     NOP
00000CD4  31FC 5555 1554          2405m     MOVE.W #$5555,$1554
00000CDA  4E71                    2406m     NOP
00000CDC  31FC 8080 2AAA          2407m     MOVE.W #$8080,$2AAA
00000CE2  4E71                    2408m     NOP
00000CE4  31FC AAAA 2AAA          2409m     MOVE.W #$AAAA,$2AAA
00000CEA  4E71                    2410m     NOP
00000CEC  31FC 5555 1554          2411m     MOVE.W #$5555,$1554
00000CF2  4E71                    2412m     NOP
00000CF4  31FC 2020 2AAA          2413m     MOVE.W #$2020,$2AAA
00000CFA                          2414m     ENDM
00000CFA                          2415                      
00000CFA                          2416      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00000CFA  3E3C 0000               2417s     MOVE.W  #$0,D7
00000CFE  6000 0006               2418s     BRA _2000000D
00000D02                          2419s _2000000C
00000D02  4E71                    2420          NOP
00000D04                          2421      ENDF
00000D04  5247                    2422s     ADD.W   #1,D7
00000D06                          2423s _2000000D
00000D06  BE7C FFFF               2424s     CMP.W   #$FFFFFFFF,D7
00000D0A  6FF6                    2425s     BLE _2000000C
00000D0C                          2426                  
00000D0C  45FA 12A3               2427      LEA LOADING(PC),A2
00000D10                          2428m     PRINT_STR A2,D2
00000D10                          2429m LOOP_142
00000D10  0C12 0000               2430m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D14  6700 0016               2431m     BEQ EXIT_142
00000D18                          2432mm     PRINT_CHAR (A2)+,D2
00000D18                          2433mm WAIT_FOR_READY_143                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D18                 TRUE     2434mm     IFEQ DEBUG
00000D18  1439 00C00003           2435mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D1E  0802 0002               2436mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D22  67F4                    2437mm         BEQ WAIT_FOR_READY_143                      ; NO SPACE, CHECK AGAIN
00000D24  13DA 00C00007           2438mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D2A                          2439mm     ENDC
00000D2A                          2440mm 
00000D2A                 FALSE    2441mm     IFNE DEBUG
00000D2A                          2442mm     ENDC
00000D2A                          2443mm 
00000D2A                          2444mm     ENDM
00000D2A  60E4                    2445m     BRA LOOP_142
00000D2C                          2446m EXIT_142
00000D2C                          2447m     ENDM
00000D2C                          2448m     PRINT_STR A2,D2
00000D2C                          2449m LOOP_144
00000D2C  0C12 0000               2450m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D30  6700 0016               2451m     BEQ EXIT_144
00000D34                          2452mm     PRINT_CHAR (A2)+,D2
00000D34                          2453mm WAIT_FOR_READY_145                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D34                 TRUE     2454mm     IFEQ DEBUG
00000D34  1439 00C00003           2455mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D3A  0802 0002               2456mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D3E  67F4                    2457mm         BEQ WAIT_FOR_READY_145                      ; NO SPACE, CHECK AGAIN
00000D40  13DA 00C00007           2458mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D46                          2459mm     ENDC
00000D46                          2460mm 
00000D46                 FALSE    2461mm     IFNE DEBUG
00000D46                          2462mm     ENDC
00000D46                          2463mm 
00000D46                          2464mm     ENDM
00000D46  60E4                    2465m     BRA LOOP_144
00000D48                          2466m EXIT_144
00000D48                          2467m     ENDM
00000D48                          2468m     PRINT_STR A2,D2
00000D48                          2469m LOOP_146
00000D48  0C12 0000               2470m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D4C  6700 0016               2471m     BEQ EXIT_146
00000D50                          2472mm     PRINT_CHAR (A2)+,D2
00000D50                          2473mm WAIT_FOR_READY_147                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D50                 TRUE     2474mm     IFEQ DEBUG
00000D50  1439 00C00003           2475mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D56  0802 0002               2476mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D5A  67F4                    2477mm         BEQ WAIT_FOR_READY_147                      ; NO SPACE, CHECK AGAIN
00000D5C  13DA 00C00007           2478mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D62                          2479mm     ENDC
00000D62                          2480mm 
00000D62                 FALSE    2481mm     IFNE DEBUG
00000D62                          2482mm     ENDC
00000D62                          2483mm 
00000D62                          2484mm     ENDM
00000D62  60E4                    2485m     BRA LOOP_146
00000D64                          2486m EXIT_146
00000D64                          2487m     ENDM
00000D64                          2488m     PRINT_STR A2,D2
00000D64                          2489m LOOP_148
00000D64  0C12 0000               2490m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D68  6700 0016               2491m     BEQ EXIT_148
00000D6C                          2492mm     PRINT_CHAR (A2)+,D2
00000D6C                          2493mm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D6C                 TRUE     2494mm     IFEQ DEBUG
00000D6C  1439 00C00003           2495mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000D72  0802 0002               2496mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000D76  67F4                    2497mm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000D78  13DA 00C00007           2498mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D7E                          2499mm     ENDC
00000D7E                          2500mm 
00000D7E                 FALSE    2501mm     IFNE DEBUG
00000D7E                          2502mm     ENDC
00000D7E                          2503mm 
00000D7E                          2504mm     ENDM
00000D7E  60E4                    2505m     BRA LOOP_148
00000D80                          2506m EXIT_148
00000D80                          2507m     ENDM
00000D80                          2508          
00000D80  2409                    2509      MOVE.L A1,D2
00000D82                          2510m     PRINT_REG D2,D3,D4,D5,A2
00000D82  45FA 1247               2511m     LEA OX(PC),A2
00000D86                          2512mm     PRINT_STR A2,D3
00000D86                          2513mm LOOP_151
00000D86  0C12 0000               2514mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000D8A  6700 0016               2515mm     BEQ EXIT_151
00000D8E                          2516mmm     PRINT_CHAR (A2)+,D3
00000D8E                          2517mmm WAIT_FOR_READY_152                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D8E                 TRUE     2518mmm     IFEQ DEBUG
00000D8E  1639 00C00003           2519mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D94  0803 0002               2520mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D98  67F4                    2521mmm         BEQ WAIT_FOR_READY_152                      ; NO SPACE, CHECK AGAIN
00000D9A  13DA 00C00007           2522mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DA0                          2523mmm     ENDC
00000DA0                          2524mmm 
00000DA0                 FALSE    2525mmm     IFNE DEBUG
00000DA0                          2526mmm     ENDC
00000DA0                          2527mmm 
00000DA0                          2528mmm     ENDM
00000DA0  60E4                    2529mm     BRA LOOP_151
00000DA2                          2530mm EXIT_151
00000DA2                          2531mm     ENDM
00000DA2  7A07                    2532m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000DA4                          2533m LOOP_150
00000DA4                          2534mm     BIN2HEX D2,D4,A2
00000DA4  45FA 11E4               2535mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000DA8  E99A                    2536mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000DAA  1802                    2537mm     MOVE.B D2,D4
00000DAC  0284 0000000F           2538mm     ANDI.L #$F,D4
00000DB2  1832 4000               2539mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000DB6                          2540mm     ENDM
00000DB6                          2541mm     PRINT_CHAR D4,D3
00000DB6                          2542mm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DB6                 TRUE     2543mm     IFEQ DEBUG
00000DB6  1639 00C00003           2544mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DBC  0803 0002               2545mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DC0  67F4                    2546mm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DC2  13C4 00C00007           2547mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DC8                          2548mm     ENDC
00000DC8                          2549mm 
00000DC8                 FALSE    2550mm     IFNE DEBUG
00000DC8                          2551mm     ENDC
00000DC8                          2552mm 
00000DC8                          2553mm     ENDM
00000DC8  57CD FFDA               2554m     DBEQ D5,LOOP_150
00000DCC                          2555m     ENDM
00000DCC                          2556  
00000DCC  45FA 1200               2557      LEA TO(PC),A2
00000DD0                          2558m     PRINT_STR A2,D3
00000DD0                          2559m LOOP_155
00000DD0  0C12 0000               2560m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DD4  6700 0016               2561m     BEQ EXIT_155
00000DD8                          2562mm     PRINT_CHAR (A2)+,D3
00000DD8                          2563mm WAIT_FOR_READY_156                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DD8                 TRUE     2564mm     IFEQ DEBUG
00000DD8  1639 00C00003           2565mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DDE  0803 0002               2566mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DE2  67F4                    2567mm         BEQ WAIT_FOR_READY_156                      ; NO SPACE, CHECK AGAIN
00000DE4  13DA 00C00007           2568mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DEA                          2569mm     ENDC
00000DEA                          2570mm 
00000DEA                 FALSE    2571mm     IFNE DEBUG
00000DEA                          2572mm     ENDC
00000DEA                          2573mm 
00000DEA                          2574mm     ENDM
00000DEA  60E4                    2575m     BRA LOOP_155
00000DEC                          2576m EXIT_155
00000DEC                          2577m     ENDM
00000DEC                          2578  
00000DEC  2408                    2579      MOVE.L A0,D2
00000DEE                          2580m     PRINT_REG D2,D3,D4,D5,A2
00000DEE  45FA 11DB               2581m     LEA OX(PC),A2
00000DF2                          2582mm     PRINT_STR A2,D3
00000DF2                          2583mm LOOP_158
00000DF2  0C12 0000               2584mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000DF6  6700 0016               2585mm     BEQ EXIT_158
00000DFA                          2586mmm     PRINT_CHAR (A2)+,D3
00000DFA                          2587mmm WAIT_FOR_READY_159                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DFA                 TRUE     2588mmm     IFEQ DEBUG
00000DFA  1639 00C00003           2589mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E00  0803 0002               2590mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E04  67F4                    2591mmm         BEQ WAIT_FOR_READY_159                      ; NO SPACE, CHECK AGAIN
00000E06  13DA 00C00007           2592mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E0C                          2593mmm     ENDC
00000E0C                          2594mmm 
00000E0C                 FALSE    2595mmm     IFNE DEBUG
00000E0C                          2596mmm     ENDC
00000E0C                          2597mmm 
00000E0C                          2598mmm     ENDM
00000E0C  60E4                    2599mm     BRA LOOP_158
00000E0E                          2600mm EXIT_158
00000E0E                          2601mm     ENDM
00000E0E  7A07                    2602m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E10                          2603m LOOP_157
00000E10                          2604mm     BIN2HEX D2,D4,A2
00000E10  45FA 1178               2605mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E14  E99A                    2606mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E16  1802                    2607mm     MOVE.B D2,D4
00000E18  0284 0000000F           2608mm     ANDI.L #$F,D4
00000E1E  1832 4000               2609mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E22                          2610mm     ENDM
00000E22                          2611mm     PRINT_CHAR D4,D3
00000E22                          2612mm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E22                 TRUE     2613mm     IFEQ DEBUG
00000E22  1639 00C00003           2614mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E28  0803 0002               2615mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E2C  67F4                    2616mm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E2E  13C4 00C00007           2617mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E34                          2618mm     ENDC
00000E34                          2619mm 
00000E34                 FALSE    2620mm     IFNE DEBUG
00000E34                          2621mm     ENDC
00000E34                          2622mm 
00000E34                          2623mm     ENDM
00000E34  57CD FFDA               2624m     DBEQ D5,LOOP_157
00000E38                          2625m     ENDM
00000E38                          2626  
00000E38  45FA 1199               2627      LEA FOR(PC),A2
00000E3C                          2628m     PRINT_STR A2,D3
00000E3C                          2629m LOOP_162
00000E3C  0C12 0000               2630m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E40  6700 0016               2631m     BEQ EXIT_162
00000E44                          2632mm     PRINT_CHAR (A2)+,D3
00000E44                          2633mm WAIT_FOR_READY_163                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E44                 TRUE     2634mm     IFEQ DEBUG
00000E44  1639 00C00003           2635mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E4A  0803 0002               2636mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E4E  67F4                    2637mm         BEQ WAIT_FOR_READY_163                      ; NO SPACE, CHECK AGAIN
00000E50  13DA 00C00007           2638mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E56                          2639mm     ENDC
00000E56                          2640mm 
00000E56                 FALSE    2641mm     IFNE DEBUG
00000E56                          2642mm     ENDC
00000E56                          2643mm 
00000E56                          2644mm     ENDM
00000E56  60E4                    2645m     BRA LOOP_162
00000E58                          2646m EXIT_162
00000E58                          2647m     ENDM
00000E58                          2648m     PRINT_REG D0,D3,D4,D5,A2
00000E58  45FA 1171               2649m     LEA OX(PC),A2
00000E5C                          2650mm     PRINT_STR A2,D3
00000E5C                          2651mm LOOP_165
00000E5C  0C12 0000               2652mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000E60  6700 0016               2653mm     BEQ EXIT_165
00000E64                          2654mmm     PRINT_CHAR (A2)+,D3
00000E64                          2655mmm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E64                 TRUE     2656mmm     IFEQ DEBUG
00000E64  1639 00C00003           2657mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E6A  0803 0002               2658mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E6E  67F4                    2659mmm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000E70  13DA 00C00007           2660mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E76                          2661mmm     ENDC
00000E76                          2662mmm 
00000E76                 FALSE    2663mmm     IFNE DEBUG
00000E76                          2664mmm     ENDC
00000E76                          2665mmm 
00000E76                          2666mmm     ENDM
00000E76  60E4                    2667mm     BRA LOOP_165
00000E78                          2668mm EXIT_165
00000E78                          2669mm     ENDM
00000E78  7A07                    2670m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E7A                          2671m LOOP_164
00000E7A                          2672mm     BIN2HEX D0,D4,A2
00000E7A  45FA 110E               2673mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000E7E  E998                    2674mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E80  1800                    2675mm     MOVE.B D0,D4
00000E82  0284 0000000F           2676mm     ANDI.L #$F,D4
00000E88  1832 4000               2677mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000E8C                          2678mm     ENDM
00000E8C                          2679mm     PRINT_CHAR D4,D3
00000E8C                          2680mm WAIT_FOR_READY_168                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E8C                 TRUE     2681mm     IFEQ DEBUG
00000E8C  1639 00C00003           2682mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000E92  0803 0002               2683mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000E96  67F4                    2684mm         BEQ WAIT_FOR_READY_168                      ; NO SPACE, CHECK AGAIN
00000E98  13C4 00C00007           2685mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E9E                          2686mm     ENDC
00000E9E                          2687mm 
00000E9E                 FALSE    2688mm     IFNE DEBUG
00000E9E                          2689mm     ENDC
00000E9E                          2690mm 
00000E9E                          2691mm     ENDM
00000E9E  57CD FFDA               2692m     DBEQ D5,LOOP_164
00000EA2                          2693m     ENDM
00000EA2                          2694  
00000EA2                          2695m     PRINT_CRLF D3,A2
00000EA2  45FA 1121               2696m     LEA CRLF(PC),A2
00000EA6                          2697mm     PRINT_STR A2,D3
00000EA6                          2698mm LOOP_170
00000EA6  0C12 0000               2699mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EAA  6700 0016               2700mm     BEQ EXIT_170
00000EAE                          2701mmm     PRINT_CHAR (A2)+,D3
00000EAE                          2702mmm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EAE                 TRUE     2703mmm     IFEQ DEBUG
00000EAE  1639 00C00003           2704mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000EB4  0803 0002               2705mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000EB8  67F4                    2706mmm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000EBA  13DA 00C00007           2707mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EC0                          2708mmm     ENDC
00000EC0                          2709mmm 
00000EC0                 FALSE    2710mmm     IFNE DEBUG
00000EC0                          2711mmm     ENDC
00000EC0                          2712mmm 
00000EC0                          2713mmm     ENDM
00000EC0  60E4                    2714mm     BRA LOOP_170
00000EC2                          2715mm EXIT_170
00000EC2                          2716mm     ENDM
00000EC2                          2717m     ENDM
00000EC2                          2718  
00000EC2                          2719      WHILE D0 <GT> #0 DO
00000EC2                          2720s _10000014
00000EC2  B07C 0000               2721s     CMP.W   #0,D0
00000EC6  6F00 001E               2722s     BLE _10000015
00000ECA  5580                    2723          SUB.L #2,D0
00000ECC                          2724  
00000ECC  2408                    2725          MOVE.L A0,D2
00000ECE  13C2 00E00001           2726          MOVE.B D2,DISPLAY
00000ED4                          2727m         PROGRAM (A1),(A0),D2
00000ED4  3091                    2728m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00000ED6                          2729m 
00000ED6                          2730m WAIT_FOR_COMPLETE_172
00000ED6  3410                    2731m         MOVE.W (A0),D2
00000ED8                          2732m 
00000ED8                          2733m         IF.W D2 <NE> (A1) THEN
00000ED8  B451                    2734ms     CMP.W   (A1),D2
00000EDA  6700 0004               2735ms     BEQ _0000000E
00000EDE  60F6                    2736m             BRA WAIT_FOR_COMPLETE_172
00000EE0                          2737m         ENDI
00000EE0                          2738ms _0000000E
00000EE0                          2739m         ENDM
00000EE0                          2740                  
00000EE0  5488                    2741          ADD.L #2,A0
00000EE2  5489                    2742          ADD.L #2,A1
00000EE4                          2743      ENDW
00000EE4  60DC                    2744s     BRA _10000014
00000EE6                          2745s _10000015
00000EE6                          2746      
00000EE6  41F8 0000               2747      LEA STACK,A0
00000EEA  D1CC                    2748      ADD.L A4,A0
00000EEC  2010                    2749      MOVE.L (A0),D0
00000EEE                          2750      
00000EEE  207C 00000000           2751      MOVE.L #0,A0
00000EF4                          2752m     PROGRAM_VECTOR D0,A0,D2
00000EF4  5488                    2753m     ADD.L #2,A0
00000EF6                          2754mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000EF6  3080                    2755mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000EF8                          2756mm 
00000EF8                          2757mm WAIT_FOR_COMPLETE_174
00000EF8  3410                    2758mm         MOVE.W (A0),D2
00000EFA                          2759mm 
00000EFA                          2760mm         IF.W D2 <NE> D0 THEN
00000EFA  B440                    2761mms     CMP.W   D0,D2
00000EFC  6700 0004               2762mms     BEQ _0000000F
00000F00  60F6                    2763mm             BRA WAIT_FOR_COMPLETE_174
00000F02                          2764mm         ENDI
00000F02                          2765mms _0000000F
00000F02                          2766mm         ENDM
00000F02  E088                    2767m     LSR.L #8,D0
00000F04  E088                    2768m     LSR.L #8,D0
00000F06  5588                    2769m     SUB.L #2,A0
00000F08                          2770mm     PROGRAM D0, (A0), D2
00000F08  3080                    2771mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F0A                          2772mm 
00000F0A                          2773mm WAIT_FOR_COMPLETE_175
00000F0A  3410                    2774mm         MOVE.W (A0),D2
00000F0C                          2775mm 
00000F0C                          2776mm         IF.W D2 <NE> D0 THEN
00000F0C  B440                    2777mms     CMP.W   D0,D2
00000F0E  6700 0004               2778mms     BEQ _00000010
00000F12  60F6                    2779mm             BRA WAIT_FOR_COMPLETE_175
00000F14                          2780mm         ENDI
00000F14                          2781mms _00000010
00000F14                          2782mm         ENDM
00000F14                          2783m     ENDM
00000F14                          2784      
00000F14                          2785      FOR A0 = #RESET TO #START-4 BY #4 DO
00000F14  307C 0004               2786s     MOVE.W  #RESET,A0
00000F18  6000 003C               2787s     BRA _2000000F
00000F1C                          2788s _2000000E
00000F1C                          2789  
00000F1C  2248                    2790          MOVE.L A0,A1
00000F1E  D3CC                    2791          ADD.L A4,A1
00000F20                          2792              
00000F20  2011                    2793          MOVE.L (A1),D0  
00000F22  D081                    2794          ADD.L D1,D0
00000F24  0480 00000104           2795          SUB.L #START,D0
00000F2A                          2796  
00000F2A  2408                    2797          MOVE.L A0,D2
00000F2C                          2798          
00000F2C  2408                    2799          MOVE.L A0,D2
00000F2E  13C2 00E00001           2800          MOVE.B D2,DISPLAY
00000F34                          2801m         PROGRAM_VECTOR D0,A0,D2
00000F34  5488                    2802m     ADD.L #2,A0
00000F36                          2803mm     PROGRAM D0, (A0), D2                            ; WRITE IT
00000F36  3080                    2804mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F38                          2805mm 
00000F38                          2806mm WAIT_FOR_COMPLETE_177
00000F38  3410                    2807mm         MOVE.W (A0),D2
00000F3A                          2808mm 
00000F3A                          2809mm         IF.W D2 <NE> D0 THEN
00000F3A  B440                    2810mms     CMP.W   D0,D2
00000F3C  6700 0004               2811mms     BEQ _00000011
00000F40  60F6                    2812mm             BRA WAIT_FOR_COMPLETE_177
00000F42                          2813mm         ENDI
00000F42                          2814mms _00000011
00000F42                          2815mm         ENDM
00000F42  E088                    2816m     LSR.L #8,D0
00000F44  E088                    2817m     LSR.L #8,D0
00000F46  5588                    2818m     SUB.L #2,A0
00000F48                          2819mm     PROGRAM D0, (A0), D2
00000F48  3080                    2820mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00000F4A                          2821mm 
00000F4A                          2822mm WAIT_FOR_COMPLETE_178
00000F4A  3410                    2823mm         MOVE.W (A0),D2
00000F4C                          2824mm 
00000F4C                          2825mm         IF.W D2 <NE> D0 THEN
00000F4C  B440                    2826mms     CMP.W   D0,D2
00000F4E  6700 0004               2827mms     BEQ _00000012
00000F52  60F6                    2828mm             BRA WAIT_FOR_COMPLETE_178
00000F54                          2829mm         ENDI
00000F54                          2830mms _00000012
00000F54                          2831mm         ENDM
00000F54                          2832m     ENDM
00000F54                          2833      ENDF
00000F54  5848                    2834s     ADD.W   #4,A0
00000F56                          2835s _2000000F
00000F56  B0FC 0100               2836s     CMP.W   #START-4,A0
00000F5A  6FC0                    2837s     BLE _2000000E
00000F5C                          2838                                          
00000F5C                          2839m     PROTECT
00000F5C  31FC AAAA 2AAA          2840m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00000F62  31FC 5555 1554          2841m     MOVE.W #$5555,$1554
00000F68  31FC A0A0 2AAA          2842m     MOVE.W #$A0A0,$2AAA
00000F6E                          2843m     ENDM
00000F6E                          2844  
00000F6E  6000 F3D4               2845      BRA MAIN_LOOP
00000F72                          2846      
00000F72                          2847  P
00000F72  7000                    2848      MOVE.L #0,D0                                    ; D0 will be the data to write
00000F74                          2849  
00000F74                          2850      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
00000F74  323C 0000               2851s     MOVE.W  #0,D1
00000F78  6000 0046               2852s     BRA _20000011
00000F7C                          2853s _20000010
00000F7C  E988                    2854          LSL.L #4,D0                                 ; make what we have so far more significant
00000F7E                          2855m         WAIT_CHAR D2,D3                             ; next character -> D2
00000F7E                          2856m WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F7E                 TRUE     2857m     IFEQ DEBUG
00000F7E  1639 00C00003           2858m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F84  0803 0000               2859m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000F88  67F4                    2860m         BEQ WAIT_FOR_READY_180                      ; NOTHING, CHECK AGAIN
00000F8A                          2861m     ENDC
00000F8A                          2862m 
00000F8A                          2863mm     READ_CHAR D2
00000F8A                 TRUE     2864mm     IFEQ DEBUG
00000F8A  1439 00C00007           2865mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
00000F90                          2866mm     ENDC
00000F90                 FALSE    2867mm     IFNE DEBUG
00000F90                          2868mm     ENDC
00000F90                          2869mm 
00000F90  B43C 001B               2870mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000F94  6700 F16E               2871mm     BEQ START
00000F98                          2872mm     ENDM
00000F98                          2873m 
00000F98                 TRUE     2874m     IFEQ DEBUG
00000F98                          2875mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000F98                          2876mm WAIT_FOR_READY_182                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F98                 TRUE     2877mm     IFEQ DEBUG
00000F98  1639 00C00003           2878mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F9E  0803 0002               2879mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FA2  67F4                    2880mm         BEQ WAIT_FOR_READY_182                      ; NO SPACE, CHECK AGAIN
00000FA4  13C2 00C00007           2881mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FAA                          2882mm     ENDC
00000FAA                          2883mm 
00000FAA                 FALSE    2884mm     IFNE DEBUG
00000FAA                          2885mm     ENDC
00000FAA                          2886mm 
00000FAA                          2887mm     ENDM
00000FAA                          2888m     ENDC
00000FAA                          2889m     ENDM
00000FAA                          2890m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00000FAA  41FA 0FEE               2891m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000FAE  0402 0030               2892m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000FB2  C4BC 000000FF           2893m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000FB8  1430 2000               2894m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000FBC                          2895m     ENDM
00000FBC  8002                    2896          OR.B D2,D0
00000FBE                          2897      ENDF
00000FBE  5241                    2898s     ADD.W   #1,D1
00000FC0                          2899s _20000011
00000FC0  B27C 0003               2900s     CMP.W   #3,D1
00000FC4  6FB6                    2901s     BLE _20000010
00000FC6                          2902  
00000FC6                          2903m     PRINT_CRLF D2,A1
00000FC6  43FA 0FFD               2904m     LEA CRLF(PC),A1
00000FCA                          2905mm     PRINT_STR A1,D2
00000FCA                          2906mm LOOP_185
00000FCA  0C11 0000               2907mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000FCE  6700 0016               2908mm     BEQ EXIT_185
00000FD2                          2909mmm     PRINT_CHAR (A1)+,D2
00000FD2                          2910mmm WAIT_FOR_READY_186                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FD2                 TRUE     2911mmm     IFEQ DEBUG
00000FD2  1439 00C00003           2912mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000FD8  0802 0002               2913mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000FDC  67F4                    2914mmm         BEQ WAIT_FOR_READY_186                      ; NO SPACE, CHECK AGAIN
00000FDE  13D9 00C00007           2915mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FE4                          2916mmm     ENDC
00000FE4                          2917mmm 
00000FE4                 FALSE    2918mmm     IFNE DEBUG
00000FE4                          2919mmm     ENDC
00000FE4                          2920mmm 
00000FE4                          2921mmm     ENDM
00000FE4  60E4                    2922mm     BRA LOOP_185
00000FE6                          2923mm EXIT_185
00000FE6                          2924mm     ENDM
00000FE6                          2925m     ENDM
00000FE6                          2926  
00000FE6  2047                    2927      MOVE.L D7,A0                                    ; address accumulator -> target address register
00000FE8  7E00                    2928      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000FEA                          2929  
00000FEA                          2930m     UNPROTECT                                       ; important to only unprotect when we are fully committed (ie, can't escape)
00000FEA  31FC AAAA 2AAA          2931m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000FF0  4E71                    2932m     NOP
00000FF2  31FC 5555 1554          2933m     MOVE.W #$5555,$1554
00000FF8  4E71                    2934m     NOP
00000FFA  31FC 8080 2AAA          2935m     MOVE.W #$8080,$2AAA
00001000  4E71                    2936m     NOP
00001002  31FC AAAA 2AAA          2937m     MOVE.W #$AAAA,$2AAA
00001008  4E71                    2938m     NOP
0000100A  31FC 5555 1554          2939m     MOVE.W #$5555,$1554
00001010  4E71                    2940m     NOP
00001012  31FC 2020 2AAA          2941m     MOVE.W #$2020,$2AAA
00001018                          2942m     ENDM
00001018                          2943                              
00001018                          2944      FOR D7 = #$0 TO #$FFFFFFFF DO                   ; dead timing loop to wait for unprotect
00001018  3E3C 0000               2945s     MOVE.W  #$0,D7
0000101C  6000 0006               2946s     BRA _20000013
00001020                          2947s _20000012
00001020  4E71                    2948          NOP
00001022                          2949      ENDF
00001022  5247                    2950s     ADD.W   #1,D7
00001024                          2951s _20000013
00001024  BE7C FFFF               2952s     CMP.W   #$FFFFFFFF,D7
00001028  6FF6                    2953s     BLE _20000012
0000102A                          2954               
0000102A  45FA 0F85               2955      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000102E                          2956m     PRINT_STR A2,D2
0000102E                          2957m LOOP_188
0000102E  0C12 0000               2958m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001032  6700 0016               2959m     BEQ EXIT_188
00001036                          2960mm     PRINT_CHAR (A2)+,D2
00001036                          2961mm WAIT_FOR_READY_189                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001036                 TRUE     2962mm     IFEQ DEBUG
00001036  1439 00C00003           2963mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000103C  0802 0002               2964mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001040  67F4                    2965mm         BEQ WAIT_FOR_READY_189                      ; NO SPACE, CHECK AGAIN
00001042  13DA 00C00007           2966mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001048                          2967mm     ENDC
00001048                          2968mm 
00001048                 FALSE    2969mm     IFNE DEBUG
00001048                          2970mm     ENDC
00001048                          2971mm 
00001048                          2972mm     ENDM
00001048  60E4                    2973m     BRA LOOP_188
0000104A                          2974m EXIT_188
0000104A                          2975m     ENDM
0000104A                          2976  
0000104A                          2977m     PRINT_REG D0,D3,D4,D5,A2
0000104A  45FA 0F7F               2978m     LEA OX(PC),A2
0000104E                          2979mm     PRINT_STR A2,D3
0000104E                          2980mm LOOP_191
0000104E  0C12 0000               2981mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001052  6700 0016               2982mm     BEQ EXIT_191
00001056                          2983mmm     PRINT_CHAR (A2)+,D3
00001056                          2984mmm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001056                 TRUE     2985mmm     IFEQ DEBUG
00001056  1639 00C00003           2986mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000105C  0803 0002               2987mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001060  67F4                    2988mmm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00001062  13DA 00C00007           2989mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001068                          2990mmm     ENDC
00001068                          2991mmm 
00001068                 FALSE    2992mmm     IFNE DEBUG
00001068                          2993mmm     ENDC
00001068                          2994mmm 
00001068                          2995mmm     ENDM
00001068  60E4                    2996mm     BRA LOOP_191
0000106A                          2997mm EXIT_191
0000106A                          2998mm     ENDM
0000106A  7A07                    2999m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000106C                          3000m LOOP_190
0000106C                          3001mm     BIN2HEX D0,D4,A2
0000106C  45FA 0F1C               3002mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001070  E998                    3003mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001072  1800                    3004mm     MOVE.B D0,D4
00001074  0284 0000000F           3005mm     ANDI.L #$F,D4
0000107A  1832 4000               3006mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000107E                          3007mm     ENDM
0000107E                          3008mm     PRINT_CHAR D4,D3
0000107E                          3009mm WAIT_FOR_READY_194                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000107E                 TRUE     3010mm     IFEQ DEBUG
0000107E  1639 00C00003           3011mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001084  0803 0002               3012mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001088  67F4                    3013mm         BEQ WAIT_FOR_READY_194                      ; NO SPACE, CHECK AGAIN
0000108A  13C4 00C00007           3014mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001090                          3015mm     ENDC
00001090                          3016mm 
00001090                 FALSE    3017mm     IFNE DEBUG
00001090                          3018mm     ENDC
00001090                          3019mm 
00001090                          3020mm     ENDM
00001090  57CD FFDA               3021m     DBEQ D5,LOOP_190
00001094                          3022m     ENDM
00001094                          3023  
00001094  45FA 0F38               3024      LEA TO(PC),A2
00001098                          3025m     PRINT_STR A2,D3
00001098                          3026m LOOP_195
00001098  0C12 0000               3027m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000109C  6700 0016               3028m     BEQ EXIT_195
000010A0                          3029mm     PRINT_CHAR (A2)+,D3
000010A0                          3030mm WAIT_FOR_READY_196                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010A0                 TRUE     3031mm     IFEQ DEBUG
000010A0  1639 00C00003           3032mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010A6  0803 0002               3033mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010AA  67F4                    3034mm         BEQ WAIT_FOR_READY_196                      ; NO SPACE, CHECK AGAIN
000010AC  13DA 00C00007           3035mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010B2                          3036mm     ENDC
000010B2                          3037mm 
000010B2                 FALSE    3038mm     IFNE DEBUG
000010B2                          3039mm     ENDC
000010B2                          3040mm 
000010B2                          3041mm     ENDM
000010B2  60E4                    3042m     BRA LOOP_195
000010B4                          3043m EXIT_195
000010B4                          3044m     ENDM
000010B4                          3045  
000010B4  2408                    3046      MOVE.L A0,D2
000010B6                          3047m     PRINT_REG D2,D3,D4,D5,A2
000010B6  45FA 0F13               3048m     LEA OX(PC),A2
000010BA                          3049mm     PRINT_STR A2,D3
000010BA                          3050mm LOOP_198
000010BA  0C12 0000               3051mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000010BE  6700 0016               3052mm     BEQ EXIT_198
000010C2                          3053mmm     PRINT_CHAR (A2)+,D3
000010C2                          3054mmm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010C2                 TRUE     3055mmm     IFEQ DEBUG
000010C2  1639 00C00003           3056mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010C8  0803 0002               3057mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010CC  67F4                    3058mmm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
000010CE  13DA 00C00007           3059mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000010D4                          3060mmm     ENDC
000010D4                          3061mmm 
000010D4                 FALSE    3062mmm     IFNE DEBUG
000010D4                          3063mmm     ENDC
000010D4                          3064mmm 
000010D4                          3065mmm     ENDM
000010D4  60E4                    3066mm     BRA LOOP_198
000010D6                          3067mm EXIT_198
000010D6                          3068mm     ENDM
000010D6  7A07                    3069m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000010D8                          3070m LOOP_197
000010D8                          3071mm     BIN2HEX D2,D4,A2
000010D8  45FA 0EB0               3072mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000010DC  E99A                    3073mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000010DE  1802                    3074mm     MOVE.B D2,D4
000010E0  0284 0000000F           3075mm     ANDI.L #$F,D4
000010E6  1832 4000               3076mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000010EA                          3077mm     ENDM
000010EA                          3078mm     PRINT_CHAR D4,D3
000010EA                          3079mm WAIT_FOR_READY_201                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010EA                 TRUE     3080mm     IFEQ DEBUG
000010EA  1639 00C00003           3081mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010F0  0803 0002               3082mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000010F4  67F4                    3083mm         BEQ WAIT_FOR_READY_201                      ; NO SPACE, CHECK AGAIN
000010F6  13C4 00C00007           3084mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010FC                          3085mm     ENDC
000010FC                          3086mm 
000010FC                 FALSE    3087mm     IFNE DEBUG
000010FC                          3088mm     ENDC
000010FC                          3089mm 
000010FC                          3090mm     ENDM
000010FC  57CD FFDA               3091m     DBEQ D5,LOOP_197
00001100                          3092m     ENDM
00001100                          3093  
00001100                          3094m     PRINT_CRLF D3,A2
00001100  45FA 0EC3               3095m     LEA CRLF(PC),A2
00001104                          3096mm     PRINT_STR A2,D3
00001104                          3097mm LOOP_203
00001104  0C12 0000               3098mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001108  6700 0016               3099mm     BEQ EXIT_203
0000110C                          3100mmm     PRINT_CHAR (A2)+,D3
0000110C                          3101mmm WAIT_FOR_READY_204                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000110C                 TRUE     3102mmm     IFEQ DEBUG
0000110C  1639 00C00003           3103mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001112  0803 0002               3104mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001116  67F4                    3105mmm         BEQ WAIT_FOR_READY_204                      ; NO SPACE, CHECK AGAIN
00001118  13DA 00C00007           3106mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000111E                          3107mmm     ENDC
0000111E                          3108mmm 
0000111E                 FALSE    3109mmm     IFNE DEBUG
0000111E                          3110mmm     ENDC
0000111E                          3111mmm 
0000111E                          3112mmm     ENDM
0000111E  60E4                    3113mm     BRA LOOP_203
00001120                          3114mm EXIT_203
00001120                          3115mm     ENDM
00001120                          3116m     ENDM
00001120                          3117  
00001120                          3118m     PROGRAM D0,(A0),D2
00001120  3080                    3119m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001122                          3120m 
00001122                          3121m WAIT_FOR_COMPLETE_205
00001122  3410                    3122m         MOVE.W (A0),D2
00001124                          3123m 
00001124                          3124m         IF.W D2 <NE> D0 THEN
00001124  B440                    3125ms     CMP.W   D0,D2
00001126  6700 0004               3126ms     BEQ _00000013
0000112A  60F6                    3127m             BRA WAIT_FOR_COMPLETE_205
0000112C                          3128m         ENDI
0000112C                          3129ms _00000013
0000112C                          3130m         ENDM
0000112C                          3131  
0000112C                          3132m     PROTECT
0000112C  31FC AAAA 2AAA          3133m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001132  31FC 5555 1554          3134m     MOVE.W #$5555,$1554
00001138  31FC A0A0 2AAA          3135m     MOVE.W #$A0A0,$2AAA
0000113E                          3136m     ENDM
0000113E                          3137      
0000113E  6000 F204               3138      BRA MAIN_LOOP
00001142                          3139      
00001142                          3140  X
00001142  45FA 0E9A               3141      LEA STATUS_REGISTER(PC),A2
00001146                          3142m     PRINT_STR A2,D3
00001146                          3143m LOOP_207
00001146  0C12 0000               3144m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000114A  6700 0016               3145m     BEQ EXIT_207
0000114E                          3146mm     PRINT_CHAR (A2)+,D3
0000114E                          3147mm WAIT_FOR_READY_208                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000114E                 TRUE     3148mm     IFEQ DEBUG
0000114E  1639 00C00003           3149mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001154  0803 0002               3150mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001158  67F4                    3151mm         BEQ WAIT_FOR_READY_208                      ; NO SPACE, CHECK AGAIN
0000115A  13DA 00C00007           3152mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001160                          3153mm     ENDC
00001160                          3154mm 
00001160                 FALSE    3155mm     IFNE DEBUG
00001160                          3156mm     ENDC
00001160                          3157mm 
00001160                          3158mm     ENDM
00001160  60E4                    3159m     BRA LOOP_207
00001162                          3160m EXIT_207
00001162                          3161m     ENDM
00001162                          3162  
00001162  40C0                    3163      MOVE SR,D0
00001164                          3164m     PRINT_REG D0,D3,D4,D5,A2
00001164  45FA 0E65               3165m     LEA OX(PC),A2
00001168                          3166mm     PRINT_STR A2,D3
00001168                          3167mm LOOP_210
00001168  0C12 0000               3168mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000116C  6700 0016               3169mm     BEQ EXIT_210
00001170                          3170mmm     PRINT_CHAR (A2)+,D3
00001170                          3171mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001170                 TRUE     3172mmm     IFEQ DEBUG
00001170  1639 00C00003           3173mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001176  0803 0002               3174mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000117A  67F4                    3175mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0000117C  13DA 00C00007           3176mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001182                          3177mmm     ENDC
00001182                          3178mmm 
00001182                 FALSE    3179mmm     IFNE DEBUG
00001182                          3180mmm     ENDC
00001182                          3181mmm 
00001182                          3182mmm     ENDM
00001182  60E4                    3183mm     BRA LOOP_210
00001184                          3184mm EXIT_210
00001184                          3185mm     ENDM
00001184  7A07                    3186m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001186                          3187m LOOP_209
00001186                          3188mm     BIN2HEX D0,D4,A2
00001186  45FA 0E02               3189mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000118A  E998                    3190mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000118C  1800                    3191mm     MOVE.B D0,D4
0000118E  0284 0000000F           3192mm     ANDI.L #$F,D4
00001194  1832 4000               3193mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001198                          3194mm     ENDM
00001198                          3195mm     PRINT_CHAR D4,D3
00001198                          3196mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001198                 TRUE     3197mm     IFEQ DEBUG
00001198  1639 00C00003           3198mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000119E  0803 0002               3199mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011A2  67F4                    3200mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
000011A4  13C4 00C00007           3201mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011AA                          3202mm     ENDC
000011AA                          3203mm 
000011AA                 FALSE    3204mm     IFNE DEBUG
000011AA                          3205mm     ENDC
000011AA                          3206mm 
000011AA                          3207mm     ENDM
000011AA  57CD FFDA               3208m     DBEQ D5,LOOP_209
000011AE                          3209m     ENDM
000011AE                          3210m     PRINT_CRLF D3,A2
000011AE  45FA 0E15               3211m     LEA CRLF(PC),A2
000011B2                          3212mm     PRINT_STR A2,D3
000011B2                          3213mm LOOP_215
000011B2  0C12 0000               3214mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011B6  6700 0016               3215mm     BEQ EXIT_215
000011BA                          3216mmm     PRINT_CHAR (A2)+,D3
000011BA                          3217mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011BA                 TRUE     3218mmm     IFEQ DEBUG
000011BA  1639 00C00003           3219mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011C0  0803 0002               3220mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011C4  67F4                    3221mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
000011C6  13DA 00C00007           3222mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011CC                          3223mmm     ENDC
000011CC                          3224mmm 
000011CC                 FALSE    3225mmm     IFNE DEBUG
000011CC                          3226mmm     ENDC
000011CC                          3227mmm 
000011CC                          3228mmm     ENDM
000011CC  60E4                    3229mm     BRA LOOP_215
000011CE                          3230mm EXIT_215
000011CE                          3231mm     ENDM
000011CE                          3232m     ENDM
000011CE                          3233  
000011CE  45FA 0E09               3234      LEA STACK_POINTER(PC),A2
000011D2                          3235m     PRINT_STR A2,D3
000011D2                          3236m LOOP_217
000011D2  0C12 0000               3237m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011D6  6700 0016               3238m     BEQ EXIT_217
000011DA                          3239mm     PRINT_CHAR (A2)+,D3
000011DA                          3240mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011DA                 TRUE     3241mm     IFEQ DEBUG
000011DA  1639 00C00003           3242mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011E0  0803 0002               3243mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011E4  67F4                    3244mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
000011E6  13DA 00C00007           3245mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011EC                          3246mm     ENDC
000011EC                          3247mm 
000011EC                 FALSE    3248mm     IFNE DEBUG
000011EC                          3249mm     ENDC
000011EC                          3250mm 
000011EC                          3251mm     ENDM
000011EC  60E4                    3252m     BRA LOOP_217
000011EE                          3253m EXIT_217
000011EE                          3254m     ENDM
000011EE                          3255  
000011EE  200F                    3256      MOVE.L SP,D0
000011F0                          3257m     PRINT_REG D0,D3,D4,D5,A2
000011F0  45FA 0DD9               3258m     LEA OX(PC),A2
000011F4                          3259mm     PRINT_STR A2,D3
000011F4                          3260mm LOOP_220
000011F4  0C12 0000               3261mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011F8  6700 0016               3262mm     BEQ EXIT_220
000011FC                          3263mmm     PRINT_CHAR (A2)+,D3
000011FC                          3264mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011FC                 TRUE     3265mmm     IFEQ DEBUG
000011FC  1639 00C00003           3266mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001202  0803 0002               3267mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001206  67F4                    3268mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001208  13DA 00C00007           3269mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000120E                          3270mmm     ENDC
0000120E                          3271mmm 
0000120E                 FALSE    3272mmm     IFNE DEBUG
0000120E                          3273mmm     ENDC
0000120E                          3274mmm 
0000120E                          3275mmm     ENDM
0000120E  60E4                    3276mm     BRA LOOP_220
00001210                          3277mm EXIT_220
00001210                          3278mm     ENDM
00001210  7A07                    3279m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001212                          3280m LOOP_219
00001212                          3281mm     BIN2HEX D0,D4,A2
00001212  45FA 0D76               3282mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001216  E998                    3283mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001218  1800                    3284mm     MOVE.B D0,D4
0000121A  0284 0000000F           3285mm     ANDI.L #$F,D4
00001220  1832 4000               3286mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001224                          3287mm     ENDM
00001224                          3288mm     PRINT_CHAR D4,D3
00001224                          3289mm WAIT_FOR_READY_223                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001224                 TRUE     3290mm     IFEQ DEBUG
00001224  1639 00C00003           3291mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000122A  0803 0002               3292mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000122E  67F4                    3293mm         BEQ WAIT_FOR_READY_223                      ; NO SPACE, CHECK AGAIN
00001230  13C4 00C00007           3294mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001236                          3295mm     ENDC
00001236                          3296mm 
00001236                 FALSE    3297mm     IFNE DEBUG
00001236                          3298mm     ENDC
00001236                          3299mm 
00001236                          3300mm     ENDM
00001236  57CD FFDA               3301m     DBEQ D5,LOOP_219
0000123A                          3302m     ENDM
0000123A                          3303m     PRINT_CRLF D3,A2
0000123A  45FA 0D89               3304m     LEA CRLF(PC),A2
0000123E                          3305mm     PRINT_STR A2,D3
0000123E                          3306mm LOOP_225
0000123E  0C12 0000               3307mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001242  6700 0016               3308mm     BEQ EXIT_225
00001246                          3309mmm     PRINT_CHAR (A2)+,D3
00001246                          3310mmm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001246                 TRUE     3311mmm     IFEQ DEBUG
00001246  1639 00C00003           3312mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000124C  0803 0002               3313mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001250  67F4                    3314mmm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
00001252  13DA 00C00007           3315mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001258                          3316mmm     ENDC
00001258                          3317mmm 
00001258                 FALSE    3318mmm     IFNE DEBUG
00001258                          3319mmm     ENDC
00001258                          3320mmm 
00001258                          3321mmm     ENDM
00001258  60E4                    3322mm     BRA LOOP_225
0000125A                          3323mm EXIT_225
0000125A                          3324mm     ENDM
0000125A                          3325m     ENDM
0000125A                          3326  
0000125A  6000 F0E8               3327      BRA MAIN_LOOP
0000125E                          3328          
0000125E                          3329  EI
0000125E  13FC 0008 00C0000B      3330      MOVE.B #8,DUART_IMR
00001266  027C F8FF               3331      AND.W #$F8FF,SR
0000126A  6000 F0D8               3332      BRA MAIN_LOOP
0000126E                          3333      
0000126E                          3334  DI
0000126E  13FC 0000 00C0000B      3335      MOVE.B #0,DUART_IMR
00001276  007C 0700               3336      OR.W #$0700,SR
0000127A  6000 F0C8               3337      BRA MAIN_LOOP
0000127E                          3338          
0000127E                          3339  HASH
0000127E                          3340m     PROTECT
0000127E  31FC AAAA 2AAA          3341m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001284  31FC 5555 1554          3342m     MOVE.W #$5555,$1554
0000128A  31FC A0A0 2AAA          3343m     MOVE.W #$A0A0,$2AAA
00001290                          3344m     ENDM
00001290  6000 F0B2               3345      BRA MAIN_LOOP
00001294                          3346  IB
00001294  13FC 0038 00A00019      3347      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000129C                          3348      
0000129C                          3349m     WRITE_8 #IDE_DRIVESEL_MASTER, #IDE_DRIVESEL_REGISTER, D0
0000129C  13FC 00FF 00A00007      3350m     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000012A4  103C 0030               3351m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000012A8  0000 0006               3352m     ORI.B #IDE_DRIVESEL_REGISTER, D0
000012AC  13C0 00A00019           3353m     MOVE.B D0, MC68230_PORT_C_DATA
000012B2  0200 00EF               3354m     ANDI.B #~MC68230_PORT_C_WRITE, D0
000012B6  13FC 00E0 00A00013      3355m     MOVE.B #IDE_DRIVESEL_MASTER, MC68230_PORT_B_DATA
000012BE  13C0 00A00019           3356m     MOVE.B D0, MC68230_PORT_C_DATA
000012C4  0000 0010               3357m     ORI.B #MC68230_PORT_C_WRITE, D0
000012C8  13C0 00A00019           3358m     MOVE.B D0, MC68230_PORT_C_DATA
000012CE  13FC 0038 00A00019      3359m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000012D6                          3360m     ENDM
000012D6                          3361m     WAIT_DRIVE_READY D0, D1
000012D6                          3362m LOOP_229
000012D6                          3363mm     READ_IDE_STATUS D0, D1
000012D6                          3364mmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000012D6  13FC 0000 00A00007      3365mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000012DE  123C 0030               3366mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000012E2  0001 0007               3367mmm     ORI.B #IDE_STATUS_REGISTER, D1
000012E6  13C1 00A00019           3368mmm     MOVE.B D1, MC68230_PORT_C_DATA
000012EC  0201 00DF               3369mmm     ANDI.B #~MC68230_PORT_C_READ, D1
000012F0  13C1 00A00019           3370mmm     MOVE.B D1, MC68230_PORT_C_DATA
000012F6  1039 00A00013           3371mmm     MOVE.B MC68230_PORT_B_DATA, D0
000012FC  0001 0020               3372mmm     ORI.B #MC68230_PORT_C_READ, D1
00001300  13C1 00A00019           3373mmm     MOVE.B D1, MC68230_PORT_C_DATA
00001306  13FC 0038 00A00019      3374mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000130E                          3375mmm     ENDM
0000130E                          3376mm     ENDM
0000130E  0800 0006               3377m     BTST #IDE_STATUS_READY, D0
00001312  67C2                    3378m     BEQ LOOP_229
00001314                          3379m     ENDM
00001314                          3380          
00001314                          3381m     SEND_READ_COMMAND_AND_WAIT #0, D0, D1, D2
00001314                          3382mm     WAIT_DRIVE_NOT_BUSY D0, D1
00001314                          3383mm LOOP_233
00001314                          3384mmm     READ_IDE_STATUS D0, D1
00001314                          3385mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
00001314  13FC 0000 00A00007      3386mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000131C  123C 0030               3387mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001320  0001 0007               3388mmmm     ORI.B #IDE_STATUS_REGISTER, D1
00001324  13C1 00A00019           3389mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000132A  0201 00DF               3390mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
0000132E  13C1 00A00019           3391mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001334  1039 00A00013           3392mmmm     MOVE.B MC68230_PORT_B_DATA, D0
0000133A  0001 0020               3393mmmm     ORI.B #MC68230_PORT_C_READ, D1
0000133E  13C1 00A00019           3394mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001344  13FC 0038 00A00019      3395mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000134C                          3396mmmm     ENDM
0000134C                          3397mmm     ENDM
0000134C  0800 0007               3398mm     BTST #IDE_STATUS_BUSY, D0
00001350  66C2                    3399mm     BNE LOOP_233
00001352                          3400mm     ENDM
00001352                          3401mm     SET_READ_ADDRESS #0, D0, D1, D2
00001352                          3402mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D0
00001352  13FC 00FF 00A00007      3403mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000135A  103C 0030               3404mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000135E  0000 0002               3405mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D0
00001362  13C0 00A00019           3406mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001368  0200 00EF               3407mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000136C  13FC 0001 00A00013      3408mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001374  13C0 00A00019           3409mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000137A  0000 0010               3410mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000137E  13C0 00A00019           3411mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001384  13FC 0038 00A00019      3412mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000138C                          3413mmm     ENDM
0000138C  7200                    3414mm     MOVE.L #0,D1
0000138E                          3415mmm     WRITE_8 D1, #IDE_LBA_0_7_REGISTER, D0
0000138E  13FC 00FF 00A00007      3416mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001396  103C 0030               3417mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000139A  0000 0003               3418mmm     ORI.B #IDE_LBA_0_7_REGISTER, D0
0000139E  13C0 00A00019           3419mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013A4  0200 00EF               3420mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000013A8  13C1 00A00013           3421mmm     MOVE.B D1, MC68230_PORT_B_DATA
000013AE  13C0 00A00019           3422mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013B4  0000 0010               3423mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000013B8  13C0 00A00019           3424mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013BE  13FC 0038 00A00019      3425mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000013C6                          3426mmm     ENDM
000013C6  E089                    3427mm     LSR.L #8, D1
000013C8                          3428mmm     WRITE_8 D1, #IDE_LBA_8_15_REGISTER, D0
000013C8  13FC 00FF 00A00007      3429mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000013D0  103C 0030               3430mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000013D4  0000 0004               3431mmm     ORI.B #IDE_LBA_8_15_REGISTER, D0
000013D8  13C0 00A00019           3432mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013DE  0200 00EF               3433mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000013E2  13C1 00A00013           3434mmm     MOVE.B D1, MC68230_PORT_B_DATA
000013E8  13C0 00A00019           3435mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013EE  0000 0010               3436mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000013F2  13C0 00A00019           3437mmm     MOVE.B D0, MC68230_PORT_C_DATA
000013F8  13FC 0038 00A00019      3438mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001400                          3439mmm     ENDM
00001400  E089                    3440mm     LSR.L #8, D1                                
00001402                          3441mmm     WRITE_8 D1, #IDE_LBA_16_23_REGISTER, D0
00001402  13FC 00FF 00A00007      3442mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000140A  103C 0030               3443mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
0000140E  0000 0005               3444mmm     ORI.B #IDE_LBA_16_23_REGISTER, D0
00001412  13C0 00A00019           3445mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001418  0200 00EF               3446mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
0000141C  13C1 00A00013           3447mmm     MOVE.B D1, MC68230_PORT_B_DATA
00001422  13C0 00A00019           3448mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001428  0000 0010               3449mmm     ORI.B #MC68230_PORT_C_WRITE, D0
0000142C  13C0 00A00019           3450mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001432  13FC 0038 00A00019      3451mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000143A                          3452mmm     ENDM
0000143A  E089                    3453mm     LSR.L #8, D1
0000143C                          3454mmm     READ_8 #IDE_DRIVESEL_REGISTER, D2, D0
0000143C  13FC 0000 00A00007      3455mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001444  103C 0030               3456mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001448  0000 0006               3457mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000144C  13C0 00A00019           3458mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001452  0200 00DF               3459mmm     ANDI.B #~MC68230_PORT_C_READ, D0
00001456  13C0 00A00019           3460mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000145C  1439 00A00013           3461mmm     MOVE.B MC68230_PORT_B_DATA, D2
00001462  0000 0020               3462mmm     ORI.B #MC68230_PORT_C_READ, D0
00001466  13C0 00A00019           3463mmm     MOVE.B D0, MC68230_PORT_C_DATA
0000146C  13FC 0038 00A00019      3464mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001474                          3465mmm     ENDM
00001474  0201 000F               3466mm     ANDI.B #$0F,D1
00001478  8401                    3467mm     OR.B D1,D2
0000147A                          3468mmm     WRITE_8 D2, #IDE_DRIVESEL_REGISTER, D0
0000147A  13FC 00FF 00A00007      3469mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001482  103C 0030               3470mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
00001486  0000 0006               3471mmm     ORI.B #IDE_DRIVESEL_REGISTER, D0
0000148A  13C0 00A00019           3472mmm     MOVE.B D0, MC68230_PORT_C_DATA
00001490  0200 00EF               3473mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
00001494  13C2 00A00013           3474mmm     MOVE.B D2, MC68230_PORT_B_DATA
0000149A  13C0 00A00019           3475mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014A0  0000 0010               3476mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014A4  13C0 00A00019           3477mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014AA  13FC 0038 00A00019      3478mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014B2                          3479mmm     ENDM
000014B2                          3480mm     ENDM
000014B2                          3481mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D0
000014B2                          3482mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D0
000014B2  13FC 00FF 00A00007      3483mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000014BA  103C 0030               3484mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D0
000014BE  0000 0007               3485mmm     ORI.B #IDE_COMMAND_REGISTER, D0
000014C2  13C0 00A00019           3486mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014C8  0200 00EF               3487mmm     ANDI.B #~MC68230_PORT_C_WRITE, D0
000014CC  13FC 0020 00A00013      3488mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
000014D4  13C0 00A00019           3489mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014DA  0000 0010               3490mmm     ORI.B #MC68230_PORT_C_WRITE, D0
000014DE  13C0 00A00019           3491mmm     MOVE.B D0, MC68230_PORT_C_DATA
000014E4  13FC 0038 00A00019      3492mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000014EC                          3493mmm     ENDM
000014EC                          3494mm     ENDM
000014EC                          3495mm     WAIT_DRIVE_NOT_BUSY D0, D1
000014EC                          3496mm LOOP_245
000014EC                          3497mmm     READ_IDE_STATUS D0, D1
000014EC                          3498mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
000014EC  13FC 0000 00A00007      3499mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000014F4  123C 0030               3500mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
000014F8  0001 0007               3501mmmm     ORI.B #IDE_STATUS_REGISTER, D1
000014FC  13C1 00A00019           3502mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001502  0201 00DF               3503mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001506  13C1 00A00019           3504mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000150C  1039 00A00013           3505mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001512  0001 0020               3506mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001516  13C1 00A00019           3507mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000151C  13FC 0038 00A00019      3508mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001524                          3509mmmm     ENDM
00001524                          3510mmm     ENDM
00001524  0800 0007               3511mm     BTST #IDE_STATUS_BUSY, D0
00001528  66C2                    3512mm     BNE LOOP_245
0000152A                          3513mm     ENDM
0000152A                          3514mm     WAIT_DRIVE_DRQ D0, D1
0000152A                          3515mm LOOP_248
0000152A                          3516mmm     READ_IDE_STATUS D0, D1
0000152A                          3517mmmm     READ_8 #IDE_STATUS_REGISTER, D0, D1
0000152A  13FC 0000 00A00007      3518mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001532  123C 0030               3519mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D1
00001536  0001 0007               3520mmmm     ORI.B #IDE_STATUS_REGISTER, D1
0000153A  13C1 00A00019           3521mmmm     MOVE.B D1, MC68230_PORT_C_DATA
00001540  0201 00DF               3522mmmm     ANDI.B #~MC68230_PORT_C_READ, D1
00001544  13C1 00A00019           3523mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000154A  1039 00A00013           3524mmmm     MOVE.B MC68230_PORT_B_DATA, D0
00001550  0001 0020               3525mmmm     ORI.B #MC68230_PORT_C_READ, D1
00001554  13C1 00A00019           3526mmmm     MOVE.B D1, MC68230_PORT_C_DATA
0000155A  13FC 0038 00A00019      3527mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001562                          3528mmmm     ENDM
00001562                          3529mmm     ENDM
00001562  0800 0003               3530mm     BTST #IDE_STATUS_DRQ, D0
00001566  67C2                    3531mm     BEQ LOOP_248
00001568                          3532mm     ENDM
00001568                          3533m     ENDM
00001568                          3534      
00001568                          3535      FOR D1 = #0 to #7 DO
00001568  323C 0000               3536s     MOVE.W  #0,D1
0000156C  6000 0098               3537s     BRA _20000015
00001570                          3538s _20000014
00001570                          3539m         READ_32 #IDE_DATA_REGISTER, D0, D6      ; num entries in boot table -> D0 (it's written 8 times to fill the block up)
00001570                          3540mm     READ_16 #IDE_DATA_REGISTER, D0, D6
00001570  13FC 0000 00A00007      3541mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001578  13FC 0000 00A00005      3542mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001580                          3543mm     
00001580  1C3C 0030               3544mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
00001584  0006 0000               3545mm     ORI.B #IDE_DATA_REGISTER, D6
00001588  13C6 00A00019           3546mm     MOVE.B D6, MC68230_PORT_C_DATA
0000158E  0206 00DF               3547mm     ANDI.B #~MC68230_PORT_C_READ, D6
00001592  13C6 00A00019           3548mm     MOVE.B D6, MC68230_PORT_C_DATA
00001598  1039 00A00011           3549mm     MOVE.B MC68230_PORT_A_DATA, D0
0000159E  E148                    3550mm     LSL.W #8, D0
000015A0  1039 00A00013           3551mm     MOVE.B MC68230_PORT_B_DATA, D0
000015A6  0006 0020               3552mm     ORI.B #MC68230_PORT_C_READ, D6
000015AA  13C6 00A00019           3553mm     MOVE.B D6, MC68230_PORT_C_DATA
000015B0  13FC 0038 00A00019      3554mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000015B8                          3555mm     ENDM
000015B8  E188                    3556m     LSL.L #8, D0
000015BA  E188                    3557m     LSL.L #8, D0
000015BC                          3558mm     READ_16 #IDE_DATA_REGISTER, D0, D6
000015BC  13FC 0000 00A00007      3559mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000015C4  13FC 0000 00A00005      3560mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000015CC                          3561mm     
000015CC  1C3C 0030               3562mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6    
000015D0  0006 0000               3563mm     ORI.B #IDE_DATA_REGISTER, D6
000015D4  13C6 00A00019           3564mm     MOVE.B D6, MC68230_PORT_C_DATA
000015DA  0206 00DF               3565mm     ANDI.B #~MC68230_PORT_C_READ, D6
000015DE  13C6 00A00019           3566mm     MOVE.B D6, MC68230_PORT_C_DATA
000015E4  1039 00A00011           3567mm     MOVE.B MC68230_PORT_A_DATA, D0
000015EA  E148                    3568mm     LSL.W #8, D0
000015EC  1039 00A00013           3569mm     MOVE.B MC68230_PORT_B_DATA, D0
000015F2  0006 0020               3570mm     ORI.B #MC68230_PORT_C_READ, D6
000015F6  13C6 00A00019           3571mm     MOVE.B D6, MC68230_PORT_C_DATA
000015FC  13FC 0038 00A00019      3572mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001604                          3573mm     ENDM
00001604                          3574m     ENDM
00001604                          3575      ENDF
00001604  5241                    3576s     ADD.W   #1,D1
00001606                          3577s _20000015
00001606  B27C 0007               3578s     CMP.W   #7,D1
0000160A  6F00 FF64               3579s     BLE _20000014
0000160E  7200                    3580      MOVE.L #0, D1                               ; current boot table index -> D1
00001610                          3581                          
00001610                          3582      IF A5 <EQ> #1 THEN                          ; if we are booting...
00001610  BAFC 0001               3583s     CMP.W   #1,A5
00001614  6600 0018               3584s     BNE _00000014
00001618  CEBC 0000000F           3585          AND.L #$F,D7                            ; consider bottom 4 bits of address accumulator only
0000161E                          3586          IF D7 <GE> D0 THEN                      ; don't boot if off the end of the boot table
0000161E  BE40                    3587s     CMP.W   D0,D7
00001620  6D00 0008               3588s     BLT _00000015
00001624  2A7C 00000002           3589              MOVE.L #2, A5
0000162A                          3590          ENDI
0000162A                          3591s _00000015
0000162A                          3592  
0000162A  2007                    3593          MOVE.L D7, D0                           ; then shorten the boot table to the selected entry 
0000162C  5280                    3594          ADD.L #1, D0
0000162E                          3595      ENDI
0000162E                          3596s _00000014
0000162E                          3597      
0000162E  227C 00000000           3598      MOVE.L #0, A1
00001634                          3599      FOR.B D2 = #0 TO #9 DO                      ; 10 boot table entries / block, each of 48 bytes
00001634  143C 0000               3600s     MOVE.B  #0,D2
00001638  6000 0236               3601s     BRA _20000017
0000163C                          3602s _20000016
0000163C  1A3C 0001               3603          MOVE.B #1, D5                           ; assume empty
00001640                          3604          FOR.B D3 = #0 TO #11 DO                 ; words read from this boot table entry -> D2
00001640  163C 0000               3605s     MOVE.B  #0,D3
00001644  6000 01EE               3606s     BRA _20000019
00001648                          3607s _20000018
00001648                          3608m             READ_32 #IDE_DATA_REGISTER, D4, D7  ; get next word ->D4
00001648                          3609mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001648  13FC 0000 00A00007      3610mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001650  13FC 0000 00A00005      3611mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001658                          3612mm     
00001658  1E3C 0030               3613mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
0000165C  0007 0000               3614mm     ORI.B #IDE_DATA_REGISTER, D7
00001660  13C7 00A00019           3615mm     MOVE.B D7, MC68230_PORT_C_DATA
00001666  0207 00DF               3616mm     ANDI.B #~MC68230_PORT_C_READ, D7
0000166A  13C7 00A00019           3617mm     MOVE.B D7, MC68230_PORT_C_DATA
00001670  1839 00A00011           3618mm     MOVE.B MC68230_PORT_A_DATA, D4
00001676  E14C                    3619mm     LSL.W #8, D4
00001678  1839 00A00013           3620mm     MOVE.B MC68230_PORT_B_DATA, D4
0000167E  0007 0020               3621mm     ORI.B #MC68230_PORT_C_READ, D7
00001682  13C7 00A00019           3622mm     MOVE.B D7, MC68230_PORT_C_DATA
00001688  13FC 0038 00A00019      3623mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001690                          3624mm     ENDM
00001690  E18C                    3625m     LSL.L #8, D4
00001692  E18C                    3626m     LSL.L #8, D4
00001694                          3627mm     READ_16 #IDE_DATA_REGISTER, D4, D7
00001694  13FC 0000 00A00007      3628mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
0000169C  13FC 0000 00A00005      3629mm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
000016A4                          3630mm     
000016A4  1E3C 0030               3631mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
000016A8  0007 0000               3632mm     ORI.B #IDE_DATA_REGISTER, D7
000016AC  13C7 00A00019           3633mm     MOVE.B D7, MC68230_PORT_C_DATA
000016B2  0207 00DF               3634mm     ANDI.B #~MC68230_PORT_C_READ, D7
000016B6  13C7 00A00019           3635mm     MOVE.B D7, MC68230_PORT_C_DATA
000016BC  1839 00A00011           3636mm     MOVE.B MC68230_PORT_A_DATA, D4
000016C2  E14C                    3637mm     LSL.W #8, D4
000016C4  1839 00A00013           3638mm     MOVE.B MC68230_PORT_B_DATA, D4
000016CA  0007 0020               3639mm     ORI.B #MC68230_PORT_C_READ, D7
000016CE  13C7 00A00019           3640mm     MOVE.B D7, MC68230_PORT_C_DATA
000016D4  13FC 0038 00A00019      3641mm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000016DC                          3642mm     ENDM
000016DC                          3643m     ENDM
000016DC                          3644              IF.B D1 <LT> D0 THEN                ; still in the boot table?
000016DC  B200                    3645s     CMP.B   D0,D1
000016DE  6C00 0152               3646s     BGE _00000016
000016E2                          3647                  IF.B D3 <EQ> #0 THEN            ; always handle the empty flag
000016E2  B63C 0000               3648s     CMP.B   #0,D3
000016E6  6600 0004               3649s     BNE _00000017
000016EA  1A04                    3650                      MOVE.B D4, D5               ; empty flag -> D5
000016EC                          3651                  ENDI
000016EC                          3652s _00000017
000016EC                          3653                  
000016EC                          3654                  IF.B D5 <NE> #1 THEN            ; not empty         
000016EC  BA3C 0001               3655s     CMP.B   #1,D5
000016F0  6700 013A               3656s     BEQ _00000018
000016F4                          3657                      IF A5 <EQ> #0 THEN          ; not booting, so print
000016F4  BAFC 0000               3658s     CMP.W   #0,A5
000016F8  6600 00FE               3659s     BNE _00000019
000016FC                          3660                          IF.B D3 <EQ> #0 THEN    ; first word in boot table, print the index
000016FC  B63C 0000               3661s     CMP.B   #0,D3
00001700  6600 0044               3662s     BNE _0000001A
00001704                          3663m                             PRINT_REG_4BIT D1, D6, D7, A0   
00001704  41FA 0884               3664m     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001708  1E01                    3665m     MOVE.B D1,D7
0000170A  0287 0000000F           3666m     ANDI.L #$F,D7
00001710  1E30 7000               3667m     MOVE.B 0(A0,D7),D7                              ; USE THAT AS AN INDEX INTO THE LUT
00001714                          3668mm     PRINT_CHAR D7,D6
00001714                          3669mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001714                 TRUE     3670mm     IFEQ DEBUG
00001714  1C39 00C00003           3671mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000171A  0806 0002               3672mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000171E  67F4                    3673mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
00001720  13C7 00C00007           3674mm         MOVE.B D7,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001726                          3675mm     ENDC
00001726                          3676mm 
00001726                 FALSE    3677mm     IFNE DEBUG
00001726                          3678mm     ENDC
00001726                          3679mm 
00001726                          3680mm     ENDM
00001726                          3681m     ENDM
00001726  41FA 08BB               3682                              LEA INDEX_SEP(PC), A0
0000172A                          3683m                             PRINT_STR A0, D7
0000172A                          3684m LOOP_259
0000172A  0C10 0000               3685m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000172E  6700 0016               3686m     BEQ EXIT_259
00001732                          3687mm     PRINT_CHAR (A0)+,D7
00001732                          3688mm WAIT_FOR_READY_260                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001732                 TRUE     3689mm     IFEQ DEBUG
00001732  1E39 00C00003           3690mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001738  0807 0002               3691mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000173C  67F4                    3692mm         BEQ WAIT_FOR_READY_260                      ; NO SPACE, CHECK AGAIN
0000173E  13D8 00C00007           3693mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001744                          3694mm     ENDC
00001744                          3695mm 
00001744                 FALSE    3696mm     IFNE DEBUG
00001744                          3697mm     ENDC
00001744                          3698mm 
00001744                          3699mm     ENDM
00001744  60E4                    3700m     BRA LOOP_259
00001746                          3701m EXIT_259
00001746                          3702m     ENDM
00001746                          3703                          ENDI
00001746                          3704s _0000001A
00001746                          3705  
00001746                          3706                          IF.B D3 <GT> #1 AND.B D3 <LT> #7 THEN   ; str, print it
00001746  B63C 0001               3707s     CMP.B   #1,D3
0000174A  6F00 002E               3708s     BLE _0000001B
0000174E  B63C 0007               3709s     CMP.B   #7,D3
00001752  6C00 0026               3710s     BGE _0000001B
00001756                          3711                              FOR.B D6 = #0 TO #3 DO
00001756  1C3C 0000               3712s     MOVE.B  #0,D6
0000175A  6000 0018               3713s     BRA _2000001B
0000175E                          3714s _2000001A
0000175E  E19C                    3715                                  ROL.L #8, D4                    
00001760                          3716m                                 PRINT_CHAR D4, D7
00001760                          3717m WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001760                 TRUE     3718m     IFEQ DEBUG
00001760  1E39 00C00003           3719m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001766  0807 0002               3720m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
0000176A  67F4                    3721m         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
0000176C  13C4 00C00007           3722m         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001772                          3723m     ENDC
00001772                          3724m 
00001772                 FALSE    3725m     IFNE DEBUG
00001772                          3726m     ENDC
00001772                          3727m 
00001772                          3728m     ENDM
00001772                          3729                              ENDF
00001772  5206                    3730s     ADD.B   #1,D6
00001774                          3731s _2000001B
00001774  BC3C 0003               3732s     CMP.B   #3,D6
00001778  6FE4                    3733s     BLE _2000001A
0000177A                          3734                          ENDI
0000177A                          3735s _0000001B
0000177A                          3736                      
0000177A                          3737                          IF.B D3 <GT> #7 AND.B D3 <LT> #12 THEN
0000177A  B63C 0007               3738s     CMP.B   #7,D3
0000177E  6F00 0078               3739s     BLE _0000001C
00001782  B63C 000C               3740s     CMP.B   #12,D3
00001786  6C00 0070               3741s     BGE _0000001C
0000178A  2C45                    3742                              MOVE.L D5, A6       ; preserve the empty flag, we're gonna use D5
0000178C  41FA 0855               3743                              LEA INDEX_SEP(PC), A0
00001790                          3744m                             PRINT_STR A0, D7
00001790                          3745m LOOP_262
00001790  0C10 0000               3746m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001794  6700 0016               3747m     BEQ EXIT_262
00001798                          3748mm     PRINT_CHAR (A0)+,D7
00001798                          3749mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001798                 TRUE     3750mm     IFEQ DEBUG
00001798  1E39 00C00003           3751mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000179E  0807 0002               3752mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000017A2  67F4                    3753mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
000017A4  13D8 00C00007           3754mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017AA                          3755mm     ENDC
000017AA                          3756mm 
000017AA                 FALSE    3757mm     IFNE DEBUG
000017AA                          3758mm     ENDC
000017AA                          3759mm 
000017AA                          3760mm     ENDM
000017AA  60E4                    3761m     BRA LOOP_262
000017AC                          3762m EXIT_262
000017AC                          3763m     ENDM
000017AC                          3764m                             PRINT_REG D4, D5, D6, D7, A0
000017AC  41FA 081D               3765m     LEA OX(PC),A0
000017B0                          3766mm     PRINT_STR A0,D5
000017B0                          3767mm LOOP_265
000017B0  0C10 0000               3768mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017B4  6700 0016               3769mm     BEQ EXIT_265
000017B8                          3770mmm     PRINT_CHAR (A0)+,D5
000017B8                          3771mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017B8                 TRUE     3772mmm     IFEQ DEBUG
000017B8  1A39 00C00003           3773mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000017BE  0805 0002               3774mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000017C2  67F4                    3775mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
000017C4  13D8 00C00007           3776mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017CA                          3777mmm     ENDC
000017CA                          3778mmm 
000017CA                 FALSE    3779mmm     IFNE DEBUG
000017CA                          3780mmm     ENDC
000017CA                          3781mmm 
000017CA                          3782mmm     ENDM
000017CA  60E4                    3783mm     BRA LOOP_265
000017CC                          3784mm EXIT_265
000017CC                          3785mm     ENDM
000017CC  7E07                    3786m     MOVE.L #7,D7                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000017CE                          3787m LOOP_264
000017CE                          3788mm     BIN2HEX D4,D6,A0
000017CE  41FA 07BA               3789mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000017D2  E99C                    3790mm     ROL.L #4,D4                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000017D4  1C04                    3791mm     MOVE.B D4,D6
000017D6  0286 0000000F           3792mm     ANDI.L #$F,D6
000017DC  1C30 6000               3793mm     MOVE.B 0(A0,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
000017E0                          3794mm     ENDM
000017E0                          3795mm     PRINT_CHAR D6,D5
000017E0                          3796mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017E0                 TRUE     3797mm     IFEQ DEBUG
000017E0  1A39 00C00003           3798mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000017E6  0805 0002               3799mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000017EA  67F4                    3800mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
000017EC  13C6 00C00007           3801mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
000017F2                          3802mm     ENDC
000017F2                          3803mm 
000017F2                 FALSE    3804mm     IFNE DEBUG
000017F2                          3805mm     ENDC
000017F2                          3806mm 
000017F2                          3807mm     ENDM
000017F2  57CF FFDA               3808m     DBEQ D7,LOOP_264
000017F6                          3809m     ENDM
000017F6  2A0E                    3810                              MOVE.L A6, D5       ; restore the empty flag into D5
000017F8                          3811                          ENDI
000017F8                          3812s _0000001C
000017F8                          3813                      ENDI
000017F8                          3814s _00000019
000017F8                          3815                      
000017F8                          3816                      IF A5 <EQ> #1 THEN          ; save the params if we are booting
000017F8  BAFC 0001               3817s     CMP.W   #1,A5
000017FC  6600 002A               3818s     BNE _0000001D
00001800                          3819                          IF.B D3 <EQ> #8 THEN                        
00001800  B63C 0008               3820s     CMP.B   #8,D3
00001804  6600 0004               3821s     BNE _0000001E
00001808  2244                    3822                              MOVE.L D4, A1       ; length -> A1
0000180A                          3823                          ENDI
0000180A                          3824s _0000001E
0000180A                          3825              
0000180A                          3826                          IF.B D3 <EQ> #9 THEN
0000180A  B63C 0009               3827s     CMP.B   #9,D3
0000180E  6600 0004               3828s     BNE _0000001F
00001812  2444                    3829                              MOVE.L D4, A2       ; start address -> A2
00001814                          3830                          ENDI
00001814                          3831s _0000001F
00001814                          3832  
00001814                          3833                          IF.B D3 <EQ> #10 THEN
00001814  B63C 000A               3834s     CMP.B   #10,D3
00001818  6600 0004               3835s     BNE _00000020
0000181C  2644                    3836                              MOVE.L D4, A3       ; go address -> A3
0000181E                          3837                          ENDI
0000181E                          3838s _00000020
0000181E                          3839  
0000181E                          3840                          IF.B D3 <EQ> #11 THEN
0000181E  B63C 000B               3841s     CMP.B   #11,D3
00001822  6600 0004               3842s     BNE _00000021
00001826  2844                    3843                              MOVE.L D4, A4       ; start block -> A4
00001828                          3844                          ENDI                    
00001828                          3845s _00000021
00001828                          3846                      ENDI
00001828                          3847s _0000001D
00001828                          3848                  ELSE
00001828  6000 0008               3849s     BRA _00000022
0000182C                          3850s _00000018
0000182C  227C 00000000           3851                      MOVE.L #0, A1
00001832                          3852                  ENDI
00001832                          3853s _00000022
00001832                          3854              ENDI            
00001832                          3855s _00000016
00001832                          3856          ENDF
00001832  5203                    3857s     ADD.B   #1,D3
00001834                          3858s _20000019
00001834  B63C 000B               3859s     CMP.B   #11,D3
00001838  6F00 FE0E               3860s     BLE _20000018
0000183C                          3861  
0000183C                          3862          IF A5 <EQ> #0 THEN                  ; not booting?          
0000183C  BAFC 0000               3863s     CMP.W   #0,A5
00001840  6600 002A               3864s     BNE _00000023
00001844                          3865              IF.B D5 <NE> #1 THEN            ; not booting and not empty, so print crlf
00001844  BA3C 0001               3866s     CMP.B   #1,D5
00001848  6700 0022               3867s     BEQ _00000024
0000184C                          3868m                 PRINT_CRLF D7, A0
0000184C  41FA 0777               3869m     LEA CRLF(PC),A0
00001850                          3870mm     PRINT_STR A0,D7
00001850                          3871mm LOOP_270
00001850  0C10 0000               3872mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001854  6700 0016               3873mm     BEQ EXIT_270
00001858                          3874mmm     PRINT_CHAR (A0)+,D7
00001858                          3875mmm WAIT_FOR_READY_271                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001858                 TRUE     3876mmm     IFEQ DEBUG
00001858  1E39 00C00003           3877mmm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
0000185E  0807 0002               3878mmm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001862  67F4                    3879mmm         BEQ WAIT_FOR_READY_271                      ; NO SPACE, CHECK AGAIN
00001864  13D8 00C00007           3880mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000186A                          3881mmm     ENDC
0000186A                          3882mmm 
0000186A                 FALSE    3883mmm     IFNE DEBUG
0000186A                          3884mmm     ENDC
0000186A                          3885mmm 
0000186A                          3886mmm     ENDM
0000186A  60E4                    3887mm     BRA LOOP_270
0000186C                          3888mm EXIT_270
0000186C                          3889mm     ENDM
0000186C                          3890m     ENDM
0000186C                          3891              ENDI
0000186C                          3892s _00000024
0000186C                          3893          ENDI
0000186C                          3894s _00000023
0000186C                          3895          
0000186C  5281                    3896          ADD.L #1,D1                         ; next boot table index
0000186E                          3897      ENDF
0000186E  5202                    3898s     ADD.B   #1,D2
00001870                          3899s _20000017
00001870  B43C 0009               3900s     CMP.B   #9,D2
00001874  6F00 FDC6               3901s     BLE _20000016
00001878                          3902                          
00001878                          3903      IF A5 <NE> #0 THEN                      ; check for boot from empty slot
00001878  BAFC 0000               3904s     CMP.W   #0,A5
0000187C  6700 0034               3905s     BEQ _00000025
00001880                          3906          IF A5 <EQ> #2 OR A1 <EQ> #0  THEN 
00001880  BAFC 0002               3907s     CMP.W   #2,A5
00001884  6708                    3908s     BEQ.S   _00000026
00001886  B2FC 0000               3909s     CMP.W   #0,A1
0000188A  6600 0026               3910s     BNE _00000027
0000188E                          3911s _00000026
0000188E  41FA 075F               3912              LEA NOT_FOUND(PC), A0
00001892                          3913m             PRINT_STR A0, D7
00001892                          3914m LOOP_272
00001892  0C10 0000               3915m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001896  6700 0016               3916m     BEQ EXIT_272
0000189A                          3917mm     PRINT_CHAR (A0)+,D7
0000189A                          3918mm WAIT_FOR_READY_273                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000189A                 TRUE     3919mm     IFEQ DEBUG
0000189A  1E39 00C00003           3920mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000018A0  0807 0002               3921mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000018A4  67F4                    3922mm         BEQ WAIT_FOR_READY_273                      ; NO SPACE, CHECK AGAIN
000018A6  13D8 00C00007           3923mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018AC                          3924mm     ENDC
000018AC                          3925mm 
000018AC                 FALSE    3926mm     IFNE DEBUG
000018AC                          3927mm     ENDC
000018AC                          3928mm 
000018AC                          3929mm     ENDM
000018AC  60E4                    3930m     BRA LOOP_272
000018AE                          3931m EXIT_272
000018AE                          3932m     ENDM
000018AE  6000 EA94               3933              BRA MAIN_LOOP
000018B2                          3934          ENDI
000018B2                          3935s _00000027
000018B2                          3936      ENDI
000018B2                          3937s _00000025
000018B2                          3938      
000018B2                          3939      IF A5 <EQ> #1 THEN                      ; booting?
000018B2  BAFC 0001               3940s     CMP.W   #1,A5
000018B6  6600 031C               3941s     BNE _00000028
000018BA  41FA 072B               3942          LEA BOOT(PC), A0
000018BE                          3943m         PRINT_STR A0, D7
000018BE                          3944m LOOP_274
000018BE  0C10 0000               3945m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000018C2  6700 0016               3946m     BEQ EXIT_274
000018C6                          3947mm     PRINT_CHAR (A0)+,D7
000018C6                          3948mm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018C6                 TRUE     3949mm     IFEQ DEBUG
000018C6  1E39 00C00003           3950mm         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
000018CC  0807 0002               3951mm         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
000018D0  67F4                    3952mm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
000018D2  13D8 00C00007           3953mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018D8                          3954mm     ENDC
000018D8                          3955mm 
000018D8                 FALSE    3956mm     IFNE DEBUG
000018D8                          3957mm     ENDC
000018D8                          3958mm 
000018D8                          3959mm     ENDM
000018D8  60E4                    3960m     BRA LOOP_274
000018DA                          3961m EXIT_274
000018DA                          3962m     ENDM
000018DA                          3963      
000018DA  2009                    3964          MOVE.L A1, D0                       ; length -> D0              
000018DC  220C                    3965          MOVE.L A4, D1                       ; start block -> D1
000018DE                          3966          
000018DE                          3967          WHILE.L D0 <GT> #0 DO
000018DE                          3968s _10000016
000018DE  B0BC 00000000           3969s     CMP.L   #0,D0
000018E4  6F00 02CC               3970s     BLE _10000017
000018E8                          3971m             SEND_READ_COMMAND_AND_WAIT D1, D5, D6, D7
000018E8                          3972mm     WAIT_DRIVE_NOT_BUSY D5, D6
000018E8                          3973mm LOOP_277
000018E8                          3974mmm     READ_IDE_STATUS D5, D6
000018E8                          3975mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
000018E8  13FC 0000 00A00007      3976mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
000018F0  1C3C 0030               3977mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
000018F4  0006 0007               3978mmmm     ORI.B #IDE_STATUS_REGISTER, D6
000018F8  13C6 00A00019           3979mmmm     MOVE.B D6, MC68230_PORT_C_DATA
000018FE  0206 00DF               3980mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001902  13C6 00A00019           3981mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001908  1A39 00A00013           3982mmmm     MOVE.B MC68230_PORT_B_DATA, D5
0000190E  0006 0020               3983mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001912  13C6 00A00019           3984mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001918  13FC 0038 00A00019      3985mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001920                          3986mmmm     ENDM
00001920                          3987mmm     ENDM
00001920  0805 0007               3988mm     BTST #IDE_STATUS_BUSY, D5
00001924  66C2                    3989mm     BNE LOOP_277
00001926                          3990mm     ENDM
00001926                          3991mm     SET_READ_ADDRESS D1, D5, D6, D7
00001926                          3992mmm     WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, D5
00001926  13FC 00FF 00A00007      3993mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000192E  1A3C 0030               3994mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001932  0005 0002               3995mmm     ORI.B #IDE_SECTOR_COUNT_REGISTER, D5
00001936  13C5 00A00019           3996mmm     MOVE.B D5, MC68230_PORT_C_DATA
0000193C  0205 00EF               3997mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001940  13FC 0001 00A00013      3998mmm     MOVE.B #1, MC68230_PORT_B_DATA
00001948  13C5 00A00019           3999mmm     MOVE.B D5, MC68230_PORT_C_DATA
0000194E  0005 0010               4000mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001952  13C5 00A00019           4001mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001958  13FC 0038 00A00019      4002mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001960                          4003mmm     ENDM
00001960  2C01                    4004mm     MOVE.L D1,D6
00001962                          4005mmm     WRITE_8 D6, #IDE_LBA_0_7_REGISTER, D5
00001962  13FC 00FF 00A00007      4006mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
0000196A  1A3C 0030               4007mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
0000196E  0005 0003               4008mmm     ORI.B #IDE_LBA_0_7_REGISTER, D5
00001972  13C5 00A00019           4009mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001978  0205 00EF               4010mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
0000197C  13C6 00A00013           4011mmm     MOVE.B D6, MC68230_PORT_B_DATA
00001982  13C5 00A00019           4012mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001988  0005 0010               4013mmm     ORI.B #MC68230_PORT_C_WRITE, D5
0000198C  13C5 00A00019           4014mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001992  13FC 0038 00A00019      4015mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
0000199A                          4016mmm     ENDM
0000199A  E08E                    4017mm     LSR.L #8, D6
0000199C                          4018mmm     WRITE_8 D6, #IDE_LBA_8_15_REGISTER, D5
0000199C  13FC 00FF 00A00007      4019mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019A4  1A3C 0030               4020mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019A8  0005 0004               4021mmm     ORI.B #IDE_LBA_8_15_REGISTER, D5
000019AC  13C5 00A00019           4022mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019B2  0205 00EF               4023mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019B6  13C6 00A00013           4024mmm     MOVE.B D6, MC68230_PORT_B_DATA
000019BC  13C5 00A00019           4025mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019C2  0005 0010               4026mmm     ORI.B #MC68230_PORT_C_WRITE, D5
000019C6  13C5 00A00019           4027mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019CC  13FC 0038 00A00019      4028mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
000019D4                          4029mmm     ENDM
000019D4  E08E                    4030mm     LSR.L #8, D6                                
000019D6                          4031mmm     WRITE_8 D6, #IDE_LBA_16_23_REGISTER, D5
000019D6  13FC 00FF 00A00007      4032mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
000019DE  1A3C 0030               4033mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
000019E2  0005 0005               4034mmm     ORI.B #IDE_LBA_16_23_REGISTER, D5
000019E6  13C5 00A00019           4035mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019EC  0205 00EF               4036mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
000019F0  13C6 00A00013           4037mmm     MOVE.B D6, MC68230_PORT_B_DATA
000019F6  13C5 00A00019           4038mmm     MOVE.B D5, MC68230_PORT_C_DATA
000019FC  0005 0010               4039mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A00  13C5 00A00019           4040mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A06  13FC 0038 00A00019      4041mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A0E                          4042mmm     ENDM
00001A0E  E08E                    4043mm     LSR.L #8, D6
00001A10                          4044mmm     READ_8 #IDE_DRIVESEL_REGISTER, D7, D5
00001A10  13FC 0000 00A00007      4045mmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001A18  1A3C 0030               4046mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A1C  0005 0006               4047mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001A20  13C5 00A00019           4048mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A26  0205 00DF               4049mmm     ANDI.B #~MC68230_PORT_C_READ, D5
00001A2A  13C5 00A00019           4050mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A30  1E39 00A00013           4051mmm     MOVE.B MC68230_PORT_B_DATA, D7
00001A36  0005 0020               4052mmm     ORI.B #MC68230_PORT_C_READ, D5
00001A3A  13C5 00A00019           4053mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A40  13FC 0038 00A00019      4054mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A48                          4055mmm     ENDM
00001A48  0206 000F               4056mm     ANDI.B #$0F,D6
00001A4C  8E06                    4057mm     OR.B D6,D7
00001A4E                          4058mmm     WRITE_8 D7, #IDE_DRIVESEL_REGISTER, D5
00001A4E  13FC 00FF 00A00007      4059mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A56  1A3C 0030               4060mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A5A  0005 0006               4061mmm     ORI.B #IDE_DRIVESEL_REGISTER, D5
00001A5E  13C5 00A00019           4062mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A64  0205 00EF               4063mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001A68  13C7 00A00013           4064mmm     MOVE.B D7, MC68230_PORT_B_DATA
00001A6E  13C5 00A00019           4065mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A74  0005 0010               4066mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001A78  13C5 00A00019           4067mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A7E  13FC 0038 00A00019      4068mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001A86                          4069mmm     ENDM
00001A86                          4070mm     ENDM
00001A86                          4071mm     SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, D5
00001A86                          4072mmm     WRITE_8 #IDE_COMMAND_READ_WITH_RETRY, #IDE_COMMAND_REGISTER, D5
00001A86  13FC 00FF 00A00007      4073mmm     MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00001A8E  1A3C 0030               4074mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D5
00001A92  0005 0007               4075mmm     ORI.B #IDE_COMMAND_REGISTER, D5
00001A96  13C5 00A00019           4076mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001A9C  0205 00EF               4077mmm     ANDI.B #~MC68230_PORT_C_WRITE, D5
00001AA0  13FC 0020 00A00013      4078mmm     MOVE.B #IDE_COMMAND_READ_WITH_RETRY, MC68230_PORT_B_DATA
00001AA8  13C5 00A00019           4079mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AAE  0005 0010               4080mmm     ORI.B #MC68230_PORT_C_WRITE, D5
00001AB2  13C5 00A00019           4081mmm     MOVE.B D5, MC68230_PORT_C_DATA
00001AB8  13FC 0038 00A00019      4082mmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AC0                          4083mmm     ENDM
00001AC0                          4084mm     ENDM
00001AC0                          4085mm     WAIT_DRIVE_NOT_BUSY D5, D6
00001AC0                          4086mm LOOP_289
00001AC0                          4087mmm     READ_IDE_STATUS D5, D6
00001AC0                          4088mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001AC0  13FC 0000 00A00007      4089mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001AC8  1C3C 0030               4090mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001ACC  0006 0007               4091mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001AD0  13C6 00A00019           4092mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001AD6  0206 00DF               4093mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001ADA  13C6 00A00019           4094mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001AE0  1A39 00A00013           4095mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001AE6  0006 0020               4096mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001AEA  13C6 00A00019           4097mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001AF0  13FC 0038 00A00019      4098mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001AF8                          4099mmmm     ENDM
00001AF8                          4100mmm     ENDM
00001AF8  0805 0007               4101mm     BTST #IDE_STATUS_BUSY, D5
00001AFC  66C2                    4102mm     BNE LOOP_289
00001AFE                          4103mm     ENDM
00001AFE                          4104mm     WAIT_DRIVE_DRQ D5, D6
00001AFE                          4105mm LOOP_292
00001AFE                          4106mmm     READ_IDE_STATUS D5, D6
00001AFE                          4107mmmm     READ_8 #IDE_STATUS_REGISTER, D5, D6
00001AFE  13FC 0000 00A00007      4108mmmm     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B06  1C3C 0030               4109mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D6
00001B0A  0006 0007               4110mmmm     ORI.B #IDE_STATUS_REGISTER, D6
00001B0E  13C6 00A00019           4111mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B14  0206 00DF               4112mmmm     ANDI.B #~MC68230_PORT_C_READ, D6
00001B18  13C6 00A00019           4113mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B1E  1A39 00A00013           4114mmmm     MOVE.B MC68230_PORT_B_DATA, D5
00001B24  0006 0020               4115mmmm     ORI.B #MC68230_PORT_C_READ, D6
00001B28  13C6 00A00019           4116mmmm     MOVE.B D6, MC68230_PORT_C_DATA
00001B2E  13FC 0038 00A00019      4117mmmm     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B36                          4118mmmm     ENDM
00001B36                          4119mmm     ENDM
00001B36  0805 0003               4120mm     BTST #IDE_STATUS_DRQ, D5
00001B3A  67C2                    4121mm     BEQ LOOP_292
00001B3C                          4122mm     ENDM
00001B3C                          4123m     ENDM
00001B3C                          4124m             PRINT_CHAR #'.', D7
00001B3C                          4125m WAIT_FOR_READY_295                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001B3C                 TRUE     4126m     IFEQ DEBUG
00001B3C  1E39 00C00003           4127m         MOVE.B DUART_SRA,D7                         ; READ STATUS REGISTER
00001B42  0807 0002               4128m         BTST #2,D7                                  ; CHECK FOR SPACE TO SEND
00001B46  67F4                    4129m         BEQ WAIT_FOR_READY_295                      ; NO SPACE, CHECK AGAIN
00001B48  13FC 002E 00C00007      4130m         MOVE.B #'.',DUART_TXA                           ; SEND THE NEXT CHARACTER
00001B50                          4131m     ENDC
00001B50                          4132m 
00001B50                 FALSE    4133m     IFNE DEBUG
00001B50                          4134m     ENDC
00001B50                          4135m 
00001B50                          4136m     ENDM
00001B50                          4137              
00001B50                          4138              FOR.L D3 = #0 TO #255 DO
00001B50  7600                    4139s     MOVE.L  #0,D3
00001B52  6000 0050               4140s     BRA _2000001D
00001B56                          4141s _2000001C
00001B56                          4142m                 READ_16 #IDE_DATA_REGISTER, D4, D7
00001B56  13FC 0000 00A00007      4143m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00001B5E  13FC 0000 00A00005      4144m     MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00001B66                          4145m     
00001B66  1E3C 0030               4146m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), D7    
00001B6A  0007 0000               4147m     ORI.B #IDE_DATA_REGISTER, D7
00001B6E  13C7 00A00019           4148m     MOVE.B D7, MC68230_PORT_C_DATA
00001B74  0207 00DF               4149m     ANDI.B #~MC68230_PORT_C_READ, D7
00001B78  13C7 00A00019           4150m     MOVE.B D7, MC68230_PORT_C_DATA
00001B7E  1839 00A00011           4151m     MOVE.B MC68230_PORT_A_DATA, D4
00001B84  E14C                    4152m     LSL.W #8, D4
00001B86  1839 00A00013           4153m     MOVE.B MC68230_PORT_B_DATA, D4
00001B8C  0007 0020               4154m     ORI.B #MC68230_PORT_C_READ, D7
00001B90  13C7 00A00019           4155m     MOVE.B D7, MC68230_PORT_C_DATA
00001B96  13FC 0038 00A00019      4156m     MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00001B9E                          4157m     ENDM
00001B9E  34C4                    4158                  MOVE.W D4,(A2)+
00001BA0  5580                    4159                  SUB.L #2, D0
00001BA2                          4160              ENDF
00001BA2  5283                    4161s     ADD.L   #1,D3
00001BA4                          4162s _2000001D
00001BA4  B6BC 000000FF           4163s     CMP.L   #255,D3
00001BAA  6FAA                    4164s     BLE _2000001C
00001BAC                          4165          
00001BAC  5281                    4166              ADD.L #1, D1                    ; next block
00001BAE                          4167          ENDW
00001BAE  6000 FD2E               4168s     BRA _10000016
00001BB2                          4169s _10000017
00001BB2                          4170  
00001BB2                          4171m         PRINT_CRLF D3, A6   
00001BB2  4DFA 0411               4172m     LEA CRLF(PC),A6
00001BB6                          4173mm     PRINT_STR A6,D3
00001BB6                          4174mm LOOP_298
00001BB6  0C16 0000               4175mm     CMP.B #NULL,(A6)                                ; 0 -> DONE
00001BBA  6700 0016               4176mm     BEQ EXIT_298
00001BBE                          4177mmm     PRINT_CHAR (A6)+,D3
00001BBE                          4178mmm WAIT_FOR_READY_299                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001BBE                 TRUE     4179mmm     IFEQ DEBUG
00001BBE  1639 00C00003           4180mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001BC4  0803 0002               4181mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001BC8  67F4                    4182mmm         BEQ WAIT_FOR_READY_299                      ; NO SPACE, CHECK AGAIN
00001BCA  13DE 00C00007           4183mmm         MOVE.B (A6)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001BD0                          4184mmm     ENDC
00001BD0                          4185mmm 
00001BD0                 FALSE    4186mmm     IFNE DEBUG
00001BD0                          4187mmm     ENDC
00001BD0                          4188mmm 
00001BD0                          4189mmm     ENDM
00001BD0  60E4                    4190mm     BRA LOOP_298
00001BD2                          4191mm EXIT_298
00001BD2                          4192mm     ENDM
00001BD2                          4193m     ENDM
00001BD2                          4194      
00001BD2  2E0B                    4195          MOVE.L A3, D7                           ; set go address
00001BD4                          4196      ENDI
00001BD4                          4197s _00000028
00001BD4                          4198  
00001BD4  6000 E76E               4199      BRA MAIN_LOOP
00001BD8                          4200  
00001BD8                          4201  HEX_DIGIT
00001BD8  E98F                    4202      LSL.L #4,D7                                 ; add the next digit in the next 4 bits
00001BDA                          4203m     HEX2BIN D2,D2,A0
00001BDA  41FA 03BE               4204m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001BDE  0402 0030               4205m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001BE2  C4BC 000000FF           4206m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001BE8  1430 2000               4207m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001BEC                          4208m     ENDM
00001BEC  8E02                    4209      OR.B D2,D7  
00001BEE  6000 E774               4210      BRA GET_INPUT
00001BF2                          4211  
00001BF2                          4212  ; exceptions    
00001BF2                          4213  BUS_ERROR_HANDLER
00001BF2                          4214  
00001BF2  41FA 040E               4215      LEA BUS_ERROR(PC),A0
00001BF6                          4216m     PRINT_STR A0,D1
00001BF6                          4217m LOOP_301
00001BF6  0C10 0000               4218m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001BFA  6700 0016               4219m     BEQ EXIT_301
00001BFE                          4220mm     PRINT_CHAR (A0)+,D1
00001BFE                          4221mm WAIT_FOR_READY_302                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001BFE                 TRUE     4222mm     IFEQ DEBUG
00001BFE  1239 00C00003           4223mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C04  0801 0002               4224mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001C08  67F4                    4225mm         BEQ WAIT_FOR_READY_302                      ; NO SPACE, CHECK AGAIN
00001C0A  13D8 00C00007           4226mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C10                          4227mm     ENDC
00001C10                          4228mm 
00001C10                 FALSE    4229mm     IFNE DEBUG
00001C10                          4230mm     ENDC
00001C10                          4231mm 
00001C10                          4232mm     ENDM
00001C10  60E4                    4233m     BRA LOOP_301
00001C12                          4234m EXIT_301
00001C12                          4235m     ENDM
00001C12                          4236  
00001C12  7000                    4237      MOVE.L #0,D0
00001C14  3017                    4238      MOVE.W (SP),D0
00001C16                          4239  
00001C16  0800 0004               4240      BTST #4,D0
00001C1A  6700 0026               4241      BEQ WRITE
00001C1E                          4242      
00001C1E  41FA 03F7               4243      LEA READING(PC),A0
00001C22                          4244m     PRINT_STR A0,D1
00001C22                          4245m LOOP_303
00001C22  0C10 0000               4246m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C26  6700 0016               4247m     BEQ EXIT_303
00001C2A                          4248mm     PRINT_CHAR (A0)+,D1
00001C2A                          4249mm WAIT_FOR_READY_304                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C2A                 TRUE     4250mm     IFEQ DEBUG
00001C2A  1239 00C00003           4251mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C30  0801 0002               4252mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001C34  67F4                    4253mm         BEQ WAIT_FOR_READY_304                      ; NO SPACE, CHECK AGAIN
00001C36  13D8 00C00007           4254mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C3C                          4255mm     ENDC
00001C3C                          4256mm 
00001C3C                 FALSE    4257mm     IFNE DEBUG
00001C3C                          4258mm     ENDC
00001C3C                          4259mm 
00001C3C                          4260mm     ENDM
00001C3C  60E4                    4261m     BRA LOOP_303
00001C3E                          4262m EXIT_303
00001C3E                          4263m     ENDM
00001C3E                          4264  
00001C3E  6000 0022               4265      BRA CONTINUE    
00001C42                          4266  WRITE
00001C42  41FA 03DC               4267      LEA WRITING(PC),A0
00001C46                          4268m     PRINT_STR A0,D1
00001C46                          4269m LOOP_305
00001C46  0C10 0000               4270m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C4A  6700 0016               4271m     BEQ EXIT_305
00001C4E                          4272mm     PRINT_CHAR (A0)+,D1
00001C4E                          4273mm WAIT_FOR_READY_306                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C4E                 TRUE     4274mm     IFEQ DEBUG
00001C4E  1239 00C00003           4275mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001C54  0801 0002               4276mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001C58  67F4                    4277mm         BEQ WAIT_FOR_READY_306                      ; NO SPACE, CHECK AGAIN
00001C5A  13D8 00C00007           4278mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C60                          4279mm     ENDC
00001C60                          4280mm 
00001C60                 FALSE    4281mm     IFNE DEBUG
00001C60                          4282mm     ENDC
00001C60                          4283mm 
00001C60                          4284mm     ENDM
00001C60  60E4                    4285m     BRA LOOP_305
00001C62                          4286m EXIT_305
00001C62                          4287m     ENDM
00001C62                          4288  
00001C62                          4289  CONTINUE
00001C62  222F 0002               4290      MOVE.L 2(SP),D1
00001C66                          4291m     PRINT_REG D1,D2,D3,D4,A0
00001C66  41FA 0363               4292m     LEA OX(PC),A0
00001C6A                          4293mm     PRINT_STR A0,D2
00001C6A                          4294mm LOOP_308
00001C6A  0C10 0000               4295mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001C6E  6700 0016               4296mm     BEQ EXIT_308
00001C72                          4297mmm     PRINT_CHAR (A0)+,D2
00001C72                          4298mmm WAIT_FOR_READY_309                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C72                 TRUE     4299mmm     IFEQ DEBUG
00001C72  1439 00C00003           4300mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001C78  0802 0002               4301mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001C7C  67F4                    4302mmm         BEQ WAIT_FOR_READY_309                      ; NO SPACE, CHECK AGAIN
00001C7E  13D8 00C00007           4303mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001C84                          4304mmm     ENDC
00001C84                          4305mmm 
00001C84                 FALSE    4306mmm     IFNE DEBUG
00001C84                          4307mmm     ENDC
00001C84                          4308mmm 
00001C84                          4309mmm     ENDM
00001C84  60E4                    4310mm     BRA LOOP_308
00001C86                          4311mm EXIT_308
00001C86                          4312mm     ENDM
00001C86  7807                    4313m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001C88                          4314m LOOP_307
00001C88                          4315mm     BIN2HEX D1,D3,A0
00001C88  41FA 0300               4316mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001C8C  E999                    4317mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001C8E  1601                    4318mm     MOVE.B D1,D3
00001C90  0283 0000000F           4319mm     ANDI.L #$F,D3
00001C96  1630 3000               4320mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001C9A                          4321mm     ENDM
00001C9A                          4322mm     PRINT_CHAR D3,D2
00001C9A                          4323mm WAIT_FOR_READY_311                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001C9A                 TRUE     4324mm     IFEQ DEBUG
00001C9A  1439 00C00003           4325mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001CA0  0802 0002               4326mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001CA4  67F4                    4327mm         BEQ WAIT_FOR_READY_311                      ; NO SPACE, CHECK AGAIN
00001CA6  13C3 00C00007           4328mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001CAC                          4329mm     ENDC
00001CAC                          4330mm 
00001CAC                 FALSE    4331mm     IFNE DEBUG
00001CAC                          4332mm     ENDC
00001CAC                          4333mm 
00001CAC                          4334mm     ENDM
00001CAC  57CC FFDA               4335m     DBEQ D4,LOOP_307
00001CB0                          4336m     ENDM
00001CB0                          4337  
00001CB0  41FA 0377               4338      LEA FROM(PC),A0
00001CB4                          4339m     PRINT_STR A0,D0
00001CB4                          4340m LOOP_312
00001CB4  0C10 0000               4341m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CB8  6700 0016               4342m     BEQ EXIT_312
00001CBC                          4343mm     PRINT_CHAR (A0)+,D0
00001CBC                          4344mm WAIT_FOR_READY_313                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CBC                 TRUE     4345mm     IFEQ DEBUG
00001CBC  1039 00C00003           4346mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001CC2  0800 0002               4347mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001CC6  67F4                    4348mm         BEQ WAIT_FOR_READY_313                      ; NO SPACE, CHECK AGAIN
00001CC8  13D8 00C00007           4349mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CCE                          4350mm     ENDC
00001CCE                          4351mm 
00001CCE                 FALSE    4352mm     IFNE DEBUG
00001CCE                          4353mm     ENDC
00001CCE                          4354mm 
00001CCE                          4355mm     ENDM
00001CCE  60E4                    4356m     BRA LOOP_312
00001CD0                          4357m EXIT_312
00001CD0                          4358m     ENDM
00001CD0                          4359  
00001CD0  222F 000A               4360      MOVE.L 10(SP),D1
00001CD4                          4361m     PRINT_REG D1,D2,D3,D4,A0
00001CD4  41FA 02F5               4362m     LEA OX(PC),A0
00001CD8                          4363mm     PRINT_STR A0,D2
00001CD8                          4364mm LOOP_315
00001CD8  0C10 0000               4365mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001CDC  6700 0016               4366mm     BEQ EXIT_315
00001CE0                          4367mmm     PRINT_CHAR (A0)+,D2
00001CE0                          4368mmm WAIT_FOR_READY_316                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001CE0                 TRUE     4369mmm     IFEQ DEBUG
00001CE0  1439 00C00003           4370mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001CE6  0802 0002               4371mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001CEA  67F4                    4372mmm         BEQ WAIT_FOR_READY_316                      ; NO SPACE, CHECK AGAIN
00001CEC  13D8 00C00007           4373mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001CF2                          4374mmm     ENDC
00001CF2                          4375mmm 
00001CF2                 FALSE    4376mmm     IFNE DEBUG
00001CF2                          4377mmm     ENDC
00001CF2                          4378mmm 
00001CF2                          4379mmm     ENDM
00001CF2  60E4                    4380mm     BRA LOOP_315
00001CF4                          4381mm EXIT_315
00001CF4                          4382mm     ENDM
00001CF4  7807                    4383m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001CF6                          4384m LOOP_314
00001CF6                          4385mm     BIN2HEX D1,D3,A0
00001CF6  41FA 0292               4386mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001CFA  E999                    4387mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001CFC  1601                    4388mm     MOVE.B D1,D3
00001CFE  0283 0000000F           4389mm     ANDI.L #$F,D3
00001D04  1630 3000               4390mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001D08                          4391mm     ENDM
00001D08                          4392mm     PRINT_CHAR D3,D2
00001D08                          4393mm WAIT_FOR_READY_318                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D08                 TRUE     4394mm     IFEQ DEBUG
00001D08  1439 00C00003           4395mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001D0E  0802 0002               4396mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001D12  67F4                    4397mm         BEQ WAIT_FOR_READY_318                      ; NO SPACE, CHECK AGAIN
00001D14  13C3 00C00007           4398mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001D1A                          4399mm     ENDC
00001D1A                          4400mm 
00001D1A                 FALSE    4401mm     IFNE DEBUG
00001D1A                          4402mm     ENDC
00001D1A                          4403mm 
00001D1A                          4404mm     ENDM
00001D1A  57CC FFDA               4405m     DBEQ D4,LOOP_314
00001D1E                          4406m     ENDM
00001D1E                          4407m     PRINT_CRLF D0,A0
00001D1E  41FA 02A5               4408m     LEA CRLF(PC),A0
00001D22                          4409mm     PRINT_STR A0,D0
00001D22                          4410mm LOOP_320
00001D22  0C10 0000               4411mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D26  6700 0016               4412mm     BEQ EXIT_320
00001D2A                          4413mmm     PRINT_CHAR (A0)+,D0
00001D2A                          4414mmm WAIT_FOR_READY_321                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D2A                 TRUE     4415mmm     IFEQ DEBUG
00001D2A  1039 00C00003           4416mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001D30  0800 0002               4417mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001D34  67F4                    4418mmm         BEQ WAIT_FOR_READY_321                      ; NO SPACE, CHECK AGAIN
00001D36  13D8 00C00007           4419mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D3C                          4420mmm     ENDC
00001D3C                          4421mmm 
00001D3C                 FALSE    4422mmm     IFNE DEBUG
00001D3C                          4423mmm     ENDC
00001D3C                          4424mmm 
00001D3C                          4425mmm     ENDM
00001D3C  60E4                    4426mm     BRA LOOP_320
00001D3E                          4427mm EXIT_320
00001D3E                          4428mm     ENDM
00001D3E                          4429m     ENDM
00001D3E                          4430      
00001D3E  207C 00000004           4431      MOVE.L #4,A0
00001D44  4ED0                    4432      JMP (A0)
00001D46                          4433          
00001D46                          4434  ILLEGAL_HANDLER
00001D46  13FC 0007 00E00001      4435      MOVE.B #7,DISPLAY   
00001D4E  207C 00000004           4436      MOVE.L #4,A0
00001D54  4ED0                    4437      JMP (A0)
00001D56                          4438          
00001D56                          4439  UNHANDLED_HANDLER
00001D56  41FA 02D8               4440      LEA UNHANDLED(PC),A0
00001D5A  4EF9 00001D7E           4441      JMP PRINTIT_RTE
00001D60                          4442      
00001D60                          4443  UNINITIALISED_HANDLER
00001D60  41FA 02E4               4444      LEA UNINITIALISED(PC),A0
00001D64  4EF9 00001D7E           4445      JMP PRINTIT_RTE
00001D6A                          4446  
00001D6A                          4447  TICK_HANDLER
00001D6A  1039 00C0001F           4448      MOVE.B DUART_RESET_OPR,D0
00001D70  41FA 0289               4449      LEA TICK(PC),A0
00001D74  4EF9 00001D7E           4450      JMP PRINTIT_RTE
00001D7A                          4451  
00001D7A                          4452  SPURIOUS_HANDLER
00001D7A  41FA 02E9               4453      LEA SPURIOUS(PC),A0
00001D7E                          4454  PRINTIT_RTE
00001D7E                          4455m     PRINT_STR A0,D1
00001D7E                          4456m LOOP_322
00001D7E  0C10 0000               4457m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001D82  6700 0016               4458m     BEQ EXIT_322
00001D86                          4459mm     PRINT_CHAR (A0)+,D1
00001D86                          4460mm WAIT_FOR_READY_323                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001D86                 TRUE     4461mm     IFEQ DEBUG
00001D86  1239 00C00003           4462mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001D8C  0801 0002               4463mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001D90  67F4                    4464mm         BEQ WAIT_FOR_READY_323                      ; NO SPACE, CHECK AGAIN
00001D92  13D8 00C00007           4465mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001D98                          4466mm     ENDC
00001D98                          4467mm 
00001D98                 FALSE    4468mm     IFNE DEBUG
00001D98                          4469mm     ENDC
00001D98                          4470mm 
00001D98                          4471mm     ENDM
00001D98  60E4                    4472m     BRA LOOP_322
00001D9A                          4473m EXIT_322
00001D9A                          4474m     ENDM
00001D9A  4E73                    4475      RTE 
00001D9C                          4476      
00001D9C  FFFF FFFF               4477      SIMHALT                                             ; halt simulator
00001DA0                          4478  
00001DA0                          4479  ; strings
00001DA0= 50 72 65 73 73 20 ...   4480  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001DB3= 5B 3F 5D 09 09 09 ...   4481  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001DBF= 5B 76 5D 09 09 09 ...   4482          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001DCE= 78 78 78 78 78 78 ...   4483          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001DE6= 78 78 78 78 78 78 ...   4484          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001E06= 78 78 78 78 78 78 ...   4485          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001E27= 78 78 78 78 78 78 ...   4486          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
00001E38= 5B 7A 5D 09 09 09 ...   4487          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
00001E4A= 78 78 78 78 78 78 ...   4488          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
00001E6E= 78 78 78 78 78 78 ...   4489          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00001E90= 23 09 09 09 77 72 ...   4490          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
00001EAA= 5B 78 5D 09 09 09 ...   4491          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001EC1= 5B 49 5D 09 09 09 ...   4492          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
00001EDA= 5B 6F 5D 09 09 09 ...   4493          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00001EF4= 5B 69 5D 09 09 09 ...   4494          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
00001F0A= 78 78 78 78 78 78 ...   4495          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00001F28= 48 75 68 3F 0D 0A 00    4496  HUH  DC.B 'Huh?',CR,LF,NULL
00001F2F= 20 53 20 72 65 63 ...   4497  READ    DC.B ' S records read, start address = ',NULL
00001F51= 57 3A 20 55 6E 6B ...   4498  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001F68= 21 20 43 53 20 66 ...   4499  CS_FAILURE  DC.B '! CS failure at ',NULL
00001F79= 21 20 52 41 4D 20 ...   4500  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001F8A= 30 31 32 33 34 35 ...   4501  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001F9A= 00 01 02 03 04 05 ...   4502  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001FB1= 4C 6F 61 64 69 6E ...   4503  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001FC5= 0D 0A 00                4504  CRLF    DC.B CR,LF,NULL
00001FC8= 3E 20 00                4505  PROMPT  DC.B '> ',NULL
00001FCB= 30 78 00                4506  ox      DC.B '0x',NULL
00001FCE= 20 2D 3E 20 00          4507  to      DC.B ' -> ',NULL
00001FD3= 20 66 6F 72 20 00       4508  for     DC.B ' for ',NULL
00001FD9= 53 50 3A 20 00          4509  STACK_POINTER DC.B 'SP: ',NULL
00001FDE= 53 52 3A 20 00          4510  STATUS_REGISTER DC.B 'SR: ',NULL
00001FE3= 20 3A 20 00             4511  INDEX_SEP DC.B ' : ',NULL
00001FE7= 42 6F 6F 74 69 6E ...   4512  BOOT DC.B 'Booting',NULL
00001FEF= 4E 6F 74 20 66 6F ...   4513  NOT_FOUND DC.B 'Not found',CR,LF,NULL
00001FFB= 74 69 63 6B 0D 0A 00    4514  TICK DC.B 'tick',CR,LF,NULL
00002002= 2A 20 42 75 73 2F ...   4515  BUS_ERROR DC.B '* Bus/address error ',NULL
00002017= 72 65 61 64 69 6E ...   4516  READING DC.B 'reading ',NULL
00002020= 77 72 69 74 69 6E ...   4517  WRITING DC.B 'writing ',NULL
00002029= 20 66 72 6F 6D 20 00    4518  FROM DC.B ' from ',NULL
00002030= 2A 20 55 6E 68 61 ...   4519  UNHANDLED DC.B '* Unhandled interrupt',NULL
00002046= 2A 20 55 6E 69 74 ...   4520  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
00002065= 2A 20 53 70 75 72 ...   4521  SPURIOUS DC.B '* Spurious interrupt',NULL
0000207A= 4D 44 46 2D 6D 6F ...   4522  VERSION DC.B 'MDF-mon V1.150 (12/09/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00002098= 00                      4523  END     DC.B 0
00002099                          4524      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1F8A
BOOT                1FE7
BUS_ERROR           2002
BUS_ERROR_HANDLER   1BF2
CONTINUE            1C62
CONTINUE_54         608
CONTINUE_56         63C
CONTINUE_58         664
CONTINUE_61         6CA
CONTINUE_64         70E
CONTINUE_67         75C
CONTINUE_70         7AC
CONTINUE_73         806
CONTINUE_76         84A
CONTINUE_79         88E
CONTINUE_91         952
CR                  D
CRLF                1FC5
CS_FAILURE          1F68
DEBUG               0
DI                  126E
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            7E4
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       A4A
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
EI                  125E
END                 2098
EXIT_10             288
EXIT_104            A3A
EXIT_107            A6A
EXIT_110            A8A
EXIT_114            AD4
EXIT_117            AF6
EXIT_122            B40
EXIT_124            BBC
EXIT_127            BE0
EXIT_132            C2A
EXIT_139            CBC
EXIT_142            D2C
EXIT_144            D48
EXIT_146            D64
EXIT_148            D80
EXIT_15             2D2
EXIT_151            DA2
EXIT_155            DEC
EXIT_158            E0E
EXIT_162            E58
EXIT_165            E78
EXIT_17             2F2
EXIT_170            EC2
EXIT_185            FE6
EXIT_188            104A
EXIT_191            106A
EXIT_195            10B4
EXIT_198            10D6
EXIT_20             312
EXIT_203            1120
EXIT_207            1162
EXIT_210            1184
EXIT_215            11CE
EXIT_217            11EE
EXIT_22             364
EXIT_220            1210
EXIT_225            125A
EXIT_259            1746
EXIT_262            17AC
EXIT_265            17CC
EXIT_270            186C
EXIT_272            18AE
EXIT_274            18DA
EXIT_28             3F0
EXIT_298            1BD2
EXIT_30             47C
EXIT_301            1C12
EXIT_303            1C3E
EXIT_305            1C62
EXIT_308            1C86
EXIT_312            1CD0
EXIT_315            1CF4
EXIT_32             4A8
EXIT_320            1D3E
EXIT_322            1D9A
EXIT_35             4D2
EXIT_45             580
EXIT_5              240
EXIT_52             5F6
EXIT_7              260
EXIT_82             8EE
EXIT_84             90E
EXIT_88             940
EXIT_94             9B0
EXIT_96             9D0
EXIT_99             9F0
FOR                 1FD3
FROM                2029
G                   B44
GET_INPUT           364
H                   480
HASH                127E
HELP                1DB3
HELPPROMPT          1DA0
HEX2BIN             10B
HEX2BIN_LUT         1F9A
HEX_DIGIT           1BD8
HUH                 1F28
IB                  1294
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
ILLEGAL_HANDLER     1D46
INDEX_SEP           1FE3
L                   C3A
LF                  A
LOADING             1FB1
LOOP_10             26C
LOOP_104            A1E
LOOP_107            A4E
LOOP_109            A8C
LOOP_110            A6E
LOOP_114            AB8
LOOP_116            AF8
LOOP_117            ADA
LOOP_122            B24
LOOP_124            BA0
LOOP_126            BE2
LOOP_127            BC4
LOOP_132            C0E
LOOP_139            CA0
LOOP_142            D10
LOOP_144            D2C
LOOP_146            D48
LOOP_148            D64
LOOP_15             2B6
LOOP_150            DA4
LOOP_151            D86
LOOP_155            DD0
LOOP_157            E10
LOOP_158            DF2
LOOP_162            E3C
LOOP_164            E7A
LOOP_165            E5C
LOOP_17             2D6
LOOP_170            EA6
LOOP_185            FCA
LOOP_188            102E
LOOP_190            106C
LOOP_191            104E
LOOP_195            1098
LOOP_197            10D8
LOOP_198            10BA
LOOP_20             2F6
LOOP_203            1104
LOOP_207            1146
LOOP_209            1186
LOOP_210            1168
LOOP_215            11B2
LOOP_217            11D2
LOOP_219            1212
LOOP_22             348
LOOP_220            11F4
LOOP_225            123E
LOOP_229            12D6
LOOP_233            1314
LOOP_245            14EC
LOOP_248            152A
LOOP_259            172A
LOOP_262            1790
LOOP_264            17CE
LOOP_265            17B0
LOOP_270            1850
LOOP_272            1892
LOOP_274            18BE
LOOP_277            18E8
LOOP_28             3D4
LOOP_289            1AC0
LOOP_292            1AFE
LOOP_298            1BB6
LOOP_30             460
LOOP_301            1BF6
LOOP_303            1C22
LOOP_305            1C46
LOOP_307            1C88
LOOP_308            1C6A
LOOP_312            1CB4
LOOP_314            1CF6
LOOP_315            1CD8
LOOP_32             48C
LOOP_320            1D22
LOOP_322            1D7E
LOOP_34             4D4
LOOP_35             4B6
LOOP_45             564
LOOP_5              224
LOOP_52             5DA
LOOP_7              244
LOOP_82             8D2
LOOP_84             8F2
LOOP_88             924
LOOP_9              28A
LOOP_94             994
LOOP_96             9B4
LOOP_98             9F2
LOOP_99             9D4
MAIN_LOOP           344
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           1FEF
NULL                0
OX                  1FCB
P                   F72
PRINTIT             48C
PRINTIT_RTE         1D7E
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           4E8
PRINT_REG_4BIT      438
PRINT_STR           3CB
PROGRAM             D79
PROGRAM_VECTOR      E10
PROMPT              1FC8
PROTECT             D15
R                   4AC
RAM                 200000
RAM_ERROR           1F79
READ                1F2F
READING             2017
READ_16             1203
READ_32             1430
READ_8              E8E
READ_CHAR           6DD
READ_IDE_STATUS     147F
RESET               4
ROM                 0
S                   5FE
SEND_COMMAND        1701
SEND_READ_COMMAND_AND_WAIT  1730
SET_READ_ADDRESS    159F
SPURIOUS            2065
SPURIOUS_HANDLER    1D7A
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       1FD9
START               104
STATUS_REGISTER     1FDE
TAB                 9
TICK                1FFB
TICK_HANDLER        1D6A
TO                  1FCE
UNHANDLED           2030
UNHANDLED_HANDLER   1D56
UNINITIALISED       2046
UNINITIALISED_HANDLER  1D60
UNPROTECT           C4E
UNREC               1F51
USER                100
V                   488
VECS                8
VERSION             207A
W                   584
WAIT_CHAR           599
WAIT_DRIVE_DRQ      154F
WAIT_DRIVE_NOT_BUSY  14FE
WAIT_DRIVE_READY    14AC
WAIT_FOR_COMPLETE_172  ED6
WAIT_FOR_COMPLETE_174  EF8
WAIT_FOR_COMPLETE_175  F0A
WAIT_FOR_COMPLETE_177  F38
WAIT_FOR_COMPLETE_178  F4A
WAIT_FOR_COMPLETE_205  1122
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_100  9DC
WAIT_FOR_READY_102  A04
WAIT_FOR_READY_105  A26
WAIT_FOR_READY_108  A56
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  A76
WAIT_FOR_READY_113  A9E
WAIT_FOR_READY_115  AC0
WAIT_FOR_READY_118  AE2
WAIT_FOR_READY_120  B0A
WAIT_FOR_READY_123  B2C
WAIT_FOR_READY_125  BA8
WAIT_FOR_READY_128  BCC
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_130  BF4
WAIT_FOR_READY_133  C16
WAIT_FOR_READY_134  C48
WAIT_FOR_READY_136  C62
WAIT_FOR_READY_140  CA8
WAIT_FOR_READY_143  D18
WAIT_FOR_READY_145  D34
WAIT_FOR_READY_147  D50
WAIT_FOR_READY_149  D6C
WAIT_FOR_READY_152  D8E
WAIT_FOR_READY_154  DB6
WAIT_FOR_READY_156  DD8
WAIT_FOR_READY_159  DFA
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E22
WAIT_FOR_READY_163  E44
WAIT_FOR_READY_166  E64
WAIT_FOR_READY_168  E8C
WAIT_FOR_READY_171  EAE
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  F7E
WAIT_FOR_READY_182  F98
WAIT_FOR_READY_186  FD2
WAIT_FOR_READY_189  1036
WAIT_FOR_READY_192  1056
WAIT_FOR_READY_194  107E
WAIT_FOR_READY_196  10A0
WAIT_FOR_READY_199  10C2
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_201  10EA
WAIT_FOR_READY_204  110C
WAIT_FOR_READY_208  114E
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  1170
WAIT_FOR_READY_213  1198
WAIT_FOR_READY_216  11BA
WAIT_FOR_READY_218  11DA
WAIT_FOR_READY_221  11FC
WAIT_FOR_READY_223  1224
WAIT_FOR_READY_226  1246
WAIT_FOR_READY_23   350
WAIT_FOR_READY_24   364
WAIT_FOR_READY_258  1714
WAIT_FOR_READY_26   37E
WAIT_FOR_READY_260  1732
WAIT_FOR_READY_261  1760
WAIT_FOR_READY_263  1798
WAIT_FOR_READY_266  17B8
WAIT_FOR_READY_268  17E0
WAIT_FOR_READY_271  1858
WAIT_FOR_READY_273  189A
WAIT_FOR_READY_275  18C6
WAIT_FOR_READY_29   3DC
WAIT_FOR_READY_295  1B3C
WAIT_FOR_READY_299  1BBE
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_302  1BFE
WAIT_FOR_READY_304  1C2A
WAIT_FOR_READY_306  1C4E
WAIT_FOR_READY_309  1C72
WAIT_FOR_READY_31   468
WAIT_FOR_READY_311  1C9A
WAIT_FOR_READY_313  1CBC
WAIT_FOR_READY_316  1CE0
WAIT_FOR_READY_318  1D08
WAIT_FOR_READY_321  1D2A
WAIT_FOR_READY_323  1D86
WAIT_FOR_READY_33   494
WAIT_FOR_READY_36   4BE
WAIT_FOR_READY_38   4E6
WAIT_FOR_READY_39   4FC
WAIT_FOR_READY_40   512
WAIT_FOR_READY_41   526
WAIT_FOR_READY_42   53A
WAIT_FOR_READY_43   54E
WAIT_FOR_READY_46   56C
WAIT_FOR_READY_47   58E
WAIT_FOR_READY_49   5A8
WAIT_FOR_READY_53   5E2
WAIT_FOR_READY_54   608
WAIT_FOR_READY_55   626
WAIT_FOR_READY_56   63C
WAIT_FOR_READY_58   664
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   6CA
WAIT_FOR_READY_64   70E
WAIT_FOR_READY_67   75C
WAIT_FOR_READY_70   7AC
WAIT_FOR_READY_73   806
WAIT_FOR_READY_76   84A
WAIT_FOR_READY_79   88E
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_83   8DA
WAIT_FOR_READY_85   8FA
WAIT_FOR_READY_86   90E
WAIT_FOR_READY_89   92C
WAIT_FOR_READY_91   952
WAIT_FOR_READY_95   99C
WAIT_FOR_READY_97   9BC
WAIT_FOR_SRECORD    608
WRITE               1C42
WRITE_8             1047
WRITING             2020
X                   1142
Z                   B4A
_00000000           218
_00000001           3A4
_00000002           3B8
_00000003           6AA
_00000004           944
_00000005           6B8
_00000006           7EE
_00000007           792
_00000008           944
_00000009           8CE
_0000000A           944
_0000000B           A3E
_0000000C           A4A
_0000000D           C2A
_0000000E           EE0
_0000000F           F02
_00000010           F14
_00000011           F42
_00000012           F54
_00000013           112C
_00000014           162E
_00000015           162A
_00000016           1832
_00000017           16EC
_00000018           182C
_00000019           17F8
_0000001A           1746
_0000001B           177A
_0000001C           17F8
_0000001D           1828
_0000001E           180A
_0000001F           1814
_00000020           181E
_00000021           1828
_00000022           1832
_00000023           186C
_00000024           186C
_00000025           18B2
_00000026           188E
_00000027           18B2
_00000028           1BD4
_10000000           65A
_10000001           694
_10000002           6C0
_10000003           6FA
_10000004           704
_10000005           73E
_10000006           752
_10000007           78C
_10000008           796
_10000009           7E8
_1000000A           7A2
_1000000B           7DC
_1000000C           7FC
_1000000D           836
_1000000E           840
_1000000F           87A
_10000010           884
_10000011           8BE
_10000012           948
_10000013           982
_10000014           EC2
_10000015           EE6
_10000016           18DE
_10000017           1BB2
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           58C
_20000005           5D0
_20000006           B5C
_20000007           B6C
_20000008           B86
_20000009           C2C
_2000000A           C46
_2000000B           C8A
_2000000C           D02
_2000000D           D06
_2000000E           F1C
_2000000F           F56
_20000010           F7C
_20000011           FC0
_20000012           1020
_20000013           1024
_20000014           1570
_20000015           1606
_20000016           163C
_20000017           1870
_20000018           1648
_20000019           1834
_2000001A           175E
_2000001B           1774
_2000001C           1B56
_2000001D           1BA4
