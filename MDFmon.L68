00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 30/04/2021 12:45:58

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  
00000000                             8      ORG  $0
00000000                             9  
00000000  =00000000                 10  DEBUG               EQU 0
00000000                            11  
00000000                            12  ; constants
00000000  =00000000                 13  NULL                EQU 0
00000000  =00000009                 14  TAB                 EQU 9
00000000  =0000000D                 15  CR                  EQU 13
00000000  =0000000A                 16  LF                  EQU 10
00000000                            17  
00000000  =00000000                 18  ROM                 EQU $0
00000000  =00200000                 19  RAM                 EQU $200000
00000000  =002E0000                 20  STACK_ADDRESS       EQU $2E0000
00000000                            21  
00000000  =00C00000                 22  DUART_BASE          EQU $C00000
00000000  =00000000                 23  DUART_MRA_          EQU $0
00000000  =00000001                 24  DUART_CSRA_         EQU $1
00000000  =00000001                 25  DUART_SRA_          EQU $1
00000000  =00000002                 26  DUART_CRA_          EQU $2
00000000  =00000003                 27  DUART_TXA_          EQU $3
00000000  =00000003                 28  DUART_RXA_          EQU $3
00000000  =00000004                 29  DUART_ACR_          EQU $4
00000000  =00000005                 30  DUART_IMR_          EQU $5
00000000  =00000006                 31  DUART_CTUR_         EQU $6
00000000  =00000007                 32  DUART_CTLR_         EQU $7
00000000  =00000008                 33  DUART_MRB_          EQU $8
00000000  =00000009                 34  DUART_CSRB_         EQU $9
00000000  =00000009                 35  DUART_SRB_          EQU $9
00000000  =0000000A                 36  DUART_CRB_          EQU $A
00000000  =0000000B                 37  DUART_TXB_          EQU $B
00000000  =0000000B                 38  DUART_RXB_          EQU $B
00000000  =0000000C                 39  DUART_IVR_          EQU $C
00000000  =0000000D                 40  DUART_OPCR_         EQU $D
00000000  =0000000E                 41  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 42  DUART_RESET_OPR_    EQU $F
00000000                            43  
00000000  =00C00001                 44  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 45  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 46  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 47  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 48  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 49  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            50  
00000000  =00C00011                 51  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 52  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 53  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 54  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 55  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 56  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            57  
00000000  =00C00009                 58  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 59  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                 60  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                 61  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                 62  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 63  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 64  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 65  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            66  
00000000  =00E00000                 67  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 68  DISPLAY_            EQU $0
00000000  =00E00001                 69  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            70  
00000000                            71  ; macros
00000000                            72  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            73  ; the input register is changed during the process
00000000                            74  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            75  BIN2HEX MACRO
00000000                            76      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            77      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            78      MOVE.B \1,\2
00000000                            79      ANDI.L #$F,\2
00000000                            80      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            81      ENDM
00000000                            82  
00000000                            83  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            84  ; the input register is changed during the process
00000000                            85  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            86  HEX2BIN MACRO
00000000                            87      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            88      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            89      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            90      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            91      ENDM
00000000                            92  
00000000                            93  ; send a single char to the serial port
00000000                            94  ; \1 = char to send, \2 = data register to use for status poll
00000000                            95  ; will stamp on D0 and D1 in debug mode
00000000                            96  PRINT_CHAR MACRO
00000000                            97  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                            98      IFEQ DEBUG
00000000                            99          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           100          BTST #2,\2                                  ; check for space to send
00000000                           101          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           102          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           103      ENDC
00000000                           104  
00000000                           105      IFNE DEBUG
00000000                           106          MOVE.B \1,D1
00000000                           107          MOVE.L #6,D0   
00000000                           108          TRAP #15                                    ; write to terminal in simulator
00000000                           109      ENDC
00000000                           110  
00000000                           111      ENDM
00000000                           112  
00000000                           113  ; send CR,LF to the serial port
00000000                           114  ; \1 = data register to use for status poll, /2 = working address register
00000000                           115  PRINT_CRLF MACRO
00000000                           116      LEA CRLF(PC),\2
00000000                           117      PRINT_STR \2,\1
00000000                           118      ENDM
00000000                           119  
00000000                           120  ; send C-style, zero terminated string to the serial port
00000000                           121  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           122  PRINT_STR MACRO
00000000                           123  LOOP\@
00000000                           124      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           125      BEQ EXIT\@
00000000                           126      PRINT_CHAR (\1)+,\2
00000000                           127      BRA LOOP\@
00000000                           128  EXIT\@
00000000                           129      ENDM
00000000                           130    
00000000                           131  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           132  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           133  PRINT_REG MACRO
00000000                           134      LEA ox(PC),\5
00000000                           135      PRINT_STR \5,\2
00000000                           136      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           137  LOOP\@
00000000                           138      BIN2HEX \1,\3,\5
00000000                           139      PRINT_CHAR \3,\2
00000000                           140      DBEQ \4,LOOP\@
00000000                           141      ENDM
00000000                           142  
00000000                           143  ; wait for a char from the serial port
00000000                           144  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           145  ; will stamp on D0 and D1 in debug mode
00000000                           146  WAIT_CHAR MACRO
00000000                           147  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           148      IFEQ DEBUG
00000000                           149          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           150          BTST #0,\2                                  ; check for character
00000000                           151          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           152      ENDC
00000000                           153  
00000000                           154      READ_CHAR \1
00000000                           155  
00000000                           156      IFEQ DEBUG
00000000                           157          PRINT_CHAR \1,\2                            ; echo it back
00000000                           158      ENDC
00000000                           159      ENDM
00000000                           160  
00000000                           161  ; read a char from the serial port - assumes that there is one!
00000000                           162  ; \ 1= data register for read char
00000000                           163  ; will stamp on D0 and D1 in debug mode
00000000                           164  READ_CHAR MACRO
00000000                           165      IFEQ DEBUG
00000000                           166          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           167      ENDC
00000000                           168      IFNE DEBUG
00000000                           169          MOVE.L #5,D0    
00000000                           170          TRAP #15                                    ; read from keyboard in simulator
00000000                           171          MOVE.L D1,\1
00000000                           172      ENDC
00000000                           173  
00000000                           174      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           175      BEQ START
00000000                           176      ENDM
00000000                           177  
00000000                           178  
00000000                           179  ; read data from the download serial port
00000000                           180  ; \ 1= data register for read char
00000000                           181  DOWNLOAD MACRO
00000000                           182  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           183  
00000000                           184      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           185      BTST #0,\1                                      ; check for character
00000000                           186      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           187  
00000000                           188      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           189  CONTINUE\@
00000000                           190      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           191      BTST #0,\1                                      ; check for character
00000000                           192      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           193      
00000000                           194      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           195      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           196  
00000000                           197      ENDM
00000000                           198  
00000000                           199  ; unprotect the EEPROM
00000000                           200  UNPROTECT MACRO
00000000                           201      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           202      NOP
00000000                           203      MOVE.W #$5555,$1554
00000000                           204      NOP
00000000                           205      MOVE.W #$8080,$2AAA
00000000                           206      NOP
00000000                           207      MOVE.W #$AAAA,$2AAA
00000000                           208      NOP
00000000                           209      MOVE.W #$5555,$1554
00000000                           210      NOP
00000000                           211      MOVE.W #$2020,$2AAA
00000000                           212      ENDM
00000000                           213      
00000000                           214  ; protect the EEPROM
00000000                           215  PROTECT MACRO
00000000                           216      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           217      MOVE.W #$5555,$1554
00000000                           218      MOVE.W #$A0A0,$2AAA
00000000                           219      ENDM
00000000                           220  
00000000                           221  
00000000                           222  ; read two hex digits from the download serial port and convert to a byte
00000000                           223  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           224  DOWNLOAD_BYTE MACRO
00000000                           225      MOVE.B #2,\4
00000000                           226      WHILE.B \4 <GT> 0 DO
00000000                           227          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           228          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           229          PRINT_CHAR \2,\3
00000000                           230          HEX2BIN \2,\2,\6
00000000                           231          OR.B \2,\1
00000000                           232          SUB.B #1,\4
00000000                           233      ENDW
00000000                           234  
00000000                           235      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           236      MOVE.B \1,\2
00000000                           237      ADD.L \1,\5
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; write word to EEPROM
00000000                           242  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           243  PROGRAM MACRO
00000000                           244    MOVE.W \1,\2                                      ; write the data
00000000                           245  
00000000                           246  WAIT_FOR_COMPLETE\@
00000000                           247          MOVE.W \2,\3
00000000                           248  
00000000                           249          IF.W \3 <NE> \1 THEN
00000000                           250              BRA WAIT_FOR_COMPLETE\@
00000000                           251          ENDI
00000000                           252          ENDM
00000000                           253          
00000000                           254  ; program vector to EEPROM
00000000                           255  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           256  PROGRAM_VECTOR MACRO
00000000                           257      ADD.L #2,\2
00000000                           258      PROGRAM \1, (\2), \3                                ; write it
00000000                           259      LSR.L #8,\1
00000000                           260      LSR.L #8,\1
00000000                           261      SUB.L #2,\2
00000000                           262      PROGRAM \1, (\2), \3
00000000                           263      ENDM
00000000                           264  
00000000                           265  
00000000                           266  ; register catalogue
00000000                           267  ; D0 - used for simulator I/O
00000000                           268  ; D1 - used for simulator I/O
00000000                           269  ; D2 - read character
00000000                           270  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           271  ; D6 - working register used in R/W
00000000                           272  ; D7 - address accumulator, reset by download
00000000                           273  ; A0 - address of string to print 
00000000                           274  
00000000                           275  ; start vector
00000000= 002E0000                 276  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 277  RESET   DC.L START                              ; RESET
00000008= 00001418                 278  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 00001418                 279          DC.L BUS_ERROR_HANDLER                  ; ADDRESS ERROR
00000010= 0000156C                 280          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 0000157C                 281          DC.L UNHANDLED_HANDLER
00000018= 0000157C                 282          DC.L UNHANDLED_HANDLER
0000001C= 0000157C                 283          DC.L UNHANDLED_HANDLER
00000020= 0000157C                 284          DC.L UNHANDLED_HANDLER
00000024= 0000157C                 285          DC.L UNHANDLED_HANDLER
00000028= 0000157C                 286          DC.L UNHANDLED_HANDLER
0000002C= 0000157C                 287          DC.L UNHANDLED_HANDLER
00000030= 0000157C                 288          DC.L UNHANDLED_HANDLER
00000034= 0000157C                 289          DC.L UNHANDLED_HANDLER
00000038= 0000157C                 290          DC.L UNHANDLED_HANDLER
0000003C= 0000157C                 291          DC.L UNHANDLED_HANDLER
00000040= 0000157C                 292          DC.L UNHANDLED_HANDLER
00000044= 0000157C                 293          DC.L UNHANDLED_HANDLER
00000048= 0000157C                 294          DC.L UNHANDLED_HANDLER
0000004C= 0000157C                 295          DC.L UNHANDLED_HANDLER
00000050= 0000157C                 296          DC.L UNHANDLED_HANDLER
00000054= 0000157C                 297          DC.L UNHANDLED_HANDLER
00000058= 0000157C                 298          DC.L UNHANDLED_HANDLER
0000005C= 0000157C                 299          DC.L UNHANDLED_HANDLER
00000060= 000015C0                 300          DC.L SPURIOUS_HANDLER
00000064= 0000157C                 301          DC.L UNHANDLED_HANDLER
00000068= 0000157C                 302          DC.L UNHANDLED_HANDLER
0000006C= 0000157C                 303          DC.L UNHANDLED_HANDLER
00000070= 0000157C                 304          DC.L UNHANDLED_HANDLER
00000074= 0000157C                 305          DC.L UNHANDLED_HANDLER
00000078= 0000157C                 306          DC.L UNHANDLED_HANDLER
0000007C= 0000157C                 307          DC.L UNHANDLED_HANDLER
00000080= 0000157C                 308          DC.L UNHANDLED_HANDLER
00000084= 0000157C                 309          DC.L UNHANDLED_HANDLER
00000088= 0000157C                 310          DC.L UNHANDLED_HANDLER
0000008C= 0000157C                 311          DC.L UNHANDLED_HANDLER
00000090= 0000157C                 312          DC.L UNHANDLED_HANDLER
00000094= 0000157C                 313          DC.L UNHANDLED_HANDLER
00000098= 0000157C                 314          DC.L UNHANDLED_HANDLER
0000009C= 0000157C                 315          DC.L UNHANDLED_HANDLER
000000A0= 0000157C                 316          DC.L UNHANDLED_HANDLER
000000A4= 0000157C                 317          DC.L UNHANDLED_HANDLER
000000A8= 0000157C                 318          DC.L UNHANDLED_HANDLER
000000AC= 0000157C                 319          DC.L UNHANDLED_HANDLER
000000B0= 0000157C                 320          DC.L UNHANDLED_HANDLER
000000B4= 0000157C                 321          DC.L UNHANDLED_HANDLER
000000B8= 0000157C                 322          DC.L UNHANDLED_HANDLER
000000BC= 0000157C                 323          DC.L UNHANDLED_HANDLER
000000C0= 0000157C                 324          DC.L UNHANDLED_HANDLER
000000C4= 0000157C                 325          DC.L UNHANDLED_HANDLER
000000C8= 0000157C                 326          DC.L UNHANDLED_HANDLER
000000CC= 0000157C                 327          DC.L UNHANDLED_HANDLER
000000D0= 0000157C                 328          DC.L UNHANDLED_HANDLER
000000D4= 0000157C                 329          DC.L UNHANDLED_HANDLER
000000D8= 0000157C                 330          DC.L UNHANDLED_HANDLER 
000000DC= 0000157C                 331          DC.L UNHANDLED_HANDLER
000000E0= 0000157C                 332          DC.L UNHANDLED_HANDLER
000000E4= 0000157C                 333          DC.L UNHANDLED_HANDLER 
000000E8= 0000157C                 334          DC.L UNHANDLED_HANDLER 
000000EC= 0000157C                 335          DC.L UNHANDLED_HANDLER
000000F0= 0000157C                 336          DC.L UNHANDLED_HANDLER 
000000F4= 0000157C                 337          DC.L UNHANDLED_HANDLER 
000000F8= 0000157C                 338          DC.L UNHANDLED_HANDLER 
000000FC= 0000157C                 339          DC.L UNHANDLED_HANDLER
00000100= 000015E2                 340  USER    DC.L TICK_HANDLER
00000104                           341      ; start of program  
00000104                           342  START
00000104  2E7C 002E0000            343      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       344      MOVE.B #0,DISPLAY
00000112                           345  
00000112  7000                     346      MOVE.L #0,D0
00000114  1039 00C00019            347      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           348  
0000011A                           349  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       350      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       351      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           352      
0000012A                           353      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                354s     MOVE.W  #$50,D1
0000012E  6000 000E                355s     BRA _20000001
00000132                           356s _20000000
00000132  13C1 00C00005            357          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     358          NOP
0000013A                           359      ENDF
0000013A  0441 0010                360s     SUB.W   #$10,D1
0000013E                           361s _20000001
0000013E  B27C 0010                362s     CMP.W   #$10,D1
00000142  6CEE                     363s     BGE _20000000
00000144                           364  
00000144                           365      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                366s     MOVE.W  #$50,D1
00000148  6000 000E                367s     BRA _20000003
0000014C                           368s _20000002
0000014C  13C1 00C00015            369          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     370          NOP
00000154                           371      ENDF
00000154  0441 0010                372s     SUB.W   #$10,D1
00000158                           373s _20000003
00000158  B27C 0010                374s     CMP.W   #$10,D1
0000015C  6CEE                     375s     BGE _20000002
0000015E                           376      
0000015E                           377  ;initialise UART
0000015E  13FC 0000 00C0000B       378      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       379      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       380      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       381      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       382      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           383  
00000186                           384  ; channel A
00000186  13FC 0013 00C00001       385      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       386      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       387      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       388      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           389  
000001A6                           390  ; channel B
000001A6  13FC 0013 00C00011       391      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       392      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       393      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       394      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       395      MOVE.B #64,DUART_IVR
000001CE                           396  
000001CE                           397m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           398m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE                 TRUE      399m     IFEQ DEBUG
000001CE  1239 00C00003            400m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                401m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     402m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       403m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           404m     ENDC
000001E2                           405m 
000001E2                 FALSE     406m     IFNE DEBUG
000001E2                           407m     ENDC
000001E2                           408m 
000001E2                           409m     ENDM
000001E2                           410m     PRINT_CHAR #0,D1
000001E2                           411m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2                 TRUE      412m     IFEQ DEBUG
000001E2  1239 00C00003            413m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                414m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     415m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       416m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           417m     ENDC
000001F6                           418m 
000001F6                 FALSE     419m     IFNE DEBUG
000001F6                           420m     ENDC
000001F6                           421m 
000001F6                           422m     ENDM
000001F6                           423m     PRINT_CHAR #0,D1
000001F6                           424m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6                 TRUE      425m     IFEQ DEBUG
000001F6  1239 00C00003            426m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                427m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     428m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       429m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           430m     ENDC
0000020A                           431m 
0000020A                 FALSE     432m     IFNE DEBUG
0000020A                           433m     ENDC
0000020A                           434m 
0000020A                           435m     ENDM
0000020A                           436      
0000020A                           437      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                438s     CMP.W   #$0F,D0
0000020E  6600 0008                439s     BNE _00000000
00000212  1039 00C00005            440          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           441      ENDI
00000218                           442s _00000000
00000218                           443  
00000218  13FC 0001 00E00001       444      MOVE.B #1,DISPLAY
00000220                           445      
00000220                           446m     PRINT_CRLF D1,A0
00000220  41FA 15D4                447m     LEA CRLF(PC),A0
00000224                           448mm     PRINT_STR A0,D1
00000224                           449mm LOOP_5
00000224  0C10 0000                450mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000228  6700 0016                451mm     BEQ EXIT_5
0000022C                           452mmm     PRINT_CHAR (A0)+,D1
0000022C                           453mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000022C                 TRUE      454mmm     IFEQ DEBUG
0000022C  1239 00C00003            455mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000232  0801 0002                456mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000236  67F4                     457mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000238  13D8 00C00007            458mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000023E                           459mmm     ENDC
0000023E                           460mmm 
0000023E                 FALSE     461mmm     IFNE DEBUG
0000023E                           462mmm     ENDC
0000023E                           463mmm 
0000023E                           464mmm     ENDM
0000023E  60E4                     465mm     BRA LOOP_5
00000240                           466mm EXIT_5
00000240                           467mm     ENDM
00000240                           468m     ENDM
00000240  41FA 1652                469      LEA VERSION(PC),A0
00000244                           470m     PRINT_STR A0,D3
00000244                           471m LOOP_7
00000244  0C10 0000                472m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000248  6700 0016                473m     BEQ EXIT_7
0000024C                           474mm     PRINT_CHAR (A0)+,D3
0000024C                           475mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000024C                 TRUE      476mm     IFEQ DEBUG
0000024C  1639 00C00003            477mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000252  0803 0002                478mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000256  67F4                     479mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000258  13D8 00C00007            480mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000025E                           481mm     ENDC
0000025E                           482mm 
0000025E                 FALSE     483mm     IFNE DEBUG
0000025E                           484mm     ENDC
0000025E                           485mm 
0000025E                           486mm     ENDM
0000025E  60E4                     487m     BRA LOOP_7
00000260                           488m EXIT_7
00000260                           489m     ENDM
00000260                           490  
00000260  41F9 000018B2            491      LEA END,A0
00000266  2008                     492      MOVE.L A0,D0
00000268                           493m     PRINT_REG D0,D1,D2,D3,A0
00000268  41FA 1592                494m     LEA OX(PC),A0
0000026C                           495mm     PRINT_STR A0,D1
0000026C                           496mm LOOP_10
0000026C  0C10 0000                497mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000270  6700 0016                498mm     BEQ EXIT_10
00000274                           499mmm     PRINT_CHAR (A0)+,D1
00000274                           500mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000274                 TRUE      501mmm     IFEQ DEBUG
00000274  1239 00C00003            502mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000027A  0801 0002                503mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000027E  67F4                     504mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
00000280  13D8 00C00007            505mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000286                           506mmm     ENDC
00000286                           507mmm 
00000286                 FALSE     508mmm     IFNE DEBUG
00000286                           509mmm     ENDC
00000286                           510mmm 
00000286                           511mmm     ENDM
00000286  60E4                     512mm     BRA LOOP_10
00000288                           513mm EXIT_10
00000288                           514mm     ENDM
00000288  7607                     515m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000028A                           516m LOOP_9
0000028A                           517mm     BIN2HEX D0,D2,A0
0000028A  41FA 152F                518mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028E  E998                     519mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000290  1400                     520mm     MOVE.B D0,D2
00000292  0282 0000000F            521mm     ANDI.L #$F,D2
00000298  1430 2000                522mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000029C                           523mm     ENDM
0000029C                           524mm     PRINT_CHAR D2,D1
0000029C                           525mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029C                 TRUE      526mm     IFEQ DEBUG
0000029C  1239 00C00003            527mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002A2  0801 0002                528mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002A6  67F4                     529mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
000002A8  13C2 00C00007            530mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AE                           531mm     ENDC
000002AE                           532mm 
000002AE                 FALSE     533mm     IFNE DEBUG
000002AE                           534mm     ENDC
000002AE                           535mm 
000002AE                           536mm     ENDM
000002AE  57CB FFDA                537m     DBEQ D3,LOOP_9
000002B2                           538m     ENDM
000002B2                           539m     PRINT_CRLF D1,A0
000002B2  41FA 1542                540m     LEA CRLF(PC),A0
000002B6                           541mm     PRINT_STR A0,D1
000002B6                           542mm LOOP_15
000002B6  0C10 0000                543mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002BA  6700 0016                544mm     BEQ EXIT_15
000002BE                           545mmm     PRINT_CHAR (A0)+,D1
000002BE                           546mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BE                 TRUE      547mmm     IFEQ DEBUG
000002BE  1239 00C00003            548mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000002C4  0801 0002                549mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000002C8  67F4                     550mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
000002CA  13D8 00C00007            551mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002D0                           552mmm     ENDC
000002D0                           553mmm 
000002D0                 FALSE     554mmm     IFNE DEBUG
000002D0                           555mmm     ENDC
000002D0                           556mmm 
000002D0                           557mmm     ENDM
000002D0  60E4                     558mm     BRA LOOP_15
000002D2                           559mm EXIT_15
000002D2                           560mm     ENDM
000002D2                           561m     ENDM
000002D2                           562  
000002D2  41FA 1336                563      LEA HELPPROMPT(PC),A0
000002D6                           564m     PRINT_STR A0,D3
000002D6                           565m LOOP_17
000002D6  0C10 0000                566m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002DA  6700 0016                567m     BEQ EXIT_17
000002DE                           568mm     PRINT_CHAR (A0)+,D3
000002DE                           569mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002DE                 TRUE      570mm     IFEQ DEBUG
000002DE  1639 00C00003            571mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000002E4  0803 0002                572mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000002E8  67F4                     573mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000002EA  13D8 00C00007            574mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002F0                           575mm     ENDC
000002F0                           576mm 
000002F0                 FALSE     577mm     IFNE DEBUG
000002F0                           578mm     ENDC
000002F0                           579mm 
000002F0                           580mm     ENDM
000002F0  60E4                     581m     BRA LOOP_17
000002F2                           582m EXIT_17
000002F2                           583m     ENDM
000002F2                           584  
000002F2                           585m     PRINT_CRLF D3,A0
000002F2  41FA 1502                586m     LEA CRLF(PC),A0
000002F6                           587mm     PRINT_STR A0,D3
000002F6                           588mm LOOP_20
000002F6  0C10 0000                589mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002FA  6700 0016                590mm     BEQ EXIT_20
000002FE                           591mmm     PRINT_CHAR (A0)+,D3
000002FE                           592mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002FE                 TRUE      593mmm     IFEQ DEBUG
000002FE  1639 00C00003            594mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000304  0803 0002                595mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000308  67F4                     596mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
0000030A  13D8 00C00007            597mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000310                           598mmm     ENDC
00000310                           599mmm 
00000310                 FALSE     600mmm     IFNE DEBUG
00000310                           601mmm     ENDC
00000310                           602mmm 
00000310                           603mmm     ENDM
00000310  60E4                     604mm     BRA LOOP_20
00000312                           605mm EXIT_20
00000312                           606mm     ENDM
00000312                           607m     ENDM
00000312                           608  
00000312  7E00                     609      MOVE.L #0,D7                                    ; address accumulator
00000314                           610  
00000314  13FC 0002 00E00001       611      MOVE.B #2,DISPLAY
0000031C                           612      
0000031C                           613  MAIN_LOOP
0000031C  41FA 14DB                614      LEA PROMPT(PC),A0
00000320                           615m     PRINT_STR A0,D3
00000320                           616m LOOP_22
00000320  0C10 0000                617m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000324  6700 0016                618m     BEQ EXIT_22
00000328                           619mm     PRINT_CHAR (A0)+,D3
00000328                           620mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000328                 TRUE      621mm     IFEQ DEBUG
00000328  1639 00C00003            622mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000032E  0803 0002                623mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000332  67F4                     624mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000334  13D8 00C00007            625mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000033A                           626mm     ENDC
0000033A                           627mm 
0000033A                 FALSE     628mm     IFNE DEBUG
0000033A                           629mm     ENDC
0000033A                           630mm 
0000033A                           631mm     ENDM
0000033A  60E4                     632m     BRA LOOP_22
0000033C                           633m EXIT_22
0000033C                           634m     ENDM
0000033C                           635  
0000033C                           636  GET_INPUT
0000033C                           637m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000033C                           638m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000033C                 TRUE      639m     IFEQ DEBUG
0000033C  1639 00C00003            640m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000342  0803 0000                641m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000346  67F4                     642m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000348                           643m     ENDC
00000348                           644m 
00000348                           645mm     READ_CHAR D2
00000348                 TRUE      646mm     IFEQ DEBUG
00000348  1439 00C00007            647mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000034E                           648mm     ENDC
0000034E                 FALSE     649mm     IFNE DEBUG
0000034E                           650mm     ENDC
0000034E                           651mm 
0000034E  B43C 001B                652mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000352  6700 FDB0                653mm     BEQ START
00000356                           654mm     ENDM
00000356                           655m 
00000356                 TRUE      656m     IFEQ DEBUG
00000356                           657mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000356                           658mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000356                 TRUE      659mm     IFEQ DEBUG
00000356  1639 00C00003            660mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000035C  0803 0002                661mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000360  67F4                     662mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000362  13C2 00C00007            663mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000368                           664mm     ENDC
00000368                           665mm 
00000368                 FALSE     666mm     IFNE DEBUG
00000368                           667mm     ENDC
00000368                           668mm 
00000368                           669mm     ENDM
00000368                           670m     ENDC
00000368                           671m     ENDM
00000368                           672  
00000368                           673      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000368  B43C 0030                674s     CMP.B   #'0',D2
0000036C  6D00 000E                675s     BLT _00000001
00000370  B43C 0039                676s     CMP.B   #'9',D2
00000374  6E00 0006                677s     BGT _00000001
00000378  6000 1080                678          BRA HEX_DIGIT
0000037C                           679      ENDI
0000037C                           680s _00000001
0000037C                           681      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000037C  B43C 0041                682s     CMP.B   #'A',D2
00000380  6D00 000E                683s     BLT _00000002
00000384  B43C 0046                684s     CMP.B   #'F',D2
00000388  6E00 0006                685s     BGT _00000002
0000038C  6000 106C                686          BRA HEX_DIGIT
00000390                           687      ENDI
00000390                           688s _00000002
00000390                           689  
00000390  B43C 0077                690      CMP.B #'w',D2
00000394  6700 01AA                691      BEQ W
00000398                           692  
00000398  B43C 006C                693      CMP.B #'l',D2
0000039C  6700 0A40                694      BEQ L 
000003A0                           695  
000003A0  B43C 0070                696      CMP.B #'p',D2
000003A4  6700 0D32                697      BEQ P
000003A8                           698  
000003A8                           699m     PRINT_CRLF D3,A0
000003A8  41FA 144C                700m     LEA CRLF(PC),A0
000003AC                           701mm     PRINT_STR A0,D3
000003AC                           702mm LOOP_28
000003AC  0C10 0000                703mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000003B0  6700 0016                704mm     BEQ EXIT_28
000003B4                           705mmm     PRINT_CHAR (A0)+,D3
000003B4                           706mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000003B4                 TRUE      707mmm     IFEQ DEBUG
000003B4  1639 00C00003            708mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000003BA  0803 0002                709mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000003BE  67F4                     710mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
000003C0  13D8 00C00007            711mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000003C6                           712mmm     ENDC
000003C6                           713mmm 
000003C6                 FALSE     714mmm     IFNE DEBUG
000003C6                           715mmm     ENDC
000003C6                           716mmm 
000003C6                           717mmm     ENDM
000003C6  60E4                     718mm     BRA LOOP_28
000003C8                           719mm EXIT_28
000003C8                           720mm     ENDM
000003C8                           721m     ENDM
000003C8                           722   
000003C8  B43C 003F                723      CMP.B #'?',D2
000003CC  6700 006E                724      BEQ H
000003D0                           725   
000003D0  B43C 0076                726      CMP.B #'v',D2
000003D4  6700 006E                727      BEQ V
000003D8                           728      
000003D8  B43C 0072                729      CMP.B #'r',D2
000003DC  6700 008A                730      BEQ R
000003E0                           731  
000003E0  B43C 0073                732      CMP.B #'s',D2
000003E4  6700 01D6                733      BEQ S
000003E8                           734  
000003E8  B43C 0067                735      CMP.B #'g',D2
000003EC  6700 08FA                736      BEQ G   
000003F0                           737  
000003F0  B43C 007A                738      CMP.B #'z',D2
000003F4  6700 08F8                739      BEQ Z   
000003F8                           740  
000003F8  B43C 0078                741      CMP.B #'x',D2
000003FC  6700 0EAA                742      BEQ X
00000400                           743  
00000400  B43C 0069                744      CMP.B #'i',D2
00000404  6700 0FBE                745      BEQ I
00000408                           746  
00000408  B43C 006F                747      CMP.B #'o',D2
0000040C  6700 0FC6                748      BEQ O
00000410                           749  
00000410  B43C 0023                750      CMP.B #'#',D2
00000414  6700 0FCE                751      BEQ HASH
00000418                           752  
00000418  41FA 133F                753      LEA HUH(PC),A0
0000041C                           754m     PRINT_STR A0,D3
0000041C                           755m LOOP_30
0000041C  0C10 0000                756m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000420  6700 0016                757m     BEQ EXIT_30
00000424                           758mm     PRINT_CHAR (A0)+,D3
00000424                           759mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000424                 TRUE      760mm     IFEQ DEBUG
00000424  1639 00C00003            761mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000042A  0803 0002                762mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000042E  67F4                     763mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
00000430  13D8 00C00007            764mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000436                           765mm     ENDC
00000436                           766mm 
00000436                 FALSE     767mm     IFNE DEBUG
00000436                           768mm     ENDC
00000436                           769mm 
00000436                           770mm     ENDM
00000436  60E4                     771m     BRA LOOP_30
00000438                           772m EXIT_30
00000438                           773m     ENDM
00000438                           774  
00000438  6000 FEE2                775      BRA MAIN_LOOP
0000043C                           776  
0000043C                           777  ; commands
0000043C                           778  H
0000043C  41FA 11DF                779      LEA HELP(PC),A0
00000440  6000 0006                780      BRA PRINTSTR
00000444                           781  
00000444                           782  V
00000444  41FA 144E                783      LEA VERSION(PC),A0
00000448                           784  PRINTSTR
00000448                           785m     PRINT_STR A0,D3    
00000448                           786m LOOP_32
00000448  0C10 0000                787m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000044C  6700 0016                788m     BEQ EXIT_32
00000450                           789mm     PRINT_CHAR (A0)+,D3
00000450                           790mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000450                 TRUE      791mm     IFEQ DEBUG
00000450  1639 00C00003            792mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000456  0803 0002                793mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000045A  67F4                     794mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000045C  13D8 00C00007            795mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000462                           796mm     ENDC
00000462                           797mm 
00000462                 FALSE     798mm     IFNE DEBUG
00000462                           799mm     ENDC
00000462                           800mm 
00000462                           801mm     ENDM
00000462  60E4                     802m     BRA LOOP_32
00000464                           803m EXIT_32
00000464                           804m     ENDM
00000464  6000 FEB6                805      BRA MAIN_LOOP
00000468                           806  
00000468                           807  R
00000468  2047                     808      MOVE.L D7,A0                                    ; address accumulator -> address register
0000046A  7E00                     809      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000046C  2410                     810      MOVE.L (A0),D2                                  ; read the memory and print it
0000046E                           811m     PRINT_REG D2,D3,D4,D5,A0
0000046E  41FA 138C                812m     LEA OX(PC),A0
00000472                           813mm     PRINT_STR A0,D3
00000472                           814mm LOOP_35
00000472  0C10 0000                815mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000476  6700 0016                816mm     BEQ EXIT_35
0000047A                           817mmm     PRINT_CHAR (A0)+,D3
0000047A                           818mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000047A                 TRUE      819mmm     IFEQ DEBUG
0000047A  1639 00C00003            820mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000480  0803 0002                821mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000484  67F4                     822mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
00000486  13D8 00C00007            823mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000048C                           824mmm     ENDC
0000048C                           825mmm 
0000048C                 FALSE     826mmm     IFNE DEBUG
0000048C                           827mmm     ENDC
0000048C                           828mmm 
0000048C                           829mmm     ENDM
0000048C  60E4                     830mm     BRA LOOP_35
0000048E                           831mm EXIT_35
0000048E                           832mm     ENDM
0000048E  7A07                     833m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000490                           834m LOOP_34
00000490                           835mm     BIN2HEX D2,D4,A0
00000490  41FA 1329                836mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000494  E99A                     837mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000496  1802                     838mm     MOVE.B D2,D4
00000498  0284 0000000F            839mm     ANDI.L #$F,D4
0000049E  1830 4000                840mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000004A2                           841mm     ENDM
000004A2                           842mm     PRINT_CHAR D4,D3
000004A2                           843mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004A2                 TRUE      844mm     IFEQ DEBUG
000004A2  1639 00C00003            845mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004A8  0803 0002                846mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004AC  67F4                     847mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
000004AE  13C4 00C00007            848mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004B4                           849mm     ENDC
000004B4                           850mm 
000004B4                 FALSE     851mm     IFNE DEBUG
000004B4                           852mm     ENDC
000004B4                           853mm 
000004B4                           854mm     ENDM
000004B4  57CD FFDA                855m     DBEQ D5,LOOP_34
000004B8                           856m     ENDM
000004B8                           857      
000004B8                           858m     PRINT_CHAR #32,D3
000004B8                           859m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004B8                 TRUE      860m     IFEQ DEBUG
000004B8  1639 00C00003            861m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004BE  0803 0002                862m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004C2  67F4                     863m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
000004C4  13FC 0020 00C00007       864m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
000004CC                           865m     ENDC
000004CC                           866m 
000004CC                 FALSE     867m     IFNE DEBUG
000004CC                           868m     ENDC
000004CC                           869m 
000004CC                           870m     ENDM
000004CC                           871  
000004CC  E19A                     872      ROL.L #8,D2
000004CE                           873m     PRINT_CHAR D2,D3
000004CE                           874m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004CE                 TRUE      875m     IFEQ DEBUG
000004CE  1639 00C00003            876m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004D4  0803 0002                877m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004D8  67F4                     878m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
000004DA  13C2 00C00007            879m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E0                           880m     ENDC
000004E0                           881m 
000004E0                 FALSE     882m     IFNE DEBUG
000004E0                           883m     ENDC
000004E0                           884m 
000004E0                           885m     ENDM
000004E0  E19A                     886      ROL.L #8,D2
000004E2                           887m     PRINT_CHAR D2,D3
000004E2                           888m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004E2                 TRUE      889m     IFEQ DEBUG
000004E2  1639 00C00003            890m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004E8  0803 0002                891m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000004EC  67F4                     892m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000004EE  13C2 00C00007            893m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004F4                           894m     ENDC
000004F4                           895m 
000004F4                 FALSE     896m     IFNE DEBUG
000004F4                           897m     ENDC
000004F4                           898m 
000004F4                           899m     ENDM
000004F4  E19A                     900      ROL.L #8,D2
000004F6                           901m     PRINT_CHAR D2,D3
000004F6                           902m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004F6                 TRUE      903m     IFEQ DEBUG
000004F6  1639 00C00003            904m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000004FC  0803 0002                905m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000500  67F4                     906m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
00000502  13C2 00C00007            907m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000508                           908m     ENDC
00000508                           909m 
00000508                 FALSE     910m     IFNE DEBUG
00000508                           911m     ENDC
00000508                           912m 
00000508                           913m     ENDM
00000508  E19A                     914      ROL.L #8,D2
0000050A                           915m     PRINT_CHAR D2,D3
0000050A                           916m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000050A                 TRUE      917m     IFEQ DEBUG
0000050A  1639 00C00003            918m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000510  0803 0002                919m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000514  67F4                     920m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
00000516  13C2 00C00007            921m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000051C                           922m     ENDC
0000051C                           923m 
0000051C                 FALSE     924m     IFNE DEBUG
0000051C                           925m     ENDC
0000051C                           926m 
0000051C                           927m     ENDM
0000051C                           928  
0000051C                           929m     PRINT_CRLF D3,A0
0000051C  41FA 12D8                930m     LEA CRLF(PC),A0
00000520                           931mm     PRINT_STR A0,D3
00000520                           932mm LOOP_45
00000520  0C10 0000                933mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000524  6700 0016                934mm     BEQ EXIT_45
00000528                           935mmm     PRINT_CHAR (A0)+,D3
00000528                           936mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000528                 TRUE      937mmm     IFEQ DEBUG
00000528  1639 00C00003            938mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000052E  0803 0002                939mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000532  67F4                     940mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
00000534  13D8 00C00007            941mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000053A                           942mmm     ENDC
0000053A                           943mmm 
0000053A                 FALSE     944mmm     IFNE DEBUG
0000053A                           945mmm     ENDC
0000053A                           946mmm 
0000053A                           947mmm     ENDM
0000053A  60E4                     948mm     BRA LOOP_45
0000053C                           949mm EXIT_45
0000053C                           950mm     ENDM
0000053C                           951m     ENDM
0000053C                           952      
0000053C  6000 FDDE                953      BRA MAIN_LOOP
00000540                           954  
00000540                           955  W
00000540                           956      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
00000540  3C3C 0000                957s     MOVE.W  #0,D6
00000544  6000 0046                958s     BRA _20000005
00000548                           959s _20000004
00000548  E98D                     960          LSL.L #4,D5                                     ; make what we have so far more significant
0000054A                           961m         WAIT_CHAR D2,D3                                 ; next character -> D2
0000054A                           962m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000054A                 TRUE      963m     IFEQ DEBUG
0000054A  1639 00C00003            964m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000550  0803 0000                965m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000554  67F4                     966m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000556                           967m     ENDC
00000556                           968m 
00000556                           969mm     READ_CHAR D2
00000556                 TRUE      970mm     IFEQ DEBUG
00000556  1439 00C00007            971mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000055C                           972mm     ENDC
0000055C                 FALSE     973mm     IFNE DEBUG
0000055C                           974mm     ENDC
0000055C                           975mm 
0000055C  B43C 001B                976mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000560  6700 FBA2                977mm     BEQ START
00000564                           978mm     ENDM
00000564                           979m 
00000564                 TRUE      980m     IFEQ DEBUG
00000564                           981mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000564                           982mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000564                 TRUE      983mm     IFEQ DEBUG
00000564  1639 00C00003            984mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000056A  0803 0002                985mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000056E  67F4                     986mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
00000570  13C2 00C00007            987mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000576                           988mm     ENDC
00000576                           989mm 
00000576                 FALSE     990mm     IFNE DEBUG
00000576                           991mm     ENDC
00000576                           992mm 
00000576                           993mm     ENDM
00000576                           994m     ENDC
00000576                           995m     ENDM
00000576                           996m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000576  41FA 1253                997m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000057A  0402 0030                998m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000057E  C4BC 000000FF            999m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000584  1430 2000               1000m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000588                          1001m     ENDM
00000588  8A02                    1002          OR.B D2,D5
0000058A                          1003      ENDF
0000058A  5246                    1004s     ADD.W   #1,D6
0000058C                          1005s _20000005
0000058C  BC7C 0007               1006s     CMP.W   #7,D6
00000590  6FB6                    1007s     BLE _20000004
00000592                          1008  
00000592                          1009m     PRINT_CRLF D3,A0
00000592  41FA 1262               1010m     LEA CRLF(PC),A0
00000596                          1011mm     PRINT_STR A0,D3
00000596                          1012mm LOOP_52
00000596  0C10 0000               1013mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000059A  6700 0016               1014mm     BEQ EXIT_52
0000059E                          1015mmm     PRINT_CHAR (A0)+,D3
0000059E                          1016mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000059E                 TRUE     1017mmm     IFEQ DEBUG
0000059E  1639 00C00003           1018mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005A4  0803 0002               1019mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005A8  67F4                    1020mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
000005AA  13D8 00C00007           1021mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005B0                          1022mmm     ENDC
000005B0                          1023mmm 
000005B0                 FALSE    1024mmm     IFNE DEBUG
000005B0                          1025mmm     ENDC
000005B0                          1026mmm 
000005B0                          1027mmm     ENDM
000005B0  60E4                    1028mm     BRA LOOP_52
000005B2                          1029mm EXIT_52
000005B2                          1030mm     ENDM
000005B2                          1031m     ENDM
000005B2                          1032  
000005B2  2047                    1033      MOVE.L D7,A0                                    ; address accumulator -> address register
000005B4  7E00                    1034      MOVE.L #0,D7                                    ; clear the now used address accumulator
000005B6                          1035  
000005B6  2085                    1036      MOVE.L D5,(A0)                                  ; write the data
000005B8                          1037  
000005B8  6000 FD62               1038      BRA MAIN_LOOP
000005BC                          1039  
000005BC                          1040  ; register map for S
000005BC                          1041  ; A0 - start address
000005BC                          1042  ; A1 - offset
000005BC                          1043  ; A2 - next address to write
000005BC                          1044  ; A3 - next location (jmp)
000005BC                          1045  ; A4 - Working Address Register
000005BC                          1046  ; D0 - record count
000005BC                          1047  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
000005BC                          1048  ; D2 - checksum
000005BC                          1049  ; D3 - data byte count
000005BC                          1050  ; D4 - read address, moved into A2
000005BC                          1051  ; D5 - temp
000005BC                          1052  ; D6 - temp
000005BC                          1053  ; D7 - temp
000005BC                          1054  S
000005BC  2078 0000               1055      MOVE.L 0,A0                                     ; start address -> A0
000005C0  2247                    1056      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
000005C2                          1057      
000005C2  7000                    1058      MOVE.L #0,D0                                    ; count of records read -> D0
000005C4                          1059          
000005C4                          1060  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
000005C4                          1061m     DOWNLOAD D1
000005C4                          1062m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005C4                          1063m 
000005C4  1239 00C00003           1064m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000005CA  0801 0000               1065m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005CE  6700 0010               1066m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
000005D2                          1067m 
000005D2                          1068mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000005D2                 TRUE     1069mm     IFEQ DEBUG
000005D2  1239 00C00007           1070mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000005D8                          1071mm     ENDC
000005D8                 FALSE    1072mm     IFNE DEBUG
000005D8                          1073mm     ENDC
000005D8                          1074mm 
000005D8  B23C 001B               1075mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000005DC  6700 FB26               1076mm     BEQ START
000005E0                          1077mm     ENDM
000005E0                          1078m CONTINUE_54
000005E0  1239 00C00013           1079m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000005E6  0801 0000               1080m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000005EA  67D8                    1081m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000005EC                          1082m     
000005EC  1239 00C00017           1083m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000005F2  13C1 00E00001           1084m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000005F8                          1085m 
000005F8                          1086m     ENDM
000005F8  B23C 0053               1087      CMP.B #'S',D1                                   ; found S?
000005FC  66C6                    1088      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000005FE                          1089      
000005FE                          1090m     PRINT_CHAR #'S',D5                              ; print the S
000005FE                          1091m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005FE                 TRUE     1092m     IFEQ DEBUG
000005FE  1A39 00C00003           1093m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000604  0805 0002               1094m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000608  67F4                    1095m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
0000060A  13FC 0053 00C00007      1096m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
00000612                          1097m     ENDC
00000612                          1098m 
00000612                 FALSE    1099m     IFNE DEBUG
00000612                          1100m     ENDC
00000612                          1101m 
00000612                          1102m     ENDM
00000612  5280                    1103      ADD.L #1,D0                                     ; read another S record, increment count
00000614                          1104      
00000614                          1105m     DOWNLOAD D1                                     ; read the record identifier and echo it back
00000614                          1106m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000614                          1107m 
00000614  1239 00C00003           1108m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
0000061A  0801 0000               1109m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000061E  6700 0010               1110m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
00000622                          1111m 
00000622                          1112mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000622                 TRUE     1113mm     IFEQ DEBUG
00000622  1239 00C00007           1114mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000628                          1115mm     ENDC
00000628                 FALSE    1116mm     IFNE DEBUG
00000628                          1117mm     ENDC
00000628                          1118mm 
00000628  B23C 001B               1119mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000062C  6700 FAD6               1120mm     BEQ START
00000630                          1121mm     ENDM
00000630                          1122m CONTINUE_57
00000630  1239 00C00013           1123m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
00000636  0801 0000               1124m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000063A  67D8                    1125m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
0000063C                          1126m     
0000063C  1239 00C00017           1127m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000642  13C1 00E00001           1128m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000648                          1129m 
00000648                          1130m     ENDM
00000648                          1131m     PRINT_CHAR D1,D5
00000648                          1132m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000648                 TRUE     1133m     IFEQ DEBUG
00000648  1A39 00C00003           1134m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000064E  0805 0002               1135m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000652  67F4                    1136m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000654  13C1 00C00007           1137m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000065A                          1138m     ENDC
0000065A                          1139m 
0000065A                 FALSE    1140m     IFNE DEBUG
0000065A                          1141m     ENDC
0000065A                          1142m 
0000065A                          1143m     ENDM
0000065A                          1144  
0000065A  7400                    1145      MOVE.L #0,D2                                    ; clear the checksum
0000065C                          1146  
0000065C                          1147m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000065C  1E3C 0002               1148m     MOVE.B #2,D7
00000660                          1149m     WHILE.B D7 <GT> 0 DO
00000660                          1150ms _10000000
00000660  BE38 0000               1151ms     CMP.B   0,D7
00000664  6F00 0062               1152ms     BLE _10000001
00000668  E98B                    1153m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
0000066A                          1154mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000066A                          1155mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000066A                          1156mm 
0000066A  1A39 00C00003           1157mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000670  0805 0000               1158mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000674  6700 0010               1159mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000678                          1160mm 
00000678                          1161mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000678                 TRUE     1162mmm     IFEQ DEBUG
00000678  1A39 00C00007           1163mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000067E                          1164mmm     ENDC
0000067E                 FALSE    1165mmm     IFNE DEBUG
0000067E                          1166mmm     ENDC
0000067E                          1167mmm 
0000067E  BA3C 001B               1168mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000682  6700 FA80               1169mmm     BEQ START
00000686                          1170mmm     ENDM
00000686                          1171mm CONTINUE_61
00000686  1A39 00C00013           1172mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000068C  0805 0000               1173mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000690  67D8                    1174mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000692                          1175mm     
00000692  1A39 00C00017           1176mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000698  13C5 00E00001           1177mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000069E                          1178mm 
0000069E                          1179mm     ENDM
0000069E                          1180mm         PRINT_CHAR D5,D6
0000069E                          1181mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000069E                 TRUE     1182mm     IFEQ DEBUG
0000069E  1C39 00C00003           1183mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000006A4  0806 0002               1184mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000006A8  67F4                    1185mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
000006AA  13C5 00C00007           1186mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000006B0                          1187mm     ENDC
000006B0                          1188mm 
000006B0                 FALSE    1189mm     IFNE DEBUG
000006B0                          1190mm     ENDC
000006B0                          1191mm 
000006B0                          1192mm     ENDM
000006B0                          1193mm         HEX2BIN D5,D5,A4
000006B0  49FA 1119               1194mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000006B4  0405 0030               1195mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000006B8  CABC 000000FF           1196mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000006BE  1A34 5000               1197mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000006C2                          1198mm     ENDM
000006C2  8605                    1199m         OR.B D5,D3
000006C4  5307                    1200m         SUB.B #1,D7
000006C6                          1201m     ENDW
000006C6  6098                    1202ms     BRA _10000000
000006C8                          1203ms _10000001
000006C8                          1204m 
000006C8  7A00                    1205m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000006CA  1A03                    1206m     MOVE.B D3,D5
000006CC  D483                    1207m     ADD.L D3,D2
000006CE                          1208m 
000006CE                          1209m     ENDM
000006CE                          1210  
000006CE                          1211      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
000006CE  B23C 0030               1212s     CMP.B   #'0',D1
000006D2  6600 002A               1213s     BNE.L   _00000003
000006D6                          1214m         PRINT_CRLF D5,A4
000006D6  49FA 111E               1215m     LEA CRLF(PC),A4
000006DA                          1216mm     PRINT_STR A4,D5
000006DA                          1217mm LOOP_66
000006DA  0C14 0000               1218mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
000006DE  6700 0016               1219mm     BEQ EXIT_66
000006E2                          1220mmm     PRINT_CHAR (A4)+,D5
000006E2                          1221mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E2                 TRUE     1222mmm     IFEQ DEBUG
000006E2  1A39 00C00003           1223mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000006E8  0805 0002               1224mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000006EC  67F4                    1225mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000006EE  13DC 00C00007           1226mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000006F4                          1227mmm     ENDC
000006F4                          1228mmm 
000006F4                 FALSE    1229mmm     IFNE DEBUG
000006F4                          1230mmm     ENDC
000006F4                          1231mmm 
000006F4                          1232mmm     ENDM
000006F4  60E4                    1233mm     BRA LOOP_66
000006F6                          1234mm EXIT_66
000006F6                          1235mm     ENDM
000006F6                          1236m     ENDM
000006F6  6000 FECC               1237          BRA WAIT_FOR_SRECORD
000006FA                          1238      ELSE
000006FA  6000 03DE               1239s     BRA _00000004
000006FE                          1240s _00000003
000006FE                          1241          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000006FE  B23C 0031               1242s     CMP.B   #'1',D1
00000702  6708                    1243s     BEQ.S   _00000005
00000704  B23C 0032               1244s     CMP.B   #'2',D1
00000708  6600 01F0               1245s     BNE.L   _00000006
0000070C                          1246s _00000005
0000070C  5783                    1247              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
0000070E                          1248  
0000070E  7800                    1249              MOVE.L #0,D4                            ; read two bytes of address
00000710                          1250m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
00000710  1E3C 0002               1251m     MOVE.B #2,D7
00000714                          1252m     WHILE.B D7 <GT> 0 DO
00000714                          1253ms _10000002
00000714  BE38 0000               1254ms     CMP.B   0,D7
00000718  6F00 0062               1255ms     BLE _10000003
0000071C  E98C                    1256m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000071E                          1257mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000071E                          1258mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000071E                          1259mm 
0000071E  1A39 00C00003           1260mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000724  0805 0000               1261mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000728  6700 0010               1262mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
0000072C                          1263mm 
0000072C                          1264mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000072C                 TRUE     1265mmm     IFEQ DEBUG
0000072C  1A39 00C00007           1266mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000732                          1267mmm     ENDC
00000732                 FALSE    1268mmm     IFNE DEBUG
00000732                          1269mmm     ENDC
00000732                          1270mmm 
00000732  BA3C 001B               1271mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000736  6700 F9CC               1272mmm     BEQ START
0000073A                          1273mmm     ENDM
0000073A                          1274mm CONTINUE_69
0000073A  1A39 00C00013           1275mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000740  0805 0000               1276mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000744  67D8                    1277mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000746                          1278mm     
00000746  1A39 00C00017           1279mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000074C  13C5 00E00001           1280mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000752                          1281mm 
00000752                          1282mm     ENDM
00000752                          1283mm         PRINT_CHAR D5,D6
00000752                          1284mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000752                 TRUE     1285mm     IFEQ DEBUG
00000752  1C39 00C00003           1286mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000758  0806 0002               1287mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000075C  67F4                    1288mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
0000075E  13C5 00C00007           1289mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000764                          1290mm     ENDC
00000764                          1291mm 
00000764                 FALSE    1292mm     IFNE DEBUG
00000764                          1293mm     ENDC
00000764                          1294mm 
00000764                          1295mm     ENDM
00000764                          1296mm         HEX2BIN D5,D5,A4
00000764  49FA 1065               1297mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000768  0405 0030               1298mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000076C  CABC 000000FF           1299mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000772  1A34 5000               1300mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000776                          1301mm     ENDM
00000776  8805                    1302m         OR.B D5,D4
00000778  5307                    1303m         SUB.B #1,D7
0000077A                          1304m     ENDW
0000077A  6098                    1305ms     BRA _10000002
0000077C                          1306ms _10000003
0000077C                          1307m 
0000077C  7A00                    1308m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000077E  1A04                    1309m     MOVE.B D4,D5
00000780  D484                    1310m     ADD.L D4,D2
00000782                          1311m 
00000782                          1312m     ENDM
00000782                          1313m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000782  1E3C 0002               1314m     MOVE.B #2,D7
00000786                          1315m     WHILE.B D7 <GT> 0 DO
00000786                          1316ms _10000004
00000786  BE38 0000               1317ms     CMP.B   0,D7
0000078A  6F00 0062               1318ms     BLE _10000005
0000078E  E98C                    1319m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000790                          1320mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000790                          1321mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000790                          1322mm 
00000790  1A39 00C00003           1323mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000796  0805 0000               1324mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000079A  6700 0010               1325mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
0000079E                          1326mm 
0000079E                          1327mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000079E                 TRUE     1328mmm     IFEQ DEBUG
0000079E  1A39 00C00007           1329mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000007A4                          1330mmm     ENDC
000007A4                 FALSE    1331mmm     IFNE DEBUG
000007A4                          1332mmm     ENDC
000007A4                          1333mmm 
000007A4  BA3C 001B               1334mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000007A8  6700 F95A               1335mmm     BEQ START
000007AC                          1336mmm     ENDM
000007AC                          1337mm CONTINUE_74
000007AC  1A39 00C00013           1338mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000007B2  0805 0000               1339mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000007B6  67D8                    1340mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
000007B8                          1341mm     
000007B8  1A39 00C00017           1342mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000007BE  13C5 00E00001           1343mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000007C4                          1344mm 
000007C4                          1345mm     ENDM
000007C4                          1346mm         PRINT_CHAR D5,D6
000007C4                          1347mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C4                 TRUE     1348mm     IFEQ DEBUG
000007C4  1C39 00C00003           1349mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000007CA  0806 0002               1350mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000007CE  67F4                    1351mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
000007D0  13C5 00C00007           1352mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007D6                          1353mm     ENDC
000007D6                          1354mm 
000007D6                 FALSE    1355mm     IFNE DEBUG
000007D6                          1356mm     ENDC
000007D6                          1357mm 
000007D6                          1358mm     ENDM
000007D6                          1359mm         HEX2BIN D5,D5,A4
000007D6  49FA 0FF3               1360mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000007DA  0405 0030               1361mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000007DE  CABC 000000FF           1362mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000007E4  1A34 5000               1363mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000007E8                          1364mm     ENDM
000007E8  8805                    1365m         OR.B D5,D4
000007EA  5307                    1366m         SUB.B #1,D7
000007EC                          1367m     ENDW
000007EC  6098                    1368ms     BRA _10000004
000007EE                          1369ms _10000005
000007EE                          1370m 
000007EE  7A00                    1371m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000007F0  1A04                    1372m     MOVE.B D4,D5
000007F2  D484                    1373m     ADD.L D4,D2
000007F4                          1374m 
000007F4                          1375m     ENDM
000007F4                          1376  
000007F4                          1377              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
000007F4  B23C 0032               1378s     CMP.B   #'2',D1
000007F8  6600 0076               1379s     BNE.L   _00000007
000007FC  5383                    1380                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
000007FE                          1381m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
000007FE  1E3C 0002               1382m     MOVE.B #2,D7
00000802                          1383m     WHILE.B D7 <GT> 0 DO
00000802                          1384ms _10000006
00000802  BE38 0000               1385ms     CMP.B   0,D7
00000806  6F00 0062               1386ms     BLE _10000007
0000080A  E98C                    1387m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
0000080C                          1388mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000080C                          1389mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000080C                          1390mm 
0000080C  1A39 00C00003           1391mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000812  0805 0000               1392mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000816  6700 0010               1393mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
0000081A                          1394mm 
0000081A                          1395mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
0000081A                 TRUE     1396mmm     IFEQ DEBUG
0000081A  1A39 00C00007           1397mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000820                          1398mmm     ENDC
00000820                 FALSE    1399mmm     IFNE DEBUG
00000820                          1400mmm     ENDC
00000820                          1401mmm 
00000820  BA3C 001B               1402mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000824  6700 F8DE               1403mmm     BEQ START
00000828                          1404mmm     ENDM
00000828                          1405mm CONTINUE_79
00000828  1A39 00C00013           1406mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000082E  0805 0000               1407mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000832  67D8                    1408mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000834                          1409mm     
00000834  1A39 00C00017           1410mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
0000083A  13C5 00E00001           1411mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000840                          1412mm 
00000840                          1413mm     ENDM
00000840                          1414mm         PRINT_CHAR D5,D6
00000840                          1415mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000840                 TRUE     1416mm     IFEQ DEBUG
00000840  1C39 00C00003           1417mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000846  0806 0002               1418mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
0000084A  67F4                    1419mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
0000084C  13C5 00C00007           1420mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000852                          1421mm     ENDC
00000852                          1422mm 
00000852                 FALSE    1423mm     IFNE DEBUG
00000852                          1424mm     ENDC
00000852                          1425mm 
00000852                          1426mm     ENDM
00000852                          1427mm         HEX2BIN D5,D5,A4
00000852  49FA 0F77               1428mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000856  0405 0030               1429mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000085A  CABC 000000FF           1430mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000860  1A34 5000               1431mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000864                          1432mm     ENDM
00000864  8805                    1433m         OR.B D5,D4
00000866  5307                    1434m         SUB.B #1,D7
00000868                          1435m     ENDW
00000868  6098                    1436ms     BRA _10000006
0000086A                          1437ms _10000007
0000086A                          1438m 
0000086A  7A00                    1439m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
0000086C  1A04                    1440m     MOVE.B D4,D5
0000086E  D484                    1441m     ADD.L D4,D2
00000870                          1442m 
00000870                          1443m     ENDM
00000870                          1444              ENDI
00000870                          1445s _00000007
00000870                          1446  
00000870  2444                    1447              MOVE.L D4,A2                            ; put the address in an address register
00000872  D5C9                    1448              ADD.L A1,A2                             ; add in the offset
00000874                          1449  
00000874                          1450              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000874                          1451s _10000008
00000874  B63C 0000               1452s     CMP.B   #0,D3
00000878  6F00 007A               1453s     BLE _10000009
0000087C                          1454m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
0000087C  1E3C 0002               1455m     MOVE.B #2,D7
00000880                          1456m     WHILE.B D7 <GT> 0 DO
00000880                          1457ms _1000000A
00000880  BE38 0000               1458ms     CMP.B   0,D7
00000884  6F00 0062               1459ms     BLE _1000000B
00000888  E989                    1460m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
0000088A                          1461mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
0000088A                          1462mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000088A                          1463mm 
0000088A  1A39 00C00003           1464mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000890  0805 0000               1465mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000894  6700 0010               1466mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000898                          1467mm 
00000898                          1468mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000898                 TRUE     1469mmm     IFEQ DEBUG
00000898  1A39 00C00007           1470mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000089E                          1471mmm     ENDC
0000089E                 FALSE    1472mmm     IFNE DEBUG
0000089E                          1473mmm     ENDC
0000089E                          1474mmm 
0000089E  BA3C 001B               1475mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000008A2  6700 F860               1476mmm     BEQ START
000008A6                          1477mmm     ENDM
000008A6                          1478mm CONTINUE_84
000008A6  1A39 00C00013           1479mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000008AC  0805 0000               1480mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000008B0  67D8                    1481mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
000008B2                          1482mm     
000008B2  1A39 00C00017           1483mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000008B8  13C5 00E00001           1484mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000008BE                          1485mm 
000008BE                          1486mm     ENDM
000008BE                          1487mm         PRINT_CHAR D5,D6
000008BE                          1488mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BE                 TRUE     1489mm     IFEQ DEBUG
000008BE  1C39 00C00003           1490mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000008C4  0806 0002               1491mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000008C8  67F4                    1492mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
000008CA  13C5 00C00007           1493mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000008D0                          1494mm     ENDC
000008D0                          1495mm 
000008D0                 FALSE    1496mm     IFNE DEBUG
000008D0                          1497mm     ENDC
000008D0                          1498mm 
000008D0                          1499mm     ENDM
000008D0                          1500mm         HEX2BIN D5,D5,A4
000008D0  49FA 0EF9               1501mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000008D4  0405 0030               1502mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000008D8  CABC 000000FF           1503mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000008DE  1A34 5000               1504mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000008E2                          1505mm     ENDM
000008E2  8205                    1506m         OR.B D5,D1
000008E4  5307                    1507m         SUB.B #1,D7
000008E6                          1508m     ENDW
000008E6  6098                    1509ms     BRA _1000000A
000008E8                          1510ms _1000000B
000008E8                          1511m 
000008E8  7A00                    1512m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000008EA  1A01                    1513m     MOVE.B D1,D5
000008EC  D481                    1514m     ADD.L D1,D2
000008EE                          1515m 
000008EE                          1516m     ENDM
000008EE                          1517   
000008EE  14C1                    1518                  MOVE.B D1,(A2)+                     ; store it!
000008F0                          1519  
000008F0  5303                    1520                  SUB.B #1,D3                         ; 1 less byte to go
000008F2                          1521              ENDW
000008F2  6080                    1522s     BRA _10000008
000008F4                          1523s _10000009
000008F4                          1524  
000008F4  7200                    1525              MOVE.L #0,D1                            ; not done yet
000008F6                          1526          ELSE
000008F6  6000 01E2               1527s     BRA _00000008
000008FA                          1528s _00000006
000008FA                          1529              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
000008FA  B23C 0038               1530s     CMP.B   #'8',D1
000008FE  6600 0164               1531s     BNE.L   _00000009
00000902  7800                    1532                  MOVE.L #0,D4                        ; read the 24 bit start address
00000904                          1533m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000904  1E3C 0002               1534m     MOVE.B #2,D7
00000908                          1535m     WHILE.B D7 <GT> 0 DO
00000908                          1536ms _1000000C
00000908  BE38 0000               1537ms     CMP.B   0,D7
0000090C  6F00 0062               1538ms     BLE _1000000D
00000910  E98C                    1539m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000912                          1540mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000912                          1541mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000912                          1542mm 
00000912  1A39 00C00003           1543mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000918  0805 0000               1544mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000091C  6700 0010               1545mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000920                          1546mm 
00000920                          1547mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000920                 TRUE     1548mmm     IFEQ DEBUG
00000920  1A39 00C00007           1549mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000926                          1550mmm     ENDC
00000926                 FALSE    1551mmm     IFNE DEBUG
00000926                          1552mmm     ENDC
00000926                          1553mmm 
00000926  BA3C 001B               1554mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000092A  6700 F7D8               1555mmm     BEQ START
0000092E                          1556mmm     ENDM
0000092E                          1557mm CONTINUE_89
0000092E  1A39 00C00013           1558mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000934  0805 0000               1559mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000938  67D8                    1560mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
0000093A                          1561mm     
0000093A  1A39 00C00017           1562mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000940  13C5 00E00001           1563mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000946                          1564mm 
00000946                          1565mm     ENDM
00000946                          1566mm         PRINT_CHAR D5,D6
00000946                          1567mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000946                 TRUE     1568mm     IFEQ DEBUG
00000946  1C39 00C00003           1569mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
0000094C  0806 0002               1570mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000950  67F4                    1571mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000952  13C5 00C00007           1572mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000958                          1573mm     ENDC
00000958                          1574mm 
00000958                 FALSE    1575mm     IFNE DEBUG
00000958                          1576mm     ENDC
00000958                          1577mm 
00000958                          1578mm     ENDM
00000958                          1579mm         HEX2BIN D5,D5,A4
00000958  49FA 0E71               1580mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
0000095C  0405 0030               1581mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000960  CABC 000000FF           1582mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000966  1A34 5000               1583mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
0000096A                          1584mm     ENDM
0000096A  8805                    1585m         OR.B D5,D4
0000096C  5307                    1586m         SUB.B #1,D7
0000096E                          1587m     ENDW
0000096E  6098                    1588ms     BRA _1000000C
00000970                          1589ms _1000000D
00000970                          1590m 
00000970  7A00                    1591m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000972  1A04                    1592m     MOVE.B D4,D5
00000974  D484                    1593m     ADD.L D4,D2
00000976                          1594m 
00000976                          1595m     ENDM
00000976                          1596m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000976  1E3C 0002               1597m     MOVE.B #2,D7
0000097A                          1598m     WHILE.B D7 <GT> 0 DO
0000097A                          1599ms _1000000E
0000097A  BE38 0000               1600ms     CMP.B   0,D7
0000097E  6F00 0062               1601ms     BLE _1000000F
00000982  E98C                    1602m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000984                          1603mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000984                          1604mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000984                          1605mm 
00000984  1A39 00C00003           1606mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000098A  0805 0000               1607mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000098E  6700 0010               1608mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
00000992                          1609mm 
00000992                          1610mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000992                 TRUE     1611mmm     IFEQ DEBUG
00000992  1A39 00C00007           1612mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000998                          1613mmm     ENDC
00000998                 FALSE    1614mmm     IFNE DEBUG
00000998                          1615mmm     ENDC
00000998                          1616mmm 
00000998  BA3C 001B               1617mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
0000099C  6700 F766               1618mmm     BEQ START
000009A0                          1619mmm     ENDM
000009A0                          1620mm CONTINUE_94
000009A0  1A39 00C00013           1621mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009A6  0805 0000               1622mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009AA  67D8                    1623mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
000009AC                          1624mm     
000009AC  1A39 00C00017           1625mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
000009B2  13C5 00E00001           1626mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
000009B8                          1627mm 
000009B8                          1628mm     ENDM
000009B8                          1629mm         PRINT_CHAR D5,D6
000009B8                          1630mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009B8                 TRUE     1631mm     IFEQ DEBUG
000009B8  1C39 00C00003           1632mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
000009BE  0806 0002               1633mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
000009C2  67F4                    1634mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
000009C4  13C5 00C00007           1635mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
000009CA                          1636mm     ENDC
000009CA                          1637mm 
000009CA                 FALSE    1638mm     IFNE DEBUG
000009CA                          1639mm     ENDC
000009CA                          1640mm 
000009CA                          1641mm     ENDM
000009CA                          1642mm         HEX2BIN D5,D5,A4
000009CA  49FA 0DFF               1643mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
000009CE  0405 0030               1644mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000009D2  CABC 000000FF           1645mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
000009D8  1A34 5000               1646mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
000009DC                          1647mm     ENDM
000009DC  8805                    1648m         OR.B D5,D4
000009DE  5307                    1649m         SUB.B #1,D7
000009E0                          1650m     ENDW
000009E0  6098                    1651ms     BRA _1000000E
000009E2                          1652ms _1000000F
000009E2                          1653m 
000009E2  7A00                    1654m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
000009E4  1A04                    1655m     MOVE.B D4,D5
000009E6  D484                    1656m     ADD.L D4,D2
000009E8                          1657m 
000009E8                          1658m     ENDM
000009E8                          1659m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
000009E8  1E3C 0002               1660m     MOVE.B #2,D7
000009EC                          1661m     WHILE.B D7 <GT> 0 DO
000009EC                          1662ms _10000010
000009EC  BE38 0000               1663ms     CMP.B   0,D7
000009F0  6F00 0062               1664ms     BLE _10000011
000009F4  E98C                    1665m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009F6                          1666mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009F6                          1667mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009F6                          1668mm 
000009F6  1A39 00C00003           1669mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009FC  0805 0000               1670mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A00  6700 0010               1671mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000A04                          1672mm 
00000A04                          1673mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A04                 TRUE     1674mmm     IFEQ DEBUG
00000A04  1A39 00C00007           1675mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A0A                          1676mmm     ENDC
00000A0A                 FALSE    1677mmm     IFNE DEBUG
00000A0A                          1678mmm     ENDC
00000A0A                          1679mmm 
00000A0A  BA3C 001B               1680mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A0E  6700 F6F4               1681mmm     BEQ START
00000A12                          1682mmm     ENDM
00000A12                          1683mm CONTINUE_99
00000A12  1A39 00C00013           1684mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A18  0805 0000               1685mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A1C  67D8                    1686mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000A1E                          1687mm     
00000A1E  1A39 00C00017           1688mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A24  13C5 00E00001           1689mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A2A                          1690mm 
00000A2A                          1691mm     ENDM
00000A2A                          1692mm         PRINT_CHAR D5,D6
00000A2A                          1693mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A2A                 TRUE     1694mm     IFEQ DEBUG
00000A2A  1C39 00C00003           1695mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A30  0806 0002               1696mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A34  67F4                    1697mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000A36  13C5 00C00007           1698mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A3C                          1699mm     ENDC
00000A3C                          1700mm 
00000A3C                 FALSE    1701mm     IFNE DEBUG
00000A3C                          1702mm     ENDC
00000A3C                          1703mm 
00000A3C                          1704mm     ENDM
00000A3C                          1705mm         HEX2BIN D5,D5,A4
00000A3C  49FA 0D8D               1706mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A40  0405 0030               1707mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A44  CABC 000000FF           1708mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A4A  1A34 5000               1709mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A4E                          1710mm     ENDM
00000A4E  8805                    1711m         OR.B D5,D4
00000A50  5307                    1712m         SUB.B #1,D7
00000A52                          1713m     ENDW
00000A52  6098                    1714ms     BRA _10000010
00000A54                          1715ms _10000011
00000A54                          1716m 
00000A54  7A00                    1717m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A56  1A04                    1718m     MOVE.B D4,D5
00000A58  D484                    1719m     ADD.L D4,D2
00000A5A                          1720m 
00000A5A                          1721m     ENDM
00000A5A                          1722  
00000A5A  2044                    1723                  MOVE.L D4,A0                        ; start address -> A0
00000A5C  D1C9                    1724                  ADD.L A1,A0                         ; add in the offset
00000A5E                          1725  
00000A5E  72FF                    1726                  MOVE.L #$FFFFFFFF,D1                ; done
00000A60                          1727              ELSE
00000A60  6000 0078               1728s     BRA _0000000A
00000A64                          1729s _00000009
00000A64                          1730m                 PRINT_CRLF D5,A4
00000A64  49FA 0D90               1731m     LEA CRLF(PC),A4
00000A68                          1732mm     PRINT_STR A4,D5
00000A68                          1733mm LOOP_104
00000A68  0C14 0000               1734mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A6C  6700 0016               1735mm     BEQ EXIT_104
00000A70                          1736mmm     PRINT_CHAR (A4)+,D5
00000A70                          1737mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A70                 TRUE     1738mmm     IFEQ DEBUG
00000A70  1A39 00C00003           1739mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A76  0805 0002               1740mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A7A  67F4                    1741mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000A7C  13DC 00C00007           1742mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000A82                          1743mmm     ENDC
00000A82                          1744mmm 
00000A82                 FALSE    1745mmm     IFNE DEBUG
00000A82                          1746mmm     ENDC
00000A82                          1747mmm 
00000A82                          1748mmm     ENDM
00000A82  60E4                    1749mm     BRA LOOP_104
00000A84                          1750mm EXIT_104
00000A84                          1751mm     ENDM
00000A84                          1752m     ENDM
00000A84                          1753  
00000A84  49FA 0CFC               1754                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000A88                          1755m                 PRINT_STR A4,D5
00000A88                          1756m LOOP_106
00000A88  0C14 0000               1757m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000A8C  6700 0016               1758m     BEQ EXIT_106
00000A90                          1759mm     PRINT_CHAR (A4)+,D5
00000A90                          1760mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A90                 TRUE     1761mm     IFEQ DEBUG
00000A90  1A39 00C00003           1762mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000A96  0805 0002               1763mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000A9A  67F4                    1764mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000A9C  13DC 00C00007           1765mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AA2                          1766mm     ENDC
00000AA2                          1767mm 
00000AA2                 FALSE    1768mm     IFNE DEBUG
00000AA2                          1769mm     ENDC
00000AA2                          1770mm 
00000AA2                          1771mm     ENDM
00000AA2  60E4                    1772m     BRA LOOP_106
00000AA4                          1773m EXIT_106
00000AA4                          1774m     ENDM
00000AA4                          1775m                 PRINT_CHAR D1,D5
00000AA4                          1776m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AA4                 TRUE     1777m     IFEQ DEBUG
00000AA4  1A39 00C00003           1778m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AAA  0805 0002               1779m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000AAE  67F4                    1780m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000AB0  13C1 00C00007           1781m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000AB6                          1782m     ENDC
00000AB6                          1783m 
00000AB6                 FALSE    1784m     IFNE DEBUG
00000AB6                          1785m     ENDC
00000AB6                          1786m 
00000AB6                          1787m     ENDM
00000AB6                          1788m                 PRINT_CRLF D5,A4
00000AB6  49FA 0D3E               1789m     LEA CRLF(PC),A4
00000ABA                          1790mm     PRINT_STR A4,D5
00000ABA                          1791mm LOOP_110
00000ABA  0C14 0000               1792mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000ABE  6700 0016               1793mm     BEQ EXIT_110
00000AC2                          1794mmm     PRINT_CHAR (A4)+,D5
00000AC2                          1795mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AC2                 TRUE     1796mmm     IFEQ DEBUG
00000AC2  1A39 00C00003           1797mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000AC8  0805 0002               1798mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000ACC  67F4                    1799mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000ACE  13DC 00C00007           1800mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000AD4                          1801mmm     ENDC
00000AD4                          1802mmm 
00000AD4                 FALSE    1803mmm     IFNE DEBUG
00000AD4                          1804mmm     ENDC
00000AD4                          1805mmm 
00000AD4                          1806mmm     ENDM
00000AD4  60E4                    1807mm     BRA LOOP_110
00000AD6                          1808mm EXIT_110
00000AD6                          1809mm     ENDM
00000AD6                          1810m     ENDM
00000AD6                          1811  
00000AD6  6000 FAEC               1812                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000ADA                          1813              ENDI
00000ADA                          1814s _0000000A
00000ADA                          1815          ENDI
00000ADA                          1816s _00000008
00000ADA                          1817      ENDI
00000ADA                          1818s _00000004
00000ADA                          1819  
00000ADA                          1820m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000ADA  1E3C 0002               1821m     MOVE.B #2,D7
00000ADE                          1822m     WHILE.B D7 <GT> 0 DO
00000ADE                          1823ms _10000012
00000ADE  BE38 0000               1824ms     CMP.B   0,D7
00000AE2  6F00 0062               1825ms     BLE _10000013
00000AE6  E98C                    1826m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000AE8                          1827mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000AE8                          1828mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AE8                          1829mm 
00000AE8  1A39 00C00003           1830mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000AEE  0805 0000               1831mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AF2  6700 0010               1832mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000AF6                          1833mm 
00000AF6                          1834mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AF6                 TRUE     1835mmm     IFEQ DEBUG
00000AF6  1A39 00C00007           1836mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000AFC                          1837mmm     ENDC
00000AFC                 FALSE    1838mmm     IFNE DEBUG
00000AFC                          1839mmm     ENDC
00000AFC                          1840mmm 
00000AFC  BA3C 001B               1841mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B00  6700 F602               1842mmm     BEQ START
00000B04                          1843mmm     ENDM
00000B04                          1844mm CONTINUE_113
00000B04  1A39 00C00013           1845mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B0A  0805 0000               1846mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B0E  67D8                    1847mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000B10                          1848mm     
00000B10  1A39 00C00017           1849mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B16  13C5 00E00001           1850mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B1C                          1851mm 
00000B1C                          1852mm     ENDM
00000B1C                          1853mm         PRINT_CHAR D5,D6
00000B1C                          1854mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B1C                 TRUE     1855mm     IFEQ DEBUG
00000B1C  1C39 00C00003           1856mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B22  0806 0002               1857mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B26  67F4                    1858mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000B28  13C5 00C00007           1859mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B2E                          1860mm     ENDC
00000B2E                          1861mm 
00000B2E                 FALSE    1862mm     IFNE DEBUG
00000B2E                          1863mm     ENDC
00000B2E                          1864mm 
00000B2E                          1865mm     ENDM
00000B2E                          1866mm         HEX2BIN D5,D5,A4
00000B2E  49FA 0C9B               1867mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B32  0405 0030               1868mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B36  CABC 000000FF           1869mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B3C  1A34 5000               1870mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B40                          1871mm     ENDM
00000B40  8805                    1872m         OR.B D5,D4
00000B42  5307                    1873m         SUB.B #1,D7
00000B44                          1874m     ENDW
00000B44  6098                    1875ms     BRA _10000012
00000B46                          1876ms _10000013
00000B46                          1877m 
00000B46  7A00                    1878m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B48  1A04                    1879m     MOVE.B D4,D5
00000B4A  D484                    1880m     ADD.L D4,D2
00000B4C                          1881m 
00000B4C                          1882m     ENDM
00000B4C                          1883m     PRINT_CRLF D5,A4
00000B4C  49FA 0CA8               1884m     LEA CRLF(PC),A4
00000B50                          1885mm     PRINT_STR A4,D5
00000B50                          1886mm LOOP_118
00000B50  0C14 0000               1887mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B54  6700 0016               1888mm     BEQ EXIT_118
00000B58                          1889mmm     PRINT_CHAR (A4)+,D5
00000B58                          1890mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B58                 TRUE     1891mmm     IFEQ DEBUG
00000B58  1A39 00C00003           1892mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B5E  0805 0002               1893mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B62  67F4                    1894mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000B64  13DC 00C00007           1895mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B6A                          1896mmm     ENDC
00000B6A                          1897mmm 
00000B6A                 FALSE    1898mmm     IFNE DEBUG
00000B6A                          1899mmm     ENDC
00000B6A                          1900mmm 
00000B6A                          1901mmm     ENDM
00000B6A  60E4                    1902mm     BRA LOOP_118
00000B6C                          1903mm EXIT_118
00000B6C                          1904mm     ENDM
00000B6C                          1905m     ENDM
00000B6C                          1906  
00000B6C                          1907      IF.B D2 <NE> #$FF THEN.L
00000B6C  B43C 00FF               1908s     CMP.B   #$FF,D2
00000B70  6700 0090               1909s     BEQ.L   _0000000B
00000B74  49FA 0C23               1910          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000B78                          1911m         PRINT_STR A4,D5
00000B78                          1912m LOOP_120
00000B78  0C14 0000               1913m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B7C  6700 0016               1914m     BEQ EXIT_120
00000B80                          1915mm     PRINT_CHAR (A4)+,D5
00000B80                          1916mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B80                 TRUE     1917mm     IFEQ DEBUG
00000B80  1A39 00C00003           1918mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000B86  0805 0002               1919mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000B8A  67F4                    1920mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000B8C  13DC 00C00007           1921mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000B92                          1922mm     ENDC
00000B92                          1923mm 
00000B92                 FALSE    1924mm     IFNE DEBUG
00000B92                          1925mm     ENDC
00000B92                          1926mm 
00000B92                          1927mm     ENDM
00000B92  60E4                    1928m     BRA LOOP_120
00000B94                          1929m EXIT_120
00000B94                          1930m     ENDM
00000B94                          1931m         PRINT_REG D0,D5,D3,D6,A4
00000B94  49FA 0C66               1932m     LEA OX(PC),A4
00000B98                          1933mm     PRINT_STR A4,D5
00000B98                          1934mm LOOP_123
00000B98  0C14 0000               1935mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000B9C  6700 0016               1936mm     BEQ EXIT_123
00000BA0                          1937mmm     PRINT_CHAR (A4)+,D5
00000BA0                          1938mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BA0                 TRUE     1939mmm     IFEQ DEBUG
00000BA0  1A39 00C00003           1940mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BA6  0805 0002               1941mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BAA  67F4                    1942mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000BAC  13DC 00C00007           1943mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BB2                          1944mmm     ENDC
00000BB2                          1945mmm 
00000BB2                 FALSE    1946mmm     IFNE DEBUG
00000BB2                          1947mmm     ENDC
00000BB2                          1948mmm 
00000BB2                          1949mmm     ENDM
00000BB2  60E4                    1950mm     BRA LOOP_123
00000BB4                          1951mm EXIT_123
00000BB4                          1952mm     ENDM
00000BB4  7C07                    1953m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000BB6                          1954m LOOP_122
00000BB6                          1955mm     BIN2HEX D0,D3,A4
00000BB6  49FA 0C03               1956mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000BBA  E998                    1957mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000BBC  1600                    1958mm     MOVE.B D0,D3
00000BBE  0283 0000000F           1959mm     ANDI.L #$F,D3
00000BC4  1634 3000               1960mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000BC8                          1961mm     ENDM
00000BC8                          1962mm     PRINT_CHAR D3,D5
00000BC8                          1963mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BC8                 TRUE     1964mm     IFEQ DEBUG
00000BC8  1A39 00C00003           1965mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BCE  0805 0002               1966mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BD2  67F4                    1967mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000BD4  13C3 00C00007           1968mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000BDA                          1969mm     ENDC
00000BDA                          1970mm 
00000BDA                 FALSE    1971mm     IFNE DEBUG
00000BDA                          1972mm     ENDC
00000BDA                          1973mm 
00000BDA                          1974mm     ENDM
00000BDA  57CE FFDA               1975m     DBEQ D6,LOOP_122
00000BDE                          1976m     ENDM
00000BDE                          1977m         PRINT_CRLF D5,A4
00000BDE  49FA 0C16               1978m     LEA CRLF(PC),A4
00000BE2                          1979mm     PRINT_STR A4,D5
00000BE2                          1980mm LOOP_128
00000BE2  0C14 0000               1981mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000BE6  6700 0016               1982mm     BEQ EXIT_128
00000BEA                          1983mmm     PRINT_CHAR (A4)+,D5
00000BEA                          1984mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BEA                 TRUE     1985mmm     IFEQ DEBUG
00000BEA  1A39 00C00003           1986mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000BF0  0805 0002               1987mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000BF4  67F4                    1988mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000BF6  13DC 00C00007           1989mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000BFC                          1990mmm     ENDC
00000BFC                          1991mmm 
00000BFC                 FALSE    1992mmm     IFNE DEBUG
00000BFC                          1993mmm     ENDC
00000BFC                          1994mmm 
00000BFC                          1995mmm     ENDM
00000BFC  60E4                    1996mm     BRA LOOP_128
00000BFE                          1997mm EXIT_128
00000BFE                          1998mm     ENDM
00000BFE                          1999m     ENDM
00000BFE                          2000          
00000BFE  6000 F71C               2001          BRA MAIN_LOOP
00000C02                          2002      ENDI
00000C02                          2003s _0000000B
00000C02                          2004  
00000C02                          2005      IF D1 <EQ> #0 THEN
00000C02  B27C 0000               2006s     CMP.W   #0,D1
00000C06  6600 0006               2007s     BNE _0000000C
00000C0A  6000 F9B8               2008        BRA WAIT_FOR_SRECORD
00000C0E                          2009      ENDI
00000C0E                          2010s _0000000C
00000C0E                          2011  DOWNLOAD_DONE
00000C0E                          2012m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000C0E  43FA 0BEC               2013m     LEA OX(PC),A1
00000C12                          2014mm     PRINT_STR A1,D5
00000C12                          2015mm LOOP_131
00000C12  0C11 0000               2016mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C16  6700 0016               2017mm     BEQ EXIT_131
00000C1A                          2018mmm     PRINT_CHAR (A1)+,D5
00000C1A                          2019mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C1A                 TRUE     2020mmm     IFEQ DEBUG
00000C1A  1A39 00C00003           2021mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C20  0805 0002               2022mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C24  67F4                    2023mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000C26  13D9 00C00007           2024mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C2C                          2025mmm     ENDC
00000C2C                          2026mmm 
00000C2C                 FALSE    2027mmm     IFNE DEBUG
00000C2C                          2028mmm     ENDC
00000C2C                          2029mmm 
00000C2C                          2030mmm     ENDM
00000C2C  60E4                    2031mm     BRA LOOP_131
00000C2E                          2032mm EXIT_131
00000C2E                          2033mm     ENDM
00000C2E  7407                    2034m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C30                          2035m LOOP_130
00000C30                          2036mm     BIN2HEX D0,D6,A1
00000C30  43FA 0B89               2037mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000C34  E998                    2038mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000C36  1C00                    2039mm     MOVE.B D0,D6
00000C38  0286 0000000F           2040mm     ANDI.L #$F,D6
00000C3E  1C31 6000               2041mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000C42                          2042mm     ENDM
00000C42                          2043mm     PRINT_CHAR D6,D5
00000C42                          2044mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C42                 TRUE     2045mm     IFEQ DEBUG
00000C42  1A39 00C00003           2046mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C48  0805 0002               2047mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C4C  67F4                    2048mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000C4E  13C6 00C00007           2049mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C54                          2050mm     ENDC
00000C54                          2051mm 
00000C54                 FALSE    2052mm     IFNE DEBUG
00000C54                          2053mm     ENDC
00000C54                          2054mm 
00000C54                          2055mm     ENDM
00000C54  57CA FFDA               2056m     DBEQ D2,LOOP_130
00000C58                          2057m     ENDM
00000C58  43FA 0B06               2058      LEA READ(PC),A1
00000C5C                          2059m     PRINT_STR A1,D5
00000C5C                          2060m LOOP_135
00000C5C  0C11 0000               2061m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C60  6700 0016               2062m     BEQ EXIT_135
00000C64                          2063mm     PRINT_CHAR (A1)+,D5
00000C64                          2064mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C64                 TRUE     2065mm     IFEQ DEBUG
00000C64  1A39 00C00003           2066mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C6A  0805 0002               2067mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C6E  67F4                    2068mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000C70  13D9 00C00007           2069mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C76                          2070mm     ENDC
00000C76                          2071mm 
00000C76                 FALSE    2072mm     IFNE DEBUG
00000C76                          2073mm     ENDC
00000C76                          2074mm 
00000C76                          2075mm     ENDM
00000C76  60E4                    2076m     BRA LOOP_135
00000C78                          2077m EXIT_135
00000C78                          2078m     ENDM
00000C78  2E08                    2079      MOVE.L A0,D7                                    ; set address accumulator to start address
00000C7A                          2080m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000C7A  43FA 0B80               2081m     LEA OX(PC),A1
00000C7E                          2082mm     PRINT_STR A1,D5
00000C7E                          2083mm LOOP_138
00000C7E  0C11 0000               2084mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000C82  6700 0016               2085mm     BEQ EXIT_138
00000C86                          2086mmm     PRINT_CHAR (A1)+,D5
00000C86                          2087mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C86                 TRUE     2088mmm     IFEQ DEBUG
00000C86  1A39 00C00003           2089mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000C8C  0805 0002               2090mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000C90  67F4                    2091mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000C92  13D9 00C00007           2092mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000C98                          2093mmm     ENDC
00000C98                          2094mmm 
00000C98                 FALSE    2095mmm     IFNE DEBUG
00000C98                          2096mmm     ENDC
00000C98                          2097mmm 
00000C98                          2098mmm     ENDM
00000C98  60E4                    2099mm     BRA LOOP_138
00000C9A                          2100mm EXIT_138
00000C9A                          2101mm     ENDM
00000C9A  7407                    2102m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000C9C                          2103m LOOP_137
00000C9C                          2104mm     BIN2HEX D7,D6,A1
00000C9C  43FA 0B1D               2105mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000CA0  E99F                    2106mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000CA2  1C07                    2107mm     MOVE.B D7,D6
00000CA4  0286 0000000F           2108mm     ANDI.L #$F,D6
00000CAA  1C31 6000               2109mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000CAE                          2110mm     ENDM
00000CAE                          2111mm     PRINT_CHAR D6,D5
00000CAE                          2112mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CAE                 TRUE     2113mm     IFEQ DEBUG
00000CAE  1A39 00C00003           2114mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CB4  0805 0002               2115mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CB8  67F4                    2116mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000CBA  13C6 00C00007           2117mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CC0                          2118mm     ENDC
00000CC0                          2119mm 
00000CC0                 FALSE    2120mm     IFNE DEBUG
00000CC0                          2121mm     ENDC
00000CC0                          2122mm 
00000CC0                          2123mm     ENDM
00000CC0  57CA FFDA               2124m     DBEQ D2,LOOP_137
00000CC4                          2125m     ENDM
00000CC4                          2126m     PRINT_CRLF D5,A4
00000CC4  49FA 0B30               2127m     LEA CRLF(PC),A4
00000CC8                          2128mm     PRINT_STR A4,D5
00000CC8                          2129mm LOOP_143
00000CC8  0C14 0000               2130mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000CCC  6700 0016               2131mm     BEQ EXIT_143
00000CD0                          2132mmm     PRINT_CHAR (A4)+,D5
00000CD0                          2133mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CD0                 TRUE     2134mmm     IFEQ DEBUG
00000CD0  1A39 00C00003           2135mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000CD6  0805 0002               2136mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000CDA  67F4                    2137mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000CDC  13DC 00C00007           2138mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000CE2                          2139mmm     ENDC
00000CE2                          2140mmm 
00000CE2                 FALSE    2141mmm     IFNE DEBUG
00000CE2                          2142mmm     ENDC
00000CE2                          2143mmm 
00000CE2                          2144mmm     ENDM
00000CE2  60E4                    2145mm     BRA LOOP_143
00000CE4                          2146mm EXIT_143
00000CE4                          2147mm     ENDM
00000CE4                          2148m     ENDM
00000CE4                          2149  
00000CE4  6000 F636               2150      BRA MAIN_LOOP
00000CE8                          2151  
00000CE8                          2152  G
00000CE8  2047                    2153      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000CEA  7E00                    2154      MOVE.L #0,D7
00000CEC                          2155  
00000CEC  4ED0                    2156      JMP (A0)
00000CEE                          2157          
00000CEE                          2158  Z
00000CEE  207C 00200000           2159      MOVE.L #RAM,A0                                  ; address of RAM
00000CF4  D1FC 00100000           2160      ADD.L #$100000,A0
00000CFA                          2161  
00000CFA                          2162      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000CFA  7000                    2163s     MOVE.L  #0,D0
00000CFC  6000 0012               2164s     BRA _20000007
00000D00                          2165s _20000006
00000D00  2200                    2166          MOVE.L D0,D1                                ; progress update
00000D02  E089                    2167          LSR.L #8,D1 
00000D04  E089                    2168          LSR.L #8,D1
00000D06  13C1 00E00001           2169          MOVE.B D1,DISPLAY
00000D0C                          2170          
00000D0C  2108                    2171          MOVE.L A0,-(A0)
00000D0E                          2172      ENDF
00000D0E  5880                    2173s     ADD.L   #4,D0
00000D10                          2174s _20000007
00000D10  B0BC 000FFFFC           2175s     CMP.L   #$FFFFC,D0
00000D16  6FE8                    2176s     BLE _20000006
00000D18                          2177  
00000D18  207C 00200000           2178      MOVE.L #RAM,A0                                  ; address of RAM
00000D1E  D1FC 00100000           2179      ADD.L #$100000,A0
00000D24                          2180  
00000D24                          2181      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000D24  7000                    2182s     MOVE.L  #0,D0
00000D26  6000 00A8               2183s     BRA _20000009
00000D2A                          2184s _20000008
00000D2A  2200                    2185          MOVE.L D0,D1                                ; progress update
00000D2C  E089                    2186          LSR.L #8,D1
00000D2E  E089                    2187          LSR.L #8,D1
00000D30  13C1 00E00001           2188          MOVE.B D1,DISPLAY
00000D36                          2189  
00000D36  2408                    2190          MOVE.L A0,D2
00000D38  2220                    2191          MOVE.L -(A0),D1
00000D3A                          2192  
00000D3A                          2193          IF.L D2 <NE> D1 THEN
00000D3A  B481                    2194s     CMP.L   D1,D2
00000D3C  6700 0090               2195s     BEQ _0000000D
00000D40  43FA 0A68               2196              LEA RAM_ERROR(PC),A1
00000D44                          2197m             PRINT_STR A1,D1
00000D44                          2198m LOOP_145
00000D44  0C11 0000               2199m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D48  6700 0016               2200m     BEQ EXIT_145
00000D4C                          2201mm     PRINT_CHAR (A1)+,D1
00000D4C                          2202mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D4C                 TRUE     2203mm     IFEQ DEBUG
00000D4C  1239 00C00003           2204mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000D52  0801 0002               2205mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000D56  67F4                    2206mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00000D58  13D9 00C00007           2207mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D5E                          2208mm     ENDC
00000D5E                          2209mm 
00000D5E                 FALSE    2210mm     IFNE DEBUG
00000D5E                          2211mm     ENDC
00000D5E                          2212mm 
00000D5E                          2213mm     ENDM
00000D5E  60E4                    2214m     BRA LOOP_145
00000D60                          2215m EXIT_145
00000D60                          2216m     ENDM
00000D60  2208                    2217              MOVE.L A0,D1
00000D62  5981                    2218              SUB.L #4,D1
00000D64                          2219m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00000D64  43FA 0A96               2220m     LEA OX(PC),A1
00000D68                          2221mm     PRINT_STR A1,D3
00000D68                          2222mm LOOP_148
00000D68  0C11 0000               2223mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000D6C  6700 0016               2224mm     BEQ EXIT_148
00000D70                          2225mmm     PRINT_CHAR (A1)+,D3
00000D70                          2226mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D70                 TRUE     2227mmm     IFEQ DEBUG
00000D70  1639 00C00003           2228mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D76  0803 0002               2229mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000D7A  67F4                    2230mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
00000D7C  13D9 00C00007           2231mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D82                          2232mmm     ENDC
00000D82                          2233mmm 
00000D82                 FALSE    2234mmm     IFNE DEBUG
00000D82                          2235mmm     ENDC
00000D82                          2236mmm 
00000D82                          2237mmm     ENDM
00000D82  60E4                    2238mm     BRA LOOP_148
00000D84                          2239mm EXIT_148
00000D84                          2240mm     ENDM
00000D84  7C07                    2241m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000D86                          2242m LOOP_147
00000D86                          2243mm     BIN2HEX D1,D2,A1
00000D86  43FA 0A33               2244mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000D8A  E999                    2245mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000D8C  1401                    2246mm     MOVE.B D1,D2
00000D8E  0282 0000000F           2247mm     ANDI.L #$F,D2
00000D94  1431 2000               2248mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00000D98                          2249mm     ENDM
00000D98                          2250mm     PRINT_CHAR D2,D3
00000D98                          2251mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D98                 TRUE     2252mm     IFEQ DEBUG
00000D98  1639 00C00003           2253mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000D9E  0803 0002               2254mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DA2  67F4                    2255mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00000DA4  13C2 00C00007           2256mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DAA                          2257mm     ENDC
00000DAA                          2258mm 
00000DAA                 FALSE    2259mm     IFNE DEBUG
00000DAA                          2260mm     ENDC
00000DAA                          2261mm 
00000DAA                          2262mm     ENDM
00000DAA  57CE FFDA               2263m     DBEQ D6,LOOP_147
00000DAE                          2264m     ENDM
00000DAE                          2265m             PRINT_CRLF D3,A1
00000DAE  43FA 0A46               2266m     LEA CRLF(PC),A1
00000DB2                          2267mm     PRINT_STR A1,D3
00000DB2                          2268mm LOOP_153
00000DB2  0C11 0000               2269mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000DB6  6700 0016               2270mm     BEQ EXIT_153
00000DBA                          2271mmm     PRINT_CHAR (A1)+,D3
00000DBA                          2272mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DBA                 TRUE     2273mmm     IFEQ DEBUG
00000DBA  1639 00C00003           2274mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000DC0  0803 0002               2275mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000DC4  67F4                    2276mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00000DC6  13D9 00C00007           2277mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000DCC                          2278mmm     ENDC
00000DCC                          2279mmm 
00000DCC                 FALSE    2280mmm     IFNE DEBUG
00000DCC                          2281mmm     ENDC
00000DCC                          2282mmm 
00000DCC                          2283mmm     ENDM
00000DCC  60E4                    2284mm     BRA LOOP_153
00000DCE                          2285mm EXIT_153
00000DCE                          2286mm     ENDM
00000DCE                          2287m     ENDM
00000DCE                          2288          ENDI 
00000DCE                          2289s _0000000D
00000DCE                          2290      ENDF
00000DCE  5880                    2291s     ADD.L   #4,D0
00000DD0                          2292s _20000009
00000DD0  B0BC 000FFFFC           2293s     CMP.L   #$FFFFC,D0
00000DD6  6F00 FF52               2294s     BLE _20000008
00000DDA                          2295  
00000DDA  6000 F540               2296      BRA MAIN_LOOP
00000DDE                          2297  
00000DDE                          2298  L
00000DDE  7000                    2299      MOVE.L #0,D0                                    ; D0 will be the length to write               
00000DE0  7200                    2300      MOVE.L #0,D1                                    ; D1 will be the address to write 
00000DE2                          2301  
00000DE2                          2302      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
00000DE2  343C 0000               2303s     MOVE.W  #0,D2
00000DE6  6000 0046               2304s     BRA _2000000B
00000DEA                          2305s _2000000A
00000DEA  E989                    2306          LSL.L #4,D1                                 ; make what we have so far more significant
00000DEC                          2307m         WAIT_CHAR D3,D4                             ; next character -> D2
00000DEC                          2308m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DEC                 TRUE     2309m     IFEQ DEBUG
00000DEC  1839 00C00003           2310m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000DF2  0804 0000               2311m         BTST #0,D4                                  ; CHECK FOR CHARACTER
00000DF6  67F4                    2312m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
00000DF8                          2313m     ENDC
00000DF8                          2314m 
00000DF8                          2315mm     READ_CHAR D3
00000DF8                 TRUE     2316mm     IFEQ DEBUG
00000DF8  1639 00C00007           2317mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
00000DFE                          2318mm     ENDC
00000DFE                 FALSE    2319mm     IFNE DEBUG
00000DFE                          2320mm     ENDC
00000DFE                          2321mm 
00000DFE  B63C 001B               2322mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
00000E02  6700 F300               2323mm     BEQ START
00000E06                          2324mm     ENDM
00000E06                          2325m 
00000E06                 TRUE     2326m     IFEQ DEBUG
00000E06                          2327mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
00000E06                          2328mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E06                 TRUE     2329mm     IFEQ DEBUG
00000E06  1839 00C00003           2330mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
00000E0C  0804 0002               2331mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
00000E10  67F4                    2332mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
00000E12  13C3 00C00007           2333mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E18                          2334mm     ENDC
00000E18                          2335mm 
00000E18                 FALSE    2336mm     IFNE DEBUG
00000E18                          2337mm     ENDC
00000E18                          2338mm 
00000E18                          2339mm     ENDM
00000E18                          2340m     ENDC
00000E18                          2341m     ENDM
00000E18                          2342m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
00000E18  41FA 09B1               2343m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000E1C  0403 0030               2344m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000E20  C6BC 000000FF           2345m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
00000E26  1630 3000               2346m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
00000E2A                          2347m     ENDM
00000E2A  8203                    2348          OR.B D3,D1
00000E2C                          2349      ENDF
00000E2C  5242                    2350s     ADD.W   #1,D2
00000E2E                          2351s _2000000B
00000E2E  B47C 0007               2352s     CMP.W   #7,D2
00000E32  6FB6                    2353s     BLE _2000000A
00000E34                          2354  
00000E34  3001                    2355      MOVE.W D1,D0                                    ; extract the LSword for the length 
00000E36  0480 00000104           2356      SUB.L #START,D0                                 ; remove the vector table from the length
00000E3C  E089                    2357      LSR.L #8,D1                                     ; extract the MSword for the address
00000E3E  E089                    2358      LSR.L #8,D1
00000E40                          2359  
00000E40                          2360m     PRINT_CRLF D2,A1
00000E40  43FA 09B4               2361m     LEA CRLF(PC),A1
00000E44                          2362mm     PRINT_STR A1,D2
00000E44                          2363mm LOOP_160
00000E44  0C11 0000               2364mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000E48  6700 0016               2365mm     BEQ EXIT_160
00000E4C                          2366mmm     PRINT_CHAR (A1)+,D2
00000E4C                          2367mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E4C                 TRUE     2368mmm     IFEQ DEBUG
00000E4C  1439 00C00003           2369mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000E52  0802 0002               2370mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000E56  67F4                    2371mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00000E58  13D9 00C00007           2372mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E5E                          2373mmm     ENDC
00000E5E                          2374mmm 
00000E5E                 FALSE    2375mmm     IFNE DEBUG
00000E5E                          2376mmm     ENDC
00000E5E                          2377mmm 
00000E5E                          2378mmm     ENDM
00000E5E  60E4                    2379mm     BRA LOOP_160
00000E60                          2380mm EXIT_160
00000E60                          2381mm     ENDM
00000E60                          2382m     ENDM
00000E60                          2383  
00000E60  2041                    2384      MOVE.L D1,A0                                    ; target address
00000E62  2641                    2385      MOVE.L D1,A3                                    ; keep a copy for later
00000E64                          2386  
00000E64  2247                    2387      MOVE.L D7,A1                                    ; address accumulator -> address register
00000E66  D3FC 00000104           2388      ADD.L #START,A1                             ; skip the vectors
00000E6C  2847                    2389      MOVE.L D7,A4                                    ; keep a clean copy for later
00000E6E  7E00                    2390      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000E70                          2391  
00000E70                          2392m     UNPROTECT                                   ; important to only unprotect when we are fully committed (ie, can't escape)
00000E70  31FC AAAA 2AAA          2393m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00000E76  4E71                    2394m     NOP
00000E78  31FC 5555 1554          2395m     MOVE.W #$5555,$1554
00000E7E  4E71                    2396m     NOP
00000E80  31FC 8080 2AAA          2397m     MOVE.W #$8080,$2AAA
00000E86  4E71                    2398m     NOP
00000E88  31FC AAAA 2AAA          2399m     MOVE.W #$AAAA,$2AAA
00000E8E  4E71                    2400m     NOP
00000E90  31FC 5555 1554          2401m     MOVE.W #$5555,$1554
00000E96  4E71                    2402m     NOP
00000E98  31FC 2020 2AAA          2403m     MOVE.W #$2020,$2AAA
00000E9E                          2404m     ENDM
00000E9E                          2405                      
00000E9E                          2406      FOR D7 = #$0 TO #$FFFFFFFF DO               ; dead timing loop to wait for unprotect
00000E9E  3E3C 0000               2407s     MOVE.W  #$0,D7
00000EA2  6000 0006               2408s     BRA _2000000D
00000EA6                          2409s _2000000C
00000EA6  4E71                    2410          NOP
00000EA8                          2411      ENDF
00000EA8  5247                    2412s     ADD.W   #1,D7
00000EAA                          2413s _2000000D
00000EAA  BE7C FFFF               2414s     CMP.W   #$FFFFFFFF,D7
00000EAE  6FF6                    2415s     BLE _2000000C
00000EB0                          2416                  
00000EB0  45FA 0930               2417      LEA LOADING(PC),A2
00000EB4                          2418m     PRINT_STR A2,D2
00000EB4                          2419m LOOP_163
00000EB4  0C12 0000               2420m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EB8  6700 0016               2421m     BEQ EXIT_163
00000EBC                          2422mm     PRINT_CHAR (A2)+,D2
00000EBC                          2423mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EBC                 TRUE     2424mm     IFEQ DEBUG
00000EBC  1439 00C00003           2425mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EC2  0802 0002               2426mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EC6  67F4                    2427mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
00000EC8  13DA 00C00007           2428mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000ECE                          2429mm     ENDC
00000ECE                          2430mm 
00000ECE                 FALSE    2431mm     IFNE DEBUG
00000ECE                          2432mm     ENDC
00000ECE                          2433mm 
00000ECE                          2434mm     ENDM
00000ECE  60E4                    2435m     BRA LOOP_163
00000ED0                          2436m EXIT_163
00000ED0                          2437m     ENDM
00000ED0  45FA 0910               2438      LEA LOADING(PC),A2
00000ED4                          2439m     PRINT_STR A2,D2
00000ED4                          2440m LOOP_165
00000ED4  0C12 0000               2441m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000ED8  6700 0016               2442m     BEQ EXIT_165
00000EDC                          2443mm     PRINT_CHAR (A2)+,D2
00000EDC                          2444mm WAIT_FOR_READY_166                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EDC                 TRUE     2445mm     IFEQ DEBUG
00000EDC  1439 00C00003           2446mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000EE2  0802 0002               2447mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00000EE6  67F4                    2448mm         BEQ WAIT_FOR_READY_166                      ; NO SPACE, CHECK AGAIN
00000EE8  13DA 00C00007           2449mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EEE                          2450mm     ENDC
00000EEE                          2451mm 
00000EEE                 FALSE    2452mm     IFNE DEBUG
00000EEE                          2453mm     ENDC
00000EEE                          2454mm 
00000EEE                          2455mm     ENDM
00000EEE  60E4                    2456m     BRA LOOP_165
00000EF0                          2457m EXIT_165
00000EF0                          2458m     ENDM
00000EF0                          2459          
00000EF0  2409                    2460      MOVE.L A1,D2
00000EF2                          2461m     PRINT_REG D2,D3,D4,D5,A2
00000EF2  45FA 0908               2462m     LEA OX(PC),A2
00000EF6                          2463mm     PRINT_STR A2,D3
00000EF6                          2464mm LOOP_168
00000EF6  0C12 0000               2465mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000EFA  6700 0016               2466mm     BEQ EXIT_168
00000EFE                          2467mmm     PRINT_CHAR (A2)+,D3
00000EFE                          2468mmm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EFE                 TRUE     2469mmm     IFEQ DEBUG
00000EFE  1639 00C00003           2470mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F04  0803 0002               2471mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F08  67F4                    2472mmm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
00000F0A  13DA 00C00007           2473mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F10                          2474mmm     ENDC
00000F10                          2475mmm 
00000F10                 FALSE    2476mmm     IFNE DEBUG
00000F10                          2477mmm     ENDC
00000F10                          2478mmm 
00000F10                          2479mmm     ENDM
00000F10  60E4                    2480mm     BRA LOOP_168
00000F12                          2481mm EXIT_168
00000F12                          2482mm     ENDM
00000F12  7A07                    2483m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F14                          2484m LOOP_167
00000F14                          2485mm     BIN2HEX D2,D4,A2
00000F14  45FA 08A5               2486mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F18  E99A                    2487mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F1A  1802                    2488mm     MOVE.B D2,D4
00000F1C  0284 0000000F           2489mm     ANDI.L #$F,D4
00000F22  1832 4000               2490mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F26                          2491mm     ENDM
00000F26                          2492mm     PRINT_CHAR D4,D3
00000F26                          2493mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F26                 TRUE     2494mm     IFEQ DEBUG
00000F26  1639 00C00003           2495mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F2C  0803 0002               2496mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F30  67F4                    2497mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
00000F32  13C4 00C00007           2498mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F38                          2499mm     ENDC
00000F38                          2500mm 
00000F38                 FALSE    2501mm     IFNE DEBUG
00000F38                          2502mm     ENDC
00000F38                          2503mm 
00000F38                          2504mm     ENDM
00000F38  57CD FFDA               2505m     DBEQ D5,LOOP_167
00000F3C                          2506m     ENDM
00000F3C                          2507  
00000F3C  45FA 08C1               2508      LEA TO(PC),A2
00000F40                          2509m     PRINT_STR A2,D3
00000F40                          2510m LOOP_172
00000F40  0C12 0000               2511m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F44  6700 0016               2512m     BEQ EXIT_172
00000F48                          2513mm     PRINT_CHAR (A2)+,D3
00000F48                          2514mm WAIT_FOR_READY_173                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F48                 TRUE     2515mm     IFEQ DEBUG
00000F48  1639 00C00003           2516mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F4E  0803 0002               2517mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F52  67F4                    2518mm         BEQ WAIT_FOR_READY_173                      ; NO SPACE, CHECK AGAIN
00000F54  13DA 00C00007           2519mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F5A                          2520mm     ENDC
00000F5A                          2521mm 
00000F5A                 FALSE    2522mm     IFNE DEBUG
00000F5A                          2523mm     ENDC
00000F5A                          2524mm 
00000F5A                          2525mm     ENDM
00000F5A  60E4                    2526m     BRA LOOP_172
00000F5C                          2527m EXIT_172
00000F5C                          2528m     ENDM
00000F5C                          2529  
00000F5C  2408                    2530      MOVE.L A0,D2
00000F5E                          2531m     PRINT_REG D2,D3,D4,D5,A2
00000F5E  45FA 089C               2532m     LEA OX(PC),A2
00000F62                          2533mm     PRINT_STR A2,D3
00000F62                          2534mm LOOP_175
00000F62  0C12 0000               2535mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000F66  6700 0016               2536mm     BEQ EXIT_175
00000F6A                          2537mmm     PRINT_CHAR (A2)+,D3
00000F6A                          2538mmm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F6A                 TRUE     2539mmm     IFEQ DEBUG
00000F6A  1639 00C00003           2540mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F70  0803 0002               2541mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F74  67F4                    2542mmm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00000F76  13DA 00C00007           2543mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F7C                          2544mmm     ENDC
00000F7C                          2545mmm 
00000F7C                 FALSE    2546mmm     IFNE DEBUG
00000F7C                          2547mmm     ENDC
00000F7C                          2548mmm 
00000F7C                          2549mmm     ENDM
00000F7C  60E4                    2550mm     BRA LOOP_175
00000F7E                          2551mm EXIT_175
00000F7E                          2552mm     ENDM
00000F7E  7A07                    2553m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F80                          2554m LOOP_174
00000F80                          2555mm     BIN2HEX D2,D4,A2
00000F80  45FA 0839               2556mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000F84  E99A                    2557mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F86  1802                    2558mm     MOVE.B D2,D4
00000F88  0284 0000000F           2559mm     ANDI.L #$F,D4
00000F8E  1832 4000               2560mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000F92                          2561mm     ENDM
00000F92                          2562mm     PRINT_CHAR D4,D3
00000F92                          2563mm WAIT_FOR_READY_178                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F92                 TRUE     2564mm     IFEQ DEBUG
00000F92  1639 00C00003           2565mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000F98  0803 0002               2566mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000F9C  67F4                    2567mm         BEQ WAIT_FOR_READY_178                      ; NO SPACE, CHECK AGAIN
00000F9E  13C4 00C00007           2568mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000FA4                          2569mm     ENDC
00000FA4                          2570mm 
00000FA4                 FALSE    2571mm     IFNE DEBUG
00000FA4                          2572mm     ENDC
00000FA4                          2573mm 
00000FA4                          2574mm     ENDM
00000FA4  57CD FFDA               2575m     DBEQ D5,LOOP_174
00000FA8                          2576m     ENDM
00000FA8                          2577  
00000FA8  45FA 085A               2578      LEA FOR(PC),A2
00000FAC                          2579m     PRINT_STR A2,D3
00000FAC                          2580m LOOP_179
00000FAC  0C12 0000               2581m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FB0  6700 0016               2582m     BEQ EXIT_179
00000FB4                          2583mm     PRINT_CHAR (A2)+,D3
00000FB4                          2584mm WAIT_FOR_READY_180                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FB4                 TRUE     2585mm     IFEQ DEBUG
00000FB4  1639 00C00003           2586mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FBA  0803 0002               2587mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FBE  67F4                    2588mm         BEQ WAIT_FOR_READY_180                      ; NO SPACE, CHECK AGAIN
00000FC0  13DA 00C00007           2589mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FC6                          2590mm     ENDC
00000FC6                          2591mm 
00000FC6                 FALSE    2592mm     IFNE DEBUG
00000FC6                          2593mm     ENDC
00000FC6                          2594mm 
00000FC6                          2595mm     ENDM
00000FC6  60E4                    2596m     BRA LOOP_179
00000FC8                          2597m EXIT_179
00000FC8                          2598m     ENDM
00000FC8                          2599m     PRINT_REG D0,D3,D4,D5,A2
00000FC8  45FA 0832               2600m     LEA OX(PC),A2
00000FCC                          2601mm     PRINT_STR A2,D3
00000FCC                          2602mm LOOP_182
00000FCC  0C12 0000               2603mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00000FD0  6700 0016               2604mm     BEQ EXIT_182
00000FD4                          2605mmm     PRINT_CHAR (A2)+,D3
00000FD4                          2606mmm WAIT_FOR_READY_183                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FD4                 TRUE     2607mmm     IFEQ DEBUG
00000FD4  1639 00C00003           2608mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000FDA  0803 0002               2609mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000FDE  67F4                    2610mmm         BEQ WAIT_FOR_READY_183                      ; NO SPACE, CHECK AGAIN
00000FE0  13DA 00C00007           2611mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FE6                          2612mmm     ENDC
00000FE6                          2613mmm 
00000FE6                 FALSE    2614mmm     IFNE DEBUG
00000FE6                          2615mmm     ENDC
00000FE6                          2616mmm 
00000FE6                          2617mmm     ENDM
00000FE6  60E4                    2618mm     BRA LOOP_182
00000FE8                          2619mm EXIT_182
00000FE8                          2620mm     ENDM
00000FE8  7A07                    2621m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000FEA                          2622m LOOP_181
00000FEA                          2623mm     BIN2HEX D0,D4,A2
00000FEA  45FA 07CF               2624mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00000FEE  E998                    2625mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000FF0  1800                    2626mm     MOVE.B D0,D4
00000FF2  0284 0000000F           2627mm     ANDI.L #$F,D4
00000FF8  1832 4000               2628mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000FFC                          2629mm     ENDM
00000FFC                          2630mm     PRINT_CHAR D4,D3
00000FFC                          2631mm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000FFC                 TRUE     2632mm     IFEQ DEBUG
00000FFC  1639 00C00003           2633mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001002  0803 0002               2634mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001006  67F4                    2635mm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
00001008  13C4 00C00007           2636mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000100E                          2637mm     ENDC
0000100E                          2638mm 
0000100E                 FALSE    2639mm     IFNE DEBUG
0000100E                          2640mm     ENDC
0000100E                          2641mm 
0000100E                          2642mm     ENDM
0000100E  57CD FFDA               2643m     DBEQ D5,LOOP_181
00001012                          2644m     ENDM
00001012                          2645  
00001012                          2646m     PRINT_CRLF D3,A2
00001012  45FA 07E2               2647m     LEA CRLF(PC),A2
00001016                          2648mm     PRINT_STR A2,D3
00001016                          2649mm LOOP_187
00001016  0C12 0000               2650mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000101A  6700 0016               2651mm     BEQ EXIT_187
0000101E                          2652mmm     PRINT_CHAR (A2)+,D3
0000101E                          2653mmm WAIT_FOR_READY_188                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000101E                 TRUE     2654mmm     IFEQ DEBUG
0000101E  1639 00C00003           2655mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001024  0803 0002               2656mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001028  67F4                    2657mmm         BEQ WAIT_FOR_READY_188                      ; NO SPACE, CHECK AGAIN
0000102A  13DA 00C00007           2658mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001030                          2659mmm     ENDC
00001030                          2660mmm 
00001030                 FALSE    2661mmm     IFNE DEBUG
00001030                          2662mmm     ENDC
00001030                          2663mmm 
00001030                          2664mmm     ENDM
00001030  60E4                    2665mm     BRA LOOP_187
00001032                          2666mm EXIT_187
00001032                          2667mm     ENDM
00001032                          2668m     ENDM
00001032                          2669  
00001032                          2670      WHILE D0 <GT> #0 DO
00001032                          2671s _10000014
00001032  B07C 0000               2672s     CMP.W   #0,D0
00001036  6F00 001C               2673s     BLE _10000015
0000103A  5580                    2674          SUB.L #2,D0
0000103C                          2675  
0000103C  13D1 00E00001           2676          MOVE.B (A1),DISPLAY
00001042                          2677m         PROGRAM (A1),(A0),D2
00001042  3091                    2678m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001044                          2679m 
00001044                          2680m WAIT_FOR_COMPLETE_189
00001044  3410                    2681m         MOVE.W (A0),D2
00001046                          2682m 
00001046                          2683m         IF.W D2 <NE> (A1) THEN
00001046  B451                    2684ms     CMP.W   (A1),D2
00001048  6700 0004               2685ms     BEQ _0000000E
0000104C  60F6                    2686m             BRA WAIT_FOR_COMPLETE_189
0000104E                          2687m         ENDI
0000104E                          2688ms _0000000E
0000104E                          2689m         ENDM
0000104E                          2690                  
0000104E  5488                    2691          ADD.L #2,A0
00001050  5489                    2692          ADD.L #2,A1
00001052                          2693      ENDW
00001052  60DE                    2694s     BRA _10000014
00001054                          2695s _10000015
00001054                          2696      
00001054  41F8 0000               2697      LEA STACK,A0
00001058  D1CC                    2698      ADD.L A4,A0
0000105A  2010                    2699      MOVE.L (A0),D0
0000105C                          2700      
0000105C  207C 00000000           2701      MOVE.L #0,A0
00001062                          2702m     PROGRAM_VECTOR D0,A0,D2
00001062  5488                    2703m     ADD.L #2,A0
00001064                          2704mm     PROGRAM D0, (A0), D2                                ; WRITE IT
00001064  3080                    2705mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001066                          2706mm 
00001066                          2707mm WAIT_FOR_COMPLETE_191
00001066  3410                    2708mm         MOVE.W (A0),D2
00001068                          2709mm 
00001068                          2710mm         IF.W D2 <NE> D0 THEN
00001068  B440                    2711mms     CMP.W   D0,D2
0000106A  6700 0004               2712mms     BEQ _0000000F
0000106E  60F6                    2713mm             BRA WAIT_FOR_COMPLETE_191
00001070                          2714mm         ENDI
00001070                          2715mms _0000000F
00001070                          2716mm         ENDM
00001070  E088                    2717m     LSR.L #8,D0
00001072  E088                    2718m     LSR.L #8,D0
00001074  5588                    2719m     SUB.L #2,A0
00001076                          2720mm     PROGRAM D0, (A0), D2
00001076  3080                    2721mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001078                          2722mm 
00001078                          2723mm WAIT_FOR_COMPLETE_192
00001078  3410                    2724mm         MOVE.W (A0),D2
0000107A                          2725mm 
0000107A                          2726mm         IF.W D2 <NE> D0 THEN
0000107A  B440                    2727mms     CMP.W   D0,D2
0000107C  6700 0004               2728mms     BEQ _00000010
00001080  60F6                    2729mm             BRA WAIT_FOR_COMPLETE_192
00001082                          2730mm         ENDI
00001082                          2731mms _00000010
00001082                          2732mm         ENDM
00001082                          2733m     ENDM
00001082                          2734      
00001082                          2735      FOR A0 = #RESET TO #START-4 BY #4 DO
00001082  307C 0004               2736s     MOVE.W  #RESET,A0
00001086  6000 0034               2737s     BRA _2000000F
0000108A                          2738s _2000000E
0000108A                          2739  
0000108A  2248                    2740          MOVE.L A0,A1
0000108C  D3CC                    2741          ADD.L A4,A1
0000108E                          2742              
0000108E  2011                    2743          MOVE.L (A1),D0  
00001090  D081                    2744          ADD.L D1,D0
00001092  0480 00000104           2745          SUB.L #START,D0
00001098                          2746  
00001098  2408                    2747          MOVE.L A0,D2
0000109A                          2748          
0000109A                          2749m         PROGRAM_VECTOR D0,A0,D2
0000109A  5488                    2750m     ADD.L #2,A0
0000109C                          2751mm     PROGRAM D0, (A0), D2                                ; WRITE IT
0000109C  3080                    2752mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000109E                          2753mm 
0000109E                          2754mm WAIT_FOR_COMPLETE_194
0000109E  3410                    2755mm         MOVE.W (A0),D2
000010A0                          2756mm 
000010A0                          2757mm         IF.W D2 <NE> D0 THEN
000010A0  B440                    2758mms     CMP.W   D0,D2
000010A2  6700 0004               2759mms     BEQ _00000011
000010A6  60F6                    2760mm             BRA WAIT_FOR_COMPLETE_194
000010A8                          2761mm         ENDI
000010A8                          2762mms _00000011
000010A8                          2763mm         ENDM
000010A8  E088                    2764m     LSR.L #8,D0
000010AA  E088                    2765m     LSR.L #8,D0
000010AC  5588                    2766m     SUB.L #2,A0
000010AE                          2767mm     PROGRAM D0, (A0), D2
000010AE  3080                    2768mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000010B0                          2769mm 
000010B0                          2770mm WAIT_FOR_COMPLETE_195
000010B0  3410                    2771mm         MOVE.W (A0),D2
000010B2                          2772mm 
000010B2                          2773mm         IF.W D2 <NE> D0 THEN
000010B2  B440                    2774mms     CMP.W   D0,D2
000010B4  6700 0004               2775mms     BEQ _00000012
000010B8  60F6                    2776mm             BRA WAIT_FOR_COMPLETE_195
000010BA                          2777mm         ENDI
000010BA                          2778mms _00000012
000010BA                          2779mm         ENDM
000010BA                          2780m     ENDM
000010BA                          2781      ENDF
000010BA  5848                    2782s     ADD.W   #4,A0
000010BC                          2783s _2000000F
000010BC  B0FC 0100               2784s     CMP.W   #START-4,A0
000010C0  6FC8                    2785s     BLE _2000000E
000010C2                          2786                                          
000010C2                          2787m     PROTECT
000010C2  31FC AAAA 2AAA          2788m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000010C8  31FC 5555 1554          2789m     MOVE.W #$5555,$1554
000010CE  31FC A0A0 2AAA          2790m     MOVE.W #$A0A0,$2AAA
000010D4                          2791m     ENDM
000010D4                          2792  
000010D4  6000 F246               2793      BRA MAIN_LOOP
000010D8                          2794      
000010D8                          2795  P
000010D8  7000                    2796      MOVE.L #0,D0                                    ; D0 will be the data to write
000010DA                          2797  
000010DA                          2798      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000010DA  323C 0000               2799s     MOVE.W  #0,D1
000010DE  6000 0046               2800s     BRA _20000011
000010E2                          2801s _20000010
000010E2  E988                    2802          LSL.L #4,D0                             ; make what we have so far more significant
000010E4                          2803m         WAIT_CHAR D2,D3                         ; next character -> D2
000010E4                          2804m WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010E4                 TRUE     2805m     IFEQ DEBUG
000010E4  1639 00C00003           2806m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000010EA  0803 0000               2807m         BTST #0,D3                                  ; CHECK FOR CHARACTER
000010EE  67F4                    2808m         BEQ WAIT_FOR_READY_197                      ; NOTHING, CHECK AGAIN
000010F0                          2809m     ENDC
000010F0                          2810m 
000010F0                          2811mm     READ_CHAR D2
000010F0                 TRUE     2812mm     IFEQ DEBUG
000010F0  1439 00C00007           2813mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
000010F6                          2814mm     ENDC
000010F6                 FALSE    2815mm     IFNE DEBUG
000010F6                          2816mm     ENDC
000010F6                          2817mm 
000010F6  B43C 001B               2818mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
000010FA  6700 F008               2819mm     BEQ START
000010FE                          2820mm     ENDM
000010FE                          2821m 
000010FE                 TRUE     2822m     IFEQ DEBUG
000010FE                          2823mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
000010FE                          2824mm WAIT_FOR_READY_199                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010FE                 TRUE     2825mm     IFEQ DEBUG
000010FE  1639 00C00003           2826mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001104  0803 0002               2827mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001108  67F4                    2828mm         BEQ WAIT_FOR_READY_199                      ; NO SPACE, CHECK AGAIN
0000110A  13C2 00C00007           2829mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001110                          2830mm     ENDC
00001110                          2831mm 
00001110                 FALSE    2832mm     IFNE DEBUG
00001110                          2833mm     ENDC
00001110                          2834mm 
00001110                          2835mm     ENDM
00001110                          2836m     ENDC
00001110                          2837m     ENDM
00001110                          2838m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001110  41FA 06B9               2839m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001114  0402 0030               2840m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001118  C4BC 000000FF           2841m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000111E  1430 2000               2842m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001122                          2843m     ENDM
00001122  8002                    2844          OR.B D2,D0
00001124                          2845      ENDF
00001124  5241                    2846s     ADD.W   #1,D1
00001126                          2847s _20000011
00001126  B27C 0003               2848s     CMP.W   #3,D1
0000112A  6FB6                    2849s     BLE _20000010
0000112C                          2850  
0000112C                          2851m     PRINT_CRLF D2,A1
0000112C  43FA 06C8               2852m     LEA CRLF(PC),A1
00001130                          2853mm     PRINT_STR A1,D2
00001130                          2854mm LOOP_202
00001130  0C11 0000               2855mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001134  6700 0016               2856mm     BEQ EXIT_202
00001138                          2857mmm     PRINT_CHAR (A1)+,D2
00001138                          2858mmm WAIT_FOR_READY_203                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001138                 TRUE     2859mmm     IFEQ DEBUG
00001138  1439 00C00003           2860mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000113E  0802 0002               2861mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001142  67F4                    2862mmm         BEQ WAIT_FOR_READY_203                      ; NO SPACE, CHECK AGAIN
00001144  13D9 00C00007           2863mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000114A                          2864mmm     ENDC
0000114A                          2865mmm 
0000114A                 FALSE    2866mmm     IFNE DEBUG
0000114A                          2867mmm     ENDC
0000114A                          2868mmm 
0000114A                          2869mmm     ENDM
0000114A  60E4                    2870mm     BRA LOOP_202
0000114C                          2871mm EXIT_202
0000114C                          2872mm     ENDM
0000114C                          2873m     ENDM
0000114C                          2874  
0000114C  2047                    2875      MOVE.L D7,A0                                    ; address accumulator -> target address register
0000114E  7E00                    2876      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001150                          2877  
00001150                          2878m     UNPROTECT                                   ; important to only unprotect when we are fully committed (ie, can't escape)
00001150  31FC AAAA 2AAA          2879m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
00001156  4E71                    2880m     NOP
00001158  31FC 5555 1554          2881m     MOVE.W #$5555,$1554
0000115E  4E71                    2882m     NOP
00001160  31FC 8080 2AAA          2883m     MOVE.W #$8080,$2AAA
00001166  4E71                    2884m     NOP
00001168  31FC AAAA 2AAA          2885m     MOVE.W #$AAAA,$2AAA
0000116E  4E71                    2886m     NOP
00001170  31FC 5555 1554          2887m     MOVE.W #$5555,$1554
00001176  4E71                    2888m     NOP
00001178  31FC 2020 2AAA          2889m     MOVE.W #$2020,$2AAA
0000117E                          2890m     ENDM
0000117E                          2891                              
0000117E                          2892      FOR D7 = #$0 TO #$FFFFFFFF DO               ; dead timing loop to wait for unprotect
0000117E  3E3C 0000               2893s     MOVE.W  #$0,D7
00001182  6000 0006               2894s     BRA _20000013
00001186                          2895s _20000012
00001186  4E71                    2896          NOP
00001188                          2897      ENDF
00001188  5247                    2898s     ADD.W   #1,D7
0000118A                          2899s _20000013
0000118A  BE7C FFFF               2900s     CMP.W   #$FFFFFFFF,D7
0000118E  6FF6                    2901s     BLE _20000012
00001190                          2902               
00001190  45FA 0650               2903      LEA LOADING(PC),A2                          ; the prints seem to be important for timing to unprotect the EEPROM
00001194                          2904m     PRINT_STR A2,D2
00001194                          2905m LOOP_205
00001194  0C12 0000               2906m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001198  6700 0016               2907m     BEQ EXIT_205
0000119C                          2908mm     PRINT_CHAR (A2)+,D2
0000119C                          2909mm WAIT_FOR_READY_206                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000119C                 TRUE     2910mm     IFEQ DEBUG
0000119C  1439 00C00003           2911mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000011A2  0802 0002               2912mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000011A6  67F4                    2913mm         BEQ WAIT_FOR_READY_206                      ; NO SPACE, CHECK AGAIN
000011A8  13DA 00C00007           2914mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011AE                          2915mm     ENDC
000011AE                          2916mm 
000011AE                 FALSE    2917mm     IFNE DEBUG
000011AE                          2918mm     ENDC
000011AE                          2919mm 
000011AE                          2920mm     ENDM
000011AE  60E4                    2921m     BRA LOOP_205
000011B0                          2922m EXIT_205
000011B0                          2923m     ENDM
000011B0                          2924  
000011B0                          2925m     PRINT_REG D0,D3,D4,D5,A2
000011B0  45FA 064A               2926m     LEA OX(PC),A2
000011B4                          2927mm     PRINT_STR A2,D3
000011B4                          2928mm LOOP_208
000011B4  0C12 0000               2929mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011B8  6700 0016               2930mm     BEQ EXIT_208
000011BC                          2931mmm     PRINT_CHAR (A2)+,D3
000011BC                          2932mmm WAIT_FOR_READY_209                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011BC                 TRUE     2933mmm     IFEQ DEBUG
000011BC  1639 00C00003           2934mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011C2  0803 0002               2935mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011C6  67F4                    2936mmm         BEQ WAIT_FOR_READY_209                      ; NO SPACE, CHECK AGAIN
000011C8  13DA 00C00007           2937mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011CE                          2938mmm     ENDC
000011CE                          2939mmm 
000011CE                 FALSE    2940mmm     IFNE DEBUG
000011CE                          2941mmm     ENDC
000011CE                          2942mmm 
000011CE                          2943mmm     ENDM
000011CE  60E4                    2944mm     BRA LOOP_208
000011D0                          2945mm EXIT_208
000011D0                          2946mm     ENDM
000011D0  7A07                    2947m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000011D2                          2948m LOOP_207
000011D2                          2949mm     BIN2HEX D0,D4,A2
000011D2  45FA 05E7               2950mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000011D6  E998                    2951mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011D8  1800                    2952mm     MOVE.B D0,D4
000011DA  0284 0000000F           2953mm     ANDI.L #$F,D4
000011E0  1832 4000               2954mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011E4                          2955mm     ENDM
000011E4                          2956mm     PRINT_CHAR D4,D3
000011E4                          2957mm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011E4                 TRUE     2958mm     IFEQ DEBUG
000011E4  1639 00C00003           2959mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011EA  0803 0002               2960mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011EE  67F4                    2961mm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
000011F0  13C4 00C00007           2962mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011F6                          2963mm     ENDC
000011F6                          2964mm 
000011F6                 FALSE    2965mm     IFNE DEBUG
000011F6                          2966mm     ENDC
000011F6                          2967mm 
000011F6                          2968mm     ENDM
000011F6  57CD FFDA               2969m     DBEQ D5,LOOP_207
000011FA                          2970m     ENDM
000011FA                          2971  
000011FA  45FA 0603               2972      LEA TO(PC),A2
000011FE                          2973m     PRINT_STR A2,D3
000011FE                          2974m LOOP_212
000011FE  0C12 0000               2975m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001202  6700 0016               2976m     BEQ EXIT_212
00001206                          2977mm     PRINT_CHAR (A2)+,D3
00001206                          2978mm WAIT_FOR_READY_213                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001206                 TRUE     2979mm     IFEQ DEBUG
00001206  1639 00C00003           2980mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000120C  0803 0002               2981mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001210  67F4                    2982mm         BEQ WAIT_FOR_READY_213                      ; NO SPACE, CHECK AGAIN
00001212  13DA 00C00007           2983mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001218                          2984mm     ENDC
00001218                          2985mm 
00001218                 FALSE    2986mm     IFNE DEBUG
00001218                          2987mm     ENDC
00001218                          2988mm 
00001218                          2989mm     ENDM
00001218  60E4                    2990m     BRA LOOP_212
0000121A                          2991m EXIT_212
0000121A                          2992m     ENDM
0000121A                          2993  
0000121A  2408                    2994      MOVE.L A0,D2
0000121C                          2995m     PRINT_REG D2,D3,D4,D5,A2
0000121C  45FA 05DE               2996m     LEA OX(PC),A2
00001220                          2997mm     PRINT_STR A2,D3
00001220                          2998mm LOOP_215
00001220  0C12 0000               2999mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001224  6700 0016               3000mm     BEQ EXIT_215
00001228                          3001mmm     PRINT_CHAR (A2)+,D3
00001228                          3002mmm WAIT_FOR_READY_216                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001228                 TRUE     3003mmm     IFEQ DEBUG
00001228  1639 00C00003           3004mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000122E  0803 0002               3005mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001232  67F4                    3006mmm         BEQ WAIT_FOR_READY_216                      ; NO SPACE, CHECK AGAIN
00001234  13DA 00C00007           3007mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000123A                          3008mmm     ENDC
0000123A                          3009mmm 
0000123A                 FALSE    3010mmm     IFNE DEBUG
0000123A                          3011mmm     ENDC
0000123A                          3012mmm 
0000123A                          3013mmm     ENDM
0000123A  60E4                    3014mm     BRA LOOP_215
0000123C                          3015mm EXIT_215
0000123C                          3016mm     ENDM
0000123C  7A07                    3017m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000123E                          3018m LOOP_214
0000123E                          3019mm     BIN2HEX D2,D4,A2
0000123E  45FA 057B               3020mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001242  E99A                    3021mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001244  1802                    3022mm     MOVE.B D2,D4
00001246  0284 0000000F           3023mm     ANDI.L #$F,D4
0000124C  1832 4000               3024mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001250                          3025mm     ENDM
00001250                          3026mm     PRINT_CHAR D4,D3
00001250                          3027mm WAIT_FOR_READY_218                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001250                 TRUE     3028mm     IFEQ DEBUG
00001250  1639 00C00003           3029mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001256  0803 0002               3030mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000125A  67F4                    3031mm         BEQ WAIT_FOR_READY_218                      ; NO SPACE, CHECK AGAIN
0000125C  13C4 00C00007           3032mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001262                          3033mm     ENDC
00001262                          3034mm 
00001262                 FALSE    3035mm     IFNE DEBUG
00001262                          3036mm     ENDC
00001262                          3037mm 
00001262                          3038mm     ENDM
00001262  57CD FFDA               3039m     DBEQ D5,LOOP_214
00001266                          3040m     ENDM
00001266                          3041  
00001266                          3042m     PRINT_CRLF D3,A2
00001266  45FA 058E               3043m     LEA CRLF(PC),A2
0000126A                          3044mm     PRINT_STR A2,D3
0000126A                          3045mm LOOP_220
0000126A  0C12 0000               3046mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000126E  6700 0016               3047mm     BEQ EXIT_220
00001272                          3048mmm     PRINT_CHAR (A2)+,D3
00001272                          3049mmm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001272                 TRUE     3050mmm     IFEQ DEBUG
00001272  1639 00C00003           3051mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001278  0803 0002               3052mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000127C  67F4                    3053mmm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
0000127E  13DA 00C00007           3054mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001284                          3055mmm     ENDC
00001284                          3056mmm 
00001284                 FALSE    3057mmm     IFNE DEBUG
00001284                          3058mmm     ENDC
00001284                          3059mmm 
00001284                          3060mmm     ENDM
00001284  60E4                    3061mm     BRA LOOP_220
00001286                          3062mm EXIT_220
00001286                          3063mm     ENDM
00001286                          3064m     ENDM
00001286                          3065  
00001286                          3066m     PROGRAM D0,(A0),D2
00001286  3080                    3067m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
00001288                          3068m 
00001288                          3069m WAIT_FOR_COMPLETE_222
00001288  3410                    3070m         MOVE.W (A0),D2
0000128A                          3071m 
0000128A                          3072m         IF.W D2 <NE> D0 THEN
0000128A  B440                    3073ms     CMP.W   D0,D2
0000128C  6700 0004               3074ms     BEQ _00000013
00001290  60F6                    3075m             BRA WAIT_FOR_COMPLETE_222
00001292                          3076m         ENDI
00001292                          3077ms _00000013
00001292                          3078m         ENDM
00001292                          3079  
00001292                          3080m     PROTECT
00001292  31FC AAAA 2AAA          3081m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
00001298  31FC 5555 1554          3082m     MOVE.W #$5555,$1554
0000129E  31FC A0A0 2AAA          3083m     MOVE.W #$A0A0,$2AAA
000012A4                          3084m     ENDM
000012A4                          3085  
000012A4  6000 F076               3086      BRA MAIN_LOOP
000012A8                          3087      
000012A8                          3088  X
000012A8  45FA 0565               3089      LEA STATUS_REGISTER(PC),A2
000012AC                          3090m     PRINT_STR A2,D3
000012AC                          3091m LOOP_224
000012AC  0C12 0000               3092m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012B0  6700 0016               3093m     BEQ EXIT_224
000012B4                          3094mm     PRINT_CHAR (A2)+,D3
000012B4                          3095mm WAIT_FOR_READY_225                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012B4                 TRUE     3096mm     IFEQ DEBUG
000012B4  1639 00C00003           3097mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012BA  0803 0002               3098mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012BE  67F4                    3099mm         BEQ WAIT_FOR_READY_225                      ; NO SPACE, CHECK AGAIN
000012C0  13DA 00C00007           3100mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012C6                          3101mm     ENDC
000012C6                          3102mm 
000012C6                 FALSE    3103mm     IFNE DEBUG
000012C6                          3104mm     ENDC
000012C6                          3105mm 
000012C6                          3106mm     ENDM
000012C6  60E4                    3107m     BRA LOOP_224
000012C8                          3108m EXIT_224
000012C8                          3109m     ENDM
000012C8                          3110  
000012C8  40C0                    3111      MOVE SR,D0
000012CA                          3112m     PRINT_REG D0,D3,D4,D5,A2
000012CA  45FA 0530               3113m     LEA OX(PC),A2
000012CE                          3114mm     PRINT_STR A2,D3
000012CE                          3115mm LOOP_227
000012CE  0C12 0000               3116mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000012D2  6700 0016               3117mm     BEQ EXIT_227
000012D6                          3118mmm     PRINT_CHAR (A2)+,D3
000012D6                          3119mmm WAIT_FOR_READY_228                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012D6                 TRUE     3120mmm     IFEQ DEBUG
000012D6  1639 00C00003           3121mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000012DC  0803 0002               3122mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000012E0  67F4                    3123mmm         BEQ WAIT_FOR_READY_228                      ; NO SPACE, CHECK AGAIN
000012E2  13DA 00C00007           3124mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012E8                          3125mmm     ENDC
000012E8                          3126mmm 
000012E8                 FALSE    3127mmm     IFNE DEBUG
000012E8                          3128mmm     ENDC
000012E8                          3129mmm 
000012E8                          3130mmm     ENDM
000012E8  60E4                    3131mm     BRA LOOP_227
000012EA                          3132mm EXIT_227
000012EA                          3133mm     ENDM
000012EA  7A07                    3134m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012EC                          3135m LOOP_226
000012EC                          3136mm     BIN2HEX D0,D4,A2
000012EC  45FA 04CD               3137mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000012F0  E998                    3138mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012F2  1800                    3139mm     MOVE.B D0,D4
000012F4  0284 0000000F           3140mm     ANDI.L #$F,D4
000012FA  1832 4000               3141mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000012FE                          3142mm     ENDM
000012FE                          3143mm     PRINT_CHAR D4,D3
000012FE                          3144mm WAIT_FOR_READY_230                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012FE                 TRUE     3145mm     IFEQ DEBUG
000012FE  1639 00C00003           3146mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001304  0803 0002               3147mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001308  67F4                    3148mm         BEQ WAIT_FOR_READY_230                      ; NO SPACE, CHECK AGAIN
0000130A  13C4 00C00007           3149mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001310                          3150mm     ENDC
00001310                          3151mm 
00001310                 FALSE    3152mm     IFNE DEBUG
00001310                          3153mm     ENDC
00001310                          3154mm 
00001310                          3155mm     ENDM
00001310  57CD FFDA               3156m     DBEQ D5,LOOP_226
00001314                          3157m     ENDM
00001314                          3158m     PRINT_CRLF D3,A2
00001314  45FA 04E0               3159m     LEA CRLF(PC),A2
00001318                          3160mm     PRINT_STR A2,D3
00001318                          3161mm LOOP_232
00001318  0C12 0000               3162mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000131C  6700 0016               3163mm     BEQ EXIT_232
00001320                          3164mmm     PRINT_CHAR (A2)+,D3
00001320                          3165mmm WAIT_FOR_READY_233                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001320                 TRUE     3166mmm     IFEQ DEBUG
00001320  1639 00C00003           3167mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001326  0803 0002               3168mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000132A  67F4                    3169mmm         BEQ WAIT_FOR_READY_233                      ; NO SPACE, CHECK AGAIN
0000132C  13DA 00C00007           3170mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001332                          3171mmm     ENDC
00001332                          3172mmm 
00001332                 FALSE    3173mmm     IFNE DEBUG
00001332                          3174mmm     ENDC
00001332                          3175mmm 
00001332                          3176mmm     ENDM
00001332  60E4                    3177mm     BRA LOOP_232
00001334                          3178mm EXIT_232
00001334                          3179mm     ENDM
00001334                          3180m     ENDM
00001334                          3181  
00001334  45FA 04D4               3182      LEA STACK_POINTER(PC),A2
00001338                          3183m     PRINT_STR A2,D3
00001338                          3184m LOOP_234
00001338  0C12 0000               3185m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000133C  6700 0016               3186m     BEQ EXIT_234
00001340                          3187mm     PRINT_CHAR (A2)+,D3
00001340                          3188mm WAIT_FOR_READY_235                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001340                 TRUE     3189mm     IFEQ DEBUG
00001340  1639 00C00003           3190mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001346  0803 0002               3191mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000134A  67F4                    3192mm         BEQ WAIT_FOR_READY_235                      ; NO SPACE, CHECK AGAIN
0000134C  13DA 00C00007           3193mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001352                          3194mm     ENDC
00001352                          3195mm 
00001352                 FALSE    3196mm     IFNE DEBUG
00001352                          3197mm     ENDC
00001352                          3198mm 
00001352                          3199mm     ENDM
00001352  60E4                    3200m     BRA LOOP_234
00001354                          3201m EXIT_234
00001354                          3202m     ENDM
00001354                          3203  
00001354  200F                    3204      MOVE.L SP,D0
00001356                          3205m     PRINT_REG D0,D3,D4,D5,A2
00001356  45FA 04A4               3206m     LEA OX(PC),A2
0000135A                          3207mm     PRINT_STR A2,D3
0000135A                          3208mm LOOP_237
0000135A  0C12 0000               3209mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000135E  6700 0016               3210mm     BEQ EXIT_237
00001362                          3211mmm     PRINT_CHAR (A2)+,D3
00001362                          3212mmm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001362                 TRUE     3213mmm     IFEQ DEBUG
00001362  1639 00C00003           3214mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001368  0803 0002               3215mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000136C  67F4                    3216mmm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
0000136E  13DA 00C00007           3217mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001374                          3218mmm     ENDC
00001374                          3219mmm 
00001374                 FALSE    3220mmm     IFNE DEBUG
00001374                          3221mmm     ENDC
00001374                          3222mmm 
00001374                          3223mmm     ENDM
00001374  60E4                    3224mm     BRA LOOP_237
00001376                          3225mm EXIT_237
00001376                          3226mm     ENDM
00001376  7A07                    3227m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001378                          3228m LOOP_236
00001378                          3229mm     BIN2HEX D0,D4,A2
00001378  45FA 0441               3230mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000137C  E998                    3231mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000137E  1800                    3232mm     MOVE.B D0,D4
00001380  0284 0000000F           3233mm     ANDI.L #$F,D4
00001386  1832 4000               3234mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000138A                          3235mm     ENDM
0000138A                          3236mm     PRINT_CHAR D4,D3
0000138A                          3237mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000138A                 TRUE     3238mm     IFEQ DEBUG
0000138A  1639 00C00003           3239mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001390  0803 0002               3240mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001394  67F4                    3241mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
00001396  13C4 00C00007           3242mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000139C                          3243mm     ENDC
0000139C                          3244mm 
0000139C                 FALSE    3245mm     IFNE DEBUG
0000139C                          3246mm     ENDC
0000139C                          3247mm 
0000139C                          3248mm     ENDM
0000139C  57CD FFDA               3249m     DBEQ D5,LOOP_236
000013A0                          3250m     ENDM
000013A0                          3251m     PRINT_CRLF D3,A2
000013A0  45FA 0454               3252m     LEA CRLF(PC),A2
000013A4                          3253mm     PRINT_STR A2,D3
000013A4                          3254mm LOOP_242
000013A4  0C12 0000               3255mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000013A8  6700 0016               3256mm     BEQ EXIT_242
000013AC                          3257mmm     PRINT_CHAR (A2)+,D3
000013AC                          3258mmm WAIT_FOR_READY_243                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013AC                 TRUE     3259mmm     IFEQ DEBUG
000013AC  1639 00C00003           3260mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000013B2  0803 0002               3261mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000013B6  67F4                    3262mmm         BEQ WAIT_FOR_READY_243                      ; NO SPACE, CHECK AGAIN
000013B8  13DA 00C00007           3263mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013BE                          3264mmm     ENDC
000013BE                          3265mmm 
000013BE                 FALSE    3266mmm     IFNE DEBUG
000013BE                          3267mmm     ENDC
000013BE                          3268mmm 
000013BE                          3269mmm     ENDM
000013BE  60E4                    3270mm     BRA LOOP_242
000013C0                          3271mm EXIT_242
000013C0                          3272mm     ENDM
000013C0                          3273m     ENDM
000013C0                          3274  
000013C0  6000 EF5A               3275      BRA MAIN_LOOP
000013C4                          3276  
000013C4                          3277          
000013C4                          3278  I
000013C4  13FC 0008 00C0000B      3279      MOVE.B #8,DUART_IMR
000013CC  027C F8FF               3280      AND.W #$F8FF,SR
000013D0  6000 EF4A               3281      BRA MAIN_LOOP
000013D4                          3282      
000013D4                          3283  O
000013D4  13FC 0000 00C0000B      3284      MOVE.B #0,DUART_IMR
000013DC  007C 0700               3285      OR.W #$0700,SR
000013E0  6000 EF3A               3286      BRA MAIN_LOOP
000013E4                          3287          
000013E4                          3288  HASH
000013E4                          3289m     PROTECT
000013E4  31FC AAAA 2AAA          3290m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000013EA  31FC 5555 1554          3291m     MOVE.W #$5555,$1554
000013F0  31FC A0A0 2AAA          3292m     MOVE.W #$A0A0,$2AAA
000013F6                          3293m     ENDM
000013F6  6000 EF24               3294      BRA MAIN_LOOP
000013FA                          3295  
000013FA                          3296  
000013FA                          3297  
000013FA                          3298  HEX_DIGIT
000013FA  E98F                    3299      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
000013FC                          3300m     HEX2BIN D2,D2,A0
000013FC  41FA 03CD               3301m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001400  0402 0030               3302m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001404  C4BC 000000FF           3303m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
0000140A  1430 2000               3304m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000140E                          3305m     ENDM
0000140E  8E02                    3306      OR.B D2,D7  
00001410  6000 EF2A               3307      BRA GET_INPUT
00001414                          3308  
00001414  FFFF FFFF               3309      SIMHALT                                             ; halt simulator
00001418                          3310  
00001418                          3311  ; exceptions    
00001418                          3312  BUS_ERROR_HANDLER
00001418                          3313  
00001418  41FA 0401               3314      LEA BUS_ERROR(PC),A0
0000141C                          3315m     PRINT_STR A0,D1
0000141C                          3316m LOOP_246
0000141C  0C10 0000               3317m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001420  6700 0016               3318m     BEQ EXIT_246
00001424                          3319mm     PRINT_CHAR (A0)+,D1
00001424                          3320mm WAIT_FOR_READY_247                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001424                 TRUE     3321mm     IFEQ DEBUG
00001424  1239 00C00003           3322mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000142A  0801 0002               3323mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000142E  67F4                    3324mm         BEQ WAIT_FOR_READY_247                      ; NO SPACE, CHECK AGAIN
00001430  13D8 00C00007           3325mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001436                          3326mm     ENDC
00001436                          3327mm 
00001436                 FALSE    3328mm     IFNE DEBUG
00001436                          3329mm     ENDC
00001436                          3330mm 
00001436                          3331mm     ENDM
00001436  60E4                    3332m     BRA LOOP_246
00001438                          3333m EXIT_246
00001438                          3334m     ENDM
00001438                          3335  
00001438  7000                    3336      MOVE.L #0,D0
0000143A  3017                    3337      MOVE.W (SP),D0
0000143C                          3338  
0000143C  0800 0004               3339      BTST #4,D0
00001440  6700 0026               3340      BEQ WRITE
00001444                          3341      
00001444  41FA 03EA               3342      LEA READING(PC),A0
00001448                          3343m     PRINT_STR A0,D1
00001448                          3344m LOOP_248
00001448  0C10 0000               3345m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000144C  6700 0016               3346m     BEQ EXIT_248
00001450                          3347mm     PRINT_CHAR (A0)+,D1
00001450                          3348mm WAIT_FOR_READY_249                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001450                 TRUE     3349mm     IFEQ DEBUG
00001450  1239 00C00003           3350mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001456  0801 0002               3351mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000145A  67F4                    3352mm         BEQ WAIT_FOR_READY_249                      ; NO SPACE, CHECK AGAIN
0000145C  13D8 00C00007           3353mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001462                          3354mm     ENDC
00001462                          3355mm 
00001462                 FALSE    3356mm     IFNE DEBUG
00001462                          3357mm     ENDC
00001462                          3358mm 
00001462                          3359mm     ENDM
00001462  60E4                    3360m     BRA LOOP_248
00001464                          3361m EXIT_248
00001464                          3362m     ENDM
00001464                          3363  
00001464  6000 0022               3364      BRA CONTINUE    
00001468                          3365  WRITE
00001468  41FA 03CF               3366      LEA WRITING(PC),A0
0000146C                          3367m     PRINT_STR A0,D1
0000146C                          3368m LOOP_250
0000146C  0C10 0000               3369m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001470  6700 0016               3370m     BEQ EXIT_250
00001474                          3371mm     PRINT_CHAR (A0)+,D1
00001474                          3372mm WAIT_FOR_READY_251                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001474                 TRUE     3373mm     IFEQ DEBUG
00001474  1239 00C00003           3374mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000147A  0801 0002               3375mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000147E  67F4                    3376mm         BEQ WAIT_FOR_READY_251                      ; NO SPACE, CHECK AGAIN
00001480  13D8 00C00007           3377mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001486                          3378mm     ENDC
00001486                          3379mm 
00001486                 FALSE    3380mm     IFNE DEBUG
00001486                          3381mm     ENDC
00001486                          3382mm 
00001486                          3383mm     ENDM
00001486  60E4                    3384m     BRA LOOP_250
00001488                          3385m EXIT_250
00001488                          3386m     ENDM
00001488                          3387  
00001488                          3388  CONTINUE
00001488  222F 0002               3389      MOVE.L 2(SP),D1
0000148C                          3390m     PRINT_REG D1,D2,D3,D4,A0
0000148C  41FA 036E               3391m     LEA OX(PC),A0
00001490                          3392mm     PRINT_STR A0,D2
00001490                          3393mm LOOP_253
00001490  0C10 0000               3394mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001494  6700 0016               3395mm     BEQ EXIT_253
00001498                          3396mmm     PRINT_CHAR (A0)+,D2
00001498                          3397mmm WAIT_FOR_READY_254                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001498                 TRUE     3398mmm     IFEQ DEBUG
00001498  1439 00C00003           3399mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000149E  0802 0002               3400mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014A2  67F4                    3401mmm         BEQ WAIT_FOR_READY_254                      ; NO SPACE, CHECK AGAIN
000014A4  13D8 00C00007           3402mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014AA                          3403mmm     ENDC
000014AA                          3404mmm 
000014AA                 FALSE    3405mmm     IFNE DEBUG
000014AA                          3406mmm     ENDC
000014AA                          3407mmm 
000014AA                          3408mmm     ENDM
000014AA  60E4                    3409mm     BRA LOOP_253
000014AC                          3410mm EXIT_253
000014AC                          3411mm     ENDM
000014AC  7807                    3412m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014AE                          3413m LOOP_252
000014AE                          3414mm     BIN2HEX D1,D3,A0
000014AE  41FA 030B               3415mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000014B2  E999                    3416mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014B4  1601                    3417mm     MOVE.B D1,D3
000014B6  0283 0000000F           3418mm     ANDI.L #$F,D3
000014BC  1630 3000               3419mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000014C0                          3420mm     ENDM
000014C0                          3421mm     PRINT_CHAR D3,D2
000014C0                          3422mm WAIT_FOR_READY_256                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014C0                 TRUE     3423mm     IFEQ DEBUG
000014C0  1439 00C00003           3424mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014C6  0802 0002               3425mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014CA  67F4                    3426mm         BEQ WAIT_FOR_READY_256                      ; NO SPACE, CHECK AGAIN
000014CC  13C3 00C00007           3427mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014D2                          3428mm     ENDC
000014D2                          3429mm 
000014D2                 FALSE    3430mm     IFNE DEBUG
000014D2                          3431mm     ENDC
000014D2                          3432mm 
000014D2                          3433mm     ENDM
000014D2  57CC FFDA               3434m     DBEQ D4,LOOP_252
000014D6                          3435m     ENDM
000014D6                          3436  
000014D6  41FA 036A               3437      LEA FROM(PC),A0
000014DA                          3438m     PRINT_STR A0,D0
000014DA                          3439m LOOP_257
000014DA  0C10 0000               3440m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000014DE  6700 0016               3441m     BEQ EXIT_257
000014E2                          3442mm     PRINT_CHAR (A0)+,D0
000014E2                          3443mm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014E2                 TRUE     3444mm     IFEQ DEBUG
000014E2  1039 00C00003           3445mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000014E8  0800 0002               3446mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000014EC  67F4                    3447mm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
000014EE  13D8 00C00007           3448mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014F4                          3449mm     ENDC
000014F4                          3450mm 
000014F4                 FALSE    3451mm     IFNE DEBUG
000014F4                          3452mm     ENDC
000014F4                          3453mm 
000014F4                          3454mm     ENDM
000014F4  60E4                    3455m     BRA LOOP_257
000014F6                          3456m EXIT_257
000014F6                          3457m     ENDM
000014F6                          3458  
000014F6  222F 000A               3459      MOVE.L 10(SP),D1
000014FA                          3460m     PRINT_REG D1,D2,D3,D4,A0
000014FA  41FA 0300               3461m     LEA OX(PC),A0
000014FE                          3462mm     PRINT_STR A0,D2
000014FE                          3463mm LOOP_260
000014FE  0C10 0000               3464mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001502  6700 0016               3465mm     BEQ EXIT_260
00001506                          3466mmm     PRINT_CHAR (A0)+,D2
00001506                          3467mmm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001506                 TRUE     3468mmm     IFEQ DEBUG
00001506  1439 00C00003           3469mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000150C  0802 0002               3470mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001510  67F4                    3471mmm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
00001512  13D8 00C00007           3472mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001518                          3473mmm     ENDC
00001518                          3474mmm 
00001518                 FALSE    3475mmm     IFNE DEBUG
00001518                          3476mmm     ENDC
00001518                          3477mmm 
00001518                          3478mmm     ENDM
00001518  60E4                    3479mm     BRA LOOP_260
0000151A                          3480mm EXIT_260
0000151A                          3481mm     ENDM
0000151A  7807                    3482m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000151C                          3483m LOOP_259
0000151C                          3484mm     BIN2HEX D1,D3,A0
0000151C  41FA 029D               3485mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001520  E999                    3486mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001522  1601                    3487mm     MOVE.B D1,D3
00001524  0283 0000000F           3488mm     ANDI.L #$F,D3
0000152A  1630 3000               3489mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000152E                          3490mm     ENDM
0000152E                          3491mm     PRINT_CHAR D3,D2
0000152E                          3492mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000152E                 TRUE     3493mm     IFEQ DEBUG
0000152E  1439 00C00003           3494mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001534  0802 0002               3495mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001538  67F4                    3496mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
0000153A  13C3 00C00007           3497mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001540                          3498mm     ENDC
00001540                          3499mm 
00001540                 FALSE    3500mm     IFNE DEBUG
00001540                          3501mm     ENDC
00001540                          3502mm 
00001540                          3503mm     ENDM
00001540  57CC FFDA               3504m     DBEQ D4,LOOP_259
00001544                          3505m     ENDM
00001544                          3506m     PRINT_CRLF D0,A0
00001544  41FA 02B0               3507m     LEA CRLF(PC),A0
00001548                          3508mm     PRINT_STR A0,D0
00001548                          3509mm LOOP_265
00001548  0C10 0000               3510mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000154C  6700 0016               3511mm     BEQ EXIT_265
00001550                          3512mmm     PRINT_CHAR (A0)+,D0
00001550                          3513mmm WAIT_FOR_READY_266                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001550                 TRUE     3514mmm     IFEQ DEBUG
00001550  1039 00C00003           3515mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001556  0800 0002               3516mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
0000155A  67F4                    3517mmm         BEQ WAIT_FOR_READY_266                      ; NO SPACE, CHECK AGAIN
0000155C  13D8 00C00007           3518mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001562                          3519mmm     ENDC
00001562                          3520mmm 
00001562                 FALSE    3521mmm     IFNE DEBUG
00001562                          3522mmm     ENDC
00001562                          3523mmm 
00001562                          3524mmm     ENDM
00001562  60E4                    3525mm     BRA LOOP_265
00001564                          3526mm EXIT_265
00001564                          3527mm     ENDM
00001564                          3528m     ENDM
00001564                          3529      
00001564  207C 00000004           3530      MOVE.L #4,A0
0000156A  4ED0                    3531      JMP (A0)
0000156C                          3532          
0000156C                          3533  ILLEGAL_HANDLER
0000156C  13FC 0007 00E00001      3534      MOVE.B #7,DISPLAY   
00001574                          3535      
00001574  207C 00000004           3536      MOVE.L #4,A0
0000157A  4ED0                    3537      JMP (A0)
0000157C                          3538          
0000157C                          3539  UNHANDLED_HANDLER
0000157C  41FA 02CB               3540      LEA UNHANDLED(PC),A0
00001580                          3541m     PRINT_STR A0,D1
00001580                          3542m LOOP_267
00001580  0C10 0000               3543m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001584  6700 0016               3544m     BEQ EXIT_267
00001588                          3545mm     PRINT_CHAR (A0)+,D1
00001588                          3546mm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001588                 TRUE     3547mm     IFEQ DEBUG
00001588  1239 00C00003           3548mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
0000158E  0801 0002               3549mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001592  67F4                    3550mm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
00001594  13D8 00C00007           3551mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000159A                          3552mm     ENDC
0000159A                          3553mm 
0000159A                 FALSE    3554mm     IFNE DEBUG
0000159A                          3555mm     ENDC
0000159A                          3556mm 
0000159A                          3557mm     ENDM
0000159A  60E4                    3558m     BRA LOOP_267
0000159C                          3559m EXIT_267
0000159C                          3560m     ENDM
0000159C                          3561  
0000159C  4E73                    3562      RTE 
0000159E                          3563      
0000159E                          3564  UNINITIALISED_HANDLER
0000159E  41FA 02BF               3565      LEA UNINITIALISED(PC),A0
000015A2                          3566m     PRINT_STR A0,D1
000015A2                          3567m LOOP_269
000015A2  0C10 0000               3568m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000015A6  6700 0016               3569m     BEQ EXIT_269
000015AA                          3570mm     PRINT_CHAR (A0)+,D1
000015AA                          3571mm WAIT_FOR_READY_270                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015AA                 TRUE     3572mm     IFEQ DEBUG
000015AA  1239 00C00003           3573mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000015B0  0801 0002               3574mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000015B4  67F4                    3575mm         BEQ WAIT_FOR_READY_270                      ; NO SPACE, CHECK AGAIN
000015B6  13D8 00C00007           3576mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015BC                          3577mm     ENDC
000015BC                          3578mm 
000015BC                 FALSE    3579mm     IFNE DEBUG
000015BC                          3580mm     ENDC
000015BC                          3581mm 
000015BC                          3582mm     ENDM
000015BC  60E4                    3583m     BRA LOOP_269
000015BE                          3584m EXIT_269
000015BE                          3585m     ENDM
000015BE                          3586  
000015BE  4E73                    3587      RTE 
000015C0                          3588  
000015C0                          3589  SPURIOUS_HANDLER
000015C0  41FA 02BD               3590      LEA SPURIOUS(PC),A0
000015C4                          3591m     PRINT_STR A0,D1
000015C4                          3592m LOOP_271
000015C4  0C10 0000               3593m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000015C8  6700 0016               3594m     BEQ EXIT_271
000015CC                          3595mm     PRINT_CHAR (A0)+,D1
000015CC                          3596mm WAIT_FOR_READY_272                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015CC                 TRUE     3597mm     IFEQ DEBUG
000015CC  1239 00C00003           3598mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000015D2  0801 0002               3599mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000015D6  67F4                    3600mm         BEQ WAIT_FOR_READY_272                      ; NO SPACE, CHECK AGAIN
000015D8  13D8 00C00007           3601mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000015DE                          3602mm     ENDC
000015DE                          3603mm 
000015DE                 FALSE    3604mm     IFNE DEBUG
000015DE                          3605mm     ENDC
000015DE                          3606mm 
000015DE                          3607mm     ENDM
000015DE  60E4                    3608m     BRA LOOP_271
000015E0                          3609m EXIT_271
000015E0                          3610m     ENDM
000015E0                          3611  
000015E0  4E73                    3612      RTE 
000015E2                          3613      
000015E2                          3614  TICK_HANDLER
000015E2  41FA 0230               3615      LEA TICK(PC),A0
000015E6                          3616m     PRINT_STR A0,D1
000015E6                          3617m LOOP_273
000015E6  0C10 0000               3618m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000015EA  6700 0016               3619m     BEQ EXIT_273
000015EE                          3620mm     PRINT_CHAR (A0)+,D1
000015EE                          3621mm WAIT_FOR_READY_274                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015EE                 TRUE     3622mm     IFEQ DEBUG
000015EE  1239 00C00003           3623mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000015F4  0801 0002               3624mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000015F8  67F4                    3625mm         BEQ WAIT_FOR_READY_274                      ; NO SPACE, CHECK AGAIN
000015FA  13D8 00C00007           3626mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001600                          3627mm     ENDC
00001600                          3628mm 
00001600                 FALSE    3629mm     IFNE DEBUG
00001600                          3630mm     ENDC
00001600                          3631mm 
00001600                          3632mm     ENDM
00001600  60E4                    3633m     BRA LOOP_273
00001602                          3634m EXIT_273
00001602                          3635m     ENDM
00001602                          3636      
00001602  1039 00C0001F           3637      MOVE.B DUART_RESET_OPR,D0
00001608  4E73                    3638      RTE 
0000160A                          3639  
0000160A                          3640  ; strings
0000160A= 50 72 65 73 73 20 ...   3641  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
0000161D= 5B 3F 5D 09 09 09 ...   3642  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001629= 5B 76 5D 09 09 09 ...   3643          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001638= 78 78 78 78 78 78 ...   3644          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00001650= 78 78 78 78 78 78 ...   3645          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00001670= 78 78 78 78 78 78 ...   3646          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00001691= 78 78 78 78 78 78 ...   3647          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
000016A2= 5B 7A 5D 09 09 09 ...   3648          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
000016B4= 78 78 78 78 78 78 ...   3649          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000016D5= 78 78 78 78 78 78 ...   3650          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000016F4= 23 09 09 09 77 72 ...   3651          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
0000170E= 5B 78 5D 09 09 09 ...   3652          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00001725= 5B 69 5D 09 09 09 ...   3653          DC.B '[i]',TAB,TAB,TAB,'enable interrupts',CR,LF
0000173E= 5B 6F 5D 09 09 09 ...   3654          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF,NULL
00001759= 48 75 68 3F 0D 0A 00    3655  HUH  DC.B 'Huh?',CR,LF,NULL
00001760= 20 53 20 72 65 63 ...   3656  READ    DC.B ' S records read, start address = ',NULL
00001782= 57 3A 20 55 6E 6B ...   3657  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001799= 21 20 43 53 20 66 ...   3658  CS_FAILURE  DC.B '! CS failure at ',NULL
000017AA= 21 20 52 41 4D 20 ...   3659  RAM_ERROR   DC.B '! RAM error at: ',NULL
000017BB= 30 31 32 33 34 35 ...   3660  BIN2HEX_LUT DC.B '0123456789ABCDEF'
000017CB= 00 01 02 03 04 05 ...   3661  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
000017E2= 4C 6F 61 64 69 6E ...   3662  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
000017F6= 0D 0A 00                3663  CRLF    DC.B CR,LF,NULL
000017F9= 3E 20 00                3664  PROMPT  DC.B '> ',NULL
000017FC= 30 78 00                3665  ox      DC.B '0x',NULL
000017FF= 20 2D 3E 20 00          3666  to      DC.B ' -> ',NULL
00001804= 20 66 6F 72 20 00       3667  for     DC.B ' for ',NULL
0000180A= 53 50 3A 20 00          3668  STACK_POINTER DC.B 'SP: ',NULL
0000180F= 53 52 3A 20 00          3669  STATUS_REGISTER DC.B 'SR: ',NULL
00001814= 74 69 63 6B 0D 0A 00    3670  TICK DC.B 'tick',CR,LF,NULL
0000181B= 2A 20 42 75 73 2F ...   3671  BUS_ERROR DC.B '* Bus/address error ',NULL
00001830= 72 65 61 64 69 6E ...   3672  READING DC.B 'reading ',NULL
00001839= 77 72 69 74 69 6E ...   3673  WRITING DC.B 'writing ',NULL
00001842= 20 66 72 6F 6D 20 00    3674  FROM DC.B ' from ',NULL
00001849= 2A 20 55 6E 68 61 ...   3675  UNHANDLED DC.B '* Unhandled interrupt',NULL
0000185F= 2A 20 20 55 6E 69 ...   3676  UNINITIALISED DC.B '*  Unitialised interrupt vector',NULL
0000187F= 2A 20 53 70 75 72 ...   3677  SPURIOUS DC.B '* Spurious interrupt',NULL
00001894= 4D 44 46 2D 6D 6F ...   3678  VERSION DC.B 'MDF-mon V1.129 (30/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
000018B2= 00                      3679  END     DC.B 0
000018B3                          3680      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         17BB
BUS_ERROR           181B
BUS_ERROR_HANDLER   1418
CONTINUE            1488
CONTINUE_113        B04
CONTINUE_54         5E0
CONTINUE_57         630
CONTINUE_61         686
CONTINUE_69         73A
CONTINUE_74         7AC
CONTINUE_79         828
CONTINUE_84         8A6
CONTINUE_89         92E
CONTINUE_94         9A0
CONTINUE_99         A12
CR                  D
CRLF                17F6
CS_FAILURE          1799
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       C0E
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 18B2
EXIT_10             288
EXIT_104            A84
EXIT_106            AA4
EXIT_110            AD6
EXIT_118            B6C
EXIT_120            B94
EXIT_123            BB4
EXIT_128            BFE
EXIT_131            C2E
EXIT_135            C78
EXIT_138            C9A
EXIT_143            CE4
EXIT_145            D60
EXIT_148            D84
EXIT_15             2D2
EXIT_153            DCE
EXIT_160            E60
EXIT_163            ED0
EXIT_165            EF0
EXIT_168            F12
EXIT_17             2F2
EXIT_172            F5C
EXIT_175            F7E
EXIT_179            FC8
EXIT_182            FE8
EXIT_187            1032
EXIT_20             312
EXIT_202            114C
EXIT_205            11B0
EXIT_208            11D0
EXIT_212            121A
EXIT_215            123C
EXIT_22             33C
EXIT_220            1286
EXIT_224            12C8
EXIT_227            12EA
EXIT_232            1334
EXIT_234            1354
EXIT_237            1376
EXIT_242            13C0
EXIT_246            1438
EXIT_248            1464
EXIT_250            1488
EXIT_253            14AC
EXIT_257            14F6
EXIT_260            151A
EXIT_265            1564
EXIT_267            159C
EXIT_269            15BE
EXIT_271            15E0
EXIT_273            1602
EXIT_28             3C8
EXIT_30             438
EXIT_32             464
EXIT_35             48E
EXIT_45             53C
EXIT_5              240
EXIT_52             5B2
EXIT_66             6F6
EXIT_7              260
FOR                 1804
FROM                1842
G                   CE8
GET_INPUT           33C
H                   43C
HASH                13E4
HELP                161D
HELPPROMPT          160A
HEX2BIN             10B
HEX2BIN_LUT         17CB
HEX_DIGIT           13FA
HUH                 1759
I                   13C4
ILLEGAL_HANDLER     156C
L                   DDE
LF                  A
LOADING             17E2
LOOP_10             26C
LOOP_104            A68
LOOP_106            A88
LOOP_110            ABA
LOOP_118            B50
LOOP_120            B78
LOOP_122            BB6
LOOP_123            B98
LOOP_128            BE2
LOOP_130            C30
LOOP_131            C12
LOOP_135            C5C
LOOP_137            C9C
LOOP_138            C7E
LOOP_143            CC8
LOOP_145            D44
LOOP_147            D86
LOOP_148            D68
LOOP_15             2B6
LOOP_153            DB2
LOOP_160            E44
LOOP_163            EB4
LOOP_165            ED4
LOOP_167            F14
LOOP_168            EF6
LOOP_17             2D6
LOOP_172            F40
LOOP_174            F80
LOOP_175            F62
LOOP_179            FAC
LOOP_181            FEA
LOOP_182            FCC
LOOP_187            1016
LOOP_20             2F6
LOOP_202            1130
LOOP_205            1194
LOOP_207            11D2
LOOP_208            11B4
LOOP_212            11FE
LOOP_214            123E
LOOP_215            1220
LOOP_22             320
LOOP_220            126A
LOOP_224            12AC
LOOP_226            12EC
LOOP_227            12CE
LOOP_232            1318
LOOP_234            1338
LOOP_236            1378
LOOP_237            135A
LOOP_242            13A4
LOOP_246            141C
LOOP_248            1448
LOOP_250            146C
LOOP_252            14AE
LOOP_253            1490
LOOP_257            14DA
LOOP_259            151C
LOOP_260            14FE
LOOP_265            1548
LOOP_267            1580
LOOP_269            15A2
LOOP_271            15C4
LOOP_273            15E6
LOOP_28             3AC
LOOP_30             41C
LOOP_32             448
LOOP_34             490
LOOP_35             472
LOOP_45             520
LOOP_5              224
LOOP_52             596
LOOP_66             6DA
LOOP_7              244
LOOP_9              28A
MAIN_LOOP           31C
NULL                0
O                   13D4
OX                  17FC
P                   10D8
PRINTSTR            448
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              17F9
PROTECT             A40
R                   468
RAM                 200000
RAM_ERROR           17AA
READ                1760
READING             1830
READ_CHAR           62D
RESET               4
ROM                 0
S                   5BC
SPURIOUS            187F
SPURIOUS_HANDLER    15C0
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       180A
START               104
STATUS_REGISTER     180F
TAB                 9
TICK                1814
TICK_HANDLER        15E2
TO                  17FF
UNHANDLED           1849
UNHANDLED_HANDLER   157C
UNINITIALISED       185F
UNINITIALISED_HANDLER  159E
UNPROTECT           979
UNREC               1782
USER                100
V                   444
VECS                8
VERSION             1894
W                   540
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_189  1044
WAIT_FOR_COMPLETE_191  1066
WAIT_FOR_COMPLETE_192  1078
WAIT_FOR_COMPLETE_194  109E
WAIT_FOR_COMPLETE_195  10B0
WAIT_FOR_COMPLETE_222  1288
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_101  A2A
WAIT_FOR_READY_105  A70
WAIT_FOR_READY_107  A90
WAIT_FOR_READY_108  AA4
WAIT_FOR_READY_11   274
WAIT_FOR_READY_111  AC2
WAIT_FOR_READY_113  AE8
WAIT_FOR_READY_115  B1C
WAIT_FOR_READY_119  B58
WAIT_FOR_READY_121  B80
WAIT_FOR_READY_124  BA0
WAIT_FOR_READY_126  BC8
WAIT_FOR_READY_129  BEA
WAIT_FOR_READY_13   29C
WAIT_FOR_READY_132  C1A
WAIT_FOR_READY_134  C42
WAIT_FOR_READY_136  C64
WAIT_FOR_READY_139  C86
WAIT_FOR_READY_141  CAE
WAIT_FOR_READY_144  CD0
WAIT_FOR_READY_146  D4C
WAIT_FOR_READY_149  D70
WAIT_FOR_READY_151  D98
WAIT_FOR_READY_154  DBA
WAIT_FOR_READY_155  DEC
WAIT_FOR_READY_157  E06
WAIT_FOR_READY_16   2BE
WAIT_FOR_READY_161  E4C
WAIT_FOR_READY_164  EBC
WAIT_FOR_READY_166  EDC
WAIT_FOR_READY_169  EFE
WAIT_FOR_READY_171  F26
WAIT_FOR_READY_173  F48
WAIT_FOR_READY_176  F6A
WAIT_FOR_READY_178  F92
WAIT_FOR_READY_18   2DE
WAIT_FOR_READY_180  FB4
WAIT_FOR_READY_183  FD4
WAIT_FOR_READY_185  FFC
WAIT_FOR_READY_188  101E
WAIT_FOR_READY_197  10E4
WAIT_FOR_READY_199  10FE
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_203  1138
WAIT_FOR_READY_206  119C
WAIT_FOR_READY_209  11BC
WAIT_FOR_READY_21   2FE
WAIT_FOR_READY_211  11E4
WAIT_FOR_READY_213  1206
WAIT_FOR_READY_216  1228
WAIT_FOR_READY_218  1250
WAIT_FOR_READY_221  1272
WAIT_FOR_READY_225  12B4
WAIT_FOR_READY_228  12D6
WAIT_FOR_READY_23   328
WAIT_FOR_READY_230  12FE
WAIT_FOR_READY_233  1320
WAIT_FOR_READY_235  1340
WAIT_FOR_READY_238  1362
WAIT_FOR_READY_24   33C
WAIT_FOR_READY_240  138A
WAIT_FOR_READY_243  13AC
WAIT_FOR_READY_247  1424
WAIT_FOR_READY_249  1450
WAIT_FOR_READY_251  1474
WAIT_FOR_READY_254  1498
WAIT_FOR_READY_256  14C0
WAIT_FOR_READY_258  14E2
WAIT_FOR_READY_26   356
WAIT_FOR_READY_261  1506
WAIT_FOR_READY_263  152E
WAIT_FOR_READY_266  1550
WAIT_FOR_READY_268  1588
WAIT_FOR_READY_270  15AA
WAIT_FOR_READY_272  15CC
WAIT_FOR_READY_274  15EE
WAIT_FOR_READY_29   3B4
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_31   424
WAIT_FOR_READY_33   450
WAIT_FOR_READY_36   47A
WAIT_FOR_READY_38   4A2
WAIT_FOR_READY_39   4B8
WAIT_FOR_READY_40   4CE
WAIT_FOR_READY_41   4E2
WAIT_FOR_READY_42   4F6
WAIT_FOR_READY_43   50A
WAIT_FOR_READY_46   528
WAIT_FOR_READY_47   54A
WAIT_FOR_READY_49   564
WAIT_FOR_READY_53   59E
WAIT_FOR_READY_54   5C4
WAIT_FOR_READY_56   5FE
WAIT_FOR_READY_57   614
WAIT_FOR_READY_59   648
WAIT_FOR_READY_6    22C
WAIT_FOR_READY_61   66A
WAIT_FOR_READY_63   69E
WAIT_FOR_READY_67   6E2
WAIT_FOR_READY_69   71E
WAIT_FOR_READY_71   752
WAIT_FOR_READY_74   790
WAIT_FOR_READY_76   7C4
WAIT_FOR_READY_79   80C
WAIT_FOR_READY_8    24C
WAIT_FOR_READY_81   840
WAIT_FOR_READY_84   88A
WAIT_FOR_READY_86   8BE
WAIT_FOR_READY_89   912
WAIT_FOR_READY_91   946
WAIT_FOR_READY_94   984
WAIT_FOR_READY_96   9B8
WAIT_FOR_READY_99   9F6
WAIT_FOR_SRECORD    5C4
WRITE               1468
WRITING             1839
X                   12A8
Z                   CEE
_00000000           218
_00000001           37C
_00000002           390
_00000003           6FE
_00000004           ADA
_00000005           70C
_00000006           8FA
_00000007           870
_00000008           ADA
_00000009           A64
_0000000A           ADA
_0000000B           C02
_0000000C           C0E
_0000000D           DCE
_0000000E           104E
_0000000F           1070
_00000010           1082
_00000011           10A8
_00000012           10BA
_00000013           1292
_10000000           660
_10000001           6C8
_10000002           714
_10000003           77C
_10000004           786
_10000005           7EE
_10000006           802
_10000007           86A
_10000008           874
_10000009           8F4
_1000000A           880
_1000000B           8E8
_1000000C           908
_1000000D           970
_1000000E           97A
_1000000F           9E2
_10000010           9EC
_10000011           A54
_10000012           ADE
_10000013           B46
_10000014           1032
_10000015           1054
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           548
_20000005           58C
_20000006           D00
_20000007           D10
_20000008           D2A
_20000009           DD0
_2000000A           DEA
_2000000B           E2E
_2000000C           EA6
_2000000D           EAA
_2000000E           108A
_2000000F           10BC
_20000010           10E2
_20000011           1126
_20000012           1186
_20000013           118A
