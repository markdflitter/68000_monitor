00000400 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 25/04/2021 14:56:42

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor program
00000000                             6  *-----------------------------------------------------------
00000000                             7  ; to do
00000000                             8  
00000000                             9  ; other ideas
00000000                            10  ;------------
00000000                            11  ; use DBLoop?
00000000                            12  ; keep track of highest address hit during srec download
00000000                            13  ; implement backspace
00000000                            14  ; fix being able to enter random chars when W'ing
00000000                            15  ; ram check at startup?  Not sure if this is a good idea!
00000000                            16  ; check for escape during Z and L?  Not sure if W is a good idea either
00000000                            17  
00000000                            18      ORG  $0
00000000                            19  
00000000  =00000000                 20  DEBUG               EQU 0
00000000                            21  
00000000                            22  ; constants
00000000  =00000000                 23  NULL                EQU 0
00000000  =00000009                 24  TAB                 EQU 9
00000000  =0000000D                 25  CR                  EQU 13
00000000  =0000000A                 26  LF                  EQU 10
00000000                            27  
00000000  =00000000                 28  ROM                 EQU $0
00000000  =00200000                 29  RAM                 EQU $200000
00000000                            30  
00000000  =00C00000                 31  DUART_BASE          EQU $C00000
00000000  =00000000                 32  DUART_MRA_          EQU $0
00000000  =00000001                 33  DUART_CSRA_         EQU $1
00000000  =00000001                 34  DUART_SRA_          EQU $1
00000000  =00000002                 35  DUART_CRA_          EQU $2
00000000  =00000003                 36  DUART_TXA_          EQU $3
00000000  =00000003                 37  DUART_RXA_          EQU $3
00000000  =00000004                 38  DUART_ACR_          EQU $4
00000000  =00000005                 39  DUART_IMR_          EQU $5
00000000  =00000008                 40  DUART_MRB_          EQU $8
00000000  =00000009                 41  DUART_CSRB_         EQU $9
00000000  =00000009                 42  DUART_SRB_          EQU $9
00000000  =0000000A                 43  DUART_CRB_          EQU $A
00000000  =0000000B                 44  DUART_TXB_          EQU $B
00000000  =0000000B                 45  DUART_RXB_          EQU $B
00000000  =0000000C                 46  DUART_IVR_          EQU $C
00000000  =0000000D                 47  DUART_OPCR_         EQU $D
00000000  =0000000E                 48  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 49  DUART_RESET_OPR_    EQU $F
00000000                            50  
00000000  =00C00001                 51  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 52  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 53  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                 54  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                 55  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                 56  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                            57  
00000000  =00C00011                 58  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                 59  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                 60  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                 61  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                 62  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                 63  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                            64  
00000000  =00C00009                 65  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                 66  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C00019                 67  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                 68  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                 69  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                 70  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                            71  
00000000  =00E00000                 72  DISPLAY_BASE        EQU $E00000
00000000  =00000000                 73  DISPLAY_            EQU $0
00000000  =00E00001                 74  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                            75  
00000000                            76  ; macros
00000000                            77  ; convert top 4 bits of input register from binary to a single hex digit
00000000                            78  ; the input register is changed during the process
00000000                            79  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                            80  BIN2HEX MACRO
00000000                            81      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                            82      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                            83      MOVE.B \1,\2
00000000                            84      ANDI.L #$F,\2
00000000                            85      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                            86      ENDM
00000000                            87  
00000000                            88  ; convert single hex digit to 4 bit binary number in LSbits
00000000                            89  ; the input register is changed during the process
00000000                            90  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                            91  HEX2BIN MACRO
00000000                            92      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                            93      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                            94      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                            95      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                            96      ENDM
00000000                            97  
00000000                            98  ; send a single char to the serial port
00000000                            99  ; \1 = char to send, \2 = data register to use for status poll
00000000                           100  ; will stamp on D0 and D1 in debug mode
00000000                           101  PRINT_CHAR MACRO
00000000                           102  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           103      IFEQ DEBUG
00000000                           104          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           105          BTST #2,\2                                  ; check for space to send
00000000                           106          BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           107          MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           108      ENDC
00000000                           109  
00000000                           110      IFNE DEBUG
00000000                           111          MOVE.B \1,D1
00000000                           112          MOVE.L #6,D0   
00000000                           113          TRAP #15                                    ; write to terminal in simulator
00000000                           114      ENDC
00000000                           115  
00000000                           116      ENDM
00000000                           117  
00000000                           118  ; send CR,LF to the serial port
00000000                           119  ; \1 = data register to use for status poll, /2 = working address register
00000000                           120  PRINT_CRLF MACRO
00000000                           121      LEA CRLF(PC),\2
00000000                           122      PRINT_STR \2,\1
00000000                           123      ENDM
00000000                           124  
00000000                           125  ; send C-style, zero terminated string to the serial port
00000000                           126  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           127  PRINT_STR MACRO
00000000                           128  LOOP\@
00000000                           129      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           130      BEQ EXIT\@
00000000                           131      PRINT_CHAR (\1)+,\2
00000000                           132      BRA LOOP\@
00000000                           133  EXIT\@
00000000                           134      ENDM
00000000                           135    
00000000                           136  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           137  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           138  PRINT_REG MACRO
00000000                           139      LEA ox(PC),\5
00000000                           140      PRINT_STR \5,\2
00000000                           141      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           142  LOOP\@
00000000                           143      BIN2HEX \1,\3,\5
00000000                           144      PRINT_CHAR \3,\2
00000000                           145      DBEQ \4,LOOP\@
00000000                           146      ENDM
00000000                           147  
00000000                           148  ; wait for a char from the serial port
00000000                           149  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           150  ; will stamp on D0 and D1 in debug mode
00000000                           151  WAIT_CHAR MACRO
00000000                           152  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           153      IFEQ DEBUG
00000000                           154          MOVE.B DUART_SRA,\2                         ; read status register
00000000                           155          BTST #0,\2                                  ; check for character
00000000                           156          BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           157      ENDC
00000000                           158  
00000000                           159      READ_CHAR \1
00000000                           160  
00000000                           161      IFEQ DEBUG
00000000                           162          PRINT_CHAR \1,\2                            ; echo it back
00000000                           163      ENDC
00000000                           164      ENDM
00000000                           165  
00000000                           166  ; read a char from the serial port - assumes that there is one!
00000000                           167  ; \ 1= data register for read char
00000000                           168  ; will stamp on D0 and D1 in debug mode
00000000                           169  READ_CHAR MACRO
00000000                           170      IFEQ DEBUG
00000000                           171          MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           172      ENDC
00000000                           173      IFNE DEBUG
00000000                           174          MOVE.L #5,D0    
00000000                           175          TRAP #15                                    ; read from keyboard in simulator
00000000                           176          MOVE.L D1,\1
00000000                           177      ENDC
00000000                           178  
00000000                           179      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           180      BEQ START
00000000                           181      ENDM
00000000                           182  
00000000                           183  
00000000                           184  ; read data from the download serial port
00000000                           185  ; \ 1= data register for read char
00000000                           186  DOWNLOAD MACRO
00000000                           187  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           188  
00000000                           189      MOVE.B DUART_SRA,\1                             ; check for command
00000000                           190      BTST #0,\1                                      ; check for character
00000000                           191      BEQ CONTINUE\@                                  ; nothing, continue
00000000                           192  
00000000                           193      READ_CHAR \1                                    ; we're not going to do anything with it, just check for escape
00000000                           194  CONTINUE\@
00000000                           195      MOVE.B DUART_SRB,\1                             ; read download status register
00000000                           196      BTST #0,\1                                      ; check for character
00000000                           197      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           198      
00000000                           199      MOVE.B DUART_RXB,\1                             ; got a character, read it
00000000                           200      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           201  
00000000                           202      ENDM
00000000                           203  
00000000                           204  ; unprotect the EEPROM
00000000                           205  UNPROTECT MACRO
00000000                           206      MOVE.W #$AAAA,$2AAA                             ; remove write protect
00000000                           207      NOP
00000000                           208      MOVE.W #$5555,$1554
00000000                           209      NOP
00000000                           210      MOVE.W #$8080,$2AAA
00000000                           211      NOP
00000000                           212      MOVE.W #$AAAA,$2AAA
00000000                           213      NOP
00000000                           214      MOVE.W #$5555,$1554
00000000                           215      NOP
00000000                           216      MOVE.W #$2020,$2AAA
00000000                           217      ENDM
00000000                           218      
00000000                           219  ; protect the EEPROM
00000000                           220  PROTECT MACRO
00000000                           221      MOVE.W #$AAAA,$2AAA                             ; and write protect
00000000                           222      MOVE.W #$5555,$1554
00000000                           223      MOVE.W #$A0A0,$2AAA
00000000                           224      ENDM
00000000                           225  
00000000                           226  
00000000                           227  ; read two hex digits from the download serial port and convert to a byte
00000000                           228  ; \1 result register, \2 = data register for read char, \3 = register to use for status poll, \4 = working data register, \5 = checksum register, \6 = working address register
00000000                           229  DOWNLOAD_BYTE MACRO
00000000                           230      MOVE.B #2,\4
00000000                           231      WHILE.B \4 <GT> 0 DO
00000000                           232          LSL.L #4,\1                                 ; it's OK to do this first, because we are either starting from 0, 
00000000                           233          DOWNLOAD \2                                 ; or we are reading the next byte along, so need to shift up the previous one
00000000                           234          PRINT_CHAR \2,\3
00000000                           235          HEX2BIN \2,\2,\6
00000000                           236          OR.B \2,\1
00000000                           237          SUB.B #1,\4
00000000                           238      ENDW
00000000                           239  
00000000                           240      MOVE.L #0,\2                                    ; rextract latest byte of address and add into checksum
00000000                           241      MOVE.B \1,\2
00000000                           242      ADD.L \1,\5
00000000                           243  
00000000                           244      ENDM
00000000                           245  
00000000                           246  ; write word to EEPROM
00000000                           247  ; \1 word to write, \2 = target address, \3 = working data register
00000000                           248  PROGRAM MACRO
00000000                           249    MOVE.W \1,\2                                      ; write the data
00000000                           250  
00000000                           251  WAIT_FOR_COMPLETE\@
00000000                           252          MOVE.W \2,\3
00000000                           253  
00000000                           254          IF.W \3 <NE> \1 THEN
00000000                           255              BRA WAIT_FOR_COMPLETE\@
00000000                           256          ENDI
00000000                           257          ENDM
00000000                           258          
00000000                           259  ; program vector to EEPROM
00000000                           260  ; \1 handler address, \2 = target address, \3 = working data register
00000000                           261  PROGRAM_VECTOR MACRO
00000000                           262      ADD.L #2,\2
00000000                           263      PROGRAM \1, (\2), \3                                ; write it
00000000                           264      LSR.L #8,\1
00000000                           265      LSR.L #8,\1
00000000                           266      SUB.L #2,\2
00000000                           267      PROGRAM \1, (\2), \3
00000000                           268      ENDM
00000000                           269  
00000000                           270  
00000000                           271  ; register catalogue
00000000                           272  ; D0 - used for simulator I/O
00000000                           273  ; D1 - used for simulator I/O
00000000                           274  ; D2 - read character
00000000                           275  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           276  ; D6 - working register used in R/W
00000000                           277  ; D7 - address accumulator, reset by download
00000000                           278  ; A0 - address of string to print 
00000000                           279  
00000000                           280  ; start vector
00000000= 002FFFFC                 281  STACK   DC.L $2FFFFC                                ; STACK
00000004= 00000400                 282  RESET   DC.L START                                  ; RESET
00000008= 00001780                 283  VECS    DC.L BUS_ERROR_HANDLER                      ; BUS ERROR
0000000C= 00001780                 284          DC.L BUS_ERROR_HANDLER                      ; ADDRESS ERROR
00000010= 000018D4                 285          DC.L ILLEGAL_HANDLER                        ; ILLEGAL INSTRUCTION
00000014= 000018E4                 286          DC.L UNHANDLED_HANDLER
00000018= 000018E4                 287          DC.L UNHANDLED_HANDLER
0000001C= 000018E4                 288          DC.L UNHANDLED_HANDLER
00000020= 000018E4                 289          DC.L UNHANDLED_HANDLER
00000024= 000018E4                 290          DC.L UNHANDLED_HANDLER
00000028= 000018E4                 291          DC.L UNHANDLED_HANDLER
0000002C= 000018E4                 292          DC.L UNHANDLED_HANDLER
00000030= 000018E4                 293          DC.L UNHANDLED_HANDLER
00000034= 000018E4                 294          DC.L UNHANDLED_HANDLER
00000038= 000018E4                 295          DC.L UNHANDLED_HANDLER
0000003C= 000018E4                 296          DC.L UNHANDLED_HANDLER
00000040= 000018E4                 297          DC.L UNHANDLED_HANDLER
00000044= 000018E4                 298          DC.L UNHANDLED_HANDLER
00000048= 000018E4                 299          DC.L UNHANDLED_HANDLER
0000004C= 000018E4                 300          DC.L UNHANDLED_HANDLER
00000050= 000018E4                 301          DC.L UNHANDLED_HANDLER
00000054= 000018E4                 302          DC.L UNHANDLED_HANDLER
00000058= 000018E4                 303          DC.L UNHANDLED_HANDLER
0000005C= 000018E4                 304          DC.L UNHANDLED_HANDLER
00000060= 000018E4                 305          DC.L UNHANDLED_HANDLER
00000064= 000018E4                 306          DC.L UNHANDLED_HANDLER
00000068= 000018E4                 307          DC.L UNHANDLED_HANDLER
0000006C= 000018E4                 308          DC.L UNHANDLED_HANDLER
00000070= 000018E4                 309          DC.L UNHANDLED_HANDLER
00000074= 000018E4                 310          DC.L UNHANDLED_HANDLER
00000078= 000018E4                 311          DC.L UNHANDLED_HANDLER
0000007C= 000018E4                 312          DC.L UNHANDLED_HANDLER
00000080= 000018E4                 313          DC.L UNHANDLED_HANDLER
00000084= 000018E4                 314          DC.L UNHANDLED_HANDLER
00000088= 000018E4                 315          DC.L UNHANDLED_HANDLER
0000008C= 000018E4                 316          DC.L UNHANDLED_HANDLER
00000090= 000018E4                 317          DC.L UNHANDLED_HANDLER
00000094= 000018E4                 318          DC.L UNHANDLED_HANDLER
00000098= 000018E4                 319          DC.L UNHANDLED_HANDLER
0000009C= 000018E4                 320          DC.L UNHANDLED_HANDLER
000000A0= 000018E4                 321          DC.L UNHANDLED_HANDLER
000000A4= 000018E4                 322          DC.L UNHANDLED_HANDLER
000000A8= 000018E4                 323          DC.L UNHANDLED_HANDLER
000000AC= 000018E4                 324          DC.L UNHANDLED_HANDLER
000000B0= 000018E4                 325          DC.L UNHANDLED_HANDLER
000000B4= 000018E4                 326          DC.L UNHANDLED_HANDLER
000000B8= 000018E4                 327          DC.L UNHANDLED_HANDLER
000000BC= 000018E4                 328          DC.L UNHANDLED_HANDLER
000000C0= 000018E4                 329          DC.L UNHANDLED_HANDLER
000000C4= 000018E4                 330          DC.L UNHANDLED_HANDLER
000000C8= 000018E4                 331          DC.L UNHANDLED_HANDLER
000000CC= 000018E4                 332          DC.L UNHANDLED_HANDLER
000000D0= 000018E4                 333          DC.L UNHANDLED_HANDLER
000000D4= 000018E4                 334          DC.L UNHANDLED_HANDLER
000000D8= 000018E4                 335          DC.L UNHANDLED_HANDLER
000000DC= 000018E4                 336          DC.L UNHANDLED_HANDLER
000000E0= 000018E4                 337          DC.L UNHANDLED_HANDLER
000000E4= 000018E4                 338          DC.L UNHANDLED_HANDLER
000000E8= 000018E4                 339          DC.L UNHANDLED_HANDLER
000000EC= 000018E4                 340          DC.L UNHANDLED_HANDLER
000000F0= 000018E4                 341          DC.L UNHANDLED_HANDLER
000000F4= 000018E4                 342          DC.L UNHANDLED_HANDLER
000000F8= 000018E4                 343          DC.L UNHANDLED_HANDLER
000000FC= 000018E4                 344          DC.L UNHANDLED_HANDLER
00000100= 000018E4                 345  USER        DC.L UNHANDLED_HANDLER
00000104= 000018E4                 346          DC.L UNHANDLED_HANDLER
00000108= 000018E4                 347          DC.L UNHANDLED_HANDLER
0000010C= 000018E4                 348          DC.L UNHANDLED_HANDLER
00000110= 000018E4                 349          DC.L UNHANDLED_HANDLER
00000114= 000018E4                 350          DC.L UNHANDLED_HANDLER
00000118= 000018E4                 351          DC.L UNHANDLED_HANDLER
0000011C= 000018E4                 352          DC.L UNHANDLED_HANDLER
00000120= 000018E4                 353          DC.L UNHANDLED_HANDLER
00000124= 000018E4                 354          DC.L UNHANDLED_HANDLER
00000128= 000018E4                 355          DC.L UNHANDLED_HANDLER
0000012C= 000018E4                 356          DC.L UNHANDLED_HANDLER
00000130= 000018E4                 357          DC.L UNHANDLED_HANDLER
00000134= 000018E4                 358          DC.L UNHANDLED_HANDLER
00000138= 000018E4                 359          DC.L UNHANDLED_HANDLER
0000013C= 000018E4                 360          DC.L UNHANDLED_HANDLER
00000140= 000018E4                 361          DC.L UNHANDLED_HANDLER
00000144= 000018E4                 362          DC.L UNHANDLED_HANDLER
00000148= 000018E4                 363          DC.L UNHANDLED_HANDLER
0000014C= 000018E4                 364          DC.L UNHANDLED_HANDLER
00000150= 000018E4                 365          DC.L UNHANDLED_HANDLER
00000154= 000018E4                 366          DC.L UNHANDLED_HANDLER
00000158= 000018E4                 367          DC.L UNHANDLED_HANDLER
0000015C= 000018E4                 368          DC.L UNHANDLED_HANDLER
00000160= 000018E4                 369          DC.L UNHANDLED_HANDLER
00000164= 000018E4                 370          DC.L UNHANDLED_HANDLER
00000168= 000018E4                 371          DC.L UNHANDLED_HANDLER
0000016C= 000018E4                 372          DC.L UNHANDLED_HANDLER
00000170= 000018E4                 373          DC.L UNHANDLED_HANDLER
00000174= 000018E4                 374          DC.L UNHANDLED_HANDLER
00000178= 000018E4                 375          DC.L UNHANDLED_HANDLER
0000017C= 000018E4                 376          DC.L UNHANDLED_HANDLER
00000180= 000018E4                 377          DC.L UNHANDLED_HANDLER
00000184= 000018E4                 378          DC.L UNHANDLED_HANDLER
00000188= 000018E4                 379          DC.L UNHANDLED_HANDLER
0000018C= 000018E4                 380          DC.L UNHANDLED_HANDLER
00000190= 000018E4                 381          DC.L UNHANDLED_HANDLER
00000194= 000018E4                 382          DC.L UNHANDLED_HANDLER
00000198= 000018E4                 383          DC.L UNHANDLED_HANDLER
0000019C= 000018E4                 384          DC.L UNHANDLED_HANDLER
000001A0= 000018E4                 385          DC.L UNHANDLED_HANDLER
000001A4= 000018E4                 386          DC.L UNHANDLED_HANDLER
000001A8= 000018E4                 387          DC.L UNHANDLED_HANDLER
000001AC= 000018E4                 388          DC.L UNHANDLED_HANDLER
000001B0= 000018E4                 389          DC.L UNHANDLED_HANDLER
000001B4= 000018E4                 390          DC.L UNHANDLED_HANDLER
000001B8= 000018E4                 391          DC.L UNHANDLED_HANDLER
000001BC= 000018E4                 392          DC.L UNHANDLED_HANDLER
000001C0= 000018E4                 393          DC.L UNHANDLED_HANDLER
000001C4= 000018E4                 394          DC.L UNHANDLED_HANDLER
000001C8= 000018E4                 395          DC.L UNHANDLED_HANDLER
000001CC= 000018E4                 396          DC.L UNHANDLED_HANDLER
000001D0= 000018E4                 397          DC.L UNHANDLED_HANDLER
000001D4= 000018E4                 398          DC.L UNHANDLED_HANDLER
000001D8= 000018E4                 399          DC.L UNHANDLED_HANDLER
000001DC= 000018E4                 400          DC.L UNHANDLED_HANDLER
000001E0= 000018E4                 401          DC.L UNHANDLED_HANDLER
000001E4= 000018E4                 402          DC.L UNHANDLED_HANDLER
000001E8= 000018E4                 403          DC.L UNHANDLED_HANDLER
000001EC= 000018E4                 404          DC.L UNHANDLED_HANDLER
000001F0= 000018E4                 405          DC.L UNHANDLED_HANDLER
000001F4= 000018E4                 406          DC.L UNHANDLED_HANDLER
000001F8= 000018E4                 407          DC.L UNHANDLED_HANDLER
000001FC= 000018E4                 408          DC.L UNHANDLED_HANDLER
00000200= 000018E4                 409          DC.L UNHANDLED_HANDLER
00000204= 000018E4                 410          DC.L UNHANDLED_HANDLER
00000208= 000018E4                 411          DC.L UNHANDLED_HANDLER
0000020C= 000018E4                 412          DC.L UNHANDLED_HANDLER
00000210= 000018E4                 413          DC.L UNHANDLED_HANDLER
00000214= 000018E4                 414          DC.L UNHANDLED_HANDLER
00000218= 000018E4                 415          DC.L UNHANDLED_HANDLER
0000021C= 000018E4                 416          DC.L UNHANDLED_HANDLER
00000220= 000018E4                 417          DC.L UNHANDLED_HANDLER
00000224= 000018E4                 418          DC.L UNHANDLED_HANDLER
00000228= 000018E4                 419          DC.L UNHANDLED_HANDLER
0000022C= 000018E4                 420          DC.L UNHANDLED_HANDLER
00000230= 000018E4                 421          DC.L UNHANDLED_HANDLER
00000234= 000018E4                 422          DC.L UNHANDLED_HANDLER
00000238= 000018E4                 423          DC.L UNHANDLED_HANDLER
0000023C= 000018E4                 424          DC.L UNHANDLED_HANDLER
00000240= 000018E4                 425          DC.L UNHANDLED_HANDLER
00000244= 000018E4                 426          DC.L UNHANDLED_HANDLER
00000248= 000018E4                 427          DC.L UNHANDLED_HANDLER
0000024C= 000018E4                 428          DC.L UNHANDLED_HANDLER
00000250= 000018E4                 429          DC.L UNHANDLED_HANDLER
00000254= 000018E4                 430          DC.L UNHANDLED_HANDLER
00000258= 000018E4                 431          DC.L UNHANDLED_HANDLER
0000025C= 000018E4                 432          DC.L UNHANDLED_HANDLER
00000260= 000018E4                 433          DC.L UNHANDLED_HANDLER
00000264= 000018E4                 434          DC.L UNHANDLED_HANDLER
00000268= 000018E4                 435          DC.L UNHANDLED_HANDLER
0000026C= 000018E4                 436          DC.L UNHANDLED_HANDLER
00000270= 000018E4                 437          DC.L UNHANDLED_HANDLER
00000274= 000018E4                 438          DC.L UNHANDLED_HANDLER
00000278= 000018E4                 439          DC.L UNHANDLED_HANDLER
0000027C= 000018E4                 440          DC.L UNHANDLED_HANDLER
00000280= 000018E4                 441          DC.L UNHANDLED_HANDLER
00000284= 000018E4                 442          DC.L UNHANDLED_HANDLER
00000288= 000018E4                 443          DC.L UNHANDLED_HANDLER
0000028C= 000018E4                 444          DC.L UNHANDLED_HANDLER
00000290= 000018E4                 445          DC.L UNHANDLED_HANDLER
00000294= 000018E4                 446          DC.L UNHANDLED_HANDLER
00000298= 000018E4                 447          DC.L UNHANDLED_HANDLER
0000029C= 000018E4                 448          DC.L UNHANDLED_HANDLER
000002A0= 000018E4                 449          DC.L UNHANDLED_HANDLER
000002A4= 000018E4                 450          DC.L UNHANDLED_HANDLER
000002A8= 000018E4                 451          DC.L UNHANDLED_HANDLER
000002AC= 000018E4                 452          DC.L UNHANDLED_HANDLER
000002B0= 000018E4                 453          DC.L UNHANDLED_HANDLER
000002B4= 000018E4                 454          DC.L UNHANDLED_HANDLER
000002B8= 000018E4                 455          DC.L UNHANDLED_HANDLER
000002BC= 000018E4                 456          DC.L UNHANDLED_HANDLER
000002C0= 000018E4                 457          DC.L UNHANDLED_HANDLER
000002C4= 000018E4                 458          DC.L UNHANDLED_HANDLER
000002C8= 000018E4                 459          DC.L UNHANDLED_HANDLER
000002CC= 000018E4                 460          DC.L UNHANDLED_HANDLER
000002D0= 000018E4                 461          DC.L UNHANDLED_HANDLER
000002D4= 000018E4                 462          DC.L UNHANDLED_HANDLER
000002D8= 000018E4                 463          DC.L UNHANDLED_HANDLER
000002DC= 000018E4                 464          DC.L UNHANDLED_HANDLER
000002E0= 000018E4                 465          DC.L UNHANDLED_HANDLER
000002E4= 000018E4                 466          DC.L UNHANDLED_HANDLER
000002E8= 000018E4                 467          DC.L UNHANDLED_HANDLER
000002EC= 000018E4                 468          DC.L UNHANDLED_HANDLER
000002F0= 000018E4                 469          DC.L UNHANDLED_HANDLER
000002F4= 000018E4                 470          DC.L UNHANDLED_HANDLER
000002F8= 000018E4                 471          DC.L UNHANDLED_HANDLER
000002FC= 000018E4                 472          DC.L UNHANDLED_HANDLER
00000300= 000018E4                 473          DC.L UNHANDLED_HANDLER
00000304= 000018E4                 474          DC.L UNHANDLED_HANDLER
00000308= 000018E4                 475          DC.L UNHANDLED_HANDLER
0000030C= 000018E4                 476          DC.L UNHANDLED_HANDLER
00000310= 000018E4                 477          DC.L UNHANDLED_HANDLER
00000314= 000018E4                 478          DC.L UNHANDLED_HANDLER
00000318= 000018E4                 479          DC.L UNHANDLED_HANDLER
0000031C= 000018E4                 480          DC.L UNHANDLED_HANDLER
00000320= 000018E4                 481          DC.L UNHANDLED_HANDLER
00000324= 000018E4                 482          DC.L UNHANDLED_HANDLER
00000328= 000018E4                 483          DC.L UNHANDLED_HANDLER
0000032C= 000018E4                 484          DC.L UNHANDLED_HANDLER
00000330= 000018E4                 485          DC.L UNHANDLED_HANDLER
00000334= 000018E4                 486          DC.L UNHANDLED_HANDLER
00000338= 000018E4                 487          DC.L UNHANDLED_HANDLER
0000033C= 000018E4                 488          DC.L UNHANDLED_HANDLER
00000340= 000018E4                 489          DC.L UNHANDLED_HANDLER
00000344= 000018E4                 490          DC.L UNHANDLED_HANDLER
00000348= 000018E4                 491          DC.L UNHANDLED_HANDLER
0000034C= 000018E4                 492          DC.L UNHANDLED_HANDLER
00000350= 000018E4                 493          DC.L UNHANDLED_HANDLER
00000354= 000018E4                 494          DC.L UNHANDLED_HANDLER
00000358= 000018E4                 495          DC.L UNHANDLED_HANDLER
0000035C= 000018E4                 496          DC.L UNHANDLED_HANDLER
00000360= 000018E4                 497          DC.L UNHANDLED_HANDLER
00000364= 000018E4                 498          DC.L UNHANDLED_HANDLER
00000368= 000018E4                 499          DC.L UNHANDLED_HANDLER
0000036C= 000018E4                 500          DC.L UNHANDLED_HANDLER
00000370= 000018E4                 501          DC.L UNHANDLED_HANDLER
00000374= 000018E4                 502          DC.L UNHANDLED_HANDLER
00000378= 000018E4                 503          DC.L UNHANDLED_HANDLER
0000037C= 000018E4                 504          DC.L UNHANDLED_HANDLER
00000380= 000018E4                 505          DC.L UNHANDLED_HANDLER
00000384= 000018E4                 506          DC.L UNHANDLED_HANDLER
00000388= 000018E4                 507          DC.L UNHANDLED_HANDLER
0000038C= 000018E4                 508          DC.L UNHANDLED_HANDLER
00000390= 000018E4                 509          DC.L UNHANDLED_HANDLER
00000394= 000018E4                 510          DC.L UNHANDLED_HANDLER
00000398= 000018E4                 511          DC.L UNHANDLED_HANDLER
0000039C= 000018E4                 512          DC.L UNHANDLED_HANDLER
000003A0= 000018E4                 513          DC.L UNHANDLED_HANDLER
000003A4= 000018E4                 514          DC.L UNHANDLED_HANDLER
000003A8= 000018E4                 515          DC.L UNHANDLED_HANDLER
000003AC= 000018E4                 516          DC.L UNHANDLED_HANDLER
000003B0= 000018E4                 517          DC.L UNHANDLED_HANDLER
000003B4= 000018E4                 518          DC.L UNHANDLED_HANDLER
000003B8= 000018E4                 519          DC.L UNHANDLED_HANDLER
000003BC= 000018E4                 520          DC.L UNHANDLED_HANDLER
000003C0= 000018E4                 521          DC.L UNHANDLED_HANDLER
000003C4= 000018E4                 522          DC.L UNHANDLED_HANDLER
000003C8= 000018E4                 523          DC.L UNHANDLED_HANDLER
000003CC= 000018E4                 524          DC.L UNHANDLED_HANDLER
000003D0= 000018E4                 525          DC.L UNHANDLED_HANDLER
000003D4= 000018E4                 526          DC.L UNHANDLED_HANDLER
000003D8= 000018E4                 527          DC.L UNHANDLED_HANDLER
000003DC= 000018E4                 528          DC.L UNHANDLED_HANDLER
000003E0= 000018E4                 529          DC.L UNHANDLED_HANDLER
000003E4= 000018E4                 530          DC.L UNHANDLED_HANDLER
000003E8= 000018E4                 531          DC.L UNHANDLED_HANDLER
000003EC= 000018E4                 532          DC.L UNHANDLED_HANDLER
000003F0= 000018E4                 533          DC.L UNHANDLED_HANDLER
000003F4= 000018E4                 534          DC.L UNHANDLED_HANDLER
000003F8= 000018E4                 535          DC.L UNHANDLED_HANDLER
000003FC= 000018E4                 536          DC.L UNHANDLED_HANDLER
00000400                           537  ; start of program  
00000400                           538  START
00000400  13FC 0000 00E00001       539      MOVE.B #0,DISPLAY
00000408                           540  
00000408  2E7C 002FFFFC            541      MOVE.L #$2FFFFC,A7                              ; reset the stack pointer, in case we got here through an exception
0000040E                           542  
0000040E                           543  ; reset the UART in case of warm start
0000040E  13FC 000A 00C00005       544      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000416  13FC 000A 00C00015       545      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000041E                           546      
0000041E                           547      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000041E  323C 0050                548s     MOVE.W  #$50,D1
00000422  6000 000E                549s     BRA _20000001
00000426                           550s _20000000
00000426  13C1 00C00005            551          MOVE.B D1,DUART_CRA                         ; reset everyting
0000042C  4E71                     552          NOP
0000042E                           553      ENDF
0000042E  0441 0010                554s     SUB.W   #$10,D1
00000432                           555s _20000001
00000432  B27C 0010                556s     CMP.W   #$10,D1
00000436  6CEE                     557s     BGE _20000000
00000438                           558  
00000438                           559      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000438  323C 0050                560s     MOVE.W  #$50,D1
0000043C  6000 000E                561s     BRA _20000003
00000440                           562s _20000002
00000440  13C1 00C00015            563          MOVE.B D1,DUART_CRB                         ; reset everyting
00000446  4E71                     564          NOP
00000448                           565      ENDF
00000448  0441 0010                566s     SUB.W   #$10,D1
0000044C                           567s _20000003
0000044C  B27C 0010                568s     CMP.W   #$10,D1
00000450  6CEE                     569s     BGE _20000002
00000452                           570      
00000452                           571  ;initialise UART
00000452  13FC 0000 00C00009       572      MOVE.B #$0,DUART_ACR
0000045A  13FC 0000 00C0000B       573      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000462  13FC 0000 00C0001B       574      MOVE.B #$0,DUART_OPCR                           ; enable all outputs
0000046A                           575  
0000046A                           576  ; channel A
0000046A  13FC 0013 00C00001       577      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
00000472  13FC 0007 00C00001       578      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
0000047A  13FC 00CC 00C00003       579      MOVE.B #$CC,DUART_CSRA                          ; 38400 baud
00000482  13FC 0005 00C00005       580      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
0000048A                           581  
0000048A                           582  ; channel B
0000048A  13FC 0013 00C00011       583      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
00000492  13FC 0007 00C00011       584      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
0000049A  13FC 00CC 00C00013       585      MOVE.B #$CC,DUART_CSRB                          ; 38400 baud
000004A2  13FC 0005 00C00015       586      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000004AA                           587  
000004AA                           588m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000004AA                           589m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004AA                 TRUE      590m     IFEQ DEBUG
000004AA  1239 00C00003            591m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004B0  0801 0002                592m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004B4  67F4                     593m         BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000004B6  13FC 0000 00C00007       594m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004BE                           595m     ENDC
000004BE                           596m 
000004BE                 FALSE     597m     IFNE DEBUG
000004BE                           598m     ENDC
000004BE                           599m 
000004BE                           600m     ENDM
000004BE                           601m     PRINT_CHAR #0,D1
000004BE                           602m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004BE                 TRUE      603m     IFEQ DEBUG
000004BE  1239 00C00003            604m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004C4  0801 0002                605m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004C8  67F4                     606m         BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000004CA  13FC 0000 00C00007       607m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004D2                           608m     ENDC
000004D2                           609m 
000004D2                 FALSE     610m     IFNE DEBUG
000004D2                           611m     ENDC
000004D2                           612m 
000004D2                           613m     ENDM
000004D2                           614m     PRINT_CHAR #0,D1
000004D2                           615m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004D2                 TRUE      616m     IFEQ DEBUG
000004D2  1239 00C00003            617m         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000004D8  0801 0002                618m         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000004DC  67F4                     619m         BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
000004DE  13FC 0000 00C00007       620m         MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000004E6                           621m     ENDC
000004E6                           622m 
000004E6                 FALSE     623m     IFNE DEBUG
000004E6                           624m     ENDC
000004E6                           625m 
000004E6                           626m     ENDM
000004E6                           627  
000004E6  13FC 0001 00E00001       628      MOVE.B #1,DISPLAY
000004EE                           629      
000004EE                           630m     PRINT_CRLF D1,A0
000004EE  41FA 15C7                631m     LEA CRLF(PC),A0
000004F2                           632mm     PRINT_STR A0,D1
000004F2                           633mm LOOP_5
000004F2  0C10 0000                634mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000004F6  6700 0016                635mm     BEQ EXIT_5
000004FA                           636mmm     PRINT_CHAR (A0)+,D1
000004FA                           637mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000004FA                 TRUE      638mmm     IFEQ DEBUG
000004FA  1239 00C00003            639mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000500  0801 0002                640mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000504  67F4                     641mmm         BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
00000506  13D8 00C00007            642mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000050C                           643mmm     ENDC
0000050C                           644mmm 
0000050C                 FALSE     645mmm     IFNE DEBUG
0000050C                           646mmm     ENDC
0000050C                           647mmm 
0000050C                           648mmm     ENDM
0000050C  60E4                     649mm     BRA LOOP_5
0000050E                           650mm EXIT_5
0000050E                           651mm     ENDM
0000050E                           652m     ENDM
0000050E  41FA 1607                653      LEA VERSION(PC),A0
00000512                           654m     PRINT_STR A0,D3
00000512                           655m LOOP_7
00000512  0C10 0000                656m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000516  6700 0016                657m     BEQ EXIT_7
0000051A                           658mm     PRINT_CHAR (A0)+,D3
0000051A                           659mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000051A                 TRUE      660mm     IFEQ DEBUG
0000051A  1639 00C00003            661mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000520  0803 0002                662mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000524  67F4                     663mm         BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
00000526  13D8 00C00007            664mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000052C                           665mm     ENDC
0000052C                           666mm 
0000052C                 FALSE     667mm     IFNE DEBUG
0000052C                           668mm     ENDC
0000052C                           669mm 
0000052C                           670mm     ENDM
0000052C  60E4                     671m     BRA LOOP_7
0000052E                           672m EXIT_7
0000052E                           673m     ENDM
0000052E                           674  
0000052E  41F9 00001B35            675      LEA END,A0
00000534  2008                     676      MOVE.L A0,D0
00000536                           677m     PRINT_REG D0,D1,D2,D3,A0
00000536  41FA 1585                678m     LEA OX(PC),A0
0000053A                           679mm     PRINT_STR A0,D1
0000053A                           680mm LOOP_10
0000053A  0C10 0000                681mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000053E  6700 0016                682mm     BEQ EXIT_10
00000542                           683mmm     PRINT_CHAR (A0)+,D1
00000542                           684mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000542                 TRUE      685mmm     IFEQ DEBUG
00000542  1239 00C00003            686mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000548  0801 0002                687mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
0000054C  67F4                     688mmm         BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
0000054E  13D8 00C00007            689mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000554                           690mmm     ENDC
00000554                           691mmm 
00000554                 FALSE     692mmm     IFNE DEBUG
00000554                           693mmm     ENDC
00000554                           694mmm 
00000554                           695mmm     ENDM
00000554  60E4                     696mm     BRA LOOP_10
00000556                           697mm EXIT_10
00000556                           698mm     ENDM
00000556  7607                     699m     MOVE.L #7,D3                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000558                           700m LOOP_9
00000558                           701mm     BIN2HEX D0,D2,A0
00000558  41FA 1522                702mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000055C  E998                     703mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000055E  1400                     704mm     MOVE.B D0,D2
00000560  0282 0000000F            705mm     ANDI.L #$F,D2
00000566  1430 2000                706mm     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
0000056A                           707mm     ENDM
0000056A                           708mm     PRINT_CHAR D2,D1
0000056A                           709mm WAIT_FOR_READY_13                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000056A                 TRUE      710mm     IFEQ DEBUG
0000056A  1239 00C00003            711mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000570  0801 0002                712mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000574  67F4                     713mm         BEQ WAIT_FOR_READY_13                       ; NO SPACE, CHECK AGAIN
00000576  13C2 00C00007            714mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000057C                           715mm     ENDC
0000057C                           716mm 
0000057C                 FALSE     717mm     IFNE DEBUG
0000057C                           718mm     ENDC
0000057C                           719mm 
0000057C                           720mm     ENDM
0000057C  57CB FFDA                721m     DBEQ D3,LOOP_9
00000580                           722m     ENDM
00000580                           723m     PRINT_CRLF D1,A0
00000580  41FA 1535                724m     LEA CRLF(PC),A0
00000584                           725mm     PRINT_STR A0,D1
00000584                           726mm LOOP_15
00000584  0C10 0000                727mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000588  6700 0016                728mm     BEQ EXIT_15
0000058C                           729mmm     PRINT_CHAR (A0)+,D1
0000058C                           730mmm WAIT_FOR_READY_16                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000058C                 TRUE      731mmm     IFEQ DEBUG
0000058C  1239 00C00003            732mmm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00000592  0801 0002                733mmm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000596  67F4                     734mmm         BEQ WAIT_FOR_READY_16                       ; NO SPACE, CHECK AGAIN
00000598  13D8 00C00007            735mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000059E                           736mmm     ENDC
0000059E                           737mmm 
0000059E                 FALSE     738mmm     IFNE DEBUG
0000059E                           739mmm     ENDC
0000059E                           740mmm 
0000059E                           741mmm     ENDM
0000059E  60E4                     742mm     BRA LOOP_15
000005A0                           743mm EXIT_15
000005A0                           744mm     ENDM
000005A0                           745m     ENDM
000005A0                           746  
000005A0  41FA 1352                747      LEA HELPPROMPT(PC),A0
000005A4                           748m     PRINT_STR A0,D3
000005A4                           749m LOOP_17
000005A4  0C10 0000                750m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005A8  6700 0016                751m     BEQ EXIT_17
000005AC                           752mm     PRINT_CHAR (A0)+,D3
000005AC                           753mm WAIT_FOR_READY_18                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005AC                 TRUE      754mm     IFEQ DEBUG
000005AC  1639 00C00003            755mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005B2  0803 0002                756mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005B6  67F4                     757mm         BEQ WAIT_FOR_READY_18                       ; NO SPACE, CHECK AGAIN
000005B8  13D8 00C00007            758mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005BE                           759mm     ENDC
000005BE                           760mm 
000005BE                 FALSE     761mm     IFNE DEBUG
000005BE                           762mm     ENDC
000005BE                           763mm 
000005BE                           764mm     ENDM
000005BE  60E4                     765m     BRA LOOP_17
000005C0                           766m EXIT_17
000005C0                           767m     ENDM
000005C0                           768  
000005C0                           769m     PRINT_CRLF D3,A0
000005C0  41FA 14F5                770m     LEA CRLF(PC),A0
000005C4                           771mm     PRINT_STR A0,D3
000005C4                           772mm LOOP_20
000005C4  0C10 0000                773mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005C8  6700 0016                774mm     BEQ EXIT_20
000005CC                           775mmm     PRINT_CHAR (A0)+,D3
000005CC                           776mmm WAIT_FOR_READY_21                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005CC                 TRUE      777mmm     IFEQ DEBUG
000005CC  1639 00C00003            778mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005D2  0803 0002                779mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000005D6  67F4                     780mmm         BEQ WAIT_FOR_READY_21                       ; NO SPACE, CHECK AGAIN
000005D8  13D8 00C00007            781mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000005DE                           782mmm     ENDC
000005DE                           783mmm 
000005DE                 FALSE     784mmm     IFNE DEBUG
000005DE                           785mmm     ENDC
000005DE                           786mmm 
000005DE                           787mmm     ENDM
000005DE  60E4                     788mm     BRA LOOP_20
000005E0                           789mm EXIT_20
000005E0                           790mm     ENDM
000005E0                           791m     ENDM
000005E0                           792  
000005E0  7E00                     793      MOVE.L #0,D7                                    ; address accumulator
000005E2                           794  
000005E2  13FC 0002 00E00001       795      MOVE.B #2,DISPLAY
000005EA                           796  MAIN_LOOP
000005EA  41FA 14CE                797      LEA PROMPT(PC),A0
000005EE                           798m     PRINT_STR A0,D3
000005EE                           799m LOOP_22
000005EE  0C10 0000                800m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000005F2  6700 0016                801m     BEQ EXIT_22
000005F6                           802mm     PRINT_CHAR (A0)+,D3
000005F6                           803mm WAIT_FOR_READY_23                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000005F6                 TRUE      804mm     IFEQ DEBUG
000005F6  1639 00C00003            805mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000005FC  0803 0002                806mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000600  67F4                     807mm         BEQ WAIT_FOR_READY_23                       ; NO SPACE, CHECK AGAIN
00000602  13D8 00C00007            808mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000608                           809mm     ENDC
00000608                           810mm 
00000608                 FALSE     811mm     IFNE DEBUG
00000608                           812mm     ENDC
00000608                           813mm 
00000608                           814mm     ENDM
00000608  60E4                     815m     BRA LOOP_22
0000060A                           816m EXIT_22
0000060A                           817m     ENDM
0000060A                           818  
0000060A                           819  GET_INPUT
0000060A                           820m     WAIT_CHAR D2,D3                                 ; fetch character from serial port -> D2
0000060A                           821m WAIT_FOR_READY_24                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000060A                 TRUE      822m     IFEQ DEBUG
0000060A  1639 00C00003            823m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000610  0803 0000                824m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000614  67F4                     825m         BEQ WAIT_FOR_READY_24                       ; NOTHING, CHECK AGAIN
00000616                           826m     ENDC
00000616                           827m 
00000616                           828mm     READ_CHAR D2
00000616                 TRUE      829mm     IFEQ DEBUG
00000616  1439 00C00007            830mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000061C                           831mm     ENDC
0000061C                 FALSE     832mm     IFNE DEBUG
0000061C                           833mm     ENDC
0000061C                           834mm 
0000061C  B43C 001B                835mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00000620  6700 FDDE                836mm     BEQ START
00000624                           837mm     ENDM
00000624                           838m 
00000624                 TRUE      839m     IFEQ DEBUG
00000624                           840mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000624                           841mm WAIT_FOR_READY_26                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000624                 TRUE      842mm     IFEQ DEBUG
00000624  1639 00C00003            843mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000062A  0803 0002                844mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000062E  67F4                     845mm         BEQ WAIT_FOR_READY_26                       ; NO SPACE, CHECK AGAIN
00000630  13C2 00C00007            846mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000636                           847mm     ENDC
00000636                           848mm 
00000636                 FALSE     849mm     IFNE DEBUG
00000636                           850mm     ENDC
00000636                           851mm 
00000636                           852mm     ENDM
00000636                           853m     ENDC
00000636                           854m     ENDM
00000636                           855  
00000636                           856      IF.B D2 <GE> #'0' AND.B D2 <LE> #'9' THEN
00000636  B43C 0030                857s     CMP.B   #'0',D2
0000063A  6D00 000E                858s     BLT _00000000
0000063E  B43C 0039                859s     CMP.B   #'9',D2
00000642  6E00 0006                860s     BGT _00000000
00000646  6000 111A                861          BRA HEX_DIGIT
0000064A                           862      ENDI
0000064A                           863s _00000000
0000064A                           864      IF.B D2 <GE> #'A' AND.B D2 <LE> #'F' THEN
0000064A  B43C 0041                865s     CMP.B   #'A',D2
0000064E  6D00 000E                866s     BLT _00000001
00000652  B43C 0046                867s     CMP.B   #'F',D2
00000656  6E00 0006                868s     BGT _00000001
0000065A  6000 1106                869          BRA HEX_DIGIT
0000065E                           870      ENDI
0000065E                           871s _00000001
0000065E                           872  
0000065E  B43C 0077                873      CMP.B #'w',D2
00000662  6700 019A                874      BEQ W
00000666                           875  
00000666  B43C 006C                876      CMP.B #'l',D2
0000066A  6700 0A30                877      BEQ L 
0000066E                           878  
0000066E  B43C 0070                879      CMP.B #'p',D2
00000672  6700 0D7C                880      BEQ P
00000676                           881  
00000676  B43C 006D                882      CMP.B #'m',D2
0000067A  6700 0F32                883      BEQ M
0000067E                           884  
0000067E                           885m     PRINT_CRLF D3,A0
0000067E  41FA 1437                886m     LEA CRLF(PC),A0
00000682                           887mm     PRINT_STR A0,D3
00000682                           888mm LOOP_28
00000682  0C10 0000                889mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000686  6700 0016                890mm     BEQ EXIT_28
0000068A                           891mmm     PRINT_CHAR (A0)+,D3
0000068A                           892mmm WAIT_FOR_READY_29                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000068A                 TRUE      893mmm     IFEQ DEBUG
0000068A  1639 00C00003            894mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000690  0803 0002                895mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000694  67F4                     896mmm         BEQ WAIT_FOR_READY_29                       ; NO SPACE, CHECK AGAIN
00000696  13D8 00C00007            897mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000069C                           898mmm     ENDC
0000069C                           899mmm 
0000069C                 FALSE     900mmm     IFNE DEBUG
0000069C                           901mmm     ENDC
0000069C                           902mmm 
0000069C                           903mmm     ENDM
0000069C  60E4                     904mm     BRA LOOP_28
0000069E                           905mm EXIT_28
0000069E                           906mm     ENDM
0000069E                           907m     ENDM
0000069E                           908   
0000069E  B43C 003F                909      CMP.B #'?',D2
000006A2  6700 0056                910      BEQ H
000006A6                           911   
000006A6  B43C 0076                912      CMP.B #'v',D2
000006AA  6700 0056                913      BEQ V
000006AE                           914      
000006AE  B43C 0072                915      CMP.B #'r',D2
000006B2  6700 0072                916      BEQ R
000006B6                           917  
000006B6  B43C 0073                918      CMP.B #'s',D2
000006BA  6700 01BE                919      BEQ S
000006BE                           920  
000006BE  B43C 0067                921      CMP.B #'g',D2
000006C2  6700 08E2                922      BEQ G   
000006C6                           923  
000006C6  B43C 007A                924      CMP.B #'z',D2
000006CA  6700 08E0                925      BEQ Z   
000006CE                           926  
000006CE  B43C 0078                927      CMP.B #'x',D2
000006D2  6700 0F72                928      BEQ X
000006D6                           929  
000006D6  41FA 1342                930      LEA HUH(PC),A0
000006DA                           931m     PRINT_STR A0,D3
000006DA                           932m LOOP_30
000006DA  0C10 0000                933m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000006DE  6700 0016                934m     BEQ EXIT_30
000006E2                           935mm     PRINT_CHAR (A0)+,D3
000006E2                           936mm WAIT_FOR_READY_31                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000006E2                 TRUE      937mm     IFEQ DEBUG
000006E2  1639 00C00003            938mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000006E8  0803 0002                939mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000006EC  67F4                     940mm         BEQ WAIT_FOR_READY_31                       ; NO SPACE, CHECK AGAIN
000006EE  13D8 00C00007            941mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000006F4                           942mm     ENDC
000006F4                           943mm 
000006F4                 FALSE     944mm     IFNE DEBUG
000006F4                           945mm     ENDC
000006F4                           946mm 
000006F4                           947mm     ENDM
000006F4  60E4                     948m     BRA LOOP_30
000006F6                           949m EXIT_30
000006F6                           950m     ENDM
000006F6                           951  
000006F6  6000 FEF2                952      BRA MAIN_LOOP
000006FA                           953  
000006FA                           954  ; commands
000006FA                           955  H
000006FA  41FA 120B                956      LEA HELP(PC),A0
000006FE  6000 0006                957      BRA PRINTSTR
00000702                           958  
00000702                           959  V
00000702  41FA 1413                960      LEA VERSION(PC),A0
00000706                           961  PRINTSTR
00000706                           962m     PRINT_STR A0,D3    
00000706                           963m LOOP_32
00000706  0C10 0000                964m     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000070A  6700 0016                965m     BEQ EXIT_32
0000070E                           966mm     PRINT_CHAR (A0)+,D3
0000070E                           967mm WAIT_FOR_READY_33                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000070E                 TRUE      968mm     IFEQ DEBUG
0000070E  1639 00C00003            969mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000714  0803 0002                970mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000718  67F4                     971mm         BEQ WAIT_FOR_READY_33                       ; NO SPACE, CHECK AGAIN
0000071A  13D8 00C00007            972mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000720                           973mm     ENDC
00000720                           974mm 
00000720                 FALSE     975mm     IFNE DEBUG
00000720                           976mm     ENDC
00000720                           977mm 
00000720                           978mm     ENDM
00000720  60E4                     979m     BRA LOOP_32
00000722                           980m EXIT_32
00000722                           981m     ENDM
00000722  6000 FEC6                982      BRA MAIN_LOOP
00000726                           983  
00000726                           984  R
00000726  2047                     985      MOVE.L D7,A0                                    ; address accumulator -> address register
00000728  7E00                     986      MOVE.L #0,D7                                    ;clear the now used address accumulator
0000072A  2410                     987      MOVE.L (A0),D2                                  ; read the memory and print it
0000072C                           988m     PRINT_REG D2,D3,D4,D5,A0
0000072C  41FA 138F                989m     LEA OX(PC),A0
00000730                           990mm     PRINT_STR A0,D3
00000730                           991mm LOOP_35
00000730  0C10 0000                992mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000734  6700 0016                993mm     BEQ EXIT_35
00000738                           994mmm     PRINT_CHAR (A0)+,D3
00000738                           995mmm WAIT_FOR_READY_36                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000738                 TRUE      996mmm     IFEQ DEBUG
00000738  1639 00C00003            997mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000073E  0803 0002                998mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000742  67F4                     999mmm         BEQ WAIT_FOR_READY_36                       ; NO SPACE, CHECK AGAIN
00000744  13D8 00C00007           1000mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000074A                          1001mmm     ENDC
0000074A                          1002mmm 
0000074A                 FALSE    1003mmm     IFNE DEBUG
0000074A                          1004mmm     ENDC
0000074A                          1005mmm 
0000074A                          1006mmm     ENDM
0000074A  60E4                    1007mm     BRA LOOP_35
0000074C                          1008mm EXIT_35
0000074C                          1009mm     ENDM
0000074C  7A07                    1010m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000074E                          1011m LOOP_34
0000074E                          1012mm     BIN2HEX D2,D4,A0
0000074E  41FA 132C               1013mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000752  E99A                    1014mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000754  1802                    1015mm     MOVE.B D2,D4
00000756  0284 0000000F           1016mm     ANDI.L #$F,D4
0000075C  1830 4000               1017mm     MOVE.B 0(A0,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00000760                          1018mm     ENDM
00000760                          1019mm     PRINT_CHAR D4,D3
00000760                          1020mm WAIT_FOR_READY_38                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000760                 TRUE     1021mm     IFEQ DEBUG
00000760  1639 00C00003           1022mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000766  0803 0002               1023mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000076A  67F4                    1024mm         BEQ WAIT_FOR_READY_38                       ; NO SPACE, CHECK AGAIN
0000076C  13C4 00C00007           1025mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000772                          1026mm     ENDC
00000772                          1027mm 
00000772                 FALSE    1028mm     IFNE DEBUG
00000772                          1029mm     ENDC
00000772                          1030mm 
00000772                          1031mm     ENDM
00000772  57CD FFDA               1032m     DBEQ D5,LOOP_34
00000776                          1033m     ENDM
00000776                          1034      
00000776                          1035m     PRINT_CHAR #32,D3
00000776                          1036m WAIT_FOR_READY_39                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000776                 TRUE     1037m     IFEQ DEBUG
00000776  1639 00C00003           1038m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000077C  0803 0002               1039m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000780  67F4                    1040m         BEQ WAIT_FOR_READY_39                       ; NO SPACE, CHECK AGAIN
00000782  13FC 0020 00C00007      1041m         MOVE.B #32,DUART_TXA                            ; SEND THE NEXT CHARACTER
0000078A                          1042m     ENDC
0000078A                          1043m 
0000078A                 FALSE    1044m     IFNE DEBUG
0000078A                          1045m     ENDC
0000078A                          1046m 
0000078A                          1047m     ENDM
0000078A                          1048  
0000078A  E19A                    1049      ROL.L #8,D2
0000078C                          1050m     PRINT_CHAR D2,D3
0000078C                          1051m WAIT_FOR_READY_40                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000078C                 TRUE     1052m     IFEQ DEBUG
0000078C  1639 00C00003           1053m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000792  0803 0002               1054m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000796  67F4                    1055m         BEQ WAIT_FOR_READY_40                       ; NO SPACE, CHECK AGAIN
00000798  13C2 00C00007           1056m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000079E                          1057m     ENDC
0000079E                          1058m 
0000079E                 FALSE    1059m     IFNE DEBUG
0000079E                          1060m     ENDC
0000079E                          1061m 
0000079E                          1062m     ENDM
0000079E  E19A                    1063      ROL.L #8,D2
000007A0                          1064m     PRINT_CHAR D2,D3
000007A0                          1065m WAIT_FOR_READY_41                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007A0                 TRUE     1066m     IFEQ DEBUG
000007A0  1639 00C00003           1067m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007A6  0803 0002               1068m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007AA  67F4                    1069m         BEQ WAIT_FOR_READY_41                       ; NO SPACE, CHECK AGAIN
000007AC  13C2 00C00007           1070m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007B2                          1071m     ENDC
000007B2                          1072m 
000007B2                 FALSE    1073m     IFNE DEBUG
000007B2                          1074m     ENDC
000007B2                          1075m 
000007B2                          1076m     ENDM
000007B2  E19A                    1077      ROL.L #8,D2
000007B4                          1078m     PRINT_CHAR D2,D3
000007B4                          1079m WAIT_FOR_READY_42                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007B4                 TRUE     1080m     IFEQ DEBUG
000007B4  1639 00C00003           1081m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007BA  0803 0002               1082m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007BE  67F4                    1083m         BEQ WAIT_FOR_READY_42                       ; NO SPACE, CHECK AGAIN
000007C0  13C2 00C00007           1084m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007C6                          1085m     ENDC
000007C6                          1086m 
000007C6                 FALSE    1087m     IFNE DEBUG
000007C6                          1088m     ENDC
000007C6                          1089m 
000007C6                          1090m     ENDM
000007C6  E19A                    1091      ROL.L #8,D2
000007C8                          1092m     PRINT_CHAR D2,D3
000007C8                          1093m WAIT_FOR_READY_43                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007C8                 TRUE     1094m     IFEQ DEBUG
000007C8  1639 00C00003           1095m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007CE  0803 0002               1096m         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007D2  67F4                    1097m         BEQ WAIT_FOR_READY_43                       ; NO SPACE, CHECK AGAIN
000007D4  13C2 00C00007           1098m         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
000007DA                          1099m     ENDC
000007DA                          1100m 
000007DA                 FALSE    1101m     IFNE DEBUG
000007DA                          1102m     ENDC
000007DA                          1103m 
000007DA                          1104m     ENDM
000007DA                          1105  
000007DA                          1106m     PRINT_CRLF D3,A0
000007DA  41FA 12DB               1107m     LEA CRLF(PC),A0
000007DE                          1108mm     PRINT_STR A0,D3
000007DE                          1109mm LOOP_45
000007DE  0C10 0000               1110mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000007E2  6700 0016               1111mm     BEQ EXIT_45
000007E6                          1112mmm     PRINT_CHAR (A0)+,D3
000007E6                          1113mmm WAIT_FOR_READY_46                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000007E6                 TRUE     1114mmm     IFEQ DEBUG
000007E6  1639 00C00003           1115mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000007EC  0803 0002               1116mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000007F0  67F4                    1117mmm         BEQ WAIT_FOR_READY_46                       ; NO SPACE, CHECK AGAIN
000007F2  13D8 00C00007           1118mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000007F8                          1119mmm     ENDC
000007F8                          1120mmm 
000007F8                 FALSE    1121mmm     IFNE DEBUG
000007F8                          1122mmm     ENDC
000007F8                          1123mmm 
000007F8                          1124mmm     ENDM
000007F8  60E4                    1125mm     BRA LOOP_45
000007FA                          1126mm EXIT_45
000007FA                          1127mm     ENDM
000007FA                          1128m     ENDM
000007FA                          1129      
000007FA  6000 FDEE               1130      BRA MAIN_LOOP
000007FE                          1131  
000007FE                          1132  W
000007FE                          1133      FOR D6 = #0 TO #7 DO                                ; read 4 bytes
000007FE  3C3C 0000               1134s     MOVE.W  #0,D6
00000802  6000 0046               1135s     BRA _20000005
00000806                          1136s _20000004
00000806  E98D                    1137          LSL.L #4,D5                                     ; make what we have so far more significant
00000808                          1138m         WAIT_CHAR D2,D3                                 ; next character -> D2
00000808                          1139m WAIT_FOR_READY_47                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000808                 TRUE     1140m     IFEQ DEBUG
00000808  1639 00C00003           1141m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000080E  0803 0000               1142m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00000812  67F4                    1143m         BEQ WAIT_FOR_READY_47                       ; NOTHING, CHECK AGAIN
00000814                          1144m     ENDC
00000814                          1145m 
00000814                          1146mm     READ_CHAR D2
00000814                 TRUE     1147mm     IFEQ DEBUG
00000814  1439 00C00007           1148mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000081A                          1149mm     ENDC
0000081A                 FALSE    1150mm     IFNE DEBUG
0000081A                          1151mm     ENDC
0000081A                          1152mm 
0000081A  B43C 001B               1153mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
0000081E  6700 FBE0               1154mm     BEQ START
00000822                          1155mm     ENDM
00000822                          1156m 
00000822                 TRUE     1157m     IFEQ DEBUG
00000822                          1158mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00000822                          1159mm WAIT_FOR_READY_49                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000822                 TRUE     1160mm     IFEQ DEBUG
00000822  1639 00C00003           1161mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000828  0803 0002               1162mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000082C  67F4                    1163mm         BEQ WAIT_FOR_READY_49                       ; NO SPACE, CHECK AGAIN
0000082E  13C2 00C00007           1164mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000834                          1165mm     ENDC
00000834                          1166mm 
00000834                 FALSE    1167mm     IFNE DEBUG
00000834                          1168mm     ENDC
00000834                          1169mm 
00000834                          1170mm     ENDM
00000834                          1171m     ENDC
00000834                          1172m     ENDM
00000834                          1173m         HEX2BIN D2,D2,A0                                ; convert to binary -> D2
00000834  41FA 1256               1174m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00000838  0402 0030               1175m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000083C  C4BC 000000FF           1176m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00000842  1430 2000               1177m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00000846                          1178m     ENDM
00000846  8A02                    1179          OR.B D2,D5
00000848                          1180      ENDF
00000848  5246                    1181s     ADD.W   #1,D6
0000084A                          1182s _20000005
0000084A  BC7C 0007               1183s     CMP.W   #7,D6
0000084E  6FB6                    1184s     BLE _20000004
00000850                          1185  
00000850                          1186m     PRINT_CRLF D3,A0
00000850  41FA 1265               1187m     LEA CRLF(PC),A0
00000854                          1188mm     PRINT_STR A0,D3
00000854                          1189mm LOOP_52
00000854  0C10 0000               1190mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
00000858  6700 0016               1191mm     BEQ EXIT_52
0000085C                          1192mmm     PRINT_CHAR (A0)+,D3
0000085C                          1193mmm WAIT_FOR_READY_53                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000085C                 TRUE     1194mmm     IFEQ DEBUG
0000085C  1639 00C00003           1195mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00000862  0803 0002               1196mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00000866  67F4                    1197mmm         BEQ WAIT_FOR_READY_53                       ; NO SPACE, CHECK AGAIN
00000868  13D8 00C00007           1198mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000086E                          1199mmm     ENDC
0000086E                          1200mmm 
0000086E                 FALSE    1201mmm     IFNE DEBUG
0000086E                          1202mmm     ENDC
0000086E                          1203mmm 
0000086E                          1204mmm     ENDM
0000086E  60E4                    1205mm     BRA LOOP_52
00000870                          1206mm EXIT_52
00000870                          1207mm     ENDM
00000870                          1208m     ENDM
00000870                          1209  
00000870  2047                    1210      MOVE.L D7,A0                                    ; address accumulator -> address register
00000872  7E00                    1211      MOVE.L #0,D7                                    ; clear the now used address accumulator
00000874                          1212  
00000874  2085                    1213      MOVE.L D5,(A0)                                  ; write the data
00000876                          1214  
00000876  6000 FD72               1215      BRA MAIN_LOOP
0000087A                          1216  
0000087A                          1217  ; register map for S
0000087A                          1218  ; A0 - start address
0000087A                          1219  ; A1 - offset
0000087A                          1220  ; A2 - next address to write
0000087A                          1221  ; A3 - next location (jmp)
0000087A                          1222  ; A4 - Working Address Register
0000087A                          1223  ; D0 - record count
0000087A                          1224  ; D1 - 'S', record type, data byte, done flag (0x00000000 = continue, 0xFFFFFFFF = done)
0000087A                          1225  ; D2 - checksum
0000087A                          1226  ; D3 - data byte count
0000087A                          1227  ; D4 - read address, moved into A2
0000087A                          1228  ; D5 - temp
0000087A                          1229  ; D6 - temp
0000087A                          1230  ; D7 - temp
0000087A                          1231  S
0000087A  2078 0000               1232      MOVE.L 0,A0                                     ; start address -> A0
0000087E  2247                    1233      MOVE.L D7,A1                                    ; grab the address accumulator (offset) into A1
00000880                          1234      
00000880  7000                    1235      MOVE.L #0,D0                                    ; count of records read -> D0
00000882                          1236          
00000882                          1237  WAIT_FOR_SRECORD                                    ; wait for the start of a record, indicated by 'S'
00000882                          1238m     DOWNLOAD D1
00000882                          1239m WAIT_FOR_READY_54                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000882                          1240m 
00000882  1239 00C00003           1241m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
00000888  0801 0000               1242m     BTST #0,D1                                      ; CHECK FOR CHARACTER
0000088C  6700 0010               1243m     BEQ CONTINUE_54                                 ; NOTHING, CONTINUE
00000890                          1244m 
00000890                          1245mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
00000890                 TRUE     1246mm     IFEQ DEBUG
00000890  1239 00C00007           1247mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
00000896                          1248mm     ENDC
00000896                 FALSE    1249mm     IFNE DEBUG
00000896                          1250mm     ENDC
00000896                          1251mm 
00000896  B23C 001B               1252mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
0000089A  6700 FB64               1253mm     BEQ START
0000089E                          1254mm     ENDM
0000089E                          1255m CONTINUE_54
0000089E  1239 00C00013           1256m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000008A4  0801 0000               1257m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000008A8  67D8                    1258m     BEQ WAIT_FOR_READY_54                           ; NOTHING, CHECK AGAIN
000008AA                          1259m     
000008AA  1239 00C00017           1260m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
000008B0  13C1 00E00001           1261m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
000008B6                          1262m 
000008B6                          1263m     ENDM
000008B6  B23C 0053               1264      CMP.B #'S',D1                                   ; found S?
000008BA  66C6                    1265      BNE WAIT_FOR_SRECORD                            ; nope, keep waiting
000008BC                          1266      
000008BC                          1267m     PRINT_CHAR #'S',D5                              ; print the S
000008BC                          1268m WAIT_FOR_READY_56                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008BC                 TRUE     1269m     IFEQ DEBUG
000008BC  1A39 00C00003           1270m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000008C2  0805 0002               1271m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000008C6  67F4                    1272m         BEQ WAIT_FOR_READY_56                       ; NO SPACE, CHECK AGAIN
000008C8  13FC 0053 00C00007      1273m         MOVE.B #'S',DUART_TXA                           ; SEND THE NEXT CHARACTER
000008D0                          1274m     ENDC
000008D0                          1275m 
000008D0                 FALSE    1276m     IFNE DEBUG
000008D0                          1277m     ENDC
000008D0                          1278m 
000008D0                          1279m     ENDM
000008D0  5280                    1280      ADD.L #1,D0                                     ; read another S record, increment count
000008D2                          1281      
000008D2                          1282m     DOWNLOAD D1                                     ; read the record identifier and echo it back
000008D2                          1283m WAIT_FOR_READY_57                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000008D2                          1284m 
000008D2  1239 00C00003           1285m     MOVE.B DUART_SRA,D1                             ; CHECK FOR COMMAND
000008D8  0801 0000               1286m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000008DC  6700 0010               1287m     BEQ CONTINUE_57                                 ; NOTHING, CONTINUE
000008E0                          1288m 
000008E0                          1289mm     READ_CHAR D1                                    ; WE're not going to do anything with it, just check for escape
000008E0                 TRUE     1290mm     IFEQ DEBUG
000008E0  1239 00C00007           1291mm         MOVE.B DUART_RXA,D1                         ; GOT A CHARACTER, READ IT
000008E6                          1292mm     ENDC
000008E6                 FALSE    1293mm     IFNE DEBUG
000008E6                          1294mm     ENDC
000008E6                          1295mm 
000008E6  B23C 001B               1296mm     CMP.B #$1B,D1                                   ; CHECK FOR ESCAPE AND GO TO START
000008EA  6700 FB14               1297mm     BEQ START
000008EE                          1298mm     ENDM
000008EE                          1299m CONTINUE_57
000008EE  1239 00C00013           1300m     MOVE.B DUART_SRB,D1                             ; READ DOWNLOAD STATUS REGISTER
000008F4  0801 0000               1301m     BTST #0,D1                                      ; CHECK FOR CHARACTER
000008F8  67D8                    1302m     BEQ WAIT_FOR_READY_57                           ; NOTHING, CHECK AGAIN
000008FA                          1303m     
000008FA  1239 00C00017           1304m     MOVE.B DUART_RXB,D1                             ; GOT A CHARACTER, READ IT
00000900  13C1 00E00001           1305m     MOVE.B D1,DISPLAY                               ; ECHO TO THE DISPLAY
00000906                          1306m 
00000906                          1307m     ENDM
00000906                          1308m     PRINT_CHAR D1,D5
00000906                          1309m WAIT_FOR_READY_59                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000906                 TRUE     1310m     IFEQ DEBUG
00000906  1A39 00C00003           1311m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
0000090C  0805 0002               1312m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000910  67F4                    1313m         BEQ WAIT_FOR_READY_59                       ; NO SPACE, CHECK AGAIN
00000912  13C1 00C00007           1314m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000918                          1315m     ENDC
00000918                          1316m 
00000918                 FALSE    1317m     IFNE DEBUG
00000918                          1318m     ENDC
00000918                          1319m 
00000918                          1320m     ENDM
00000918                          1321  
00000918  7400                    1322      MOVE.L #0,D2                                    ; clear the checksum
0000091A                          1323  
0000091A                          1324m     DOWNLOAD_BYTE D3,D5,D6,D7,D2,A4
0000091A  1E3C 0002               1325m     MOVE.B #2,D7
0000091E                          1326m     WHILE.B D7 <GT> 0 DO
0000091E                          1327ms _10000000
0000091E  BE38 0000               1328ms     CMP.B   0,D7
00000922  6F00 0062               1329ms     BLE _10000001
00000926  E98B                    1330m         LSL.L #4,D3                                 ; IT's OK to do this first, because we are either starting from 0, 
00000928                          1331mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000928                          1332mm WAIT_FOR_READY_61                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000928                          1333mm 
00000928  1A39 00C00003           1334mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
0000092E  0805 0000               1335mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000932  6700 0010               1336mm     BEQ CONTINUE_61                                 ; NOTHING, CONTINUE
00000936                          1337mm 
00000936                          1338mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000936                 TRUE     1339mmm     IFEQ DEBUG
00000936  1A39 00C00007           1340mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
0000093C                          1341mmm     ENDC
0000093C                 FALSE    1342mmm     IFNE DEBUG
0000093C                          1343mmm     ENDC
0000093C                          1344mmm 
0000093C  BA3C 001B               1345mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000940  6700 FABE               1346mmm     BEQ START
00000944                          1347mmm     ENDM
00000944                          1348mm CONTINUE_61
00000944  1A39 00C00013           1349mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
0000094A  0805 0000               1350mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
0000094E  67D8                    1351mm     BEQ WAIT_FOR_READY_61                           ; NOTHING, CHECK AGAIN
00000950                          1352mm     
00000950  1A39 00C00017           1353mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000956  13C5 00E00001           1354mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
0000095C                          1355mm 
0000095C                          1356mm     ENDM
0000095C                          1357mm         PRINT_CHAR D5,D6
0000095C                          1358mm WAIT_FOR_READY_63                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000095C                 TRUE     1359mm     IFEQ DEBUG
0000095C  1C39 00C00003           1360mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000962  0806 0002               1361mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000966  67F4                    1362mm         BEQ WAIT_FOR_READY_63                       ; NO SPACE, CHECK AGAIN
00000968  13C5 00C00007           1363mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000096E                          1364mm     ENDC
0000096E                          1365mm 
0000096E                 FALSE    1366mm     IFNE DEBUG
0000096E                          1367mm     ENDC
0000096E                          1368mm 
0000096E                          1369mm     ENDM
0000096E                          1370mm         HEX2BIN D5,D5,A4
0000096E  49FA 111C               1371mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000972  0405 0030               1372mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000976  CABC 000000FF           1373mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
0000097C  1A34 5000               1374mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000980                          1375mm     ENDM
00000980  8605                    1376m         OR.B D5,D3
00000982  5307                    1377m         SUB.B #1,D7
00000984                          1378m     ENDW
00000984  6098                    1379ms     BRA _10000000
00000986                          1380ms _10000001
00000986                          1381m 
00000986  7A00                    1382m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000988  1A03                    1383m     MOVE.B D3,D5
0000098A  D483                    1384m     ADD.L D3,D2
0000098C                          1385m 
0000098C                          1386m     ENDM
0000098C                          1387  
0000098C                          1388      IF.B D1 <EQ> #'0' THEN.L                        ; header, just ignore it
0000098C  B23C 0030               1389s     CMP.B   #'0',D1
00000990  6600 002A               1390s     BNE.L   _00000002
00000994                          1391m         PRINT_CRLF D5,A4
00000994  49FA 1121               1392m     LEA CRLF(PC),A4
00000998                          1393mm     PRINT_STR A4,D5
00000998                          1394mm LOOP_66
00000998  0C14 0000               1395mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
0000099C  6700 0016               1396mm     BEQ EXIT_66
000009A0                          1397mmm     PRINT_CHAR (A4)+,D5
000009A0                          1398mmm WAIT_FOR_READY_67                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009A0                 TRUE     1399mmm     IFEQ DEBUG
000009A0  1A39 00C00003           1400mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
000009A6  0805 0002               1401mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
000009AA  67F4                    1402mmm         BEQ WAIT_FOR_READY_67                       ; NO SPACE, CHECK AGAIN
000009AC  13DC 00C00007           1403mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000009B2                          1404mmm     ENDC
000009B2                          1405mmm 
000009B2                 FALSE    1406mmm     IFNE DEBUG
000009B2                          1407mmm     ENDC
000009B2                          1408mmm 
000009B2                          1409mmm     ENDM
000009B2  60E4                    1410mm     BRA LOOP_66
000009B4                          1411mm EXIT_66
000009B4                          1412mm     ENDM
000009B4                          1413m     ENDM
000009B4  6000 FECC               1414          BRA WAIT_FOR_SRECORD
000009B8                          1415      ELSE
000009B8  6000 03DE               1416s     BRA _00000003
000009BC                          1417s _00000002
000009BC                          1418          IF.B D1 <EQ> #'1' OR.B D1 <EQ> #'2' THEN.L  ; 16 or 24 bit address data record
000009BC  B23C 0031               1419s     CMP.B   #'1',D1
000009C0  6708                    1420s     BEQ.S   _00000004
000009C2  B23C 0032               1421s     CMP.B   #'2',D1
000009C6  6600 01F0               1422s     BNE.L   _00000005
000009CA                          1423s _00000004
000009CA  5783                    1424              SUB.L #3,D3                             ; subtract three bytes for 16 bit address and 1 byte checksum
000009CC                          1425  
000009CC  7800                    1426              MOVE.L #0,D4                            ; read two bytes of address
000009CE                          1427m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; first byte                                    
000009CE  1E3C 0002               1428m     MOVE.B #2,D7
000009D2                          1429m     WHILE.B D7 <GT> 0 DO
000009D2                          1430ms _10000002
000009D2  BE38 0000               1431ms     CMP.B   0,D7
000009D6  6F00 0062               1432ms     BLE _10000003
000009DA  E98C                    1433m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
000009DC                          1434mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
000009DC                          1435mm WAIT_FOR_READY_69                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000009DC                          1436mm 
000009DC  1A39 00C00003           1437mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
000009E2  0805 0000               1438mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
000009E6  6700 0010               1439mm     BEQ CONTINUE_69                                 ; NOTHING, CONTINUE
000009EA                          1440mm 
000009EA                          1441mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
000009EA                 TRUE     1442mmm     IFEQ DEBUG
000009EA  1A39 00C00007           1443mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
000009F0                          1444mmm     ENDC
000009F0                 FALSE    1445mmm     IFNE DEBUG
000009F0                          1446mmm     ENDC
000009F0                          1447mmm 
000009F0  BA3C 001B               1448mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
000009F4  6700 FA0A               1449mmm     BEQ START
000009F8                          1450mmm     ENDM
000009F8                          1451mm CONTINUE_69
000009F8  1A39 00C00013           1452mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
000009FE  0805 0000               1453mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A02  67D8                    1454mm     BEQ WAIT_FOR_READY_69                           ; NOTHING, CHECK AGAIN
00000A04                          1455mm     
00000A04  1A39 00C00017           1456mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A0A  13C5 00E00001           1457mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A10                          1458mm 
00000A10                          1459mm     ENDM
00000A10                          1460mm         PRINT_CHAR D5,D6
00000A10                          1461mm WAIT_FOR_READY_71                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A10                 TRUE     1462mm     IFEQ DEBUG
00000A10  1C39 00C00003           1463mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A16  0806 0002               1464mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A1A  67F4                    1465mm         BEQ WAIT_FOR_READY_71                       ; NO SPACE, CHECK AGAIN
00000A1C  13C5 00C00007           1466mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A22                          1467mm     ENDC
00000A22                          1468mm 
00000A22                 FALSE    1469mm     IFNE DEBUG
00000A22                          1470mm     ENDC
00000A22                          1471mm 
00000A22                          1472mm     ENDM
00000A22                          1473mm         HEX2BIN D5,D5,A4
00000A22  49FA 1068               1474mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A26  0405 0030               1475mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A2A  CABC 000000FF           1476mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000A30  1A34 5000               1477mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000A34                          1478mm     ENDM
00000A34  8805                    1479m         OR.B D5,D4
00000A36  5307                    1480m         SUB.B #1,D7
00000A38                          1481m     ENDW
00000A38  6098                    1482ms     BRA _10000002
00000A3A                          1483ms _10000003
00000A3A                          1484m 
00000A3A  7A00                    1485m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000A3C  1A04                    1486m     MOVE.B D4,D5
00000A3E  D484                    1487m     ADD.L D4,D2
00000A40                          1488m 
00000A40                          1489m     ENDM
00000A40                          1490m             DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4         ; second one
00000A40  1E3C 0002               1491m     MOVE.B #2,D7
00000A44                          1492m     WHILE.B D7 <GT> 0 DO
00000A44                          1493ms _10000004
00000A44  BE38 0000               1494ms     CMP.B   0,D7
00000A48  6F00 0062               1495ms     BLE _10000005
00000A4C  E98C                    1496m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000A4E                          1497mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000A4E                          1498mm WAIT_FOR_READY_74                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A4E                          1499mm 
00000A4E  1A39 00C00003           1500mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000A54  0805 0000               1501mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A58  6700 0010               1502mm     BEQ CONTINUE_74                                 ; NOTHING, CONTINUE
00000A5C                          1503mm 
00000A5C                          1504mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000A5C                 TRUE     1505mmm     IFEQ DEBUG
00000A5C  1A39 00C00007           1506mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000A62                          1507mmm     ENDC
00000A62                 FALSE    1508mmm     IFNE DEBUG
00000A62                          1509mmm     ENDC
00000A62                          1510mmm 
00000A62  BA3C 001B               1511mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000A66  6700 F998               1512mmm     BEQ START
00000A6A                          1513mmm     ENDM
00000A6A                          1514mm CONTINUE_74
00000A6A  1A39 00C00013           1515mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000A70  0805 0000               1516mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000A74  67D8                    1517mm     BEQ WAIT_FOR_READY_74                           ; NOTHING, CHECK AGAIN
00000A76                          1518mm     
00000A76  1A39 00C00017           1519mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000A7C  13C5 00E00001           1520mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000A82                          1521mm 
00000A82                          1522mm     ENDM
00000A82                          1523mm         PRINT_CHAR D5,D6
00000A82                          1524mm WAIT_FOR_READY_76                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000A82                 TRUE     1525mm     IFEQ DEBUG
00000A82  1C39 00C00003           1526mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000A88  0806 0002               1527mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000A8C  67F4                    1528mm         BEQ WAIT_FOR_READY_76                       ; NO SPACE, CHECK AGAIN
00000A8E  13C5 00C00007           1529mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000A94                          1530mm     ENDC
00000A94                          1531mm 
00000A94                 FALSE    1532mm     IFNE DEBUG
00000A94                          1533mm     ENDC
00000A94                          1534mm 
00000A94                          1535mm     ENDM
00000A94                          1536mm         HEX2BIN D5,D5,A4
00000A94  49FA 0FF6               1537mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000A98  0405 0030               1538mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000A9C  CABC 000000FF           1539mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000AA2  1A34 5000               1540mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000AA6                          1541mm     ENDM
00000AA6  8805                    1542m         OR.B D5,D4
00000AA8  5307                    1543m         SUB.B #1,D7
00000AAA                          1544m     ENDW
00000AAA  6098                    1545ms     BRA _10000004
00000AAC                          1546ms _10000005
00000AAC                          1547m 
00000AAC  7A00                    1548m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000AAE  1A04                    1549m     MOVE.B D4,D5
00000AB0  D484                    1550m     ADD.L D4,D2
00000AB2                          1551m 
00000AB2                          1552m     ENDM
00000AB2                          1553  
00000AB2                          1554              IF.B D1 <EQ> #'2'  THEN.L               ; 24 bit address data record, read another byte
00000AB2  B23C 0032               1555s     CMP.B   #'2',D1
00000AB6  6600 0076               1556s     BNE.L   _00000006
00000ABA  5383                    1557                  SUB.L #1,D3                         ; subtract an extra bytes for 24 bit address    
00000ABC                          1558m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; 3rd byte
00000ABC  1E3C 0002               1559m     MOVE.B #2,D7
00000AC0                          1560m     WHILE.B D7 <GT> 0 DO
00000AC0                          1561ms _10000006
00000AC0  BE38 0000               1562ms     CMP.B   0,D7
00000AC4  6F00 0062               1563ms     BLE _10000007
00000AC8  E98C                    1564m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000ACA                          1565mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000ACA                          1566mm WAIT_FOR_READY_79                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ACA                          1567mm 
00000ACA  1A39 00C00003           1568mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000AD0  0805 0000               1569mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AD4  6700 0010               1570mm     BEQ CONTINUE_79                                 ; NOTHING, CONTINUE
00000AD8                          1571mm 
00000AD8                          1572mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000AD8                 TRUE     1573mmm     IFEQ DEBUG
00000AD8  1A39 00C00007           1574mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000ADE                          1575mmm     ENDC
00000ADE                 FALSE    1576mmm     IFNE DEBUG
00000ADE                          1577mmm     ENDC
00000ADE                          1578mmm 
00000ADE  BA3C 001B               1579mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000AE2  6700 F91C               1580mmm     BEQ START
00000AE6                          1581mmm     ENDM
00000AE6                          1582mm CONTINUE_79
00000AE6  1A39 00C00013           1583mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000AEC  0805 0000               1584mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000AF0  67D8                    1585mm     BEQ WAIT_FOR_READY_79                           ; NOTHING, CHECK AGAIN
00000AF2                          1586mm     
00000AF2  1A39 00C00017           1587mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000AF8  13C5 00E00001           1588mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000AFE                          1589mm 
00000AFE                          1590mm     ENDM
00000AFE                          1591mm         PRINT_CHAR D5,D6
00000AFE                          1592mm WAIT_FOR_READY_81                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000AFE                 TRUE     1593mm     IFEQ DEBUG
00000AFE  1C39 00C00003           1594mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B04  0806 0002               1595mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B08  67F4                    1596mm         BEQ WAIT_FOR_READY_81                       ; NO SPACE, CHECK AGAIN
00000B0A  13C5 00C00007           1597mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B10                          1598mm     ENDC
00000B10                          1599mm 
00000B10                 FALSE    1600mm     IFNE DEBUG
00000B10                          1601mm     ENDC
00000B10                          1602mm 
00000B10                          1603mm     ENDM
00000B10                          1604mm         HEX2BIN D5,D5,A4
00000B10  49FA 0F7A               1605mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B14  0405 0030               1606mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B18  CABC 000000FF           1607mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B1E  1A34 5000               1608mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000B22                          1609mm     ENDM
00000B22  8805                    1610m         OR.B D5,D4
00000B24  5307                    1611m         SUB.B #1,D7
00000B26                          1612m     ENDW
00000B26  6098                    1613ms     BRA _10000006
00000B28                          1614ms _10000007
00000B28                          1615m 
00000B28  7A00                    1616m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000B2A  1A04                    1617m     MOVE.B D4,D5
00000B2C  D484                    1618m     ADD.L D4,D2
00000B2E                          1619m 
00000B2E                          1620m     ENDM
00000B2E                          1621              ENDI
00000B2E                          1622s _00000006
00000B2E                          1623  
00000B2E  2444                    1624              MOVE.L D4,A2                            ; put the address in an address register
00000B30  D5C9                    1625              ADD.L A1,A2                             ; add in the offset
00000B32                          1626  
00000B32                          1627              WHILE.B D3 <GT> #0 DO                   ; read the data bytes
00000B32                          1628s _10000008
00000B32  B63C 0000               1629s     CMP.B   #0,D3
00000B36  6F00 007A               1630s     BLE _10000009
00000B3A                          1631m                 DOWNLOAD_BYTE D1,D5,D6,D7,D2,A4     ; read it
00000B3A  1E3C 0002               1632m     MOVE.B #2,D7
00000B3E                          1633m     WHILE.B D7 <GT> 0 DO
00000B3E                          1634ms _1000000A
00000B3E  BE38 0000               1635ms     CMP.B   0,D7
00000B42  6F00 0062               1636ms     BLE _1000000B
00000B46  E989                    1637m         LSL.L #4,D1                                 ; IT's OK to do this first, because we are either starting from 0, 
00000B48                          1638mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000B48                          1639mm WAIT_FOR_READY_84                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B48                          1640mm 
00000B48  1A39 00C00003           1641mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000B4E  0805 0000               1642mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B52  6700 0010               1643mm     BEQ CONTINUE_84                                 ; NOTHING, CONTINUE
00000B56                          1644mm 
00000B56                          1645mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000B56                 TRUE     1646mmm     IFEQ DEBUG
00000B56  1A39 00C00007           1647mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000B5C                          1648mmm     ENDC
00000B5C                 FALSE    1649mmm     IFNE DEBUG
00000B5C                          1650mmm     ENDC
00000B5C                          1651mmm 
00000B5C  BA3C 001B               1652mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000B60  6700 F89E               1653mmm     BEQ START
00000B64                          1654mmm     ENDM
00000B64                          1655mm CONTINUE_84
00000B64  1A39 00C00013           1656mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000B6A  0805 0000               1657mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000B6E  67D8                    1658mm     BEQ WAIT_FOR_READY_84                           ; NOTHING, CHECK AGAIN
00000B70                          1659mm     
00000B70  1A39 00C00017           1660mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000B76  13C5 00E00001           1661mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000B7C                          1662mm 
00000B7C                          1663mm     ENDM
00000B7C                          1664mm         PRINT_CHAR D5,D6
00000B7C                          1665mm WAIT_FOR_READY_86                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000B7C                 TRUE     1666mm     IFEQ DEBUG
00000B7C  1C39 00C00003           1667mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000B82  0806 0002               1668mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000B86  67F4                    1669mm         BEQ WAIT_FOR_READY_86                       ; NO SPACE, CHECK AGAIN
00000B88  13C5 00C00007           1670mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000B8E                          1671mm     ENDC
00000B8E                          1672mm 
00000B8E                 FALSE    1673mm     IFNE DEBUG
00000B8E                          1674mm     ENDC
00000B8E                          1675mm 
00000B8E                          1676mm     ENDM
00000B8E                          1677mm         HEX2BIN D5,D5,A4
00000B8E  49FA 0EFC               1678mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000B92  0405 0030               1679mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000B96  CABC 000000FF           1680mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000B9C  1A34 5000               1681mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000BA0                          1682mm     ENDM
00000BA0  8205                    1683m         OR.B D5,D1
00000BA2  5307                    1684m         SUB.B #1,D7
00000BA4                          1685m     ENDW
00000BA4  6098                    1686ms     BRA _1000000A
00000BA6                          1687ms _1000000B
00000BA6                          1688m 
00000BA6  7A00                    1689m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000BA8  1A01                    1690m     MOVE.B D1,D5
00000BAA  D481                    1691m     ADD.L D1,D2
00000BAC                          1692m 
00000BAC                          1693m     ENDM
00000BAC                          1694   
00000BAC  14C1                    1695                  MOVE.B D1,(A2)+                     ; store it!
00000BAE                          1696  
00000BAE  5303                    1697                  SUB.B #1,D3                         ; 1 less byte to go
00000BB0                          1698              ENDW
00000BB0  6080                    1699s     BRA _10000008
00000BB2                          1700s _10000009
00000BB2                          1701  
00000BB2  7200                    1702              MOVE.L #0,D1                            ; not done yet
00000BB4                          1703          ELSE
00000BB4  6000 01E2               1704s     BRA _00000007
00000BB8                          1705s _00000005
00000BB8                          1706              IF.B D1 <EQ> #'8' THEN.L                ; termination record, exit
00000BB8  B23C 0038               1707s     CMP.B   #'8',D1
00000BBC  6600 0164               1708s     BNE.L   _00000008
00000BC0  7800                    1709                  MOVE.L #0,D4                        ; read the 24 bit start address
00000BC2                          1710m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; top byte
00000BC2  1E3C 0002               1711m     MOVE.B #2,D7
00000BC6                          1712m     WHILE.B D7 <GT> 0 DO
00000BC6                          1713ms _1000000C
00000BC6  BE38 0000               1714ms     CMP.B   0,D7
00000BCA  6F00 0062               1715ms     BLE _1000000D
00000BCE  E98C                    1716m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000BD0                          1717mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000BD0                          1718mm WAIT_FOR_READY_89                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000BD0                          1719mm 
00000BD0  1A39 00C00003           1720mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000BD6  0805 0000               1721mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BDA  6700 0010               1722mm     BEQ CONTINUE_89                                 ; NOTHING, CONTINUE
00000BDE                          1723mm 
00000BDE                          1724mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000BDE                 TRUE     1725mmm     IFEQ DEBUG
00000BDE  1A39 00C00007           1726mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000BE4                          1727mmm     ENDC
00000BE4                 FALSE    1728mmm     IFNE DEBUG
00000BE4                          1729mmm     ENDC
00000BE4                          1730mmm 
00000BE4  BA3C 001B               1731mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000BE8  6700 F816               1732mmm     BEQ START
00000BEC                          1733mmm     ENDM
00000BEC                          1734mm CONTINUE_89
00000BEC  1A39 00C00013           1735mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000BF2  0805 0000               1736mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000BF6  67D8                    1737mm     BEQ WAIT_FOR_READY_89                           ; NOTHING, CHECK AGAIN
00000BF8                          1738mm     
00000BF8  1A39 00C00017           1739mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000BFE  13C5 00E00001           1740mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C04                          1741mm 
00000C04                          1742mm     ENDM
00000C04                          1743mm         PRINT_CHAR D5,D6
00000C04                          1744mm WAIT_FOR_READY_91                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C04                 TRUE     1745mm     IFEQ DEBUG
00000C04  1C39 00C00003           1746mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C0A  0806 0002               1747mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C0E  67F4                    1748mm         BEQ WAIT_FOR_READY_91                       ; NO SPACE, CHECK AGAIN
00000C10  13C5 00C00007           1749mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C16                          1750mm     ENDC
00000C16                          1751mm 
00000C16                 FALSE    1752mm     IFNE DEBUG
00000C16                          1753mm     ENDC
00000C16                          1754mm 
00000C16                          1755mm     ENDM
00000C16                          1756mm         HEX2BIN D5,D5,A4
00000C16  49FA 0E74               1757mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000C1A  0405 0030               1758mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C1E  CABC 000000FF           1759mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000C24  1A34 5000               1760mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C28                          1761mm     ENDM
00000C28  8805                    1762m         OR.B D5,D4
00000C2A  5307                    1763m         SUB.B #1,D7
00000C2C                          1764m     ENDW
00000C2C  6098                    1765ms     BRA _1000000C
00000C2E                          1766ms _1000000D
00000C2E                          1767m 
00000C2E  7A00                    1768m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000C30  1A04                    1769m     MOVE.B D4,D5
00000C32  D484                    1770m     ADD.L D4,D2
00000C34                          1771m 
00000C34                          1772m     ENDM
00000C34                          1773m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; middle byte
00000C34  1E3C 0002               1774m     MOVE.B #2,D7
00000C38                          1775m     WHILE.B D7 <GT> 0 DO
00000C38                          1776ms _1000000E
00000C38  BE38 0000               1777ms     CMP.B   0,D7
00000C3C  6F00 0062               1778ms     BLE _1000000F
00000C40  E98C                    1779m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000C42                          1780mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000C42                          1781mm WAIT_FOR_READY_94                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C42                          1782mm 
00000C42  1A39 00C00003           1783mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000C48  0805 0000               1784mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C4C  6700 0010               1785mm     BEQ CONTINUE_94                                 ; NOTHING, CONTINUE
00000C50                          1786mm 
00000C50                          1787mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000C50                 TRUE     1788mmm     IFEQ DEBUG
00000C50  1A39 00C00007           1789mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000C56                          1790mmm     ENDC
00000C56                 FALSE    1791mmm     IFNE DEBUG
00000C56                          1792mmm     ENDC
00000C56                          1793mmm 
00000C56  BA3C 001B               1794mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000C5A  6700 F7A4               1795mmm     BEQ START
00000C5E                          1796mmm     ENDM
00000C5E                          1797mm CONTINUE_94
00000C5E  1A39 00C00013           1798mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000C64  0805 0000               1799mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000C68  67D8                    1800mm     BEQ WAIT_FOR_READY_94                           ; NOTHING, CHECK AGAIN
00000C6A                          1801mm     
00000C6A  1A39 00C00017           1802mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000C70  13C5 00E00001           1803mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000C76                          1804mm 
00000C76                          1805mm     ENDM
00000C76                          1806mm         PRINT_CHAR D5,D6
00000C76                          1807mm WAIT_FOR_READY_96                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000C76                 TRUE     1808mm     IFEQ DEBUG
00000C76  1C39 00C00003           1809mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000C7C  0806 0002               1810mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000C80  67F4                    1811mm         BEQ WAIT_FOR_READY_96                       ; NO SPACE, CHECK AGAIN
00000C82  13C5 00C00007           1812mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000C88                          1813mm     ENDC
00000C88                          1814mm 
00000C88                 FALSE    1815mm     IFNE DEBUG
00000C88                          1816mm     ENDC
00000C88                          1817mm 
00000C88                          1818mm     ENDM
00000C88                          1819mm         HEX2BIN D5,D5,A4
00000C88  49FA 0E02               1820mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000C8C  0405 0030               1821mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000C90  CABC 000000FF           1822mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000C96  1A34 5000               1823mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000C9A                          1824mm     ENDM
00000C9A  8805                    1825m         OR.B D5,D4
00000C9C  5307                    1826m         SUB.B #1,D7
00000C9E                          1827m     ENDW
00000C9E  6098                    1828ms     BRA _1000000E
00000CA0                          1829ms _1000000F
00000CA0                          1830m 
00000CA0  7A00                    1831m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000CA2  1A04                    1832m     MOVE.B D4,D5
00000CA4  D484                    1833m     ADD.L D4,D2
00000CA6                          1834m 
00000CA6                          1835m     ENDM
00000CA6                          1836m                 DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4     ; bottom byte
00000CA6  1E3C 0002               1837m     MOVE.B #2,D7
00000CAA                          1838m     WHILE.B D7 <GT> 0 DO
00000CAA                          1839ms _10000010
00000CAA  BE38 0000               1840ms     CMP.B   0,D7
00000CAE  6F00 0062               1841ms     BLE _10000011
00000CB2  E98C                    1842m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000CB4                          1843mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000CB4                          1844mm WAIT_FOR_READY_99                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CB4                          1845mm 
00000CB4  1A39 00C00003           1846mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000CBA  0805 0000               1847mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CBE  6700 0010               1848mm     BEQ CONTINUE_99                                 ; NOTHING, CONTINUE
00000CC2                          1849mm 
00000CC2                          1850mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000CC2                 TRUE     1851mmm     IFEQ DEBUG
00000CC2  1A39 00C00007           1852mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000CC8                          1853mmm     ENDC
00000CC8                 FALSE    1854mmm     IFNE DEBUG
00000CC8                          1855mmm     ENDC
00000CC8                          1856mmm 
00000CC8  BA3C 001B               1857mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000CCC  6700 F732               1858mmm     BEQ START
00000CD0                          1859mmm     ENDM
00000CD0                          1860mm CONTINUE_99
00000CD0  1A39 00C00013           1861mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000CD6  0805 0000               1862mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000CDA  67D8                    1863mm     BEQ WAIT_FOR_READY_99                           ; NOTHING, CHECK AGAIN
00000CDC                          1864mm     
00000CDC  1A39 00C00017           1865mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000CE2  13C5 00E00001           1866mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000CE8                          1867mm 
00000CE8                          1868mm     ENDM
00000CE8                          1869mm         PRINT_CHAR D5,D6
00000CE8                          1870mm WAIT_FOR_READY_101                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000CE8                 TRUE     1871mm     IFEQ DEBUG
00000CE8  1C39 00C00003           1872mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000CEE  0806 0002               1873mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000CF2  67F4                    1874mm         BEQ WAIT_FOR_READY_101                      ; NO SPACE, CHECK AGAIN
00000CF4  13C5 00C00007           1875mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000CFA                          1876mm     ENDC
00000CFA                          1877mm 
00000CFA                 FALSE    1878mm     IFNE DEBUG
00000CFA                          1879mm     ENDC
00000CFA                          1880mm 
00000CFA                          1881mm     ENDM
00000CFA                          1882mm         HEX2BIN D5,D5,A4
00000CFA  49FA 0D90               1883mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000CFE  0405 0030               1884mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000D02  CABC 000000FF           1885mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000D08  1A34 5000               1886mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000D0C                          1887mm     ENDM
00000D0C  8805                    1888m         OR.B D5,D4
00000D0E  5307                    1889m         SUB.B #1,D7
00000D10                          1890m     ENDW
00000D10  6098                    1891ms     BRA _10000010
00000D12                          1892ms _10000011
00000D12                          1893m 
00000D12  7A00                    1894m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000D14  1A04                    1895m     MOVE.B D4,D5
00000D16  D484                    1896m     ADD.L D4,D2
00000D18                          1897m 
00000D18                          1898m     ENDM
00000D18                          1899  
00000D18  2044                    1900                  MOVE.L D4,A0                        ; start address -> A0
00000D1A  D1C9                    1901                  ADD.L A1,A0                         ; add in the offset
00000D1C                          1902  
00000D1C  72FF                    1903                  MOVE.L #$FFFFFFFF,D1                ; done
00000D1E                          1904              ELSE
00000D1E  6000 0078               1905s     BRA _00000009
00000D22                          1906s _00000008
00000D22                          1907m                 PRINT_CRLF D5,A4
00000D22  49FA 0D93               1908m     LEA CRLF(PC),A4
00000D26                          1909mm     PRINT_STR A4,D5
00000D26                          1910mm LOOP_104
00000D26  0C14 0000               1911mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000D2A  6700 0016               1912mm     BEQ EXIT_104
00000D2E                          1913mmm     PRINT_CHAR (A4)+,D5
00000D2E                          1914mmm WAIT_FOR_READY_105                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D2E                 TRUE     1915mmm     IFEQ DEBUG
00000D2E  1A39 00C00003           1916mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D34  0805 0002               1917mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D38  67F4                    1918mmm         BEQ WAIT_FOR_READY_105                      ; NO SPACE, CHECK AGAIN
00000D3A  13DC 00C00007           1919mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D40                          1920mmm     ENDC
00000D40                          1921mmm 
00000D40                 FALSE    1922mmm     IFNE DEBUG
00000D40                          1923mmm     ENDC
00000D40                          1924mmm 
00000D40                          1925mmm     ENDM
00000D40  60E4                    1926mm     BRA LOOP_104
00000D42                          1927mm EXIT_104
00000D42                          1928mm     ENDM
00000D42                          1929m     ENDM
00000D42                          1930  
00000D42  49FA 0CFF               1931                  LEA UNREC(PC),A4                    ; warn for unrecognised type
00000D46                          1932m                 PRINT_STR A4,D5
00000D46                          1933m LOOP_106
00000D46  0C14 0000               1934m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000D4A  6700 0016               1935m     BEQ EXIT_106
00000D4E                          1936mm     PRINT_CHAR (A4)+,D5
00000D4E                          1937mm WAIT_FOR_READY_107                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D4E                 TRUE     1938mm     IFEQ DEBUG
00000D4E  1A39 00C00003           1939mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D54  0805 0002               1940mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D58  67F4                    1941mm         BEQ WAIT_FOR_READY_107                      ; NO SPACE, CHECK AGAIN
00000D5A  13DC 00C00007           1942mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D60                          1943mm     ENDC
00000D60                          1944mm 
00000D60                 FALSE    1945mm     IFNE DEBUG
00000D60                          1946mm     ENDC
00000D60                          1947mm 
00000D60                          1948mm     ENDM
00000D60  60E4                    1949m     BRA LOOP_106
00000D62                          1950m EXIT_106
00000D62                          1951m     ENDM
00000D62                          1952m                 PRINT_CHAR D1,D5
00000D62                          1953m WAIT_FOR_READY_108                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D62                 TRUE     1954m     IFEQ DEBUG
00000D62  1A39 00C00003           1955m         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D68  0805 0002               1956m         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D6C  67F4                    1957m         BEQ WAIT_FOR_READY_108                      ; NO SPACE, CHECK AGAIN
00000D6E  13C1 00C00007           1958m         MOVE.B D1,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000D74                          1959m     ENDC
00000D74                          1960m 
00000D74                 FALSE    1961m     IFNE DEBUG
00000D74                          1962m     ENDC
00000D74                          1963m 
00000D74                          1964m     ENDM
00000D74                          1965m                 PRINT_CRLF D5,A4
00000D74  49FA 0D41               1966m     LEA CRLF(PC),A4
00000D78                          1967mm     PRINT_STR A4,D5
00000D78                          1968mm LOOP_110
00000D78  0C14 0000               1969mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000D7C  6700 0016               1970mm     BEQ EXIT_110
00000D80                          1971mmm     PRINT_CHAR (A4)+,D5
00000D80                          1972mmm WAIT_FOR_READY_111                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000D80                 TRUE     1973mmm     IFEQ DEBUG
00000D80  1A39 00C00003           1974mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000D86  0805 0002               1975mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000D8A  67F4                    1976mmm         BEQ WAIT_FOR_READY_111                      ; NO SPACE, CHECK AGAIN
00000D8C  13DC 00C00007           1977mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000D92                          1978mmm     ENDC
00000D92                          1979mmm 
00000D92                 FALSE    1980mmm     IFNE DEBUG
00000D92                          1981mmm     ENDC
00000D92                          1982mmm 
00000D92                          1983mmm     ENDM
00000D92  60E4                    1984mm     BRA LOOP_110
00000D94                          1985mm EXIT_110
00000D94                          1986mm     ENDM
00000D94                          1987m     ENDM
00000D94                          1988  
00000D94  6000 FAEC               1989                  BRA WAIT_FOR_SRECORD                ; ignore any other type 
00000D98                          1990              ENDI
00000D98                          1991s _00000009
00000D98                          1992          ENDI
00000D98                          1993s _00000007
00000D98                          1994      ENDI
00000D98                          1995s _00000003
00000D98                          1996  
00000D98                          1997m     DOWNLOAD_BYTE D4,D5,D6,D7,D2,A4
00000D98  1E3C 0002               1998m     MOVE.B #2,D7
00000D9C                          1999m     WHILE.B D7 <GT> 0 DO
00000D9C                          2000ms _10000012
00000D9C  BE38 0000               2001ms     CMP.B   0,D7
00000DA0  6F00 0062               2002ms     BLE _10000013
00000DA4  E98C                    2003m         LSL.L #4,D4                                 ; IT's OK to do this first, because we are either starting from 0, 
00000DA6                          2004mm         DOWNLOAD D5                                 ; OR WE ARE READING THE NEXT BYTE ALONG, SO NEED TO SHIFT UP THE PREVIOUS ONE
00000DA6                          2005mm WAIT_FOR_READY_113                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DA6                          2006mm 
00000DA6  1A39 00C00003           2007mm     MOVE.B DUART_SRA,D5                             ; CHECK FOR COMMAND
00000DAC  0805 0000               2008mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000DB0  6700 0010               2009mm     BEQ CONTINUE_113                                    ; NOTHING, CONTINUE
00000DB4                          2010mm 
00000DB4                          2011mmm     READ_CHAR D5                                    ; WE're not going to do anything with it, just check for escape
00000DB4                 TRUE     2012mmm     IFEQ DEBUG
00000DB4  1A39 00C00007           2013mmm         MOVE.B DUART_RXA,D5                         ; GOT A CHARACTER, READ IT
00000DBA                          2014mmm     ENDC
00000DBA                 FALSE    2015mmm     IFNE DEBUG
00000DBA                          2016mmm     ENDC
00000DBA                          2017mmm 
00000DBA  BA3C 001B               2018mmm     CMP.B #$1B,D5                                   ; CHECK FOR ESCAPE AND GO TO START
00000DBE  6700 F640               2019mmm     BEQ START
00000DC2                          2020mmm     ENDM
00000DC2                          2021mm CONTINUE_113
00000DC2  1A39 00C00013           2022mm     MOVE.B DUART_SRB,D5                             ; READ DOWNLOAD STATUS REGISTER
00000DC8  0805 0000               2023mm     BTST #0,D5                                      ; CHECK FOR CHARACTER
00000DCC  67D8                    2024mm     BEQ WAIT_FOR_READY_113                          ; NOTHING, CHECK AGAIN
00000DCE                          2025mm     
00000DCE  1A39 00C00017           2026mm     MOVE.B DUART_RXB,D5                             ; GOT A CHARACTER, READ IT
00000DD4  13C5 00E00001           2027mm     MOVE.B D5,DISPLAY                               ; ECHO TO THE DISPLAY
00000DDA                          2028mm 
00000DDA                          2029mm     ENDM
00000DDA                          2030mm         PRINT_CHAR D5,D6
00000DDA                          2031mm WAIT_FOR_READY_115                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000DDA                 TRUE     2032mm     IFEQ DEBUG
00000DDA  1C39 00C00003           2033mm         MOVE.B DUART_SRA,D6                         ; READ STATUS REGISTER
00000DE0  0806 0002               2034mm         BTST #2,D6                                  ; CHECK FOR SPACE TO SEND
00000DE4  67F4                    2035mm         BEQ WAIT_FOR_READY_115                      ; NO SPACE, CHECK AGAIN
00000DE6  13C5 00C00007           2036mm         MOVE.B D5,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000DEC                          2037mm     ENDC
00000DEC                          2038mm 
00000DEC                 FALSE    2039mm     IFNE DEBUG
00000DEC                          2040mm     ENDC
00000DEC                          2041mm 
00000DEC                          2042mm     ENDM
00000DEC                          2043mm         HEX2BIN D5,D5,A4
00000DEC  49FA 0C9E               2044mm     LEA HEX2BIN_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000DF0  0405 0030               2045mm     SUB.B #'0',D5                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00000DF4  CABC 000000FF           2046mm     AND.L #$FF,D5                                   ; IGNORE THE TOP 3 BYTES
00000DFA  1A34 5000               2047mm     MOVE.B 0(A4,D5),D5                              ; USE THAT AS AN INDEX INTO THE LUT   
00000DFE                          2048mm     ENDM
00000DFE  8805                    2049m         OR.B D5,D4
00000E00  5307                    2050m         SUB.B #1,D7
00000E02                          2051m     ENDW
00000E02  6098                    2052ms     BRA _10000012
00000E04                          2053ms _10000013
00000E04                          2054m 
00000E04  7A00                    2055m     MOVE.L #0,D5                                    ; REXTRACT LATEST BYTE OF ADDRESS AND ADD INTO CHECKSUM
00000E06  1A04                    2056m     MOVE.B D4,D5
00000E08  D484                    2057m     ADD.L D4,D2
00000E0A                          2058m 
00000E0A                          2059m     ENDM
00000E0A                          2060m     PRINT_CRLF D5,A4
00000E0A  49FA 0CAB               2061m     LEA CRLF(PC),A4
00000E0E                          2062mm     PRINT_STR A4,D5
00000E0E                          2063mm LOOP_118
00000E0E  0C14 0000               2064mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E12  6700 0016               2065mm     BEQ EXIT_118
00000E16                          2066mmm     PRINT_CHAR (A4)+,D5
00000E16                          2067mmm WAIT_FOR_READY_119                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E16                 TRUE     2068mmm     IFEQ DEBUG
00000E16  1A39 00C00003           2069mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E1C  0805 0002               2070mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E20  67F4                    2071mmm         BEQ WAIT_FOR_READY_119                      ; NO SPACE, CHECK AGAIN
00000E22  13DC 00C00007           2072mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E28                          2073mmm     ENDC
00000E28                          2074mmm 
00000E28                 FALSE    2075mmm     IFNE DEBUG
00000E28                          2076mmm     ENDC
00000E28                          2077mmm 
00000E28                          2078mmm     ENDM
00000E28  60E4                    2079mm     BRA LOOP_118
00000E2A                          2080mm EXIT_118
00000E2A                          2081mm     ENDM
00000E2A                          2082m     ENDM
00000E2A                          2083  
00000E2A                          2084      IF.B D2 <NE> #$FF THEN.L
00000E2A  B43C 00FF               2085s     CMP.B   #$FF,D2
00000E2E  6700 0090               2086s     BEQ.L   _0000000A
00000E32  49FA 0C26               2087          LEA CS_FAILURE(PC),A4                       ; warn for mismatched checksum
00000E36                          2088m         PRINT_STR A4,D5
00000E36                          2089m LOOP_120
00000E36  0C14 0000               2090m     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E3A  6700 0016               2091m     BEQ EXIT_120
00000E3E                          2092mm     PRINT_CHAR (A4)+,D5
00000E3E                          2093mm WAIT_FOR_READY_121                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E3E                 TRUE     2094mm     IFEQ DEBUG
00000E3E  1A39 00C00003           2095mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E44  0805 0002               2096mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E48  67F4                    2097mm         BEQ WAIT_FOR_READY_121                      ; NO SPACE, CHECK AGAIN
00000E4A  13DC 00C00007           2098mm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E50                          2099mm     ENDC
00000E50                          2100mm 
00000E50                 FALSE    2101mm     IFNE DEBUG
00000E50                          2102mm     ENDC
00000E50                          2103mm 
00000E50                          2104mm     ENDM
00000E50  60E4                    2105m     BRA LOOP_120
00000E52                          2106m EXIT_120
00000E52                          2107m     ENDM
00000E52                          2108m         PRINT_REG D0,D5,D3,D6,A4
00000E52  49FA 0C69               2109m     LEA OX(PC),A4
00000E56                          2110mm     PRINT_STR A4,D5
00000E56                          2111mm LOOP_123
00000E56  0C14 0000               2112mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000E5A  6700 0016               2113mm     BEQ EXIT_123
00000E5E                          2114mmm     PRINT_CHAR (A4)+,D5
00000E5E                          2115mmm WAIT_FOR_READY_124                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E5E                 TRUE     2116mmm     IFEQ DEBUG
00000E5E  1A39 00C00003           2117mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E64  0805 0002               2118mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E68  67F4                    2119mmm         BEQ WAIT_FOR_READY_124                      ; NO SPACE, CHECK AGAIN
00000E6A  13DC 00C00007           2120mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000E70                          2121mmm     ENDC
00000E70                          2122mmm 
00000E70                 FALSE    2123mmm     IFNE DEBUG
00000E70                          2124mmm     ENDC
00000E70                          2125mmm 
00000E70                          2126mmm     ENDM
00000E70  60E4                    2127mm     BRA LOOP_123
00000E72                          2128mm EXIT_123
00000E72                          2129mm     ENDM
00000E72  7C07                    2130m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000E74                          2131m LOOP_122
00000E74                          2132mm     BIN2HEX D0,D3,A4
00000E74  49FA 0C06               2133mm     LEA BIN2HEX_LUT(PC),A4                          ; LOAD THE LOOKUP TABLE
00000E78  E998                    2134mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000E7A  1600                    2135mm     MOVE.B D0,D3
00000E7C  0283 0000000F           2136mm     ANDI.L #$F,D3
00000E82  1634 3000               2137mm     MOVE.B 0(A4,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00000E86                          2138mm     ENDM
00000E86                          2139mm     PRINT_CHAR D3,D5
00000E86                          2140mm WAIT_FOR_READY_126                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000E86                 TRUE     2141mm     IFEQ DEBUG
00000E86  1A39 00C00003           2142mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000E8C  0805 0002               2143mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000E90  67F4                    2144mm         BEQ WAIT_FOR_READY_126                      ; NO SPACE, CHECK AGAIN
00000E92  13C3 00C00007           2145mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000E98                          2146mm     ENDC
00000E98                          2147mm 
00000E98                 FALSE    2148mm     IFNE DEBUG
00000E98                          2149mm     ENDC
00000E98                          2150mm 
00000E98                          2151mm     ENDM
00000E98  57CE FFDA               2152m     DBEQ D6,LOOP_122
00000E9C                          2153m     ENDM
00000E9C                          2154m         PRINT_CRLF D5,A4
00000E9C  49FA 0C19               2155m     LEA CRLF(PC),A4
00000EA0                          2156mm     PRINT_STR A4,D5
00000EA0                          2157mm LOOP_128
00000EA0  0C14 0000               2158mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000EA4  6700 0016               2159mm     BEQ EXIT_128
00000EA8                          2160mmm     PRINT_CHAR (A4)+,D5
00000EA8                          2161mmm WAIT_FOR_READY_129                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000EA8                 TRUE     2162mmm     IFEQ DEBUG
00000EA8  1A39 00C00003           2163mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EAE  0805 0002               2164mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EB2  67F4                    2165mmm         BEQ WAIT_FOR_READY_129                      ; NO SPACE, CHECK AGAIN
00000EB4  13DC 00C00007           2166mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EBA                          2167mmm     ENDC
00000EBA                          2168mmm 
00000EBA                 FALSE    2169mmm     IFNE DEBUG
00000EBA                          2170mmm     ENDC
00000EBA                          2171mmm 
00000EBA                          2172mmm     ENDM
00000EBA  60E4                    2173mm     BRA LOOP_128
00000EBC                          2174mm EXIT_128
00000EBC                          2175mm     ENDM
00000EBC                          2176m     ENDM
00000EBC                          2177          
00000EBC  6000 F72C               2178          BRA MAIN_LOOP
00000EC0                          2179      ENDI
00000EC0                          2180s _0000000A
00000EC0                          2181  
00000EC0                          2182      IF D1 <EQ> #0 THEN
00000EC0  B27C 0000               2183s     CMP.W   #0,D1
00000EC4  6600 0006               2184s     BNE _0000000B
00000EC8  6000 F9B8               2185        BRA WAIT_FOR_SRECORD
00000ECC                          2186      ENDI
00000ECC                          2187s _0000000B
00000ECC                          2188  DOWNLOAD_DONE
00000ECC                          2189m     PRINT_REG D0,D5,D6,D2,A1                        ; print out number of Srecords read
00000ECC  43FA 0BEF               2190m     LEA OX(PC),A1
00000ED0                          2191mm     PRINT_STR A1,D5
00000ED0                          2192mm LOOP_131
00000ED0  0C11 0000               2193mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000ED4  6700 0016               2194mm     BEQ EXIT_131
00000ED8                          2195mmm     PRINT_CHAR (A1)+,D5
00000ED8                          2196mmm WAIT_FOR_READY_132                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000ED8                 TRUE     2197mmm     IFEQ DEBUG
00000ED8  1A39 00C00003           2198mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000EDE  0805 0002               2199mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000EE2  67F4                    2200mmm         BEQ WAIT_FOR_READY_132                      ; NO SPACE, CHECK AGAIN
00000EE4  13D9 00C00007           2201mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000EEA                          2202mmm     ENDC
00000EEA                          2203mmm 
00000EEA                 FALSE    2204mmm     IFNE DEBUG
00000EEA                          2205mmm     ENDC
00000EEA                          2206mmm 
00000EEA                          2207mmm     ENDM
00000EEA  60E4                    2208mm     BRA LOOP_131
00000EEC                          2209mm EXIT_131
00000EEC                          2210mm     ENDM
00000EEC  7407                    2211m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000EEE                          2212m LOOP_130
00000EEE                          2213mm     BIN2HEX D0,D6,A1
00000EEE  43FA 0B8C               2214mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000EF2  E998                    2215mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000EF4  1C00                    2216mm     MOVE.B D0,D6
00000EF6  0286 0000000F           2217mm     ANDI.L #$F,D6
00000EFC  1C31 6000               2218mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000F00                          2219mm     ENDM
00000F00                          2220mm     PRINT_CHAR D6,D5
00000F00                          2221mm WAIT_FOR_READY_134                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F00                 TRUE     2222mm     IFEQ DEBUG
00000F00  1A39 00C00003           2223mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F06  0805 0002               2224mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F0A  67F4                    2225mm         BEQ WAIT_FOR_READY_134                      ; NO SPACE, CHECK AGAIN
00000F0C  13C6 00C00007           2226mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F12                          2227mm     ENDC
00000F12                          2228mm 
00000F12                 FALSE    2229mm     IFNE DEBUG
00000F12                          2230mm     ENDC
00000F12                          2231mm 
00000F12                          2232mm     ENDM
00000F12  57CA FFDA               2233m     DBEQ D2,LOOP_130
00000F16                          2234m     ENDM
00000F16  43FA 0B09               2235      LEA READ(PC),A1
00000F1A                          2236m     PRINT_STR A1,D5
00000F1A                          2237m LOOP_135
00000F1A  0C11 0000               2238m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F1E  6700 0016               2239m     BEQ EXIT_135
00000F22                          2240mm     PRINT_CHAR (A1)+,D5
00000F22                          2241mm WAIT_FOR_READY_136                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F22                 TRUE     2242mm     IFEQ DEBUG
00000F22  1A39 00C00003           2243mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F28  0805 0002               2244mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F2C  67F4                    2245mm         BEQ WAIT_FOR_READY_136                      ; NO SPACE, CHECK AGAIN
00000F2E  13D9 00C00007           2246mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F34                          2247mm     ENDC
00000F34                          2248mm 
00000F34                 FALSE    2249mm     IFNE DEBUG
00000F34                          2250mm     ENDC
00000F34                          2251mm 
00000F34                          2252mm     ENDM
00000F34  60E4                    2253m     BRA LOOP_135
00000F36                          2254m EXIT_135
00000F36                          2255m     ENDM
00000F36  2E08                    2256      MOVE.L A0,D7                                    ; set address accumulator to start address
00000F38                          2257m     PRINT_REG D7,D5,D6,D2,A1                        ; print out start address
00000F38  43FA 0B83               2258m     LEA OX(PC),A1
00000F3C                          2259mm     PRINT_STR A1,D5
00000F3C                          2260mm LOOP_138
00000F3C  0C11 0000               2261mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00000F40  6700 0016               2262mm     BEQ EXIT_138
00000F44                          2263mmm     PRINT_CHAR (A1)+,D5
00000F44                          2264mmm WAIT_FOR_READY_139                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F44                 TRUE     2265mmm     IFEQ DEBUG
00000F44  1A39 00C00003           2266mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F4A  0805 0002               2267mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F4E  67F4                    2268mmm         BEQ WAIT_FOR_READY_139                      ; NO SPACE, CHECK AGAIN
00000F50  13D9 00C00007           2269mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000F56                          2270mmm     ENDC
00000F56                          2271mmm 
00000F56                 FALSE    2272mmm     IFNE DEBUG
00000F56                          2273mmm     ENDC
00000F56                          2274mmm 
00000F56                          2275mmm     ENDM
00000F56  60E4                    2276mm     BRA LOOP_138
00000F58                          2277mm EXIT_138
00000F58                          2278mm     ENDM
00000F58  7407                    2279m     MOVE.L #7,D2                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000F5A                          2280m LOOP_137
00000F5A                          2281mm     BIN2HEX D7,D6,A1
00000F5A  43FA 0B20               2282mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00000F5E  E99F                    2283mm     ROL.L #4,D7                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00000F60  1C07                    2284mm     MOVE.B D7,D6
00000F62  0286 0000000F           2285mm     ANDI.L #$F,D6
00000F68  1C31 6000               2286mm     MOVE.B 0(A1,D6),D6                              ; USE THAT AS AN INDEX INTO THE LUT
00000F6C                          2287mm     ENDM
00000F6C                          2288mm     PRINT_CHAR D6,D5
00000F6C                          2289mm WAIT_FOR_READY_141                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F6C                 TRUE     2290mm     IFEQ DEBUG
00000F6C  1A39 00C00003           2291mm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F72  0805 0002               2292mm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F76  67F4                    2293mm         BEQ WAIT_FOR_READY_141                      ; NO SPACE, CHECK AGAIN
00000F78  13C6 00C00007           2294mm         MOVE.B D6,DUART_TXA                         ; SEND THE NEXT CHARACTER
00000F7E                          2295mm     ENDC
00000F7E                          2296mm 
00000F7E                 FALSE    2297mm     IFNE DEBUG
00000F7E                          2298mm     ENDC
00000F7E                          2299mm 
00000F7E                          2300mm     ENDM
00000F7E  57CA FFDA               2301m     DBEQ D2,LOOP_137
00000F82                          2302m     ENDM
00000F82                          2303m     PRINT_CRLF D5,A4
00000F82  49FA 0B33               2304m     LEA CRLF(PC),A4
00000F86                          2305mm     PRINT_STR A4,D5
00000F86                          2306mm LOOP_143
00000F86  0C14 0000               2307mm     CMP.B #NULL,(A4)                                ; 0 -> DONE
00000F8A  6700 0016               2308mm     BEQ EXIT_143
00000F8E                          2309mmm     PRINT_CHAR (A4)+,D5
00000F8E                          2310mmm WAIT_FOR_READY_144                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000F8E                 TRUE     2311mmm     IFEQ DEBUG
00000F8E  1A39 00C00003           2312mmm         MOVE.B DUART_SRA,D5                         ; READ STATUS REGISTER
00000F94  0805 0002               2313mmm         BTST #2,D5                                  ; CHECK FOR SPACE TO SEND
00000F98  67F4                    2314mmm         BEQ WAIT_FOR_READY_144                      ; NO SPACE, CHECK AGAIN
00000F9A  13DC 00C00007           2315mmm         MOVE.B (A4)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000FA0                          2316mmm     ENDC
00000FA0                          2317mmm 
00000FA0                 FALSE    2318mmm     IFNE DEBUG
00000FA0                          2319mmm     ENDC
00000FA0                          2320mmm 
00000FA0                          2321mmm     ENDM
00000FA0  60E4                    2322mm     BRA LOOP_143
00000FA2                          2323mm EXIT_143
00000FA2                          2324mm     ENDM
00000FA2                          2325m     ENDM
00000FA2                          2326  
00000FA2  6000 F646               2327      BRA MAIN_LOOP
00000FA6                          2328  
00000FA6                          2329  G
00000FA6  2047                    2330      MOVE.L D7,A0                                        ; grab the address accumulator and then clear it
00000FA8  7E00                    2331      MOVE.L #0,D7
00000FAA                          2332  
00000FAA  4ED0                    2333      JMP (A0)
00000FAC                          2334          
00000FAC                          2335  Z
00000FAC  207C 00200000           2336      MOVE.L #RAM,A0                                  ; address of RAM
00000FB2  D1FC 00100000           2337      ADD.L #$100000,A0
00000FB8                          2338  
00000FB8                          2339      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; write
00000FB8  7000                    2340s     MOVE.L  #0,D0
00000FBA  6000 0012               2341s     BRA _20000007
00000FBE                          2342s _20000006
00000FBE  2200                    2343          MOVE.L D0,D1                                ; progress update
00000FC0  E089                    2344          LSR.L #8,D1 
00000FC2  E089                    2345          LSR.L #8,D1
00000FC4  13C1 00E00001           2346          MOVE.B D1,DISPLAY
00000FCA                          2347          
00000FCA  2108                    2348          MOVE.L A0,-(A0)
00000FCC                          2349      ENDF
00000FCC  5880                    2350s     ADD.L   #4,D0
00000FCE                          2351s _20000007
00000FCE  B0BC 000FFFFC           2352s     CMP.L   #$FFFFC,D0
00000FD4  6FE8                    2353s     BLE _20000006
00000FD6                          2354  
00000FD6  207C 00200000           2355      MOVE.L #RAM,A0                                  ; address of RAM
00000FDC  D1FC 00100000           2356      ADD.L #$100000,A0
00000FE2                          2357  
00000FE2                          2358      FOR.L D0 = #0 TO #$FFFFC BY #4 DO               ; read back and check 
00000FE2  7000                    2359s     MOVE.L  #0,D0
00000FE4  6000 00A8               2360s     BRA _20000009
00000FE8                          2361s _20000008
00000FE8  2200                    2362          MOVE.L D0,D1                                ; progress update
00000FEA  E089                    2363          LSR.L #8,D1
00000FEC  E089                    2364          LSR.L #8,D1
00000FEE  13C1 00E00001           2365          MOVE.B D1,DISPLAY
00000FF4                          2366  
00000FF4  2408                    2367          MOVE.L A0,D2
00000FF6  2220                    2368          MOVE.L -(A0),D1
00000FF8                          2369  
00000FF8                          2370          IF.L D2 <NE> D1 THEN
00000FF8  B481                    2371s     CMP.L   D1,D2
00000FFA  6700 0090               2372s     BEQ _0000000C
00000FFE  43FA 0A6B               2373              LEA RAM_ERROR(PC),A1
00001002                          2374m             PRINT_STR A1,D1
00001002                          2375m LOOP_145
00001002  0C11 0000               2376m     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001006  6700 0016               2377m     BEQ EXIT_145
0000100A                          2378mm     PRINT_CHAR (A1)+,D1
0000100A                          2379mm WAIT_FOR_READY_146                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000100A                 TRUE     2380mm     IFEQ DEBUG
0000100A  1239 00C00003           2381mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001010  0801 0002               2382mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001014  67F4                    2383mm         BEQ WAIT_FOR_READY_146                      ; NO SPACE, CHECK AGAIN
00001016  13D9 00C00007           2384mm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000101C                          2385mm     ENDC
0000101C                          2386mm 
0000101C                 FALSE    2387mm     IFNE DEBUG
0000101C                          2388mm     ENDC
0000101C                          2389mm 
0000101C                          2390mm     ENDM
0000101C  60E4                    2391m     BRA LOOP_145
0000101E                          2392m EXIT_145
0000101E                          2393m     ENDM
0000101E  2208                    2394              MOVE.L A0,D1
00001020  5981                    2395              SUB.L #4,D1
00001022                          2396m             PRINT_REG D1,D3,D2,D6,A1                ; print out failure address
00001022  43FA 0A99               2397m     LEA OX(PC),A1
00001026                          2398mm     PRINT_STR A1,D3
00001026                          2399mm LOOP_148
00001026  0C11 0000               2400mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000102A  6700 0016               2401mm     BEQ EXIT_148
0000102E                          2402mmm     PRINT_CHAR (A1)+,D3
0000102E                          2403mmm WAIT_FOR_READY_149                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000102E                 TRUE     2404mmm     IFEQ DEBUG
0000102E  1639 00C00003           2405mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001034  0803 0002               2406mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001038  67F4                    2407mmm         BEQ WAIT_FOR_READY_149                      ; NO SPACE, CHECK AGAIN
0000103A  13D9 00C00007           2408mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001040                          2409mmm     ENDC
00001040                          2410mmm 
00001040                 FALSE    2411mmm     IFNE DEBUG
00001040                          2412mmm     ENDC
00001040                          2413mmm 
00001040                          2414mmm     ENDM
00001040  60E4                    2415mm     BRA LOOP_148
00001042                          2416mm EXIT_148
00001042                          2417mm     ENDM
00001042  7C07                    2418m     MOVE.L #7,D6                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001044                          2419m LOOP_147
00001044                          2420mm     BIN2HEX D1,D2,A1
00001044  43FA 0A36               2421mm     LEA BIN2HEX_LUT(PC),A1                          ; LOAD THE LOOKUP TABLE
00001048  E999                    2422mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000104A  1401                    2423mm     MOVE.B D1,D2
0000104C  0282 0000000F           2424mm     ANDI.L #$F,D2
00001052  1431 2000               2425mm     MOVE.B 0(A1,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT
00001056                          2426mm     ENDM
00001056                          2427mm     PRINT_CHAR D2,D3
00001056                          2428mm WAIT_FOR_READY_151                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001056                 TRUE     2429mm     IFEQ DEBUG
00001056  1639 00C00003           2430mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000105C  0803 0002               2431mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001060  67F4                    2432mm         BEQ WAIT_FOR_READY_151                      ; NO SPACE, CHECK AGAIN
00001062  13C2 00C00007           2433mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001068                          2434mm     ENDC
00001068                          2435mm 
00001068                 FALSE    2436mm     IFNE DEBUG
00001068                          2437mm     ENDC
00001068                          2438mm 
00001068                          2439mm     ENDM
00001068  57CE FFDA               2440m     DBEQ D6,LOOP_147
0000106C                          2441m     ENDM
0000106C                          2442m             PRINT_CRLF D3,A1
0000106C  43FA 0A49               2443m     LEA CRLF(PC),A1
00001070                          2444mm     PRINT_STR A1,D3
00001070                          2445mm LOOP_153
00001070  0C11 0000               2446mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001074  6700 0016               2447mm     BEQ EXIT_153
00001078                          2448mmm     PRINT_CHAR (A1)+,D3
00001078                          2449mmm WAIT_FOR_READY_154                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001078                 TRUE     2450mmm     IFEQ DEBUG
00001078  1639 00C00003           2451mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000107E  0803 0002               2452mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001082  67F4                    2453mmm         BEQ WAIT_FOR_READY_154                      ; NO SPACE, CHECK AGAIN
00001084  13D9 00C00007           2454mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000108A                          2455mmm     ENDC
0000108A                          2456mmm 
0000108A                 FALSE    2457mmm     IFNE DEBUG
0000108A                          2458mmm     ENDC
0000108A                          2459mmm 
0000108A                          2460mmm     ENDM
0000108A  60E4                    2461mm     BRA LOOP_153
0000108C                          2462mm EXIT_153
0000108C                          2463mm     ENDM
0000108C                          2464m     ENDM
0000108C                          2465          ENDI 
0000108C                          2466s _0000000C
0000108C                          2467      ENDF
0000108C  5880                    2468s     ADD.L   #4,D0
0000108E                          2469s _20000009
0000108E  B0BC 000FFFFC           2470s     CMP.L   #$FFFFC,D0
00001094  6F00 FF52               2471s     BLE _20000008
00001098                          2472  
00001098  6000 F550               2473      BRA MAIN_LOOP
0000109C                          2474  
0000109C                          2475  L
0000109C  7000                    2476      MOVE.L #0,D0                                    ; D0 will be the length to write               
0000109E  7200                    2477      MOVE.L #0,D1                                    ; D1 will be the address to write 
000010A0                          2478  
000010A0                          2479      FOR D2 = #0 TO #7 DO                            ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
000010A0  343C 0000               2480s     MOVE.W  #0,D2
000010A4  6000 0046               2481s     BRA _2000000B
000010A8                          2482s _2000000A
000010A8  E989                    2483          LSL.L #4,D1                                 ; make what we have so far more significant
000010AA                          2484m         WAIT_CHAR D3,D4                             ; next character -> D2
000010AA                          2485m WAIT_FOR_READY_155                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010AA                 TRUE     2486m     IFEQ DEBUG
000010AA  1839 00C00003           2487m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000010B0  0804 0000               2488m         BTST #0,D4                                  ; CHECK FOR CHARACTER
000010B4  67F4                    2489m         BEQ WAIT_FOR_READY_155                      ; NOTHING, CHECK AGAIN
000010B6                          2490m     ENDC
000010B6                          2491m 
000010B6                          2492mm     READ_CHAR D3
000010B6                 TRUE     2493mm     IFEQ DEBUG
000010B6  1639 00C00007           2494mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
000010BC                          2495mm     ENDC
000010BC                 FALSE    2496mm     IFNE DEBUG
000010BC                          2497mm     ENDC
000010BC                          2498mm 
000010BC  B63C 001B               2499mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
000010C0  6700 F33E               2500mm     BEQ START
000010C4                          2501mm     ENDM
000010C4                          2502m 
000010C4                 TRUE     2503m     IFEQ DEBUG
000010C4                          2504mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
000010C4                          2505mm WAIT_FOR_READY_157                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000010C4                 TRUE     2506mm     IFEQ DEBUG
000010C4  1839 00C00003           2507mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000010CA  0804 0002               2508mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
000010CE  67F4                    2509mm         BEQ WAIT_FOR_READY_157                      ; NO SPACE, CHECK AGAIN
000010D0  13C3 00C00007           2510mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000010D6                          2511mm     ENDC
000010D6                          2512mm 
000010D6                 FALSE    2513mm     IFNE DEBUG
000010D6                          2514mm     ENDC
000010D6                          2515mm 
000010D6                          2516mm     ENDM
000010D6                          2517m     ENDC
000010D6                          2518m     ENDM
000010D6                          2519m         HEX2BIN D3,D3,A0                            ; convert to binary -> D2
000010D6  41FA 09B4               2520m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000010DA  0403 0030               2521m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000010DE  C6BC 000000FF           2522m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
000010E4  1630 3000               2523m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
000010E8                          2524m     ENDM
000010E8  8203                    2525          OR.B D3,D1
000010EA                          2526      ENDF
000010EA  5242                    2527s     ADD.W   #1,D2
000010EC                          2528s _2000000B
000010EC  B47C 0007               2529s     CMP.W   #7,D2
000010F0  6FB6                    2530s     BLE _2000000A
000010F2                          2531  
000010F2  3001                    2532      MOVE.W D1,D0                                    ; extract the LSword for the length
000010F4  E089                    2533      LSR.L #8,D1                                     ; extract the MSword for the address
000010F6  E089                    2534      LSR.L #8,D1
000010F8                          2535  
000010F8                          2536m     PRINT_CRLF D2,A1
000010F8  43FA 09BD               2537m     LEA CRLF(PC),A1
000010FC                          2538mm     PRINT_STR A1,D2
000010FC                          2539mm LOOP_160
000010FC  0C11 0000               2540mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
00001100  6700 0016               2541mm     BEQ EXIT_160
00001104                          2542mmm     PRINT_CHAR (A1)+,D2
00001104                          2543mmm WAIT_FOR_READY_161                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001104                 TRUE     2544mmm     IFEQ DEBUG
00001104  1439 00C00003           2545mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000110A  0802 0002               2546mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000110E  67F4                    2547mmm         BEQ WAIT_FOR_READY_161                      ; NO SPACE, CHECK AGAIN
00001110  13D9 00C00007           2548mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001116                          2549mmm     ENDC
00001116                          2550mmm 
00001116                 FALSE    2551mmm     IFNE DEBUG
00001116                          2552mmm     ENDC
00001116                          2553mmm 
00001116                          2554mmm     ENDM
00001116  60E4                    2555mm     BRA LOOP_160
00001118                          2556mm EXIT_160
00001118                          2557mm     ENDM
00001118                          2558m     ENDM
00001118                          2559  
00001118  2041                    2560      MOVE.L D1,A0                                    ; target address
0000111A  2641                    2561      MOVE.L D1,A3                                    ; keep a copy for later
0000111C                          2562  
0000111C  2247                    2563      MOVE.L D7,A1                                    ; address accumulator -> address register
0000111E  D3FC 00000400           2564      ADD.L #START,A1                             ; skip the vectors
00001124  2847                    2565      MOVE.L D7,A4                                    ; keep a clean copy for later
00001126  7E00                    2566      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001128                          2567  
00001128                          2568m     UNPROTECT
00001128  31FC AAAA 2AAA          2569m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000112E  4E71                    2570m     NOP
00001130  31FC 5555 1554          2571m     MOVE.W #$5555,$1554
00001136  4E71                    2572m     NOP
00001138  31FC 8080 2AAA          2573m     MOVE.W #$8080,$2AAA
0000113E  4E71                    2574m     NOP
00001140  31FC AAAA 2AAA          2575m     MOVE.W #$AAAA,$2AAA
00001146  4E71                    2576m     NOP
00001148  31FC 5555 1554          2577m     MOVE.W #$5555,$1554
0000114E  4E71                    2578m     NOP
00001150  31FC 2020 2AAA          2579m     MOVE.W #$2020,$2AAA
00001156                          2580m     ENDM
00001156                          2581  
00001156  45FA 094B               2582      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000115A                          2583m     PRINT_STR A2,D2
0000115A                          2584m LOOP_163
0000115A  0C12 0000               2585m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000115E  6700 0016               2586m     BEQ EXIT_163
00001162                          2587mm     PRINT_CHAR (A2)+,D2
00001162                          2588mm WAIT_FOR_READY_164                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001162                 TRUE     2589mm     IFEQ DEBUG
00001162  1439 00C00003           2590mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001168  0802 0002               2591mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000116C  67F4                    2592mm         BEQ WAIT_FOR_READY_164                      ; NO SPACE, CHECK AGAIN
0000116E  13DA 00C00007           2593mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001174                          2594mm     ENDC
00001174                          2595mm 
00001174                 FALSE    2596mm     IFNE DEBUG
00001174                          2597mm     ENDC
00001174                          2598mm 
00001174                          2599mm     ENDM
00001174  60E4                    2600m     BRA LOOP_163
00001176                          2601m EXIT_163
00001176                          2602m     ENDM
00001176                          2603  
00001176  2409                    2604      MOVE.L A1,D2
00001178                          2605m     PRINT_REG D2,D3,D4,D5,A2
00001178  45FA 0943               2606m     LEA OX(PC),A2
0000117C                          2607mm     PRINT_STR A2,D3
0000117C                          2608mm LOOP_166
0000117C  0C12 0000               2609mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001180  6700 0016               2610mm     BEQ EXIT_166
00001184                          2611mmm     PRINT_CHAR (A2)+,D3
00001184                          2612mmm WAIT_FOR_READY_167                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001184                 TRUE     2613mmm     IFEQ DEBUG
00001184  1639 00C00003           2614mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000118A  0803 0002               2615mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000118E  67F4                    2616mmm         BEQ WAIT_FOR_READY_167                      ; NO SPACE, CHECK AGAIN
00001190  13DA 00C00007           2617mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001196                          2618mmm     ENDC
00001196                          2619mmm 
00001196                 FALSE    2620mmm     IFNE DEBUG
00001196                          2621mmm     ENDC
00001196                          2622mmm 
00001196                          2623mmm     ENDM
00001196  60E4                    2624mm     BRA LOOP_166
00001198                          2625mm EXIT_166
00001198                          2626mm     ENDM
00001198  7A07                    2627m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000119A                          2628m LOOP_165
0000119A                          2629mm     BIN2HEX D2,D4,A2
0000119A  45FA 08E0               2630mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000119E  E99A                    2631mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000011A0  1802                    2632mm     MOVE.B D2,D4
000011A2  0284 0000000F           2633mm     ANDI.L #$F,D4
000011A8  1832 4000               2634mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000011AC                          2635mm     ENDM
000011AC                          2636mm     PRINT_CHAR D4,D3
000011AC                          2637mm WAIT_FOR_READY_169                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011AC                 TRUE     2638mm     IFEQ DEBUG
000011AC  1639 00C00003           2639mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011B2  0803 0002               2640mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011B6  67F4                    2641mm         BEQ WAIT_FOR_READY_169                      ; NO SPACE, CHECK AGAIN
000011B8  13C4 00C00007           2642mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000011BE                          2643mm     ENDC
000011BE                          2644mm 
000011BE                 FALSE    2645mm     IFNE DEBUG
000011BE                          2646mm     ENDC
000011BE                          2647mm 
000011BE                          2648mm     ENDM
000011BE  57CD FFDA               2649m     DBEQ D5,LOOP_165
000011C2                          2650m     ENDM
000011C2                          2651  
000011C2  45FA 08FC               2652      LEA TO(PC),A2
000011C6                          2653m     PRINT_STR A2,D3
000011C6                          2654m LOOP_170
000011C6  0C12 0000               2655m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011CA  6700 0016               2656m     BEQ EXIT_170
000011CE                          2657mm     PRINT_CHAR (A2)+,D3
000011CE                          2658mm WAIT_FOR_READY_171                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011CE                 TRUE     2659mm     IFEQ DEBUG
000011CE  1639 00C00003           2660mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011D4  0803 0002               2661mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011D8  67F4                    2662mm         BEQ WAIT_FOR_READY_171                      ; NO SPACE, CHECK AGAIN
000011DA  13DA 00C00007           2663mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000011E0                          2664mm     ENDC
000011E0                          2665mm 
000011E0                 FALSE    2666mm     IFNE DEBUG
000011E0                          2667mm     ENDC
000011E0                          2668mm 
000011E0                          2669mm     ENDM
000011E0  60E4                    2670m     BRA LOOP_170
000011E2                          2671m EXIT_170
000011E2                          2672m     ENDM
000011E2                          2673  
000011E2  2408                    2674      MOVE.L A0,D2
000011E4                          2675m     PRINT_REG D2,D3,D4,D5,A2
000011E4  45FA 08D7               2676m     LEA OX(PC),A2
000011E8                          2677mm     PRINT_STR A2,D3
000011E8                          2678mm LOOP_173
000011E8  0C12 0000               2679mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000011EC  6700 0016               2680mm     BEQ EXIT_173
000011F0                          2681mmm     PRINT_CHAR (A2)+,D3
000011F0                          2682mmm WAIT_FOR_READY_174                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000011F0                 TRUE     2683mmm     IFEQ DEBUG
000011F0  1639 00C00003           2684mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000011F6  0803 0002               2685mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000011FA  67F4                    2686mmm         BEQ WAIT_FOR_READY_174                      ; NO SPACE, CHECK AGAIN
000011FC  13DA 00C00007           2687mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001202                          2688mmm     ENDC
00001202                          2689mmm 
00001202                 FALSE    2690mmm     IFNE DEBUG
00001202                          2691mmm     ENDC
00001202                          2692mmm 
00001202                          2693mmm     ENDM
00001202  60E4                    2694mm     BRA LOOP_173
00001204                          2695mm EXIT_173
00001204                          2696mm     ENDM
00001204  7A07                    2697m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001206                          2698m LOOP_172
00001206                          2699mm     BIN2HEX D2,D4,A2
00001206  45FA 0874               2700mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000120A  E99A                    2701mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000120C  1802                    2702mm     MOVE.B D2,D4
0000120E  0284 0000000F           2703mm     ANDI.L #$F,D4
00001214  1832 4000               2704mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001218                          2705mm     ENDM
00001218                          2706mm     PRINT_CHAR D4,D3
00001218                          2707mm WAIT_FOR_READY_176                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001218                 TRUE     2708mm     IFEQ DEBUG
00001218  1639 00C00003           2709mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000121E  0803 0002               2710mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001222  67F4                    2711mm         BEQ WAIT_FOR_READY_176                      ; NO SPACE, CHECK AGAIN
00001224  13C4 00C00007           2712mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000122A                          2713mm     ENDC
0000122A                          2714mm 
0000122A                 FALSE    2715mm     IFNE DEBUG
0000122A                          2716mm     ENDC
0000122A                          2717mm 
0000122A                          2718mm     ENDM
0000122A  57CD FFDA               2719m     DBEQ D5,LOOP_172
0000122E                          2720m     ENDM
0000122E                          2721  
0000122E                          2722m     PRINT_CRLF D3,A2
0000122E  45FA 0887               2723m     LEA CRLF(PC),A2
00001232                          2724mm     PRINT_STR A2,D3
00001232                          2725mm LOOP_178
00001232  0C12 0000               2726mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001236  6700 0016               2727mm     BEQ EXIT_178
0000123A                          2728mmm     PRINT_CHAR (A2)+,D3
0000123A                          2729mmm WAIT_FOR_READY_179                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000123A                 TRUE     2730mmm     IFEQ DEBUG
0000123A  1639 00C00003           2731mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001240  0803 0002               2732mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001244  67F4                    2733mmm         BEQ WAIT_FOR_READY_179                      ; NO SPACE, CHECK AGAIN
00001246  13DA 00C00007           2734mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000124C                          2735mmm     ENDC
0000124C                          2736mmm 
0000124C                 FALSE    2737mmm     IFNE DEBUG
0000124C                          2738mmm     ENDC
0000124C                          2739mmm 
0000124C                          2740mmm     ENDM
0000124C  60E4                    2741mm     BRA LOOP_178
0000124E                          2742mm EXIT_178
0000124E                          2743mm     ENDM
0000124E                          2744m     ENDM
0000124E                          2745  
0000124E                          2746      WHILE D0 <GT> #0 DO
0000124E                          2747s _10000014
0000124E  B07C 0000               2748s     CMP.W   #0,D0
00001252  6F00 001C               2749s     BLE _10000015
00001256  5580                    2750          SUB.L #2,D0
00001258                          2751  
00001258  13D1 00E00001           2752          MOVE.B (A1),DISPLAY
0000125E                          2753m         PROGRAM (A1),(A0),D2
0000125E  3091                    2754m   MOVE.W (A1),(A0)                                      ; WRITE THE DATA
00001260                          2755m 
00001260                          2756m WAIT_FOR_COMPLETE_180
00001260  3410                    2757m         MOVE.W (A0),D2
00001262                          2758m 
00001262                          2759m         IF.W D2 <NE> (A1) THEN
00001262  B451                    2760ms     CMP.W   (A1),D2
00001264  6700 0004               2761ms     BEQ _0000000D
00001268  60F6                    2762m             BRA WAIT_FOR_COMPLETE_180
0000126A                          2763m         ENDI
0000126A                          2764ms _0000000D
0000126A                          2765m         ENDM
0000126A                          2766  
0000126A  5488                    2767          ADD.L #2,A0
0000126C  5489                    2768          ADD.L #2,A1
0000126E                          2769      ENDW
0000126E  60DE                    2770s     BRA _10000014
00001270                          2771s _10000015
00001270                          2772                                                      ; we're done, can now update the SP
00001270                          2773m     PROGRAM #$FFFC, $2, D2                          ; SP, should read this from above
00001270  31FC FFFC 0002          2774m   MOVE.W #$FFFC,$2                                      ; WRITE THE DATA
00001276                          2775m 
00001276                          2776m WAIT_FOR_COMPLETE_181
00001276  3438 0002               2777m         MOVE.W $2,D2
0000127A                          2778m 
0000127A                          2779m         IF.W D2 <NE> #$FFFC THEN
0000127A  B47C FFFC               2780ms     CMP.W   #$FFFC,D2
0000127E  6700 0004               2781ms     BEQ _0000000E
00001282  60F2                    2782m             BRA WAIT_FOR_COMPLETE_181
00001284                          2783m         ENDI
00001284                          2784ms _0000000E
00001284                          2785m         ENDM
00001284                          2786m     PROGRAM #$002F, $0, D2          
00001284  31FC 002F 0000          2787m   MOVE.W #$002F,$0                                      ; WRITE THE DATA
0000128A                          2788m 
0000128A                          2789m WAIT_FOR_COMPLETE_182
0000128A  3438 0000               2790m         MOVE.W $0,D2
0000128E                          2791m 
0000128E                          2792m         IF.W D2 <NE> #$002F THEN
0000128E  B47C 002F               2793ms     CMP.W   #$002F,D2
00001292  6700 0004               2794ms     BEQ _0000000F
00001296  60F2                    2795m             BRA WAIT_FOR_COMPLETE_182
00001298                          2796m         ENDI
00001298                          2797ms _0000000F
00001298                          2798m         ENDM
00001298                          2799  
00001298                          2800      FOR A0 = #RESET TO #START-4 BY #4 DO
00001298  307C 0004               2801s     MOVE.W  #RESET,A0
0000129C  6000 0134               2802s     BRA _2000000D
000012A0                          2803s _2000000C
000012A0  2008                    2804          MOVE.L A0,D0    
000012A2                          2805m         PRINT_REG D0,D2,D3,D4,A3
000012A2  47FA 0819               2806m     LEA OX(PC),A3
000012A6                          2807mm     PRINT_STR A3,D2
000012A6                          2808mm LOOP_184
000012A6  0C13 0000               2809mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000012AA  6700 0016               2810mm     BEQ EXIT_184
000012AE                          2811mmm     PRINT_CHAR (A3)+,D2
000012AE                          2812mmm WAIT_FOR_READY_185                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012AE                 TRUE     2813mmm     IFEQ DEBUG
000012AE  1439 00C00003           2814mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000012B4  0802 0002               2815mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000012B8  67F4                    2816mmm         BEQ WAIT_FOR_READY_185                      ; NO SPACE, CHECK AGAIN
000012BA  13DB 00C00007           2817mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000012C0                          2818mmm     ENDC
000012C0                          2819mmm 
000012C0                 FALSE    2820mmm     IFNE DEBUG
000012C0                          2821mmm     ENDC
000012C0                          2822mmm 
000012C0                          2823mmm     ENDM
000012C0  60E4                    2824mm     BRA LOOP_184
000012C2                          2825mm EXIT_184
000012C2                          2826mm     ENDM
000012C2  7807                    2827m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000012C4                          2828m LOOP_183
000012C4                          2829mm     BIN2HEX D0,D3,A3
000012C4  47FA 07B6               2830mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
000012C8  E998                    2831mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000012CA  1600                    2832mm     MOVE.B D0,D3
000012CC  0283 0000000F           2833mm     ANDI.L #$F,D3
000012D2  1633 3000               2834mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
000012D6                          2835mm     ENDM
000012D6                          2836mm     PRINT_CHAR D3,D2
000012D6                          2837mm WAIT_FOR_READY_187                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012D6                 TRUE     2838mm     IFEQ DEBUG
000012D6  1439 00C00003           2839mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000012DC  0802 0002               2840mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000012E0  67F4                    2841mm         BEQ WAIT_FOR_READY_187                      ; NO SPACE, CHECK AGAIN
000012E2  13C3 00C00007           2842mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000012E8                          2843mm     ENDC
000012E8                          2844mm 
000012E8                 FALSE    2845mm     IFNE DEBUG
000012E8                          2846mm     ENDC
000012E8                          2847mm 
000012E8                          2848mm     ENDM
000012E8  57CC FFDA               2849m     DBEQ D4,LOOP_183
000012EC                          2850m     ENDM
000012EC                          2851  
000012EC  2248                    2852          MOVE.L A0,A1
000012EE  D3CC                    2853          ADD.L A4,A1
000012F0                          2854          
000012F0  2009                    2855          MOVE.L A1,D0    
000012F2                          2856m         PRINT_REG D0,D2,D3,D4,A3
000012F2  47FA 07C9               2857m     LEA OX(PC),A3
000012F6                          2858mm     PRINT_STR A3,D2
000012F6                          2859mm LOOP_189
000012F6  0C13 0000               2860mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
000012FA  6700 0016               2861mm     BEQ EXIT_189
000012FE                          2862mmm     PRINT_CHAR (A3)+,D2
000012FE                          2863mmm WAIT_FOR_READY_190                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000012FE                 TRUE     2864mmm     IFEQ DEBUG
000012FE  1439 00C00003           2865mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001304  0802 0002               2866mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001308  67F4                    2867mmm         BEQ WAIT_FOR_READY_190                      ; NO SPACE, CHECK AGAIN
0000130A  13DB 00C00007           2868mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001310                          2869mmm     ENDC
00001310                          2870mmm 
00001310                 FALSE    2871mmm     IFNE DEBUG
00001310                          2872mmm     ENDC
00001310                          2873mmm 
00001310                          2874mmm     ENDM
00001310  60E4                    2875mm     BRA LOOP_189
00001312                          2876mm EXIT_189
00001312                          2877mm     ENDM
00001312  7807                    2878m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001314                          2879m LOOP_188
00001314                          2880mm     BIN2HEX D0,D3,A3
00001314  47FA 0766               2881mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
00001318  E998                    2882mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000131A  1600                    2883mm     MOVE.B D0,D3
0000131C  0283 0000000F           2884mm     ANDI.L #$F,D3
00001322  1633 3000               2885mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001326                          2886mm     ENDM
00001326                          2887mm     PRINT_CHAR D3,D2
00001326                          2888mm WAIT_FOR_READY_192                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001326                 TRUE     2889mm     IFEQ DEBUG
00001326  1439 00C00003           2890mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000132C  0802 0002               2891mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001330  67F4                    2892mm         BEQ WAIT_FOR_READY_192                      ; NO SPACE, CHECK AGAIN
00001332  13C3 00C00007           2893mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001338                          2894mm     ENDC
00001338                          2895mm 
00001338                 FALSE    2896mm     IFNE DEBUG
00001338                          2897mm     ENDC
00001338                          2898mm 
00001338                          2899mm     ENDM
00001338  57CC FFDA               2900m     DBEQ D4,LOOP_188
0000133C                          2901m     ENDM
0000133C                          2902          
0000133C  2011                    2903          MOVE.L (A1),D0  
0000133E  D081                    2904          ADD.L D1,D0
00001340  0480 00000400           2905          SUB.L #START,D0
00001346                          2906m         PRINT_REG D0,D2,D3,D4,A3
00001346  47FA 0775               2907m     LEA OX(PC),A3
0000134A                          2908mm     PRINT_STR A3,D2
0000134A                          2909mm LOOP_194
0000134A  0C13 0000               2910mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
0000134E  6700 0016               2911mm     BEQ EXIT_194
00001352                          2912mmm     PRINT_CHAR (A3)+,D2
00001352                          2913mmm WAIT_FOR_READY_195                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001352                 TRUE     2914mmm     IFEQ DEBUG
00001352  1439 00C00003           2915mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001358  0802 0002               2916mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000135C  67F4                    2917mmm         BEQ WAIT_FOR_READY_195                      ; NO SPACE, CHECK AGAIN
0000135E  13DB 00C00007           2918mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001364                          2919mmm     ENDC
00001364                          2920mmm 
00001364                 FALSE    2921mmm     IFNE DEBUG
00001364                          2922mmm     ENDC
00001364                          2923mmm 
00001364                          2924mmm     ENDM
00001364  60E4                    2925mm     BRA LOOP_194
00001366                          2926mm EXIT_194
00001366                          2927mm     ENDM
00001366  7807                    2928m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001368                          2929m LOOP_193
00001368                          2930mm     BIN2HEX D0,D3,A3
00001368  47FA 0712               2931mm     LEA BIN2HEX_LUT(PC),A3                          ; LOAD THE LOOKUP TABLE
0000136C  E998                    2932mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000136E  1600                    2933mm     MOVE.B D0,D3
00001370  0283 0000000F           2934mm     ANDI.L #$F,D3
00001376  1633 3000               2935mm     MOVE.B 0(A3,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000137A                          2936mm     ENDM
0000137A                          2937mm     PRINT_CHAR D3,D2
0000137A                          2938mm WAIT_FOR_READY_197                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000137A                 TRUE     2939mm     IFEQ DEBUG
0000137A  1439 00C00003           2940mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001380  0802 0002               2941mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001384  67F4                    2942mm         BEQ WAIT_FOR_READY_197                      ; NO SPACE, CHECK AGAIN
00001386  13C3 00C00007           2943mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000138C                          2944mm     ENDC
0000138C                          2945mm 
0000138C                 FALSE    2946mm     IFNE DEBUG
0000138C                          2947mm     ENDC
0000138C                          2948mm 
0000138C                          2949mm     ENDM
0000138C  57CC FFDA               2950m     DBEQ D4,LOOP_193
00001390                          2951m     ENDM
00001390                          2952          
00001390                          2953m         PRINT_CRLF D2,A3
00001390  47FA 0725               2954m     LEA CRLF(PC),A3
00001394                          2955mm     PRINT_STR A3,D2
00001394                          2956mm LOOP_199
00001394  0C13 0000               2957mm     CMP.B #NULL,(A3)                                ; 0 -> DONE
00001398  6700 0016               2958mm     BEQ EXIT_199
0000139C                          2959mmm     PRINT_CHAR (A3)+,D2
0000139C                          2960mmm WAIT_FOR_READY_200                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000139C                 TRUE     2961mmm     IFEQ DEBUG
0000139C  1439 00C00003           2962mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000013A2  0802 0002               2963mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000013A6  67F4                    2964mmm         BEQ WAIT_FOR_READY_200                      ; NO SPACE, CHECK AGAIN
000013A8  13DB 00C00007           2965mmm         MOVE.B (A3)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000013AE                          2966mmm     ENDC
000013AE                          2967mmm 
000013AE                 FALSE    2968mmm     IFNE DEBUG
000013AE                          2969mmm     ENDC
000013AE                          2970mmm 
000013AE                          2971mmm     ENDM
000013AE  60E4                    2972mm     BRA LOOP_199
000013B0                          2973mm EXIT_199
000013B0                          2974mm     ENDM
000013B0                          2975m     ENDM
000013B0                          2976          
000013B0                          2977m         PROGRAM_VECTOR D0,A0,D2
000013B0  5488                    2978m     ADD.L #2,A0
000013B2                          2979mm     PROGRAM D0, (A0), D2                                ; WRITE IT
000013B2  3080                    2980mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000013B4                          2981mm 
000013B4                          2982mm WAIT_FOR_COMPLETE_202
000013B4  3410                    2983mm         MOVE.W (A0),D2
000013B6                          2984mm 
000013B6                          2985mm         IF.W D2 <NE> D0 THEN
000013B6  B440                    2986mms     CMP.W   D0,D2
000013B8  6700 0004               2987mms     BEQ _00000010
000013BC  60F6                    2988mm             BRA WAIT_FOR_COMPLETE_202
000013BE                          2989mm         ENDI
000013BE                          2990mms _00000010
000013BE                          2991mm         ENDM
000013BE  E088                    2992m     LSR.L #8,D0
000013C0  E088                    2993m     LSR.L #8,D0
000013C2  5588                    2994m     SUB.L #2,A0
000013C4                          2995mm     PROGRAM D0, (A0), D2
000013C4  3080                    2996mm   MOVE.W D0,(A0)                                        ; WRITE THE DATA
000013C6                          2997mm 
000013C6                          2998mm WAIT_FOR_COMPLETE_203
000013C6  3410                    2999mm         MOVE.W (A0),D2
000013C8                          3000mm 
000013C8                          3001mm         IF.W D2 <NE> D0 THEN
000013C8  B440                    3002mms     CMP.W   D0,D2
000013CA  6700 0004               3003mms     BEQ _00000011
000013CE  60F6                    3004mm             BRA WAIT_FOR_COMPLETE_203
000013D0                          3005mm         ENDI
000013D0                          3006mms _00000011
000013D0                          3007mm         ENDM
000013D0                          3008m     ENDM
000013D0                          3009      ENDF
000013D0  5848                    3010s     ADD.W   #4,A0
000013D2                          3011s _2000000D
000013D2  B0FC 03FC               3012s     CMP.W   #START-4,A0
000013D6  6F00 FEC8               3013s     BLE _2000000C
000013DA                          3014                                          
000013DA                          3015m     PROTECT
000013DA  31FC AAAA 2AAA          3016m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
000013E0  31FC 5555 1554          3017m     MOVE.W #$5555,$1554
000013E6  31FC A0A0 2AAA          3018m     MOVE.W #$A0A0,$2AAA
000013EC                          3019m     ENDM
000013EC                          3020  
000013EC  6000 F1FC               3021      BRA MAIN_LOOP
000013F0                          3022      
000013F0                          3023  P
000013F0  7000                    3024      MOVE.L #0,D0                                    ; D0 will be the data to write
000013F2                          3025  
000013F2                          3026      FOR D1 = #0 TO #3 DO                            ; read 2 bytes
000013F2  323C 0000               3027s     MOVE.W  #0,D1
000013F6  6000 0046               3028s     BRA _2000000F
000013FA                          3029s _2000000E
000013FA  E988                    3030          LSL.L #4,D0                                 ; make what we have so far more significant
000013FC                          3031m         WAIT_CHAR D2,D3                             ; next character -> D2
000013FC                          3032m WAIT_FOR_READY_205                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000013FC                 TRUE     3033m     IFEQ DEBUG
000013FC  1639 00C00003           3034m         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001402  0803 0000               3035m         BTST #0,D3                                  ; CHECK FOR CHARACTER
00001406  67F4                    3036m         BEQ WAIT_FOR_READY_205                      ; NOTHING, CHECK AGAIN
00001408                          3037m     ENDC
00001408                          3038m 
00001408                          3039mm     READ_CHAR D2
00001408                 TRUE     3040mm     IFEQ DEBUG
00001408  1439 00C00007           3041mm         MOVE.B DUART_RXA,D2                         ; GOT A CHARACTER, READ IT
0000140E                          3042mm     ENDC
0000140E                 FALSE    3043mm     IFNE DEBUG
0000140E                          3044mm     ENDC
0000140E                          3045mm 
0000140E  B43C 001B               3046mm     CMP.B #$1B,D2                                   ; CHECK FOR ESCAPE AND GO TO START
00001412  6700 EFEC               3047mm     BEQ START
00001416                          3048mm     ENDM
00001416                          3049m 
00001416                 TRUE     3050m     IFEQ DEBUG
00001416                          3051mm         PRINT_CHAR D2,D3                            ; ECHO IT BACK
00001416                          3052mm WAIT_FOR_READY_207                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001416                 TRUE     3053mm     IFEQ DEBUG
00001416  1639 00C00003           3054mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000141C  0803 0002               3055mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001420  67F4                    3056mm         BEQ WAIT_FOR_READY_207                      ; NO SPACE, CHECK AGAIN
00001422  13C2 00C00007           3057mm         MOVE.B D2,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001428                          3058mm     ENDC
00001428                          3059mm 
00001428                 FALSE    3060mm     IFNE DEBUG
00001428                          3061mm     ENDC
00001428                          3062mm 
00001428                          3063mm     ENDM
00001428                          3064m     ENDC
00001428                          3065m     ENDM
00001428                          3066m         HEX2BIN D2,D2,A0                            ; convert to binary -> D2
00001428  41FA 0662               3067m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000142C  0402 0030               3068m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
00001430  C4BC 000000FF           3069m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001436  1430 2000               3070m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
0000143A                          3071m     ENDM
0000143A  8002                    3072          OR.B D2,D0
0000143C                          3073      ENDF
0000143C  5241                    3074s     ADD.W   #1,D1
0000143E                          3075s _2000000F
0000143E  B27C 0003               3076s     CMP.W   #3,D1
00001442  6FB6                    3077s     BLE _2000000E
00001444                          3078  
00001444                          3079m     PRINT_CRLF D2,A1
00001444  43FA 0671               3080m     LEA CRLF(PC),A1
00001448                          3081mm     PRINT_STR A1,D2
00001448                          3082mm LOOP_210
00001448  0C11 0000               3083mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000144C  6700 0016               3084mm     BEQ EXIT_210
00001450                          3085mmm     PRINT_CHAR (A1)+,D2
00001450                          3086mmm WAIT_FOR_READY_211                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001450                 TRUE     3087mmm     IFEQ DEBUG
00001450  1439 00C00003           3088mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001456  0802 0002               3089mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000145A  67F4                    3090mmm         BEQ WAIT_FOR_READY_211                      ; NO SPACE, CHECK AGAIN
0000145C  13D9 00C00007           3091mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001462                          3092mmm     ENDC
00001462                          3093mmm 
00001462                 FALSE    3094mmm     IFNE DEBUG
00001462                          3095mmm     ENDC
00001462                          3096mmm 
00001462                          3097mmm     ENDM
00001462  60E4                    3098mm     BRA LOOP_210
00001464                          3099mm EXIT_210
00001464                          3100mm     ENDM
00001464                          3101m     ENDM
00001464                          3102  
00001464  2047                    3103      MOVE.L D7,A0                                    ; address accumulator -> target address register
00001466  7E00                    3104      MOVE.L #0,D7                                    ; clear the now used address accumulator
00001468                          3105  
00001468                          3106m     UNPROTECT
00001468  31FC AAAA 2AAA          3107m     MOVE.W #$AAAA,$2AAA                             ; REMOVE WRITE PROTECT
0000146E  4E71                    3108m     NOP
00001470  31FC 5555 1554          3109m     MOVE.W #$5555,$1554
00001476  4E71                    3110m     NOP
00001478  31FC 8080 2AAA          3111m     MOVE.W #$8080,$2AAA
0000147E  4E71                    3112m     NOP
00001480  31FC AAAA 2AAA          3113m     MOVE.W #$AAAA,$2AAA
00001486  4E71                    3114m     NOP
00001488  31FC 5555 1554          3115m     MOVE.W #$5555,$1554
0000148E  4E71                    3116m     NOP
00001490  31FC 2020 2AAA          3117m     MOVE.W #$2020,$2AAA
00001496                          3118m     ENDM
00001496                          3119               
00001496  45FA 060B               3120      LEA LOADING(PC),A2                              ; the prints seem to be important for timing to unprotect the EEPROM
0000149A                          3121m     PRINT_STR A2,D2
0000149A                          3122m LOOP_213
0000149A  0C12 0000               3123m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000149E  6700 0016               3124m     BEQ EXIT_213
000014A2                          3125mm     PRINT_CHAR (A2)+,D2
000014A2                          3126mm WAIT_FOR_READY_214                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014A2                 TRUE     3127mm     IFEQ DEBUG
000014A2  1439 00C00003           3128mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000014A8  0802 0002               3129mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000014AC  67F4                    3130mm         BEQ WAIT_FOR_READY_214                      ; NO SPACE, CHECK AGAIN
000014AE  13DA 00C00007           3131mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014B4                          3132mm     ENDC
000014B4                          3133mm 
000014B4                 FALSE    3134mm     IFNE DEBUG
000014B4                          3135mm     ENDC
000014B4                          3136mm 
000014B4                          3137mm     ENDM
000014B4  60E4                    3138m     BRA LOOP_213
000014B6                          3139m EXIT_213
000014B6                          3140m     ENDM
000014B6                          3141  
000014B6                          3142m     PRINT_REG D0,D3,D4,D5,A2
000014B6  45FA 0605               3143m     LEA OX(PC),A2
000014BA                          3144mm     PRINT_STR A2,D3
000014BA                          3145mm LOOP_216
000014BA  0C12 0000               3146mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000014BE  6700 0016               3147mm     BEQ EXIT_216
000014C2                          3148mmm     PRINT_CHAR (A2)+,D3
000014C2                          3149mmm WAIT_FOR_READY_217                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014C2                 TRUE     3150mmm     IFEQ DEBUG
000014C2  1639 00C00003           3151mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000014C8  0803 0002               3152mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000014CC  67F4                    3153mmm         BEQ WAIT_FOR_READY_217                      ; NO SPACE, CHECK AGAIN
000014CE  13DA 00C00007           3154mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000014D4                          3155mmm     ENDC
000014D4                          3156mmm 
000014D4                 FALSE    3157mmm     IFNE DEBUG
000014D4                          3158mmm     ENDC
000014D4                          3159mmm 
000014D4                          3160mmm     ENDM
000014D4  60E4                    3161mm     BRA LOOP_216
000014D6                          3162mm EXIT_216
000014D6                          3163mm     ENDM
000014D6  7A07                    3164m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
000014D8                          3165m LOOP_215
000014D8                          3166mm     BIN2HEX D0,D4,A2
000014D8  45FA 05A2               3167mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
000014DC  E998                    3168mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
000014DE  1800                    3169mm     MOVE.B D0,D4
000014E0  0284 0000000F           3170mm     ANDI.L #$F,D4
000014E6  1832 4000               3171mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
000014EA                          3172mm     ENDM
000014EA                          3173mm     PRINT_CHAR D4,D3
000014EA                          3174mm WAIT_FOR_READY_219                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000014EA                 TRUE     3175mm     IFEQ DEBUG
000014EA  1639 00C00003           3176mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000014F0  0803 0002               3177mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000014F4  67F4                    3178mm         BEQ WAIT_FOR_READY_219                      ; NO SPACE, CHECK AGAIN
000014F6  13C4 00C00007           3179mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000014FC                          3180mm     ENDC
000014FC                          3181mm 
000014FC                 FALSE    3182mm     IFNE DEBUG
000014FC                          3183mm     ENDC
000014FC                          3184mm 
000014FC                          3185mm     ENDM
000014FC  57CD FFDA               3186m     DBEQ D5,LOOP_215
00001500                          3187m     ENDM
00001500                          3188  
00001500  45FA 05BE               3189      LEA TO(PC),A2
00001504                          3190m     PRINT_STR A2,D3
00001504                          3191m LOOP_220
00001504  0C12 0000               3192m     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001508  6700 0016               3193m     BEQ EXIT_220
0000150C                          3194mm     PRINT_CHAR (A2)+,D3
0000150C                          3195mm WAIT_FOR_READY_221                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000150C                 TRUE     3196mm     IFEQ DEBUG
0000150C  1639 00C00003           3197mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001512  0803 0002               3198mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001516  67F4                    3199mm         BEQ WAIT_FOR_READY_221                      ; NO SPACE, CHECK AGAIN
00001518  13DA 00C00007           3200mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000151E                          3201mm     ENDC
0000151E                          3202mm 
0000151E                 FALSE    3203mm     IFNE DEBUG
0000151E                          3204mm     ENDC
0000151E                          3205mm 
0000151E                          3206mm     ENDM
0000151E  60E4                    3207m     BRA LOOP_220
00001520                          3208m EXIT_220
00001520                          3209m     ENDM
00001520                          3210  
00001520  2408                    3211      MOVE.L A0,D2
00001522                          3212m     PRINT_REG D2,D3,D4,D5,A2
00001522  45FA 0599               3213m     LEA OX(PC),A2
00001526                          3214mm     PRINT_STR A2,D3
00001526                          3215mm LOOP_223
00001526  0C12 0000               3216mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000152A  6700 0016               3217mm     BEQ EXIT_223
0000152E                          3218mmm     PRINT_CHAR (A2)+,D3
0000152E                          3219mmm WAIT_FOR_READY_224                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000152E                 TRUE     3220mmm     IFEQ DEBUG
0000152E  1639 00C00003           3221mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001534  0803 0002               3222mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001538  67F4                    3223mmm         BEQ WAIT_FOR_READY_224                      ; NO SPACE, CHECK AGAIN
0000153A  13DA 00C00007           3224mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001540                          3225mmm     ENDC
00001540                          3226mmm 
00001540                 FALSE    3227mmm     IFNE DEBUG
00001540                          3228mmm     ENDC
00001540                          3229mmm 
00001540                          3230mmm     ENDM
00001540  60E4                    3231mm     BRA LOOP_223
00001542                          3232mm EXIT_223
00001542                          3233mm     ENDM
00001542  7A07                    3234m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001544                          3235m LOOP_222
00001544                          3236mm     BIN2HEX D2,D4,A2
00001544  45FA 0536               3237mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
00001548  E99A                    3238mm     ROL.L #4,D2                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000154A  1802                    3239mm     MOVE.B D2,D4
0000154C  0284 0000000F           3240mm     ANDI.L #$F,D4
00001552  1832 4000               3241mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001556                          3242mm     ENDM
00001556                          3243mm     PRINT_CHAR D4,D3
00001556                          3244mm WAIT_FOR_READY_226                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001556                 TRUE     3245mm     IFEQ DEBUG
00001556  1639 00C00003           3246mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000155C  0803 0002               3247mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001560  67F4                    3248mm         BEQ WAIT_FOR_READY_226                      ; NO SPACE, CHECK AGAIN
00001562  13C4 00C00007           3249mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
00001568                          3250mm     ENDC
00001568                          3251mm 
00001568                 FALSE    3252mm     IFNE DEBUG
00001568                          3253mm     ENDC
00001568                          3254mm 
00001568                          3255mm     ENDM
00001568  57CD FFDA               3256m     DBEQ D5,LOOP_222
0000156C                          3257m     ENDM
0000156C                          3258  
0000156C                          3259m     PRINT_CRLF D3,A2
0000156C  45FA 0549               3260m     LEA CRLF(PC),A2
00001570                          3261mm     PRINT_STR A2,D3
00001570                          3262mm LOOP_228
00001570  0C12 0000               3263mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001574  6700 0016               3264mm     BEQ EXIT_228
00001578                          3265mmm     PRINT_CHAR (A2)+,D3
00001578                          3266mmm WAIT_FOR_READY_229                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001578                 TRUE     3267mmm     IFEQ DEBUG
00001578  1639 00C00003           3268mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000157E  0803 0002               3269mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001582  67F4                    3270mmm         BEQ WAIT_FOR_READY_229                      ; NO SPACE, CHECK AGAIN
00001584  13DA 00C00007           3271mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000158A                          3272mmm     ENDC
0000158A                          3273mmm 
0000158A                 FALSE    3274mmm     IFNE DEBUG
0000158A                          3275mmm     ENDC
0000158A                          3276mmm 
0000158A                          3277mmm     ENDM
0000158A  60E4                    3278mm     BRA LOOP_228
0000158C                          3279mm EXIT_228
0000158C                          3280mm     ENDM
0000158C                          3281m     ENDM
0000158C                          3282  
0000158C                          3283m     PROGRAM D0,(A0),D2
0000158C  3080                    3284m   MOVE.W D0,(A0)                                        ; WRITE THE DATA
0000158E                          3285m 
0000158E                          3286m WAIT_FOR_COMPLETE_230
0000158E  3410                    3287m         MOVE.W (A0),D2
00001590                          3288m 
00001590                          3289m         IF.W D2 <NE> D0 THEN
00001590  B440                    3290ms     CMP.W   D0,D2
00001592  6700 0004               3291ms     BEQ _00000012
00001596  60F6                    3292m             BRA WAIT_FOR_COMPLETE_230
00001598                          3293m         ENDI
00001598                          3294ms _00000012
00001598                          3295m         ENDM
00001598                          3296  
00001598                          3297m     PROTECT
00001598  31FC AAAA 2AAA          3298m     MOVE.W #$AAAA,$2AAA                             ; AND WRITE PROTECT
0000159E  31FC 5555 1554          3299m     MOVE.W #$5555,$1554
000015A4  31FC A0A0 2AAA          3300m     MOVE.W #$A0A0,$2AAA
000015AA                          3301m     ENDM
000015AA                          3302  
000015AA  6000 F03E               3303      BRA MAIN_LOOP
000015AE                          3304      
000015AE                          3305  M
000015AE  7000                    3306      MOVE.L #0,D0                                        ; D0 will be the length to read            
000015B0  7200                    3307      MOVE.L #0,D1                                        ; D1 will be the address to read 
000015B2                          3308  
000015B2                          3309      FOR D2 = #0 TO #7 DO                                ; read 4 bytes, we'll split into 2 byte address (MS) and 2 byte length (LS)
000015B2  343C 0000               3310s     MOVE.W  #0,D2
000015B6  6000 0046               3311s     BRA _20000011
000015BA                          3312s _20000010
000015BA  E989                    3313          LSL.L #4,D1                                     ; make what we have so far more significant
000015BC                          3314m         WAIT_CHAR D3,D4                                 ; next character -> D2
000015BC                          3315m WAIT_FOR_READY_232                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015BC                 TRUE     3316m     IFEQ DEBUG
000015BC  1839 00C00003           3317m         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000015C2  0804 0000               3318m         BTST #0,D4                                  ; CHECK FOR CHARACTER
000015C6  67F4                    3319m         BEQ WAIT_FOR_READY_232                      ; NOTHING, CHECK AGAIN
000015C8                          3320m     ENDC
000015C8                          3321m 
000015C8                          3322mm     READ_CHAR D3
000015C8                 TRUE     3323mm     IFEQ DEBUG
000015C8  1639 00C00007           3324mm         MOVE.B DUART_RXA,D3                         ; GOT A CHARACTER, READ IT
000015CE                          3325mm     ENDC
000015CE                 FALSE    3326mm     IFNE DEBUG
000015CE                          3327mm     ENDC
000015CE                          3328mm 
000015CE  B63C 001B               3329mm     CMP.B #$1B,D3                                   ; CHECK FOR ESCAPE AND GO TO START
000015D2  6700 EE2C               3330mm     BEQ START
000015D6                          3331mm     ENDM
000015D6                          3332m 
000015D6                 TRUE     3333m     IFEQ DEBUG
000015D6                          3334mm         PRINT_CHAR D3,D4                            ; ECHO IT BACK
000015D6                          3335mm WAIT_FOR_READY_234                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000015D6                 TRUE     3336mm     IFEQ DEBUG
000015D6  1839 00C00003           3337mm         MOVE.B DUART_SRA,D4                         ; READ STATUS REGISTER
000015DC  0804 0002               3338mm         BTST #2,D4                                  ; CHECK FOR SPACE TO SEND
000015E0  67F4                    3339mm         BEQ WAIT_FOR_READY_234                      ; NO SPACE, CHECK AGAIN
000015E2  13C3 00C00007           3340mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000015E8                          3341mm     ENDC
000015E8                          3342mm 
000015E8                 FALSE    3343mm     IFNE DEBUG
000015E8                          3344mm     ENDC
000015E8                          3345mm 
000015E8                          3346mm     ENDM
000015E8                          3347m     ENDC
000015E8                          3348m     ENDM
000015E8                          3349m         HEX2BIN D3,D3,A0                                ; convert to binary -> D2
000015E8  41FA 04A2               3350m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
000015EC  0403 0030               3351m     SUB.B #'0',D3                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
000015F0  C6BC 000000FF           3352m     AND.L #$FF,D3                                   ; IGNORE THE TOP 3 BYTES
000015F6  1630 3000               3353m     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT   
000015FA                          3354m     ENDM
000015FA  8203                    3355          OR.B D3,D1
000015FC                          3356      ENDF
000015FC  5242                    3357s     ADD.W   #1,D2
000015FE                          3358s _20000011
000015FE  B47C 0007               3359s     CMP.W   #7,D2
00001602  6FB6                    3360s     BLE _20000010
00001604                          3361m     PRINT_CRLF D2,A1
00001604  43FA 04B1               3362m     LEA CRLF(PC),A1
00001608                          3363mm     PRINT_STR A1,D2
00001608                          3364mm LOOP_237
00001608  0C11 0000               3365mm     CMP.B #NULL,(A1)                                ; 0 -> DONE
0000160C  6700 0016               3366mm     BEQ EXIT_237
00001610                          3367mmm     PRINT_CHAR (A1)+,D2
00001610                          3368mmm WAIT_FOR_READY_238                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001610                 TRUE     3369mmm     IFEQ DEBUG
00001610  1439 00C00003           3370mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001616  0802 0002               3371mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000161A  67F4                    3372mmm         BEQ WAIT_FOR_READY_238                      ; NO SPACE, CHECK AGAIN
0000161C  13D9 00C00007           3373mmm         MOVE.B (A1)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001622                          3374mmm     ENDC
00001622                          3375mmm 
00001622                 FALSE    3376mmm     IFNE DEBUG
00001622                          3377mmm     ENDC
00001622                          3378mmm 
00001622                          3379mmm     ENDM
00001622  60E4                    3380mm     BRA LOOP_237
00001624                          3381mm EXIT_237
00001624                          3382mm     ENDM
00001624                          3383m     ENDM
00001624                          3384  
00001624  3001                    3385      MOVE.W D1,D0                                        ; extract the LSword for the length
00001626  E089                    3386      LSR.L #8,D1                                         ; extract the MSword for the address
00001628  E089                    3387      LSR.L #8,D1
0000162A                          3388  
0000162A  2241                    3389      MOVE.L D1,A1
0000162C                          3390      
0000162C  2047                    3391      MOVE.L D7,A0                                        ; address accumulator -> target address register
0000162E                          3392      ;MOVE.L #0,D7                                       ; we're not going to clear it, so we can do go
0000162E                          3393  
0000162E                          3394      WHILE D0 <GT> #0 DO
0000162E                          3395s _10000016
0000162E  B07C 0000               3396s     CMP.W   #0,D0
00001632  6F00 000E               3397s     BLE _10000017
00001636  5580                    3398          SUB.L #2,D0
00001638                          3399  
00001638  13D1 00E00001           3400          MOVE.B (A1),DISPLAY
0000163E  30D9                    3401          MOVE.W (A1)+,(A0)+
00001640                          3402      ENDW
00001640  60EC                    3403s     BRA _10000016
00001642                          3404s _10000017
00001642                          3405      
00001642  6000 EFA6               3406      BRA MAIN_LOOP
00001646                          3407  
00001646                          3408  X
00001646  45FA 0482               3409      LEA STATUS_REGISTER(PC),A2
0000164A                          3410m     PRINT_STR A2,D3
0000164A                          3411m LOOP_239
0000164A  0C12 0000               3412m     CMP.B #NULL,(A2)                                ; 0 -> DONE
0000164E  6700 0016               3413m     BEQ EXIT_239
00001652                          3414mm     PRINT_CHAR (A2)+,D3
00001652                          3415mm WAIT_FOR_READY_240                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001652                 TRUE     3416mm     IFEQ DEBUG
00001652  1639 00C00003           3417mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001658  0803 0002               3418mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000165C  67F4                    3419mm         BEQ WAIT_FOR_READY_240                      ; NO SPACE, CHECK AGAIN
0000165E  13DA 00C00007           3420mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001664                          3421mm     ENDC
00001664                          3422mm 
00001664                 FALSE    3423mm     IFNE DEBUG
00001664                          3424mm     ENDC
00001664                          3425mm 
00001664                          3426mm     ENDM
00001664  60E4                    3427m     BRA LOOP_239
00001666                          3428m EXIT_239
00001666                          3429m     ENDM
00001666                          3430  
00001666  40C0                    3431      MOVE SR,D0
00001668                          3432m     PRINT_REG D0,D3,D4,D5,A2
00001668  45FA 0453               3433m     LEA OX(PC),A2
0000166C                          3434mm     PRINT_STR A2,D3
0000166C                          3435mm LOOP_242
0000166C  0C12 0000               3436mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001670  6700 0016               3437mm     BEQ EXIT_242
00001674                          3438mmm     PRINT_CHAR (A2)+,D3
00001674                          3439mmm WAIT_FOR_READY_243                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001674                 TRUE     3440mmm     IFEQ DEBUG
00001674  1639 00C00003           3441mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000167A  0803 0002               3442mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000167E  67F4                    3443mmm         BEQ WAIT_FOR_READY_243                      ; NO SPACE, CHECK AGAIN
00001680  13DA 00C00007           3444mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001686                          3445mmm     ENDC
00001686                          3446mmm 
00001686                 FALSE    3447mmm     IFNE DEBUG
00001686                          3448mmm     ENDC
00001686                          3449mmm 
00001686                          3450mmm     ENDM
00001686  60E4                    3451mm     BRA LOOP_242
00001688                          3452mm EXIT_242
00001688                          3453mm     ENDM
00001688  7A07                    3454m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
0000168A                          3455m LOOP_241
0000168A                          3456mm     BIN2HEX D0,D4,A2
0000168A  45FA 03F0               3457mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000168E  E998                    3458mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
00001690  1800                    3459mm     MOVE.B D0,D4
00001692  0284 0000000F           3460mm     ANDI.L #$F,D4
00001698  1832 4000               3461mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
0000169C                          3462mm     ENDM
0000169C                          3463mm     PRINT_CHAR D4,D3
0000169C                          3464mm WAIT_FOR_READY_245                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000169C                 TRUE     3465mm     IFEQ DEBUG
0000169C  1639 00C00003           3466mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016A2  0803 0002               3467mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016A6  67F4                    3468mm         BEQ WAIT_FOR_READY_245                      ; NO SPACE, CHECK AGAIN
000016A8  13C4 00C00007           3469mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
000016AE                          3470mm     ENDC
000016AE                          3471mm 
000016AE                 FALSE    3472mm     IFNE DEBUG
000016AE                          3473mm     ENDC
000016AE                          3474mm 
000016AE                          3475mm     ENDM
000016AE  57CD FFDA               3476m     DBEQ D5,LOOP_241
000016B2                          3477m     ENDM
000016B2                          3478m     PRINT_CRLF D3,A2
000016B2  45FA 0403               3479m     LEA CRLF(PC),A2
000016B6                          3480mm     PRINT_STR A2,D3
000016B6                          3481mm LOOP_247
000016B6  0C12 0000               3482mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016BA  6700 0016               3483mm     BEQ EXIT_247
000016BE                          3484mmm     PRINT_CHAR (A2)+,D3
000016BE                          3485mmm WAIT_FOR_READY_248                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016BE                 TRUE     3486mmm     IFEQ DEBUG
000016BE  1639 00C00003           3487mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016C4  0803 0002               3488mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016C8  67F4                    3489mmm         BEQ WAIT_FOR_READY_248                      ; NO SPACE, CHECK AGAIN
000016CA  13DA 00C00007           3490mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016D0                          3491mmm     ENDC
000016D0                          3492mmm 
000016D0                 FALSE    3493mmm     IFNE DEBUG
000016D0                          3494mmm     ENDC
000016D0                          3495mmm 
000016D0                          3496mmm     ENDM
000016D0  60E4                    3497mm     BRA LOOP_247
000016D2                          3498mm EXIT_247
000016D2                          3499mm     ENDM
000016D2                          3500m     ENDM
000016D2                          3501  
000016D2  45FA 03F1               3502      LEA STACK_POINTER(PC),A2
000016D6                          3503m     PRINT_STR A2,D3
000016D6                          3504m LOOP_249
000016D6  0C12 0000               3505m     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016DA  6700 0016               3506m     BEQ EXIT_249
000016DE                          3507mm     PRINT_CHAR (A2)+,D3
000016DE                          3508mm WAIT_FOR_READY_250                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000016DE                 TRUE     3509mm     IFEQ DEBUG
000016DE  1639 00C00003           3510mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
000016E4  0803 0002               3511mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
000016E8  67F4                    3512mm         BEQ WAIT_FOR_READY_250                      ; NO SPACE, CHECK AGAIN
000016EA  13DA 00C00007           3513mm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000016F0                          3514mm     ENDC
000016F0                          3515mm 
000016F0                 FALSE    3516mm     IFNE DEBUG
000016F0                          3517mm     ENDC
000016F0                          3518mm 
000016F0                          3519mm     ENDM
000016F0  60E4                    3520m     BRA LOOP_249
000016F2                          3521m EXIT_249
000016F2                          3522m     ENDM
000016F2                          3523  
000016F2  200F                    3524      MOVE.L SP,D0
000016F4                          3525m     PRINT_REG D0,D3,D4,D5,A2
000016F4  45FA 03C7               3526m     LEA OX(PC),A2
000016F8                          3527mm     PRINT_STR A2,D3
000016F8                          3528mm LOOP_252
000016F8  0C12 0000               3529mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
000016FC  6700 0016               3530mm     BEQ EXIT_252
00001700                          3531mmm     PRINT_CHAR (A2)+,D3
00001700                          3532mmm WAIT_FOR_READY_253                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001700                 TRUE     3533mmm     IFEQ DEBUG
00001700  1639 00C00003           3534mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001706  0803 0002               3535mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
0000170A  67F4                    3536mmm         BEQ WAIT_FOR_READY_253                      ; NO SPACE, CHECK AGAIN
0000170C  13DA 00C00007           3537mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001712                          3538mmm     ENDC
00001712                          3539mmm 
00001712                 FALSE    3540mmm     IFNE DEBUG
00001712                          3541mmm     ENDC
00001712                          3542mmm 
00001712                          3543mmm     ENDM
00001712  60E4                    3544mm     BRA LOOP_252
00001714                          3545mm EXIT_252
00001714                          3546mm     ENDM
00001714  7A07                    3547m     MOVE.L #7,D5                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001716                          3548m LOOP_251
00001716                          3549mm     BIN2HEX D0,D4,A2
00001716  45FA 0364               3550mm     LEA BIN2HEX_LUT(PC),A2                          ; LOAD THE LOOKUP TABLE
0000171A  E998                    3551mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000171C  1800                    3552mm     MOVE.B D0,D4
0000171E  0284 0000000F           3553mm     ANDI.L #$F,D4
00001724  1832 4000               3554mm     MOVE.B 0(A2,D4),D4                              ; USE THAT AS AN INDEX INTO THE LUT
00001728                          3555mm     ENDM
00001728                          3556mm     PRINT_CHAR D4,D3
00001728                          3557mm WAIT_FOR_READY_255                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001728                 TRUE     3558mm     IFEQ DEBUG
00001728  1639 00C00003           3559mm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
0000172E  0803 0002               3560mm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001732  67F4                    3561mm         BEQ WAIT_FOR_READY_255                      ; NO SPACE, CHECK AGAIN
00001734  13C4 00C00007           3562mm         MOVE.B D4,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000173A                          3563mm     ENDC
0000173A                          3564mm 
0000173A                 FALSE    3565mm     IFNE DEBUG
0000173A                          3566mm     ENDC
0000173A                          3567mm 
0000173A                          3568mm     ENDM
0000173A  57CD FFDA               3569m     DBEQ D5,LOOP_251
0000173E                          3570m     ENDM
0000173E                          3571m     PRINT_CRLF D3,A2
0000173E  45FA 0377               3572m     LEA CRLF(PC),A2
00001742                          3573mm     PRINT_STR A2,D3
00001742                          3574mm LOOP_257
00001742  0C12 0000               3575mm     CMP.B #NULL,(A2)                                ; 0 -> DONE
00001746  6700 0016               3576mm     BEQ EXIT_257
0000174A                          3577mmm     PRINT_CHAR (A2)+,D3
0000174A                          3578mmm WAIT_FOR_READY_258                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000174A                 TRUE     3579mmm     IFEQ DEBUG
0000174A  1639 00C00003           3580mmm         MOVE.B DUART_SRA,D3                         ; READ STATUS REGISTER
00001750  0803 0002               3581mmm         BTST #2,D3                                  ; CHECK FOR SPACE TO SEND
00001754  67F4                    3582mmm         BEQ WAIT_FOR_READY_258                      ; NO SPACE, CHECK AGAIN
00001756  13DA 00C00007           3583mmm         MOVE.B (A2)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000175C                          3584mmm     ENDC
0000175C                          3585mmm 
0000175C                 FALSE    3586mmm     IFNE DEBUG
0000175C                          3587mmm     ENDC
0000175C                          3588mmm 
0000175C                          3589mmm     ENDM
0000175C  60E4                    3590mm     BRA LOOP_257
0000175E                          3591mm EXIT_257
0000175E                          3592mm     ENDM
0000175E                          3593m     ENDM
0000175E                          3594  
0000175E  6000 EE8A               3595      BRA MAIN_LOOP
00001762                          3596  
00001762                          3597          
00001762                          3598  HEX_DIGIT
00001762  E98F                    3599      LSL.L #4,D7                                         ; add the next digit in the next 4 bits
00001764                          3600m     HEX2BIN D2,D2,A0
00001764  41FA 0326               3601m     LEA HEX2BIN_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001768  0402 0030               3602m     SUB.B #'0',D2                                   ; WORK OUT OFFSET AND MASK OFF ANYTHING ROGUE
0000176C  C4BC 000000FF           3603m     AND.L #$FF,D2                                   ; IGNORE THE TOP 3 BYTES
00001772  1430 2000               3604m     MOVE.B 0(A0,D2),D2                              ; USE THAT AS AN INDEX INTO THE LUT   
00001776                          3605m     ENDM
00001776  8E02                    3606      OR.B D2,D7  
00001778  6000 EE90               3607      BRA GET_INPUT
0000177C                          3608  
0000177C  FFFF FFFF               3609      SIMHALT                                             ; halt simulator
00001780                          3610  
00001780                          3611  ; exceptions
00001780                          3612  BUS_ERROR_HANDLER
00001780                          3613  
00001780  41FA 034D               3614      LEA BUS_ERROR(PC),A0
00001784                          3615m     PRINT_STR A0,D1
00001784                          3616m LOOP_260
00001784  0C10 0000               3617m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001788  6700 0016               3618m     BEQ EXIT_260
0000178C                          3619mm     PRINT_CHAR (A0)+,D1
0000178C                          3620mm WAIT_FOR_READY_261                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000178C                 TRUE     3621mm     IFEQ DEBUG
0000178C  1239 00C00003           3622mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
00001792  0801 0002               3623mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00001796  67F4                    3624mm         BEQ WAIT_FOR_READY_261                      ; NO SPACE, CHECK AGAIN
00001798  13D8 00C00007           3625mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000179E                          3626mm     ENDC
0000179E                          3627mm 
0000179E                 FALSE    3628mm     IFNE DEBUG
0000179E                          3629mm     ENDC
0000179E                          3630mm 
0000179E                          3631mm     ENDM
0000179E  60E4                    3632m     BRA LOOP_260
000017A0                          3633m EXIT_260
000017A0                          3634m     ENDM
000017A0                          3635  
000017A0  7000                    3636      MOVE.L #0,D0
000017A2  3017                    3637      MOVE.W (SP),D0
000017A4                          3638  
000017A4  0800 0004               3639      BTST #4,D0
000017A8  6700 0026               3640      BEQ WRITE
000017AC                          3641      
000017AC  41FA 0336               3642      LEA READING(PC),A0
000017B0                          3643m     PRINT_STR A0,D1
000017B0                          3644m LOOP_262
000017B0  0C10 0000               3645m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017B4  6700 0016               3646m     BEQ EXIT_262
000017B8                          3647mm     PRINT_CHAR (A0)+,D1
000017B8                          3648mm WAIT_FOR_READY_263                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017B8                 TRUE     3649mm     IFEQ DEBUG
000017B8  1239 00C00003           3650mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000017BE  0801 0002               3651mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000017C2  67F4                    3652mm         BEQ WAIT_FOR_READY_263                      ; NO SPACE, CHECK AGAIN
000017C4  13D8 00C00007           3653mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017CA                          3654mm     ENDC
000017CA                          3655mm 
000017CA                 FALSE    3656mm     IFNE DEBUG
000017CA                          3657mm     ENDC
000017CA                          3658mm 
000017CA                          3659mm     ENDM
000017CA  60E4                    3660m     BRA LOOP_262
000017CC                          3661m EXIT_262
000017CC                          3662m     ENDM
000017CC                          3663  
000017CC  6000 0022               3664      BRA CONTINUE    
000017D0                          3665  WRITE
000017D0  41FA 031B               3666      LEA WRITING(PC),A0
000017D4                          3667m     PRINT_STR A0,D1
000017D4                          3668m LOOP_264
000017D4  0C10 0000               3669m     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017D8  6700 0016               3670m     BEQ EXIT_264
000017DC                          3671mm     PRINT_CHAR (A0)+,D1
000017DC                          3672mm WAIT_FOR_READY_265                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000017DC                 TRUE     3673mm     IFEQ DEBUG
000017DC  1239 00C00003           3674mm         MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000017E2  0801 0002               3675mm         BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000017E6  67F4                    3676mm         BEQ WAIT_FOR_READY_265                      ; NO SPACE, CHECK AGAIN
000017E8  13D8 00C00007           3677mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000017EE                          3678mm     ENDC
000017EE                          3679mm 
000017EE                 FALSE    3680mm     IFNE DEBUG
000017EE                          3681mm     ENDC
000017EE                          3682mm 
000017EE                          3683mm     ENDM
000017EE  60E4                    3684m     BRA LOOP_264
000017F0                          3685m EXIT_264
000017F0                          3686m     ENDM
000017F0                          3687  
000017F0                          3688  CONTINUE
000017F0  222F 0002               3689      MOVE.L 2(SP),D1
000017F4                          3690m     PRINT_REG D1,D2,D3,D4,A0
000017F4  41FA 02C7               3691m     LEA OX(PC),A0
000017F8                          3692mm     PRINT_STR A0,D2
000017F8                          3693mm LOOP_267
000017F8  0C10 0000               3694mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000017FC  6700 0016               3695mm     BEQ EXIT_267
00001800                          3696mmm     PRINT_CHAR (A0)+,D2
00001800                          3697mmm WAIT_FOR_READY_268                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001800                 TRUE     3698mmm     IFEQ DEBUG
00001800  1439 00C00003           3699mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001806  0802 0002               3700mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000180A  67F4                    3701mmm         BEQ WAIT_FOR_READY_268                      ; NO SPACE, CHECK AGAIN
0000180C  13D8 00C00007           3702mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001812                          3703mmm     ENDC
00001812                          3704mmm 
00001812                 FALSE    3705mmm     IFNE DEBUG
00001812                          3706mmm     ENDC
00001812                          3707mmm 
00001812                          3708mmm     ENDM
00001812  60E4                    3709mm     BRA LOOP_267
00001814                          3710mm EXIT_267
00001814                          3711mm     ENDM
00001814  7807                    3712m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001816                          3713m LOOP_266
00001816                          3714mm     BIN2HEX D1,D3,A0
00001816  41FA 0264               3715mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000181A  E999                    3716mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000181C  1601                    3717mm     MOVE.B D1,D3
0000181E  0283 0000000F           3718mm     ANDI.L #$F,D3
00001824  1630 3000               3719mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001828                          3720mm     ENDM
00001828                          3721mm     PRINT_CHAR D3,D2
00001828                          3722mm WAIT_FOR_READY_270                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001828                 TRUE     3723mm     IFEQ DEBUG
00001828  1439 00C00003           3724mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000182E  0802 0002               3725mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001832  67F4                    3726mm         BEQ WAIT_FOR_READY_270                      ; NO SPACE, CHECK AGAIN
00001834  13C3 00C00007           3727mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000183A                          3728mm     ENDC
0000183A                          3729mm 
0000183A                 FALSE    3730mm     IFNE DEBUG
0000183A                          3731mm     ENDC
0000183A                          3732mm 
0000183A                          3733mm     ENDM
0000183A  57CC FFDA               3734m     DBEQ D4,LOOP_266
0000183E                          3735m     ENDM
0000183E                          3736  
0000183E  41FA 02B6               3737      LEA FROM(PC),A0
00001842                          3738m     PRINT_STR A0,D0
00001842                          3739m LOOP_271
00001842  0C10 0000               3740m     CMP.B #NULL,(A0)                                ; 0 -> DONE
00001846  6700 0016               3741m     BEQ EXIT_271
0000184A                          3742mm     PRINT_CHAR (A0)+,D0
0000184A                          3743mm WAIT_FOR_READY_272                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000184A                 TRUE     3744mm     IFEQ DEBUG
0000184A  1039 00C00003           3745mm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
00001850  0800 0002               3746mm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
00001854  67F4                    3747mm         BEQ WAIT_FOR_READY_272                      ; NO SPACE, CHECK AGAIN
00001856  13D8 00C00007           3748mm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
0000185C                          3749mm     ENDC
0000185C                          3750mm 
0000185C                 FALSE    3751mm     IFNE DEBUG
0000185C                          3752mm     ENDC
0000185C                          3753mm 
0000185C                          3754mm     ENDM
0000185C  60E4                    3755m     BRA LOOP_271
0000185E                          3756m EXIT_271
0000185E                          3757m     ENDM
0000185E                          3758  
0000185E  222F 000A               3759      MOVE.L 10(SP),D1
00001862                          3760m     PRINT_REG D1,D2,D3,D4,A0
00001862  41FA 0259               3761m     LEA OX(PC),A0
00001866                          3762mm     PRINT_STR A0,D2
00001866                          3763mm LOOP_274
00001866  0C10 0000               3764mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000186A  6700 0016               3765mm     BEQ EXIT_274
0000186E                          3766mmm     PRINT_CHAR (A0)+,D2
0000186E                          3767mmm WAIT_FOR_READY_275                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000186E                 TRUE     3768mmm     IFEQ DEBUG
0000186E  1439 00C00003           3769mmm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00001874  0802 0002               3770mmm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
00001878  67F4                    3771mmm         BEQ WAIT_FOR_READY_275                      ; NO SPACE, CHECK AGAIN
0000187A  13D8 00C00007           3772mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00001880                          3773mmm     ENDC
00001880                          3774mmm 
00001880                 FALSE    3775mmm     IFNE DEBUG
00001880                          3776mmm     ENDC
00001880                          3777mmm 
00001880                          3778mmm     ENDM
00001880  60E4                    3779mm     BRA LOOP_274
00001882                          3780mm EXIT_274
00001882                          3781mm     ENDM
00001882  7807                    3782m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00001884                          3783m LOOP_273
00001884                          3784mm     BIN2HEX D1,D3,A0
00001884  41FA 01F6               3785mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
00001888  E999                    3786mm     ROL.L #4,D1                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000188A  1601                    3787mm     MOVE.B D1,D3
0000188C  0283 0000000F           3788mm     ANDI.L #$F,D3
00001892  1630 3000               3789mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
00001896                          3790mm     ENDM
00001896                          3791mm     PRINT_CHAR D3,D2
00001896                          3792mm WAIT_FOR_READY_277                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
00001896                 TRUE     3793mm     IFEQ DEBUG
00001896  1439 00C00003           3794mm         MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
0000189C  0802 0002               3795mm         BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000018A0  67F4                    3796mm         BEQ WAIT_FOR_READY_277                      ; NO SPACE, CHECK AGAIN
000018A2  13C3 00C00007           3797mm         MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000018A8                          3798mm     ENDC
000018A8                          3799mm 
000018A8                 FALSE    3800mm     IFNE DEBUG
000018A8                          3801mm     ENDC
000018A8                          3802mm 
000018A8                          3803mm     ENDM
000018A8  57CC FFDA               3804m     DBEQ D4,LOOP_273
000018AC                          3805m     ENDM
000018AC                          3806m     PRINT_CRLF D0,A0
000018AC  41FA 0209               3807m     LEA CRLF(PC),A0
000018B0                          3808mm     PRINT_STR A0,D0
000018B0                          3809mm LOOP_279
000018B0  0C10 0000               3810mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000018B4  6700 0016               3811mm     BEQ EXIT_279
000018B8                          3812mmm     PRINT_CHAR (A0)+,D0
000018B8                          3813mmm WAIT_FOR_READY_280                                  ; WAIT UNTIL THE THERE IS SPACE TO SEND
000018B8                 TRUE     3814mmm     IFEQ DEBUG
000018B8  1039 00C00003           3815mmm         MOVE.B DUART_SRA,D0                         ; READ STATUS REGISTER
000018BE  0800 0002               3816mmm         BTST #2,D0                                  ; CHECK FOR SPACE TO SEND
000018C2  67F4                    3817mmm         BEQ WAIT_FOR_READY_280                      ; NO SPACE, CHECK AGAIN
000018C4  13D8 00C00007           3818mmm         MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000018CA                          3819mmm     ENDC
000018CA                          3820mmm 
000018CA                 FALSE    3821mmm     IFNE DEBUG
000018CA                          3822mmm     ENDC
000018CA                          3823mmm 
000018CA                          3824mmm     ENDM
000018CA  60E4                    3825mm     BRA LOOP_279
000018CC                          3826mm EXIT_279
000018CC                          3827mm     ENDM
000018CC                          3828m     ENDM
000018CC                          3829      
000018CC  207C 00000004           3830      MOVE.L #4,A0
000018D2  4ED0                    3831      JMP (A0)
000018D4                          3832          
000018D4                          3833  ILLEGAL_HANDLER
000018D4  13FC 0007 00E00001      3834      MOVE.B #7,DISPLAY   
000018DC  207C 00000004           3835      MOVE.L #4,A0
000018E2  4ED0                    3836      JMP (A0)
000018E4                          3837          
000018E4                          3838  UNHANDLED_HANDLER
000018E4  13FC 0008 00E00001      3839      MOVE.B #8,DISPLAY   
000018EC  207C 00000004           3840      MOVE.L #4,A0
000018F2  4ED0                    3841      JMP (A0)
000018F4                          3842  
000018F4                          3843  ; strings
000018F4= 50 72 65 73 73 20 ...   3844  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00001907= 5B 3F 5D 09 09 09 ...   3845  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
00001913= 5B 76 5D 09 09 09 ...   3846          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
00001922= 78 78 78 78 78 78 ...   3847          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
0000193A= 78 78 78 78 78 78 ...   3848          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
0000195A= 78 78 78 78 78 78 ...   3849          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
0000197B= 78 78 78 78 78 78 ...   3850          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
0000198C= 5B 7A 5D 09 09 09 ...   3851          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
0000199E= 78 78 78 78 78 78 ...   3852          DC.B 'xxxxxxxx[l]xxxx',TAB,TAB,'load to EEPROM',CR,LF
000019BF= 78 78 78 78 78 78 ...   3853          DC.B 'xxxxxxxx[p]xxxx',TAB,TAB,'patch EEPROM',CR,LF
000019DE= 78 78 78 78 78 78 ...   3854          DC.B 'xxxxxxxx[m]xxxxxxxx',TAB,'monitor to RAM',CR,LF
00001A02= 5B 78 5D 09 09 09 ...   3855          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF,NULL
00001A1A= 48 75 68 3F 0D 0A 00    3856  HUH  DC.B 'Huh?',CR,LF,NULL
00001A21= 20 53 20 72 65 63 ...   3857  READ    DC.B ' S records read, start address = ',NULL
00001A43= 57 3A 20 55 6E 6B ...   3858  UNREC   DC.B 'W: Unknown Srec type: ',NULL
00001A5A= 21 20 43 53 20 66 ...   3859  CS_FAILURE  DC.B '! CS failure at ',NULL
00001A6B= 21 20 52 41 4D 20 ...   3860  RAM_ERROR   DC.B '! RAM error at: ',NULL
00001A7C= 30 31 32 33 34 35 ...   3861  BIN2HEX_LUT DC.B '0123456789ABCDEF'
00001A8C= 00 01 02 03 04 05 ...   3862  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00001AA3= 4C 6F 61 64 69 6E ...   3863  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00001AB7= 0D 0A 00                3864  CRLF    DC.B CR,LF,NULL
00001ABA= 3E 20 00                3865  PROMPT  DC.B '> ',NULL
00001ABD= 30 78 00                3866  ox      DC.B '0x',NULL
00001AC0= 20 2D 3E 20 00          3867  to      DC.B ' -> ',NULL
00001AC5= 53 50 3A 20 00          3868  STACK_POINTER DC.B 'SP: ',NULL
00001ACA= 53 52 3A 20 00          3869  STATUS_REGISTER DC.B 'SR: ',NULL
00001ACF= 2A 20 42 75 73 2F ...   3870  BUS_ERROR DC.B '* Bus/address error ',NULL
00001AE4= 72 65 61 64 69 6E ...   3871  READING DC.B 'reading ',NULL
00001AED= 77 72 69 74 69 6E ...   3872  WRITING DC.B 'writing ',NULL
00001AF6= 20 66 72 6F 6D 20 00    3873  FROM DC.B ' from ',NULL
00001AFD= 2A 20 55 6E 68 61 ...   3874  UNHANDLED DC.B '* Unhandled exception at ',NULL
00001B17= 4D 44 46 2D 6D 6F ...   3875  VERSION DC.B 'MDF-mon V1.109 (25/04/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00001B35= 00                      3876  END     DC.B 0
00001B36                          3877      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         1A7C
BUS_ERROR           1ACF
BUS_ERROR_HANDLER   1780
CONTINUE            17F0
CONTINUE_113        DC2
CONTINUE_54         89E
CONTINUE_57         8EE
CONTINUE_61         944
CONTINUE_69         9F8
CONTINUE_74         A6A
CONTINUE_79         AE6
CONTINUE_84         B64
CONTINUE_89         BEC
CONTINUE_94         C5E
CONTINUE_99         CD0
CR                  D
CRLF                1AB7
CS_FAILURE          1A5A
DEBUG               0
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            734
DOWNLOAD_BYTE       AA4
DOWNLOAD_DONE       ECC
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 1B35
EXIT_10             556
EXIT_104            D42
EXIT_106            D62
EXIT_110            D94
EXIT_118            E2A
EXIT_120            E52
EXIT_123            E72
EXIT_128            EBC
EXIT_131            EEC
EXIT_135            F36
EXIT_138            F58
EXIT_143            FA2
EXIT_145            101E
EXIT_148            1042
EXIT_15             5A0
EXIT_153            108C
EXIT_160            1118
EXIT_163            1176
EXIT_166            1198
EXIT_17             5C0
EXIT_170            11E2
EXIT_173            1204
EXIT_178            124E
EXIT_184            12C2
EXIT_189            1312
EXIT_194            1366
EXIT_199            13B0
EXIT_20             5E0
EXIT_210            1464
EXIT_213            14B6
EXIT_216            14D6
EXIT_22             60A
EXIT_220            1520
EXIT_223            1542
EXIT_228            158C
EXIT_237            1624
EXIT_239            1666
EXIT_242            1688
EXIT_247            16D2
EXIT_249            16F2
EXIT_252            1714
EXIT_257            175E
EXIT_260            17A0
EXIT_262            17CC
EXIT_264            17F0
EXIT_267            1814
EXIT_271            185E
EXIT_274            1882
EXIT_279            18CC
EXIT_28             69E
EXIT_30             6F6
EXIT_32             722
EXIT_35             74C
EXIT_45             7FA
EXIT_5              50E
EXIT_52             870
EXIT_66             9B4
EXIT_7              52E
FROM                1AF6
G                   FA6
GET_INPUT           60A
H                   6FA
HELP                1907
HELPPROMPT          18F4
HEX2BIN             10B
HEX2BIN_LUT         1A8C
HEX_DIGIT           1762
HUH                 1A1A
ILLEGAL_HANDLER     18D4
L                   109C
LF                  A
LOADING             1AA3
LOOP_10             53A
LOOP_104            D26
LOOP_106            D46
LOOP_110            D78
LOOP_118            E0E
LOOP_120            E36
LOOP_122            E74
LOOP_123            E56
LOOP_128            EA0
LOOP_130            EEE
LOOP_131            ED0
LOOP_135            F1A
LOOP_137            F5A
LOOP_138            F3C
LOOP_143            F86
LOOP_145            1002
LOOP_147            1044
LOOP_148            1026
LOOP_15             584
LOOP_153            1070
LOOP_160            10FC
LOOP_163            115A
LOOP_165            119A
LOOP_166            117C
LOOP_17             5A4
LOOP_170            11C6
LOOP_172            1206
LOOP_173            11E8
LOOP_178            1232
LOOP_183            12C4
LOOP_184            12A6
LOOP_188            1314
LOOP_189            12F6
LOOP_193            1368
LOOP_194            134A
LOOP_199            1394
LOOP_20             5C4
LOOP_210            1448
LOOP_213            149A
LOOP_215            14D8
LOOP_216            14BA
LOOP_22             5EE
LOOP_220            1504
LOOP_222            1544
LOOP_223            1526
LOOP_228            1570
LOOP_237            1608
LOOP_239            164A
LOOP_241            168A
LOOP_242            166C
LOOP_247            16B6
LOOP_249            16D6
LOOP_251            1716
LOOP_252            16F8
LOOP_257            1742
LOOP_260            1784
LOOP_262            17B0
LOOP_264            17D4
LOOP_266            1816
LOOP_267            17F8
LOOP_271            1842
LOOP_273            1884
LOOP_274            1866
LOOP_279            18B0
LOOP_28             682
LOOP_30             6DA
LOOP_32             706
LOOP_34             74E
LOOP_35             730
LOOP_45             7DE
LOOP_5              4F2
LOOP_52             854
LOOP_66             998
LOOP_7              512
LOOP_9              558
M                   15AE
MAIN_LOOP           5EA
NULL                0
OX                  1ABD
P                   13F0
PRINTSTR            706
PRINT_CHAR          203
PRINT_CRLF          3A0
PRINT_REG           438
PRINT_STR           3CB
PROGRAM             C4D
PROGRAM_VECTOR      CE4
PROMPT              1ABA
PROTECT             A40
R                   726
RAM                 200000
RAM_ERROR           1A6B
READ                1A21
READING             1AE4
READ_CHAR           62D
RESET               4
ROM                 0
S                   87A
STACK               0
STACK_POINTER       1AC5
START               400
STATUS_REGISTER     1ACA
TAB                 9
TO                  1AC0
UNHANDLED           1AFD
UNHANDLED_HANDLER   18E4
UNPROTECT           979
UNREC               1A43
USER                100
V                   702
VECS                8
VERSION             1B17
W                   7FE
WAIT_CHAR           4E9
WAIT_FOR_COMPLETE_180  1260
WAIT_FOR_COMPLETE_181  1276
WAIT_FOR_COMPLETE_182  128A
WAIT_FOR_COMPLETE_202  13B4
WAIT_FOR_COMPLETE_203  13C6
WAIT_FOR_COMPLETE_230  158E
WAIT_FOR_READY_1    4AA
WAIT_FOR_READY_101  CE8
WAIT_FOR_READY_105  D2E
WAIT_FOR_READY_107  D4E
WAIT_FOR_READY_108  D62
WAIT_FOR_READY_11   542
WAIT_FOR_READY_111  D80
WAIT_FOR_READY_113  DA6
WAIT_FOR_READY_115  DDA
WAIT_FOR_READY_119  E16
WAIT_FOR_READY_121  E3E
WAIT_FOR_READY_124  E5E
WAIT_FOR_READY_126  E86
WAIT_FOR_READY_129  EA8
WAIT_FOR_READY_13   56A
WAIT_FOR_READY_132  ED8
WAIT_FOR_READY_134  F00
WAIT_FOR_READY_136  F22
WAIT_FOR_READY_139  F44
WAIT_FOR_READY_141  F6C
WAIT_FOR_READY_144  F8E
WAIT_FOR_READY_146  100A
WAIT_FOR_READY_149  102E
WAIT_FOR_READY_151  1056
WAIT_FOR_READY_154  1078
WAIT_FOR_READY_155  10AA
WAIT_FOR_READY_157  10C4
WAIT_FOR_READY_16   58C
WAIT_FOR_READY_161  1104
WAIT_FOR_READY_164  1162
WAIT_FOR_READY_167  1184
WAIT_FOR_READY_169  11AC
WAIT_FOR_READY_171  11CE
WAIT_FOR_READY_174  11F0
WAIT_FOR_READY_176  1218
WAIT_FOR_READY_179  123A
WAIT_FOR_READY_18   5AC
WAIT_FOR_READY_185  12AE
WAIT_FOR_READY_187  12D6
WAIT_FOR_READY_190  12FE
WAIT_FOR_READY_192  1326
WAIT_FOR_READY_195  1352
WAIT_FOR_READY_197  137A
WAIT_FOR_READY_2    4BE
WAIT_FOR_READY_200  139C
WAIT_FOR_READY_205  13FC
WAIT_FOR_READY_207  1416
WAIT_FOR_READY_21   5CC
WAIT_FOR_READY_211  1450
WAIT_FOR_READY_214  14A2
WAIT_FOR_READY_217  14C2
WAIT_FOR_READY_219  14EA
WAIT_FOR_READY_221  150C
WAIT_FOR_READY_224  152E
WAIT_FOR_READY_226  1556
WAIT_FOR_READY_229  1578
WAIT_FOR_READY_23   5F6
WAIT_FOR_READY_232  15BC
WAIT_FOR_READY_234  15D6
WAIT_FOR_READY_238  1610
WAIT_FOR_READY_24   60A
WAIT_FOR_READY_240  1652
WAIT_FOR_READY_243  1674
WAIT_FOR_READY_245  169C
WAIT_FOR_READY_248  16BE
WAIT_FOR_READY_250  16DE
WAIT_FOR_READY_253  1700
WAIT_FOR_READY_255  1728
WAIT_FOR_READY_258  174A
WAIT_FOR_READY_26   624
WAIT_FOR_READY_261  178C
WAIT_FOR_READY_263  17B8
WAIT_FOR_READY_265  17DC
WAIT_FOR_READY_268  1800
WAIT_FOR_READY_270  1828
WAIT_FOR_READY_272  184A
WAIT_FOR_READY_275  186E
WAIT_FOR_READY_277  1896
WAIT_FOR_READY_280  18B8
WAIT_FOR_READY_29   68A
WAIT_FOR_READY_3    4D2
WAIT_FOR_READY_31   6E2
WAIT_FOR_READY_33   70E
WAIT_FOR_READY_36   738
WAIT_FOR_READY_38   760
WAIT_FOR_READY_39   776
WAIT_FOR_READY_40   78C
WAIT_FOR_READY_41   7A0
WAIT_FOR_READY_42   7B4
WAIT_FOR_READY_43   7C8
WAIT_FOR_READY_46   7E6
WAIT_FOR_READY_47   808
WAIT_FOR_READY_49   822
WAIT_FOR_READY_53   85C
WAIT_FOR_READY_54   882
WAIT_FOR_READY_56   8BC
WAIT_FOR_READY_57   8D2
WAIT_FOR_READY_59   906
WAIT_FOR_READY_6    4FA
WAIT_FOR_READY_61   928
WAIT_FOR_READY_63   95C
WAIT_FOR_READY_67   9A0
WAIT_FOR_READY_69   9DC
WAIT_FOR_READY_71   A10
WAIT_FOR_READY_74   A4E
WAIT_FOR_READY_76   A82
WAIT_FOR_READY_79   ACA
WAIT_FOR_READY_8    51A
WAIT_FOR_READY_81   AFE
WAIT_FOR_READY_84   B48
WAIT_FOR_READY_86   B7C
WAIT_FOR_READY_89   BD0
WAIT_FOR_READY_91   C04
WAIT_FOR_READY_94   C42
WAIT_FOR_READY_96   C76
WAIT_FOR_READY_99   CB4
WAIT_FOR_SRECORD    882
WRITE               17D0
WRITING             1AED
X                   1646
Z                   FAC
_00000000           64A
_00000001           65E
_00000002           9BC
_00000003           D98
_00000004           9CA
_00000005           BB8
_00000006           B2E
_00000007           D98
_00000008           D22
_00000009           D98
_0000000A           EC0
_0000000B           ECC
_0000000C           108C
_0000000D           126A
_0000000E           1284
_0000000F           1298
_00000010           13BE
_00000011           13D0
_00000012           1598
_10000000           91E
_10000001           986
_10000002           9D2
_10000003           A3A
_10000004           A44
_10000005           AAC
_10000006           AC0
_10000007           B28
_10000008           B32
_10000009           BB2
_1000000A           B3E
_1000000B           BA6
_1000000C           BC6
_1000000D           C2E
_1000000E           C38
_1000000F           CA0
_10000010           CAA
_10000011           D12
_10000012           D9C
_10000013           E04
_10000014           124E
_10000015           1270
_10000016           162E
_10000017           1642
_20000000           426
_20000001           432
_20000002           440
_20000003           44C
_20000004           806
_20000005           84A
_20000006           FBE
_20000007           FCE
_20000008           FE8
_20000009           108E
_2000000A           10A8
_2000000B           10EC
_2000000C           12A0
_2000000D           13D2
_2000000E           13FA
_2000000F           143E
_20000010           15BA
_20000011           15FE
