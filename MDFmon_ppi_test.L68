00000104 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 28/09/2021 12:02:01

00000000                             1  *------------------------------------------------------------
00000000                             2  * Title         MDFmon 
00000000                             3  * Written by    Mark Flitter
00000000                             4  * Date          March 2021
00000000                             5  * Description:  68000 monitor 
00000000                             6  
00000000                             7  *-----------------------------------------------------------
00000000                             8  
00000000                             9  ; constants
00000000  =00000000                 10  NULL                EQU 0
00000000  =00000009                 11  TAB                 EQU 9
00000000  =0000000D                 12  CR                  EQU 13
00000000  =0000000A                 13  LF                  EQU 10
00000000                            14  
00000000  =00000000                 15  ROM                 EQU $0
00000000  =002E0000                 16  STACK_ADDRESS       EQU $2E0000
00000000                            17  
00000000  =00A00000                 18  MC68230_BASE        EQU $A00000
00000000  =00000000                 19  MC68230_GENERAL_CONTROL_    EQU $0
00000000  =00000001                 20  MC68230_SERVICE_REQUEST_    EQU $1
00000000  =00000002                 21  MC68230_PORT_A_DIRECTION_   EQU $2
00000000  =00000003                 22  MC68230_PORT_B_DIRECTION_   EQU $3
00000000  =00000004                 23  MC68230_PORT_C_DIRECTION_   EQU $4
00000000  =00000005                 24  MC68230_INTERRUPT_VECTOR_   EQU $5
00000000  =00000006                 25  MC68230_PORT_A_CONTROL_     EQU $6
00000000  =00000007                 26  MC68230_PORT_B_CONTROL_     EQU $7
00000000  =00000008                 27  MC68230_PORT_A_DATA_        EQU $8
00000000  =00000009                 28  MC68230_PORT_B_DATA_        EQU $9
00000000  =0000000A                 29  MC68230_PORT_A_ALTERNATE_   EQU $A
00000000  =0000000B                 30  MC68230_PORT_B_ALTERNATE_   EQU $B
00000000  =0000000C                 31  MC68230_PORT_C_DATA_        EQU $C
00000000  =0000000D                 32  MC68230_STATUS_             EQU $D
00000000                            33  
00000000  =00A00001                 34  MC68230_GENERAL_CONTROL     EQU MC68230_BASE+2*MC68230_GENERAL_CONTROL_+1
00000000  =00A00003                 35  MC68230_SERVICE_REQUEST     EQU MC68230_BASE+2*MC68230_SERVICE_REQUEST_+1
00000000  =00A00005                 36  MC68230_PORT_A_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_A_DIRECTION_+1
00000000  =00A00007                 37  MC68230_PORT_B_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_B_DIRECTION_+1
00000000  =00A00009                 38  MC68230_PORT_C_DIRECTION    EQU MC68230_BASE+2*MC68230_PORT_C_DIRECTION_+1
00000000  =00000000                 39  MC68230_PORT_DIRECTION_READ EQU 0
00000000  =000000FF                 40  MC68230_PORT_DIRECTION_WRITE EQU $FF
00000000                            41  
00000000  =00A0000B                 42  MC68230_INTERRUPT_VECTOR    EQU MC68230_BASE+2*MC68230_INTERRUPT_VECTOR_+1
00000000  =00A0000D                 43  MC68230_PORT_A_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_A_CONTROL_+1
00000000  =00A0000F                 44  MC68230_PORT_B_CONTROL      EQU MC68230_BASE+2*MC68230_PORT_B_CONTROL_+1
00000000  =00A00011                 45  MC68230_PORT_A_DATA         EQU MC68230_BASE+2*MC68230_PORT_A_DATA_+1
00000000  =00A00013                 46  MC68230_PORT_B_DATA         EQU MC68230_BASE+2*MC68230_PORT_B_DATA_+1
00000000  =00A00015                 47  MC68230_PORT_A_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_A_ALTERNATE_+1
00000000  =00A00017                 48  MC68230_PORT_B_ALTERNATE    EQU MC68230_BASE+2*MC68230_PORT_B_ALTERNATE_+1
00000000  =00A00019                 49  MC68230_PORT_C_DATA         EQU MC68230_BASE+2*MC68230_PORT_C_DATA_+1
00000000  =00000020                 50  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 51  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 52  MC68230_PORT_C_CS           EQU $08
00000000  =00A0001B                 53  MC68230_STATUS              EQU MC68230_BASE+2*MC68230_STATUS_+1
00000000                            54  
00000000  =00000020                 55  MC68230_PORT_C_READ         EQU $20
00000000  =00000010                 56  MC68230_PORT_C_WRITE        EQU $10
00000000  =00000008                 57  MC68230_PORT_C_CS           EQU $08
00000000                            58  
00000000  =00000000                 59  IDE_DATA_REGISTER           EQU 0
00000000  =00000002                 60  IDE_SECTOR_COUNT_REGISTER   EQU 2
00000000  =00000003                 61  IDE_LBA_0_7_REGISTER        EQU 3
00000000  =00000004                 62  IDE_LBA_8_15_REGISTER       EQU 4
00000000  =00000005                 63  IDE_LBA_16_23_REGISTER      EQU 5
00000000  =00000006                 64  IDE_DRIVESEL_REGISTER       EQU 6
00000000  =000000E0                 65  IDE_DRIVESEL_MASTER         EQU $E0
00000000                            66  
00000000  =00000007                 67  IDE_COMMAND_REGISTER        EQU 7
00000000  =00000020                 68  IDE_COMMAND_READ_WITH_RETRY         EQU $20
00000000                            69  
00000000  =00000007                 70  IDE_STATUS_REGISTER         EQU 7
00000000  =00000007                 71  IDE_STATUS_BUSY             EQU 7
00000000  =00000006                 72  IDE_STATUS_READY            EQU 6
00000000  =00000003                 73  IDE_STATUS_DRQ              EQU 3
00000000                            74  
00000000  =00C00000                 75  DUART_BASE          EQU $C00000
00000000  =00000000                 76  DUART_MRA_          EQU $0
00000000  =00000001                 77  DUART_CSRA_         EQU $1
00000000  =00000001                 78  DUART_SRA_          EQU $1
00000000  =00000002                 79  DUART_CRA_          EQU $2
00000000  =00000003                 80  DUART_TXA_          EQU $3
00000000  =00000003                 81  DUART_RXA_          EQU $3
00000000  =00000004                 82  DUART_ACR_          EQU $4
00000000  =00000005                 83  DUART_IMR_          EQU $5
00000000  =00000006                 84  DUART_CTUR_         EQU $6
00000000  =00000007                 85  DUART_CTLR_         EQU $7
00000000  =00000008                 86  DUART_MRB_          EQU $8
00000000  =00000009                 87  DUART_CSRB_         EQU $9
00000000  =00000009                 88  DUART_SRB_          EQU $9
00000000  =0000000A                 89  DUART_CRB_          EQU $A
00000000  =0000000B                 90  DUART_TXB_          EQU $B
00000000  =0000000B                 91  DUART_RXB_          EQU $B
00000000  =0000000C                 92  DUART_IVR_          EQU $C
00000000  =0000000D                 93  DUART_OPCR_         EQU $D
00000000  =0000000E                 94  DUART_SET_OPR_      EQU $E
00000000  =0000000F                 95  DUART_RESET_OPR_    EQU $F
00000000                            96  
00000000  =00C00001                 97  DUART_MRA           EQU DUART_BASE+2*DUART_MRA_+1
00000000  =00C00003                 98  DUART_SRA           EQU DUART_BASE+2*DUART_SRA_+1
00000000  =00C00003                 99  DUART_CSRA          EQU DUART_BASE+2*DUART_CSRA_+1
00000000  =00C00005                100  DUART_CRA           EQU DUART_BASE+2*DUART_CRA_+1
00000000  =00C00007                101  DUART_TXA           EQU DUART_BASE+2*DUART_TXA_+1
00000000  =00C00007                102  DUART_RXA           EQU DUART_BASE+2*DUART_RXA_+1
00000000                           103  
00000000  =00C00011                104  DUART_MRB           EQU DUART_BASE+2*DUART_MRB_+1
00000000  =00C00013                105  DUART_SRB           EQU DUART_BASE+2*DUART_SRB_+1
00000000  =00C00013                106  DUART_CSRB          EQU DUART_BASE+2*DUART_CSRB_+1
00000000  =00C00015                107  DUART_CRB           EQU DUART_BASE+2*DUART_CRB_+1
00000000  =00C00017                108  DUART_TXB           EQU DUART_BASE+2*DUART_TXB_+1
00000000  =00C00017                109  DUART_RXB           EQU DUART_BASE+2*DUART_RXB_+1
00000000                           110  
00000000  =00C00009                111  DUART_ACR           EQU DUART_BASE+2*DUART_ACR_+1
00000000  =00C0000B                112  DUART_IMR           EQU DUART_BASE+2*DUART_IMR_+1
00000000  =00C0000D                113  DUART_CTUR          EQU DUART_BASE+2*DUART_CTUR_+1
00000000  =00C0000F                114  DUART_CTLR          EQU DUART_BASE+2*DUART_CTLR_+1
00000000  =00C00019                115  DUART_IVR           EQU DUART_BASE+2*DUART_IVR_+1
00000000  =00C0001B                116  DUART_OPCR          EQU DUART_BASE+2*DUART_OPCR_+1
00000000  =00C0001D                117  DUART_SET_OPR       EQU DUART_BASE+2*DUART_SET_OPR_+1
00000000  =00C0001F                118  DUART_RESET_OPR     EQU DUART_BASE+2*DUART_RESET_OPR_+1
00000000                           119  
00000000  =00E00000                120  DISPLAY_BASE        EQU $E00000
00000000  =00000000                121  DISPLAY_            EQU $0
00000000  =00E00001                122  DISPLAY             EQU DISPLAY_BASE+2*DISPLAY_+1
00000000                           123  
00000000                           124  ; macros
00000000                           125  ; convert top 4 bits of input register from binary to a single hex digit
00000000                           126  ; the input register is changed during the process
00000000                           127  ; \1 input data register containing binary number, \2 data register for return value, \3 working address register
00000000                           128  BIN2HEX MACRO
00000000                           129      LEA BIN2HEX_LUT(PC),\3                          ; load the lookup table
00000000                           130      ROL.L #4,\1                                     ; shift the top 4 bits down to bottom of the register the and mask off everything else
00000000                           131      MOVE.B \1,\2
00000000                           132      ANDI.L #$F,\2
00000000                           133      MOVE.B 0(\3,\2),\2                              ; use that as an index into the LUT
00000000                           134      ENDM
00000000                           135  
00000000                           136  ; convert single hex digit to 4 bit binary number in LSbits
00000000                           137  ; the input register is changed during the process
00000000                           138  ; \1 data register containing hex character, \2 data register for return value, \3 working address register
00000000                           139  HEX2BIN MACRO
00000000                           140      LEA HEX2BIN_LUT(PC),\3                          ; load the lookup table
00000000                           141      SUB.B #'0',\1                                   ; work out offset and mask off anything rogue
00000000                           142      AND.L #$FF,\1                                   ; ignore the top 3 bytes
00000000                           143      MOVE.B 0(\3,\1),\2                              ; use that as an index into the LUT   
00000000                           144      ENDM
00000000                           145  
00000000                           146  ; send a single char to the serial port
00000000                           147  ; \1 = char to send, \2 = data register to use for status poll
00000000                           148  ; will stamp on D0 and D1 in debug mode
00000000                           149  PRINT_CHAR MACRO
00000000                           150  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           151      MOVE.B DUART_SRA,\2                         ; read status register
00000000                           152      BTST #2,\2                                  ; check for space to send
00000000                           153      BEQ WAIT_FOR_READY\@                        ; no space, check again
00000000                           154      MOVE.B \1,DUART_TXA                         ; send the next character
00000000                           155  
00000000                           156      ENDM
00000000                           157  
00000000                           158  ; send CR,LF to the serial port
00000000                           159  ; \1 = data register to use for status poll, /2 = working address register
00000000                           160  PRINT_CRLF MACRO
00000000                           161      LEA CRLF(PC),\2
00000000                           162      PRINT_STR \2,\1
00000000                           163      ENDM
00000000                           164  
00000000                           165  ; send C-style, zero terminated string to the serial port
00000000                           166  ; \1 = address register containing address of zero terminated string, \2 = data register to use for status poll, 
00000000                           167  PRINT_STR MACRO
00000000                           168  LOOP\@
00000000                           169      CMP.B #NULL,(\1)                                ; 0 -> done
00000000                           170      BEQ EXIT\@
00000000                           171      PRINT_CHAR (\1)+,\2
00000000                           172      BRA LOOP\@
00000000                           173  EXIT\@
00000000                           174      ENDM
00000000                           175    
00000000                           176  ; send the contents of a data register to the serial port as a 1 digit hex number
00000000                           177  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 working address register
00000000                           178  PRINT_REG_4BIT MACRO
00000000                           179      LEA BIN2HEX_LUT(PC),\4                          ; load the lookup table
00000000                           180      MOVE.B \1,\3
00000000                           181      ANDI.L #$F,\3
00000000                           182      MOVE.B 0(\4,\3),\3                              ; use that as an index into the LUT
00000000                           183      PRINT_CHAR \3,\2
00000000                           184      ENDM
00000000                           185  
00000000                           186  ; send the contents of a data register to the serial port as a 8 digit hex number
00000000                           187  ; \1 = data register containing binary number, \2 = data register to use for status poll, \3 working data register, \4 counter register, \5 working address register
00000000                           188  PRINT_REG MACRO
00000000                           189      LEA ox(PC),\5
00000000                           190      PRINT_STR \5,\2
00000000                           191      MOVE.L #7,\4                                    ; loop round all 8 hex characters of 4 bits each
00000000                           192  LOOP\@
00000000                           193      BIN2HEX \1,\3,\5
00000000                           194      PRINT_CHAR \3,\2
00000000                           195      DBEQ \4,LOOP\@
00000000                           196      ENDM
00000000                           197  
00000000                           198  ; wait for a char from the serial port
00000000                           199  ; \ 1= data register for read char, \2 = register to use for status poll
00000000                           200  ; will stamp on D0 and D1 in debug mode
00000000                           201  WAIT_CHAR MACRO
00000000                           202  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           203      MOVE.B DUART_SRA,\2                         ; read status register
00000000                           204      BTST #0,\2                                  ; check for character
00000000                           205      BEQ WAIT_FOR_READY\@                        ; nothing, check again
00000000                           206  
00000000                           207      READ_CHAR \1
00000000                           208  
00000000                           209      PRINT_CHAR \1,\2                            ; echo it back
00000000                           210      ENDM
00000000                           211  
00000000                           212  ; read a char from the serial port - assumes that there is one!
00000000                           213  ; \ 1= data register for read char
00000000                           214  ; will stamp on D0 and D1 in debug mode
00000000                           215  READ_CHAR MACRO
00000000                           216      MOVE.B DUART_RXA,\1                         ; got a character, read it
00000000                           217  
00000000                           218      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           219      BEQ START
00000000                           220      ENDM
00000000                           221  
00000000                           222  
00000000                           223  ; read data from the download serial port
00000000                           224  ; \ 1= data register for read char
00000000                           225  DOWNLOAD MACRO
00000000                           226  WAIT_FOR_READY\@                                    ; wait until the there is space to send
00000000                           227  
00000000                           228      MOVE.B DUART_SRA,\1                             ; read download status register
00000000                           229      BTST #0,\1                                      ; check for character
00000000                           230      BEQ WAIT_FOR_READY\@                            ; nothing, check again
00000000                           231      
00000000                           232      MOVE.B DUART_RXA,\1                             ; got a character, read it
00000000                           233      
00000000                           234      CMP.B #$1B,\1                                   ; check for escape and go to start
00000000                           235      BEQ START
00000000                           236  
00000000                           237      MOVE.B \1,DISPLAY                               ; echo to the display
00000000                           238  
00000000                           239      ENDM
00000000                           240  
00000000                           241  ; read an ide register
00000000                           242  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           243  READ_8 MACRO
00000000                           244      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           245      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           246      ORI.B \1, \3
00000000                           247      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           248      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           249      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           250      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           251      ORI.B #MC68230_PORT_C_READ, \3
00000000                           252      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           253      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           254      ENDM
00000000                           255      
00000000                           256  ; write an ide register
00000000                           257  ; \1 = value to write, \2 = register to write, \3 = working data register 
00000000                           258  WRITE_8 MACRO
00000000                           259      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000000                           260      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3
00000000                           261      ORI.B \2, \3
00000000                           262      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           263      ANDI.B #~MC68230_PORT_C_WRITE, \3
00000000                           264      MOVE.B \1, MC68230_PORT_B_DATA
00000000                           265      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           266      ORI.B #MC68230_PORT_C_WRITE, \3
00000000                           267      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           268      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           269      ENDM
00000000                           270  
00000000                           271  ; read ide data
00000000                           272  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           273  READ_16 MACRO
00000000                           274      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_B_DIRECTION
00000000                           275      MOVE.B #MC68230_PORT_DIRECTION_READ, MC68230_PORT_A_DIRECTION
00000000                           276      
00000000                           277      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE), \3    
00000000                           278      ORI.B \1, \3
00000000                           279      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           280      ANDI.B #~MC68230_PORT_C_READ, \3
00000000                           281      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           282      MOVE.B MC68230_PORT_A_DATA, \2
00000000                           283      LSL.W #8, \2
00000000                           284      MOVE.B MC68230_PORT_B_DATA, \2
00000000                           285      ORI.B #MC68230_PORT_C_READ, \3
00000000                           286      MOVE.B \3, MC68230_PORT_C_DATA
00000000                           287      MOVE.B #(MC68230_PORT_C_READ | MC68230_PORT_C_WRITE | MC68230_PORT_C_CS), MC68230_PORT_C_DATA
00000000                           288      ENDM
00000000                           289      
00000000                           290  ; read ide data
00000000                           291  ; \1 = register to read, \2 = data register for result, \3 = working data register 
00000000                           292  READ_32 MACRO
00000000                           293      READ_16 \1, \2, \3
00000000                           294      LSL.L #8, \2
00000000                           295      LSL.L #8, \2
00000000                           296      READ_16 \1, \2, \3
00000000                           297      ENDM
00000000                           298          
00000000                           299  ; read ide status
00000000                           300  ;\1 = data register for result, \2 = working data register 
00000000                           301  READ_IDE_STATUS MACRO   
00000000                           302      READ_8 #IDE_STATUS_REGISTER, \1, \2
00000000                           303      ENDM
00000000                           304      
00000000                           305  ; wait for ide drive to be ready
00000000                           306  ;\1 = working data register 1, \2 = working data register 2
00000000                           307  WAIT_DRIVE_READY MACRO
00000000                           308  LOOP\@
00000000                           309      READ_IDE_STATUS \1, \2
00000000                           310      BTST #IDE_STATUS_READY, \1
00000000                           311      BEQ LOOP\@
00000000                           312      ENDM
00000000                           313      
00000000                           314  ; wait for ide drive to be not busy
00000000                           315  ;\1 = working data register 1, \2 = working data register 2
00000000                           316  WAIT_DRIVE_NOT_BUSY MACRO
00000000                           317  LOOP\@
00000000                           318      READ_IDE_STATUS \1, \2
00000000                           319      BTST #IDE_STATUS_BUSY, \1
00000000                           320      BNE LOOP\@
00000000                           321      ENDM
00000000                           322      
00000000                           323  ; wait for ide drive to have data for us
00000000                           324  ;\1 = working data register 1, \2 = working data register 2
00000000                           325  WAIT_DRIVE_DRQ MACRO
00000000                           326  LOOP\@
00000000                           327      READ_IDE_STATUS \1, \2
00000000                           328      BTST #IDE_STATUS_DRQ, \1
00000000                           329      BEQ LOOP\@
00000000                           330      ENDM
00000000                           331      
00000000                           332  ; prepare to send a read command
00000000                           333  ; \1 = block number, \2 = working data register 1, /3 = working data register 2, /4 = working data register 3
00000000                           334  SET_READ_ADDRESS MACRO
00000000                           335      WRITE_8 #1, #IDE_SECTOR_COUNT_REGISTER, \2
00000000                           336      MOVE.L \1,\3
00000000                           337      WRITE_8 \3, #IDE_LBA_0_7_REGISTER, \2
00000000                           338      LSR.L #8, \3
00000000                           339      WRITE_8 \3, #IDE_LBA_8_15_REGISTER, \2
00000000                           340      LSR.L #8, \3                                
00000000                           341      WRITE_8 \3, #IDE_LBA_16_23_REGISTER, \2
00000000                           342      LSR.L #8, \3
00000000                           343      READ_8 #IDE_DRIVESEL_REGISTER, \4, \2
00000000                           344      ANDI.B #$0F,\3
00000000                           345      OR.B \3,\4
00000000                           346      WRITE_8 \4, #IDE_DRIVESEL_REGISTER, \2
00000000                           347      ENDM
00000000                           348  
00000000                           349  ; send command
00000000                           350  ; \1 = command, \2 = working data register 1,
00000000                           351  SEND_COMMAND MACRO
00000000                           352      WRITE_8 \1, #IDE_COMMAND_REGISTER, \2
00000000                           353      ENDM
00000000                           354      
00000000                           355  ; send read command and wait
00000000                           356  ; \1 = block to read, \2 = working data register 1, \2 = working data register 2, \2 = working data register 3
00000000                           357  SEND_READ_COMMAND_AND_WAIT MACRO
00000000                           358      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           359      SET_READ_ADDRESS \1, \2, \3, \4
00000000                           360      SEND_COMMAND #IDE_COMMAND_READ_WITH_RETRY, \2
00000000                           361      WAIT_DRIVE_NOT_BUSY \2, \3
00000000                           362      WAIT_DRIVE_DRQ \2, \3
00000000                           363      ENDM
00000000                           364  
00000000                           365  ; register catalogue
00000000                           366  ; D0 - used for simulator I/O
00000000                           367  ; D1 - used for simulator I/O
00000000                           368  ; D2 - read character
00000000                           369  ; D3 - serial port status poll / task for TRAP in simulator
00000000                           370  ; D6 - working register used in R/W
00000000                           371  ; D7 - address accumulator, reset by download
00000000                           372  ; A0 - address of string to print 
00000000                           373  
00000000                           374  ; start vector
00000000= 002E0000                 375  STACK   DC.L STACK_ADDRESS                      ; STACK
00000004= 00000104                 376  RESET   DC.L START                              ; RESET
00000008= 00000104                 377  VECS    DC.L UNHANDLED_HANDLER                  ; BUS ERROR
0000000C= 00000104                 378          DC.L UNHANDLED_HANDLER                  ; ADDRESS ERROR
00000010= 00000104                 379          DC.L UNHANDLED_HANDLER                  ; ILLEGAL INSTRUCTION
00000014= 00000104                 380          DC.L UNHANDLED_HANDLER
00000018= 00000104                 381          DC.L UNHANDLED_HANDLER
0000001C= 00000104                 382          DC.L UNHANDLED_HANDLER
00000020= 00000104                 383          DC.L UNHANDLED_HANDLER
00000024= 00000104                 384          DC.L UNHANDLED_HANDLER
00000028= 00000104                 385          DC.L UNHANDLED_HANDLER
0000002C= 00000104                 386          DC.L UNHANDLED_HANDLER
00000030= 00000104                 387          DC.L UNHANDLED_HANDLER
00000034= 00000104                 388          DC.L UNHANDLED_HANDLER
00000038= 00000104                 389          DC.L UNHANDLED_HANDLER
0000003C= 00000104                 390          DC.L UNHANDLED_HANDLER
00000040= 00000104                 391          DC.L UNHANDLED_HANDLER
00000044= 00000104                 392          DC.L UNHANDLED_HANDLER
00000048= 00000104                 393          DC.L UNHANDLED_HANDLER
0000004C= 00000104                 394          DC.L UNHANDLED_HANDLER
00000050= 00000104                 395          DC.L UNHANDLED_HANDLER
00000054= 00000104                 396          DC.L UNHANDLED_HANDLER
00000058= 00000104                 397          DC.L UNHANDLED_HANDLER
0000005C= 00000104                 398          DC.L UNHANDLED_HANDLER
00000060= 00000104                 399          DC.L UNHANDLED_HANDLER
00000064= 00000104                 400          DC.L UNHANDLED_HANDLER
00000068= 00000104                 401          DC.L UNHANDLED_HANDLER
0000006C= 00000104                 402          DC.L UNHANDLED_HANDLER
00000070= 00000104                 403          DC.L UNHANDLED_HANDLER
00000074= 00000104                 404          DC.L UNHANDLED_HANDLER
00000078= 00000104                 405          DC.L UNHANDLED_HANDLER
0000007C= 00000104                 406          DC.L UNHANDLED_HANDLER
00000080= 00000104                 407          DC.L UNHANDLED_HANDLER
00000084= 00000104                 408          DC.L UNHANDLED_HANDLER
00000088= 00000104                 409          DC.L UNHANDLED_HANDLER
0000008C= 00000104                 410          DC.L UNHANDLED_HANDLER
00000090= 00000104                 411          DC.L UNHANDLED_HANDLER
00000094= 00000104                 412          DC.L UNHANDLED_HANDLER
00000098= 00000104                 413          DC.L UNHANDLED_HANDLER
0000009C= 00000104                 414          DC.L UNHANDLED_HANDLER
000000A0= 00000104                 415          DC.L UNHANDLED_HANDLER
000000A4= 00000104                 416          DC.L UNHANDLED_HANDLER
000000A8= 00000104                 417          DC.L UNHANDLED_HANDLER
000000AC= 00000104                 418          DC.L UNHANDLED_HANDLER
000000B0= 00000104                 419          DC.L UNHANDLED_HANDLER
000000B4= 00000104                 420          DC.L UNHANDLED_HANDLER
000000B8= 00000104                 421          DC.L UNHANDLED_HANDLER
000000BC= 00000104                 422          DC.L UNHANDLED_HANDLER
000000C0= 00000104                 423          DC.L UNHANDLED_HANDLER
000000C4= 00000104                 424          DC.L UNHANDLED_HANDLER
000000C8= 00000104                 425          DC.L UNHANDLED_HANDLER
000000CC= 00000104                 426          DC.L UNHANDLED_HANDLER
000000D0= 00000104                 427          DC.L UNHANDLED_HANDLER
000000D4= 00000104                 428          DC.L UNHANDLED_HANDLER
000000D8= 00000104                 429          DC.L UNHANDLED_HANDLER 
000000DC= 00000104                 430          DC.L UNHANDLED_HANDLER
000000E0= 00000104                 431          DC.L UNHANDLED_HANDLER
000000E4= 00000104                 432          DC.L UNHANDLED_HANDLER 
000000E8= 00000104                 433          DC.L UNHANDLED_HANDLER 
000000EC= 00000104                 434          DC.L UNHANDLED_HANDLER
000000F0= 00000104                 435          DC.L UNHANDLED_HANDLER 
000000F4= 00000104                 436          DC.L UNHANDLED_HANDLER 
000000F8= 00000104                 437          DC.L UNHANDLED_HANDLER 
000000FC= 00000104                 438          DC.L UNHANDLED_HANDLER
00000100= 00000104                 439          DC.L UNHANDLED_HANDLER
00000104                           440  ; start of program
00000104                           441  UNHANDLED_HANDLER     
00000104                           442  START
00000104  2E7C 002E0000            443      MOVE.L #STACK_ADDRESS,A7
0000010A  13FC 0000 00E00001       444      MOVE.B #0,DISPLAY
00000112                           445  
00000112  7000                     446      MOVE.L #0,D0
00000114  1039 00C00019            447      MOVE.B DUART_IVR,D0                             ; warm start?
0000011A                           448  
0000011A                           449  ; reset the UART in case of warm start
0000011A  13FC 000A 00C00005       450      MOVE.B #$A,DUART_CRA                            ; disable rx & tx
00000122  13FC 000A 00C00015       451      MOVE.B #$A,DUART_CRB                            ; disable rx & tx
0000012A                           452      
0000012A                           453      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
0000012A  323C 0050                454s     MOVE.W  #$50,D1
0000012E  6000 000E                455s     BRA _20000001
00000132                           456s _20000000
00000132  13C1 00C00005            457          MOVE.B D1,DUART_CRA                         ; reset everyting
00000138  4E71                     458          NOP
0000013A                           459      ENDF
0000013A  0441 0010                460s     SUB.W   #$10,D1
0000013E                           461s _20000001
0000013E  B27C 0010                462s     CMP.W   #$10,D1
00000142  6CEE                     463s     BGE _20000000
00000144                           464  
00000144                           465      FOR D1 = #$50 DOWNTO #$10 BY #$10 DO
00000144  323C 0050                466s     MOVE.W  #$50,D1
00000148  6000 000E                467s     BRA _20000003
0000014C                           468s _20000002
0000014C  13C1 00C00015            469          MOVE.B D1,DUART_CRB                         ; reset everyting
00000152  4E71                     470          NOP
00000154                           471      ENDF
00000154  0441 0010                472s     SUB.W   #$10,D1
00000158                           473s _20000003
00000158  B27C 0010                474s     CMP.W   #$10,D1
0000015C  6CEE                     475s     BGE _20000002
0000015E                           476      
0000015E                           477  ;initialise UART
0000015E  13FC 0000 00C0000B       478      MOVE.B #$0,DUART_IMR                            ; no interrupts, please
00000166  13FC 00FF 00C0000D       479      MOVE.B #$FF,DUART_CTUR
0000016E  13FC 00FF 00C0000F       480      MOVE.B #$FF,DUART_CTLR
00000176  13FC 0070 00C00009       481      MOVE.B #$70,DUART_ACR
0000017E  13FC 0004 00C0001B       482      MOVE.B #$4,DUART_OPCR                           ; enable counter
00000186                           483  
00000186                           484  ; channel A
00000186  13FC 0013 00C00001       485      MOVE.B #$13,DUART_MRA                           ; no flow control, no parity, 8 data bits
0000018E  13FC 0007 00C00001       486      MOVE.B #$07,DUART_MRA                           ; 1 stop bit
00000196  13FC 0066 00C00003       487      MOVE.B #$66,DUART_CSRA                          ; 115K  baud
0000019E  13FC 0005 00C00005       488      MOVE.B #$5,DUART_CRA                            ; enable rx & tx
000001A6                           489  
000001A6                           490  ; channel B
000001A6  13FC 0013 00C00011       491      MOVE.B #$13,DUART_MRB                           ; no flow control, no parity, 8 data bits
000001AE  13FC 0007 00C00011       492      MOVE.B #$07,DUART_MRB                           ; 1 stop bit
000001B6  13FC 0066 00C00013       493      MOVE.B #$66,DUART_CSRB                          ; 115K baud
000001BE  13FC 0005 00C00015       494      MOVE.B #$5,DUART_CRB                            ; enable rx & tx
000001C6  13FC 0040 00C00019       495      MOVE.B #64,DUART_IVR
000001CE                           496  
000001CE                           497m     PRINT_CHAR #0,D1                                ; some non-printing char to flush out the serial port
000001CE                           498m WAIT_FOR_READY_1                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001CE  1239 00C00003            499m     MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001D4  0801 0002                500m     BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001D8  67F4                     501m     BEQ WAIT_FOR_READY_1                        ; NO SPACE, CHECK AGAIN
000001DA  13FC 0000 00C00007       502m     MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001E2                           503m 
000001E2                           504m     ENDM
000001E2                           505m     PRINT_CHAR #0,D1
000001E2                           506m WAIT_FOR_READY_2                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001E2  1239 00C00003            507m     MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001E8  0801 0002                508m     BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
000001EC  67F4                     509m     BEQ WAIT_FOR_READY_2                        ; NO SPACE, CHECK AGAIN
000001EE  13FC 0000 00C00007       510m     MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
000001F6                           511m 
000001F6                           512m     ENDM
000001F6                           513m     PRINT_CHAR #0,D1
000001F6                           514m WAIT_FOR_READY_3                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
000001F6  1239 00C00003            515m     MOVE.B DUART_SRA,D1                         ; READ STATUS REGISTER
000001FC  0801 0002                516m     BTST #2,D1                                  ; CHECK FOR SPACE TO SEND
00000200  67F4                     517m     BEQ WAIT_FOR_READY_3                        ; NO SPACE, CHECK AGAIN
00000202  13FC 0000 00C00007       518m     MOVE.B #0,DUART_TXA                         ; SEND THE NEXT CHARACTER
0000020A                           519m 
0000020A                           520m     ENDM
0000020A                           521      
0000020A                           522      IF D0 <EQ> #$0F THEN
0000020A  B07C 000F                523s     CMP.W   #$0F,D0
0000020E  6600 0008                524s     BNE _00000000
00000212  1039 00C00005            525          MOVE.B DUART_CRA,D0                         ; BRG test mode
00000218                           526      ENDI
00000218                           527s _00000000
00000218                           528  
00000218  13FC 0001 00E00001       529      MOVE.B #1,DISPLAY
00000220                           530  
00000220  13FC 0002 00E00001       531      MOVE.B #2,DISPLAY
00000228                           532      
00000228  13FC 0000 00A00001       533      MOVE.B #$0, MC68230_GENERAL_CONTROL             ; set up the MC68230
00000230  13FC 0040 00A0000D       534      MOVE.B #$40, MC68230_PORT_A_CONTROL
00000238  13FC 0040 00A0000F       535      MOVE.B #$40, MC68230_PORT_B_CONTROL
00000240  13FC 00FF 00A00005       536      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_A_DIRECTION
00000248  13FC 00FF 00A00007       537      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_B_DIRECTION
00000250  13FC 00FF 00A00009       538      MOVE.B #MC68230_PORT_DIRECTION_WRITE, MC68230_PORT_C_DIRECTION
00000258                           539      
00000258  13FC 0003 00E00001       540      MOVE.B #3,DISPLAY
00000260                           541      
00000260                           542  MAIN_LOOP
00000260                           543      FOR.L D0 = #0 TO #$FF DO
00000260  7000                     544s     MOVE.L  #0,D0
00000262  6000 009E                545s     BRA _20000005
00000266                           546s _20000004
00000266                           547m         PRINT_REG D0,D2,D3,D4,A0
00000266  41FA 02D3                548m     LEA OX(PC),A0
0000026A                           549mm     PRINT_STR A0,D2
0000026A                           550mm LOOP_5
0000026A  0C10 0000                551mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
0000026E  6700 0016                552mm     BEQ EXIT_5
00000272                           553mmm     PRINT_CHAR (A0)+,D2
00000272                           554mmm WAIT_FOR_READY_6                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
00000272  1439 00C00003            555mmm     MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
00000278  0802 0002                556mmm     BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
0000027C  67F4                     557mmm     BEQ WAIT_FOR_READY_6                        ; NO SPACE, CHECK AGAIN
0000027E  13D8 00C00007            558mmm     MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
00000284                           559mmm 
00000284                           560mmm     ENDM
00000284  60E4                     561mm     BRA LOOP_5
00000286                           562mm EXIT_5
00000286                           563mm     ENDM
00000286  7807                     564m     MOVE.L #7,D4                                    ; LOOP ROUND ALL 8 HEX CHARACTERS OF 4 BITS EACH
00000288                           565m LOOP_4
00000288                           566mm     BIN2HEX D0,D3,A0
00000288  41FA 0270                567mm     LEA BIN2HEX_LUT(PC),A0                          ; LOAD THE LOOKUP TABLE
0000028C  E998                     568mm     ROL.L #4,D0                                     ; SHIFT THE TOP 4 BITS DOWN TO BOTTOM OF THE REGISTER THE AND MASK OFF EVERYTHING ELSE
0000028E  1600                     569mm     MOVE.B D0,D3
00000290  0283 0000000F            570mm     ANDI.L #$F,D3
00000296  1630 3000                571mm     MOVE.B 0(A0,D3),D3                              ; USE THAT AS AN INDEX INTO THE LUT
0000029A                           572mm     ENDM
0000029A                           573mm     PRINT_CHAR D3,D2
0000029A                           574mm WAIT_FOR_READY_8                                    ; WAIT UNTIL THE THERE IS SPACE TO SEND
0000029A  1439 00C00003            575mm     MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000002A0  0802 0002                576mm     BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000002A4  67F4                     577mm     BEQ WAIT_FOR_READY_8                        ; NO SPACE, CHECK AGAIN
000002A6  13C3 00C00007            578mm     MOVE.B D3,DUART_TXA                         ; SEND THE NEXT CHARACTER
000002AC                           579mm 
000002AC                           580mm     ENDM
000002AC  57CC FFDA                581m     DBEQ D4,LOOP_4
000002B0                           582m     ENDM
000002B0                           583m         PRINT_CRLF D2,A0
000002B0  41FA 0283                584m     LEA CRLF(PC),A0
000002B4                           585mm     PRINT_STR A0,D2
000002B4                           586mm LOOP_10
000002B4  0C10 0000                587mm     CMP.B #NULL,(A0)                                ; 0 -> DONE
000002B8  6700 0016                588mm     BEQ EXIT_10
000002BC                           589mmm     PRINT_CHAR (A0)+,D2
000002BC                           590mmm WAIT_FOR_READY_11                                   ; WAIT UNTIL THE THERE IS SPACE TO SEND
000002BC  1439 00C00003            591mmm     MOVE.B DUART_SRA,D2                         ; READ STATUS REGISTER
000002C2  0802 0002                592mmm     BTST #2,D2                                  ; CHECK FOR SPACE TO SEND
000002C6  67F4                     593mmm     BEQ WAIT_FOR_READY_11                       ; NO SPACE, CHECK AGAIN
000002C8  13D8 00C00007            594mmm     MOVE.B (A0)+,DUART_TXA                          ; SEND THE NEXT CHARACTER
000002CE                           595mmm 
000002CE                           596mmm     ENDM
000002CE  60E4                     597mm     BRA LOOP_10
000002D0                           598mm EXIT_10
000002D0                           599mm     ENDM
000002D0                           600m     ENDM
000002D0                           601  
000002D0  13C0 00E00001            602          MOVE.B D0,DISPLAY
000002D6                           603  
000002D6  13C0 00A00011            604          MOVE.B D0, MC68230_PORT_A_DATA
000002DC  13C0 00A00013            605          MOVE.B D0, MC68230_PORT_B_DATA
000002E2  13C0 00A00019            606          MOVE.B D0, MC68230_PORT_C_DATA
000002E8                           607  
000002E8                           608          FOR.L D1 = #0 TO #$FFFF DO
000002E8  7200                     609s     MOVE.L  #0,D1
000002EA  6000 000C                610s     BRA _20000007
000002EE                           611s _20000006
000002EE  7400                     612              MOVE.L #0,D2
000002F0  7400                     613              MOVE.L #0,D2
000002F2  7400                     614              MOVE.L #0,D2
000002F4  7400                     615              MOVE.L #0,D2
000002F6                           616          ENDF
000002F6  5281                     617s     ADD.L   #1,D1
000002F8                           618s _20000007
000002F8  B2BC 0000FFFF            619s     CMP.L   #$FFFF,D1
000002FE  6FEE                     620s     BLE _20000006
00000300                           621  
00000300                           622      ENDF
00000300  5280                     623s     ADD.L   #1,D0
00000302                           624s _20000005
00000302  B0BC 000000FF            625s     CMP.L   #$FF,D0
00000308  6F00 FF5C                626s     BLE _20000004
0000030C                           627      
0000030C  4EFA FDF6                628      JMP START(PC)
00000310                           629  ; strings
00000310= 50 72 65 73 73 20 ...    630  HELPPROMPT DC.B 'Press ? for help',CR,LF,NULL
00000323= 5B 3F 5D 09 09 09 ...    631  HELP    DC.B '[?]',TAB,TAB,TAB,'help',CR,LF
0000032F= 5B 76 5D 09 09 09 ...    632          DC.B '[v]',TAB,TAB,TAB,'version',CR,LF
0000033E= 78 78 78 78 78 78 ...    633          DC.B 'xxxxxxxx[r]',TAB,TAB,'read long',CR,LF
00000356= 78 78 78 78 78 78 ...    634          DC.B 'xxxxxxxx[w]xxxxxxxx',TAB,'write long',CR,LF
00000376= 78 78 78 78 78 78 ...    635          DC.B 'xxxxxxxx[s]',TAB,TAB,'download S records',CR,LF
00000397= 78 78 78 78 78 78 ...    636          DC.B 'xxxxxxxx[g]',TAB,TAB,'go',CR,LF
000003A8= 5B 7A 5D 09 09 09 ...    637          DC.B '[z]',TAB,TAB,TAB,'zap memory',CR,LF
000003BA= 78 78 78 78 78 78 ...    638          DC.B 'xxxxxxxx[l]xxxxxxxx',TAB,'load to EEPROM',CR,LF
000003DE= 78 78 78 78 78 78 ...    639          DC.B 'xxxxxxxx[p]xxxxxxxx',TAB,'patch EEPROM',CR,LF
00000400= 23 09 09 09 77 72 ...    640          DC.B '#',TAB,TAB,TAB,'write protect EEPROM',CR,LF
0000041A= 5B 78 5D 09 09 09 ...    641          DC.B '[x]',TAB,TAB,TAB,'print registers',CR,LF
00000431= 5B 49 5D 09 09 09 ...    642          DC.B '[I]',TAB,TAB,TAB,'enable interrupts',CR,LF
0000044A= 5B 6F 5D 09 09 09 ...    643          DC.B '[o]',TAB,TAB,TAB,'disable interrupts',CR,LF
00000464= 5B 69 5D 09 09 09 ...    644          DC.B '[i]',TAB,TAB,TAB,'index the disk',CR,LF
0000047A= 78 78 78 78 78 78 ...    645          DC.B 'xxxxxxxx[b]',TAB,TAB,'boot from disk',CR,LF,NULL
00000498= 48 75 68 3F 0D 0A 00     646  HUH  DC.B 'Huh?',CR,LF,NULL
0000049F= 20 53 20 72 65 63 ...    647  READ    DC.B ' S records read, start address = ',NULL
000004C1= 57 3A 20 55 6E 6B ...    648  UNREC   DC.B 'W: Unknown Srec type: ',NULL
000004D8= 21 20 43 53 20 66 ...    649  CS_FAILURE  DC.B '! CS failure at ',NULL
000004E9= 21 20 52 41 4D 20 ...    650  RAM_ERROR   DC.B '! RAM error at: ',NULL
000004FA= 30 31 32 33 34 35 ...    651  BIN2HEX_LUT DC.B '0123456789ABCDEF'
0000050A= 00 01 02 03 04 05 ...    652  HEX2BIN_LUT DC.B 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,$A,$B,$C,$D,$E,$F
00000521= 4C 6F 61 64 69 6E ...    653  LOADING DC.B 'Loading EEPROM...',CR,LF,NULL
00000535= 0D 0A 00                 654  CRLF    DC.B CR,LF,NULL
00000538= 3E 20 00                 655  PROMPT  DC.B '> ',NULL
0000053B= 30 78 00                 656  ox      DC.B '0x',NULL
0000053E= 20 2D 3E 20 00           657  to      DC.B ' -> ',NULL
00000543= 20 66 6F 72 20 00        658  for     DC.B ' for ',NULL
00000549= 53 50 3A 20 00           659  STACK_POINTER DC.B 'SP: ',NULL
0000054E= 53 52 3A 20 00           660  STATUS_REGISTER DC.B 'SR: ',NULL
00000553= 20 3A 20 00              661  INDEX_SEP DC.B ' : ',NULL
00000557= 42 6F 6F 74 69 6E ...    662  BOOT DC.B 'Booting',NULL
0000055F= 4E 6F 74 20 66 6F ...    663  NOT_FOUND DC.B 'Not found',CR,LF,NULL
0000056B= 74 69 63 6B 0D 0A 00     664  TICK DC.B 'tick',CR,LF,NULL
00000572= 2A 20 42 75 73 2F ...    665  BUS_ERROR DC.B '* Bus/address error ',NULL
00000587= 72 65 61 64 69 6E ...    666  READING DC.B 'reading ',NULL
00000590= 77 72 69 74 69 6E ...    667  WRITING DC.B 'writing ',NULL
00000599= 20 66 72 6F 6D 20 00     668  FROM DC.B ' from ',NULL
000005A0= 2A 20 55 6E 68 61 ...    669  UNHANDLED DC.B '* Unhandled interrupt',NULL
000005B6= 2A 20 55 6E 69 74 ...    670  UNINITIALISED DC.B '* Unitialised interrupt vector',NULL
000005D5= 2A 20 53 70 75 72 ...    671  SPURIOUS DC.B '* Spurious interrupt',NULL
000005EA= 4D 44 46 2D 6D 6F ...    672  VERSION DC.B 'MDF-mon V1.149 (01/06/2021)',CR,LF,NULL   ; this is the last line on purpose, so if it prints, we can be sure we got it all
00000608= 00                       673  END     DC.B 0
00000609                           674      END START                                           ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BIN2HEX             0
BIN2HEX_LUT         4FA
BOOT                557
BUS_ERROR           572
CR                  D
CRLF                535
CS_FAILURE          4D8
DISPLAY             E00001
DISPLAY_            0
DISPLAY_BASE        E00000
DOWNLOAD            6B2
DUART_ACR           C00009
DUART_ACR_          4
DUART_BASE          C00000
DUART_CRA           C00005
DUART_CRA_          2
DUART_CRB           C00015
DUART_CRB_          A
DUART_CSRA          C00003
DUART_CSRA_         1
DUART_CSRB          C00013
DUART_CSRB_         9
DUART_CTLR          C0000F
DUART_CTLR_         7
DUART_CTUR          C0000D
DUART_CTUR_         6
DUART_IMR           C0000B
DUART_IMR_          5
DUART_IVR           C00019
DUART_IVR_          C
DUART_MRA           C00001
DUART_MRA_          0
DUART_MRB           C00011
DUART_MRB_          8
DUART_OPCR          C0001B
DUART_OPCR_         D
DUART_RESET_OPR     C0001F
DUART_RESET_OPR_    F
DUART_RXA           C00007
DUART_RXA_          3
DUART_RXB           C00017
DUART_RXB_          B
DUART_SET_OPR       C0001D
DUART_SET_OPR_      E
DUART_SRA           C00003
DUART_SRA_          1
DUART_SRB           C00013
DUART_SRB_          9
DUART_TXA           C00007
DUART_TXA_          3
DUART_TXB           C00017
DUART_TXB_          B
END                 608
EXIT_10             2D0
EXIT_5              286
FOR                 543
FROM                599
HELP                323
HELPPROMPT          310
HEX2BIN             10B
HEX2BIN_LUT         50A
HUH                 498
IDE_COMMAND_READ_WITH_RETRY  20
IDE_COMMAND_REGISTER  7
IDE_DATA_REGISTER   0
IDE_DRIVESEL_MASTER  E0
IDE_DRIVESEL_REGISTER  6
IDE_LBA_0_7_REGISTER  3
IDE_LBA_16_23_REGISTER  5
IDE_LBA_8_15_REGISTER  4
IDE_SECTOR_COUNT_REGISTER  2
IDE_STATUS_BUSY     7
IDE_STATUS_DRQ      3
IDE_STATUS_READY    6
IDE_STATUS_REGISTER  7
INDEX_SEP           553
LF                  A
LOADING             521
LOOP_10             2B4
LOOP_4              288
LOOP_5              26A
MAIN_LOOP           260
MC68230_BASE        A00000
MC68230_GENERAL_CONTROL  A00001
MC68230_GENERAL_CONTROL_  0
MC68230_INTERRUPT_VECTOR  A0000B
MC68230_INTERRUPT_VECTOR_  5
MC68230_PORT_A_ALTERNATE  A00015
MC68230_PORT_A_ALTERNATE_  A
MC68230_PORT_A_CONTROL  A0000D
MC68230_PORT_A_CONTROL_  6
MC68230_PORT_A_DATA  A00011
MC68230_PORT_A_DATA_  8
MC68230_PORT_A_DIRECTION  A00005
MC68230_PORT_A_DIRECTION_  2
MC68230_PORT_B_ALTERNATE  A00017
MC68230_PORT_B_ALTERNATE_  B
MC68230_PORT_B_CONTROL  A0000F
MC68230_PORT_B_CONTROL_  7
MC68230_PORT_B_DATA  A00013
MC68230_PORT_B_DATA_  9
MC68230_PORT_B_DIRECTION  A00007
MC68230_PORT_B_DIRECTION_  3
MC68230_PORT_C_CS   8
MC68230_PORT_C_DATA  A00019
MC68230_PORT_C_DATA_  C
MC68230_PORT_C_DIRECTION  A00009
MC68230_PORT_C_DIRECTION_  4
MC68230_PORT_C_READ  20
MC68230_PORT_C_WRITE  10
MC68230_PORT_DIRECTION_READ  0
MC68230_PORT_DIRECTION_WRITE  FF
MC68230_SERVICE_REQUEST  A00003
MC68230_SERVICE_REQUEST_  1
MC68230_STATUS      A0001B
MC68230_STATUS_     D
NOT_FOUND           55F
NULL                0
OX                  53B
PRINT_CHAR          203
PRINT_CRLF          31A
PRINT_REG           462
PRINT_REG_4BIT      3B2
PRINT_STR           345
PROMPT              538
RAM_ERROR           4E9
READ                49F
READING             587
READ_16             BC9
READ_32             DF6
READ_8              854
READ_CHAR           62B
READ_IDE_STATUS     E45
RESET               4
ROM                 0
SEND_COMMAND        10C7
SEND_READ_COMMAND_AND_WAIT  10F6
SET_READ_ADDRESS    F65
SPURIOUS            5D5
STACK               0
STACK_ADDRESS       2E0000
STACK_POINTER       549
START               104
STATUS_REGISTER     54E
TAB                 9
TICK                56B
TO                  53E
UNHANDLED           5A0
UNHANDLED_HANDLER   104
UNINITIALISED       5B6
UNREC               4C1
VECS                8
VERSION             5EA
WAIT_CHAR           513
WAIT_DRIVE_DRQ      F15
WAIT_DRIVE_NOT_BUSY  EC4
WAIT_DRIVE_READY    E72
WAIT_FOR_READY_1    1CE
WAIT_FOR_READY_11   2BC
WAIT_FOR_READY_2    1E2
WAIT_FOR_READY_3    1F6
WAIT_FOR_READY_6    272
WAIT_FOR_READY_8    29A
WRITE_8             A0D
WRITING             590
_00000000           218
_20000000           132
_20000001           13E
_20000002           14C
_20000003           158
_20000004           266
_20000005           302
_20000006           2EE
_20000007           2F8
